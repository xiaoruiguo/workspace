TEXT runtime.memhash0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memhash0(p unsafe.Pointer, h uintptr) uintptr {
  0x401000		488b442410		MOVQ 0x10(SP), AX	
	return h
  0x401005		4889442418		MOVQ AX, 0x18(SP)	
  0x40100a		c3			RET			

TEXT runtime.memhash8(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memhash8(p unsafe.Pointer, h uintptr) uintptr {
  0x401010		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401019		483b6110		CMPQ 0x10(CX), SP	
  0x40101d		7643			JBE 0x401062		
  0x40101f		4883ec28		SUBQ $0x28, SP		
  0x401023		48896c2420		MOVQ BP, 0x20(SP)	
  0x401028		488d6c2420		LEAQ 0x20(SP), BP	
  0x40102d		488b442430		MOVQ 0x30(SP), AX	
	return memhash(p, h, 1)
  0x401032		48890424		MOVQ AX, 0(SP)		
func memhash8(p unsafe.Pointer, h uintptr) uintptr {
  0x401036		488b442438		MOVQ 0x38(SP), AX	
	return memhash(p, h, 1)
  0x40103b		4889442408		MOVQ AX, 0x8(SP)		
  0x401040		48c744241001000000	MOVQ $0x1, 0x10(SP)		
  0x401049		e8c24a0000		CALL runtime.memhash(SB)	
  0x40104e		488b442418		MOVQ 0x18(SP), AX		
  0x401053		4889442440		MOVQ AX, 0x40(SP)		
  0x401058		488b6c2420		MOVQ 0x20(SP), BP		
  0x40105d		4883c428		ADDQ $0x28, SP			
  0x401061		c3			RET				
func memhash8(p unsafe.Pointer, h uintptr) uintptr {
  0x401062		e809350400		CALL runtime.morestack_noctxt(SB)	
  0x401067		eba7			JMP runtime.memhash8(SB)		

TEXT runtime.memhash16(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memhash16(p unsafe.Pointer, h uintptr) uintptr {
  0x401070		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401079		483b6110		CMPQ 0x10(CX), SP	
  0x40107d		7643			JBE 0x4010c2		
  0x40107f		4883ec28		SUBQ $0x28, SP		
  0x401083		48896c2420		MOVQ BP, 0x20(SP)	
  0x401088		488d6c2420		LEAQ 0x20(SP), BP	
  0x40108d		488b442430		MOVQ 0x30(SP), AX	
	return memhash(p, h, 2)
  0x401092		48890424		MOVQ AX, 0(SP)		
func memhash16(p unsafe.Pointer, h uintptr) uintptr {
  0x401096		488b442438		MOVQ 0x38(SP), AX	
	return memhash(p, h, 2)
  0x40109b		4889442408		MOVQ AX, 0x8(SP)		
  0x4010a0		48c744241002000000	MOVQ $0x2, 0x10(SP)		
  0x4010a9		e8624a0000		CALL runtime.memhash(SB)	
  0x4010ae		488b442418		MOVQ 0x18(SP), AX		
  0x4010b3		4889442440		MOVQ AX, 0x40(SP)		
  0x4010b8		488b6c2420		MOVQ 0x20(SP), BP		
  0x4010bd		4883c428		ADDQ $0x28, SP			
  0x4010c1		c3			RET				
func memhash16(p unsafe.Pointer, h uintptr) uintptr {
  0x4010c2		e8a9340400		CALL runtime.morestack_noctxt(SB)	
  0x4010c7		eba7			JMP runtime.memhash16(SB)		

TEXT runtime.memhash128(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memhash128(p unsafe.Pointer, h uintptr) uintptr {
  0x4010d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4010d9		483b6110		CMPQ 0x10(CX), SP	
  0x4010dd		7643			JBE 0x401122		
  0x4010df		4883ec28		SUBQ $0x28, SP		
  0x4010e3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4010e8		488d6c2420		LEAQ 0x20(SP), BP	
  0x4010ed		488b442430		MOVQ 0x30(SP), AX	
	return memhash(p, h, 16)
  0x4010f2		48890424		MOVQ AX, 0(SP)		
func memhash128(p unsafe.Pointer, h uintptr) uintptr {
  0x4010f6		488b442438		MOVQ 0x38(SP), AX	
	return memhash(p, h, 16)
  0x4010fb		4889442408		MOVQ AX, 0x8(SP)		
  0x401100		48c744241010000000	MOVQ $0x10, 0x10(SP)		
  0x401109		e8024a0000		CALL runtime.memhash(SB)	
  0x40110e		488b442418		MOVQ 0x18(SP), AX		
  0x401113		4889442440		MOVQ AX, 0x40(SP)		
  0x401118		488b6c2420		MOVQ 0x20(SP), BP		
  0x40111d		4883c428		ADDQ $0x28, SP			
  0x401121		c3			RET				
func memhash128(p unsafe.Pointer, h uintptr) uintptr {
  0x401122		e849340400		CALL runtime.morestack_noctxt(SB)	
  0x401127		eba7			JMP runtime.memhash128(SB)		

TEXT runtime.memhash_varlen(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memhash_varlen(p unsafe.Pointer, h uintptr) uintptr {
  0x401130		4883ec28		SUBQ $0x28, SP		
  0x401134		48896c2420		MOVQ BP, 0x20(SP)	
  0x401139		488d6c2420		LEAQ 0x20(SP), BP	
	size := *(*uintptr)(unsafe.Pointer(ptr + unsafe.Sizeof(h)))
  0x40113e		488d4208		LEAQ 0x8(DX), AX	
  0x401142		488b00			MOVQ 0(AX), AX		
  0x401145		488b4c2430		MOVQ 0x30(SP), CX	
	return memhash(p, h, size)
  0x40114a		48890c24		MOVQ CX, 0(SP)		
func memhash_varlen(p unsafe.Pointer, h uintptr) uintptr {
  0x40114e		488b4c2438		MOVQ 0x38(SP), CX	
	return memhash(p, h, size)
  0x401153		48894c2408		MOVQ CX, 0x8(SP)		
  0x401158		4889442410		MOVQ AX, 0x10(SP)		
  0x40115d		e8ae490000		CALL runtime.memhash(SB)	
  0x401162		488b442418		MOVQ 0x18(SP), AX		
  0x401167		4889442440		MOVQ AX, 0x40(SP)		
  0x40116c		488b6c2420		MOVQ 0x20(SP), BP		
  0x401171		4883c428		ADDQ $0x28, SP			
  0x401175		c3			RET				

TEXT runtime.strhash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func strhash(a unsafe.Pointer, h uintptr) uintptr {
  0x401180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401189		483b6110		CMPQ 0x10(CX), SP	
  0x40118d		7646			JBE 0x4011d5		
  0x40118f		4883ec28		SUBQ $0x28, SP		
  0x401193		48896c2420		MOVQ BP, 0x20(SP)	
  0x401198		488d6c2420		LEAQ 0x20(SP), BP	
  0x40119d		488b442430		MOVQ 0x30(SP), AX	
	return memhash(x.str, h, uintptr(x.len))
  0x4011a2		488b08			MOVQ 0(AX), CX		
  0x4011a5		488b4008		MOVQ 0x8(AX), AX	
  0x4011a9		4889442410		MOVQ AX, 0x10(SP)	
  0x4011ae		48890c24		MOVQ CX, 0(SP)		
func strhash(a unsafe.Pointer, h uintptr) uintptr {
  0x4011b2		488b442438		MOVQ 0x38(SP), AX	
	return memhash(x.str, h, uintptr(x.len))
  0x4011b7		4889442408		MOVQ AX, 0x8(SP)		
  0x4011bc		e84f490000		CALL runtime.memhash(SB)	
  0x4011c1		488b442418		MOVQ 0x18(SP), AX		
  0x4011c6		4889442440		MOVQ AX, 0x40(SP)		
  0x4011cb		488b6c2420		MOVQ 0x20(SP), BP		
  0x4011d0		4883c428		ADDQ $0x28, SP			
  0x4011d4		c3			RET				
func strhash(a unsafe.Pointer, h uintptr) uintptr {
  0x4011d5		e896330400		CALL runtime.morestack_noctxt(SB)	
  0x4011da		eba4			JMP runtime.strhash(SB)			

TEXT runtime.f32hash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func f32hash(p unsafe.Pointer, h uintptr) uintptr {
  0x4011e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4011e9		483b6110		CMPQ 0x10(CX), SP	
  0x4011ed		0f86fc000000		JBE 0x4012ef		
  0x4011f3		4883ec28		SUBQ $0x28, SP		
  0x4011f7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4011fc		488d6c2420		LEAQ 0x20(SP), BP	
  0x401201		488b442430		MOVQ 0x30(SP), AX	
	f := *(*float32)(p)
  0x401206		f30f1000		MOVSS 0(AX), X0		
	case f == 0:
  0x40120a		0f57c9			XORPS X1, X1		
  0x40120d		0f2ec1			UCOMISS X1, X0		
  0x401210		7506			JNE 0x401218		
  0x401212		0f8ba8000000		JNP 0x4012c0		
	case f != f:
  0x401218		0f2ec0			UCOMISS X0, X0		
  0x40121b		7502			JNE 0x40121f		
  0x40121d		7b71			JNP 0x401290		
	mp := getg().m
  0x40121f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x401228		488b4030		MOVQ 0x30(AX), AX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40122c		8b8820010000		MOVL 0x120(AX), CX	
  0x401232		8b9024010000		MOVL 0x124(AX), DX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x401238		899020010000		MOVL DX, 0x120(AX)	
  0x40123e		89cb			MOVL CX, BX		
	s1 ^= s1 << 17
  0x401240		c1e111			SHLL $0x11, CX		
  0x401243		31cb			XORL CX, BX		
  0x401245		89d1			MOVL DX, CX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x401247		31da			XORL BX, DX		
  0x401249		c1eb07			SHRL $0x7, BX		
  0x40124c		31d3			XORL DX, BX		
  0x40124e		89ca			MOVL CX, DX		
  0x401250		c1e910			SHRL $0x10, CX		
  0x401253		31d9			XORL BX, CX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x401255		898824010000		MOVL CX, 0x124(AX)	
	return s0 + s1
  0x40125b		8d040a			LEAL 0(DX)(CX*1), AX	
  0x40125e		488b4c2438		MOVQ 0x38(SP), CX	
		return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN
  0x401263		4831c8			XORQ CX, AX			
  0x401266		48b921a6566aa16e7500	MOVQ $0x756ea16a56a621, CX	
  0x401270		4831c1			XORQ AX, CX			
  0x401273		48b8bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, AX	
  0x40127d		480fafc8		IMULQ AX, CX			
  0x401281		48894c2440		MOVQ CX, 0x40(SP)		
  0x401286		488b6c2420		MOVQ 0x20(SP), BP		
  0x40128b		4883c428		ADDQ $0x28, SP			
  0x40128f		c3			RET				
		return memhash(p, h, 4)
  0x401290		48890424		MOVQ AX, 0(SP)			
  0x401294		488b442438		MOVQ 0x38(SP), AX		
  0x401299		4889442408		MOVQ AX, 0x8(SP)		
  0x40129e		48c744241004000000	MOVQ $0x4, 0x10(SP)		
  0x4012a7		e864480000		CALL runtime.memhash(SB)	
  0x4012ac		488b442418		MOVQ 0x18(SP), AX		
  0x4012b1		4889442440		MOVQ AX, 0x40(SP)		
  0x4012b6		488b6c2420		MOVQ 0x20(SP), BP		
  0x4012bb		4883c428		ADDQ $0x28, SP			
  0x4012bf		c3			RET				
		return c1 * (c0 ^ h) // +0, -0
  0x4012c0		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x4012ca		488b4c2438		MOVQ 0x38(SP), CX		
  0x4012cf		4831c8			XORQ CX, AX			
  0x4012d2		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x4012dc		480fafc1		IMULQ CX, AX			
  0x4012e0		4889442440		MOVQ AX, 0x40(SP)		
  0x4012e5		488b6c2420		MOVQ 0x20(SP), BP		
  0x4012ea		4883c428		ADDQ $0x28, SP			
  0x4012ee		c3			RET				
func f32hash(p unsafe.Pointer, h uintptr) uintptr {
  0x4012ef		e87c320400		CALL runtime.morestack_noctxt(SB)	
  0x4012f4		e9e7feffff		JMP runtime.f32hash(SB)			

TEXT runtime.f64hash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func f64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x401300		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401309		483b6110		CMPQ 0x10(CX), SP	
  0x40130d		0f86fe000000		JBE 0x401411		
  0x401313		4883ec28		SUBQ $0x28, SP		
  0x401317		48896c2420		MOVQ BP, 0x20(SP)	
  0x40131c		488d6c2420		LEAQ 0x20(SP), BP	
  0x401321		488b442430		MOVQ 0x30(SP), AX	
	f := *(*float64)(p)
  0x401326		f20f1000		MOVSD_XMM 0(AX), X0	
	case f == 0:
  0x40132a		0f57c9			XORPS X1, X1		
  0x40132d		660f2ec1		UCOMISD X1, X0		
  0x401331		7506			JNE 0x401339		
  0x401333		0f8ba9000000		JNP 0x4013e2		
	case f != f:
  0x401339		660f2ec0		UCOMISD X0, X0		
  0x40133d		7502			JNE 0x401341		
  0x40133f		7b71			JNP 0x4013b2		
	mp := getg().m
  0x401341		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40134a		488b4030		MOVQ 0x30(AX), AX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40134e		8b8820010000		MOVL 0x120(AX), CX	
  0x401354		8b9024010000		MOVL 0x124(AX), DX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40135a		899020010000		MOVL DX, 0x120(AX)	
  0x401360		89cb			MOVL CX, BX		
	s1 ^= s1 << 17
  0x401362		c1e111			SHLL $0x11, CX		
  0x401365		31cb			XORL CX, BX		
  0x401367		89d1			MOVL DX, CX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x401369		31da			XORL BX, DX		
  0x40136b		c1eb07			SHRL $0x7, BX		
  0x40136e		31d3			XORL DX, BX		
  0x401370		89ca			MOVL CX, DX		
  0x401372		c1e910			SHRL $0x10, CX		
  0x401375		31d9			XORL BX, CX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x401377		898824010000		MOVL CX, 0x124(AX)	
	return s0 + s1
  0x40137d		8d040a			LEAL 0(DX)(CX*1), AX	
  0x401380		488b4c2438		MOVQ 0x38(SP), CX	
		return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN
  0x401385		4831c8			XORQ CX, AX			
  0x401388		48b921a6566aa16e7500	MOVQ $0x756ea16a56a621, CX	
  0x401392		4831c1			XORQ AX, CX			
  0x401395		48b8bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, AX	
  0x40139f		480fafc8		IMULQ AX, CX			
  0x4013a3		48894c2440		MOVQ CX, 0x40(SP)		
  0x4013a8		488b6c2420		MOVQ 0x20(SP), BP		
  0x4013ad		4883c428		ADDQ $0x28, SP			
  0x4013b1		c3			RET				
		return memhash(p, h, 8)
  0x4013b2		48890424		MOVQ AX, 0(SP)			
  0x4013b6		488b442438		MOVQ 0x38(SP), AX		
  0x4013bb		4889442408		MOVQ AX, 0x8(SP)		
  0x4013c0		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x4013c9		e842470000		CALL runtime.memhash(SB)	
  0x4013ce		488b442418		MOVQ 0x18(SP), AX		
  0x4013d3		4889442440		MOVQ AX, 0x40(SP)		
  0x4013d8		488b6c2420		MOVQ 0x20(SP), BP		
  0x4013dd		4883c428		ADDQ $0x28, SP			
  0x4013e1		c3			RET				
		return c1 * (c0 ^ h) // +0, -0
  0x4013e2		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x4013ec		488b4c2438		MOVQ 0x38(SP), CX		
  0x4013f1		4831c8			XORQ CX, AX			
  0x4013f4		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x4013fe		480fafc1		IMULQ CX, AX			
  0x401402		4889442440		MOVQ AX, 0x40(SP)		
  0x401407		488b6c2420		MOVQ 0x20(SP), BP		
  0x40140c		4883c428		ADDQ $0x28, SP			
  0x401410		c3			RET				
func f64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x401411		e85a310400		CALL runtime.morestack_noctxt(SB)	
  0x401416		e9e5feffff		JMP runtime.f64hash(SB)			

TEXT runtime.c64hash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func c64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x401420		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401429		483b6110		CMPQ 0x10(CX), SP	
  0x40142d		7658			JBE 0x401487		
  0x40142f		4883ec20		SUBQ $0x20, SP		
  0x401433		48896c2418		MOVQ BP, 0x18(SP)	
  0x401438		488d6c2418		LEAQ 0x18(SP), BP	
  0x40143d		488b442428		MOVQ 0x28(SP), AX	
	return f32hash(unsafe.Pointer(&x[1]), f32hash(unsafe.Pointer(&x[0]), h))
  0x401442		8400			TESTB AL, 0(AX)		
  0x401444		48890424		MOVQ AX, 0(SP)		
func c64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x401448		488b4c2430		MOVQ 0x30(SP), CX	
	return f32hash(unsafe.Pointer(&x[1]), f32hash(unsafe.Pointer(&x[0]), h))
  0x40144d		48894c2408		MOVQ CX, 0x8(SP)		
  0x401452		e889fdffff		CALL runtime.f32hash(SB)	
  0x401457		488b442428		MOVQ 0x28(SP), AX		
  0x40145c		4883c004		ADDQ $0x4, AX			
  0x401460		488b4c2410		MOVQ 0x10(SP), CX		
  0x401465		48890424		MOVQ AX, 0(SP)			
  0x401469		48894c2408		MOVQ CX, 0x8(SP)		
  0x40146e		e86dfdffff		CALL runtime.f32hash(SB)	
  0x401473		488b442410		MOVQ 0x10(SP), AX		
  0x401478		4889442438		MOVQ AX, 0x38(SP)		
  0x40147d		488b6c2418		MOVQ 0x18(SP), BP		
  0x401482		4883c420		ADDQ $0x20, SP			
  0x401486		c3			RET				
func c64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x401487		e8e4300400		CALL runtime.morestack_noctxt(SB)	
  0x40148c		eb92			JMP runtime.c64hash(SB)			

TEXT runtime.c128hash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func c128hash(p unsafe.Pointer, h uintptr) uintptr {
  0x401490		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401499		483b6110		CMPQ 0x10(CX), SP	
  0x40149d		7658			JBE 0x4014f7		
  0x40149f		4883ec20		SUBQ $0x20, SP		
  0x4014a3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4014a8		488d6c2418		LEAQ 0x18(SP), BP	
  0x4014ad		488b442428		MOVQ 0x28(SP), AX	
	return f64hash(unsafe.Pointer(&x[1]), f64hash(unsafe.Pointer(&x[0]), h))
  0x4014b2		8400			TESTB AL, 0(AX)		
  0x4014b4		48890424		MOVQ AX, 0(SP)		
func c128hash(p unsafe.Pointer, h uintptr) uintptr {
  0x4014b8		488b4c2430		MOVQ 0x30(SP), CX	
	return f64hash(unsafe.Pointer(&x[1]), f64hash(unsafe.Pointer(&x[0]), h))
  0x4014bd		48894c2408		MOVQ CX, 0x8(SP)		
  0x4014c2		e839feffff		CALL runtime.f64hash(SB)	
  0x4014c7		488b442428		MOVQ 0x28(SP), AX		
  0x4014cc		4883c008		ADDQ $0x8, AX			
  0x4014d0		488b4c2410		MOVQ 0x10(SP), CX		
  0x4014d5		48890424		MOVQ AX, 0(SP)			
  0x4014d9		48894c2408		MOVQ CX, 0x8(SP)		
  0x4014de		e81dfeffff		CALL runtime.f64hash(SB)	
  0x4014e3		488b442410		MOVQ 0x10(SP), AX		
  0x4014e8		4889442438		MOVQ AX, 0x38(SP)		
  0x4014ed		488b6c2418		MOVQ 0x18(SP), BP		
  0x4014f2		4883c420		ADDQ $0x20, SP			
  0x4014f6		c3			RET				
func c128hash(p unsafe.Pointer, h uintptr) uintptr {
  0x4014f7		e874300400		CALL runtime.morestack_noctxt(SB)	
  0x4014fc		eb92			JMP runtime.c128hash(SB)		

TEXT runtime.interhash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func interhash(p unsafe.Pointer, h uintptr) uintptr {
  0x401500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401509		483b6110		CMPQ 0x10(CX), SP	
  0x40150d		0f8663010000		JBE 0x401676		
  0x401513		4883ec50		SUBQ $0x50, SP		
  0x401517		48896c2448		MOVQ BP, 0x48(SP)	
  0x40151c		488d6c2448		LEAQ 0x48(SP), BP	
  0x401521		488b442458		MOVQ 0x58(SP), AX	
	tab := a.tab
  0x401526		488b08			MOVQ 0(AX), CX		
	if tab == nil {
  0x401529		4885c9			TESTQ CX, CX		
  0x40152c		0f84a9000000		JE 0x4015db		
	t := tab._type
  0x401532		488b4908		MOVQ 0x8(CX), CX	
	fn := t.alg.hash
  0x401536		488b5918		MOVQ 0x18(CX), BX	
  0x40153a		488b13			MOVQ 0(BX), DX		
	if fn == nil {
  0x40153d		4885d2			TESTQ DX, DX		
  0x401540		0f84a9000000		JE 0x4015ef		
	return t.kind&kindDirectIface != 0
  0x401546		0fb64917		MOVZX 0x17(CX), CX	
  0x40154a		f6c120			TESTL $0x20, CL		
	if isDirectIface(t) {
  0x40154d		7446			JE 0x401595		
		return c1 * fn(unsafe.Pointer(&a.data), h^c0)
  0x40154f		4883c008		ADDQ $0x8, AX			
  0x401553		48890424		MOVQ AX, 0(SP)			
  0x401557		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x401561		488b4c2460		MOVQ 0x60(SP), CX		
  0x401566		4831c8			XORQ CX, AX			
  0x401569		4889442408		MOVQ AX, 0x8(SP)		
  0x40156e		488b02			MOVQ 0(DX), AX			
  0x401571		ffd0			CALL AX				
  0x401573		488b442410		MOVQ 0x10(SP), AX		
  0x401578		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x401582		480fafc8		IMULQ AX, CX			
  0x401586		48894c2468		MOVQ CX, 0x68(SP)		
  0x40158b		488b6c2448		MOVQ 0x48(SP), BP		
  0x401590		4883c450		ADDQ $0x50, SP			
  0x401594		c3			RET				
		return c1 * fn(a.data, h^c0)
  0x401595		488b4008		MOVQ 0x8(AX), AX		
  0x401599		48890424		MOVQ AX, 0(SP)			
  0x40159d		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x4015a7		488b4c2460		MOVQ 0x60(SP), CX		
  0x4015ac		4831c8			XORQ CX, AX			
  0x4015af		4889442408		MOVQ AX, 0x8(SP)		
  0x4015b4		488b02			MOVQ 0(DX), AX			
  0x4015b7		ffd0			CALL AX				
  0x4015b9		488b442410		MOVQ 0x10(SP), AX		
  0x4015be		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x4015c8		480fafc1		IMULQ CX, AX			
  0x4015cc		4889442468		MOVQ AX, 0x68(SP)		
  0x4015d1		488b6c2448		MOVQ 0x48(SP), BP		
  0x4015d6		4883c450		ADDQ $0x50, SP			
  0x4015da		c3			RET				
		return h
  0x4015db		488b442460		MOVQ 0x60(SP), AX	
  0x4015e0		4889442468		MOVQ AX, 0x68(SP)	
  0x4015e5		488b6c2448		MOVQ 0x48(SP), BP	
  0x4015ea		4883c450		ADDQ $0x50, SP		
  0x4015ee		c3			RET			
		panic(errorString("hash of unhashable type " + t.string()))
  0x4015ef		48890c24		MOVQ CX, 0(SP)				
  0x4015f3		e878d30300		CALL runtime.(*_type).string(SB)	
  0x4015f8		488b442410		MOVQ 0x10(SP), AX			
  0x4015fd		488b4c2408		MOVQ 0x8(SP), CX			
  0x401602		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x40160a		488d15c5a20600		LEAQ 0x6a2c5(IP), DX			
  0x401611		4889542408		MOVQ DX, 0x8(SP)			
  0x401616		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x40161f		48894c2418		MOVQ CX, 0x18(SP)			
  0x401624		4889442420		MOVQ AX, 0x20(SP)			
  0x401629		e8b2590300		CALL runtime.concatstring2(SB)		
  0x40162e		488b442430		MOVQ 0x30(SP), AX			
  0x401633		488b4c2428		MOVQ 0x28(SP), CX			
  0x401638		48894c2438		MOVQ CX, 0x38(SP)			
  0x40163d		4889442440		MOVQ AX, 0x40(SP)			
  0x401642		488d0577980500		LEAQ 0x59877(IP), AX			
  0x401649		48890424		MOVQ AX, 0(SP)				
  0x40164d		488d442438		LEAQ 0x38(SP), AX			
  0x401652		4889442408		MOVQ AX, 0x8(SP)			
  0x401657		e8447b0000		CALL runtime.convT2Estring(SB)		
  0x40165c		488b442418		MOVQ 0x18(SP), AX			
  0x401661		488b4c2410		MOVQ 0x10(SP), CX			
  0x401666		48890c24		MOVQ CX, 0(SP)				
  0x40166a		4889442408		MOVQ AX, 0x8(SP)			
  0x40166f		e8bcf30100		CALL runtime.gopanic(SB)		
  0x401674		0f0b			UD2					
func interhash(p unsafe.Pointer, h uintptr) uintptr {
  0x401676		e8f52e0400		CALL runtime.morestack_noctxt(SB)	
  0x40167b		e980feffff		JMP runtime.interhash(SB)		

TEXT runtime.nilinterhash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {
  0x401680		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401689		483b6110		CMPQ 0x10(CX), SP	
  0x40168d		0f865f010000		JBE 0x4017f2		
  0x401693		4883ec50		SUBQ $0x50, SP		
  0x401697		48896c2448		MOVQ BP, 0x48(SP)	
  0x40169c		488d6c2448		LEAQ 0x48(SP), BP	
  0x4016a1		488b442458		MOVQ 0x58(SP), AX	
	t := a._type
  0x4016a6		488b08			MOVQ 0(AX), CX		
	if t == nil {
  0x4016a9		4885c9			TESTQ CX, CX		
  0x4016ac		0f84a5000000		JE 0x401757		
	fn := t.alg.hash
  0x4016b2		488b5918		MOVQ 0x18(CX), BX	
  0x4016b6		488b13			MOVQ 0(BX), DX		
	if fn == nil {
  0x4016b9		4885d2			TESTQ DX, DX		
  0x4016bc		0f84a9000000		JE 0x40176b		
	return t.kind&kindDirectIface != 0
  0x4016c2		0fb64917		MOVZX 0x17(CX), CX	
  0x4016c6		f6c120			TESTL $0x20, CL		
	if isDirectIface(t) {
  0x4016c9		7446			JE 0x401711		
		return c1 * fn(unsafe.Pointer(&a.data), h^c0)
  0x4016cb		4883c008		ADDQ $0x8, AX			
  0x4016cf		48890424		MOVQ AX, 0(SP)			
  0x4016d3		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x4016dd		488b4c2460		MOVQ 0x60(SP), CX		
  0x4016e2		4831c8			XORQ CX, AX			
  0x4016e5		4889442408		MOVQ AX, 0x8(SP)		
  0x4016ea		488b02			MOVQ 0(DX), AX			
  0x4016ed		ffd0			CALL AX				
  0x4016ef		488b442410		MOVQ 0x10(SP), AX		
  0x4016f4		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x4016fe		480fafc8		IMULQ AX, CX			
  0x401702		48894c2468		MOVQ CX, 0x68(SP)		
  0x401707		488b6c2448		MOVQ 0x48(SP), BP		
  0x40170c		4883c450		ADDQ $0x50, SP			
  0x401710		c3			RET				
		return c1 * fn(a.data, h^c0)
  0x401711		488b4008		MOVQ 0x8(AX), AX		
  0x401715		48890424		MOVQ AX, 0(SP)			
  0x401719		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x401723		488b4c2460		MOVQ 0x60(SP), CX		
  0x401728		4831c8			XORQ CX, AX			
  0x40172b		4889442408		MOVQ AX, 0x8(SP)		
  0x401730		488b02			MOVQ 0(DX), AX			
  0x401733		ffd0			CALL AX				
  0x401735		488b442410		MOVQ 0x10(SP), AX		
  0x40173a		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x401744		480fafc1		IMULQ CX, AX			
  0x401748		4889442468		MOVQ AX, 0x68(SP)		
  0x40174d		488b6c2448		MOVQ 0x48(SP), BP		
  0x401752		4883c450		ADDQ $0x50, SP			
  0x401756		c3			RET				
		return h
  0x401757		488b442460		MOVQ 0x60(SP), AX	
  0x40175c		4889442468		MOVQ AX, 0x68(SP)	
  0x401761		488b6c2448		MOVQ 0x48(SP), BP	
  0x401766		4883c450		ADDQ $0x50, SP		
  0x40176a		c3			RET			
		panic(errorString("hash of unhashable type " + t.string()))
  0x40176b		48890c24		MOVQ CX, 0(SP)				
  0x40176f		e8fcd10300		CALL runtime.(*_type).string(SB)	
  0x401774		488b442410		MOVQ 0x10(SP), AX			
  0x401779		488b4c2408		MOVQ 0x8(SP), CX			
  0x40177e		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x401786		488d1549a10600		LEAQ 0x6a149(IP), DX			
  0x40178d		4889542408		MOVQ DX, 0x8(SP)			
  0x401792		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x40179b		48894c2418		MOVQ CX, 0x18(SP)			
  0x4017a0		4889442420		MOVQ AX, 0x20(SP)			
  0x4017a5		e836580300		CALL runtime.concatstring2(SB)		
  0x4017aa		488b442430		MOVQ 0x30(SP), AX			
  0x4017af		488b4c2428		MOVQ 0x28(SP), CX			
  0x4017b4		48894c2438		MOVQ CX, 0x38(SP)			
  0x4017b9		4889442440		MOVQ AX, 0x40(SP)			
  0x4017be		488d05fb960500		LEAQ 0x596fb(IP), AX			
  0x4017c5		48890424		MOVQ AX, 0(SP)				
  0x4017c9		488d442438		LEAQ 0x38(SP), AX			
  0x4017ce		4889442408		MOVQ AX, 0x8(SP)			
  0x4017d3		e8c8790000		CALL runtime.convT2Estring(SB)		
  0x4017d8		488b442418		MOVQ 0x18(SP), AX			
  0x4017dd		488b4c2410		MOVQ 0x10(SP), CX			
  0x4017e2		48890c24		MOVQ CX, 0(SP)				
  0x4017e6		4889442408		MOVQ AX, 0x8(SP)			
  0x4017eb		e840f20100		CALL runtime.gopanic(SB)		
  0x4017f0		0f0b			UD2					
func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {
  0x4017f2		e8792d0400		CALL runtime.morestack_noctxt(SB)	
  0x4017f7		e984feffff		JMP runtime.nilinterhash(SB)		

TEXT runtime.memequal0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
	return true
  0x401800		c644241801		MOVB $0x1, 0x18(SP)	
  0x401805		c3			RET			

TEXT runtime.memequal8(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memequal8(p, q unsafe.Pointer) bool {
  0x401810		488b442408		MOVQ 0x8(SP), AX	
	return *(*int8)(p) == *(*int8)(q)
  0x401815		0fb600			MOVZX 0(AX), AX		
  0x401818		488b4c2410		MOVQ 0x10(SP), CX	
  0x40181d		0fb609			MOVZX 0(CX), CX		
  0x401820		38c8			CMPL CL, AL		
  0x401822		488d442418		LEAQ 0x18(SP), AX	
  0x401827		0f9400			SETE 0(AX)		
  0x40182a		c3			RET			

TEXT runtime.memequal16(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memequal16(p, q unsafe.Pointer) bool {
  0x401830		488b442408		MOVQ 0x8(SP), AX	
	return *(*int16)(p) == *(*int16)(q)
  0x401835		0fb700			MOVZX 0(AX), AX		
  0x401838		488b4c2410		MOVQ 0x10(SP), CX	
  0x40183d		0fb709			MOVZX 0(CX), CX		
  0x401840		6639c8			CMPW CX, AX		
  0x401843		488d442418		LEAQ 0x18(SP), AX	
  0x401848		0f9400			SETE 0(AX)		
  0x40184b		c3			RET			

TEXT runtime.memequal32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memequal32(p, q unsafe.Pointer) bool {
  0x401850		488b442408		MOVQ 0x8(SP), AX	
	return *(*int32)(p) == *(*int32)(q)
  0x401855		8b00			MOVL 0(AX), AX		
  0x401857		488b4c2410		MOVQ 0x10(SP), CX	
  0x40185c		8b09			MOVL 0(CX), CX		
  0x40185e		39c8			CMPL CX, AX		
  0x401860		488d442418		LEAQ 0x18(SP), AX	
  0x401865		0f9400			SETE 0(AX)		
  0x401868		c3			RET			

TEXT runtime.memequal64(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memequal64(p, q unsafe.Pointer) bool {
  0x401870		488b442408		MOVQ 0x8(SP), AX	
	return *(*int64)(p) == *(*int64)(q)
  0x401875		488b00			MOVQ 0(AX), AX		
  0x401878		488b4c2410		MOVQ 0x10(SP), CX	
  0x40187d		488b09			MOVQ 0(CX), CX		
  0x401880		4839c8			CMPQ CX, AX		
  0x401883		488d442418		LEAQ 0x18(SP), AX	
  0x401888		0f9400			SETE 0(AX)		
  0x40188b		c3			RET			

TEXT runtime.memequal128(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func memequal128(p, q unsafe.Pointer) bool {
  0x401890		488b442408		MOVQ 0x8(SP), AX	
	return *(*[2]int64)(p) == *(*[2]int64)(q)
  0x401895		488b08			MOVQ 0(AX), CX		
  0x401898		488b542410		MOVQ 0x10(SP), DX	
  0x40189d		488b1a			MOVQ 0(DX), BX		
  0x4018a0		4839d9			CMPQ BX, CX		
  0x4018a3		7513			JNE 0x4018b8		
  0x4018a5		488b4008		MOVQ 0x8(AX), AX	
  0x4018a9		488b4a08		MOVQ 0x8(DX), CX	
  0x4018ad		4839c1			CMPQ AX, CX		
  0x4018b0		0f94c0			SETE AL			
  0x4018b3		88442418		MOVB AL, 0x18(SP)	
  0x4018b7		c3			RET			
  0x4018b8		31c0			XORL AX, AX		
  0x4018ba		ebf7			JMP 0x4018b3		

TEXT runtime.f32equal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func f32equal(p, q unsafe.Pointer) bool {
  0x4018c0		488b442408		MOVQ 0x8(SP), AX	
	return *(*float32)(p) == *(*float32)(q)
  0x4018c5		f30f1000		MOVSS 0(AX), X0		
  0x4018c9		488b442410		MOVQ 0x10(SP), AX	
  0x4018ce		f30f1008		MOVSS 0(AX), X1		
  0x4018d2		0f2ec1			UCOMISS X1, X0		
  0x4018d5		0f94c1			SETE CL			
  0x4018d8		0f9bc0			SETNP AL		
  0x4018db		21c1			ANDL AX, CX		
  0x4018dd		884c2418		MOVB CL, 0x18(SP)	
  0x4018e1		c3			RET			

TEXT runtime.f64equal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func f64equal(p, q unsafe.Pointer) bool {
  0x4018f0		488b442408		MOVQ 0x8(SP), AX	
	return *(*float64)(p) == *(*float64)(q)
  0x4018f5		f20f1000		MOVSD_XMM 0(AX), X0	
  0x4018f9		488b442410		MOVQ 0x10(SP), AX	
  0x4018fe		f20f1008		MOVSD_XMM 0(AX), X1	
  0x401902		660f2ec1		UCOMISD X1, X0		
  0x401906		0f94c1			SETE CL			
  0x401909		0f9bc0			SETNP AL		
  0x40190c		21c1			ANDL AX, CX		
  0x40190e		884c2418		MOVB CL, 0x18(SP)	
  0x401912		c3			RET			

TEXT runtime.c64equal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func c64equal(p, q unsafe.Pointer) bool {
  0x401920		488b442408		MOVQ 0x8(SP), AX	
	return *(*complex64)(p) == *(*complex64)(q)
  0x401925		f30f104004		MOVSS 0x4(AX), X0	
  0x40192a		f30f1008		MOVSS 0(AX), X1		
  0x40192e		488b442410		MOVQ 0x10(SP), AX	
  0x401933		f30f105004		MOVSS 0x4(AX), X2	
  0x401938		f30f1018		MOVSS 0(AX), X3		
  0x40193c		0f2ecb			UCOMISS X3, X1		
  0x40193f		0f94c1			SETE CL			
  0x401942		0f9bc0			SETNP AL		
  0x401945		21c1			ANDL AX, CX		
  0x401947		0f2ec2			UCOMISS X2, X0		
  0x40194a		0f94c2			SETE DL			
  0x40194d		0f9bc0			SETNP AL		
  0x401950		21c2			ANDL AX, DX		
  0x401952		21d1			ANDL DX, CX		
  0x401954		884c2418		MOVB CL, 0x18(SP)	
  0x401958		c3			RET			

TEXT runtime.c128equal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func c128equal(p, q unsafe.Pointer) bool {
  0x401960		488b442408		MOVQ 0x8(SP), AX	
	return *(*complex128)(p) == *(*complex128)(q)
  0x401965		f20f104008		MOVSD_XMM 0x8(AX), X0	
  0x40196a		f20f1008		MOVSD_XMM 0(AX), X1	
  0x40196e		488b442410		MOVQ 0x10(SP), AX	
  0x401973		f20f105008		MOVSD_XMM 0x8(AX), X2	
  0x401978		f20f1018		MOVSD_XMM 0(AX), X3	
  0x40197c		660f2ecb		UCOMISD X3, X1		
  0x401980		0f94c1			SETE CL			
  0x401983		0f9bc0			SETNP AL		
  0x401986		21c1			ANDL AX, CX		
  0x401988		660f2ec2		UCOMISD X2, X0		
  0x40198c		0f94c2			SETE DL			
  0x40198f		0f9bc0			SETNP AL		
  0x401992		21c2			ANDL AX, DX		
  0x401994		21d1			ANDL DX, CX		
  0x401996		884c2418		MOVB CL, 0x18(SP)	
  0x40199a		c3			RET			

TEXT runtime.strequal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func strequal(p, q unsafe.Pointer) bool {
  0x4019a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4019a9		483b6110		CMPQ 0x10(CX), SP	
  0x4019ad		7655			JBE 0x401a04		
  0x4019af		4883ec28		SUBQ $0x28, SP		
  0x4019b3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4019b8		488d6c2420		LEAQ 0x20(SP), BP	
  0x4019bd		488b442430		MOVQ 0x30(SP), AX	
	return *(*string)(p) == *(*string)(q)
  0x4019c2		488b4808		MOVQ 0x8(AX), CX		
  0x4019c6		488b00			MOVQ 0(AX), AX			
  0x4019c9		488b542438		MOVQ 0x38(SP), DX		
  0x4019ce		488b5a08		MOVQ 0x8(DX), BX		
  0x4019d2		488b12			MOVQ 0(DX), DX			
  0x4019d5		4839d9			CMPQ BX, CX			
  0x4019d8		7410			JE 0x4019ea			
  0x4019da		31c0			XORL AX, AX			
  0x4019dc		88442440		MOVB AL, 0x40(SP)		
  0x4019e0		488b6c2420		MOVQ 0x20(SP), BP		
  0x4019e5		4883c428		ADDQ $0x28, SP			
  0x4019e9		c3			RET				
  0x4019ea		48890424		MOVQ AX, 0(SP)			
  0x4019ee		4889542408		MOVQ DX, 0x8(SP)		
  0x4019f3		48894c2410		MOVQ CX, 0x10(SP)		
  0x4019f8		e843490400		CALL runtime.memequal(SB)	
  0x4019fd		0fb6442418		MOVZX 0x18(SP), AX		
  0x401a02		ebd8			JMP 0x4019dc			
func strequal(p, q unsafe.Pointer) bool {
  0x401a04		e8672b0400		CALL runtime.morestack_noctxt(SB)	
  0x401a09		eb95			JMP runtime.strequal(SB)		

TEXT runtime.interequal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func interequal(p, q unsafe.Pointer) bool {
  0x401a10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401a19		483b6110		CMPQ 0x10(CX), SP	
  0x401a1d		7655			JBE 0x401a74		
  0x401a1f		4883ec28		SUBQ $0x28, SP		
  0x401a23		48896c2420		MOVQ BP, 0x20(SP)	
  0x401a28		488d6c2420		LEAQ 0x20(SP), BP	
  0x401a2d		488b442430		MOVQ 0x30(SP), AX	
	x := *(*iface)(p)
  0x401a32		488b4808		MOVQ 0x8(AX), CX	
  0x401a36		488b00			MOVQ 0(AX), AX		
  0x401a39		488b542438		MOVQ 0x38(SP), DX	
	y := *(*iface)(q)
  0x401a3e		488b5a08		MOVQ 0x8(DX), BX	
  0x401a42		488b12			MOVQ 0(DX), DX		
	return x.tab == y.tab && ifaceeq(x.tab, x.data, y.data)
  0x401a45		4839d0			CMPQ DX, AX			
  0x401a48		7410			JE 0x401a5a			
  0x401a4a		31c0			XORL AX, AX			
  0x401a4c		88442440		MOVB AL, 0x40(SP)		
  0x401a50		488b6c2420		MOVQ 0x20(SP), BP		
  0x401a55		4883c428		ADDQ $0x28, SP			
  0x401a59		c3			RET				
  0x401a5a		48890424		MOVQ AX, 0(SP)			
  0x401a5e		48894c2408		MOVQ CX, 0x8(SP)		
  0x401a63		48895c2410		MOVQ BX, 0x10(SP)		
  0x401a68		e8c3010000		CALL runtime.ifaceeq(SB)	
  0x401a6d		0fb6442418		MOVZX 0x18(SP), AX		
  0x401a72		ebd8			JMP 0x401a4c			
func interequal(p, q unsafe.Pointer) bool {
  0x401a74		e8f72a0400		CALL runtime.morestack_noctxt(SB)	
  0x401a79		eb95			JMP runtime.interequal(SB)		

TEXT runtime.nilinterequal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func nilinterequal(p, q unsafe.Pointer) bool {
  0x401a80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401a89		483b6110		CMPQ 0x10(CX), SP	
  0x401a8d		7655			JBE 0x401ae4		
  0x401a8f		4883ec28		SUBQ $0x28, SP		
  0x401a93		48896c2420		MOVQ BP, 0x20(SP)	
  0x401a98		488d6c2420		LEAQ 0x20(SP), BP	
  0x401a9d		488b442430		MOVQ 0x30(SP), AX	
	x := *(*eface)(p)
  0x401aa2		488b4808		MOVQ 0x8(AX), CX	
  0x401aa6		488b00			MOVQ 0(AX), AX		
  0x401aa9		488b542438		MOVQ 0x38(SP), DX	
	y := *(*eface)(q)
  0x401aae		488b5a08		MOVQ 0x8(DX), BX	
  0x401ab2		488b12			MOVQ 0(DX), DX		
	return x._type == y._type && efaceeq(x._type, x.data, y.data)
  0x401ab5		4839d0			CMPQ DX, AX			
  0x401ab8		7410			JE 0x401aca			
  0x401aba		31c0			XORL AX, AX			
  0x401abc		88442440		MOVB AL, 0x40(SP)		
  0x401ac0		488b6c2420		MOVQ 0x20(SP), BP		
  0x401ac5		4883c428		ADDQ $0x28, SP			
  0x401ac9		c3			RET				
  0x401aca		48890424		MOVQ AX, 0(SP)			
  0x401ace		48894c2408		MOVQ CX, 0x8(SP)		
  0x401ad3		48895c2410		MOVQ BX, 0x10(SP)		
  0x401ad8		e813000000		CALL runtime.efaceeq(SB)	
  0x401add		0fb6442418		MOVZX 0x18(SP), AX		
  0x401ae2		ebd8			JMP 0x401abc			
func nilinterequal(p, q unsafe.Pointer) bool {
  0x401ae4		e8872a0400		CALL runtime.morestack_noctxt(SB)	
  0x401ae9		eb95			JMP runtime.nilinterequal(SB)		

TEXT runtime.efaceeq(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func efaceeq(t *_type, x, y unsafe.Pointer) bool {
  0x401af0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401af9		483b6110		CMPQ 0x10(CX), SP	
  0x401afd		0f8619010000		JBE 0x401c1c		
  0x401b03		4883ec50		SUBQ $0x50, SP		
  0x401b07		48896c2448		MOVQ BP, 0x48(SP)	
  0x401b0c		488d6c2448		LEAQ 0x48(SP), BP	
  0x401b11		488b442458		MOVQ 0x58(SP), AX	
	if t == nil {
  0x401b16		4885c0			TESTQ AX, AX		
  0x401b19		746b			JE 0x401b86		
	eq := t.alg.equal
  0x401b1b		488b4818		MOVQ 0x18(AX), CX	
  0x401b1f		488b5108		MOVQ 0x8(CX), DX	
	if eq == nil {
  0x401b23		4885d2			TESTQ DX, DX		
  0x401b26		746d			JE 0x401b95		
	return t.kind&kindDirectIface != 0
  0x401b28		0fb64017		MOVZX 0x17(AX), AX	
  0x401b2c		a820			TESTL $0x20, AL		
	if isDirectIface(t) {
  0x401b2e		742b			JE 0x401b5b		
		return eq(noescape(unsafe.Pointer(&x)), noescape(unsafe.Pointer(&y)))
  0x401b30		488d442460		LEAQ 0x60(SP), AX	
  0x401b35		48890424		MOVQ AX, 0(SP)		
  0x401b39		488d442468		LEAQ 0x68(SP), AX	
  0x401b3e		4889442408		MOVQ AX, 0x8(SP)	
  0x401b43		488b02			MOVQ 0(DX), AX		
  0x401b46		ffd0			CALL AX			
  0x401b48		0fb6442410		MOVZX 0x10(SP), AX	
  0x401b4d		88442470		MOVB AL, 0x70(SP)	
  0x401b51		488b6c2448		MOVQ 0x48(SP), BP	
  0x401b56		4883c450		ADDQ $0x50, SP		
  0x401b5a		c3			RET			
	return eq(x, y)
  0x401b5b		488b442460		MOVQ 0x60(SP), AX	
  0x401b60		48890424		MOVQ AX, 0(SP)		
  0x401b64		488b442468		MOVQ 0x68(SP), AX	
  0x401b69		4889442408		MOVQ AX, 0x8(SP)	
  0x401b6e		488b02			MOVQ 0(DX), AX		
  0x401b71		ffd0			CALL AX			
  0x401b73		0fb6442410		MOVZX 0x10(SP), AX	
  0x401b78		88442470		MOVB AL, 0x70(SP)	
  0x401b7c		488b6c2448		MOVQ 0x48(SP), BP	
  0x401b81		4883c450		ADDQ $0x50, SP		
  0x401b85		c3			RET			
		return true
  0x401b86		c644247001		MOVB $0x1, 0x70(SP)	
  0x401b8b		488b6c2448		MOVQ 0x48(SP), BP	
  0x401b90		4883c450		ADDQ $0x50, SP		
  0x401b94		c3			RET			
		panic(errorString("comparing uncomparable type " + t.string()))
  0x401b95		48890424		MOVQ AX, 0(SP)				
  0x401b99		e8d2cd0300		CALL runtime.(*_type).string(SB)	
  0x401b9e		488b442410		MOVQ 0x10(SP), AX			
  0x401ba3		488b4c2408		MOVQ 0x8(SP), CX			
  0x401ba8		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x401bb0		488d15c7a40600		LEAQ 0x6a4c7(IP), DX			
  0x401bb7		4889542408		MOVQ DX, 0x8(SP)			
  0x401bbc		48c74424101c000000	MOVQ $0x1c, 0x10(SP)			
  0x401bc5		48894c2418		MOVQ CX, 0x18(SP)			
  0x401bca		4889442420		MOVQ AX, 0x20(SP)			
  0x401bcf		e80c540300		CALL runtime.concatstring2(SB)		
  0x401bd4		488b442430		MOVQ 0x30(SP), AX			
  0x401bd9		488b4c2428		MOVQ 0x28(SP), CX			
  0x401bde		48894c2438		MOVQ CX, 0x38(SP)			
  0x401be3		4889442440		MOVQ AX, 0x40(SP)			
  0x401be8		488d05d1920500		LEAQ 0x592d1(IP), AX			
  0x401bef		48890424		MOVQ AX, 0(SP)				
  0x401bf3		488d442438		LEAQ 0x38(SP), AX			
  0x401bf8		4889442408		MOVQ AX, 0x8(SP)			
  0x401bfd		e89e750000		CALL runtime.convT2Estring(SB)		
  0x401c02		488b442418		MOVQ 0x18(SP), AX			
  0x401c07		488b4c2410		MOVQ 0x10(SP), CX			
  0x401c0c		48890c24		MOVQ CX, 0(SP)				
  0x401c10		4889442408		MOVQ AX, 0x8(SP)			
  0x401c15		e816ee0100		CALL runtime.gopanic(SB)		
  0x401c1a		0f0b			UD2					
func efaceeq(t *_type, x, y unsafe.Pointer) bool {
  0x401c1c		e84f290400		CALL runtime.morestack_noctxt(SB)	
  0x401c21		e9cafeffff		JMP runtime.efaceeq(SB)			

TEXT runtime.ifaceeq(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func ifaceeq(tab *itab, x, y unsafe.Pointer) bool {
  0x401c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401c39		483b6110		CMPQ 0x10(CX), SP	
  0x401c3d		0f861d010000		JBE 0x401d60		
  0x401c43		4883ec50		SUBQ $0x50, SP		
  0x401c47		48896c2448		MOVQ BP, 0x48(SP)	
  0x401c4c		488d6c2448		LEAQ 0x48(SP), BP	
  0x401c51		488b442458		MOVQ 0x58(SP), AX	
	if tab == nil {
  0x401c56		4885c0			TESTQ AX, AX		
  0x401c59		746f			JE 0x401cca		
	t := tab._type
  0x401c5b		488b4008		MOVQ 0x8(AX), AX	
	eq := t.alg.equal
  0x401c5f		488b4818		MOVQ 0x18(AX), CX	
  0x401c63		488b5108		MOVQ 0x8(CX), DX	
	if eq == nil {
  0x401c67		4885d2			TESTQ DX, DX		
  0x401c6a		746d			JE 0x401cd9		
	return t.kind&kindDirectIface != 0
  0x401c6c		0fb64017		MOVZX 0x17(AX), AX	
  0x401c70		a820			TESTL $0x20, AL		
	if isDirectIface(t) {
  0x401c72		742b			JE 0x401c9f		
		return eq(noescape(unsafe.Pointer(&x)), noescape(unsafe.Pointer(&y)))
  0x401c74		488d442460		LEAQ 0x60(SP), AX	
  0x401c79		48890424		MOVQ AX, 0(SP)		
  0x401c7d		488d442468		LEAQ 0x68(SP), AX	
  0x401c82		4889442408		MOVQ AX, 0x8(SP)	
  0x401c87		488b02			MOVQ 0(DX), AX		
  0x401c8a		ffd0			CALL AX			
  0x401c8c		0fb6442410		MOVZX 0x10(SP), AX	
  0x401c91		88442470		MOVB AL, 0x70(SP)	
  0x401c95		488b6c2448		MOVQ 0x48(SP), BP	
  0x401c9a		4883c450		ADDQ $0x50, SP		
  0x401c9e		c3			RET			
	return eq(x, y)
  0x401c9f		488b442460		MOVQ 0x60(SP), AX	
  0x401ca4		48890424		MOVQ AX, 0(SP)		
  0x401ca8		488b442468		MOVQ 0x68(SP), AX	
  0x401cad		4889442408		MOVQ AX, 0x8(SP)	
  0x401cb2		488b02			MOVQ 0(DX), AX		
  0x401cb5		ffd0			CALL AX			
  0x401cb7		0fb6442410		MOVZX 0x10(SP), AX	
  0x401cbc		88442470		MOVB AL, 0x70(SP)	
  0x401cc0		488b6c2448		MOVQ 0x48(SP), BP	
  0x401cc5		4883c450		ADDQ $0x50, SP		
  0x401cc9		c3			RET			
		return true
  0x401cca		c644247001		MOVB $0x1, 0x70(SP)	
  0x401ccf		488b6c2448		MOVQ 0x48(SP), BP	
  0x401cd4		4883c450		ADDQ $0x50, SP		
  0x401cd8		c3			RET			
		panic(errorString("comparing uncomparable type " + t.string()))
  0x401cd9		48890424		MOVQ AX, 0(SP)				
  0x401cdd		e88ecc0300		CALL runtime.(*_type).string(SB)	
  0x401ce2		488b442410		MOVQ 0x10(SP), AX			
  0x401ce7		488b4c2408		MOVQ 0x8(SP), CX			
  0x401cec		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x401cf4		488d1583a30600		LEAQ 0x6a383(IP), DX			
  0x401cfb		4889542408		MOVQ DX, 0x8(SP)			
  0x401d00		48c74424101c000000	MOVQ $0x1c, 0x10(SP)			
  0x401d09		48894c2418		MOVQ CX, 0x18(SP)			
  0x401d0e		4889442420		MOVQ AX, 0x20(SP)			
  0x401d13		e8c8520300		CALL runtime.concatstring2(SB)		
  0x401d18		488b442430		MOVQ 0x30(SP), AX			
  0x401d1d		488b4c2428		MOVQ 0x28(SP), CX			
  0x401d22		48894c2438		MOVQ CX, 0x38(SP)			
  0x401d27		4889442440		MOVQ AX, 0x40(SP)			
  0x401d2c		488d058d910500		LEAQ 0x5918d(IP), AX			
  0x401d33		48890424		MOVQ AX, 0(SP)				
  0x401d37		488d442438		LEAQ 0x38(SP), AX			
  0x401d3c		4889442408		MOVQ AX, 0x8(SP)			
  0x401d41		e85a740000		CALL runtime.convT2Estring(SB)		
  0x401d46		488b442418		MOVQ 0x18(SP), AX			
  0x401d4b		488b4c2410		MOVQ 0x10(SP), CX			
  0x401d50		48890c24		MOVQ CX, 0(SP)				
  0x401d54		4889442408		MOVQ AX, 0x8(SP)			
  0x401d59		e8d2ec0100		CALL runtime.gopanic(SB)		
  0x401d5e		0f0b			UD2					
func ifaceeq(tab *itab, x, y unsafe.Pointer) bool {
  0x401d60		e80b280400		CALL runtime.morestack_noctxt(SB)	
  0x401d65		e9c6feffff		JMP runtime.ifaceeq(SB)			

TEXT runtime.alginit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/alg.go
func alginit() {
  0x401d70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401d79		483b6110		CMPQ 0x10(CX), SP	
  0x401d7d		0f8651010000		JBE 0x401ed4		
  0x401d83		4883ec20		SUBQ $0x20, SP		
  0x401d87		48896c2418		MOVQ BP, 0x18(SP)	
  0x401d8c		488d6c2418		LEAQ 0x18(SP), BP	
	if (GOARCH == "386" || GOARCH == "amd64") &&
  0x401d91		0fb60d191b0c00		MOVZX runtime.support_aes(SB), CX	
  0x401d98		84c9			TESTL CL, CL				
  0x401d9a		0f84c0000000		JE 0x401e60				
  0x401da0		0fb60d151b0c00		MOVZX runtime.support_ssse3(SB), CX	
  0x401da7		84c9			TESTL CL, CL				
  0x401da9		0f84b1000000		JE 0x401e60				
  0x401daf		0fb60d041b0c00		MOVZX runtime.support_sse41(SB), CX	
  0x401db6		84c9			TESTL CL, CL				
  0x401db8		0f84a2000000		JE 0x401e60				
		useAeshash = true
  0x401dbe		c605f91a0c0001		MOVB $0x1, runtime.useAeshash(SB)	
		algarray[alg_MEM32].hash = aeshash32
  0x401dc5		8b0d451c0c00		MOVL runtime.writeBarrier(SB), CX	
  0x401dcb		85c9			TESTL CX, CX				
  0x401dcd		7556			JNE 0x401e25				
  0x401dcf		488d05b2c10600		LEAQ 0x6c1b2(IP), AX			
  0x401dd6		488905a33f0a00		MOVQ AX, runtime.algarray+64(SB)	
		algarray[alg_MEM64].hash = aeshash64
  0x401ddd		488d05acc10600		LEAQ 0x6c1ac(IP), AX			
  0x401de4		488905a53f0a00		MOVQ AX, runtime.algarray+80(SB)	
		algarray[alg_STRING].hash = aeshashstr
  0x401deb		488d05a6c10600		LEAQ 0x6c1a6(IP), AX			
  0x401df2		488905b73f0a00		MOVQ AX, runtime.algarray+112(SB)	
		getRandomData(aeskeysched[:])
  0x401df9		488d05a01d0c00		LEAQ runtime.aeskeysched(SB), AX	
  0x401e00		48890424		MOVQ AX, 0(SP)				
  0x401e04		48c744240880000000	MOVQ $0x80, 0x8(SP)			
  0x401e0d		48c744241080000000	MOVQ $0x80, 0x10(SP)			
  0x401e16		e835d60100		CALL runtime.getRandomData(SB)		
		return
  0x401e1b		488b6c2418		MOVQ 0x18(SP), BP	
  0x401e20		4883c420		ADDQ $0x20, SP		
  0x401e24		c3			RET			
		algarray[alg_MEM32].hash = aeshash32
  0x401e25		488d3d543f0a00		LEAQ runtime.algarray+64(SB), DI	
  0x401e2c		488d0555c10600		LEAQ 0x6c155(IP), AX			
  0x401e33		e8684a0400		CALL runtime.gcWriteBarrier(SB)		
		algarray[alg_MEM64].hash = aeshash64
  0x401e38		488d3d513f0a00		LEAQ runtime.algarray+80(SB), DI	
  0x401e3f		488d054ac10600		LEAQ 0x6c14a(IP), AX			
  0x401e46		e8554a0400		CALL runtime.gcWriteBarrier(SB)		
		algarray[alg_STRING].hash = aeshashstr
  0x401e4b		488d3d5e3f0a00		LEAQ runtime.algarray+112(SB), DI	
  0x401e52		488d053fc10600		LEAQ 0x6c13f(IP), AX			
  0x401e59		e8424a0400		CALL runtime.gcWriteBarrier(SB)		
		algarray[alg_MEM32].hash = aeshash32
  0x401e5e		eb99			JMP 0x401df9		
	getRandomData((*[len(hashkey) * sys.PtrSize]byte)(unsafe.Pointer(&hashkey))[:])
  0x401e60		488d05b91b0c00		LEAQ runtime.hashkey(SB), AX	
  0x401e67		48890424		MOVQ AX, 0(SP)			
  0x401e6b		48c744240820000000	MOVQ $0x20, 0x8(SP)		
  0x401e74		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x401e7d		e8ced50100		CALL runtime.getRandomData(SB)	
	hashkey[0] |= 1 // make sure these numbers are odd
  0x401e82		488b05971b0c00		MOVQ runtime.hashkey(SB), AX	
  0x401e89		4883c801		ORQ $0x1, AX			
  0x401e8d		4889058c1b0c00		MOVQ AX, runtime.hashkey(SB)	
	hashkey[1] |= 1
  0x401e94		488b058d1b0c00		MOVQ runtime.hashkey+8(SB), AX	
  0x401e9b		4883c801		ORQ $0x1, AX			
  0x401e9f		488905821b0c00		MOVQ AX, runtime.hashkey+8(SB)	
	hashkey[2] |= 1
  0x401ea6		488b05831b0c00		MOVQ runtime.hashkey+16(SB), AX	
  0x401ead		4883c801		ORQ $0x1, AX			
  0x401eb1		488905781b0c00		MOVQ AX, runtime.hashkey+16(SB)	
	hashkey[3] |= 1
  0x401eb8		488b05791b0c00		MOVQ runtime.hashkey+24(SB), AX	
  0x401ebf		4883c801		ORQ $0x1, AX			
  0x401ec3		4889056e1b0c00		MOVQ AX, runtime.hashkey+24(SB)	
}
  0x401eca		488b6c2418		MOVQ 0x18(SP), BP	
  0x401ecf		4883c420		ADDQ $0x20, SP		
  0x401ed3		c3			RET			
func alginit() {
  0x401ed4		e897260400		CALL runtime.morestack_noctxt(SB)	
  0x401ed9		e992feffff		JMP runtime.alginit(SB)			

TEXT runtime.atomicstorep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/atomic_pointer.go
func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {
  0x401ee0		4883ec18		SUBQ $0x18, SP		
  0x401ee4		48896c2410		MOVQ BP, 0x10(SP)	
  0x401ee9		488d6c2410		LEAQ 0x10(SP), BP	
  0x401eee		488b442420		MOVQ 0x20(SP), AX	
	writebarrierptr_prewrite((*uintptr)(ptr), uintptr(new))
  0x401ef3		48890424		MOVQ AX, 0(SP)		
func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {
  0x401ef7		488b4c2428		MOVQ 0x28(SP), CX	
	writebarrierptr_prewrite((*uintptr)(ptr), uintptr(new))
  0x401efc		48894c2408		MOVQ CX, 0x8(SP)				
  0x401f01		e8fa9a0000		CALL runtime.writebarrierptr_prewrite(SB)	
  0x401f06		488b442428		MOVQ 0x28(SP), AX				
  0x401f0b		488b4c2420		MOVQ 0x20(SP), CX				
	atomic.StorepNoWB(noescape(ptr), new)
  0x401f10		488701			XCHGQ AX, 0(CX)		
}
  0x401f13		488b6c2410		MOVQ 0x10(SP), BP	
  0x401f18		4883c418		ADDQ $0x18, SP		
  0x401f1c		c3			RET			

TEXT runtime.casp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/atomic_pointer.go
func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {
  0x401f20		4883ec18		SUBQ $0x18, SP		
  0x401f24		48896c2410		MOVQ BP, 0x10(SP)	
  0x401f29		488d6c2410		LEAQ 0x10(SP), BP	
  0x401f2e		488b442420		MOVQ 0x20(SP), AX	
	writebarrierptr_prewrite((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))
  0x401f33		48890424		MOVQ AX, 0(SP)		
func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {
  0x401f37		488b4c2430		MOVQ 0x30(SP), CX	
	writebarrierptr_prewrite((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))
  0x401f3c		48894c2408		MOVQ CX, 0x8(SP)				
  0x401f41		e8ba9a0000		CALL runtime.writebarrierptr_prewrite(SB)	
func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {
  0x401f46		488b442428		MOVQ 0x28(SP), AX	
  0x401f4b		488b4c2420		MOVQ 0x20(SP), CX	
  0x401f50		488b542430		MOVQ 0x30(SP), DX	
	return atomic.Casp1((*unsafe.Pointer)(noescape(unsafe.Pointer(ptr))), noescape(old), new)
  0x401f55		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)	
  0x401f5a		0f94c0			SETE AL			
  0x401f5d		88442438		MOVB AL, 0x38(SP)	
  0x401f61		488b6c2410		MOVQ 0x10(SP), BP	
  0x401f66		4883c418		ADDQ $0x18, SP		
  0x401f6a		c3			RET			

TEXT runtime.mmap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgo_mmap.go
func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int) {
  0x401f70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401f79		483b6110		CMPQ 0x10(CX), SP	
  0x401f7d		0f8654010000		JBE 0x4020d7		
  0x401f83		4883ec70		SUBQ $0x70, SP		
  0x401f87		48896c2468		MOVQ BP, 0x68(SP)	
  0x401f8c		488d6c2468		LEAQ 0x68(SP), BP	
	if _cgo_mmap != nil {
  0x401f91		488b0538560a00		MOVQ _cgo_mmap(SB), AX	
  0x401f98		4885c0			TESTQ AX, AX		
  0x401f9b		0f84cb000000		JE 0x40206c		
		var ret uintptr
  0x401fa1		48c744243000000000	MOVQ $0x0, 0x30(SP)	
		systemstack(func() {
  0x401faa		0f57c0			XORPS X0, X0			
  0x401fad		0f11442438		MOVUPS X0, 0x38(SP)		
  0x401fb2		0f11442448		MOVUPS X0, 0x48(SP)		
  0x401fb7		0f11442458		MOVUPS X0, 0x58(SP)		
  0x401fbc		488d059df80300		LEAQ runtime.mmap.func1(SB), AX	
  0x401fc3		4889442438		MOVQ AX, 0x38(SP)		
  0x401fc8		488b442478		MOVQ 0x78(SP), AX		
  0x401fcd		4889442440		MOVQ AX, 0x40(SP)		
  0x401fd2		488b842480000000	MOVQ 0x80(SP), AX		
  0x401fda		4889442448		MOVQ AX, 0x48(SP)		
  0x401fdf		8b842488000000		MOVL 0x88(SP), AX		
  0x401fe6		89442450		MOVL AX, 0x50(SP)		
  0x401fea		8b84248c000000		MOVL 0x8c(SP), AX		
  0x401ff1		89442454		MOVL AX, 0x54(SP)		
  0x401ff5		8b842490000000		MOVL 0x90(SP), AX		
  0x401ffc		89442458		MOVL AX, 0x58(SP)		
  0x402000		8b842494000000		MOVL 0x94(SP), AX		
  0x402007		8944245c		MOVL AX, 0x5c(SP)		
  0x40200b		488d442430		LEAQ 0x30(SP), AX		
  0x402010		4889442460		MOVQ AX, 0x60(SP)		
  0x402015		488d442438		LEAQ 0x38(SP), AX		
  0x40201a		48890424		MOVQ AX, 0(SP)			
  0x40201e		e8fd230400		CALL runtime.systemstack(SB)	
		if ret < 4096 {
  0x402023		488b442430		MOVQ 0x30(SP), AX	
  0x402028		483d00100000		CMPQ $0x1000, AX	
  0x40202e		731e			JAE 0x40204e		
			return nil, int(ret)
  0x402030		48c784249800000000000000	MOVQ $0x0, 0x98(SP)	
  0x40203c		48898424a0000000		MOVQ AX, 0xa0(SP)	
  0x402044		488b6c2468			MOVQ 0x68(SP), BP	
  0x402049		4883c470			ADDQ $0x70, SP		
  0x40204d		c3				RET			
		return unsafe.Pointer(ret), 0
  0x40204e		4889842498000000		MOVQ AX, 0x98(SP)	
  0x402056		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)	
  0x402062		488b6c2468			MOVQ 0x68(SP), BP	
  0x402067		4883c470			ADDQ $0x70, SP		
  0x40206b		c3				RET			
  0x40206c		488b442478			MOVQ 0x78(SP), AX	
	return sysMmap(addr, n, prot, flags, fd, off)
  0x402071		48890424		MOVQ AX, 0(SP)			
  0x402075		488b842480000000	MOVQ 0x80(SP), AX		
  0x40207d		4889442408		MOVQ AX, 0x8(SP)		
  0x402082		8b842488000000		MOVL 0x88(SP), AX		
  0x402089		89442410		MOVL AX, 0x10(SP)		
  0x40208d		8b84248c000000		MOVL 0x8c(SP), AX		
  0x402094		89442414		MOVL AX, 0x14(SP)		
  0x402098		8b842490000000		MOVL 0x90(SP), AX		
  0x40209f		89442418		MOVL AX, 0x18(SP)		
  0x4020a3		8b842494000000		MOVL 0x94(SP), AX		
  0x4020aa		8944241c		MOVL AX, 0x1c(SP)		
  0x4020ae		e81d5c0400		CALL runtime.sysMmap(SB)	
  0x4020b3		488b442420		MOVQ 0x20(SP), AX		
  0x4020b8		488b4c2428		MOVQ 0x28(SP), CX		
  0x4020bd		4889842498000000	MOVQ AX, 0x98(SP)		
  0x4020c5		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x4020cd		488b6c2468		MOVQ 0x68(SP), BP		
  0x4020d2		4883c470		ADDQ $0x70, SP			
  0x4020d6		c3			RET				
func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int) {
  0x4020d7		e894240400		CALL runtime.morestack_noctxt(SB)	
  0x4020dc		e98ffeffff		JMP runtime.mmap(SB)			

TEXT runtime.munmap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgo_mmap.go
func munmap(addr unsafe.Pointer, n uintptr) {
  0x4020f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4020f9		483b6110		CMPQ 0x10(CX), SP	
  0x4020fd		7674			JBE 0x402173		
  0x4020ff		4883ec30		SUBQ $0x30, SP		
  0x402103		48896c2428		MOVQ BP, 0x28(SP)	
  0x402108		488d6c2428		LEAQ 0x28(SP), BP	
	if _cgo_munmap != nil {
  0x40210d		488b05c4540a00		MOVQ _cgo_munmap(SB), AX	
  0x402114		4885c0			TESTQ AX, AX			
  0x402117		7438			JE 0x402151			
		systemstack(func() { callCgoMunmap(addr, n) })
  0x402119		488d05c0f70300		LEAQ runtime.munmap.func1(SB), AX	
  0x402120		4889442410		MOVQ AX, 0x10(SP)			
  0x402125		488b442438		MOVQ 0x38(SP), AX			
  0x40212a		4889442418		MOVQ AX, 0x18(SP)			
  0x40212f		488b442440		MOVQ 0x40(SP), AX			
  0x402134		4889442420		MOVQ AX, 0x20(SP)			
  0x402139		488d442410		LEAQ 0x10(SP), AX			
  0x40213e		48890424		MOVQ AX, 0(SP)				
  0x402142		e8d9220400		CALL runtime.systemstack(SB)		
		return
  0x402147		488b6c2428		MOVQ 0x28(SP), BP	
  0x40214c		4883c430		ADDQ $0x30, SP		
  0x402150		c3			RET			
  0x402151		488b442438		MOVQ 0x38(SP), AX	
	sysMunmap(addr, n)
  0x402156		48890424		MOVQ AX, 0(SP)			
  0x40215a		488b442440		MOVQ 0x40(SP), AX		
  0x40215f		4889442408		MOVQ AX, 0x8(SP)		
  0x402164		e8175c0400		CALL runtime.sysMunmap(SB)	
}
  0x402169		488b6c2428		MOVQ 0x28(SP), BP	
  0x40216e		4883c430		ADDQ $0x30, SP		
  0x402172		c3			RET			
func munmap(addr unsafe.Pointer, n uintptr) {
  0x402173		e8f8230400		CALL runtime.morestack_noctxt(SB)	
  0x402178		e973ffffff		JMP runtime.munmap(SB)			

TEXT runtime.rt_sigaction(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgo_sigaction.go
func rt_sigaction(sig uintptr, new, old *sigactiont, size uintptr) int32 {
  0x402180		4883ec60		SUBQ $0x60, SP		
  0x402184		48896c2458		MOVQ BP, 0x58(SP)	
  0x402189		488d6c2458		LEAQ 0x58(SP), BP	
	var ret int32
  0x40218e		c744242c00000000	MOVL $0x0, 0x2c(SP)	
	if _cgo_sigaction == nil || inForkedChild {
  0x402196		488b054b540a00		MOVQ _cgo_sigaction(SB), AX		
  0x40219d		4885c0			TESTQ AX, AX				
  0x4021a0		740b			JE 0x4021ad				
  0x4021a2		0fb605ff160c00		MOVZX runtime.inForkedChild(SB), AX	
  0x4021a9		84c0			TESTL AL, AL				
  0x4021ab		744c			JE 0x4021f9				
		ret = sysSigaction(sig, new, old, size)
  0x4021ad		488b442468		MOVQ 0x68(SP), AX		
  0x4021b2		48890424		MOVQ AX, 0(SP)			
  0x4021b6		488b442470		MOVQ 0x70(SP), AX		
  0x4021bb		4889442408		MOVQ AX, 0x8(SP)		
  0x4021c0		488b442478		MOVQ 0x78(SP), AX		
  0x4021c5		4889442410		MOVQ AX, 0x10(SP)		
  0x4021ca		488b842480000000	MOVQ 0x80(SP), AX		
  0x4021d2		4889442418		MOVQ AX, 0x18(SP)		
  0x4021d7		e824590400		CALL runtime.sysSigaction(SB)	
  0x4021dc		8b442420		MOVL 0x20(SP), AX		
  0x4021e0		8944242c		MOVL AX, 0x2c(SP)		
	return ret
  0x4021e4		8b44242c		MOVL 0x2c(SP), AX	
  0x4021e8		89842488000000		MOVL AX, 0x88(SP)	
  0x4021ef		488b6c2458		MOVQ 0x58(SP), BP	
  0x4021f4		4883c460		ADDQ $0x60, SP		
  0x4021f8		c3			RET			
		g := getg()
  0x4021f9		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
		sp := uintptr(unsafe.Pointer(&sig))
  0x402202		488d4c2468		LEAQ 0x68(SP), CX	
		case g == nil:
  0x402207		4885c0			TESTQ AX, AX		
  0x40220a		0f84dd000000		JE 0x4022ed		
		case sp < g.stack.lo || sp >= g.stack.hi:
  0x402210		488b10			MOVQ 0(AX), DX		
  0x402213		4839d1			CMPQ DX, CX		
  0x402216		736f			JAE 0x402287		
			ret = callCgoSigaction(sig, new, old)
  0x402218		488b442468		MOVQ 0x68(SP), AX			
  0x40221d		48890424		MOVQ AX, 0(SP)				
  0x402221		488b442470		MOVQ 0x70(SP), AX			
  0x402226		4889442408		MOVQ AX, 0x8(SP)			
  0x40222b		488b4c2478		MOVQ 0x78(SP), CX			
  0x402230		48894c2410		MOVQ CX, 0x10(SP)			
  0x402235		e8e6580400		CALL runtime.callCgoSigaction(SB)	
  0x40223a		8b442418		MOVL 0x18(SP), AX			
  0x40223e		8944242c		MOVL AX, 0x2c(SP)			
		if ret == EINVAL {
  0x402242		8b44242c		MOVL 0x2c(SP), AX	
  0x402246		83f816			CMPL $0x16, AX		
  0x402249		7599			JNE 0x4021e4		
			ret = sysSigaction(sig, new, old, size)
  0x40224b		488b442468		MOVQ 0x68(SP), AX		
  0x402250		48890424		MOVQ AX, 0(SP)			
  0x402254		488b442470		MOVQ 0x70(SP), AX		
  0x402259		4889442408		MOVQ AX, 0x8(SP)		
  0x40225e		488b442478		MOVQ 0x78(SP), AX		
  0x402263		4889442410		MOVQ AX, 0x10(SP)		
  0x402268		488b842480000000	MOVQ 0x80(SP), AX		
  0x402270		4889442418		MOVQ AX, 0x18(SP)		
  0x402275		e886580400		CALL runtime.sysSigaction(SB)	
  0x40227a		8b442420		MOVL 0x20(SP), AX		
  0x40227e		8944242c		MOVL AX, 0x2c(SP)		
  0x402282		e95dffffff		JMP 0x4021e4			
		case sp < g.stack.lo || sp >= g.stack.hi:
  0x402287		488b4008		MOVQ 0x8(AX), AX	
  0x40228b		4839c1			CMPQ AX, CX		
  0x40228e		7388			JAE 0x402218		
			systemstack(func() {
  0x402290		48c744243000000000	MOVQ $0x0, 0x30(SP)			
  0x402299		0f57c0			XORPS X0, X0				
  0x40229c		0f11442438		MOVUPS X0, 0x38(SP)			
  0x4022a1		0f11442448		MOVUPS X0, 0x48(SP)			
  0x4022a6		488d0583f60300		LEAQ runtime.rt_sigaction.func1(SB), AX	
  0x4022ad		4889442430		MOVQ AX, 0x30(SP)			
  0x4022b2		488d442468		LEAQ 0x68(SP), AX			
  0x4022b7		4889442438		MOVQ AX, 0x38(SP)			
  0x4022bc		488b442470		MOVQ 0x70(SP), AX			
  0x4022c1		4889442440		MOVQ AX, 0x40(SP)			
  0x4022c6		488b4c2478		MOVQ 0x78(SP), CX			
  0x4022cb		48894c2448		MOVQ CX, 0x48(SP)			
  0x4022d0		488d54242c		LEAQ 0x2c(SP), DX			
  0x4022d5		4889542450		MOVQ DX, 0x50(SP)			
  0x4022da		488d542430		LEAQ 0x30(SP), DX			
  0x4022df		48891424		MOVQ DX, 0(SP)				
  0x4022e3		e838210400		CALL runtime.systemstack(SB)		
		switch {
  0x4022e8		e955ffffff		JMP 0x402242		
			ret = callCgoSigaction(sig, new, old)
  0x4022ed		488b442468		MOVQ 0x68(SP), AX			
  0x4022f2		48890424		MOVQ AX, 0(SP)				
  0x4022f6		488b442470		MOVQ 0x70(SP), AX			
  0x4022fb		4889442408		MOVQ AX, 0x8(SP)			
  0x402300		488b4c2478		MOVQ 0x78(SP), CX			
  0x402305		48894c2410		MOVQ CX, 0x10(SP)			
  0x40230a		e811580400		CALL runtime.callCgoSigaction(SB)	
  0x40230f		8b442418		MOVL 0x18(SP), AX			
  0x402313		8944242c		MOVL AX, 0x2c(SP)			
		switch {
  0x402317		e926ffffff		JMP 0x402242		

TEXT runtime.cgocall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocall.go
func cgocall(fn, arg unsafe.Pointer) int32 {
  0x402320		4883ec30		SUBQ $0x30, SP		
  0x402324		48896c2428		MOVQ BP, 0x28(SP)	
  0x402329		488d6c2428		LEAQ 0x28(SP), BP	
	if !iscgo && GOOS != "solaris" && GOOS != "windows" {
  0x40232e		0fb60577150c00		MOVZX runtime.iscgo(SB), AX	
  0x402335		84c0			TESTL AL, AL			
  0x402337		0f84bf000000		JE 0x4023fc			
  0x40233d		488b442438		MOVQ 0x38(SP), AX		
	if fn == nil {
  0x402342		4885c0			TESTQ AX, AX		
  0x402345		0f8496000000		JE 0x4023e1		
	mp := getg().m
  0x40234b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x402354		488b4030		MOVQ 0x30(AX), AX	
  0x402358		4889442420		MOVQ AX, 0x20(SP)	
	mp.ncgocall++
  0x40235d		48ff8030010000		INCQ 0x130(AX)		
	mp.ncgo++
  0x402364		ff8038010000		INCL 0x138(AX)		
	mp.cgoCallers[0] = 0
  0x40236a		488b8840010000		MOVQ 0x140(AX), CX	
  0x402371		48c70100000000		MOVQ $0x0, 0(CX)	
	entersyscall(0)
  0x402378		c7042400000000		MOVL $0x0, 0(SP)		
  0x40237f		e82c740200		CALL runtime.entersyscall(SB)	
  0x402384		488b442420		MOVQ 0x20(SP), AX		
	mp.incgo = true
  0x402389		c6801901000001		MOVB $0x1, 0x119(AX)	
  0x402390		488b4c2438		MOVQ 0x38(SP), CX	
	errno := asmcgocall(fn, arg)
  0x402395		48890c24		MOVQ CX, 0(SP)			
  0x402399		488b542440		MOVQ 0x40(SP), DX		
  0x40239e		4889542408		MOVQ DX, 0x8(SP)		
  0x4023a3		e848380400		CALL runtime.asmcgocall(SB)	
  0x4023a8		8b442410		MOVL 0x10(SP), AX		
  0x4023ac		8944241c		MOVL AX, 0x1c(SP)		
  0x4023b0		488b4c2420		MOVQ 0x20(SP), CX		
	mp.incgo = false
  0x4023b5		c6811901000000		MOVB $0x0, 0x119(CX)	
	mp.ncgo--
  0x4023bc		838138010000ff		ADDL $-0x1, 0x138(CX)	
	exitsyscall(0)
  0x4023c3		c7042400000000		MOVL $0x0, 0(SP)		
  0x4023ca		e891770200		CALL runtime.exitsyscall(SB)	
	return errno
  0x4023cf		8b44241c		MOVL 0x1c(SP), AX	
  0x4023d3		89442448		MOVL AX, 0x48(SP)	
  0x4023d7		488b6c2428		MOVQ 0x28(SP), BP	
  0x4023dc		4883c430		ADDQ $0x30, SP		
  0x4023e0		c3			RET			
		throw("cgocall nil")
  0x4023e1		488d058c800600		LEAQ 0x6808c(IP), AX	
  0x4023e8		48890424		MOVQ AX, 0(SP)		
  0x4023ec		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x4023f5		e8d6ed0100		CALL runtime.throw(SB)	
  0x4023fa		0f0b			UD2			
		throw("cgocall unavailable")
  0x4023fc		488d05838a0600		LEAQ 0x68a83(IP), AX	
  0x402403		48890424		MOVQ AX, 0(SP)		
  0x402407		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x402410		e8bbed0100		CALL runtime.throw(SB)	
  0x402415		0f0b			UD2			

TEXT runtime.cgoIsGoPointer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocall.go
func cgoIsGoPointer(p unsafe.Pointer) bool {
  0x402420		488b442408		MOVQ 0x8(SP), AX	
	if p == nil {
  0x402425		4885c0			TESTQ AX, AX		
  0x402428		0f8403010000		JE 0x402531		
  0x40242e		4889c1			MOVQ AX, CX		
	if b == 0 || b < mheap_.arena_start || b >= mheap_.arena_used {
  0x402431		4885c0			TESTQ AX, AX		
  0x402434		757f			JNE 0x4024b5		
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x402436		488b053b520a00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x40243d		4885c0			TESTQ AX, AX		
  0x402440		746d			JE 0x4024af		
	return *p
  0x402442		488b5008		MOVQ 0x8(AX), DX	
  0x402446		488b00			MOVQ 0(AX), AX		
	for _, datap := range activeModules() {
  0x402449		31db			XORL BX, BX		
  0x40244b		eb06			JMP 0x402453		
  0x40244d		48ffc3			INCQ BX			
  0x402450		4c89c9			MOVQ R9, CX		
  0x402453		4839d3			CMPQ DX, BX		
  0x402456		7d51			JGE 0x4024a9		
  0x402458		488b34d8		MOVQ 0(AX)(BX*8), SI	
		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {
  0x40245c		488bbe80000000		MOVQ 0x80(SI), DI	
  0x402463		4c8b8688000000		MOVQ 0x88(SI), R8	
  0x40246a		4989c9			MOVQ CX, R9		
	return start <= uintptr(p) && uintptr(p) < end
  0x40246d		4839cf			CMPQ CX, DI		
  0x402470		7733			JA 0x4024a5		
  0x402472		4c39c1			CMPQ R8, CX		
  0x402475		400f92c7		SETB DI			
  0x402479		4084ff			TESTL DI, DI		
		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {
  0x40247c		751d			JNE 0x40249b		
  0x40247e		488bbe90000000		MOVQ 0x90(SI), DI	
  0x402485		488bb698000000		MOVQ 0x98(SI), SI	
	return start <= uintptr(p) && uintptr(p) < end
  0x40248c		4839cf			CMPQ CX, DI		
  0x40248f		7710			JA 0x4024a1		
  0x402491		4839f1			CMPQ SI, CX		
  0x402494		0f92c1			SETB CL			
  0x402497		84c9			TESTL CL, CL		
		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {
  0x402499		74b2			JE 0x40244d		
			return true
  0x40249b		c644241001		MOVB $0x1, 0x10(SP)	
  0x4024a0		c3			RET			
  0x4024a1		31c9			XORL CX, CX		
	return start <= uintptr(p) && uintptr(p) < end
  0x4024a3		ebf2			JMP 0x402497		
  0x4024a5		31ff			XORL DI, DI		
  0x4024a7		ebd0			JMP 0x402479		
	return false
  0x4024a9		c644241000		MOVB $0x0, 0x10(SP)	
  0x4024ae		c3			RET			
  0x4024af		31d2			XORL DX, DX		
  0x4024b1		31c0			XORL AX, AX		
	for _, datap := range activeModules() {
  0x4024b3		eb94			JMP 0x402449		
	if b == 0 || b < mheap_.arena_start || b >= mheap_.arena_used {
  0x4024b5		488b150cb10a00		MOVQ runtime.mheap_+4904(SB), DX	
  0x4024bc		4839d0			CMPQ DX, AX				
  0x4024bf		0f8271ffffff		JB 0x402436				
  0x4024c5		488b1d04b10a00		MOVQ runtime.mheap_+4912(SB), BX	
  0x4024cc		4839d8			CMPQ BX, AX				
  0x4024cf		0f8361ffffff		JAE 0x402436				
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x4024d5		488b1d14ae0a00		MOVQ runtime.mheap_+4176(SB), BX	
  0x4024dc		488b3505ae0a00		MOVQ runtime.mheap_+4168(SB), SI	
  0x4024e3		4889c7			MOVQ AX, DI				
  0x4024e6		4829d0			SUBQ DX, AX				
  0x4024e9		48c1e80d		SHRQ $0xd, AX				
  0x4024ed		4839d8			CMPQ BX, AX				
  0x4024f0		7345			JAE 0x402537				
  0x4024f2		488b04c6		MOVQ 0(SI)(AX*8), AX			
	if s == nil || b < s.base() {
  0x4024f6		4885c0			TESTQ AX, AX		
  0x4024f9		0f8437ffffff		JE 0x402436		
	return s.startAddr
  0x4024ff		488b5018		MOVQ 0x18(AX), DX	
	if s == nil || b < s.base() {
  0x402503		4839d7			CMPQ DX, DI		
  0x402506		0f822affffff		JB 0x402436		
	switch s.state {
  0x40250c		0fb65064		MOVZX 0x64(AX), DX	
	case mSpanInUse, _MSpanManual:
  0x402510		ffca			DECL DX			
  0x402512		80fa01			CMPL $0x1, DL		
  0x402515		0f871bffffff		JA 0x402436		
		return b < s.limit
  0x40251b		488b8080000000		MOVQ 0x80(AX), AX	
  0x402522		4839c7			CMPQ AX, DI		
	if inHeapOrStack(uintptr(p)) {
  0x402525		0f830bffffff		JAE 0x402436		
		return true
  0x40252b		c644241001		MOVB $0x1, 0x10(SP)	
  0x402530		c3			RET			
		return false
  0x402531		c644241000		MOVB $0x0, 0x10(SP)	
  0x402536		c3			RET			
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x402537		e804d50100		CALL runtime.panicindex(SB)	
  0x40253c		0f0b			UD2				

TEXT runtime.cgoCheckWriteBarrier(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
func cgoCheckWriteBarrier(dst *uintptr, src uintptr) {
  0x402540		4883ec30		SUBQ $0x30, SP		
  0x402544		48896c2428		MOVQ BP, 0x28(SP)	
  0x402549		488d6c2428		LEAQ 0x28(SP), BP	
  0x40254e		488b442440		MOVQ 0x40(SP), AX	
	if !cgoIsGoPointer(unsafe.Pointer(src)) {
  0x402553		48890424		MOVQ AX, 0(SP)			
  0x402557		e8c4feffff		CALL runtime.cgoIsGoPointer(SB)	
  0x40255c		0fb6442408		MOVZX 0x8(SP), AX		
  0x402561		84c0			TESTL AL, AL			
  0x402563		0f8495000000		JE 0x4025fe			
  0x402569		488b442438		MOVQ 0x38(SP), AX		
	if cgoIsGoPointer(unsafe.Pointer(dst)) {
  0x40256e		48890424		MOVQ AX, 0(SP)			
  0x402572		e8a9feffff		CALL runtime.cgoIsGoPointer(SB)	
  0x402577		0fb6442408		MOVZX 0x8(SP), AX		
  0x40257c		84c0			TESTL AL, AL			
  0x40257e		7574			JNE 0x4025f4			
	g := getg()
  0x402580		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if g == g.m.g0 || g == g.m.gsignal {
  0x402589		488b4830		MOVQ 0x30(AX), CX	
  0x40258d		488b11			MOVQ 0(CX), DX		
  0x402590		4839c2			CMPQ AX, DX		
  0x402593		750a			JNE 0x40259f		
		return
  0x402595		488b6c2428		MOVQ 0x28(SP), BP	
  0x40259a		4883c430		ADDQ $0x30, SP		
  0x40259e		c3			RET			
	if g == g.m.g0 || g == g.m.gsignal {
  0x40259f		488b5150		MOVQ 0x50(CX), DX	
  0x4025a3		4839c2			CMPQ AX, DX		
  0x4025a6		74ed			JE 0x402595		
	if g.m.mallocing != 0 {
  0x4025a8		8b81e8000000		MOVL 0xe8(CX), AX	
  0x4025ae		85c0			TESTL AX, AX		
  0x4025b0		740a			JE 0x4025bc		
		return
  0x4025b2		488b6c2428		MOVQ 0x28(SP), BP	
  0x4025b7		4883c430		ADDQ $0x30, SP		
  0x4025bb		c3			RET			
	systemstack(func() {
  0x4025bc		488d05ddf30300		LEAQ runtime.cgoCheckWriteBarrier.func1(SB), AX	
  0x4025c3		4889442410		MOVQ AX, 0x10(SP)				
  0x4025c8		488b442440		MOVQ 0x40(SP), AX				
  0x4025cd		4889442418		MOVQ AX, 0x18(SP)				
  0x4025d2		488b442438		MOVQ 0x38(SP), AX				
  0x4025d7		4889442420		MOVQ AX, 0x20(SP)				
  0x4025dc		488d442410		LEAQ 0x10(SP), AX				
  0x4025e1		48890424		MOVQ AX, 0(SP)					
  0x4025e5		e8361e0400		CALL runtime.systemstack(SB)			
}
  0x4025ea		488b6c2428		MOVQ 0x28(SP), BP	
  0x4025ef		4883c430		ADDQ $0x30, SP		
  0x4025f3		c3			RET			
		return
  0x4025f4		488b6c2428		MOVQ 0x28(SP), BP	
  0x4025f9		4883c430		ADDQ $0x30, SP		
  0x4025fd		c3			RET			
		return
  0x4025fe		488b6c2428		MOVQ 0x28(SP), BP	
  0x402603		4883c430		ADDQ $0x30, SP		
  0x402607		c3			RET			

TEXT runtime.cgoCheckMemmove(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
func cgoCheckMemmove(typ *_type, dst, src unsafe.Pointer, off, size uintptr) {
  0x402610		4883ec28		SUBQ $0x28, SP		
  0x402614		48896c2420		MOVQ BP, 0x20(SP)	
  0x402619		488d6c2420		LEAQ 0x20(SP), BP	
  0x40261e		488b442430		MOVQ 0x30(SP), AX	
	if typ.kind&kindNoPointers != 0 {
  0x402623		0fb64817		MOVZX 0x17(AX), CX	
  0x402627		f6c180			TESTL $0x80, CL		
  0x40262a		7578			JNE 0x4026a4		
  0x40262c		488b442440		MOVQ 0x40(SP), AX	
	if !cgoIsGoPointer(src) {
  0x402631		48890424		MOVQ AX, 0(SP)			
  0x402635		e8e6fdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x40263a		0fb6442408		MOVZX 0x8(SP), AX		
  0x40263f		84c0			TESTL AL, AL			
  0x402641		7457			JE 0x40269a			
  0x402643		488b442438		MOVQ 0x38(SP), AX		
	if cgoIsGoPointer(dst) {
  0x402648		48890424		MOVQ AX, 0(SP)			
  0x40264c		e8cffdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x402651		0fb6442408		MOVZX 0x8(SP), AX		
  0x402656		84c0			TESTL AL, AL			
  0x402658		740a			JE 0x402664			
		return
  0x40265a		488b6c2420		MOVQ 0x20(SP), BP	
  0x40265f		4883c428		ADDQ $0x28, SP		
  0x402663		c3			RET			
  0x402664		488b442430		MOVQ 0x30(SP), AX	
	cgoCheckTypedBlock(typ, src, off, size)
  0x402669		48890424		MOVQ AX, 0(SP)				
  0x40266d		488b442440		MOVQ 0x40(SP), AX			
  0x402672		4889442408		MOVQ AX, 0x8(SP)			
  0x402677		488b442448		MOVQ 0x48(SP), AX			
  0x40267c		4889442410		MOVQ AX, 0x10(SP)			
  0x402681		488b442450		MOVQ 0x50(SP), AX			
  0x402686		4889442418		MOVQ AX, 0x18(SP)			
  0x40268b		e800010000		CALL runtime.cgoCheckTypedBlock(SB)	
}
  0x402690		488b6c2420		MOVQ 0x20(SP), BP	
  0x402695		4883c428		ADDQ $0x28, SP		
  0x402699		c3			RET			
		return
  0x40269a		488b6c2420		MOVQ 0x20(SP), BP	
  0x40269f		4883c428		ADDQ $0x28, SP		
  0x4026a3		c3			RET			
		return
  0x4026a4		488b6c2420		MOVQ 0x20(SP), BP	
  0x4026a9		4883c428		ADDQ $0x28, SP		
  0x4026ad		c3			RET			

TEXT runtime.cgoCheckSliceCopy(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
func cgoCheckSliceCopy(typ *_type, dst, src slice, n int) {
  0x4026b0		4883ec38		SUBQ $0x38, SP		
  0x4026b4		48896c2430		MOVQ BP, 0x30(SP)	
  0x4026b9		488d6c2430		LEAQ 0x30(SP), BP	
  0x4026be		488b442440		MOVQ 0x40(SP), AX	
	if typ.kind&kindNoPointers != 0 {
  0x4026c3		0fb64817		MOVZX 0x17(AX), CX	
  0x4026c7		f6c180			TESTL $0x80, CL		
  0x4026ca		0f85ac000000		JNE 0x40277c		
  0x4026d0		488b442460		MOVQ 0x60(SP), AX	
	if !cgoIsGoPointer(src.array) {
  0x4026d5		48890424		MOVQ AX, 0(SP)			
  0x4026d9		e842fdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x4026de		0fb6442408		MOVZX 0x8(SP), AX		
  0x4026e3		84c0			TESTL AL, AL			
  0x4026e5		0f8487000000		JE 0x402772			
  0x4026eb		488b442448		MOVQ 0x48(SP), AX		
	if cgoIsGoPointer(dst.array) {
  0x4026f0		48890424		MOVQ AX, 0(SP)			
  0x4026f4		e827fdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x4026f9		0fb6442408		MOVZX 0x8(SP), AX		
  0x4026fe		84c0			TESTL AL, AL			
  0x402700		7566			JNE 0x402768			
  0x402702		31c0			XORL AX, AX			
  0x402704		488b4c2460		MOVQ 0x60(SP), CX		
	for i := 0; i < n; i++ {
  0x402709		eb49			JMP 0x402754		
  0x40270b		4889442420		MOVQ AX, 0x20(SP)	
  0x402710		48894c2428		MOVQ CX, 0x28(SP)	
  0x402715		488b442440		MOVQ 0x40(SP), AX	
		cgoCheckTypedBlock(typ, p, 0, typ.size)
  0x40271a		488b10			MOVQ 0(AX), DX				
  0x40271d		4889542418		MOVQ DX, 0x18(SP)			
  0x402722		48890424		MOVQ AX, 0(SP)				
  0x402726		48894c2408		MOVQ CX, 0x8(SP)			
  0x40272b		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x402734		e857000000		CALL runtime.cgoCheckTypedBlock(SB)	
  0x402739		488b442420		MOVQ 0x20(SP), AX			
	for i := 0; i < n; i++ {
  0x40273e		48ffc0			INCQ AX			
  0x402741		488b4c2440		MOVQ 0x40(SP), CX	
		p = add(p, typ.size)
  0x402746		488b11			MOVQ 0(CX), DX		
  0x402749		488b5c2428		MOVQ 0x28(SP), BX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40274e		4801da			ADDQ BX, DX		
  0x402751		4889d1			MOVQ DX, CX		
	for i := 0; i < n; i++ {
  0x402754		488b542478		MOVQ 0x78(SP), DX	
  0x402759		4839d0			CMPQ DX, AX		
  0x40275c		7cad			JL 0x40270b		
  0x40275e		488b6c2430		MOVQ 0x30(SP), BP	
  0x402763		4883c438		ADDQ $0x38, SP		
  0x402767		c3			RET			
		return
  0x402768		488b6c2430		MOVQ 0x30(SP), BP	
  0x40276d		4883c438		ADDQ $0x38, SP		
  0x402771		c3			RET			
		return
  0x402772		488b6c2430		MOVQ 0x30(SP), BP	
  0x402777		4883c438		ADDQ $0x38, SP		
  0x40277b		c3			RET			
		return
  0x40277c		488b6c2430		MOVQ 0x30(SP), BP	
  0x402781		4883c438		ADDQ $0x38, SP		
  0x402785		c3			RET			

TEXT runtime.cgoCheckTypedBlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
func cgoCheckTypedBlock(typ *_type, src unsafe.Pointer, off, size uintptr) {
  0x402790		4883ec68		SUBQ $0x68, SP		
  0x402794		48896c2460		MOVQ BP, 0x60(SP)	
  0x402799		488d6c2460		LEAQ 0x60(SP), BP	
  0x40279e		488b442470		MOVQ 0x70(SP), AX	
	if typ.ptrdata <= off {
  0x4027a3		488b5008		MOVQ 0x8(AX), DX	
  0x4027a7		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x4027af		4839da			CMPQ BX, DX		
  0x4027b2		0f86b0020000		JBE 0x402a68		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x4027b8		4829da			SUBQ BX, DX		
  0x4027bb		488bb42488000000	MOVQ 0x88(SP), SI	
  0x4027c3		4839d6			CMPQ DX, SI		
  0x4027c6		0f8694020000		JBE 0x402a60		
	if typ.kind&kindGCProg == 0 {
  0x4027cc		0fb67017		MOVZX 0x17(AX), SI	
  0x4027d0		40f6c640		TESTL $0x40, SI		
  0x4027d4		0f845b020000		JE 0x402a35		
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x4027da		488b35974e0a00		MOVQ runtime.modulesSlice(SB), SI	
	if p == nil {
  0x4027e1		4885f6			TESTQ SI, SI		
  0x4027e4		0f8442020000		JE 0x402a2c		
	return *p
  0x4027ea		488b7e08		MOVQ 0x8(SI), DI	
  0x4027ee		488b36			MOVQ 0(SI), SI		
	for _, datap := range activeModules() {
  0x4027f1		4c8b442478		MOVQ 0x78(SP), R8	
  0x4027f6		31c9			XORL CX, CX		
  0x4027f8		eb06			JMP 0x402800		
  0x4027fa		48ffc1			INCQ CX			
  0x4027fd		4d89e0			MOVQ R12, R8		
  0x402800		4839f9			CMPQ DI, CX		
  0x402803		0f8dca000000		JGE 0x4028d3		
  0x402809		4c8b0cce		MOVQ 0(SI)(CX*8), R9	
		if cgoInRange(src, datap.data, datap.edata) {
  0x40280d		4d8b9180000000		MOVQ 0x80(R9), R10	
  0x402814		4d8b9988000000		MOVQ 0x88(R9), R11	
  0x40281b		4d89c4			MOVQ R8, R12		
	return start <= uintptr(p) && uintptr(p) < end
  0x40281e		4d39c2			CMPQ R8, R10		
  0x402821		0f87a4000000		JA 0x4028cb		
  0x402827		4d39d8			CMPQ R11, R8		
  0x40282a		410f92c3		SETB R11		
  0x40282e		4584db			TESTL R11, R11		
		if cgoInRange(src, datap.data, datap.edata) {
  0x402831		755e			JNE 0x402891		
		if cgoInRange(src, datap.bss, datap.ebss) {
  0x402833		4d8b9190000000		MOVQ 0x90(R9), R10	
  0x40283a		4d8b9998000000		MOVQ 0x98(R9), R11	
	return start <= uintptr(p) && uintptr(p) < end
  0x402841		4d39c2			CMPQ R8, R10		
  0x402844		7746			JA 0x40288c		
  0x402846		4d39d8			CMPQ R11, R8		
  0x402849		410f92c3		SETB R11		
  0x40284d		4584db			TESTL R11, R11		
		if cgoInRange(src, datap.bss, datap.ebss) {
  0x402850		74a8			JE 0x4027fa		
			cgoCheckBits(add(src, -boff), datap.gcbssmask.bytedata, off+boff, size)
  0x402852		498b81a8010000		MOVQ 0x1a8(R9), AX	
  0x402859		4889442408		MOVQ AX, 0x8(SP)	
  0x40285e		4c89d0			MOVQ R10, AX		
  0x402861		4d29c2			SUBQ R8, R10		
	return unsafe.Pointer(uintptr(p) + x)
  0x402864		4b8d0c22		LEAQ 0(R10)(R12*1), CX	
			cgoCheckBits(add(src, -boff), datap.gcbssmask.bytedata, off+boff, size)
  0x402868		48890c24		MOVQ CX, 0(SP)		
			boff := uintptr(src) - datap.bss
  0x40286c		4929c0			SUBQ AX, R8		
			cgoCheckBits(add(src, -boff), datap.gcbssmask.bytedata, off+boff, size)
  0x40286f		498d0418		LEAQ 0(R8)(BX*1), AX		
  0x402873		4889442410		MOVQ AX, 0x10(SP)		
  0x402878		4889542418		MOVQ DX, 0x18(SP)		
  0x40287d		e8fe010000		CALL runtime.cgoCheckBits(SB)	
			return
  0x402882		488b6c2460		MOVQ 0x60(SP), BP	
  0x402887		4883c468		ADDQ $0x68, SP		
  0x40288b		c3			RET			
  0x40288c		4531db			XORL R11, R11		
	return start <= uintptr(p) && uintptr(p) < end
  0x40288f		ebbc			JMP 0x40284d		
			cgoCheckBits(add(src, -doff), datap.gcdatamask.bytedata, off+doff, size)
  0x402891		498b8198010000		MOVQ 0x198(R9), AX	
  0x402898		4889442408		MOVQ AX, 0x8(SP)	
  0x40289d		4c89d0			MOVQ R10, AX		
  0x4028a0		4d29c2			SUBQ R8, R10		
	return unsafe.Pointer(uintptr(p) + x)
  0x4028a3		4b8d0c22		LEAQ 0(R10)(R12*1), CX	
			cgoCheckBits(add(src, -doff), datap.gcdatamask.bytedata, off+doff, size)
  0x4028a7		48890c24		MOVQ CX, 0(SP)		
			doff := uintptr(src) - datap.data
  0x4028ab		4929c0			SUBQ AX, R8		
			cgoCheckBits(add(src, -doff), datap.gcdatamask.bytedata, off+doff, size)
  0x4028ae		498d0418		LEAQ 0(R8)(BX*1), AX		
  0x4028b2		4889442410		MOVQ AX, 0x10(SP)		
  0x4028b7		4889542418		MOVQ DX, 0x18(SP)		
  0x4028bc		e8bf010000		CALL runtime.cgoCheckBits(SB)	
			return
  0x4028c1		488b6c2460		MOVQ 0x60(SP), BP	
  0x4028c6		4883c468		ADDQ $0x68, SP		
  0x4028ca		c3			RET			
  0x4028cb		4531db			XORL R11, R11		
	return start <= uintptr(p) && uintptr(p) < end
  0x4028ce		e95bffffff		JMP 0x40282e		
  0x4028d3		4c89c6			MOVQ R8, SI		
	aoff := uintptr(src) - mheap_.arena_start
  0x4028d6		4c2b05ebac0a00		SUBQ runtime.mheap_+4904(SB), R8	
  0x4028dd		4c89c7			MOVQ R8, DI				
	idx := aoff >> _PageShift
  0x4028e0		49c1e80d		SHRQ $0xd, R8		
	s := mheap_.spans[idx]
  0x4028e4		4c8b0d05aa0a00		MOVQ runtime.mheap_+4176(SB), R9	
  0x4028eb		4c8b15f6a90a00		MOVQ runtime.mheap_+4168(SB), R10	
  0x4028f2		4d39c8			CMPQ R9, R8				
  0x4028f5		0f8377010000		JAE 0x402a72				
  0x4028fb		4f8b04c2		MOVQ 0(R10)(R8*8), R8			
	if s.state == _MSpanManual {
  0x4028ff		450fb64064		MOVZX 0x64(R8), R8	
  0x402904		4180f802		CMPL $0x2, R8		
  0x402908		0f84d0000000		JE 0x4029de		
  0x40290e		4889942488000000	MOVQ DX, 0x88(SP)	
  0x402916		4889f8			MOVQ DI, AX		
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x402919		48c1ef03		SHRQ $0x3, DI		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x40291d		4c8b0594ac0a00		MOVQ runtime.mheap_+4888(SB), R8	
  0x402924		48c1e805		SHRQ $0x5, AX				
  0x402928		4929c0			SUBQ AX, R8				
  0x40292b		498d40ff		LEAQ -0x1(R8), AX			
  0x40292f		4883e703		ANDQ $0x3, DI				
  0x402933		31c9			XORL CX, CX				
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x402935		eb04			JMP 0x40293b		
  0x402937		498d4908		LEAQ 0x8(R9), CX	
  0x40293b		4c8d041a		LEAQ 0(DX)(BX*1), R8	
  0x40293f		4c39c1			CMPQ R8, CX		
  0x402942		0f838c000000		JAE 0x4029d4		
	return uint32(*h.bitp) >> (h.shift & 31)
  0x402948		440fb600		MOVZX 0(AX), R8		
  0x40294c		4989c9			MOVQ CX, R9		
  0x40294f		89f9			MOVL DI, CX		
  0x402951		41d3e8			SHRL CL, R8		
		if i >= off && bits&bitPointer != 0 {
  0x402954		4939d9			CMPQ BX, R9		
  0x402957		7207			JB 0x402960		
  0x402959		410fbae000		BTL $0x0, R8		
  0x40295e		7211			JB 0x402971		
	if h.shift < 3*heapBitsShift {
  0x402960		83f903			CMPL $0x3, CX		
  0x402963		7305			JAE 0x40296a		
		return heapBits{h.bitp, h.shift + heapBitsShift}
  0x402965		8d7901			LEAL 0x1(CX), DI	
		hbits = hbits.next()
  0x402968		ebcd			JMP 0x402937		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40296a		48ffc8			DECQ AX			
  0x40296d		31ff			XORL DI, DI		
		hbits = hbits.next()
  0x40296f		ebc6			JMP 0x402937		
  0x402971		4c894c2428		MOVQ R9, 0x28(SP)	
  0x402976		4889442430		MOVQ AX, 0x30(SP)	
  0x40297b		894c2424		MOVL CX, 0x24(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x40297f		498d0431		LEAQ 0(R9)(SI*1), AX	
			v := *(*unsafe.Pointer)(add(src, i))
  0x402983		8400			TESTB AL, 0(AX)		
  0x402985		498b0431		MOVQ 0(R9)(SI*1), AX	
			if cgoIsGoPointer(v) {
  0x402989		48890424		MOVQ AX, 0(SP)			
  0x40298d		e88efaffff		CALL runtime.cgoIsGoPointer(SB)	
  0x402992		0fb6442408		MOVZX 0x8(SP), AX		
  0x402997		84c0			TESTL AL, AL			
  0x402999		7527			JNE 0x4029c2			
  0x40299b		488b442430		MOVQ 0x30(SP), AX		
  0x4029a0		8b4c2424		MOVL 0x24(SP), CX		
  0x4029a4		488b942488000000	MOVQ 0x88(SP), DX		
  0x4029ac		488b9c2480000000	MOVQ 0x80(SP), BX		
  0x4029b4		488b742478		MOVQ 0x78(SP), SI		
  0x4029b9		89cf			MOVL CX, DI			
  0x4029bb		4c8b4c2428		MOVQ 0x28(SP), R9		
		hbits = hbits.next()
  0x4029c0		eb9e			JMP 0x402960		
				systemstack(func() {
  0x4029c2		488d051fb60600		LEAQ 0x6b61f(IP), AX		
  0x4029c9		48890424		MOVQ AX, 0(SP)			
  0x4029cd		e84e1a0400		CALL runtime.systemstack(SB)	
  0x4029d2		ebc7			JMP 0x40299b			
  0x4029d4		488b6c2460		MOVQ 0x60(SP), BP		
  0x4029d9		4883c468		ADDQ $0x68, SP			
  0x4029dd		c3			RET				
		systemstack(func() {
  0x4029de		48c744243800000000	MOVQ $0x0, 0x38(SP)				
  0x4029e7		0f57c0			XORPS X0, X0					
  0x4029ea		0f11442440		MOVUPS X0, 0x40(SP)				
  0x4029ef		0f11442450		MOVUPS X0, 0x50(SP)				
  0x4029f4		488d0d65f00300		LEAQ runtime.cgoCheckTypedBlock.func1(SB), CX	
  0x4029fb		48894c2438		MOVQ CX, 0x38(SP)				
  0x402a00		4889442440		MOVQ AX, 0x40(SP)				
  0x402a05		4889742448		MOVQ SI, 0x48(SP)				
  0x402a0a		48895c2450		MOVQ BX, 0x50(SP)				
  0x402a0f		4889542458		MOVQ DX, 0x58(SP)				
  0x402a14		488d442438		LEAQ 0x38(SP), AX				
  0x402a19		48890424		MOVQ AX, 0(SP)					
  0x402a1d		e8fe190400		CALL runtime.systemstack(SB)			
		return
  0x402a22		488b6c2460		MOVQ 0x60(SP), BP	
  0x402a27		4883c468		ADDQ $0x68, SP		
  0x402a2b		c3			RET			
  0x402a2c		31ff			XORL DI, DI		
  0x402a2e		31f6			XORL SI, SI		
	for _, datap := range activeModules() {
  0x402a30		e9bcfdffff		JMP 0x4027f1		
		cgoCheckBits(src, typ.gcdata, off, size)
  0x402a35		488b4020		MOVQ 0x20(AX), AX		
  0x402a39		4889442408		MOVQ AX, 0x8(SP)		
  0x402a3e		488b442478		MOVQ 0x78(SP), AX		
  0x402a43		48890424		MOVQ AX, 0(SP)			
  0x402a47		48895c2410		MOVQ BX, 0x10(SP)		
  0x402a4c		4889542418		MOVQ DX, 0x18(SP)		
  0x402a51		e82a000000		CALL runtime.cgoCheckBits(SB)	
		return
  0x402a56		488b6c2460		MOVQ 0x60(SP), BP	
  0x402a5b		4883c468		ADDQ $0x68, SP		
  0x402a5f		c3			RET			
  0x402a60		4889f2			MOVQ SI, DX		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x402a63		e964fdffff		JMP 0x4027cc		
		return
  0x402a68		488b6c2460		MOVQ 0x60(SP), BP	
  0x402a6d		4883c468		ADDQ $0x68, SP		
  0x402a71		c3			RET			
	s := mheap_.spans[idx]
  0x402a72		e8c9cf0100		CALL runtime.panicindex(SB)	
  0x402a77		0f0b			UD2				

TEXT runtime.cgoCheckBits(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
func cgoCheckBits(src unsafe.Pointer, gcbits *byte, off, size uintptr) {
  0x402a80		4883ec40		SUBQ $0x40, SP		
  0x402a84		48896c2438		MOVQ BP, 0x38(SP)	
  0x402a89		488d6c2438		LEAQ 0x38(SP), BP	
  0x402a8e		488b442458		MOVQ 0x58(SP), AX	
  0x402a93		4889c1			MOVQ AX, CX		
	skipMask := off / sys.PtrSize / 8
  0x402a96		48c1e806		SHRQ $0x6, AX		
  0x402a9a		4889c2			MOVQ AX, DX		
	skipBytes := skipMask * sys.PtrSize * 8
  0x402a9d		48c1e006		SHLQ $0x6, AX		
	off -= skipBytes
  0x402aa1		4829c1			SUBQ AX, CX		
  0x402aa4		488b5c2460		MOVQ 0x60(SP), BX	
	size += off
  0x402aa9		4801cb			ADDQ CX, BX		
  0x402aac		48895c2460		MOVQ BX, 0x60(SP)	
  0x402ab1		488b742450		MOVQ 0x50(SP), SI	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x402ab6		4801f2			ADDQ SI, DX		
  0x402ab9		488b742448		MOVQ 0x48(SP), SI	
	return unsafe.Pointer(uintptr(p) + x)
  0x402abe		4801f0			ADDQ SI, AX		
  0x402ac1		4889442430		MOVQ AX, 0x30(SP)	
  0x402ac6		31f6			XORL SI, SI		
  0x402ac8		31ff			XORL DI, DI		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x402aca		eb04			JMP 0x402ad0		
  0x402acc		4883c608		ADDQ $0x8, SI		
  0x402ad0		4839de			CMPQ BX, SI		
  0x402ad3		0f8384000000		JAE 0x402b5d		
		if i&(sys.PtrSize*8-1) == 0 {
  0x402ad9		48f7c63f000000		TESTQ $0x3f, SI		
  0x402ae0		7577			JNE 0x402b59		
			bits = uint32(*ptrmask)
  0x402ae2		0fb63a			MOVZX 0(DX), DI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x402ae5		48ffc2			INCQ DX			
		if off > 0 {
  0x402ae8		4885c9			TESTQ CX, CX		
  0x402aeb		7606			JBE 0x402af3		
			off -= sys.PtrSize
  0x402aed		4883c1f8		ADDQ $-0x8, CX		
  0x402af1		ebd9			JMP 0x402acc		
			if bits&1 != 0 {
  0x402af3		0fbae700		BTL $0x0, DI		
  0x402af7		73d3			JAE 0x402acc		
  0x402af9		4889742418		MOVQ SI, 0x18(SP)	
  0x402afe		897c2414		MOVL DI, 0x14(SP)	
  0x402b02		48894c2420		MOVQ CX, 0x20(SP)	
  0x402b07		4889542428		MOVQ DX, 0x28(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x402b0c		488d0c30		LEAQ 0(AX)(SI*1), CX	
				v := *(*unsafe.Pointer)(add(src, i))
  0x402b10		8401			TESTB AL, 0(CX)		
  0x402b12		488b0c06		MOVQ 0(SI)(AX*1), CX	
				if cgoIsGoPointer(v) {
  0x402b16		48890c24		MOVQ CX, 0(SP)			
  0x402b1a		e801f9ffff		CALL runtime.cgoIsGoPointer(SB)	
  0x402b1f		0fb6442408		MOVZX 0x8(SP), AX		
  0x402b24		84c0			TESTL AL, AL			
  0x402b26		751f			JNE 0x402b47			
  0x402b28		488b442430		MOVQ 0x30(SP), AX		
  0x402b2d		488b4c2420		MOVQ 0x20(SP), CX		
  0x402b32		488b542428		MOVQ 0x28(SP), DX		
  0x402b37		488b5c2460		MOVQ 0x60(SP), BX		
  0x402b3c		488b742418		MOVQ 0x18(SP), SI		
  0x402b41		8b7c2414		MOVL 0x14(SP), DI		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x402b45		eb85			JMP 0x402acc		
					systemstack(func() {
  0x402b47		488d0592b40600		LEAQ 0x6b492(IP), AX		
  0x402b4e		48890424		MOVQ AX, 0(SP)			
  0x402b52		e8c9180400		CALL runtime.systemstack(SB)	
  0x402b57		ebcf			JMP 0x402b28			
			bits >>= 1
  0x402b59		d1ef			SHRL $0x1, DI		
  0x402b5b		eb8b			JMP 0x402ae8		
  0x402b5d		488b6c2438		MOVQ 0x38(SP), BP	
  0x402b62		4883c440		ADDQ $0x40, SP		
  0x402b66		c3			RET			

TEXT runtime.cgoCheckUsingType(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
func cgoCheckUsingType(typ *_type, src unsafe.Pointer, off, size uintptr) {
  0x402b70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402b79		483b6118		CMPQ 0x18(CX), SP	
  0x402b7d		0f8640020000		JBE 0x402dc3		
  0x402b83		4883ec70		SUBQ $0x70, SP		
  0x402b87		48896c2468		MOVQ BP, 0x68(SP)	
  0x402b8c		488d6c2468		LEAQ 0x68(SP), BP	
  0x402b91		488b442478		MOVQ 0x78(SP), AX	
	if typ.kind&kindNoPointers != 0 {
  0x402b96		0fb64817		MOVZX 0x17(AX), CX	
  0x402b9a		f6c180			TESTL $0x80, CL		
  0x402b9d		0f85fb010000		JNE 0x402d9e		
	if typ.ptrdata <= off {
  0x402ba3		488b5008		MOVQ 0x8(AX), DX	
  0x402ba7		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x402baf		4839da			CMPQ BX, DX		
  0x402bb2		0f86dc010000		JBE 0x402d94		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x402bb8		4829da			SUBQ BX, DX		
  0x402bbb		488bb42490000000	MOVQ 0x90(SP), SI	
  0x402bc3		4839d6			CMPQ DX, SI		
  0x402bc6		0f86c0010000		JBE 0x402d8c		
	if typ.kind&kindGCProg == 0 {
  0x402bcc		f6c140			TESTL $0x40, CL		
  0x402bcf		0f8489010000		JE 0x402d5e		
	switch typ.kind & kindMask {
  0x402bd5		83e11f			ANDL $0x1f, CX		
	case kindArray:
  0x402bd8		80f911			CMPL $0x11, CL		
  0x402bdb		0f85b1000000		JNE 0x402c92		
  0x402be1		31c9			XORL CX, CX		
  0x402be3		488bb42480000000	MOVQ 0x80(SP), SI	
		for i := uintptr(0); i < at.len; i++ {
  0x402beb		eb06			JMP 0x402bf3		
  0x402bed		48ffc1			INCQ CX			
			size -= checked
  0x402bf0		4c29c2			SUBQ R8, DX		
		for i := uintptr(0); i < at.len; i++ {
  0x402bf3		488b7840		MOVQ 0x40(AX), DI	
  0x402bf7		4839f9			CMPQ DI, CX		
  0x402bfa		0f8388000000		JAE 0x402c88		
			if off < at.elem.size {
  0x402c00		488b7830		MOVQ 0x30(AX), DI	
  0x402c04		4c8b07			MOVQ 0(DI), R8		
  0x402c07		4c39c3			CMPQ R8, BX		
  0x402c0a		722f			JB 0x402c3b		
			src = add(src, at.elem.size)
  0x402c0c		488b7830		MOVQ 0x30(AX), DI	
  0x402c10		488b3f			MOVQ 0(DI), DI		
	return unsafe.Pointer(uintptr(p) + x)
  0x402c13		4801fe			ADDQ DI, SI		
			if skipped > at.elem.size {
  0x402c16		4839fb			CMPQ DI, BX		
  0x402c19		7618			JBE 0x402c33		
  0x402c1b		4989f8			MOVQ DI, R8		
			checked := at.elem.size - skipped
  0x402c1e		4929f8			SUBQ DI, R8		
			off -= skipped
  0x402c21		4829fb			SUBQ DI, BX		
			if size <= checked {
  0x402c24		4c39c2			CMPQ R8, DX		
  0x402c27		77c4			JA 0x402bed		
				return
  0x402c29		488b6c2468		MOVQ 0x68(SP), BP	
  0x402c2e		4883c470		ADDQ $0x70, SP		
  0x402c32		c3			RET			
  0x402c33		4989f8			MOVQ DI, R8		
  0x402c36		4889df			MOVQ BX, DI		
			if skipped > at.elem.size {
  0x402c39		ebe3			JMP 0x402c1e		
  0x402c3b		48894c2430		MOVQ CX, 0x30(SP)	
  0x402c40		4889942490000000	MOVQ DX, 0x90(SP)	
  0x402c48		4889742450		MOVQ SI, 0x50(SP)	
  0x402c4d		48895c2428		MOVQ BX, 0x28(SP)	
				cgoCheckUsingType(at.elem, src, off, size)
  0x402c52		48893c24		MOVQ DI, 0(SP)				
  0x402c56		4889742408		MOVQ SI, 0x8(SP)			
  0x402c5b		48895c2410		MOVQ BX, 0x10(SP)			
  0x402c60		4889542418		MOVQ DX, 0x18(SP)			
  0x402c65		e806ffffff		CALL runtime.cgoCheckUsingType(SB)	
  0x402c6a		488b442478		MOVQ 0x78(SP), AX			
  0x402c6f		488b4c2430		MOVQ 0x30(SP), CX			
  0x402c74		488b942490000000	MOVQ 0x90(SP), DX			
  0x402c7c		488b5c2428		MOVQ 0x28(SP), BX			
  0x402c81		488b742450		MOVQ 0x50(SP), SI			
  0x402c86		eb84			JMP 0x402c0c				
  0x402c88		488b6c2468		MOVQ 0x68(SP), BP			
  0x402c8d		4883c470		ADDQ $0x70, SP				
  0x402c91		c3			RET					
	case kindStruct:
  0x402c92		80f919			CMPL $0x19, CL		
  0x402c95		0f850d010000		JNE 0x402da8		
		for _, f := range st.fields {
  0x402c9b		488b4840		MOVQ 0x40(AX), CX	
  0x402c9f		48894c2440		MOVQ CX, 0x40(SP)	
  0x402ca4		488b4038		MOVQ 0x38(AX), AX	
  0x402ca8		31f6			XORL SI, SI		
  0x402caa		488bbc2480000000	MOVQ 0x80(SP), DI	
  0x402cb2		eb0a			JMP 0x402cbe		
  0x402cb4		4883c018		ADDQ $0x18, AX		
  0x402cb8		48ffc6			INCQ SI			
			size -= checked
  0x402cbb		4c29ca			SUBQ R9, DX		
		for _, f := range st.fields {
  0x402cbe		4839ce			CMPQ CX, SI		
  0x402cc1		7dc5			JGE 0x402c88		
  0x402cc3		4c8b4008		MOVQ 0x8(AX), R8	
			if off < f.typ.size {
  0x402cc7		4d8b08			MOVQ 0(R8), R9		
  0x402cca		4c39cb			CMPQ R9, BX		
  0x402ccd		722b			JB 0x402cfa		
			src = add(src, f.typ.size)
  0x402ccf		4d8b00			MOVQ 0(R8), R8		
	return unsafe.Pointer(uintptr(p) + x)
  0x402cd2		4c01c7			ADDQ R8, DI		
			if skipped > f.typ.size {
  0x402cd5		4c39c3			CMPQ R8, BX		
  0x402cd8		7618			JBE 0x402cf2		
  0x402cda		4d89c1			MOVQ R8, R9		
			checked := f.typ.size - skipped
  0x402cdd		4d29c1			SUBQ R8, R9		
			off -= skipped
  0x402ce0		4c29c3			SUBQ R8, BX		
			if size <= checked {
  0x402ce3		4c39ca			CMPQ R9, DX		
  0x402ce6		77cc			JA 0x402cb4		
				return
  0x402ce8		488b6c2468		MOVQ 0x68(SP), BP	
  0x402ced		4883c470		ADDQ $0x70, SP		
  0x402cf1		c3			RET			
  0x402cf2		4d89c1			MOVQ R8, R9		
  0x402cf5		4989d8			MOVQ BX, R8		
			if skipped > f.typ.size {
  0x402cf8		ebe3			JMP 0x402cdd		
  0x402cfa		4889742438		MOVQ SI, 0x38(SP)	
  0x402cff		4c89442460		MOVQ R8, 0x60(SP)	
  0x402d04		4889942490000000	MOVQ DX, 0x90(SP)	
  0x402d0c		48897c2448		MOVQ DI, 0x48(SP)	
  0x402d11		48895c2420		MOVQ BX, 0x20(SP)	
  0x402d16		4889442458		MOVQ AX, 0x58(SP)	
				cgoCheckUsingType(f.typ, src, off, size)
  0x402d1b		4c890424		MOVQ R8, 0(SP)				
  0x402d1f		48897c2408		MOVQ DI, 0x8(SP)			
  0x402d24		48895c2410		MOVQ BX, 0x10(SP)			
  0x402d29		4889542418		MOVQ DX, 0x18(SP)			
  0x402d2e		e83dfeffff		CALL runtime.cgoCheckUsingType(SB)	
  0x402d33		488b442458		MOVQ 0x58(SP), AX			
  0x402d38		488b4c2440		MOVQ 0x40(SP), CX			
  0x402d3d		488b942490000000	MOVQ 0x90(SP), DX			
  0x402d45		488b5c2420		MOVQ 0x20(SP), BX			
  0x402d4a		488b742438		MOVQ 0x38(SP), SI			
  0x402d4f		488b7c2448		MOVQ 0x48(SP), DI			
  0x402d54		4c8b442460		MOVQ 0x60(SP), R8			
  0x402d59		e971ffffff		JMP 0x402ccf				
		cgoCheckBits(src, typ.gcdata, off, size)
  0x402d5e		488b4020		MOVQ 0x20(AX), AX		
  0x402d62		4889442408		MOVQ AX, 0x8(SP)		
  0x402d67		488b842480000000	MOVQ 0x80(SP), AX		
  0x402d6f		48890424		MOVQ AX, 0(SP)			
  0x402d73		48895c2410		MOVQ BX, 0x10(SP)		
  0x402d78		4889542418		MOVQ DX, 0x18(SP)		
  0x402d7d		e8fefcffff		CALL runtime.cgoCheckBits(SB)	
		return
  0x402d82		488b6c2468		MOVQ 0x68(SP), BP	
  0x402d87		4883c470		ADDQ $0x70, SP		
  0x402d8b		c3			RET			
  0x402d8c		4889f2			MOVQ SI, DX		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x402d8f		e938feffff		JMP 0x402bcc		
		return
  0x402d94		488b6c2468		MOVQ 0x68(SP), BP	
  0x402d99		4883c470		ADDQ $0x70, SP		
  0x402d9d		c3			RET			
		return
  0x402d9e		488b6c2468		MOVQ 0x68(SP), BP	
  0x402da3		4883c470		ADDQ $0x70, SP		
  0x402da7		c3			RET			
		throw("can't happen")
  0x402da8		488d052f780600		LEAQ 0x6782f(IP), AX	
  0x402daf		48890424		MOVQ AX, 0(SP)		
  0x402db3		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x402dbc		e80fe40100		CALL runtime.throw(SB)	
  0x402dc1		0f0b			UD2			
func cgoCheckUsingType(typ *_type, src unsafe.Pointer, off, size uintptr) {
  0x402dc3		e8383f0300		CALL runtime.morestackc(SB)		
  0x402dc8		e9a3fdffff		JMP runtime.cgoCheckUsingType(SB)	

TEXT runtime.makechan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func makechan(t *chantype, size int) *hchan {
  0x402dd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402dd9		483b6110		CMPQ 0x10(CX), SP	
  0x402ddd		0f8644020000		JBE 0x403027		
  0x402de3		4883ec38		SUBQ $0x38, SP		
  0x402de7		48896c2430		MOVQ BP, 0x30(SP)	
  0x402dec		488d6c2430		LEAQ 0x30(SP), BP	
  0x402df1		488b4c2440		MOVQ 0x40(SP), CX	
	elem := t.elem
  0x402df6		488b4930		MOVQ 0x30(CX), CX	
	if elem.size >= 1<<16 {
  0x402dfa		488b11			MOVQ 0(CX), DX		
  0x402dfd		4881fa00000100		CMPQ $0x10000, DX	
  0x402e04		0f8302020000		JAE 0x40300c		
	if hchanSize%maxAlign != 0 || elem.align > maxAlign {
  0x402e0a		0fb65915		MOVZX 0x15(CX), BX	
  0x402e0e		80fb08			CMPL $0x8, BL		
  0x402e11		0f87da010000		JA 0x402ff1		
  0x402e17		488b5c2448		MOVQ 0x48(SP), BX	
	if size < 0 || uintptr(size) > maxSliceCap(elem.size) || uintptr(size)*elem.size > _MaxMem-hchanSize {
  0x402e1c		4885db			TESTQ BX, BX		
  0x402e1f		0f8cae010000		JL 0x402fd3		
	if elemsize < uintptr(len(maxElems)) {
  0x402e25		4883fa21		CMPQ $0x21, DX		
  0x402e29		0f838a010000		JAE 0x402fb9		
		return maxElems[elemsize]
  0x402e2f		488d054a270a00		LEAQ runtime.maxElems(SB), AX	
  0x402e36		488b04d0		MOVQ 0(AX)(DX*8), AX		
	if size < 0 || uintptr(size) > maxSliceCap(elem.size) || uintptr(size)*elem.size > _MaxMem-hchanSize {
  0x402e3a		4839c3			CMPQ AX, BX		
  0x402e3d		0f8790010000		JA 0x402fd3		
  0x402e43		4889d0			MOVQ DX, AX		
  0x402e46		480fafd3		IMULQ BX, DX		
  0x402e4a		48be9fffffff7f000000	MOVQ $0x7fffffff9f, SI	
  0x402e54		4839f2			CMPQ SI, DX		
  0x402e57		0f8776010000		JA 0x402fd3		
  0x402e5d		48894c2420		MOVQ CX, 0x20(SP)	
  0x402e62		4885db			TESTQ BX, BX		
	case size == 0 || elem.size == 0:
  0x402e65		0f8581000000		JNE 0x402eec		
		c = (*hchan)(mallocgc(hchanSize, nil, true))
  0x402e6b		48c7042460000000	MOVQ $0x60, 0(SP)		
  0x402e73		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x402e7c		c644241001		MOVB $0x1, 0x10(SP)		
  0x402e81		e88a770000		CALL runtime.mallocgc(SB)	
  0x402e86		488b442418		MOVQ 0x18(SP), AX		
		c.buf = unsafe.Pointer(c)
  0x402e8b		8400			TESTB AL, 0(AX)				
  0x402e8d		8b0d7d0b0c00		MOVL runtime.writeBarrier(SB), CX	
  0x402e93		488d7810		LEAQ 0x10(AX), DI			
  0x402e97		85c9			TESTL CX, CX				
  0x402e99		754a			JNE 0x402ee5				
  0x402e9b		48894010		MOVQ AX, 0x10(AX)			
  0x402e9f		488b4c2420		MOVQ 0x20(SP), CX			
	c.elemsize = uint16(elem.size)
  0x402ea4		488b11			MOVQ 0(CX), DX		
  0x402ea7		66895018		MOVW DX, 0x18(AX)	
	c.elemtype = elem
  0x402eab		8b155f0b0c00		MOVL runtime.writeBarrier(SB), DX	
  0x402eb1		488d7820		LEAQ 0x20(AX), DI			
  0x402eb5		85d2			TESTL DX, DX				
  0x402eb7		751c			JNE 0x402ed5				
  0x402eb9		48894820		MOVQ CX, 0x20(AX)			
  0x402ebd		488b4c2448		MOVQ 0x48(SP), CX			
	c.dataqsiz = uint(size)
  0x402ec2		48894808		MOVQ CX, 0x8(AX)	
	return c
  0x402ec6		4889442450		MOVQ AX, 0x50(SP)	
  0x402ecb		488b6c2430		MOVQ 0x30(SP), BP	
  0x402ed0		4883c438		ADDQ $0x38, SP		
  0x402ed4		c3			RET			
  0x402ed5		4889c2			MOVQ AX, DX		
  0x402ed8		4889c8			MOVQ CX, AX		
	c.elemtype = elem
  0x402edb		e8c0390400		CALL runtime.gcWriteBarrier(SB)	
  0x402ee0		4889d0			MOVQ DX, AX			
  0x402ee3		ebd8			JMP 0x402ebd			
		c.buf = unsafe.Pointer(c)
  0x402ee5		e8b6390400		CALL runtime.gcWriteBarrier(SB)	
  0x402eea		ebb3			JMP 0x402e9f			
	case size == 0 || elem.size == 0:
  0x402eec		4885c0			TESTQ AX, AX		
  0x402eef		0f8476ffffff		JE 0x402e6b		
	case elem.kind&kindNoPointers != 0:
  0x402ef5		0fb64117		MOVZX 0x17(CX), AX	
  0x402ef9		a880			TESTL $0x80, AL		
  0x402efb		7450			JE 0x402f4d		
		c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))
  0x402efd		488d4260		LEAQ 0x60(DX), AX		
  0x402f01		48890424		MOVQ AX, 0(SP)			
  0x402f05		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x402f0e		c644241001		MOVB $0x1, 0x10(SP)		
  0x402f13		e8f8760000		CALL runtime.mallocgc(SB)	
  0x402f18		488b442418		MOVQ 0x18(SP), AX		
		c.buf = add(unsafe.Pointer(c), hchanSize)
  0x402f1d		8400			TESTB AL, 0(AX)				
  0x402f1f		8b0deb0a0c00		MOVL runtime.writeBarrier(SB), CX	
  0x402f25		488d7810		LEAQ 0x10(AX), DI			
	return unsafe.Pointer(uintptr(p) + x)
  0x402f29		488d5060		LEAQ 0x60(AX), DX	
		c.buf = add(unsafe.Pointer(c), hchanSize)
  0x402f2d		85c9			TESTL CX, CX			
  0x402f2f		7509			JNE 0x402f3a			
  0x402f31		48895010		MOVQ DX, 0x10(AX)		
  0x402f35		e965ffffff		JMP 0x402e9f			
  0x402f3a		4889c1			MOVQ AX, CX			
  0x402f3d		4889d0			MOVQ DX, AX			
  0x402f40		e85b390400		CALL runtime.gcWriteBarrier(SB)	
  0x402f45		4889c8			MOVQ CX, AX			
  0x402f48		e952ffffff		JMP 0x402e9f			
		c = new(hchan)
  0x402f4d		488d05ec270600		LEAQ 0x627ec(IP), AX		
  0x402f54		48890424		MOVQ AX, 0(SP)			
  0x402f58		e8c3810000		CALL runtime.newobject(SB)	
  0x402f5d		488b442408		MOVQ 0x8(SP), AX		
  0x402f62		4889442428		MOVQ AX, 0x28(SP)		
  0x402f67		488b4c2420		MOVQ 0x20(SP), CX		
		c.buf = mallocgc(uintptr(size)*elem.size, elem, true)
  0x402f6c		488b11			MOVQ 0(CX), DX				
  0x402f6f		488b5c2448		MOVQ 0x48(SP), BX			
  0x402f74		480fafd3		IMULQ BX, DX				
  0x402f78		48891424		MOVQ DX, 0(SP)				
  0x402f7c		48894c2408		MOVQ CX, 0x8(SP)			
  0x402f81		c644241001		MOVB $0x1, 0x10(SP)			
  0x402f86		e885760000		CALL runtime.mallocgc(SB)		
  0x402f8b		8b057f0a0c00		MOVL runtime.writeBarrier(SB), AX	
  0x402f91		488b4c2428		MOVQ 0x28(SP), CX			
  0x402f96		488d7910		LEAQ 0x10(CX), DI			
  0x402f9a		488b542418		MOVQ 0x18(SP), DX			
  0x402f9f		85c0			TESTL AX, AX				
  0x402fa1		750c			JNE 0x402faf				
  0x402fa3		48895110		MOVQ DX, 0x10(CX)			
  0x402fa7		4889c8			MOVQ CX, AX				
	switch {
  0x402faa		e9f0feffff		JMP 0x402e9f		
  0x402faf		4889d0			MOVQ DX, AX		
		c.buf = mallocgc(uintptr(size)*elem.size, elem, true)
  0x402fb2		e8e9380400		CALL runtime.gcWriteBarrier(SB)	
  0x402fb7		ebee			JMP 0x402fa7			
	return _MaxMem / elemsize
  0x402fb9		48b8ffffffff7f000000	MOVQ $0x7fffffffff, AX	
  0x402fc3		4889d6			MOVQ DX, SI		
  0x402fc6		31d2			XORL DX, DX		
  0x402fc8		48f7f6			DIVQ SI			
  0x402fcb		4889f2			MOVQ SI, DX		
	if size < 0 || uintptr(size) > maxSliceCap(elem.size) || uintptr(size)*elem.size > _MaxMem-hchanSize {
  0x402fce		e967feffff		JMP 0x402e3a		
		panic(plainError("makechan: size out of range"))
  0x402fd3		488d0566800500		LEAQ 0x58066(IP), AX			
  0x402fda		48890424		MOVQ AX, 0(SP)				
  0x402fde		488d055b1d0700		LEAQ runtime.statictmp_1(SB), AX	
  0x402fe5		4889442408		MOVQ AX, 0x8(SP)			
  0x402fea		e841da0100		CALL runtime.gopanic(SB)		
  0x402fef		0f0b			UD2					
		throw("makechan: bad alignment")
  0x402ff1		488d05c7860600		LEAQ 0x686c7(IP), AX	
  0x402ff8		48890424		MOVQ AX, 0(SP)		
  0x402ffc		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x403005		e8c6e10100		CALL runtime.throw(SB)	
  0x40300a		0f0b			UD2			
		throw("makechan: invalid channel element type")
  0x40300c		488d05a7a00600		LEAQ 0x6a0a7(IP), AX	
  0x403013		48890424		MOVQ AX, 0(SP)		
  0x403017		48c744240826000000	MOVQ $0x26, 0x8(SP)	
  0x403020		e8abe10100		CALL runtime.throw(SB)	
  0x403025		0f0b			UD2			
func makechan(t *chantype, size int) *hchan {
  0x403027		e844150400		CALL runtime.morestack_noctxt(SB)	
  0x40302c		e99ffdffff		JMP runtime.makechan(SB)		

TEXT runtime.chansend1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func chansend1(c *hchan, elem unsafe.Pointer) {
  0x403040		4883ec30		SUBQ $0x30, SP		
  0x403044		48896c2428		MOVQ BP, 0x28(SP)	
  0x403049		488d6c2428		LEAQ 0x28(SP), BP	
  0x40304e		488b442438		MOVQ 0x38(SP), AX	
	chansend(c, elem, true, getcallerpc())
  0x403053		48890424		MOVQ AX, 0(SP)		
func chansend1(c *hchan, elem unsafe.Pointer) {
  0x403057		488b442440		MOVQ 0x40(SP), AX	
	chansend(c, elem, true, getcallerpc())
  0x40305c		4889442408		MOVQ AX, 0x8(SP)		
  0x403061		c644241001		MOVB $0x1, 0x10(SP)		
  0x403066		488b442430		MOVQ 0x30(SP), AX		
  0x40306b		4889442418		MOVQ AX, 0x18(SP)		
  0x403070		e80b000000		CALL runtime.chansend(SB)	
}
  0x403075		488b6c2428		MOVQ 0x28(SP), BP	
  0x40307a		4883c430		ADDQ $0x30, SP		
  0x40307e		c3			RET			

TEXT runtime.chansend(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x403080		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x403089		483b6110		CMPQ 0x10(CX), SP	
  0x40308d		0f861e060000		JBE 0x4036b1		
  0x403093		4881ec80000000		SUBQ $0x80, SP		
  0x40309a		48896c2478		MOVQ BP, 0x78(SP)	
  0x40309f		488d6c2478		LEAQ 0x78(SP), BP	
  0x4030a4		488b842488000000	MOVQ 0x88(SP), AX	
	if c == nil {
  0x4030ac		4885c0			TESTQ AX, AX		
  0x4030af		0f840d050000		JE 0x4035c2		
  0x4030b5		0fb68c2498000000	MOVZX 0x98(SP), CX	
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x4030bd		84c9			TESTL CL, CL		
	if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
  0x4030bf		753b			JNE 0x4030fc		
  0x4030c1		8b501c			MOVL 0x1c(AX), DX	
  0x4030c4		85d2			TESTL DX, DX		
  0x4030c6		7534			JNE 0x4030fc		
  0x4030c8		488b5008		MOVQ 0x8(AX), DX	
  0x4030cc		4885d2			TESTQ DX, DX		
  0x4030cf		750c			JNE 0x4030dd		
  0x4030d1		488b5838		MOVQ 0x38(AX), BX	
  0x4030d5		4885db			TESTQ BX, BX		
  0x4030d8		740d			JE 0x4030e7		
  0x4030da		4885d2			TESTQ DX, DX		
		(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {
  0x4030dd		761d			JBE 0x4030fc		
  0x4030df		488b18			MOVQ 0(AX), BX		
  0x4030e2		4839d3			CMPQ DX, BX		
  0x4030e5		7515			JNE 0x4030fc		
		return false
  0x4030e7		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x4030ef		488b6c2478		MOVQ 0x78(SP), BP	
  0x4030f4		4881c480000000		ADDQ $0x80, SP		
  0x4030fb		c3			RET			
	if blockprofilerate > 0 {
  0x4030fc		488b1525080c00		MOVQ runtime.blockprofilerate(SB), DX	
  0x403103		4885d2			TESTQ DX, DX				
  0x403106		0f87a0040000		JA 0x4035ac				
  0x40310c		31d2			XORL DX, DX				
  0x40310e		4889542430		MOVQ DX, 0x30(SP)			
	lock(&c.lock)
  0x403113		488d4858		LEAQ 0x58(AX), CX	
  0x403117		48894c2460		MOVQ CX, 0x60(SP)	
  0x40311c		48890c24		MOVQ CX, 0(SP)		
  0x403120		e8fb630000		CALL runtime.lock(SB)	
  0x403125		488b842488000000	MOVQ 0x88(SP), AX	
	if c.closed != 0 {
  0x40312d		8b481c			MOVL 0x1c(AX), CX	
  0x403130		85c9			TESTL CX, CX		
  0x403132		0f8503050000		JNE 0x40363b		
	if sg := c.recvq.dequeue(); sg != nil {
  0x403138		488d4838		LEAQ 0x38(AX), CX			
  0x40313c		48890c24		MOVQ CX, 0(SP)				
  0x403140		e82b130000		CALL runtime.(*waitq).dequeue(SB)	
  0x403145		488b442408		MOVQ 0x8(SP), AX			
  0x40314a		4885c0			TESTQ AX, AX				
  0x40314d		0f85fd030000		JNE 0x403550				
  0x403153		488b842488000000	MOVQ 0x88(SP), AX			
	if c.qcount < c.dataqsiz {
  0x40315b		488b08			MOVQ 0(AX), CX		
  0x40315e		488b5008		MOVQ 0x8(AX), DX	
  0x403162		4839d1			CMPQ DX, CX		
  0x403165		0f826c030000		JB 0x4034d7		
  0x40316b		0fb68c2498000000	MOVZX 0x98(SP), CX	
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x403173		84c9			TESTL CL, CL		
	if !block {
  0x403175		7523			JNE 0x40319a		
  0x403177		488b442460		MOVQ 0x60(SP), AX	
		unlock(&c.lock)
  0x40317c		48890424		MOVQ AX, 0(SP)		
  0x403180		e83b650000		CALL runtime.unlock(SB)	
		return false
  0x403185		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x40318d		488b6c2478		MOVQ 0x78(SP), BP	
  0x403192		4881c480000000		ADDQ $0x80, SP		
  0x403199		c3			RET			
	gp := getg()
  0x40319a		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4031a3		4889442440		MOVQ AX, 0x40(SP)	
	mysg := acquireSudog()
  0x4031a8		e883fe0100		CALL runtime.acquireSudog(SB)	
  0x4031ad		488b0424		MOVQ 0(SP), AX			
	mysg.releasetime = 0
  0x4031b1		48c7403000000000	MOVQ $0x0, 0x30(AX)	
  0x4031b9		488b4c2430		MOVQ 0x30(SP), CX	
	if t0 != 0 {
  0x4031be		4885c9			TESTQ CX, CX		
  0x4031c1		7408			JE 0x4031cb		
		mysg.releasetime = -1
  0x4031c3		48c74030ffffffff	MOVQ $-0x1, 0x30(AX)	
	mysg.elem = ep
  0x4031cb		8b153f080c00		MOVL runtime.writeBarrier(SB), DX	
  0x4031d1		488d7820		LEAQ 0x20(AX), DI			
	mysg.waitlink = nil
  0x4031d5		488d5848		LEAQ 0x48(AX), BX	
	mysg.elem = ep
  0x4031d9		85d2			TESTL DX, DX		
  0x4031db		0f85c2020000		JNE 0x4034a3		
  0x4031e1		488b942490000000	MOVQ 0x90(SP), DX	
  0x4031e9		48895020		MOVQ DX, 0x20(AX)	
	mysg.waitlink = nil
  0x4031ed		48c7404800000000	MOVQ $0x0, 0x48(AX)	
  0x4031f5		488b542440		MOVQ 0x40(SP), DX	
	mysg.g = gp
  0x4031fa		488910			MOVQ DX, 0(AX)		
	mysg.isSelect = false
  0x4031fd		c6400800		MOVB $0x0, 0x8(AX)	
	mysg.c = c
  0x403201		8b1d09080c00		MOVL runtime.writeBarrier(SB), BX	
  0x403207		488d7858		LEAQ 0x58(AX), DI			
  0x40320b		85db			TESTL BX, BX				
  0x40320d		0f8570020000		JNE 0x403483				
  0x403213		488b9c2488000000	MOVQ 0x88(SP), BX			
  0x40321b		48895858		MOVQ BX, 0x58(AX)			
	gp.waiting = mysg
  0x40321f		8402			TESTB AL, 0(DX)				
  0x403221		8b35e9070c00		MOVL runtime.writeBarrier(SB), SI	
  0x403227		4c8d8238010000		LEAQ 0x138(DX), R8			
	gp.param = nil
  0x40322e		4c8d8a88000000		LEAQ 0x88(DX), R9	
	sgp.next = nil
  0x403235		4c8d5010		LEAQ 0x10(AX), R10	
	gp.waiting = mysg
  0x403239		85f6			TESTL SI, SI		
  0x40323b		0f8515020000		JNE 0x403456		
  0x403241		48898238010000		MOVQ AX, 0x138(DX)	
	gp.param = nil
  0x403248		48c7828800000000000000	MOVQ $0x0, 0x88(DX)	
	sgp.next = nil
  0x403253		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	gp.waiting = mysg
  0x40325b		4889442438		MOVQ AX, 0x38(SP)	
  0x403260		48897c2458		MOVQ DI, 0x58(SP)	
  0x403265		4c89442450		MOVQ R8, 0x50(SP)	
  0x40326a		4c894c2448		MOVQ R9, 0x48(SP)	
	c.sendq.enqueue(mysg)
  0x40326f		488d7348		LEAQ 0x48(BX), SI	
	x := q.last
  0x403273		8406			TESTB AL, 0(SI)		
  0x403275		488b7350		MOVQ 0x50(BX), SI	
  0x403279		4c8d5350		LEAQ 0x50(BX), R10	
	if x == nil {
  0x40327d		4885f6			TESTQ SI, SI		
  0x403280		0f847e010000		JE 0x403404		
	sgp.prev = x
  0x403286		448b1d83070c00		MOVL runtime.writeBarrier(SB), R11	
  0x40328d		4c8d6018		LEAQ 0x18(AX), R12			
	x.next = sgp
  0x403291		4c8d6e10		LEAQ 0x10(SI), R13	
	sgp.prev = x
  0x403295		4585db			TESTL R11, R11		
  0x403298		0f853a010000		JNE 0x4033d8		
  0x40329e		48897018		MOVQ SI, 0x18(AX)	
	x.next = sgp
  0x4032a2		48894610		MOVQ AX, 0x10(SI)	
	q.last = sgp
  0x4032a6		48894350		MOVQ AX, 0x50(BX)	
	sgp.prev = x
  0x4032aa		488b442460		MOVQ 0x60(SP), AX	
	goparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)
  0x4032af		48890424		MOVQ AX, 0(SP)			
  0x4032b3		488d054b6e0600		LEAQ 0x66e4b(IP), AX		
  0x4032ba		4889442408		MOVQ AX, 0x8(SP)		
  0x4032bf		48c744241009000000	MOVQ $0x9, 0x10(SP)		
  0x4032c8		c644241816		MOVB $0x16, 0x18(SP)		
  0x4032cd		48c744242003000000	MOVQ $0x3, 0x20(SP)		
  0x4032d6		e885fc0100		CALL runtime.goparkunlock(SB)	
  0x4032db		488b442440		MOVQ 0x40(SP), AX		
	if mysg != gp.waiting {
  0x4032e0		488b8838010000		MOVQ 0x138(AX), CX	
  0x4032e7		488b542438		MOVQ 0x38(SP), DX	
  0x4032ec		4839ca			CMPQ CX, DX		
  0x4032ef		0f852b030000		JNE 0x403620		
	gp.waiting = nil
  0x4032f5		8b0d15070c00		MOVL runtime.writeBarrier(SB), CX	
  0x4032fb		85c9			TESTL CX, CX				
  0x4032fd		0f85be000000		JNE 0x4033c1				
  0x403303		48c7803801000000000000	MOVQ $0x0, 0x138(AX)			
	if gp.param == nil {
  0x40330e		488b8888000000		MOVQ 0x88(AX), CX	
  0x403315		4885c9			TESTQ CX, CX		
  0x403318		0f848b000000		JE 0x4033a9		
	gp.param = nil
  0x40331e		8b0dec060c00		MOVL runtime.writeBarrier(SB), CX	
  0x403324		85c9			TESTL CX, CX				
  0x403326		7573			JNE 0x40339b				
  0x403328		48c7808800000000000000	MOVQ $0x0, 0x88(AX)			
	if mysg.releasetime > 0 {
  0x403333		488b4a30		MOVQ 0x30(DX), CX	
  0x403337		4885c9			TESTQ CX, CX		
  0x40333a		7f3e			JG 0x40337a		
	mysg.c = nil
  0x40333c		8b0dce060c00		MOVL runtime.writeBarrier(SB), CX	
  0x403342		85c9			TESTL CX, CX				
  0x403344		7526			JNE 0x40336c				
  0x403346		48c7425800000000	MOVQ $0x0, 0x58(DX)			
	releaseSudog(mysg)
  0x40334e		48891424		MOVQ DX, 0(SP)			
  0x403352		e869000200		CALL runtime.releaseSudog(SB)	
	return true
  0x403357		c68424a800000001	MOVB $0x1, 0xa8(SP)	
  0x40335f		488b6c2478		MOVQ 0x78(SP), BP	
  0x403364		4881c480000000		ADDQ $0x80, SP		
  0x40336b		c3			RET			
  0x40336c		488b7c2458		MOVQ 0x58(SP), DI	
	mysg.c = nil
  0x403371		31c0			XORL AX, AX			
  0x403373		e828350400		CALL runtime.gcWriteBarrier(SB)	
  0x403378		ebd4			JMP 0x40334e			
  0x40337a		488b442430		MOVQ 0x30(SP), AX		
		blockevent(mysg.releasetime-t0, 2)
  0x40337f		4829c1			SUBQ AX, CX			
  0x403382		48890c24		MOVQ CX, 0(SP)			
  0x403386		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x40338f		e85ca40100		CALL runtime.blockevent(SB)	
  0x403394		488b542438		MOVQ 0x38(SP), DX		
  0x403399		eba1			JMP 0x40333c			
  0x40339b		488b7c2448		MOVQ 0x48(SP), DI		
	gp.param = nil
  0x4033a0		31c0			XORL AX, AX			
  0x4033a2		e8f9340400		CALL runtime.gcWriteBarrier(SB)	
  0x4033a7		eb8a			JMP 0x403333			
  0x4033a9		488b842488000000	MOVQ 0x88(SP), AX		
		if c.closed == 0 {
  0x4033b1		8b401c			MOVL 0x1c(AX), AX	
  0x4033b4		85c0			TESTL AX, AX		
  0x4033b6		0f8449020000		JE 0x403605		
  0x4033bc		e926020000		JMP 0x4035e7		
  0x4033c1		488b7c2450		MOVQ 0x50(SP), DI	
  0x4033c6		4889c1			MOVQ AX, CX		
	gp.waiting = nil
  0x4033c9		31c0			XORL AX, AX			
  0x4033cb		e8d0340400		CALL runtime.gcWriteBarrier(SB)	
  0x4033d0		4889c8			MOVQ CX, AX			
  0x4033d3		e936ffffff		JMP 0x40330e			
  0x4033d8		4989fb			MOVQ DI, R11			
  0x4033db		4c89e7			MOVQ R12, DI			
  0x4033de		4989c6			MOVQ AX, R14			
  0x4033e1		4889f0			MOVQ SI, AX			
	sgp.prev = x
  0x4033e4		e8b7340400		CALL runtime.gcWriteBarrier(SB)	
  0x4033e9		4c89ef			MOVQ R13, DI			
  0x4033ec		4c89f0			MOVQ R14, AX			
	x.next = sgp
  0x4033ef		e8ac340400		CALL runtime.gcWriteBarrier(SB)	
  0x4033f4		4c89d7			MOVQ R10, DI			
	q.last = sgp
  0x4033f7		e8a4340400		CALL runtime.gcWriteBarrier(SB)	
  0x4033fc		4c89df			MOVQ R11, DI			
	sgp.prev = x
  0x4033ff		e9a6feffff		JMP 0x4032aa		
		sgp.prev = nil
  0x403404		8b3506060c00		MOVL runtime.writeBarrier(SB), SI	
  0x40340a		4c8d5818		LEAQ 0x18(AX), R11			
		q.first = sgp
  0x40340e		4c8d6348		LEAQ 0x48(BX), R12	
		sgp.prev = nil
  0x403412		85f6			TESTL SI, SI		
  0x403414		7515			JNE 0x40342b		
  0x403416		48c7401800000000	MOVQ $0x0, 0x18(AX)	
		q.first = sgp
  0x40341e		48894348		MOVQ AX, 0x48(BX)	
		q.last = sgp
  0x403422		48894350		MOVQ AX, 0x50(BX)	
		sgp.prev = nil
  0x403426		e97ffeffff		JMP 0x4032aa			
  0x40342b		4889fe			MOVQ DI, SI			
  0x40342e		4c89df			MOVQ R11, DI			
  0x403431		4989c5			MOVQ AX, R13			
  0x403434		31c0			XORL AX, AX			
  0x403436		e865340400		CALL runtime.gcWriteBarrier(SB)	
  0x40343b		4c89e7			MOVQ R12, DI			
  0x40343e		4c89e8			MOVQ R13, AX			
		q.first = sgp
  0x403441		e85a340400		CALL runtime.gcWriteBarrier(SB)	
  0x403446		4c89d7			MOVQ R10, DI			
		q.last = sgp
  0x403449		e852340400		CALL runtime.gcWriteBarrier(SB)	
  0x40344e		4889f7			MOVQ SI, DI			
		sgp.prev = nil
  0x403451		e954feffff		JMP 0x4032aa		
  0x403456		4889fe			MOVQ DI, SI		
  0x403459		4c89c7			MOVQ R8, DI		
	gp.waiting = mysg
  0x40345c		e83f340400		CALL runtime.gcWriteBarrier(SB)	
  0x403461		4c89cf			MOVQ R9, DI			
  0x403464		4989c3			MOVQ AX, R11			
	gp.param = nil
  0x403467		31c0			XORL AX, AX			
  0x403469		e832340400		CALL runtime.gcWriteBarrier(SB)	
  0x40346e		4c89d7			MOVQ R10, DI			
	sgp.next = nil
  0x403471		31c0			XORL AX, AX			
  0x403473		e828340400		CALL runtime.gcWriteBarrier(SB)	
  0x403478		4c89d8			MOVQ R11, AX			
  0x40347b		4889f7			MOVQ SI, DI			
	gp.waiting = mysg
  0x40347e		e9d8fdffff		JMP 0x40325b		
  0x403483		4889c3			MOVQ AX, BX		
  0x403486		488b842488000000	MOVQ 0x88(SP), AX	
	mysg.c = c
  0x40348e		e80d340400		CALL runtime.gcWriteBarrier(SB)	
  0x403493		4889d8			MOVQ BX, AX			
  0x403496		488b9c2488000000	MOVQ 0x88(SP), BX		
  0x40349e		e97cfdffff		JMP 0x40321f			
  0x4034a3		4889c2			MOVQ AX, DX			
  0x4034a6		488b842490000000	MOVQ 0x90(SP), AX		
	mysg.elem = ep
  0x4034ae		e8ed330400		CALL runtime.gcWriteBarrier(SB)	
  0x4034b3		4889df			MOVQ BX, DI			
	mysg.waitlink = nil
  0x4034b6		31c0			XORL AX, AX			
  0x4034b8		e8e3330400		CALL runtime.gcWriteBarrier(SB)	
  0x4034bd		4889d7			MOVQ DX, DI			
  0x4034c0		488b442440		MOVQ 0x40(SP), AX		
	mysg.g = gp
  0x4034c5		e8d6330400		CALL runtime.gcWriteBarrier(SB)	
  0x4034ca		4889f8			MOVQ DI, AX			
  0x4034cd		488b542440		MOVQ 0x40(SP), DX		
	mysg.elem = ep
  0x4034d2		e926fdffff		JMP 0x4031fd		
		qp := chanbuf(c, c.sendx)
  0x4034d7		488b4828		MOVQ 0x28(AX), CX	
		typedmemmove(c.elemtype, qp, ep)
  0x4034db		488b5020		MOVQ 0x20(AX), DX	
	return add(c.buf, uintptr(i)*uintptr(c.elemsize))
  0x4034df		0fb75818		MOVZX 0x18(AX), BX	
  0x4034e3		480fafcb		IMULQ BX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4034e7		48034810		ADDQ 0x10(AX), CX	
		typedmemmove(c.elemtype, qp, ep)
  0x4034eb		48891424		MOVQ DX, 0(SP)			
  0x4034ef		48894c2408		MOVQ CX, 0x8(SP)		
  0x4034f4		488b8c2490000000	MOVQ 0x90(SP), CX		
  0x4034fc		48894c2410		MOVQ CX, 0x10(SP)		
  0x403501		e88a850000		CALL runtime.typedmemmove(SB)	
  0x403506		488b842488000000	MOVQ 0x88(SP), AX		
		c.sendx++
  0x40350e		488b4828		MOVQ 0x28(AX), CX	
  0x403512		48ffc1			INCQ CX			
  0x403515		48894828		MOVQ CX, 0x28(AX)	
		if c.sendx == c.dataqsiz {
  0x403519		488b5008		MOVQ 0x8(AX), DX	
  0x40351d		4839d1			CMPQ DX, CX		
  0x403520		7508			JNE 0x40352a		
			c.sendx = 0
  0x403522		48c7402800000000	MOVQ $0x0, 0x28(AX)	
		c.qcount++
  0x40352a		48ff00			INCQ 0(AX)		
  0x40352d		488b442460		MOVQ 0x60(SP), AX	
		unlock(&c.lock)
  0x403532		48890424		MOVQ AX, 0(SP)		
  0x403536		e885610000		CALL runtime.unlock(SB)	
		return true
  0x40353b		c68424a800000001	MOVB $0x1, 0xa8(SP)	
  0x403543		488b6c2478		MOVQ 0x78(SP), BP	
  0x403548		4881c480000000		ADDQ $0x80, SP		
  0x40354f		c3			RET			
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x403550		488d0de9e50300		LEAQ runtime.chansend.func1(SB), CX	
  0x403557		48894c2468		MOVQ CX, 0x68(SP)			
  0x40355c		488b8c2488000000	MOVQ 0x88(SP), CX			
  0x403564		48894c2470		MOVQ CX, 0x70(SP)			
  0x403569		48890c24		MOVQ CX, 0(SP)				
  0x40356d		4889442408		MOVQ AX, 0x8(SP)			
  0x403572		488b842490000000	MOVQ 0x90(SP), AX			
  0x40357a		4889442410		MOVQ AX, 0x10(SP)			
  0x40357f		488d442468		LEAQ 0x68(SP), AX			
  0x403584		4889442418		MOVQ AX, 0x18(SP)			
  0x403589		48c744242003000000	MOVQ $0x3, 0x20(SP)			
  0x403592		e829010000		CALL runtime.send(SB)			
		return true
  0x403597		c68424a800000001	MOVB $0x1, 0xa8(SP)	
  0x40359f		488b6c2478		MOVQ 0x78(SP), BP	
  0x4035a4		4881c480000000		ADDQ $0x80, SP		
  0x4035ab		c3			RET			
		t0 = cputicks()
  0x4035ac		e83f270400		CALL runtime.cputicks(SB)	
  0x4035b1		488b1424		MOVQ 0(SP), DX			
  0x4035b5		488b842488000000	MOVQ 0x88(SP), AX		
  0x4035bd		e94cfbffff		JMP 0x40310e			
  0x4035c2		0fb6842498000000	MOVZX 0x98(SP), AX		
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x4035ca		84c0			TESTL AL, AL		
		if !block {
  0x4035cc		0f8595000000		JNE 0x403667		
			return false
  0x4035d2		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x4035da		488b6c2478		MOVQ 0x78(SP), BP	
  0x4035df		4881c480000000		ADDQ $0x80, SP		
  0x4035e6		c3			RET			
		panic(plainError("send on closed channel"))
  0x4035e7		488d05527a0500		LEAQ 0x57a52(IP), AX			
  0x4035ee		48890424		MOVQ AX, 0(SP)				
  0x4035f2		488d05d7170700		LEAQ runtime.statictmp_3(SB), AX	
  0x4035f9		4889442408		MOVQ AX, 0x8(SP)			
  0x4035fe		e82dd40100		CALL runtime.gopanic(SB)		
  0x403603		0f0b			UD2					
			throw("chansend: spurious wakeup")
  0x403605		488d05f0830600		LEAQ 0x683f0(IP), AX	
  0x40360c		48890424		MOVQ AX, 0(SP)		
  0x403610		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x403619		e8b2db0100		CALL runtime.throw(SB)	
  0x40361e		0f0b			UD2			
		throw("G waiting list is corrupted")
  0x403620		488d059d860600		LEAQ 0x6869d(IP), AX	
  0x403627		48890424		MOVQ AX, 0(SP)		
  0x40362b		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x403634		e897db0100		CALL runtime.throw(SB)	
  0x403639		0f0b			UD2			
  0x40363b		488b442460		MOVQ 0x60(SP), AX	
		unlock(&c.lock)
  0x403640		48890424		MOVQ AX, 0(SP)		
  0x403644		e877600000		CALL runtime.unlock(SB)	
		panic(plainError("send on closed channel"))
  0x403649		488d05f0790500		LEAQ 0x579f0(IP), AX			
  0x403650		48890424		MOVQ AX, 0(SP)				
  0x403654		488d0525170700		LEAQ runtime.statictmp_2(SB), AX	
  0x40365b		4889442408		MOVQ AX, 0x8(SP)			
  0x403660		e8cbd30100		CALL runtime.gopanic(SB)		
  0x403665		0f0b			UD2					
		gopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2)
  0x403667		0f57c0			XORPS X0, X0		
  0x40366a		0f110424		MOVUPS X0, 0(SP)	
  0x40366e		488d05447a0600		LEAQ 0x67a44(IP), AX	
  0x403675		4889442410		MOVQ AX, 0x10(SP)	
  0x40367a		48c744241814000000	MOVQ $0x14, 0x18(SP)	
  0x403683		c644242010		MOVB $0x10, 0x20(SP)	
  0x403688		48c744242802000000	MOVQ $0x2, 0x28(SP)	
  0x403691		e85af70100		CALL runtime.gopark(SB)	
		throw("unreachable")
  0x403696		488d053a6e0600		LEAQ 0x66e3a(IP), AX	
  0x40369d		48890424		MOVQ AX, 0(SP)		
  0x4036a1		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x4036aa		e821db0100		CALL runtime.throw(SB)	
  0x4036af		0f0b			UD2			
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x4036b1		e8ba0e0400		CALL runtime.morestack_noctxt(SB)	
  0x4036b6		e9c5f9ffff		JMP runtime.chansend(SB)		

TEXT runtime.send(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x4036c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4036c9		483b6110		CMPQ 0x10(CX), SP	
  0x4036cd		0f860b010000		JBE 0x4037de		
  0x4036d3		4883ec30		SUBQ $0x30, SP		
  0x4036d7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4036dc		488d6c2428		LEAQ 0x28(SP), BP	
  0x4036e1		488b442440		MOVQ 0x40(SP), AX	
	if sg.elem != nil {
  0x4036e6		488b4820		MOVQ 0x20(AX), CX	
  0x4036ea		488d5820		LEAQ 0x20(AX), BX	
  0x4036ee		4885c9			TESTQ CX, CX		
  0x4036f1		0f858f000000		JNE 0x403786		
	gp := sg.g
  0x4036f7		488b08			MOVQ 0(AX), CX		
  0x4036fa		48894c2418		MOVQ CX, 0x18(SP)	
  0x4036ff		488b542450		MOVQ 0x50(SP), DX	
	unlockf()
  0x403704		488b1a			MOVQ 0(DX), BX		
  0x403707		ffd3			CALL BX			
  0x403709		488b442418		MOVQ 0x18(SP), AX	
	gp.param = unsafe.Pointer(sg)
  0x40370e		8400			TESTB AL, 0(AX)				
  0x403710		8b0dfa020c00		MOVL runtime.writeBarrier(SB), CX	
  0x403716		488db888000000		LEAQ 0x88(AX), DI			
  0x40371d		85c9			TESTL CX, CX				
  0x40371f		754e			JNE 0x40376f				
  0x403721		488b4c2440		MOVQ 0x40(SP), CX			
  0x403726		48898888000000		MOVQ CX, 0x88(AX)			
	if sg.releasetime != 0 {
  0x40372d		488b5130		MOVQ 0x30(CX), DX	
  0x403731		4885d2			TESTQ DX, DX		
  0x403734		7520			JNE 0x403756		
	goready(gp, skip+1)
  0x403736		48890424		MOVQ AX, 0(SP)			
  0x40373a		488b442458		MOVQ 0x58(SP), AX		
  0x40373f		48ffc0			INCQ AX				
  0x403742		4889442408		MOVQ AX, 0x8(SP)		
  0x403747		e884f80100		CALL runtime.goready(SB)	
}
  0x40374c		488b6c2428		MOVQ 0x28(SP), BP	
  0x403751		4883c430		ADDQ $0x30, SP		
  0x403755		c3			RET			
		sg.releasetime = cputicks()
  0x403756		e895250400		CALL runtime.cputicks(SB)	
  0x40375b		488b0424		MOVQ 0(SP), AX			
  0x40375f		488b4c2440		MOVQ 0x40(SP), CX		
  0x403764		48894130		MOVQ AX, 0x30(CX)		
  0x403768		488b442418		MOVQ 0x18(SP), AX		
  0x40376d		ebc7			JMP 0x403736			
  0x40376f		4889c1			MOVQ AX, CX			
  0x403772		488b442440		MOVQ 0x40(SP), AX		
	gp.param = unsafe.Pointer(sg)
  0x403777		e824310400		CALL runtime.gcWriteBarrier(SB)	
  0x40377c		4889c8			MOVQ CX, AX			
  0x40377f		488b4c2440		MOVQ 0x40(SP), CX		
  0x403784		eba7			JMP 0x40372d			
  0x403786		48895c2420		MOVQ BX, 0x20(SP)		
  0x40378b		488b4c2438		MOVQ 0x38(SP), CX		
		sendDirect(c.elemtype, sg, ep)
  0x403790		488b4920		MOVQ 0x20(CX), CX		
  0x403794		48890c24		MOVQ CX, 0(SP)			
  0x403798		4889442408		MOVQ AX, 0x8(SP)		
  0x40379d		488b4c2448		MOVQ 0x48(SP), CX		
  0x4037a2		48894c2410		MOVQ CX, 0x10(SP)		
  0x4037a7		e844000000		CALL runtime.sendDirect(SB)	
		sg.elem = nil
  0x4037ac		8b055e020c00		MOVL runtime.writeBarrier(SB), AX	
  0x4037b2		85c0			TESTL AX, AX				
  0x4037b4		7512			JNE 0x4037c8				
  0x4037b6		488b442440		MOVQ 0x40(SP), AX			
  0x4037bb		48c7402000000000	MOVQ $0x0, 0x20(AX)			
  0x4037c3		e92fffffff		JMP 0x4036f7				
  0x4037c8		488b7c2420		MOVQ 0x20(SP), DI			
  0x4037cd		31c0			XORL AX, AX				
  0x4037cf		e8cc300400		CALL runtime.gcWriteBarrier(SB)		
  0x4037d4		488b442440		MOVQ 0x40(SP), AX			
  0x4037d9		e919ffffff		JMP 0x4036f7				
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x4037de		e88d0d0400		CALL runtime.morestack_noctxt(SB)	
  0x4037e3		e9d8feffff		JMP runtime.send(SB)			

TEXT runtime.sendDirect(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
  0x4037f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4037f9		483b6110		CMPQ 0x10(CX), SP	
  0x4037fd		7670			JBE 0x40386f		
  0x4037ff		4883ec30		SUBQ $0x30, SP		
  0x403803		48896c2428		MOVQ BP, 0x28(SP)	
  0x403808		488d6c2428		LEAQ 0x28(SP), BP	
  0x40380d		488b442440		MOVQ 0x40(SP), AX	
	dst := sg.elem
  0x403812		488b4020		MOVQ 0x20(AX), AX	
  0x403816		4889442420		MOVQ AX, 0x20(SP)	
  0x40381b		488b4c2438		MOVQ 0x38(SP), CX	
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
  0x403820		488b11			MOVQ 0(CX), DX		
  0x403823		4889542418		MOVQ DX, 0x18(SP)	
  0x403828		48890c24		MOVQ CX, 0(SP)		
  0x40382c		4889442408		MOVQ AX, 0x8(SP)	
func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
  0x403831		488b442448		MOVQ 0x48(SP), AX	
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
  0x403836		4889442410		MOVQ AX, 0x10(SP)			
  0x40383b		e8b0940000		CALL runtime.typeBitsBulkBarrier(SB)	
  0x403840		488b442438		MOVQ 0x38(SP), AX			
	memmove(dst, src, t.size)
  0x403845		488b00			MOVQ 0(AX), AX			
  0x403848		4889442410		MOVQ AX, 0x10(SP)		
  0x40384d		488b442420		MOVQ 0x20(SP), AX		
  0x403852		48890424		MOVQ AX, 0(SP)			
  0x403856		488b442448		MOVQ 0x48(SP), AX		
  0x40385b		4889442408		MOVQ AX, 0x8(SP)		
  0x403860		e89b380400		CALL runtime.memmove(SB)	
}
  0x403865		488b6c2428		MOVQ 0x28(SP), BP	
  0x40386a		4883c430		ADDQ $0x30, SP		
  0x40386e		c3			RET			
func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
  0x40386f		e8fc0c0400		CALL runtime.morestack_noctxt(SB)	
  0x403874		e977ffffff		JMP runtime.sendDirect(SB)		

TEXT runtime.recvDirect(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {
  0x403880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x403889		483b6110		CMPQ 0x10(CX), SP	
  0x40388d		7670			JBE 0x4038ff		
  0x40388f		4883ec30		SUBQ $0x30, SP		
  0x403893		48896c2428		MOVQ BP, 0x28(SP)	
  0x403898		488d6c2428		LEAQ 0x28(SP), BP	
  0x40389d		488b442440		MOVQ 0x40(SP), AX	
	src := sg.elem
  0x4038a2		488b4020		MOVQ 0x20(AX), AX	
  0x4038a6		4889442420		MOVQ AX, 0x20(SP)	
  0x4038ab		488b4c2438		MOVQ 0x38(SP), CX	
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
  0x4038b0		488b11			MOVQ 0(CX), DX		
  0x4038b3		4889542418		MOVQ DX, 0x18(SP)	
  0x4038b8		48890c24		MOVQ CX, 0(SP)		
func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {
  0x4038bc		488b542448		MOVQ 0x48(SP), DX	
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
  0x4038c1		4889542408		MOVQ DX, 0x8(SP)			
  0x4038c6		4889442410		MOVQ AX, 0x10(SP)			
  0x4038cb		e820940000		CALL runtime.typeBitsBulkBarrier(SB)	
  0x4038d0		488b442438		MOVQ 0x38(SP), AX			
	memmove(dst, src, t.size)
  0x4038d5		488b00			MOVQ 0(AX), AX			
  0x4038d8		4889442410		MOVQ AX, 0x10(SP)		
  0x4038dd		488b442448		MOVQ 0x48(SP), AX		
  0x4038e2		48890424		MOVQ AX, 0(SP)			
  0x4038e6		488b442420		MOVQ 0x20(SP), AX		
  0x4038eb		4889442408		MOVQ AX, 0x8(SP)		
  0x4038f0		e80b380400		CALL runtime.memmove(SB)	
}
  0x4038f5		488b6c2428		MOVQ 0x28(SP), BP	
  0x4038fa		4883c430		ADDQ $0x30, SP		
  0x4038fe		c3			RET			
func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {
  0x4038ff		e86c0c0400		CALL runtime.morestack_noctxt(SB)	
  0x403904		e977ffffff		JMP runtime.recvDirect(SB)		

TEXT runtime.closechan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func closechan(c *hchan) {
  0x403910		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x403919		483b6110		CMPQ 0x10(CX), SP	
  0x40391d		0f8687020000		JBE 0x403baa		
  0x403923		4883ec50		SUBQ $0x50, SP		
  0x403927		48896c2448		MOVQ BP, 0x48(SP)	
  0x40392c		488d6c2448		LEAQ 0x48(SP), BP	
  0x403931		488b442458		MOVQ 0x58(SP), AX	
	if c == nil {
  0x403936		4885c0			TESTQ AX, AX		
  0x403939		0f844d020000		JE 0x403b8c		
	lock(&c.lock)
  0x40393f		488d4858		LEAQ 0x58(AX), CX	
  0x403943		48894c2440		MOVQ CX, 0x40(SP)	
  0x403948		48890c24		MOVQ CX, 0(SP)		
  0x40394c		e8cf5b0000		CALL runtime.lock(SB)	
  0x403951		488b442458		MOVQ 0x58(SP), AX	
	if c.closed != 0 {
  0x403956		8b481c			MOVL 0x1c(AX), CX	
  0x403959		85c9			TESTL CX, CX		
  0x40395b		0f85ff010000		JNE 0x403b60		
	c.closed = 1
  0x403961		c7401c01000000		MOVL $0x1, 0x1c(AX)	
  0x403968		31c9			XORL CX, CX		
	for {
  0x40396a		eb1a			JMP 0x403986		
		gp.schedlink.set(glist)
  0x40396c		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x403973		8402			TESTB AL, 0(DX)		
  0x403975		488b542420		MOVQ 0x20(SP), DX	
  0x40397a		488991b8000000		MOVQ DX, 0xb8(CX)	
  0x403981		488b442458		MOVQ 0x58(SP), AX	
		sg := c.recvq.dequeue()
  0x403986		48894c2420		MOVQ CX, 0x20(SP)			
  0x40398b		488d5038		LEAQ 0x38(AX), DX			
  0x40398f		48891424		MOVQ DX, 0(SP)				
  0x403993		e8d80a0000		CALL runtime.(*waitq).dequeue(SB)	
  0x403998		488b442408		MOVQ 0x8(SP), AX			
		if sg == nil {
  0x40399d		4885c0			TESTQ AX, AX		
  0x4039a0		0f84af000000		JE 0x403a55		
  0x4039a6		4889442418		MOVQ AX, 0x18(SP)	
		if sg.elem != nil {
  0x4039ab		488b4820		MOVQ 0x20(AX), CX	
  0x4039af		488d5020		LEAQ 0x20(AX), DX	
  0x4039b3		4885c9			TESTQ CX, CX		
  0x4039b6		754f			JNE 0x403a07		
		if sg.releasetime != 0 {
  0x4039b8		488b4830		MOVQ 0x30(AX), CX	
  0x4039bc		4885c9			TESTQ CX, CX		
  0x4039bf		752f			JNE 0x4039f0		
		gp := sg.g
  0x4039c1		488b08			MOVQ 0(AX), CX		
		gp.param = nil
  0x4039c4		8401			TESTB AL, 0(CX)				
  0x4039c6		8b1544000c00		MOVL runtime.writeBarrier(SB), DX	
  0x4039cc		488db988000000		LEAQ 0x88(CX), DI			
  0x4039d3		85d2			TESTL DX, DX				
  0x4039d5		750d			JNE 0x4039e4				
  0x4039d7		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
  0x4039e2		eb88			JMP 0x40396c				
  0x4039e4		31c0			XORL AX, AX				
  0x4039e6		e8b52e0400		CALL runtime.gcWriteBarrier(SB)		
  0x4039eb		e97cffffff		JMP 0x40396c				
			sg.releasetime = cputicks()
  0x4039f0		e8fb220400		CALL runtime.cputicks(SB)	
  0x4039f5		488b0424		MOVQ 0(SP), AX			
  0x4039f9		488b4c2418		MOVQ 0x18(SP), CX		
  0x4039fe		48894130		MOVQ AX, 0x30(CX)		
  0x403a02		4889c8			MOVQ CX, AX			
  0x403a05		ebba			JMP 0x4039c1			
  0x403a07		4889542438		MOVQ DX, 0x38(SP)		
  0x403a0c		488b442458		MOVQ 0x58(SP), AX		
			typedmemclr(c.elemtype, sg.elem)
  0x403a11		488b5020		MOVQ 0x20(AX), DX		
  0x403a15		48894c2408		MOVQ CX, 0x8(SP)		
  0x403a1a		48891424		MOVQ DX, 0(SP)			
  0x403a1e		e8ed820000		CALL runtime.typedmemclr(SB)	
			sg.elem = nil
  0x403a23		8b05e7ff0b00		MOVL runtime.writeBarrier(SB), AX	
  0x403a29		85c0			TESTL AX, AX				
  0x403a2b		7515			JNE 0x403a42				
  0x403a2d		488b4c2418		MOVQ 0x18(SP), CX			
  0x403a32		48c7412000000000	MOVQ $0x0, 0x20(CX)			
  0x403a3a		4889c8			MOVQ CX, AX				
  0x403a3d		e976ffffff		JMP 0x4039b8				
  0x403a42		488b7c2438		MOVQ 0x38(SP), DI			
  0x403a47		31c0			XORL AX, AX				
  0x403a49		e8522e0400		CALL runtime.gcWriteBarrier(SB)		
  0x403a4e		488b4c2418		MOVQ 0x18(SP), CX			
  0x403a53		ebe5			JMP 0x403a3a				
  0x403a55		488b442420		MOVQ 0x20(SP), AX			
		sg := c.sendq.dequeue()
  0x403a5a		eb18			JMP 0x403a74		
		gp.schedlink.set(glist)
  0x403a5c		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x403a63		8402			TESTB AL, 0(DX)		
  0x403a65		488b542428		MOVQ 0x28(SP), DX	
  0x403a6a		488991b8000000		MOVQ DX, 0xb8(CX)	
  0x403a71		4889c8			MOVQ CX, AX		
		sg := c.sendq.dequeue()
  0x403a74		4889442428		MOVQ AX, 0x28(SP)			
  0x403a79		488b4c2458		MOVQ 0x58(SP), CX			
  0x403a7e		488d5148		LEAQ 0x48(CX), DX			
  0x403a82		48891424		MOVQ DX, 0(SP)				
  0x403a86		e8e5090000		CALL runtime.(*waitq).dequeue(SB)	
  0x403a8b		488b442408		MOVQ 0x8(SP), AX			
		if sg == nil {
  0x403a90		4885c0			TESTQ AX, AX		
  0x403a93		7479			JE 0x403b0e		
		sg.elem = nil
  0x403a95		8b0d75ff0b00		MOVL runtime.writeBarrier(SB), CX	
  0x403a9b		488d7820		LEAQ 0x20(AX), DI			
  0x403a9f		85c9			TESTL CX, CX				
  0x403aa1		755c			JNE 0x403aff				
  0x403aa3		48c7402000000000	MOVQ $0x0, 0x20(AX)			
		if sg.releasetime != 0 {
  0x403aab		488b4830		MOVQ 0x30(AX), CX	
  0x403aaf		4885c9			TESTQ CX, CX		
  0x403ab2		752f			JNE 0x403ae3		
		gp := sg.g
  0x403ab4		488b08			MOVQ 0(AX), CX		
		gp.param = nil
  0x403ab7		8401			TESTB AL, 0(CX)				
  0x403ab9		8b1551ff0b00		MOVL runtime.writeBarrier(SB), DX	
  0x403abf		488db988000000		LEAQ 0x88(CX), DI			
  0x403ac6		85d2			TESTL DX, DX				
  0x403ac8		750d			JNE 0x403ad7				
  0x403aca		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
  0x403ad5		eb85			JMP 0x403a5c				
  0x403ad7		31c0			XORL AX, AX				
  0x403ad9		e8c22d0400		CALL runtime.gcWriteBarrier(SB)		
  0x403ade		e979ffffff		JMP 0x403a5c				
  0x403ae3		4889442410		MOVQ AX, 0x10(SP)			
			sg.releasetime = cputicks()
  0x403ae8		e803220400		CALL runtime.cputicks(SB)	
  0x403aed		488b0424		MOVQ 0(SP), AX			
  0x403af1		488b4c2410		MOVQ 0x10(SP), CX		
  0x403af6		48894130		MOVQ AX, 0x30(CX)		
  0x403afa		4889c8			MOVQ CX, AX			
  0x403afd		ebb5			JMP 0x403ab4			
  0x403aff		4889c1			MOVQ AX, CX			
		sg.elem = nil
  0x403b02		31c0			XORL AX, AX			
  0x403b04		e8972d0400		CALL runtime.gcWriteBarrier(SB)	
  0x403b09		4889c8			MOVQ CX, AX			
  0x403b0c		eb9d			JMP 0x403aab			
  0x403b0e		488b442440		MOVQ 0x40(SP), AX		
	unlock(&c.lock)
  0x403b13		48890424		MOVQ AX, 0(SP)		
  0x403b17		e8a45b0000		CALL runtime.unlock(SB)	
  0x403b1c		488b442428		MOVQ 0x28(SP), AX	
	for glist != nil {
  0x403b21		eb2e			JMP 0x403b51		
		glist = glist.schedlink.ptr()
  0x403b23		488b88b8000000		MOVQ 0xb8(AX), CX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x403b2a		48894c2430		MOVQ CX, 0x30(SP)	
		gp.schedlink = 0
  0x403b2f		48c780b800000000000000	MOVQ $0x0, 0xb8(AX)	
		goready(gp, 3)
  0x403b3a		48890424		MOVQ AX, 0(SP)			
  0x403b3e		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x403b47		e884f40100		CALL runtime.goready(SB)	
  0x403b4c		488b442430		MOVQ 0x30(SP), AX		
	for glist != nil {
  0x403b51		4885c0			TESTQ AX, AX		
  0x403b54		75cd			JNE 0x403b23		
  0x403b56		488b6c2448		MOVQ 0x48(SP), BP	
  0x403b5b		4883c450		ADDQ $0x50, SP		
  0x403b5f		c3			RET			
  0x403b60		488b442440		MOVQ 0x40(SP), AX	
		unlock(&c.lock)
  0x403b65		48890424		MOVQ AX, 0(SP)		
  0x403b69		e8525b0000		CALL runtime.unlock(SB)	
		panic(plainError("close of closed channel"))
  0x403b6e		488d05cb740500		LEAQ 0x574cb(IP), AX			
  0x403b75		48890424		MOVQ AX, 0(SP)				
  0x403b79		488d0590120700		LEAQ runtime.statictmp_5(SB), AX	
  0x403b80		4889442408		MOVQ AX, 0x8(SP)			
  0x403b85		e8a6ce0100		CALL runtime.gopanic(SB)		
  0x403b8a		0f0b			UD2					
		panic(plainError("close of nil channel"))
  0x403b8c		488d05ad740500		LEAQ 0x574ad(IP), AX			
  0x403b93		48890424		MOVQ AX, 0(SP)				
  0x403b97		488d0562120700		LEAQ runtime.statictmp_4(SB), AX	
  0x403b9e		4889442408		MOVQ AX, 0x8(SP)			
  0x403ba3		e888ce0100		CALL runtime.gopanic(SB)		
  0x403ba8		0f0b			UD2					
func closechan(c *hchan) {
  0x403baa		e8c1090400		CALL runtime.morestack_noctxt(SB)	
  0x403baf		e95cfdffff		JMP runtime.closechan(SB)		

TEXT runtime.chanrecv1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func chanrecv1(c *hchan, elem unsafe.Pointer) {
  0x403bc0		4883ec28		SUBQ $0x28, SP		
  0x403bc4		48896c2420		MOVQ BP, 0x20(SP)	
  0x403bc9		488d6c2420		LEAQ 0x20(SP), BP	
  0x403bce		488b442430		MOVQ 0x30(SP), AX	
	chanrecv(c, elem, true)
  0x403bd3		48890424		MOVQ AX, 0(SP)		
func chanrecv1(c *hchan, elem unsafe.Pointer) {
  0x403bd7		488b442438		MOVQ 0x38(SP), AX	
	chanrecv(c, elem, true)
  0x403bdc		4889442408		MOVQ AX, 0x8(SP)		
  0x403be1		c644241001		MOVB $0x1, 0x10(SP)		
  0x403be6		e815000000		CALL runtime.chanrecv(SB)	
}
  0x403beb		488b6c2420		MOVQ 0x20(SP), BP	
  0x403bf0		4883c428		ADDQ $0x28, SP		
  0x403bf4		c3			RET			

TEXT runtime.chanrecv(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x403c00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x403c09		488d4424f0		LEAQ -0x10(SP), AX	
  0x403c0e		483b4110		CMPQ 0x10(CX), AX	
  0x403c12		0f867f060000		JBE 0x404297		
  0x403c18		4881ec90000000		SUBQ $0x90, SP		
  0x403c1f		4889ac2488000000	MOVQ BP, 0x88(SP)	
  0x403c27		488dac2488000000	LEAQ 0x88(SP), BP	
  0x403c2f		488b842498000000	MOVQ 0x98(SP), AX	
	if c == nil {
  0x403c37		4885c0			TESTQ AX, AX		
  0x403c3a		0f84c6050000		JE 0x404206		
  0x403c40		0fb68c24a8000000	MOVZX 0xa8(SP), CX	
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x403c48		84c9			TESTL CL, CL		
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
  0x403c4a		0f8464050000		JE 0x4041b4		
	if blockprofilerate > 0 {
  0x403c50		488b15d1fc0b00		MOVQ runtime.blockprofilerate(SB), DX	
  0x403c57		4885d2			TESTQ DX, DX				
  0x403c5a		0f873e050000		JA 0x40419e				
  0x403c60		31d2			XORL DX, DX				
  0x403c62		4889542430		MOVQ DX, 0x30(SP)			
	lock(&c.lock)
  0x403c67		488d4858		LEAQ 0x58(AX), CX	
  0x403c6b		48894c2470		MOVQ CX, 0x70(SP)	
  0x403c70		48890c24		MOVQ CX, 0(SP)		
  0x403c74		e8a7580000		CALL runtime.lock(SB)	
  0x403c79		488b842498000000	MOVQ 0x98(SP), AX	
	if c.closed != 0 && c.qcount == 0 {
  0x403c81		8b481c			MOVL 0x1c(AX), CX	
  0x403c84		85c9			TESTL CX, CX		
  0x403c86		740c			JE 0x403c94		
  0x403c88		488b08			MOVQ 0(AX), CX		
  0x403c8b		4885c9			TESTQ CX, CX		
  0x403c8e		0f84b3040000		JE 0x404147		
	if sg := c.sendq.dequeue(); sg != nil {
  0x403c94		488d4848		LEAQ 0x48(AX), CX			
  0x403c98		48890c24		MOVQ CX, 0(SP)				
  0x403c9c		e8cf070000		CALL runtime.(*waitq).dequeue(SB)	
  0x403ca1		488b442408		MOVQ 0x8(SP), AX			
  0x403ca6		4885c0			TESTQ AX, AX				
  0x403ca9		0f852e040000		JNE 0x4040dd				
  0x403caf		488b842498000000	MOVQ 0x98(SP), AX			
	if c.qcount > 0 {
  0x403cb7		488b08			MOVQ 0(AX), CX		
  0x403cba		4885c9			TESTQ CX, CX		
  0x403cbd		0f86b3000000		JBE 0x403d76		
		qp := chanbuf(c, c.recvx)
  0x403cc3		488b4830		MOVQ 0x30(AX), CX	
	return add(c.buf, uintptr(i)*uintptr(c.elemsize))
  0x403cc7		0fb75018		MOVZX 0x18(AX), DX	
  0x403ccb		480fafca		IMULQ DX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x403ccf		48034810		ADDQ 0x10(AX), CX	
  0x403cd3		488b9424a0000000	MOVQ 0xa0(SP), DX	
		if ep != nil {
  0x403cdb		4885d2			TESTQ DX, DX		
  0x403cde		7568			JNE 0x403d48		
		typedmemclr(c.elemtype, qp)
  0x403ce0		488b5020		MOVQ 0x20(AX), DX		
  0x403ce4		48891424		MOVQ DX, 0(SP)			
  0x403ce8		48894c2408		MOVQ CX, 0x8(SP)		
  0x403ced		e81e800000		CALL runtime.typedmemclr(SB)	
  0x403cf2		488b842498000000	MOVQ 0x98(SP), AX		
		c.recvx++
  0x403cfa		488b4830		MOVQ 0x30(AX), CX	
  0x403cfe		48ffc1			INCQ CX			
  0x403d01		48894830		MOVQ CX, 0x30(AX)	
		if c.recvx == c.dataqsiz {
  0x403d05		488b5008		MOVQ 0x8(AX), DX	
  0x403d09		4839d1			CMPQ DX, CX		
  0x403d0c		7508			JNE 0x403d16		
			c.recvx = 0
  0x403d0e		48c7403000000000	MOVQ $0x0, 0x30(AX)	
		c.qcount--
  0x403d16		488300ff		ADDQ $-0x1, 0(AX)	
  0x403d1a		488b442470		MOVQ 0x70(SP), AX	
		unlock(&c.lock)
  0x403d1f		48890424		MOVQ AX, 0(SP)		
  0x403d23		e898590000		CALL runtime.unlock(SB)	
		return true, true
  0x403d28		c68424b000000001	MOVB $0x1, 0xb0(SP)	
  0x403d30		c68424b100000001	MOVB $0x1, 0xb1(SP)	
  0x403d38		488bac2488000000	MOVQ 0x88(SP), BP	
  0x403d40		4881c490000000		ADDQ $0x90, SP		
  0x403d47		c3			RET			
  0x403d48		48894c2440		MOVQ CX, 0x40(SP)	
			typedmemmove(c.elemtype, ep, qp)
  0x403d4d		488b5820		MOVQ 0x20(AX), BX		
  0x403d51		48891c24		MOVQ BX, 0(SP)			
  0x403d55		4889542408		MOVQ DX, 0x8(SP)		
  0x403d5a		48894c2410		MOVQ CX, 0x10(SP)		
  0x403d5f		e82c7d0000		CALL runtime.typedmemmove(SB)	
  0x403d64		488b842498000000	MOVQ 0x98(SP), AX		
  0x403d6c		488b4c2440		MOVQ 0x40(SP), CX		
  0x403d71		e96affffff		JMP 0x403ce0			
  0x403d76		0fb68c24a8000000	MOVZX 0xa8(SP), CX		
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x403d7e		84c9			TESTL CL, CL		
	if !block {
  0x403d80		752e			JNE 0x403db0		
  0x403d82		488b442470		MOVQ 0x70(SP), AX	
		unlock(&c.lock)
  0x403d87		48890424		MOVQ AX, 0(SP)		
  0x403d8b		e830590000		CALL runtime.unlock(SB)	
		return false, false
  0x403d90		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x403d98		c68424b100000000	MOVB $0x0, 0xb1(SP)	
  0x403da0		488bac2488000000	MOVQ 0x88(SP), BP	
  0x403da8		4881c490000000		ADDQ $0x90, SP		
  0x403daf		c3			RET			
	gp := getg()
  0x403db0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x403db9		4889442448		MOVQ AX, 0x48(SP)	
	mysg := acquireSudog()
  0x403dbe		e86df20100		CALL runtime.acquireSudog(SB)	
  0x403dc3		488b0424		MOVQ 0(SP), AX			
	mysg.releasetime = 0
  0x403dc7		48c7403000000000	MOVQ $0x0, 0x30(AX)	
  0x403dcf		488b4c2430		MOVQ 0x30(SP), CX	
	if t0 != 0 {
  0x403dd4		4885c9			TESTQ CX, CX		
  0x403dd7		7408			JE 0x403de1		
		mysg.releasetime = -1
  0x403dd9		48c74030ffffffff	MOVQ $-0x1, 0x30(AX)	
	mysg.elem = ep
  0x403de1		8b1529fc0b00		MOVL runtime.writeBarrier(SB), DX	
  0x403de7		488d7820		LEAQ 0x20(AX), DI			
	mysg.waitlink = nil
  0x403deb		488d5848		LEAQ 0x48(AX), BX	
	mysg.elem = ep
  0x403def		85d2			TESTL DX, DX		
  0x403df1		0f85c4020000		JNE 0x4040bb		
  0x403df7		488b9424a0000000	MOVQ 0xa0(SP), DX	
  0x403dff		48895020		MOVQ DX, 0x20(AX)	
	mysg.waitlink = nil
  0x403e03		48c7404800000000	MOVQ $0x0, 0x48(AX)	
	mysg.elem = ep
  0x403e0b		488b542448		MOVQ 0x48(SP), DX	
	gp.waiting = mysg
  0x403e10		8402			TESTB AL, 0(DX)				
  0x403e12		8b1df8fb0b00		MOVL runtime.writeBarrier(SB), BX	
  0x403e18		488dba38010000		LEAQ 0x138(DX), DI			
  0x403e1f		85db			TESTL BX, BX				
  0x403e21		0f8576020000		JNE 0x40409d				
  0x403e27		48898238010000		MOVQ AX, 0x138(DX)			
	mysg.g = gp
  0x403e2e		488910			MOVQ DX, 0(AX)		
	mysg.isSelect = false
  0x403e31		c6400800		MOVB $0x0, 0x8(AX)	
	mysg.c = c
  0x403e35		8b1dd5fb0b00		MOVL runtime.writeBarrier(SB), BX	
  0x403e3b		488d7058		LEAQ 0x58(AX), SI			
	gp.param = nil
  0x403e3f		4c8d8288000000		LEAQ 0x88(DX), R8	
	sgp.next = nil
  0x403e46		4c8d4810		LEAQ 0x10(AX), R9	
	mysg.c = c
  0x403e4a		85db			TESTL BX, BX		
  0x403e4c		0f8510020000		JNE 0x404062		
  0x403e52		488b9c2498000000	MOVQ 0x98(SP), BX	
  0x403e5a		48895858		MOVQ BX, 0x58(AX)	
	gp.param = nil
  0x403e5e		48c7828800000000000000	MOVQ $0x0, 0x88(DX)	
	sgp.next = nil
  0x403e69		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	mysg.c = c
  0x403e71		4889442438		MOVQ AX, 0x38(SP)	
  0x403e76		48897c2468		MOVQ DI, 0x68(SP)	
  0x403e7b		4889742460		MOVQ SI, 0x60(SP)	
  0x403e80		4c89442458		MOVQ R8, 0x58(SP)	
	c.recvq.enqueue(mysg)
  0x403e85		4c8d4b38		LEAQ 0x38(BX), R9	
	x := q.last
  0x403e89		418401			TESTB AL, 0(R9)		
  0x403e8c		4c8b4b40		MOVQ 0x40(BX), R9	
  0x403e90		4c8d5340		LEAQ 0x40(BX), R10	
	if x == nil {
  0x403e94		4d85c9			TESTQ R9, R9		
  0x403e97		0f8471010000		JE 0x40400e		
	sgp.prev = x
  0x403e9d		448b1d6cfb0b00		MOVL runtime.writeBarrier(SB), R11	
  0x403ea4		4c8d6018		LEAQ 0x18(AX), R12			
	x.next = sgp
  0x403ea8		4d8d6910		LEAQ 0x10(R9), R13	
	sgp.prev = x
  0x403eac		4585db			TESTL R11, R11		
  0x403eaf		0f852d010000		JNE 0x403fe2		
  0x403eb5		4c894818		MOVQ R9, 0x18(AX)	
	x.next = sgp
  0x403eb9		49894110		MOVQ AX, 0x10(R9)	
	q.last = sgp
  0x403ebd		48894340		MOVQ AX, 0x40(BX)	
	sgp.prev = x
  0x403ec1		488b442470		MOVQ 0x70(SP), AX	
	goparkunlock(&c.lock, "chan receive", traceEvGoBlockRecv, 3)
  0x403ec6		48890424		MOVQ AX, 0(SP)			
  0x403eca		488d0525670600		LEAQ 0x66725(IP), AX		
  0x403ed1		4889442408		MOVQ AX, 0x8(SP)		
  0x403ed6		48c74424100c000000	MOVQ $0xc, 0x10(SP)		
  0x403edf		c644241817		MOVB $0x17, 0x18(SP)		
  0x403ee4		48c744242003000000	MOVQ $0x3, 0x20(SP)		
  0x403eed		e86ef00100		CALL runtime.goparkunlock(SB)	
  0x403ef2		488b442448		MOVQ 0x48(SP), AX		
	if mysg != gp.waiting {
  0x403ef7		488b8838010000		MOVQ 0x138(AX), CX	
  0x403efe		488b542438		MOVQ 0x38(SP), DX	
  0x403f03		4839ca			CMPQ CX, DX		
  0x403f06		0f8526030000		JNE 0x404232		
	gp.waiting = nil
  0x403f0c		8b0dfefa0b00		MOVL runtime.writeBarrier(SB), CX	
  0x403f12		85c9			TESTL CX, CX				
  0x403f14		0f85b1000000		JNE 0x403fcb				
  0x403f1a		48c7803801000000000000	MOVQ $0x0, 0x138(AX)			
	if mysg.releasetime > 0 {
  0x403f25		488b4a30		MOVQ 0x30(DX), CX	
  0x403f29		4885c9			TESTQ CX, CX		
  0x403f2c		7f74			JG 0x403fa2		
	closed := gp.param == nil
  0x403f2e		488b8888000000		MOVQ 0x88(AX), CX	
  0x403f35		48894c2450		MOVQ CX, 0x50(SP)	
	gp.param = nil
  0x403f3a		8b1dd0fa0b00		MOVL runtime.writeBarrier(SB), BX	
  0x403f40		85db			TESTL BX, BX				
  0x403f42		7544			JNE 0x403f88				
  0x403f44		48c7808800000000000000	MOVQ $0x0, 0x88(AX)			
	mysg.c = nil
  0x403f4f		48c7425800000000	MOVQ $0x0, 0x58(DX)	
	releaseSudog(mysg)
  0x403f57		48891424		MOVQ DX, 0(SP)			
  0x403f5b		e860f40100		CALL runtime.releaseSudog(SB)	
	return true, !closed
  0x403f60		c68424b000000001	MOVB $0x1, 0xb0(SP)	
  0x403f68		488b442450		MOVQ 0x50(SP), AX	
	closed := gp.param == nil
  0x403f6d		4885c0			TESTQ AX, AX		
	return true, !closed
  0x403f70		0f958424b1000000	SETNE 0xb1(SP)		
  0x403f78		488bac2488000000	MOVQ 0x88(SP), BP	
  0x403f80		4881c490000000		ADDQ $0x90, SP		
  0x403f87		c3			RET			
  0x403f88		488b7c2458		MOVQ 0x58(SP), DI	
	gp.param = nil
  0x403f8d		31c0			XORL AX, AX			
  0x403f8f		e80c290400		CALL runtime.gcWriteBarrier(SB)	
  0x403f94		488b7c2460		MOVQ 0x60(SP), DI		
	mysg.c = nil
  0x403f99		31c0			XORL AX, AX			
  0x403f9b		e800290400		CALL runtime.gcWriteBarrier(SB)	
	gp.param = nil
  0x403fa0		ebb5			JMP 0x403f57		
  0x403fa2		488b442430		MOVQ 0x30(SP), AX	
		blockevent(mysg.releasetime-t0, 2)
  0x403fa7		4829c1			SUBQ AX, CX			
  0x403faa		48890c24		MOVQ CX, 0(SP)			
  0x403fae		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x403fb7		e834980100		CALL runtime.blockevent(SB)	
  0x403fbc		488b442448		MOVQ 0x48(SP), AX		
  0x403fc1		488b542438		MOVQ 0x38(SP), DX		
  0x403fc6		e963ffffff		JMP 0x403f2e			
  0x403fcb		488b7c2468		MOVQ 0x68(SP), DI		
  0x403fd0		4889c1			MOVQ AX, CX			
	gp.waiting = nil
  0x403fd3		31c0			XORL AX, AX			
  0x403fd5		e8c6280400		CALL runtime.gcWriteBarrier(SB)	
  0x403fda		4889c8			MOVQ CX, AX			
  0x403fdd		e943ffffff		JMP 0x403f25			
  0x403fe2		4889fb			MOVQ DI, BX			
  0x403fe5		4c89e7			MOVQ R12, DI			
  0x403fe8		4989c3			MOVQ AX, R11			
  0x403feb		4c89c8			MOVQ R9, AX			
	sgp.prev = x
  0x403fee		e8ad280400		CALL runtime.gcWriteBarrier(SB)	
  0x403ff3		4c89ef			MOVQ R13, DI			
  0x403ff6		4c89d8			MOVQ R11, AX			
	x.next = sgp
  0x403ff9		e8a2280400		CALL runtime.gcWriteBarrier(SB)	
  0x403ffe		4c89d7			MOVQ R10, DI			
	q.last = sgp
  0x404001		e89a280400		CALL runtime.gcWriteBarrier(SB)	
  0x404006		4889df			MOVQ BX, DI			
	sgp.prev = x
  0x404009		e9b3feffff		JMP 0x403ec1		
		sgp.prev = nil
  0x40400e		448b0dfbf90b00		MOVL runtime.writeBarrier(SB), R9	
  0x404015		4c8d5818		LEAQ 0x18(AX), R11			
		q.first = sgp
  0x404019		4c8d6338		LEAQ 0x38(BX), R12	
		sgp.prev = nil
  0x40401d		4585c9			TESTL R9, R9		
  0x404020		7515			JNE 0x404037		
  0x404022		48c7401800000000	MOVQ $0x0, 0x18(AX)	
		q.first = sgp
  0x40402a		48894338		MOVQ AX, 0x38(BX)	
		q.last = sgp
  0x40402e		48894340		MOVQ AX, 0x40(BX)	
		sgp.prev = nil
  0x404032		e98afeffff		JMP 0x403ec1			
  0x404037		4889fb			MOVQ DI, BX			
  0x40403a		4c89df			MOVQ R11, DI			
  0x40403d		4989c1			MOVQ AX, R9			
  0x404040		31c0			XORL AX, AX			
  0x404042		e859280400		CALL runtime.gcWriteBarrier(SB)	
  0x404047		4c89e7			MOVQ R12, DI			
  0x40404a		4c89c8			MOVQ R9, AX			
		q.first = sgp
  0x40404d		e84e280400		CALL runtime.gcWriteBarrier(SB)	
  0x404052		4c89d7			MOVQ R10, DI			
		q.last = sgp
  0x404055		e846280400		CALL runtime.gcWriteBarrier(SB)	
  0x40405a		4889df			MOVQ BX, DI			
		sgp.prev = nil
  0x40405d		e95ffeffff		JMP 0x403ec1		
  0x404062		4889fb			MOVQ DI, BX		
  0x404065		4889f7			MOVQ SI, DI		
  0x404068		4989c2			MOVQ AX, R10		
  0x40406b		488b842498000000	MOVQ 0x98(SP), AX	
	mysg.c = c
  0x404073		e828280400		CALL runtime.gcWriteBarrier(SB)	
  0x404078		4c89c7			MOVQ R8, DI			
  0x40407b		4989c3			MOVQ AX, R11			
	gp.param = nil
  0x40407e		31c0			XORL AX, AX			
  0x404080		e81b280400		CALL runtime.gcWriteBarrier(SB)	
  0x404085		4c89cf			MOVQ R9, DI			
	sgp.next = nil
  0x404088		31c0			XORL AX, AX			
  0x40408a		e811280400		CALL runtime.gcWriteBarrier(SB)	
  0x40408f		4c89d0			MOVQ R10, AX			
  0x404092		4889df			MOVQ BX, DI			
  0x404095		4c89db			MOVQ R11, BX			
	mysg.c = c
  0x404098		e9d4fdffff		JMP 0x403e71		
	gp.waiting = mysg
  0x40409d		e8fe270400		CALL runtime.gcWriteBarrier(SB)	
  0x4040a2		4889fb			MOVQ DI, BX			
  0x4040a5		4889c7			MOVQ AX, DI			
  0x4040a8		4889d0			MOVQ DX, AX			
	mysg.g = gp
  0x4040ab		e8f0270400		CALL runtime.gcWriteBarrier(SB)	
  0x4040b0		4889f8			MOVQ DI, AX			
  0x4040b3		4889df			MOVQ BX, DI			
	gp.waiting = mysg
  0x4040b6		e976fdffff		JMP 0x403e31		
  0x4040bb		4889c2			MOVQ AX, DX		
  0x4040be		488b8424a0000000	MOVQ 0xa0(SP), AX	
	mysg.elem = ep
  0x4040c6		e8d5270400		CALL runtime.gcWriteBarrier(SB)	
  0x4040cb		4889df			MOVQ BX, DI			
	mysg.waitlink = nil
  0x4040ce		31c0			XORL AX, AX			
  0x4040d0		e8cb270400		CALL runtime.gcWriteBarrier(SB)	
  0x4040d5		4889d0			MOVQ DX, AX			
	mysg.elem = ep
  0x4040d8		e92efdffff		JMP 0x403e0b		
		recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x4040dd		488d0dacda0300		LEAQ runtime.chanrecv.func1(SB), CX	
  0x4040e4		48894c2478		MOVQ CX, 0x78(SP)			
  0x4040e9		488b8c2498000000	MOVQ 0x98(SP), CX			
  0x4040f1		48898c2480000000	MOVQ CX, 0x80(SP)			
  0x4040f9		48890c24		MOVQ CX, 0(SP)				
  0x4040fd		4889442408		MOVQ AX, 0x8(SP)			
  0x404102		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x40410a		4889442410		MOVQ AX, 0x10(SP)			
  0x40410f		488d442478		LEAQ 0x78(SP), AX			
  0x404114		4889442418		MOVQ AX, 0x18(SP)			
  0x404119		48c744242003000000	MOVQ $0x3, 0x20(SP)			
  0x404122		e889010000		CALL runtime.recv(SB)			
		return true, true
  0x404127		c68424b000000001	MOVB $0x1, 0xb0(SP)	
  0x40412f		c68424b100000001	MOVB $0x1, 0xb1(SP)	
  0x404137		488bac2488000000	MOVQ 0x88(SP), BP	
  0x40413f		4881c490000000		ADDQ $0x90, SP		
  0x404146		c3			RET			
  0x404147		488b442470		MOVQ 0x70(SP), AX	
		unlock(&c.lock)
  0x40414c		48890424		MOVQ AX, 0(SP)		
  0x404150		e86b550000		CALL runtime.unlock(SB)	
  0x404155		488b8424a0000000	MOVQ 0xa0(SP), AX	
		if ep != nil {
  0x40415d		4885c0			TESTQ AX, AX		
  0x404160		7520			JNE 0x404182		
		return true, false
  0x404162		c68424b000000001	MOVB $0x1, 0xb0(SP)	
  0x40416a		c68424b100000000	MOVB $0x0, 0xb1(SP)	
  0x404172		488bac2488000000	MOVQ 0x88(SP), BP	
  0x40417a		4881c490000000		ADDQ $0x90, SP		
  0x404181		c3			RET			
  0x404182		488b8c2498000000	MOVQ 0x98(SP), CX	
			typedmemclr(c.elemtype, ep)
  0x40418a		488b4920		MOVQ 0x20(CX), CX		
  0x40418e		48890c24		MOVQ CX, 0(SP)			
  0x404192		4889442408		MOVQ AX, 0x8(SP)		
  0x404197		e8747b0000		CALL runtime.typedmemclr(SB)	
  0x40419c		ebc4			JMP 0x404162			
		t0 = cputicks()
  0x40419e		e84d1b0400		CALL runtime.cputicks(SB)	
  0x4041a3		488b1424		MOVQ 0(SP), DX			
  0x4041a7		488b842498000000	MOVQ 0x98(SP), AX		
  0x4041af		e9aefaffff		JMP 0x403c62			
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
  0x4041b4		488b5008		MOVQ 0x8(AX), DX	
  0x4041b8		4885d2			TESTQ DX, DX		
  0x4041bb		750c			JNE 0x4041c9		
  0x4041bd		488b5848		MOVQ 0x48(AX), BX	
  0x4041c1		4885db			TESTQ BX, BX		
  0x4041c4		7415			JE 0x4041db		
  0x4041c6		4885d2			TESTQ DX, DX		
		c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
  0x4041c9		0f8681faffff		JBE 0x403c50		
  0x4041cf		488b10			MOVQ 0(AX), DX		
  0x4041d2		4885d2			TESTQ DX, DX		
  0x4041d5		0f8575faffff		JNE 0x403c50		
		atomic.Load(&c.closed) == 0 {
  0x4041db		8b501c			MOVL 0x1c(AX), DX	
  0x4041de		85d2			TESTL DX, DX		
  0x4041e0		0f856afaffff		JNE 0x403c50		
		return
  0x4041e6		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x4041ee		c68424b100000000	MOVB $0x0, 0xb1(SP)	
  0x4041f6		488bac2488000000	MOVQ 0x88(SP), BP	
  0x4041fe		4881c490000000		ADDQ $0x90, SP		
  0x404205		c3			RET			
  0x404206		0fb68424a8000000	MOVZX 0xa8(SP), AX	
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x40420e		84c0			TESTL AL, AL		
		if !block {
  0x404210		753b			JNE 0x40424d		
			return
  0x404212		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x40421a		c68424b100000000	MOVB $0x0, 0xb1(SP)	
  0x404222		488bac2488000000	MOVQ 0x88(SP), BP	
  0x40422a		4881c490000000		ADDQ $0x90, SP		
  0x404231		c3			RET			
		throw("G waiting list is corrupted")
  0x404232		488d058b7a0600		LEAQ 0x67a8b(IP), AX	
  0x404239		48890424		MOVQ AX, 0(SP)		
  0x40423d		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x404246		e885cf0100		CALL runtime.throw(SB)	
  0x40424b		0f0b			UD2			
		gopark(nil, nil, "chan receive (nil chan)", traceEvGoStop, 2)
  0x40424d		0f57c0			XORPS X0, X0		
  0x404250		0f110424		MOVUPS X0, 0(SP)	
  0x404254		488d05c3730600		LEAQ 0x673c3(IP), AX	
  0x40425b		4889442410		MOVQ AX, 0x10(SP)	
  0x404260		48c744241817000000	MOVQ $0x17, 0x18(SP)	
  0x404269		c644242010		MOVB $0x10, 0x20(SP)	
  0x40426e		48c744242802000000	MOVQ $0x2, 0x28(SP)	
  0x404277		e874eb0100		CALL runtime.gopark(SB)	
		throw("unreachable")
  0x40427c		488d0554620600		LEAQ 0x66254(IP), AX	
  0x404283		48890424		MOVQ AX, 0(SP)		
  0x404287		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x404290		e83bcf0100		CALL runtime.throw(SB)	
  0x404295		0f0b			UD2			
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x404297		e8d4020400		CALL runtime.morestack_noctxt(SB)	
  0x40429c		e95ff9ffff		JMP runtime.chanrecv(SB)		

TEXT runtime.recv(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x4042b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4042b9		483b6110		CMPQ 0x10(CX), SP	
  0x4042bd		0f869b010000		JBE 0x40445e		
  0x4042c3		4883ec30		SUBQ $0x30, SP		
  0x4042c7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4042cc		488d6c2428		LEAQ 0x28(SP), BP	
  0x4042d1		488b4c2438		MOVQ 0x38(SP), CX	
	if c.dataqsiz == 0 {
  0x4042d6		488b5908		MOVQ 0x8(CX), BX	
  0x4042da		4885db			TESTQ BX, BX		
  0x4042dd		0f85eb000000		JNE 0x4043ce		
  0x4042e3		488b5c2448		MOVQ 0x48(SP), BX	
		if ep != nil {
  0x4042e8		4885db			TESTQ BX, BX		
  0x4042eb		0f85bc000000		JNE 0x4043ad		
  0x4042f1		488b4c2440		MOVQ 0x40(SP), CX	
	sg.elem = nil
  0x4042f6		8401			TESTB AL, 0(CX)				
  0x4042f8		8b1d12f70b00		MOVL runtime.writeBarrier(SB), BX	
  0x4042fe		488d7920		LEAQ 0x20(CX), DI			
  0x404302		85db			TESTL BX, BX				
  0x404304		0f8597000000		JNE 0x4043a1				
  0x40430a		48c7412000000000	MOVQ $0x0, 0x20(CX)			
	gp := sg.g
  0x404312		488b01			MOVQ 0(CX), AX		
  0x404315		4889442420		MOVQ AX, 0x20(SP)	
  0x40431a		488b542450		MOVQ 0x50(SP), DX	
	unlockf()
  0x40431f		488b1a			MOVQ 0(DX), BX		
  0x404322		ffd3			CALL BX			
  0x404324		488b442420		MOVQ 0x20(SP), AX	
	gp.param = unsafe.Pointer(sg)
  0x404329		8400			TESTB AL, 0(AX)				
  0x40432b		8b0ddff60b00		MOVL runtime.writeBarrier(SB), CX	
  0x404331		488db888000000		LEAQ 0x88(AX), DI			
  0x404338		85c9			TESTL CX, CX				
  0x40433a		754e			JNE 0x40438a				
  0x40433c		488b4c2440		MOVQ 0x40(SP), CX			
  0x404341		48898888000000		MOVQ CX, 0x88(AX)			
	if sg.releasetime != 0 {
  0x404348		488b5130		MOVQ 0x30(CX), DX	
  0x40434c		4885d2			TESTQ DX, DX		
  0x40434f		7520			JNE 0x404371		
	goready(gp, skip+1)
  0x404351		48890424		MOVQ AX, 0(SP)			
  0x404355		488b442458		MOVQ 0x58(SP), AX		
  0x40435a		48ffc0			INCQ AX				
  0x40435d		4889442408		MOVQ AX, 0x8(SP)		
  0x404362		e869ec0100		CALL runtime.goready(SB)	
}
  0x404367		488b6c2428		MOVQ 0x28(SP), BP	
  0x40436c		4883c430		ADDQ $0x30, SP		
  0x404370		c3			RET			
		sg.releasetime = cputicks()
  0x404371		e87a190400		CALL runtime.cputicks(SB)	
  0x404376		488b0424		MOVQ 0(SP), AX			
  0x40437a		488b4c2440		MOVQ 0x40(SP), CX		
  0x40437f		48894130		MOVQ AX, 0x30(CX)		
  0x404383		488b442420		MOVQ 0x20(SP), AX		
  0x404388		ebc7			JMP 0x404351			
  0x40438a		4889c1			MOVQ AX, CX			
  0x40438d		488b442440		MOVQ 0x40(SP), AX		
	gp.param = unsafe.Pointer(sg)
  0x404392		e809250400		CALL runtime.gcWriteBarrier(SB)	
  0x404397		4889c8			MOVQ CX, AX			
  0x40439a		488b4c2440		MOVQ 0x40(SP), CX		
  0x40439f		eba7			JMP 0x404348			
	sg.elem = nil
  0x4043a1		31c0			XORL AX, AX			
  0x4043a3		e8f8240400		CALL runtime.gcWriteBarrier(SB)	
  0x4043a8		e965ffffff		JMP 0x404312			
			recvDirect(c.elemtype, sg, ep)
  0x4043ad		488b4120		MOVQ 0x20(CX), AX		
  0x4043b1		48890424		MOVQ AX, 0(SP)			
  0x4043b5		488b442440		MOVQ 0x40(SP), AX		
  0x4043ba		4889442408		MOVQ AX, 0x8(SP)		
  0x4043bf		48895c2410		MOVQ BX, 0x10(SP)		
  0x4043c4		e8b7f4ffff		CALL runtime.recvDirect(SB)	
  0x4043c9		e923ffffff		JMP 0x4042f1			
		qp := chanbuf(c, c.recvx)
  0x4043ce		488b4130		MOVQ 0x30(CX), AX	
	return add(c.buf, uintptr(i)*uintptr(c.elemsize))
  0x4043d2		0fb75118		MOVZX 0x18(CX), DX	
  0x4043d6		480fafc2		IMULQ DX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4043da		48034110		ADDQ 0x10(CX), AX	
  0x4043de		488b542448		MOVQ 0x48(SP), DX	
		if ep != nil {
  0x4043e3		4885d2			TESTQ DX, DX		
  0x4043e6		754e			JNE 0x404436		
		typedmemmove(c.elemtype, qp, sg.elem)
  0x4043e8		488b5120		MOVQ 0x20(CX), DX		
  0x4043ec		488b5c2440		MOVQ 0x40(SP), BX		
  0x4043f1		488b7320		MOVQ 0x20(BX), SI		
  0x4043f5		4889742410		MOVQ SI, 0x10(SP)		
  0x4043fa		48891424		MOVQ DX, 0(SP)			
  0x4043fe		4889442408		MOVQ AX, 0x8(SP)		
  0x404403		e888760000		CALL runtime.typedmemmove(SB)	
  0x404408		488b442438		MOVQ 0x38(SP), AX		
		c.recvx++
  0x40440d		488b4830		MOVQ 0x30(AX), CX	
  0x404411		48ffc1			INCQ CX			
  0x404414		48894830		MOVQ CX, 0x30(AX)	
		if c.recvx == c.dataqsiz {
  0x404418		488b5008		MOVQ 0x8(AX), DX	
  0x40441c		4839d1			CMPQ DX, CX		
  0x40441f		7508			JNE 0x404429		
			c.recvx = 0
  0x404421		48c7403000000000	MOVQ $0x0, 0x30(AX)	
		c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
  0x404429		488b4830		MOVQ 0x30(AX), CX	
  0x40442d		48894828		MOVQ CX, 0x28(AX)	
  0x404431		e9bbfeffff		JMP 0x4042f1		
  0x404436		4889442418		MOVQ AX, 0x18(SP)	
			typedmemmove(c.elemtype, ep, qp)
  0x40443b		488b5920		MOVQ 0x20(CX), BX		
  0x40443f		48891c24		MOVQ BX, 0(SP)			
  0x404443		4889542408		MOVQ DX, 0x8(SP)		
  0x404448		4889442410		MOVQ AX, 0x10(SP)		
  0x40444d		e83e760000		CALL runtime.typedmemmove(SB)	
  0x404452		488b442418		MOVQ 0x18(SP), AX		
  0x404457		488b4c2438		MOVQ 0x38(SP), CX		
  0x40445c		eb8a			JMP 0x4043e8			
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x40445e		e80d010400		CALL runtime.morestack_noctxt(SB)	
  0x404463		e948feffff		JMP runtime.recv(SB)			

TEXT runtime.(*waitq).dequeue(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
func (q *waitq) dequeue() *sudog {
  0x404470		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404479		483b6110		CMPQ 0x10(CX), SP	
  0x40447d		0f86d6000000		JBE 0x404559		
  0x404483		4883ec08		SUBQ $0x8, SP		
  0x404487		48892c24		MOVQ BP, 0(SP)		
  0x40448b		488d2c24		LEAQ 0(SP), BP		
	for {
  0x40448f		488b4c2410		MOVQ 0x10(SP), CX	
		sgp := q.first
  0x404494		488b11			MOVQ 0(CX), DX		
		if sgp == nil {
  0x404497		4885d2			TESTQ DX, DX		
  0x40449a		0f84a7000000		JE 0x404547		
		y := sgp.next
  0x4044a0		488b5a10		MOVQ 0x10(DX), BX	
  0x4044a4		488d7210		LEAQ 0x10(DX), SI	
		if y == nil {
  0x4044a8		4885db			TESTQ BX, BX		
  0x4044ab		7470			JE 0x40451d		
			y.prev = nil
  0x4044ad		448b055cf50b00		MOVL runtime.writeBarrier(SB), R8	
  0x4044b4		488d7b18		LEAQ 0x18(BX), DI			
  0x4044b8		4585c0			TESTL R8, R8				
  0x4044bb		7542			JNE 0x4044ff				
  0x4044bd		48c7431800000000	MOVQ $0x0, 0x18(BX)			
			q.first = y
  0x4044c5		488919			MOVQ BX, 0(CX)		
			sgp.next = nil // mark as removed (see dequeueSudog)
  0x4044c8		48c7421000000000	MOVQ $0x0, 0x10(DX)	
		if sgp.isSelect {
  0x4044d0		0fb65a08		MOVZX 0x8(DX), BX	
  0x4044d4		84db			TESTL BL, BL		
  0x4044d6		7419			JE 0x4044f1		
			if !atomic.Cas(&sgp.g.selectDone, 0, 1) {
  0x4044d8		488b1a			MOVQ 0(DX), BX			
  0x4044db		31c0			XORL AX, AX			
  0x4044dd		be01000000		MOVL $0x1, SI			
  0x4044e2		f00fb1b368010000	LOCK CMPXCHGL SI, 0x168(BX)	
  0x4044ea		0f94c3			SETE BL				
  0x4044ed		84db			TESTL BL, BL			
  0x4044ef		74a3			JE 0x404494			
		return sgp
  0x4044f1		4889542418		MOVQ DX, 0x18(SP)	
  0x4044f6		488b2c24		MOVQ 0(SP), BP		
  0x4044fa		4883c408		ADDQ $0x8, SP		
  0x4044fe		c3			RET			
			y.prev = nil
  0x4044ff		31c0			XORL AX, AX			
  0x404501		e89a230400		CALL runtime.gcWriteBarrier(SB)	
  0x404506		4889cf			MOVQ CX, DI			
  0x404509		4889d8			MOVQ BX, AX			
			q.first = y
  0x40450c		e88f230400		CALL runtime.gcWriteBarrier(SB)	
  0x404511		4889f7			MOVQ SI, DI			
			sgp.next = nil // mark as removed (see dequeueSudog)
  0x404514		31c0			XORL AX, AX			
  0x404516		e885230400		CALL runtime.gcWriteBarrier(SB)	
			y.prev = nil
  0x40451b		ebb3			JMP 0x4044d0		
			q.first = nil
  0x40451d		8b1dedf40b00		MOVL runtime.writeBarrier(SB), BX	
			q.last = nil
  0x404523		488d7108		LEAQ 0x8(CX), SI	
			q.first = nil
  0x404527		85db			TESTL BX, BX		
  0x404529		7508			JNE 0x404533		
			q.last = nil
  0x40452b		0f57c0			XORPS X0, X0		
  0x40452e		0f1101			MOVUPS X0, 0(CX)	
			q.first = nil
  0x404531		eb9d			JMP 0x4044d0			
  0x404533		4889cf			MOVQ CX, DI			
  0x404536		31c0			XORL AX, AX			
  0x404538		e863230400		CALL runtime.gcWriteBarrier(SB)	
  0x40453d		4889f7			MOVQ SI, DI			
			q.last = nil
  0x404540		e85b230400		CALL runtime.gcWriteBarrier(SB)	
			q.first = nil
  0x404545		eb89			JMP 0x4044d0		
			return nil
  0x404547		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x404550		488b2c24		MOVQ 0(SP), BP		
  0x404554		4883c408		ADDQ $0x8, SP		
  0x404558		c3			RET			
func (q *waitq) dequeue() *sudog {
  0x404559		e812000400		CALL runtime.morestack_noctxt(SB)	
  0x40455e		e90dffffff		JMP runtime.(*waitq).dequeue(SB)	

TEXT runtime.init.0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cpuflags_amd64.go
	processor := processorVersionInfo & 0x0FFF3FF0
  0x404570		8b0582f30b00		MOVL runtime.processorVersionInfo(SB), AX	
  0x404576		25f03fff0f		ANDL $0xfff3ff0, AX				
	isIntelBridgeFamily := isIntel &&
  0x40457b		0fb60d28f30b00		MOVZX runtime.isIntel(SB), CX	
  0x404582		84c9			TESTL CL, CL			
  0x404584		7425			JE 0x4045ab			
		processor == 0x206A0 ||
  0x404586		3da0060200		CMPL $0x206a0, AX	
  0x40458b		751e			JNE 0x4045ab		
  0x40458d		b801000000		MOVL $0x1, AX		
	useAVXmemmove = support_avx && !isIntelBridgeFamily
  0x404592		0fb60d19f30b00		MOVZX runtime.support_avx(SB), CX	
  0x404599		84c9			TESTL CL, CL				
  0x40459b		740a			JE 0x4045a7				
  0x40459d		83f001			XORL $0x1, AX				
  0x4045a0		880517f30b00		MOVB AL, runtime.useAVXmemmove(SB)	
}
  0x4045a6		c3			RET			
  0x4045a7		31c0			XORL AX, AX		
	useAVXmemmove = support_avx && !isIntelBridgeFamily
  0x4045a9		ebf5			JMP 0x4045a0		
		processor == 0x206D0 ||
  0x4045ab		3dd0060200		CMPL $0x206d0, AX	
  0x4045b0		7507			JNE 0x4045b9		
  0x4045b2		b801000000		MOVL $0x1, AX		
  0x4045b7		ebd9			JMP 0x404592		
		processor == 0x306A0 ||
  0x4045b9		3da0060300		CMPL $0x306a0, AX	
  0x4045be		7507			JNE 0x4045c7		
  0x4045c0		b801000000		MOVL $0x1, AX		
  0x4045c5		ebcb			JMP 0x404592		
		processor == 0x306E0
  0x4045c7		3de0060300		CMPL $0x306e0, AX	
  0x4045cc		0f94c0			SETE AL			
  0x4045cf		ebc1			JMP 0x404592		

TEXT runtime.(*cpuProfile).add(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cpuprof.go
func (p *cpuProfile) add(gp *g, stk []uintptr) {
  0x4045e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4045e9		483b6110		CMPQ 0x10(CX), SP	
  0x4045ed		0f8605010000		JBE 0x4046f8		
  0x4045f3		4883ec58		SUBQ $0x58, SP		
  0x4045f7		48896c2450		MOVQ BP, 0x50(SP)	
  0x4045fc		488d6c2450		LEAQ 0x50(SP), BP	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x404601		eb05			JMP 0x404608		
		osyield()
  0x404603		e848390400		CALL runtime.osyield(SB)	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x404608		31c0			XORL AX, AX			
  0x40460a		488d0d9ff30b00		LEAQ runtime.prof(SB), CX	
  0x404611		ba01000000		MOVL $0x1, DX			
  0x404616		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x40461a		0f94c3			SETE BL				
  0x40461d		84db			TESTL BL, BL			
  0x40461f		74e2			JE 0x404603			
	if prof.hz != 0 { // implies cpuprof.log != nil
  0x404621		8b058df30b00		MOVL runtime.prof+4(SB), AX	
  0x404627		85c0			TESTL AX, AX			
  0x404629		0f849f000000		JE 0x4046ce			
  0x40462f		488b442460		MOVQ 0x60(SP), AX		
		if p.numExtra > 0 || p.lostExtra > 0 {
  0x404634		8400			TESTB AL, 0(AX)		
  0x404636		488b90581f0000		MOVQ 0x1f58(AX), DX	
  0x40463d		4885d2			TESTQ DX, DX		
  0x404640		0f8e9d000000		JLE 0x4046e3		
			p.addExtra()
  0x404646		48890424		MOVQ AX, 0(SP)				
  0x40464a		e8d1010000		CALL runtime.(*cpuProfile).addExtra(SB)	
		hdr := [1]uint64{1}
  0x40464f		48c744244800000000	MOVQ $0x0, 0x48(SP)	
  0x404658		48c744244801000000	MOVQ $0x1, 0x48(SP)	
		cpuprof.log.write(&gp.labels, nanotime(), hdr[:], stk)
  0x404661		e8ca330400		CALL runtime.nanotime(SB)		
  0x404666		488b442468		MOVQ 0x68(SP), AX			
  0x40466b		8400			TESTB AL, 0(AX)				
  0x40466d		480558010000		ADDQ $0x158, AX				
  0x404673		488b0c24		MOVQ 0(SP), CX				
  0x404677		4889442408		MOVQ AX, 0x8(SP)			
  0x40467c		488b05ad3c0a00		MOVQ runtime.cpuprof+16(SB), AX		
  0x404683		48890424		MOVQ AX, 0(SP)				
  0x404687		48894c2410		MOVQ CX, 0x10(SP)			
  0x40468c		488d442448		LEAQ 0x48(SP), AX			
  0x404691		4889442418		MOVQ AX, 0x18(SP)			
  0x404696		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x40469f		48c744242801000000	MOVQ $0x1, 0x28(SP)			
  0x4046a8		488b442470		MOVQ 0x70(SP), AX			
  0x4046ad		4889442430		MOVQ AX, 0x30(SP)			
  0x4046b2		488b442478		MOVQ 0x78(SP), AX			
  0x4046b7		4889442438		MOVQ AX, 0x38(SP)			
  0x4046bc		488b842480000000	MOVQ 0x80(SP), AX			
  0x4046c4		4889442440		MOVQ AX, 0x40(SP)			
  0x4046c9		e832a10200		CALL runtime.(*profBuf).write(SB)	
	atomic.Store(&prof.signalLock, 0)
  0x4046ce		31c0			XORL AX, AX			
  0x4046d0		488d0dd9f20b00		LEAQ runtime.prof(SB), CX	
  0x4046d7		8701			XCHGL AX, 0(CX)			
}
  0x4046d9		488b6c2450		MOVQ 0x50(SP), BP	
  0x4046de		4883c458		ADDQ $0x58, SP		
  0x4046e2		c3			RET			
		if p.numExtra > 0 || p.lostExtra > 0 {
  0x4046e3		488b90601f0000		MOVQ 0x1f60(AX), DX	
  0x4046ea		4885d2			TESTQ DX, DX		
  0x4046ed		0f8753ffffff		JA 0x404646		
  0x4046f3		e957ffffff		JMP 0x40464f		
func (p *cpuProfile) add(gp *g, stk []uintptr) {
  0x4046f8		e873fe0300		CALL runtime.morestack_noctxt(SB)	
  0x4046fd		e9defeffff		JMP runtime.(*cpuProfile).add(SB)	

TEXT runtime.(*cpuProfile).addNonGo(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cpuprof.go
func (p *cpuProfile) addNonGo(stk []uintptr) {
  0x404710		4883ec20		SUBQ $0x20, SP		
  0x404714		48896c2418		MOVQ BP, 0x18(SP)	
  0x404719		488d6c2418		LEAQ 0x18(SP), BP	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x40471e		eb05			JMP 0x404725		
		osyield()
  0x404720		e82b380400		CALL runtime.osyield(SB)	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x404725		31c0			XORL AX, AX			
  0x404727		488d0d82f20b00		LEAQ runtime.prof(SB), CX	
  0x40472e		ba01000000		MOVL $0x1, DX			
  0x404733		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x404737		0f94c3			SETE BL				
  0x40473a		84db			TESTL BL, BL			
  0x40473c		74e2			JE 0x404720			
	if cpuprof.numExtra+1+len(stk) < len(cpuprof.extra) {
  0x40473e		488b05335b0a00		MOVQ runtime.cpuprof+8024(SB), AX	
  0x404745		488b542438		MOVQ 0x38(SP), DX			
  0x40474a		488d5c0201		LEAQ 0x1(DX)(AX*1), BX			
  0x40474f		4881fbe8030000		CMPQ $0x3e8, BX				
  0x404756		0f8da3000000		JGE 0x4047ff				
		cpuprof.extra[i] = uintptr(1 + len(stk))
  0x40475c		483de8030000		CMPQ $0x3e8, AX			
  0x404762		0f83a7000000		JAE 0x40480f			
  0x404768		488d5a01		LEAQ 0x1(DX), BX		
  0x40476c		488d35ad3b0a00		LEAQ runtime.cpuprof(SB), SI	
  0x404773		48895cc618		MOVQ BX, 0x18(SI)(AX*8)		
		copy(cpuprof.extra[i+1:], stk)
  0x404778		488d1db93b0a00		LEAQ runtime.cpuprof+24(SB), BX	
  0x40477f		8403			TESTB AL, 0(BX)			
  0x404781		488d7001		LEAQ 0x1(AX), SI		
  0x404785		4881fee8030000		CMPQ $0x3e8, SI			
  0x40478c		777a			JA 0x404808			
  0x40478e		480519fcffff		ADDQ $-0x3e7, AX		
  0x404794		48f7d8			NEGQ AX				
  0x404797		4889c7			MOVQ AX, DI			
  0x40479a		48f7d8			NEGQ AX				
  0x40479d		48c1f83f		SARQ $0x3f, AX			
  0x4047a1		48c1e603		SHLQ $0x3, SI			
  0x4047a5		4821c6			ANDQ AX, SI			
  0x4047a8		488d0433		LEAQ 0(BX)(SI*1), AX		
  0x4047ac		4839d7			CMPQ DX, DI			
  0x4047af		7e49			JLE 0x4047fa			
  0x4047b1		48890424		MOVQ AX, 0(SP)			
  0x4047b5		488b442430		MOVQ 0x30(SP), AX		
  0x4047ba		4889442408		MOVQ AX, 0x8(SP)		
  0x4047bf		48c1e203		SHLQ $0x3, DX			
  0x4047c3		4889542410		MOVQ DX, 0x10(SP)		
  0x4047c8		e833290400		CALL runtime.memmove(SB)	
		cpuprof.numExtra += 1 + len(stk)
  0x4047cd		488b05a45a0a00		MOVQ runtime.cpuprof+8024(SB), AX	
  0x4047d4		488b4c2438		MOVQ 0x38(SP), CX			
  0x4047d9		488d440801		LEAQ 0x1(AX)(CX*1), AX			
  0x4047de		488905935a0a00		MOVQ AX, runtime.cpuprof+8024(SB)	
	atomic.Store(&prof.signalLock, 0)
  0x4047e5		31c0			XORL AX, AX			
  0x4047e7		488d0dc2f10b00		LEAQ runtime.prof(SB), CX	
  0x4047ee		8701			XCHGL AX, 0(CX)			
}
  0x4047f0		488b6c2418		MOVQ 0x18(SP), BP	
  0x4047f5		4883c420		ADDQ $0x20, SP		
  0x4047f9		c3			RET			
  0x4047fa		4889fa			MOVQ DI, DX		
		copy(cpuprof.extra[i+1:], stk)
  0x4047fd		ebb2			JMP 0x4047b1		
		cpuprof.lostExtra++
  0x4047ff		48ff057a5a0a00		INCQ runtime.cpuprof+8032(SB)	
  0x404806		ebdd			JMP 0x4047e5			
		copy(cpuprof.extra[i+1:], stk)
  0x404808		e8a3b20100		CALL runtime.panicslice(SB)	
  0x40480d		0f0b			UD2				
		cpuprof.extra[i] = uintptr(1 + len(stk))
  0x40480f		e82cb20100		CALL runtime.panicindex(SB)	
  0x404814		0f0b			UD2				

TEXT runtime.(*cpuProfile).addExtra(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cpuprof.go
func (p *cpuProfile) addExtra() {
  0x404820		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404829		488d4424e8		LEAQ -0x18(SP), AX	
  0x40482e		483b4110		CMPQ 0x10(CX), AX	
  0x404832		0f8626020000		JBE 0x404a5e		
  0x404838		4881ec98000000		SUBQ $0x98, SP		
  0x40483f		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x404847		488dac2490000000	LEAQ 0x90(SP), BP	
	hdr := [1]uint64{1}
  0x40484f		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x404858		48c744245801000000	MOVQ $0x1, 0x58(SP)	
func (p *cpuProfile) addExtra() {
  0x404861		31c0			XORL AX, AX		
	for i := 0; i < p.numExtra; {
  0x404863		e980000000		JMP 0x4048e8		
  0x404868		4889442448		MOVQ AX, 0x48(SP)	
		p.log.write(nil, 0, hdr[:], p.extra[i+1:i+int(p.extra[i])])
  0x40486d		488b7110		MOVQ 0x10(CX), SI			
  0x404871		48893424		MOVQ SI, 0(SP)				
  0x404875		0f57c0			XORPS X0, X0				
  0x404878		0f11442408		MOVUPS X0, 0x8(SP)			
  0x40487d		488d742458		LEAQ 0x58(SP), SI			
  0x404882		4889742418		MOVQ SI, 0x18(SP)			
  0x404887		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x404890		48c744242801000000	MOVQ $0x1, 0x28(SP)			
  0x404899		488db819fcffff		LEAQ 0xfffffc19(AX), DI			
  0x4048a0		48f7df			NEGQ DI					
  0x4048a3		4989f8			MOVQ DI, R8				
  0x4048a6		48f7df			NEGQ DI					
  0x4048a9		48c1ff3f		SARQ $0x3f, DI				
  0x4048ad		4989d1			MOVQ DX, R9				
  0x4048b0		48c1e203		SHLQ $0x3, DX				
  0x4048b4		4821fa			ANDQ DI, DX				
  0x4048b7		488d541118		LEAQ 0x18(CX)(DX*1), DX			
  0x4048bc		4889542430		MOVQ DX, 0x30(SP)			
  0x4048c1		4c29cb			SUBQ R9, BX				
  0x4048c4		48895c2438		MOVQ BX, 0x38(SP)			
  0x4048c9		4c89442440		MOVQ R8, 0x40(SP)			
  0x4048ce		e82d9f0200		CALL runtime.(*profBuf).write(SB)	
  0x4048d3		488b442448		MOVQ 0x48(SP), AX			
  0x4048d8		488b8c24a0000000	MOVQ 0xa0(SP), CX			
		i += int(p.extra[i])
  0x4048e0		488b54c118		MOVQ 0x18(CX)(AX*8), DX	
  0x4048e5		4801d0			ADDQ DX, AX		
	for i := 0; i < p.numExtra; {
  0x4048e8		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x4048f0		8401			TESTB AL, 0(CX)		
  0x4048f2		488b91581f0000		MOVQ 0x1f58(CX), DX	
  0x4048f9		4839d0			CMPQ DX, AX		
  0x4048fc		7d39			JGE 0x404937		
		p.log.write(nil, 0, hdr[:], p.extra[i+1:i+int(p.extra[i])])
  0x4048fe		483de8030000		CMPQ $0x3e8, AX		
  0x404904		0f8346010000		JAE 0x404a50		
  0x40490a		488d5118		LEAQ 0x18(CX), DX	
  0x40490e		8402			TESTB AL, 0(DX)		
  0x404910		488d5001		LEAQ 0x1(AX), DX	
  0x404914		488b5cc118		MOVQ 0x18(CX)(AX*8), BX	
  0x404919		4801c3			ADDQ AX, BX		
  0x40491c		4839da			CMPQ BX, DX		
  0x40491f		0f8732010000		JA 0x404a57		
  0x404925		4881fbe8030000		CMPQ $0x3e8, BX		
  0x40492c		0f8636ffffff		JBE 0x404868		
  0x404932		e920010000		JMP 0x404a57		
	p.numExtra = 0
  0x404937		48c781581f000000000000	MOVQ $0x0, 0x1f58(CX)	
	if p.lostExtra > 0 {
  0x404942		488b81601f0000		MOVQ 0x1f60(CX), AX	
  0x404949		4885c0			TESTQ AX, AX		
  0x40494c		7710			JA 0x40495e		
  0x40494e		488bac2490000000	MOVQ 0x90(SP), BP	
  0x404956		4881c498000000		ADDQ $0x98, SP		
  0x40495d		c3			RET			
		hdr := [1]uint64{p.lostExtra}
  0x40495e		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x404967		488b81601f0000		MOVQ 0x1f60(CX), AX	
  0x40496e		4889442450		MOVQ AX, 0x50(SP)	
			funcPC(_LostExternalCode) + sys.PCQuantum,
  0x404973		488d05661d0500		LEAQ 0x51d66(IP), AX	
  0x40497a		4889442470		MOVQ AX, 0x70(SP)	
  0x40497f		488d15ea950600		LEAQ 0x695ea(IP), DX	
  0x404986		4889542478		MOVQ DX, 0x78(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x40498b		488d542470		LEAQ 0x70(SP), DX	
  0x404990		bb08000000		MOVL $0x8, BX		
  0x404995		488b1413		MOVQ 0(BX)(DX*1), DX	
  0x404999		488d742478		LEAQ 0x78(SP), SI	
  0x40499e		8406			TESTB AL, 0(SI)		
  0x4049a0		488b12			MOVQ 0(DX), DX		
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x4049a3		4889842480000000	MOVQ AX, 0x80(SP)	
  0x4049ab		488d05ae950600		LEAQ 0x695ae(IP), AX	
  0x4049b2		4889842488000000	MOVQ AX, 0x88(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x4049ba		488d842480000000	LEAQ 0x80(SP), AX	
  0x4049c2		488b0418		MOVQ 0(AX)(BX*1), AX	
  0x4049c6		488d9c2488000000	LEAQ 0x88(SP), BX	
  0x4049ce		8403			TESTB AL, 0(BX)		
  0x4049d0		488b00			MOVQ 0(AX), AX		
		lostStk := [2]uintptr{
  0x4049d3		0f57c0			XORPS X0, X0		
  0x4049d6		0f11442460		MOVUPS X0, 0x60(SP)	
			funcPC(_LostExternalCode) + sys.PCQuantum,
  0x4049db		48ffc2			INCQ DX			
  0x4049de		4889542460		MOVQ DX, 0x60(SP)	
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x4049e3		48ffc0			INCQ AX			
  0x4049e6		4889442468		MOVQ AX, 0x68(SP)	
		cpuprof.log.write(nil, 0, hdr[:], lostStk[:])
  0x4049eb		488b053e390a00		MOVQ runtime.cpuprof+16(SB), AX		
  0x4049f2		48890424		MOVQ AX, 0(SP)				
  0x4049f6		0f11442408		MOVUPS X0, 0x8(SP)			
  0x4049fb		488d442450		LEAQ 0x50(SP), AX			
  0x404a00		4889442418		MOVQ AX, 0x18(SP)			
  0x404a05		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x404a0e		48c744242801000000	MOVQ $0x1, 0x28(SP)			
  0x404a17		488d442460		LEAQ 0x60(SP), AX			
  0x404a1c		4889442430		MOVQ AX, 0x30(SP)			
  0x404a21		48c744243802000000	MOVQ $0x2, 0x38(SP)			
  0x404a2a		48c744244002000000	MOVQ $0x2, 0x40(SP)			
  0x404a33		e8c89d0200		CALL runtime.(*profBuf).write(SB)	
  0x404a38		488b8424a0000000	MOVQ 0xa0(SP), AX			
		p.lostExtra = 0
  0x404a40		48c780601f000000000000	MOVQ $0x0, 0x1f60(AX)	
  0x404a4b		e9fefeffff		JMP 0x40494e		
		p.log.write(nil, 0, hdr[:], p.extra[i+1:i+int(p.extra[i])])
  0x404a50		e8ebaf0100		CALL runtime.panicindex(SB)	
  0x404a55		0f0b			UD2				
  0x404a57		e854b00100		CALL runtime.panicslice(SB)	
  0x404a5c		0f0b			UD2				
func (p *cpuProfile) addExtra() {
  0x404a5e		e80dfb0300		CALL runtime.morestack_noctxt(SB)	
  0x404a63		e9b8fdffff		JMP runtime.(*cpuProfile).addExtra(SB)	

TEXT runtime.gogetenv(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/env_posix.go
func gogetenv(key string) string {
  0x404a70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404a79		483b6110		CMPQ 0x10(CX), SP	
  0x404a7d		0f8617010000		JBE 0x404b9a		
  0x404a83		4883ec50		SUBQ $0x50, SP		
  0x404a87		48896c2448		MOVQ BP, 0x48(SP)	
  0x404a8c		488d6c2448		LEAQ 0x48(SP), BP	
	env := environ()
  0x404a91		488b05602c0a00		MOVQ runtime.envs+8(SB), AX	
  0x404a98		488b0d512c0a00		MOVQ runtime.envs(SB), CX	
	if env == nil {
  0x404a9f		4885c9			TESTQ CX, CX		
  0x404aa2		0f84d7000000		JE 0x404b7f		
  0x404aa8		4889442428		MOVQ AX, 0x28(SP)	
  0x404aad		31d2			XORL DX, DX		
	for _, s := range env {
  0x404aaf		eb07			JMP 0x404ab8		
  0x404ab1		4883c110		ADDQ $0x10, CX		
  0x404ab5		48ffc2			INCQ DX			
  0x404ab8		4839c2			CMPQ AX, DX		
  0x404abb		0f8da5000000		JGE 0x404b66		
  0x404ac1		488b19			MOVQ 0(CX), BX		
  0x404ac4		488b7108		MOVQ 0x8(CX), SI	
  0x404ac8		488b7c2460		MOVQ 0x60(SP), DI	
		if len(s) > len(key) && s[len(key)] == '=' && s[:len(key)] == key {
  0x404acd		4839fe			CMPQ DI, SI			
  0x404ad0		7edf			JLE 0x404ab1			
  0x404ad2		440fb6043b		MOVZX 0(BX)(DI*1), R8		
  0x404ad7		4180f83d		CMPL $0x3d, R8			
  0x404adb		75d4			JNE 0x404ab1			
  0x404add		4889542430		MOVQ DX, 0x30(SP)		
  0x404ae2		48895c2438		MOVQ BX, 0x38(SP)		
  0x404ae7		4889742420		MOVQ SI, 0x20(SP)		
  0x404aec		48894c2440		MOVQ CX, 0x40(SP)		
  0x404af1		48891c24		MOVQ BX, 0(SP)			
  0x404af5		488b442458		MOVQ 0x58(SP), AX		
  0x404afa		4889442408		MOVQ AX, 0x8(SP)		
  0x404aff		48897c2410		MOVQ DI, 0x10(SP)		
  0x404b04		e837180400		CALL runtime.memequal(SB)	
  0x404b09		0fb6442418		MOVZX 0x18(SP), AX		
  0x404b0e		84c0			TESTL AL, AL			
  0x404b10		7516			JNE 0x404b28			
  0x404b12		488b442428		MOVQ 0x28(SP), AX		
  0x404b17		488b4c2440		MOVQ 0x40(SP), CX		
  0x404b1c		488b542430		MOVQ 0x30(SP), DX		
  0x404b21		488b7c2460		MOVQ 0x60(SP), DI		
  0x404b26		eb89			JMP 0x404ab1			
  0x404b28		488b442460		MOVQ 0x60(SP), AX		
			return s[len(key)+1:]
  0x404b2d		48ffc0			INCQ AX			
  0x404b30		488b4c2420		MOVQ 0x20(SP), CX	
  0x404b35		4839c8			CMPQ CX, AX		
  0x404b38		773e			JA 0x404b78		
  0x404b3a		4829c1			SUBQ AX, CX		
  0x404b3d		4889ca			MOVQ CX, DX		
  0x404b40		48f7d9			NEGQ CX			
  0x404b43		48c1f93f		SARQ $0x3f, CX		
  0x404b47		4821c8			ANDQ CX, AX		
  0x404b4a		488b4c2438		MOVQ 0x38(SP), CX	
  0x404b4f		4801c8			ADDQ CX, AX		
  0x404b52		4889442468		MOVQ AX, 0x68(SP)	
  0x404b57		4889542470		MOVQ DX, 0x70(SP)	
  0x404b5c		488b6c2448		MOVQ 0x48(SP), BP	
  0x404b61		4883c450		ADDQ $0x50, SP		
  0x404b65		c3			RET			
	return ""
  0x404b66		0f57c0			XORPS X0, X0		
  0x404b69		0f11442468		MOVUPS X0, 0x68(SP)	
  0x404b6e		488b6c2448		MOVQ 0x48(SP), BP	
  0x404b73		4883c450		ADDQ $0x50, SP		
  0x404b77		c3			RET			
			return s[len(key)+1:]
  0x404b78		e833af0100		CALL runtime.panicslice(SB)	
  0x404b7d		0f0b			UD2				
		throw("getenv before env init")
  0x404b7f		488d0598680600		LEAQ 0x66898(IP), AX	
  0x404b86		48890424		MOVQ AX, 0(SP)		
  0x404b8a		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x404b93		e838c60100		CALL runtime.throw(SB)	
  0x404b98		0f0b			UD2			
func gogetenv(key string) string {
  0x404b9a		e8d1f90300		CALL runtime.morestack_noctxt(SB)	
  0x404b9f		e9ccfeffff		JMP runtime.gogetenv(SB)		

TEXT runtime.(*TypeAssertionError).Error(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/error.go
func (e *TypeAssertionError) Error() string {
  0x404bb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404bb9		488d842460ffffff	LEAQ 0xffffff60(SP), AX	
  0x404bc1		483b4110		CMPQ 0x10(CX), AX	
  0x404bc5		0f863a020000		JBE 0x404e05		
  0x404bcb		4881ec20010000		SUBQ $0x120, SP		
  0x404bd2		4889ac2418010000	MOVQ BP, 0x118(SP)	
  0x404bda		488dac2418010000	LEAQ 0x118(SP), BP	
  0x404be2		488b842428010000	MOVQ 0x128(SP), AX	
	inter := e.interfaceString
  0x404bea		488b4808		MOVQ 0x8(AX), CX	
  0x404bee		488b10			MOVQ 0(AX), DX		
	if inter == "" {
  0x404bf1		4885c9			TESTQ CX, CX		
  0x404bf4		750c			JNE 0x404c02		
  0x404bf6		b909000000		MOVL $0x9, CX		
  0x404bfb		488d151e550600		LEAQ 0x6551e(IP), DX	
	if e.concreteString == "" {
  0x404c02		488b5818		MOVQ 0x18(AX), BX	
  0x404c06		4885db			TESTQ BX, BX		
  0x404c09		0f8479010000		JE 0x404d88		
	if e.missingMethod == "" {
  0x404c0f		488b5838		MOVQ 0x38(AX), BX	
  0x404c13		4885db			TESTQ BX, BX		
  0x404c16		0f85b8000000		JNE 0x404cd4		
			", not " + e.assertedString
  0x404c1c		488dbc24b8000000	LEAQ 0xb8(SP), DI			
  0x404c24		488d3555020700		LEAQ runtime.statictmp_7(SB), SI	
  0x404c2b		48896c24f0		MOVQ BP, -0x10(SP)			
  0x404c30		488d6c24f0		LEAQ -0x10(SP), BP			
  0x404c35		e8d2210400		CALL 0x446e0c				
  0x404c3a		488b6d00		MOVQ 0(BP), BP				
  0x404c3e		48899424c8000000	MOVQ DX, 0xc8(SP)			
  0x404c46		48898c24d0000000	MOVQ CX, 0xd0(SP)			
		return "interface conversion: " + inter + " is " + e.concreteString +
  0x404c4e		488b4818		MOVQ 0x18(AX), CX	
  0x404c52		488b5010		MOVQ 0x10(AX), DX	
  0x404c56		48899424e8000000	MOVQ DX, 0xe8(SP)	
  0x404c5e		48898c24f0000000	MOVQ CX, 0xf0(SP)	
			", not " + e.assertedString
  0x404c66		488b4828		MOVQ 0x28(AX), CX		
  0x404c6a		488b4020		MOVQ 0x20(AX), AX		
  0x404c6e		4889842408010000	MOVQ AX, 0x108(SP)		
  0x404c76		48898c2410010000	MOVQ CX, 0x110(SP)		
  0x404c7e		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x404c86		488d8424b8000000	LEAQ 0xb8(SP), AX		
  0x404c8e		4889442408		MOVQ AX, 0x8(SP)		
  0x404c93		48c744241006000000	MOVQ $0x6, 0x10(SP)		
  0x404c9c		48c744241806000000	MOVQ $0x6, 0x18(SP)		
  0x404ca5		e886200300		CALL runtime.concatstrings(SB)	
  0x404caa		488b442420		MOVQ 0x20(SP), AX		
  0x404caf		488b4c2428		MOVQ 0x28(SP), CX		
		return "interface conversion: " + inter + " is " + e.concreteString +
  0x404cb4		4889842430010000	MOVQ AX, 0x130(SP)	
  0x404cbc		48898c2438010000	MOVQ CX, 0x138(SP)	
			", not " + e.assertedString
  0x404cc4		488bac2418010000	MOVQ 0x118(SP), BP	
  0x404ccc		4881c420010000		ADDQ $0x120, SP		
  0x404cd3		c3			RET			
		": missing method " + e.missingMethod
  0x404cd4		488d7c2458		LEAQ 0x58(SP), DI			
  0x404cd9		488d3500020700		LEAQ runtime.statictmp_8(SB), SI	
  0x404ce0		48896c24f0		MOVQ BP, -0x10(SP)			
  0x404ce5		488d6c24f0		LEAQ -0x10(SP), BP			
  0x404cea		e81d210400		CALL 0x446e0c				
  0x404cef		488b6d00		MOVQ 0(BP), BP				
	return "interface conversion: " + e.concreteString + " is not " + e.assertedString +
  0x404cf3		488b4810		MOVQ 0x10(AX), CX	
  0x404cf7		488b5018		MOVQ 0x18(AX), DX	
  0x404cfb		48894c2468		MOVQ CX, 0x68(SP)	
  0x404d00		4889542470		MOVQ DX, 0x70(SP)	
  0x404d05		488b4820		MOVQ 0x20(AX), CX	
  0x404d09		488b5028		MOVQ 0x28(AX), DX	
  0x404d0d		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x404d15		4889942490000000	MOVQ DX, 0x90(SP)	
		": missing method " + e.missingMethod
  0x404d1d		488b4830		MOVQ 0x30(AX), CX		
  0x404d21		488b4038		MOVQ 0x38(AX), AX		
  0x404d25		48898c24a8000000	MOVQ CX, 0xa8(SP)		
  0x404d2d		48898424b0000000	MOVQ AX, 0xb0(SP)		
  0x404d35		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x404d3d		488d442458		LEAQ 0x58(SP), AX		
  0x404d42		4889442408		MOVQ AX, 0x8(SP)		
  0x404d47		48c744241006000000	MOVQ $0x6, 0x10(SP)		
  0x404d50		48c744241806000000	MOVQ $0x6, 0x18(SP)		
  0x404d59		e8d21f0300		CALL runtime.concatstrings(SB)	
  0x404d5e		488b442420		MOVQ 0x20(SP), AX		
  0x404d63		488b4c2428		MOVQ 0x28(SP), CX		
	return "interface conversion: " + e.concreteString + " is not " + e.assertedString +
  0x404d68		4889842430010000	MOVQ AX, 0x130(SP)	
  0x404d70		48898c2438010000	MOVQ CX, 0x138(SP)	
		": missing method " + e.missingMethod
  0x404d78		488bac2418010000	MOVQ 0x118(SP), BP	
  0x404d80		4881c420010000		ADDQ $0x120, SP		
  0x404d87		c3			RET			
		return "interface conversion: " + inter + " is nil, not " + e.assertedString
  0x404d88		488b5828		MOVQ 0x28(AX), BX		
  0x404d8c		488b4020		MOVQ 0x20(AX), AX		
  0x404d90		4889442438		MOVQ AX, 0x38(SP)		
  0x404d95		48895c2440		MOVQ BX, 0x40(SP)		
  0x404d9a		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x404da2		488d05a1660600		LEAQ 0x666a1(IP), AX		
  0x404da9		4889442408		MOVQ AX, 0x8(SP)		
  0x404dae		48c744241016000000	MOVQ $0x16, 0x10(SP)		
  0x404db7		4889542418		MOVQ DX, 0x18(SP)		
  0x404dbc		48894c2420		MOVQ CX, 0x20(SP)		
  0x404dc1		488d05dd580600		LEAQ 0x658dd(IP), AX		
  0x404dc8		4889442428		MOVQ AX, 0x28(SP)		
  0x404dcd		48c74424300d000000	MOVQ $0xd, 0x30(SP)		
  0x404dd6		e875220300		CALL runtime.concatstring4(SB)	
  0x404ddb		488b442450		MOVQ 0x50(SP), AX		
  0x404de0		488b4c2448		MOVQ 0x48(SP), CX		
  0x404de5		48898c2430010000	MOVQ CX, 0x130(SP)		
  0x404ded		4889842438010000	MOVQ AX, 0x138(SP)		
  0x404df5		488bac2418010000	MOVQ 0x118(SP), BP		
  0x404dfd		4881c420010000		ADDQ $0x120, SP			
  0x404e04		c3			RET				
func (e *TypeAssertionError) Error() string {
  0x404e05		e866f70300		CALL runtime.morestack_noctxt(SB)		
  0x404e0a		e9a1fdffff		JMP runtime.(*TypeAssertionError).Error(SB)	

TEXT runtime.errorString.Error(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/error.go
func (e errorString) Error() string {
  0x404e10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404e19		483b6110		CMPQ 0x10(CX), SP	
  0x404e1d		7662			JBE 0x404e81		
  0x404e1f		4883ec40		SUBQ $0x40, SP		
  0x404e23		48896c2438		MOVQ BP, 0x38(SP)	
  0x404e28		488d6c2438		LEAQ 0x38(SP), BP	
	return "runtime error: " + string(e)
  0x404e2d		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x404e35		488d056b5b0600		LEAQ 0x65b6b(IP), AX	
  0x404e3c		4889442408		MOVQ AX, 0x8(SP)	
  0x404e41		48c74424100f000000	MOVQ $0xf, 0x10(SP)	
func (e errorString) Error() string {
  0x404e4a		488b442448		MOVQ 0x48(SP), AX	
	return "runtime error: " + string(e)
  0x404e4f		4889442418		MOVQ AX, 0x18(SP)	
func (e errorString) Error() string {
  0x404e54		488b442450		MOVQ 0x50(SP), AX	
	return "runtime error: " + string(e)
  0x404e59		4889442420		MOVQ AX, 0x20(SP)		
  0x404e5e		e87d210300		CALL runtime.concatstring2(SB)	
  0x404e63		488b442428		MOVQ 0x28(SP), AX		
  0x404e68		488b4c2430		MOVQ 0x30(SP), CX		
  0x404e6d		4889442458		MOVQ AX, 0x58(SP)		
  0x404e72		48894c2460		MOVQ CX, 0x60(SP)		
  0x404e77		488b6c2438		MOVQ 0x38(SP), BP		
  0x404e7c		4883c440		ADDQ $0x40, SP			
  0x404e80		c3			RET				
func (e errorString) Error() string {
  0x404e81		e8eaf60300		CALL runtime.morestack_noctxt(SB)	
  0x404e86		eb88			JMP runtime.errorString.Error(SB)	

TEXT runtime.plainError.Error(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/error.go
func (e plainError) Error() string {
  0x404e90		488b442408		MOVQ 0x8(SP), AX	
	return string(e)
  0x404e95		4889442418		MOVQ AX, 0x18(SP)	
func (e plainError) Error() string {
  0x404e9a		488b442410		MOVQ 0x10(SP), AX	
	return string(e)
  0x404e9f		4889442420		MOVQ AX, 0x20(SP)	
  0x404ea4		c3			RET			

TEXT runtime.typestring(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/error.go
func typestring(x interface{}) string {
  0x404eb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404eb9		483b6110		CMPQ 0x10(CX), SP	
  0x404ebd		763a			JBE 0x404ef9		
  0x404ebf		4883ec20		SUBQ $0x20, SP		
  0x404ec3		48896c2418		MOVQ BP, 0x18(SP)	
  0x404ec8		488d6c2418		LEAQ 0x18(SP), BP	
	return e._type.string()
  0x404ecd		488b442428		MOVQ 0x28(SP), AX			
  0x404ed2		48890424		MOVQ AX, 0(SP)				
  0x404ed6		e8959a0300		CALL runtime.(*_type).string(SB)	
  0x404edb		488b442410		MOVQ 0x10(SP), AX			
  0x404ee0		488b4c2408		MOVQ 0x8(SP), CX			
  0x404ee5		48894c2438		MOVQ CX, 0x38(SP)			
  0x404eea		4889442440		MOVQ AX, 0x40(SP)			
  0x404eef		488b6c2418		MOVQ 0x18(SP), BP			
  0x404ef4		4883c420		ADDQ $0x20, SP				
  0x404ef8		c3			RET					
func typestring(x interface{}) string {
  0x404ef9		e872f60300		CALL runtime.morestack_noctxt(SB)	
  0x404efe		ebb0			JMP runtime.typestring(SB)		

TEXT runtime.printany(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/error.go
func printany(i interface{}) {
  0x404f00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404f09		488d4424d8		LEAQ -0x28(SP), AX	
  0x404f0e		483b4110		CMPQ 0x10(CX), AX	
  0x404f12		0f86c6070000		JBE 0x4056de		
  0x404f18		4881eca8000000		SUBQ $0xa8, SP		
  0x404f1f		4889ac24a0000000	MOVQ BP, 0xa0(SP)	
  0x404f27		488dac24a0000000	LEAQ 0xa0(SP), BP	
  0x404f2f		488b8424b0000000	MOVQ 0xb0(SP), AX	
	switch v := i.(type) {
  0x404f37		4885c0			TESTQ AX, AX		
  0x404f3a		0f8476070000		JE 0x4056b6		
  0x404f40		8b4810			MOVL 0x10(AX), CX	
  0x404f43		81f96d541ab3		CMPL $-0x4ce5ab93, CX	
  0x404f49		0f87fe030000		JA 0x40534d		
  0x404f4f		81f98c022579		CMPL $0x7925028c, CX	
  0x404f55		0f8757020000		JA 0x4051b2		
  0x404f5b		81f9fb7fa22e		CMPL $0x2ea27ffb, CX	
  0x404f61		0f876b010000		JA 0x4050d2		
  0x404f67		81f9c506ff13		CMPL $0x13ff06c5, CX	
  0x404f6d		0f854c010000		JNE 0x4050bf		
  0x404f73		488d15661b0500		LEAQ 0x51b66(IP), DX	
  0x404f7a		4839c2			CMPQ AX, DX		
  0x404f7d		0f852a010000		JNE 0x4050ad		
  0x404f83		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x404f8b		0fb61a			MOVZX 0(DX), BX		
  0x404f8e		0f84fc000000		JE 0x405090		
  0x404f94		81f9fb7fa22e		CMPL $0x2ea27ffb, CX	
  0x404f9a		751a			JNE 0x404fb6		
  0x404f9c		488d0dbd1c0500		LEAQ 0x51cbd(IP), CX	
  0x404fa3		4839c1			CMPQ AX, CX		
  0x404fa6		0f85dc000000		JNE 0x405088		
  0x404fac		f20f1002		MOVSD_XMM 0(DX), X0	
  0x404fb0		0f84b0000000		JE 0x405066		
		print("(", typestring(i), ") ", i)
  0x404fb6		48890424		MOVQ AX, 0(SP)			
  0x404fba		4889542408		MOVQ DX, 0x8(SP)		
  0x404fbf		e8ecfeffff		CALL runtime.typestring(SB)	
  0x404fc4		488b442418		MOVQ 0x18(SP), AX		
  0x404fc9		4889842488000000	MOVQ AX, 0x88(SP)		
  0x404fd1		488b4c2410		MOVQ 0x10(SP), CX		
  0x404fd6		48898c2498000000	MOVQ CX, 0x98(SP)		
  0x404fde		e81dcb0100		CALL runtime.printlock(SB)	
  0x404fe3		488d05674c0600		LEAQ 0x64c67(IP), AX		
  0x404fea		48890424		MOVQ AX, 0(SP)			
  0x404fee		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x404ff7		e844d40100		CALL runtime.printstring(SB)	
  0x404ffc		488b842498000000	MOVQ 0x98(SP), AX		
  0x405004		48890424		MOVQ AX, 0(SP)			
  0x405008		488b842488000000	MOVQ 0x88(SP), AX		
  0x405010		4889442408		MOVQ AX, 0x8(SP)		
  0x405015		e826d40100		CALL runtime.printstring(SB)	
  0x40501a		488d05474c0600		LEAQ 0x64c47(IP), AX		
  0x405021		48890424		MOVQ AX, 0(SP)			
  0x405025		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x40502e		e80dd40100		CALL runtime.printstring(SB)	
  0x405033		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x40503b		48890424		MOVQ AX, 0(SP)			
  0x40503f		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x405047		4889442408		MOVQ AX, 0x8(SP)		
  0x40504c		e85fd50100		CALL runtime.printeface(SB)	
  0x405051		e82acb0100		CALL runtime.printunlock(SB)	
  0x405056		488bac24a0000000	MOVQ 0xa0(SP), BP		
  0x40505e		4881c4a8000000		ADDQ $0xa8, SP			
  0x405065		c3			RET				
  0x405066		f20f11442458		MOVSD_XMM X0, 0x58(SP)		
		print(v)
  0x40506c		e88fca0100		CALL runtime.printlock(SB)	
  0x405071		f20f10442458		MOVSD_XMM 0x58(SP), X0		
  0x405077		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x40507c		e8cfcd0100		CALL runtime.printfloat(SB)	
  0x405081		e8faca0100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405086		ebce			JMP 0x405056		
  0x405088		0f57c0			XORPS X0, X0		
  0x40508b		e920ffffff		JMP 0x404fb0		
  0x405090		885c2425		MOVB BL, 0x25(SP)	
		print(v)
  0x405094		e867ca0100		CALL runtime.printlock(SB)	
  0x405099		0fb6442425		MOVZX 0x25(SP), AX		
  0x40509e		880424			MOVB AL, 0(SP)			
  0x4050a1		e83acd0100		CALL runtime.printbool(SB)	
  0x4050a6		e8d5ca0100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x4050ab		eba9			JMP 0x405056		
  0x4050ad		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4050b5		bb00000000		MOVL $0x0, BX		
  0x4050ba		e9cffeffff		JMP 0x404f8e		
  0x4050bf		81f9fb7fa22e		CMPL $0x2ea27ffb, CX	
  0x4050c5		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4050cd		e9c8feffff		JMP 0x404f9a		
  0x4050d2		81f95f423e66		CMPL $0x663e425f, CX	
  0x4050d8		0f85c1000000		JNE 0x40519f		
  0x4050de		488d15fb230500		LEAQ 0x523fb(IP), DX	
  0x4050e5		4839c2			CMPQ AX, DX		
  0x4050e8		0f859f000000		JNE 0x40518d		
  0x4050ee		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4050f6		0fb61a			MOVZX 0(DX), BX		
  0x4050f9		746e			JE 0x405169		
  0x4050fb		81f98c022579		CMPL $0x7925028c, CX	
  0x405101		0f85affeffff		JNE 0x404fb6		
  0x405107		488d0dd21a0500		LEAQ 0x51ad2(IP), CX	
  0x40510e		4839c1			CMPQ AX, CX		
  0x405111		754e			JNE 0x405161		
  0x405113		f30f1002		MOVSS 0(DX), X0		
  0x405117		f30f104a04		MOVSS 0x4(DX), X1	
  0x40511c		0f8594feffff		JNE 0x404fb6		
  0x405122		f30f1144242c		MOVSS X0, 0x2c(SP)	
  0x405128		f30f114c2430		MOVSS X1, 0x30(SP)	
		print(v)
  0x40512e		e8cdc90100		CALL runtime.printlock(SB)	
  0x405133		f30f1044242c		MOVSS 0x2c(SP), X0		
  0x405139		f30f5ac0		CVTSS2SD X0, X0			
  0x40513d		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x405142		f30f10442430		MOVSS 0x30(SP), X0		
  0x405148		f30f5ac0		CVTSS2SD X0, X0			
  0x40514c		f20f11442408		MOVSD_XMM X0, 0x8(SP)		
  0x405152		e889cf0100		CALL runtime.printcomplex(SB)	
  0x405157		e824ca0100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x40515c		e9f5feffff		JMP 0x405056		
  0x405161		0f57c0			XORPS X0, X0		
  0x405164		0f57c9			XORPS X1, X1		
  0x405167		ebb3			JMP 0x40511c		
  0x405169		885c2427		MOVB BL, 0x27(SP)	
		print(v)
  0x40516d		e88ec90100		CALL runtime.printlock(SB)	
  0x405172		0fb6442427		MOVZX 0x27(SP), AX		
  0x405177		0fb6c0			MOVZX AL, AX			
  0x40517a		48890424		MOVQ AX, 0(SP)			
  0x40517e		e8edcf0100		CALL runtime.printuint(SB)	
  0x405183		e8f8c90100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405188		e9c9feffff		JMP 0x405056		
  0x40518d		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405195		bb00000000		MOVL $0x0, BX		
  0x40519a		e95affffff		JMP 0x4050f9		
  0x40519f		81f98c022579		CMPL $0x7925028c, CX	
  0x4051a5		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4051ad		e94fffffff		JMP 0x405101		
  0x4051b2		81f9ff9b3f96		CMPL $-0x69c06401, CX	
  0x4051b8		0f87b3000000		JA 0x405271		
  0x4051be		81f92e8d3186		CMPL $-0x79ce72d2, CX	
  0x4051c4		0f8594000000		JNE 0x40525e		
  0x4051ca		488d15cf220500		LEAQ 0x522cf(IP), DX	
  0x4051d1		4839c2			CMPQ AX, DX		
  0x4051d4		7579			JNE 0x40524f		
  0x4051d6		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4051de		488b1a			MOVQ 0(DX), BX		
  0x4051e1		744a			JE 0x40522d		
  0x4051e3		81f9ff9b3f96		CMPL $-0x69c06401, CX	
  0x4051e9		0f85c7fdffff		JNE 0x404fb6		
  0x4051ef		488d0dea1c0500		LEAQ 0x51cea(IP), CX	
  0x4051f6		4839c1			CMPQ AX, CX		
  0x4051f9		752b			JNE 0x405226		
  0x4051fb		488b0a			MOVQ 0(DX), CX		
  0x4051fe		0f85b2fdffff		JNE 0x404fb6		
  0x405204		48894c2468		MOVQ CX, 0x68(SP)	
		print(v)
  0x405209		e8f2c80100		CALL runtime.printlock(SB)	
  0x40520e		488b442468		MOVQ 0x68(SP), AX		
  0x405213		48890424		MOVQ AX, 0(SP)			
  0x405217		e864d00100		CALL runtime.printint(SB)	
  0x40521c		e85fc90100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405221		e930feffff		JMP 0x405056		
  0x405226		b900000000		MOVL $0x0, CX		
  0x40522b		ebd1			JMP 0x4051fe		
  0x40522d		48895c2470		MOVQ BX, 0x70(SP)	
		print(v)
  0x405232		e8c9c80100		CALL runtime.printlock(SB)	
  0x405237		488b442470		MOVQ 0x70(SP), AX		
  0x40523c		48890424		MOVQ AX, 0(SP)			
  0x405240		e82bcf0100		CALL runtime.printuint(SB)	
  0x405245		e836c90100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x40524a		e907feffff		JMP 0x405056		
  0x40524f		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405257		bb00000000		MOVL $0x0, BX		
  0x40525c		eb83			JMP 0x4051e1		
  0x40525e		81f9ff9b3f96		CMPL $-0x69c06401, CX	
  0x405264		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x40526c		e978ffffff		JMP 0x4051e9		
  0x405271		81f9d33ec2b0		CMPL $-0x4f3dc12d, CX	
  0x405277		0f85bd000000		JNE 0x40533a		
  0x40527d		488d159c190500		LEAQ 0x5199c(IP), DX	
  0x405284		4839c2			CMPQ AX, DX		
  0x405287		0f859d000000		JNE 0x40532a		
  0x40528d		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405295		f30f1002		MOVSS 0(DX), X0		
  0x405299		7466			JE 0x405301		
  0x40529b		81f96d541ab3		CMPL $-0x4ce5ab93, CX	
  0x4052a1		0f850ffdffff		JNE 0x404fb6		
  0x4052a7		488d0df2180500		LEAQ 0x518f2(IP), CX	
  0x4052ae		4839c1			CMPQ AX, CX		
  0x4052b1		7546			JNE 0x4052f9		
  0x4052b3		f20f1002		MOVSD_XMM 0(DX), X0	
  0x4052b7		f20f104a08		MOVSD_XMM 0x8(DX), X1	
  0x4052bc		0f85f4fcffff		JNE 0x404fb6		
  0x4052c2		f20f11442440		MOVSD_XMM X0, 0x40(SP)	
  0x4052c8		f20f114c2450		MOVSD_XMM X1, 0x50(SP)	
		print(v)
  0x4052ce		e82dc80100		CALL runtime.printlock(SB)	
  0x4052d3		f20f10442440		MOVSD_XMM 0x40(SP), X0		
  0x4052d9		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x4052de		f20f10442450		MOVSD_XMM 0x50(SP), X0		
  0x4052e4		f20f11442408		MOVSD_XMM X0, 0x8(SP)		
  0x4052ea		e8f1cd0100		CALL runtime.printcomplex(SB)	
  0x4052ef		e88cc80100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x4052f4		e95dfdffff		JMP 0x405056		
  0x4052f9		0f57c0			XORPS X0, X0		
  0x4052fc		0f57c9			XORPS X1, X1		
  0x4052ff		ebbb			JMP 0x4052bc		
  0x405301		f30f11442434		MOVSS X0, 0x34(SP)	
		print(v)
  0x405307		e8f4c70100		CALL runtime.printlock(SB)	
  0x40530c		f30f10442434		MOVSS 0x34(SP), X0		
  0x405312		f30f5ac0		CVTSS2SD X0, X0			
  0x405316		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x40531b		e830cb0100		CALL runtime.printfloat(SB)	
  0x405320		e85bc80100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405325		e92cfdffff		JMP 0x405056		
  0x40532a		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405332		0f57c0			XORPS X0, X0		
  0x405335		e95fffffff		JMP 0x405299		
  0x40533a		81f96d541ab3		CMPL $-0x4ce5ab93, CX	
  0x405340		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405348		e954ffffff		JMP 0x4052a1		
  0x40534d		81f93de84ad0		CMPL $-0x2fb517c3, CX	
  0x405353		0f8772010000		JA 0x4054cb		
  0x405359		81f992d74abd		CMPL $-0x42b5286e, CX	
  0x40535f		0f87b3000000		JA 0x405418		
  0x405365		81f90241adbb		CMPL $-0x4452befe, CX	
  0x40536b		0f8594000000		JNE 0x405405		
  0x405371		488d15281b0500		LEAQ 0x51b28(IP), DX	
  0x405378		4839c2			CMPQ AX, DX		
  0x40537b		7579			JNE 0x4053f6		
  0x40537d		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405385		8b1a			MOVL 0(DX), BX		
  0x405387		744a			JE 0x4053d3		
  0x405389		81f992d74abd		CMPL $-0x42b5286e, CX	
  0x40538f		0f8521fcffff		JNE 0x404fb6		
  0x405395		488d0d84210500		LEAQ 0x52184(IP), CX	
  0x40539c		4839c1			CMPQ AX, CX		
  0x40539f		752b			JNE 0x4053cc		
  0x4053a1		488b0a			MOVQ 0(DX), CX		
  0x4053a4		0f850cfcffff		JNE 0x404fb6		
  0x4053aa		48894c2478		MOVQ CX, 0x78(SP)	
		print(v)
  0x4053af		e84cc70100		CALL runtime.printlock(SB)	
  0x4053b4		488b442478		MOVQ 0x78(SP), AX		
  0x4053b9		48890424		MOVQ AX, 0(SP)			
  0x4053bd		e8aecd0100		CALL runtime.printuint(SB)	
  0x4053c2		e8b9c70100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x4053c7		e98afcffff		JMP 0x405056		
  0x4053cc		b900000000		MOVL $0x0, CX		
  0x4053d1		ebd1			JMP 0x4053a4		
  0x4053d3		895c2438		MOVL BX, 0x38(SP)	
		print(v)
  0x4053d7		e824c70100		CALL runtime.printlock(SB)	
  0x4053dc		8b442438		MOVL 0x38(SP), AX		
  0x4053e0		4863c0			MOVSXD AX, AX			
  0x4053e3		48890424		MOVQ AX, 0(SP)			
  0x4053e7		e894ce0100		CALL runtime.printint(SB)	
  0x4053ec		e88fc70100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x4053f1		e960fcffff		JMP 0x405056		
  0x4053f6		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4053fe		bb00000000		MOVL $0x0, BX		
  0x405403		eb82			JMP 0x405387		
  0x405405		81f992d74abd		CMPL $-0x42b5286e, CX	
  0x40540b		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405413		e977ffffff		JMP 0x40538f		
  0x405418		81f927c006cc		CMPL $-0x33f93fd9, CX	
  0x40541e		0f8594000000		JNE 0x4054b8		
  0x405424		488d15f51a0500		LEAQ 0x51af5(IP), DX	
  0x40542b		4839c2			CMPQ AX, DX		
  0x40542e		7579			JNE 0x4054a9		
  0x405430		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405438		0fb61a			MOVZX 0(DX), BX		
  0x40543b		7447			JE 0x405484		
  0x40543d		81f93de84ad0		CMPL $-0x2fb517c3, CX	
  0x405443		0f856dfbffff		JNE 0x404fb6		
  0x405449		488d0d10200500		LEAQ 0x52010(IP), CX	
  0x405450		4839c1			CMPQ AX, CX		
  0x405453		7528			JNE 0x40547d		
  0x405455		8b0a			MOVL 0(DX), CX		
  0x405457		0f8559fbffff		JNE 0x404fb6		
  0x40545d		894c243c		MOVL CX, 0x3c(SP)	
		print(v)
  0x405461		e89ac60100		CALL runtime.printlock(SB)	
  0x405466		8b44243c		MOVL 0x3c(SP), AX		
  0x40546a		48890424		MOVQ AX, 0(SP)			
  0x40546e		e8fdcc0100		CALL runtime.printuint(SB)	
  0x405473		e808c70100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405478		e9d9fbffff		JMP 0x405056		
  0x40547d		b900000000		MOVL $0x0, CX		
  0x405482		ebd3			JMP 0x405457		
  0x405484		885c2426		MOVB BL, 0x26(SP)	
		print(v)
  0x405488		e873c60100		CALL runtime.printlock(SB)	
  0x40548d		0fb6442426		MOVZX 0x26(SP), AX		
  0x405492		480fbec0		MOVSX AL, AX			
  0x405496		48890424		MOVQ AX, 0(SP)			
  0x40549a		e8e1cd0100		CALL runtime.printint(SB)	
  0x40549f		e8dcc60100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x4054a4		e9adfbffff		JMP 0x405056		
  0x4054a9		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4054b1		bb00000000		MOVL $0x0, BX		
  0x4054b6		eb83			JMP 0x40543b		
  0x4054b8		81f93de84ad0		CMPL $-0x2fb517c3, CX	
  0x4054be		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4054c6		e978ffffff		JMP 0x405443		
  0x4054cb		81f9b45cffe0		CMPL $-0x1f00a34c, CX	
  0x4054d1		0f87d8000000		JA 0x4055af		
  0x4054d7		81f91277b8d5		CMPL $-0x2a4788ee, CX	
  0x4054dd		0f85b9000000		JNE 0x40559c		
  0x4054e3		488d15f61e0500		LEAQ 0x51ef6(IP), DX	
  0x4054ea		4839c2			CMPQ AX, DX		
  0x4054ed		0f8597000000		JNE 0x40558a		
  0x4054f3		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4054fb		488b1a			MOVQ 0(DX), BX		
  0x4054fe		7468			JE 0x405568		
  0x405500		81f9b45cffe0		CMPL $-0x1f00a34c, CX	
  0x405506		0f85aafaffff		JNE 0x404fb6		
  0x40550c		488d0d8d1e0500		LEAQ 0x51e8d(IP), CX	
  0x405513		4839c1			CMPQ AX, CX		
  0x405516		7544			JNE 0x40555c		
  0x405518		488b0a			MOVQ 0(DX), CX		
  0x40551b		488b5a08		MOVQ 0x8(DX), BX	
  0x40551f		0f8591faffff		JNE 0x404fb6		
  0x405525		48895c2448		MOVQ BX, 0x48(SP)	
  0x40552a		48898c2490000000	MOVQ CX, 0x90(SP)	
		print(v)
  0x405532		e8c9c50100		CALL runtime.printlock(SB)	
  0x405537		488b842490000000	MOVQ 0x90(SP), AX		
  0x40553f		48890424		MOVQ AX, 0(SP)			
  0x405543		488b442448		MOVQ 0x48(SP), AX		
  0x405548		4889442408		MOVQ AX, 0x8(SP)		
  0x40554d		e8eece0100		CALL runtime.printstring(SB)	
  0x405552		e829c60100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405557		e9fafaffff		JMP 0x405056		
  0x40555c		bb00000000		MOVL $0x0, BX		
  0x405561		b900000000		MOVL $0x0, CX		
  0x405566		ebb7			JMP 0x40551f		
  0x405568		48895c2460		MOVQ BX, 0x60(SP)	
		print(v)
  0x40556d		e88ec50100		CALL runtime.printlock(SB)	
  0x405572		488b442460		MOVQ 0x60(SP), AX		
  0x405577		48890424		MOVQ AX, 0(SP)			
  0x40557b		e8f0cb0100		CALL runtime.printuint(SB)	
  0x405580		e8fbc50100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405585		e9ccfaffff		JMP 0x405056		
  0x40558a		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x405592		bb00000000		MOVL $0x0, BX		
  0x405597		e962ffffff		JMP 0x4054fe		
  0x40559c		81f9b45cffe0		CMPL $-0x1f00a34c, CX	
  0x4055a2		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4055aa		e957ffffff		JMP 0x405506		
  0x4055af		81f9ce80d5ec		CMPL $-0x132a7f32, CX	
  0x4055b5		0f85ee000000		JNE 0x4056a9		
  0x4055bb		488d159e180500		LEAQ 0x5189e(IP), DX	
  0x4055c2		4839c2			CMPQ AX, DX		
  0x4055c5		0f85cc000000		JNE 0x405697		
  0x4055cb		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4055d3		0fb71a			MOVZX 0(DX), BX		
  0x4055d6		0f8495000000		JE 0x405671		
  0x4055dc		81f9a00ef2ef		CMPL $-0x100df160, CX	
  0x4055e2		7511			JNE 0x4055f5		
  0x4055e4		488d1d351e0500		LEAQ 0x51e35(IP), BX	
  0x4055eb		4839c3			CMPQ AX, BX		
  0x4055ee		757a			JNE 0x40566a		
  0x4055f0		0fb71a			MOVZX 0(DX), BX		
  0x4055f3		7450			JE 0x405645		
  0x4055f5		81f9fa7153f7		CMPL $-0x8ac8e06, CX	
  0x4055fb		0f85b5f9ffff		JNE 0x404fb6		
  0x405601		488d0d18180500		LEAQ 0x51818(IP), CX	
  0x405608		4839c1			CMPQ AX, CX		
  0x40560b		7531			JNE 0x40563e		
  0x40560d		488b0a			MOVQ 0(DX), CX		
  0x405610		0f85a0f9ffff		JNE 0x404fb6		
  0x405616		48898c2480000000	MOVQ CX, 0x80(SP)	
		print(v)
  0x40561e		e8ddc40100		CALL runtime.printlock(SB)	
  0x405623		488b842480000000	MOVQ 0x80(SP), AX		
  0x40562b		48890424		MOVQ AX, 0(SP)			
  0x40562f		e84ccc0100		CALL runtime.printint(SB)	
  0x405634		e847c50100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405639		e918faffff		JMP 0x405056		
  0x40563e		b900000000		MOVL $0x0, CX		
  0x405643		ebcb			JMP 0x405610		
  0x405645		66895c242a		MOVW BX, 0x2a(SP)	
		print(v)
  0x40564a		e8b1c40100		CALL runtime.printlock(SB)	
  0x40564f		0fb744242a		MOVZX 0x2a(SP), AX		
  0x405654		0fb7c0			MOVZX AX, AX			
  0x405657		48890424		MOVQ AX, 0(SP)			
  0x40565b		e810cb0100		CALL runtime.printuint(SB)	
  0x405660		e81bc50100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405665		e9ecf9ffff		JMP 0x405056		
  0x40566a		bb00000000		MOVL $0x0, BX		
  0x40566f		eb82			JMP 0x4055f3		
  0x405671		66895c2428		MOVW BX, 0x28(SP)	
		print(v)
  0x405676		e885c40100		CALL runtime.printlock(SB)	
  0x40567b		0fb7442428		MOVZX 0x28(SP), AX		
  0x405680		480fbfc0		MOVSX AX, AX			
  0x405684		48890424		MOVQ AX, 0(SP)			
  0x405688		e8f3cb0100		CALL runtime.printint(SB)	
  0x40568d		e8eec40100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x405692		e9bff9ffff		JMP 0x405056		
  0x405697		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x40569f		bb00000000		MOVL $0x0, BX		
  0x4056a4		e92dffffff		JMP 0x4055d6		
  0x4056a9		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x4056b1		e926ffffff		JMP 0x4055dc		
		print("nil")
  0x4056b6		e845c40100		CALL runtime.printlock(SB)	
  0x4056bb		488d05ef450600		LEAQ 0x645ef(IP), AX		
  0x4056c2		48890424		MOVQ AX, 0(SP)			
  0x4056c6		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4056cf		e86ccd0100		CALL runtime.printstring(SB)	
  0x4056d4		e8a7c40100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x4056d9		e978f9ffff		JMP 0x405056		
func printany(i interface{}) {
  0x4056de		e88dee0300		CALL runtime.morestack_noctxt(SB)	
  0x4056e3		e918f8ffff		JMP runtime.printany(SB)		

TEXT runtime.panicwrap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/error.go
func panicwrap() {
  0x4056f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4056f9		488d842440ffffff	LEAQ 0xffffff40(SP), AX	
  0x405701		483b4110		CMPQ 0x10(CX), AX	
  0x405705		0f86e1030000		JBE 0x405aec		
  0x40570b		4881ec40010000		SUBQ $0x140, SP		
  0x405712		4889ac2438010000	MOVQ BP, 0x138(SP)	
  0x40571a		488dac2438010000	LEAQ 0x138(SP), BP	
	name := funcname(findfunc(pc))
  0x405722		488b842440010000	MOVQ 0x140(SP), AX		
  0x40572a		48890424		MOVQ AX, 0(SP)			
  0x40572e		e89d2a0300		CALL runtime.findfunc(SB)	
  0x405733		488b442408		MOVQ 0x8(SP), AX		
  0x405738		488b4c2410		MOVQ 0x10(SP), CX		
  0x40573d		48890424		MOVQ AX, 0(SP)			
  0x405741		48894c2408		MOVQ CX, 0x8(SP)		
  0x405746		e8b5310300		CALL runtime.funcname(SB)	
  0x40574b		488b442418		MOVQ 0x18(SP), AX		
  0x405750		4889442440		MOVQ AX, 0x40(SP)		
  0x405755		488b4c2410		MOVQ 0x10(SP), CX		
  0x40575a		48898c2490000000	MOVQ CX, 0x90(SP)		
	i := stringsIndexByte(name, '(')
  0x405762		48890c24		MOVQ CX, 0(SP)			
  0x405766		4889442408		MOVQ AX, 0x8(SP)		
  0x40576b		c644241028		MOVB $0x28, 0x10(SP)		
  0x405770		e8cb0f0400		CALL strings.IndexByte(SB)	
  0x405775		488b442418		MOVQ 0x18(SP), AX		
	if i < 0 {
  0x40577a		4885c0			TESTQ AX, AX		
  0x40577d		0f8c15030000		JL 0x405a98		
	pkg := name[:i-1]
  0x405783		488d48ff		LEAQ -0x1(AX), CX	
  0x405787		488b542440		MOVQ 0x40(SP), DX	
  0x40578c		4839d1			CMPQ DX, CX		
  0x40578f		0f87fc020000		JA 0x405a91		
	if i+2 >= len(name) || name[i-1:i+2] != ".(*" {
  0x405795		4883c002		ADDQ $0x2, AX		
  0x405799		4839d0			CMPQ DX, AX		
  0x40579c		7c0d			JL 0x4057ab		
  0x40579e		488bb42490000000	MOVQ 0x90(SP), SI	
  0x4057a6		e9a0020000		JMP 0x405a4b		
  0x4057ab		4839c1			CMPQ AX, CX		
  0x4057ae		0f8790020000		JA 0x405a44		
  0x4057b4		4839d0			CMPQ DX, AX		
  0x4057b7		0f8787020000		JA 0x405a44		
  0x4057bd		4889c3			MOVQ AX, BX		
  0x4057c0		4829c8			SUBQ CX, AX		
  0x4057c3		4889c6			MOVQ AX, SI		
  0x4057c6		48f7d8			NEGQ AX			
  0x4057c9		48c1f83f		SARQ $0x3f, AX		
  0x4057cd		4821c8			ANDQ CX, AX		
  0x4057d0		4883fe03		CMPQ $0x3, SI		
  0x4057d4		740d			JE 0x4057e3		
  0x4057d6		488bb42490000000	MOVQ 0x90(SP), SI	
  0x4057de		e968020000		JMP 0x405a4b		
  0x4057e3		488bb42490000000	MOVQ 0x90(SP), SI	
  0x4057eb		0fb73c30		MOVZX 0(AX)(SI*1), DI	
  0x4057ef		6681ff2e28		CMPW $0x282e, DI	
  0x4057f4		0f8551020000		JNE 0x405a4b		
  0x4057fa		0fb6440602		MOVZX 0x2(SI)(AX*1), AX	
  0x4057ff		3c2a			CMPL $0x2a, AL		
  0x405801		0f8544020000		JNE 0x405a4b		
  0x405807		48894c2438		MOVQ CX, 0x38(SP)	
	name = name[i+2:]
  0x40580c		4829da			SUBQ BX, DX		
  0x40580f		4889542440		MOVQ DX, 0x40(SP)	
  0x405814		4889d0			MOVQ DX, AX		
  0x405817		48f7da			NEGQ DX			
  0x40581a		48c1fa3f		SARQ $0x3f, DX		
  0x40581e		4821d3			ANDQ DX, BX		
  0x405821		488d0c1e		LEAQ 0(SI)(BX*1), CX	
  0x405825		48898c2488000000	MOVQ CX, 0x88(SP)	
	i = stringsIndexByte(name, ')')
  0x40582d		48890c24		MOVQ CX, 0(SP)			
  0x405831		4889442408		MOVQ AX, 0x8(SP)		
  0x405836		c644241029		MOVB $0x29, 0x10(SP)		
  0x40583b		e8000f0400		CALL strings.IndexByte(SB)	
  0x405840		488b442418		MOVQ 0x18(SP), AX		
	if i < 0 {
  0x405845		4885c0			TESTQ AX, AX		
  0x405848		0f8ca2010000		JL 0x4059f0		
	if i+2 >= len(name) || name[i:i+2] != ")." {
  0x40584e		488d4802		LEAQ 0x2(AX), CX	
  0x405852		488b542440		MOVQ 0x40(SP), DX	
  0x405857		4839d1			CMPQ DX, CX		
  0x40585a		7c0d			JL 0x405869		
  0x40585c		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x405864		e941010000		JMP 0x4059aa		
  0x405869		4839c8			CMPQ CX, AX		
  0x40586c		0f8731010000		JA 0x4059a3		
  0x405872		4839d1			CMPQ DX, CX		
  0x405875		0f8728010000		JA 0x4059a3		
  0x40587b		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x405883		440fb70418		MOVZX 0(AX)(BX*1), R8	
  0x405888		664181f8292e		CMPW $0x2e29, R8	
  0x40588e		0f8516010000		JNE 0x4059aa		
	typ := name[:i]
  0x405894		4839d0			CMPQ DX, AX		
  0x405897		0f87ff000000		JA 0x40599c		
	panic(plainError("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer"))
  0x40589d		488dbc24a8000000	LEAQ 0xa8(SP), DI			
  0x4058a5		488d3594f60600		LEAQ runtime.statictmp_9(SB), SI	
  0x4058ac		48896c24f0		MOVQ BP, -0x10(SP)			
  0x4058b1		488d6c24f0		LEAQ -0x10(SP), BP			
  0x4058b6		e827150400		CALL 0x446de2				
  0x4058bb		488b6d00		MOVQ 0(BP), BP				
  0x4058bf		4c8b842490000000	MOVQ 0x90(SP), R8			
  0x4058c7		4c898424b8000000	MOVQ R8, 0xb8(SP)			
  0x4058cf		4c8b442438		MOVQ 0x38(SP), R8			
  0x4058d4		4c898424c0000000	MOVQ R8, 0xc0(SP)			
  0x4058dc		48899c24d8000000	MOVQ BX, 0xd8(SP)			
  0x4058e4		48898424e0000000	MOVQ AX, 0xe0(SP)			
	meth := name[i+2:]
  0x4058ec		4829ca			SUBQ CX, DX		
  0x4058ef		4989d0			MOVQ DX, R8		
  0x4058f2		48f7da			NEGQ DX			
  0x4058f5		48c1fa3f		SARQ $0x3f, DX		
  0x4058f9		4821d1			ANDQ DX, CX		
  0x4058fc		4801d9			ADDQ BX, CX		
	panic(plainError("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer"))
  0x4058ff		48898c24f8000000	MOVQ CX, 0xf8(SP)		
  0x405907		4c89842400010000	MOVQ R8, 0x100(SP)		
  0x40590f		48899c2418010000	MOVQ BX, 0x118(SP)		
  0x405917		4889842420010000	MOVQ AX, 0x120(SP)		
  0x40591f		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x405927		488d8424a8000000	LEAQ 0xa8(SP), AX		
  0x40592f		4889442408		MOVQ AX, 0x8(SP)		
  0x405934		48c744241009000000	MOVQ $0x9, 0x10(SP)		
  0x40593d		48c744241809000000	MOVQ $0x9, 0x18(SP)		
  0x405946		e8e5130300		CALL runtime.concatstrings(SB)	
  0x40594b		488b442428		MOVQ 0x28(SP), AX		
  0x405950		488b4c2420		MOVQ 0x20(SP), CX		
  0x405955		48898c2498000000	MOVQ CX, 0x98(SP)		
  0x40595d		48898424a0000000	MOVQ AX, 0xa0(SP)		
  0x405965		488d05d4560500		LEAQ 0x556d4(IP), AX		
  0x40596c		48890424		MOVQ AX, 0(SP)			
  0x405970		488d842498000000	LEAQ 0x98(SP), AX		
  0x405978		4889442408		MOVQ AX, 0x8(SP)		
  0x40597d		e81e380000		CALL runtime.convT2Estring(SB)	
  0x405982		488b442418		MOVQ 0x18(SP), AX		
  0x405987		488b4c2410		MOVQ 0x10(SP), CX		
  0x40598c		48890c24		MOVQ CX, 0(SP)			
  0x405990		4889442408		MOVQ AX, 0x8(SP)		
  0x405995		e896b00100		CALL runtime.gopanic(SB)	
  0x40599a		0f0b			UD2				
	typ := name[:i]
  0x40599c		e80fa10100		CALL runtime.panicslice(SB)	
  0x4059a1		0f0b			UD2				
	if i+2 >= len(name) || name[i:i+2] != ")." {
  0x4059a3		e808a10100		CALL runtime.panicslice(SB)	
  0x4059a8		0f0b			UD2				
		throw("panicwrap: unexpected string after type name: " + name)
  0x4059aa		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x4059b2		488d05737d0600		LEAQ 0x67d73(IP), AX		
  0x4059b9		4889442408		MOVQ AX, 0x8(SP)		
  0x4059be		48c74424102e000000	MOVQ $0x2e, 0x10(SP)		
  0x4059c7		48895c2418		MOVQ BX, 0x18(SP)		
  0x4059cc		4889542420		MOVQ DX, 0x20(SP)		
  0x4059d1		e80a160300		CALL runtime.concatstring2(SB)	
  0x4059d6		488b442430		MOVQ 0x30(SP), AX		
  0x4059db		488b4c2428		MOVQ 0x28(SP), CX		
  0x4059e0		48890c24		MOVQ CX, 0(SP)			
  0x4059e4		4889442408		MOVQ AX, 0x8(SP)		
  0x4059e9		e8e2b70100		CALL runtime.throw(SB)		
  0x4059ee		0f0b			UD2				
		throw("panicwrap: no ) in " + name)
  0x4059f0		488d442448		LEAQ 0x48(SP), AX		
  0x4059f5		48890424		MOVQ AX, 0(SP)			
  0x4059f9		488d0544550600		LEAQ 0x65544(IP), AX		
  0x405a00		4889442408		MOVQ AX, 0x8(SP)		
  0x405a05		48c744241013000000	MOVQ $0x13, 0x10(SP)		
  0x405a0e		488b842488000000	MOVQ 0x88(SP), AX		
  0x405a16		4889442418		MOVQ AX, 0x18(SP)		
  0x405a1b		488b442440		MOVQ 0x40(SP), AX		
  0x405a20		4889442420		MOVQ AX, 0x20(SP)		
  0x405a25		e8b6150300		CALL runtime.concatstring2(SB)	
  0x405a2a		488b442428		MOVQ 0x28(SP), AX		
  0x405a2f		488b4c2430		MOVQ 0x30(SP), CX		
  0x405a34		48890424		MOVQ AX, 0(SP)			
  0x405a38		48894c2408		MOVQ CX, 0x8(SP)		
  0x405a3d		e88eb70100		CALL runtime.throw(SB)		
  0x405a42		0f0b			UD2				
	if i+2 >= len(name) || name[i-1:i+2] != ".(*" {
  0x405a44		e867a00100		CALL runtime.panicslice(SB)	
  0x405a49		0f0b			UD2				
		throw("panicwrap: unexpected string after package name: " + name)
  0x405a4b		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x405a53		488d05057f0600		LEAQ 0x67f05(IP), AX		
  0x405a5a		4889442408		MOVQ AX, 0x8(SP)		
  0x405a5f		48c744241031000000	MOVQ $0x31, 0x10(SP)		
  0x405a68		4889742418		MOVQ SI, 0x18(SP)		
  0x405a6d		4889542420		MOVQ DX, 0x20(SP)		
  0x405a72		e869150300		CALL runtime.concatstring2(SB)	
  0x405a77		488b442428		MOVQ 0x28(SP), AX		
  0x405a7c		488b4c2430		MOVQ 0x30(SP), CX		
  0x405a81		48890424		MOVQ AX, 0(SP)			
  0x405a85		48894c2408		MOVQ CX, 0x8(SP)		
  0x405a8a		e841b70100		CALL runtime.throw(SB)		
  0x405a8f		0f0b			UD2				
	pkg := name[:i-1]
  0x405a91		e81aa00100		CALL runtime.panicslice(SB)	
  0x405a96		0f0b			UD2				
		throw("panicwrap: no ( in " + name)
  0x405a98		488d442468		LEAQ 0x68(SP), AX		
  0x405a9d		48890424		MOVQ AX, 0(SP)			
  0x405aa1		488d0589540600		LEAQ 0x65489(IP), AX		
  0x405aa8		4889442408		MOVQ AX, 0x8(SP)		
  0x405aad		48c744241013000000	MOVQ $0x13, 0x10(SP)		
  0x405ab6		488b842490000000	MOVQ 0x90(SP), AX		
  0x405abe		4889442418		MOVQ AX, 0x18(SP)		
  0x405ac3		488b442440		MOVQ 0x40(SP), AX		
  0x405ac8		4889442420		MOVQ AX, 0x20(SP)		
  0x405acd		e80e150300		CALL runtime.concatstring2(SB)	
  0x405ad2		488b442428		MOVQ 0x28(SP), AX		
  0x405ad7		488b4c2430		MOVQ 0x30(SP), CX		
  0x405adc		48890424		MOVQ AX, 0(SP)			
  0x405ae0		48894c2408		MOVQ CX, 0x8(SP)		
  0x405ae5		e8e6b60100		CALL runtime.throw(SB)		
  0x405aea		0f0b			UD2				
func panicwrap() {
  0x405aec		e87fea0300		CALL runtime.morestack_noctxt(SB)	
  0x405af1		e9fafbffff		JMP runtime.panicwrap(SB)		

TEXT runtime.float64frombits(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/float.go
	return *(*float64)(unsafe.Pointer(&b))
  0x405b00		f20f10442408		MOVSD_XMM 0x8(SP), X0	
  0x405b06		f20f11442410		MOVSD_XMM X0, 0x10(SP)	
  0x405b0c		c3			RET			

TEXT runtime.memhash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hash64.go
func memhash(p unsafe.Pointer, seed, s uintptr) uintptr {
  0x405b10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x405b19		483b6110		CMPQ 0x10(CX), SP	
  0x405b1d		0f86f1020000		JBE 0x405e14		
  0x405b23		4883ec28		SUBQ $0x28, SP		
  0x405b27		48896c2420		MOVQ BP, 0x20(SP)	
  0x405b2c		488d6c2420		LEAQ 0x20(SP), BP	
	if GOARCH == "amd64" && GOOS != "nacl" && useAeshash {
  0x405b31		0fb60586dd0b00		MOVZX runtime.useAeshash(SB), AX	
  0x405b38		84c0			TESTL AL, AL				
  0x405b3a		0f859e020000		JNE 0x405dde				
	h := uint64(seed + s*hashkey[0])
  0x405b40		488b05d9de0b00		MOVQ runtime.hashkey(SB), AX	
  0x405b47		488b4c2440		MOVQ 0x40(SP), CX		
  0x405b4c		480fafc1		IMULQ CX, AX			
  0x405b50		488b542438		MOVQ 0x38(SP), DX		
  0x405b55		4801d0			ADDQ DX, AX			
  0x405b58		488b5c2430		MOVQ 0x30(SP), BX		
tail:
  0x405b5d		e9b5000000		JMP 0x405c17		
	return unsafe.Pointer(uintptr(p) + x)
  0x405b62		4c8d4b08		LEAQ 0x8(BX), R9	
	return *(*uint64)(p)
  0x405b66		418401			TESTB AL, 0(R9)		
	return unsafe.Pointer(uintptr(p) + x)
  0x405b69		4c8d4b10		LEAQ 0x10(BX), R9	
	return *(*uint64)(p)
  0x405b6d		418401			TESTB AL, 0(R9)		
	return unsafe.Pointer(uintptr(p) + x)
  0x405b70		4c8d4b18		LEAQ 0x18(BX), R9	
	return *(*uint64)(p)
  0x405b74		418401			TESTB AL, 0(R9)		
  0x405b77		4c8b0b			MOVQ 0(BX), R9		
			v1 ^= readUnaligned64(p)
  0x405b7a		4c31c8			XORQ R9, AX		
			v1 = rotl_31(v1*m1) * m2
  0x405b7d		49b94115f07990ec38ea	MOVQ $0xea38ec9079f01541, R9	
  0x405b87		490fafc1		IMULQ R9, AX			
	return (x << 31) | (x >> (64 - 31))
  0x405b8b		48c1c01f		ROLQ $0x1f, AX		
			v1 = rotl_31(v1*m1) * m2
  0x405b8f		49ba9913da960da32327	MOVQ $0x2723a30d96da1399, R10	
  0x405b99		490fafc2		IMULQ R10, AX			
	return *(*uint64)(p)
  0x405b9d		41bb08000000		MOVL $0x8, R11		
  0x405ba3		4e8b241b		MOVQ 0(BX)(R11*1), R12	
			v2 ^= readUnaligned64(p)
  0x405ba7		4c31e6			XORQ R12, SI		
			v2 = rotl_31(v2*m2) * m3
  0x405baa		490faff2		IMULQ R10, SI		
	return (x << 31) | (x >> (64 - 31))
  0x405bae		48c1c61f		ROLQ $0x1f, SI		
			v2 = rotl_31(v2*m2) * m3
  0x405bb2		49bcd7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, R12	
  0x405bbc		490faff4		IMULQ R12, SI			
	return *(*uint64)(p)
  0x405bc0		41bd10000000		MOVL $0x10, R13		
  0x405bc6		4e8b342b		MOVQ 0(BX)(R13*1), R14	
			v3 ^= readUnaligned64(p)
  0x405bca		4c31f7			XORQ R14, DI		
			v3 = rotl_31(v3*m3) * m4
  0x405bcd		490faffc		IMULQ R12, DI		
	return (x << 31) | (x >> (64 - 31))
  0x405bd1		48c1c71f		ROLQ $0x1f, DI		
			v3 = rotl_31(v3*m3) * m4
  0x405bd5		49be93f63d647bc2cfdb	MOVQ $0xdbcfc27b643df693, R14	
  0x405bdf		490faffe		IMULQ R14, DI			
	return *(*uint64)(p)
  0x405be3		41bf18000000		MOVL $0x18, R15		
  0x405be9		4e8b3c3b		MOVQ 0(BX)(R15*1), R15	
			v4 ^= readUnaligned64(p)
  0x405bed		4d31f8			XORQ R15, R8		
			v4 = rotl_31(v4*m4) * m1
  0x405bf0		4d0fafc6		IMULQ R14, R8		
	return (x << 31) | (x >> (64 - 31))
  0x405bf4		49c1c01f		ROLQ $0x1f, R8		
			v4 = rotl_31(v4*m4) * m1
  0x405bf8		4d0fafc1		IMULQ R9, R8		
			s -= 32
  0x405bfc		4883c1e0		ADDQ $-0x20, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x405c00		4883c320		ADDQ $0x20, BX		
		for s >= 32 {
  0x405c04		4883f920		CMPQ $0x20, CX		
  0x405c08		0f8354ffffff		JAE 0x405b62		
		h = v1 ^ v2 ^ v3 ^ v4
  0x405c0e		4831f0			XORQ SI, AX		
  0x405c11		4831f8			XORQ DI, AX		
  0x405c14		4c31c0			XORQ R8, AX		
	case s == 0:
  0x405c17		4885c9			TESTQ CX, CX		
  0x405c1a		0f84bf000000		JE 0x405cdf		
	case s < 4:
  0x405c20		4883f904		CMPQ $0x4, CX		
  0x405c24		0f8260010000		JB 0x405d8a		
	case s <= 8:
  0x405c2a		4883f908		CMPQ $0x8, CX		
  0x405c2e		0f861b010000		JBE 0x405d4f		
	case s <= 16:
  0x405c34		4883f910		CMPQ $0x10, CX		
  0x405c38		0f86d2000000		JBE 0x405d10		
	case s <= 32:
  0x405c3e		4883f920		CMPQ $0x20, CX		
  0x405c42		7623			JBE 0x405c67		
		v2 := uint64(seed * hashkey[1])
  0x405c44		488b35dddd0b00		MOVQ runtime.hashkey+8(SB), SI	
  0x405c4b		480faff2		IMULQ DX, SI			
		v3 := uint64(seed * hashkey[2])
  0x405c4f		488b3ddadd0b00		MOVQ runtime.hashkey+16(SB), DI	
  0x405c56		480faffa		IMULQ DX, DI			
		v4 := uint64(seed * hashkey[3])
  0x405c5a		4c8b05d7dd0b00		MOVQ runtime.hashkey+24(SB), R8	
  0x405c61		4c0fafc2		IMULQ DX, R8			
		for s >= 32 {
  0x405c65		eb9d			JMP 0x405c04		
	return unsafe.Pointer(uintptr(p) + x)
  0x405c67		488d5308		LEAQ 0x8(BX), DX		
  0x405c6b		4889de			MOVQ BX, SI			
  0x405c6e		488d7c19f0		LEAQ -0x10(CX)(BX*1), DI	
  0x405c73		488d4c19f8		LEAQ -0x8(CX)(BX*1), CX		
	return *(*uint64)(p)
  0x405c78		488b1e			MOVQ 0(SI), BX		
		h ^= readUnaligned64(p)
  0x405c7b		4831d8			XORQ BX, AX		
		h = rotl_31(h*m1) * m2
  0x405c7e		48bb4115f07990ec38ea	MOVQ $0xea38ec9079f01541, BX	
  0x405c88		480fafd8		IMULQ AX, BX			
	return (x << 31) | (x >> (64 - 31))
  0x405c8c		48c1c31f		ROLQ $0x1f, BX		
		h = rotl_31(h*m1) * m2
  0x405c90		48b89913da960da32327	MOVQ $0x2723a30d96da1399, AX	
  0x405c9a		480fafc3		IMULQ BX, AX			
		h ^= readUnaligned64(add(p, 8))
  0x405c9e		483302			XORQ 0(DX), AX		
		h = rotl_31(h*m1) * m2
  0x405ca1		48ba4115f07990ec38ea	MOVQ $0xea38ec9079f01541, DX	
  0x405cab		480fafc2		IMULQ DX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x405caf		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x405cb3		48bb9913da960da32327	MOVQ $0x2723a30d96da1399, BX	
  0x405cbd		480fafc3		IMULQ BX, AX			
		h ^= readUnaligned64(add(p, s-16))
  0x405cc1		483307			XORQ 0(DI), AX		
		h = rotl_31(h*m1) * m2
  0x405cc4		480fafc2		IMULQ DX, AX		
	return (x << 31) | (x >> (64 - 31))
  0x405cc8		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x405ccc		480fafc3		IMULQ BX, AX		
		h ^= readUnaligned64(add(p, s-8))
  0x405cd0		483301			XORQ 0(CX), AX		
		h = rotl_31(h*m1) * m2
  0x405cd3		480fafc2		IMULQ DX, AX		
	return (x << 31) | (x >> (64 - 31))
  0x405cd7		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x405cdb		480fafc3		IMULQ BX, AX		
	return uintptr(h)
  0x405cdf		4889c1			MOVQ AX, CX		
	h ^= h >> 29
  0x405ce2		48c1e81d		SHRQ $0x1d, AX		
  0x405ce6		4831c1			XORQ AX, CX		
	h *= m3
  0x405ce9		48b8d7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, AX	
  0x405cf3		480fafc8		IMULQ AX, CX			
  0x405cf7		4889c8			MOVQ CX, AX			
	h ^= h >> 32
  0x405cfa		48c1e920		SHRQ $0x20, CX		
  0x405cfe		4831c1			XORQ AX, CX		
	return uintptr(h)
  0x405d01		48894c2448		MOVQ CX, 0x48(SP)	
  0x405d06		488b6c2420		MOVQ 0x20(SP), BP	
  0x405d0b		4883c428		ADDQ $0x28, SP		
  0x405d0f		c3			RET			
  0x405d10		4889da			MOVQ BX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x405d13		488d4c19f8		LEAQ -0x8(CX)(BX*1), CX	
	return *(*uint64)(p)
  0x405d18		488b12			MOVQ 0(DX), DX		
		h ^= readUnaligned64(p)
  0x405d1b		4831d0			XORQ DX, AX		
		h = rotl_31(h*m1) * m2
  0x405d1e		48ba4115f07990ec38ea	MOVQ $0xea38ec9079f01541, DX	
  0x405d28		480fafc2		IMULQ DX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x405d2c		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x405d30		48bb9913da960da32327	MOVQ $0x2723a30d96da1399, BX	
  0x405d3a		480fafc3		IMULQ BX, AX			
		h ^= readUnaligned64(add(p, s-8))
  0x405d3e		483301			XORQ 0(CX), AX		
		h = rotl_31(h*m1) * m2
  0x405d41		480fafc2		IMULQ DX, AX		
	return (x << 31) | (x >> (64 - 31))
  0x405d45		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x405d49		480fafc3		IMULQ BX, AX		
	switch {
  0x405d4d		eb90			JMP 0x405cdf		
  0x405d4f		4889da			MOVQ BX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x405d52		488d4c19fc		LEAQ -0x4(CX)(BX*1), CX	
		h ^= uint64(readUnaligned32(p))
  0x405d57		8b12			MOVL 0(DX), DX		
  0x405d59		4831d0			XORQ DX, AX		
		h ^= uint64(readUnaligned32(add(p, s-4))) << 32
  0x405d5c		8b09			MOVL 0(CX), CX		
  0x405d5e		48c1e120		SHLQ $0x20, CX		
  0x405d62		4831c8			XORQ CX, AX		
		h = rotl_31(h*m1) * m2
  0x405d65		48b94115f07990ec38ea	MOVQ $0xea38ec9079f01541, CX	
  0x405d6f		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x405d73		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x405d77		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x405d81		480fafc1		IMULQ CX, AX			
	switch {
  0x405d85		e955ffffff		JMP 0x405cdf		
  0x405d8a		4889ca			MOVQ CX, DX		
		h ^= uint64(*(*byte)(add(p, s>>1))) << 8
  0x405d8d		48d1e9			SHRQ $0x1, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x405d90		488d340b		LEAQ 0(BX)(CX*1), SI	
		h ^= uint64(*(*byte)(add(p, s>>1))) << 8
  0x405d94		8406			TESTB AL, 0(SI)		
  0x405d96		4889de			MOVQ BX, SI		
	return unsafe.Pointer(uintptr(p) + x)
  0x405d99		488d541aff		LEAQ -0x1(DX)(BX*1), DX	
		h ^= uint64(*(*byte)(p))
  0x405d9e		0fb61e			MOVZX 0(SI), BX		
  0x405da1		4831d8			XORQ BX, AX		
		h ^= uint64(*(*byte)(add(p, s>>1))) << 8
  0x405da4		0fb60c0e		MOVZX 0(SI)(CX*1), CX	
  0x405da8		48c1e108		SHLQ $0x8, CX		
  0x405dac		4831c8			XORQ CX, AX		
		h ^= uint64(*(*byte)(add(p, s-1))) << 16
  0x405daf		0fb60a			MOVZX 0(DX), CX		
  0x405db2		48c1e110		SHLQ $0x10, CX		
  0x405db6		4831c8			XORQ CX, AX		
		h = rotl_31(h*m1) * m2
  0x405db9		48b94115f07990ec38ea	MOVQ $0xea38ec9079f01541, CX	
  0x405dc3		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x405dc7		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x405dcb		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x405dd5		480fafc1		IMULQ CX, AX			
	switch {
  0x405dd9		e901ffffff		JMP 0x405cdf		
  0x405dde		488b442430		MOVQ 0x30(SP), AX	
		return aeshash(p, seed, s)
  0x405de3		48890424		MOVQ AX, 0(SP)			
  0x405de7		488b442438		MOVQ 0x38(SP), AX		
  0x405dec		4889442408		MOVQ AX, 0x8(SP)		
  0x405df1		488b442440		MOVQ 0x40(SP), AX		
  0x405df6		4889442410		MOVQ AX, 0x10(SP)		
  0x405dfb		e810ff0300		CALL runtime.aeshash(SB)	
  0x405e00		488b442418		MOVQ 0x18(SP), AX		
  0x405e05		4889442448		MOVQ AX, 0x48(SP)		
  0x405e0a		488b6c2420		MOVQ 0x20(SP), BP		
  0x405e0f		4883c428		ADDQ $0x28, SP			
  0x405e13		c3			RET				
func memhash(p unsafe.Pointer, seed, s uintptr) uintptr {
  0x405e14		e857e70300		CALL runtime.morestack_noctxt(SB)	
  0x405e19		e9f2fcffff		JMP runtime.memhash(SB)			

TEXT runtime.memhash32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hash64.go
	h := uint64(seed + 4*hashkey[0])
  0x405e20		488b05f9db0b00		MOVQ runtime.hashkey(SB), AX	
  0x405e27		488b4c2408		MOVQ 0x8(SP), CX		
	v := uint64(readUnaligned32(p))
  0x405e2c		8b09			MOVL 0(CX), CX		
func memhash32(p unsafe.Pointer, seed uintptr) uintptr {
  0x405e2e		488b542410		MOVQ 0x10(SP), DX	
	h := uint64(seed + 4*hashkey[0])
  0x405e33		488d0482		LEAQ 0(DX)(AX*4), AX	
	h ^= v
  0x405e37		4831c8			XORQ CX, AX		
	h ^= v << 32
  0x405e3a		48c1e120		SHLQ $0x20, CX		
  0x405e3e		4831c1			XORQ AX, CX		
	h = rotl_31(h*m1) * m2
  0x405e41		48b84115f07990ec38ea	MOVQ $0xea38ec9079f01541, AX	
  0x405e4b		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x405e4f		48c1c01f		ROLQ $0x1f, AX		
	h = rotl_31(h*m1) * m2
  0x405e53		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x405e5d		480fafc8		IMULQ AX, CX			
  0x405e61		4889c8			MOVQ CX, AX			
	h ^= h >> 29
  0x405e64		48c1e91d		SHRQ $0x1d, CX		
  0x405e68		4831c8			XORQ CX, AX		
	h *= m3
  0x405e6b		48b9d7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, CX	
  0x405e75		480fafc8		IMULQ AX, CX			
  0x405e79		4889c8			MOVQ CX, AX			
	h ^= h >> 32
  0x405e7c		48c1e920		SHRQ $0x20, CX		
  0x405e80		4831c8			XORQ CX, AX		
	return uintptr(h)
  0x405e83		4889442418		MOVQ AX, 0x18(SP)	
  0x405e88		c3			RET			

TEXT runtime.memhash64(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hash64.go
func memhash64(p unsafe.Pointer, seed uintptr) uintptr {
  0x405e90		488b442408		MOVQ 0x8(SP), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x405e95		488d4804		LEAQ 0x4(AX), CX	
	return *(*uint32)(p)
  0x405e99		8401			TESTB AL, 0(CX)		
	h := uint64(seed + 8*hashkey[0])
  0x405e9b		488b0d7edb0b00		MOVQ runtime.hashkey(SB), CX	
  0x405ea2		488b542410		MOVQ 0x10(SP), DX		
  0x405ea7		488d0cca		LEAQ 0(DX)(CX*8), CX		
	h ^= uint64(readUnaligned32(p)) | uint64(readUnaligned32(add(p, 4)))<<32
  0x405eab		483308			XORQ 0(AX), CX		
	h = rotl_31(h*m1) * m2
  0x405eae		48b84115f07990ec38ea	MOVQ $0xea38ec9079f01541, AX	
  0x405eb8		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x405ebc		48c1c01f		ROLQ $0x1f, AX		
	h = rotl_31(h*m1) * m2
  0x405ec0		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x405eca		480fafc8		IMULQ AX, CX			
  0x405ece		4889c8			MOVQ CX, AX			
	h ^= h >> 29
  0x405ed1		48c1e91d		SHRQ $0x1d, CX		
  0x405ed5		4831c8			XORQ CX, AX		
	h *= m3
  0x405ed8		48b9d7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, CX	
  0x405ee2		480fafc8		IMULQ AX, CX			
  0x405ee6		4889c8			MOVQ CX, AX			
	h ^= h >> 32
  0x405ee9		48c1e920		SHRQ $0x20, CX		
  0x405eed		4831c1			XORQ AX, CX		
	return uintptr(h)
  0x405ef0		48894c2418		MOVQ CX, 0x18(SP)	
  0x405ef5		c3			RET			

TEXT runtime.(*hmap).incrnoverflow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func (h *hmap) incrnoverflow() {
  0x405f00		488b442408		MOVQ 0x8(SP), AX	
	if h.B < 16 {
  0x405f05		0fb65009		MOVZX 0x9(AX), DX	
  0x405f09		80fa10			CMPL $0x10, DL		
  0x405f0c		7269			JB 0x405f77		
	mp := getg().m
  0x405f0e		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x405f17		488b5b30		MOVQ 0x30(BX), BX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x405f1b		8bb320010000		MOVL 0x120(BX), SI	
  0x405f21		8bbb24010000		MOVL 0x124(BX), DI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x405f27		89bb20010000		MOVL DI, 0x120(BX)	
  0x405f2d		4189f0			MOVL SI, R8		
	s1 ^= s1 << 17
  0x405f30		c1e611			SHLL $0x11, SI		
  0x405f33		4431c6			XORL R8, SI		
  0x405f36		4189f8			MOVL DI, R8		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x405f39		31f7			XORL SI, DI		
  0x405f3b		c1ee07			SHRL $0x7, SI		
  0x405f3e		31fe			XORL DI, SI		
  0x405f40		4489c7			MOVL R8, DI		
  0x405f43		41c1e810		SHRL $0x10, R8		
  0x405f47		4131f0			XORL SI, R8		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x405f4a		44898324010000		MOVL R8, 0x124(BX)	
	mask := uint32(1)<<(h.B-15) - 1
  0x405f51		8d4af1			LEAL -0xf(DX), CX	
  0x405f54		ba01000000		MOVL $0x1, DX		
  0x405f59		d3e2			SHLL CL, DX		
  0x405f5b		80f920			CMPL $0x20, CL		
  0x405f5e		19db			SBBL BX, BX		
  0x405f60		21da			ANDL BX, DX		
  0x405f62		ffca			DECL DX			
	return s0 + s1
  0x405f64		418d1c38		LEAL 0(R8)(DI*1), BX	
	if fastrand()&mask == 0 {
  0x405f68		85da			TESTL BX, DX		
  0x405f6a		750a			JNE 0x405f76		
		h.noverflow++
  0x405f6c		0fb7480a		MOVZX 0xa(AX), CX	
  0x405f70		ffc1			INCL CX			
  0x405f72		6689480a		MOVW CX, 0xa(AX)	
  0x405f76		c3			RET			
		h.noverflow++
  0x405f77		0fb7480a		MOVZX 0xa(AX), CX	
  0x405f7b		ffc1			INCL CX			
  0x405f7d		6689480a		MOVW CX, 0xa(AX)	
		return
  0x405f81		c3			RET			

TEXT runtime.(*hmap).newoverflow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
  0x405f90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x405f99		483b6110		CMPQ 0x10(CX), SP	
  0x405f9d		0f86c5020000		JBE 0x406268		
  0x405fa3		4883ec60		SUBQ $0x60, SP		
  0x405fa7		48896c2458		MOVQ BP, 0x58(SP)	
  0x405fac		488d6c2458		LEAQ 0x58(SP), BP	
  0x405fb1		488b4c2468		MOVQ 0x68(SP), CX	
	if h.extra != nil && h.extra.nextOverflow != nil {
  0x405fb6		488b5128		MOVQ 0x28(CX), DX	
  0x405fba		488d5928		LEAQ 0x28(CX), BX	
  0x405fbe		48895c2450		MOVQ BX, 0x50(SP)	
  0x405fc3		4885d2			TESTQ DX, DX		
  0x405fc6		0f847b020000		JE 0x406247		
  0x405fcc		488b7210		MOVQ 0x10(DX), SI	
  0x405fd0		488d7a10		LEAQ 0x10(DX), DI	
  0x405fd4		4885f6			TESTQ SI, SI		
  0x405fd7		0f846a020000		JE 0x406247		
  0x405fdd		4c8b442470		MOVQ 0x70(SP), R8	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x405fe2		450fb74854		MOVZX 0x54(R8), R9	
  0x405fe7		4989f2			MOVQ SI, R10		
	return unsafe.Pointer(uintptr(p) + x)
  0x405fea		4a8d740ef8		LEAQ -0x8(SI)(R9*1), SI	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x405fef		418400			TESTB AL, 0(R8)		
  0x405ff2		4c8b1e			MOVQ 0(SI), R11		
		if ovf.overflow(t) == nil {
  0x405ff5		4d85db			TESTQ R11, R11		
  0x405ff8		0f8428020000		JE 0x406226		
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x405ffe		8b150cda0b00		MOVL runtime.writeBarrier(SB), DX	
  0x406004		85d2			TESTL DX, DX				
  0x406006		0f850b020000		JNE 0x406217				
  0x40600c		48c70600000000		MOVQ $0x0, 0(SI)			
			h.extra.nextOverflow = nil
  0x406013		488b5128		MOVQ 0x28(CX), DX			
  0x406017		8402			TESTB AL, 0(DX)				
  0x406019		8b35f1d90b00		MOVL runtime.writeBarrier(SB), SI	
  0x40601f		488d7a10		LEAQ 0x10(DX), DI			
  0x406023		85f6			TESTL SI, SI				
  0x406025		0f85e0010000		JNE 0x40620b				
  0x40602b		48c7421000000000	MOVQ $0x0, 0x10(DX)			
  0x406033		4c89542440		MOVQ R10, 0x40(SP)			
	h.incrnoverflow()
  0x406038		48890c24		MOVQ CX, 0(SP)				
  0x40603c		e8bffeffff		CALL runtime.(*hmap).incrnoverflow(SB)	
  0x406041		488b442470		MOVQ 0x70(SP), AX			
	if t.bucket.kind&kindNoPointers != 0 {
  0x406046		488b4840		MOVQ 0x40(AX), CX	
  0x40604a		0fb64917		MOVZX 0x17(CX), CX	
  0x40604e		f6c180			TESTL $0x80, CL		
  0x406051		0f84aa010000		JE 0x406201		
  0x406057		488b4c2468		MOVQ 0x68(SP), CX	
	if h.extra == nil {
  0x40605c		488b5128		MOVQ 0x28(CX), DX	
  0x406060		4885d2			TESTQ DX, DX		
  0x406063		0f844f010000		JE 0x4061b8		
	if h.extra.overflow == nil {
  0x406069		488b5128		MOVQ 0x28(CX), DX	
  0x40606d		488b12			MOVQ 0(DX), DX		
  0x406070		4885d2			TESTQ DX, DX		
  0x406073		0f84f5000000		JE 0x40616e		
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x406079		488b4928		MOVQ 0x28(CX), CX			
  0x40607d		488b11			MOVQ 0(CX), DX				
  0x406080		8401			TESTB AL, 0(CX)				
  0x406082		488b4a10		MOVQ 0x10(DX), CX			
  0x406086		488b5a08		MOVQ 0x8(DX), BX			
  0x40608a		488b32			MOVQ 0(DX), SI				
  0x40608d		4c8d4301		LEAQ 0x1(BX), R8			
  0x406091		4939c8			CMPQ CX, R8				
  0x406094		7f70			JG 0x406106				
  0x406096		488d4b01		LEAQ 0x1(BX), CX			
  0x40609a		48894a08		MOVQ CX, 0x8(DX)			
  0x40609e		8b0d6cd90b00		MOVL runtime.writeBarrier(SB), CX	
  0x4060a4		488d3cde		LEAQ 0(SI)(BX*8), DI			
  0x4060a8		85c9			TESTL CX, CX				
  0x4060aa		7542			JNE 0x4060ee				
  0x4060ac		488b4c2440		MOVQ 0x40(SP), CX			
  0x4060b1		48890cde		MOVQ CX, 0(SI)(BX*8)			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x4060b5		0fb75054		MOVZX 0x54(AX), DX	
  0x4060b9		488b5c2478		MOVQ 0x78(SP), BX	
	return unsafe.Pointer(uintptr(p) + x)
  0x4060be		488d7c13f8		LEAQ -0x8(BX)(DX*1), DI	
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x4060c3		8407			TESTB AL, 0(DI)				
  0x4060c5		8b1545d90b00		MOVL runtime.writeBarrier(SB), DX	
  0x4060cb		85d2			TESTL DX, DX				
  0x4060cd		7515			JNE 0x4060e4				
  0x4060cf		48890f			MOVQ CX, 0(DI)				
	return ovf
  0x4060d2		48898c2480000000	MOVQ CX, 0x80(SP)	
  0x4060da		488b6c2458		MOVQ 0x58(SP), BP	
  0x4060df		4883c460		ADDQ $0x60, SP		
  0x4060e3		c3			RET			
  0x4060e4		4889c8			MOVQ CX, AX		
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x4060e7		e8b4070400		CALL runtime.gcWriteBarrier(SB)	
  0x4060ec		ebe4			JMP 0x4060d2			
  0x4060ee		4889c1			MOVQ AX, CX			
  0x4060f1		488b442440		MOVQ 0x40(SP), AX		
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x4060f6		e8a5070400		CALL runtime.gcWriteBarrier(SB)		
  0x4060fb		4889c2			MOVQ AX, DX				
  0x4060fe		4889c8			MOVQ CX, AX				
  0x406101		4889d1			MOVQ DX, CX				
  0x406104		ebaf			JMP 0x4060b5				
  0x406106		4889542448		MOVQ DX, 0x48(SP)			
  0x40610b		488d050e5c0500		LEAQ 0x55c0e(IP), AX			
  0x406112		48890424		MOVQ AX, 0(SP)				
  0x406116		4889742408		MOVQ SI, 0x8(SP)			
  0x40611b		48895c2410		MOVQ BX, 0x10(SP)			
  0x406120		48894c2418		MOVQ CX, 0x18(SP)			
  0x406125		4c89442420		MOVQ R8, 0x20(SP)			
  0x40612a		e831d70200		CALL runtime.growslice(SB)		
  0x40612f		488b442428		MOVQ 0x28(SP), AX			
  0x406134		488b4c2430		MOVQ 0x30(SP), CX			
  0x406139		488b542438		MOVQ 0x38(SP), DX			
  0x40613e		488b7c2448		MOVQ 0x48(SP), DI			
  0x406143		48895710		MOVQ DX, 0x10(DI)			
  0x406147		8b15c3d80b00		MOVL runtime.writeBarrier(SB), DX	
  0x40614d		85d2			TESTL DX, DX				
  0x40614f		7516			JNE 0x406167				
  0x406151		488907			MOVQ AX, 0(DI)				
  0x406154		4889fa			MOVQ DI, DX				
  0x406157		4889cb			MOVQ CX, BX				
  0x40615a		4889c6			MOVQ AX, SI				
  0x40615d		488b442470		MOVQ 0x70(SP), AX			
  0x406162		e92fffffff		JMP 0x406096				
  0x406167		e834070400		CALL runtime.gcWriteBarrier(SB)		
  0x40616c		ebe6			JMP 0x406154				
		h.extra.overflow = new([]*bmap)
  0x40616e		488d052bf80400		LEAQ 0x4f82b(IP), AX			
  0x406175		48890424		MOVQ AX, 0(SP)				
  0x406179		e8a24f0000		CALL runtime.newobject(SB)		
  0x40617e		488b442468		MOVQ 0x68(SP), AX			
  0x406183		488b7828		MOVQ 0x28(AX), DI			
  0x406187		8407			TESTB AL, 0(DI)				
  0x406189		8b0d81d80b00		MOVL runtime.writeBarrier(SB), CX	
  0x40618f		488b542408		MOVQ 0x8(SP), DX			
  0x406194		85c9			TESTL CX, CX				
  0x406196		7510			JNE 0x4061a8				
  0x406198		488917			MOVQ DX, 0(DI)				
  0x40619b		4889c1			MOVQ AX, CX				
  0x40619e		488b442470		MOVQ 0x70(SP), AX			
  0x4061a3		e9d1feffff		JMP 0x406079				
  0x4061a8		4889c1			MOVQ AX, CX				
  0x4061ab		4889d0			MOVQ DX, AX				
  0x4061ae		e8ed060400		CALL runtime.gcWriteBarrier(SB)		
  0x4061b3		4889c8			MOVQ CX, AX				
  0x4061b6		ebe3			JMP 0x40619b				
		h.extra = new(mapextra)
  0x4061b8		488d05019d0500		LEAQ 0x59d01(IP), AX			
  0x4061bf		48890424		MOVQ AX, 0(SP)				
  0x4061c3		e8584f0000		CALL runtime.newobject(SB)		
  0x4061c8		8b0542d80b00		MOVL runtime.writeBarrier(SB), AX	
  0x4061ce		488b4c2408		MOVQ 0x8(SP), CX			
  0x4061d3		85c0			TESTL AX, AX				
  0x4061d5		7516			JNE 0x4061ed				
  0x4061d7		488b542468		MOVQ 0x68(SP), DX			
  0x4061dc		48894a28		MOVQ CX, 0x28(DX)			
  0x4061e0		488b442470		MOVQ 0x70(SP), AX			
  0x4061e5		4889d1			MOVQ DX, CX				
  0x4061e8		e97cfeffff		JMP 0x406069				
  0x4061ed		488b7c2450		MOVQ 0x50(SP), DI			
  0x4061f2		4889c8			MOVQ CX, AX				
  0x4061f5		e8a6060400		CALL runtime.gcWriteBarrier(SB)		
  0x4061fa		488b542468		MOVQ 0x68(SP), DX			
  0x4061ff		ebdf			JMP 0x4061e0				
  0x406201		488b4c2440		MOVQ 0x40(SP), CX			
	if t.bucket.kind&kindNoPointers != 0 {
  0x406206		e9aafeffff		JMP 0x4060b5		
			h.extra.nextOverflow = nil
  0x40620b		31c0			XORL AX, AX			
  0x40620d		e88e060400		CALL runtime.gcWriteBarrier(SB)	
  0x406212		e91cfeffff		JMP 0x406033			
  0x406217		4889f7			MOVQ SI, DI			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40621a		31c0			XORL AX, AX			
  0x40621c		e87f060400		CALL runtime.gcWriteBarrier(SB)	
  0x406221		e9edfdffff		JMP 0x406013			
			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
  0x406226		8b35e4d70b00		MOVL runtime.writeBarrier(SB), SI	
	return unsafe.Pointer(uintptr(p) + x)
  0x40622c		4b8d040a		LEAQ 0(R10)(R9*1), AX	
			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
  0x406230		85f6			TESTL SI, SI			
  0x406232		7509			JNE 0x40623d			
  0x406234		48894210		MOVQ AX, 0x10(DX)		
  0x406238		e9f6fdffff		JMP 0x406033			
  0x40623d		e85e060400		CALL runtime.gcWriteBarrier(SB)	
  0x406242		e9ecfdffff		JMP 0x406033			
  0x406247		488b442470		MOVQ 0x70(SP), AX		
		ovf = (*bmap)(newobject(t.bucket))
  0x40624c		488b4840		MOVQ 0x40(AX), CX		
  0x406250		48890c24		MOVQ CX, 0(SP)			
  0x406254		e8c74e0000		CALL runtime.newobject(SB)	
  0x406259		4c8b542408		MOVQ 0x8(SP), R10		
  0x40625e		488b4c2468		MOVQ 0x68(SP), CX		
  0x406263		e9cbfdffff		JMP 0x406033			
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
  0x406268		e803e30300		CALL runtime.morestack_noctxt(SB)	
  0x40626d		e91efdffff		JMP runtime.(*hmap).newoverflow(SB)	

TEXT runtime.makemap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func makemap(t *maptype, hint int, h *hmap) *hmap {
  0x406280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x406289		483b6110		CMPQ 0x10(CX), SP	
  0x40628d		0f86d1010000		JBE 0x406464		
  0x406293		4883ec38		SUBQ $0x38, SP		
  0x406297		48896c2430		MOVQ BP, 0x30(SP)	
  0x40629c		488d6c2430		LEAQ 0x30(SP), BP	
  0x4062a1		488b542448		MOVQ 0x48(SP), DX	
	if hint < 0 || hint > int(maxSliceCap(t.bucket.size)) {
  0x4062a6		4885d2			TESTQ DX, DX		
  0x4062a9		0f8d70010000		JGE 0x40641f		
  0x4062af		31c0			XORL AX, AX		
	if h == nil {
  0x4062b1		488b542450		MOVQ 0x50(SP), DX	
  0x4062b6		4885d2			TESTQ DX, DX		
  0x4062b9		0f843a010000		JE 0x4063f9		
	mp := getg().m
  0x4062bf		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x4062c8		488b5b30		MOVQ 0x30(BX), BX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x4062cc		8bb320010000		MOVL 0x120(BX), SI	
  0x4062d2		8bbb24010000		MOVL 0x124(BX), DI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x4062d8		89bb20010000		MOVL DI, 0x120(BX)	
  0x4062de		4189f0			MOVL SI, R8		
	s1 ^= s1 << 17
  0x4062e1		c1e611			SHLL $0x11, SI		
  0x4062e4		4431c6			XORL R8, SI		
  0x4062e7		4189f8			MOVL DI, R8		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x4062ea		31f7			XORL SI, DI		
  0x4062ec		c1ee07			SHRL $0x7, SI		
  0x4062ef		31fe			XORL DI, SI		
  0x4062f1		4489c7			MOVL R8, DI		
  0x4062f4		41c1e810		SHRL $0x10, R8		
  0x4062f8		4131f0			XORL SI, R8		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x4062fb		44898324010000		MOVL R8, 0x124(BX)	
	return s0 + s1
  0x406302		428d1c07		LEAL 0(DI)(R8*1), BX	
	h.hash0 = fastrand()
  0x406306		895a0c			MOVL BX, 0xc(DX)	
  0x406309		31c9			XORL CX, CX		
	for overLoadFactor(hint, B) {
  0x40630b		eb02			JMP 0x40630f		
		B++
  0x40630d		ffc1			INCL CX			
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40630f		4883f808		CMPQ $0x8, AX		
  0x406313		0f8ed9000000		JLE 0x4063f2		
	return uintptr(1) << b
  0x406319		bb01000000		MOVL $0x1, BX		
  0x40631e		48d3e3			SHLQ CL, BX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x406321		48d1eb			SHRQ $0x1, BX		
  0x406324		488d345b		LEAQ 0(BX)(BX*2), SI	
  0x406328		488d1cb3		LEAQ 0(BX)(SI*4), BX	
  0x40632c		4839d8			CMPQ BX, AX		
  0x40632f		0f97c3			SETA BL			
  0x406332		84db			TESTL BL, BL		
	for overLoadFactor(hint, B) {
  0x406334		75d7			JNE 0x40630d		
	h.B = B
  0x406336		884a09			MOVB CL, 0x9(DX)	
	if h.B != 0 {
  0x406339		84c9			TESTL CL, CL		
  0x40633b		750f			JNE 0x40634c		
	return h
  0x40633d		4889542458		MOVQ DX, 0x58(SP)	
  0x406342		488b6c2430		MOVQ 0x30(SP), BP	
  0x406347		4883c438		ADDQ $0x38, SP		
  0x40634b		c3			RET			
  0x40634c		4889542450		MOVQ DX, 0x50(SP)	
		h.buckets, nextOverflow = makeBucketArray(t, h.B)
  0x406351		884c2408		MOVB CL, 0x8(SP)			
  0x406355		488b442440		MOVQ 0x40(SP), AX			
  0x40635a		48890424		MOVQ AX, 0(SP)				
  0x40635e		e8ed080000		CALL runtime.makeBucketArray(SB)	
  0x406363		8b05a7d60b00		MOVL runtime.writeBarrier(SB), AX	
  0x406369		488b4c2410		MOVQ 0x10(SP), CX			
  0x40636e		488b542418		MOVQ 0x18(SP), DX			
  0x406373		488b5c2450		MOVQ 0x50(SP), BX			
  0x406378		488d7b10		LEAQ 0x10(BX), DI			
  0x40637c		85c0			TESTL AX, AX				
  0x40637e		7568			JNE 0x4063e8				
  0x406380		48894b10		MOVQ CX, 0x10(BX)			
		if nextOverflow != nil {
  0x406384		4885d2			TESTQ DX, DX		
  0x406387		7505			JNE 0x40638e		
  0x406389		4889da			MOVQ BX, DX		
	return h
  0x40638c		ebaf			JMP 0x40633d		
  0x40638e		4889542428		MOVQ DX, 0x28(SP)	
			h.extra = new(mapextra)
  0x406393		488d05269b0500		LEAQ 0x59b26(IP), AX			
  0x40639a		48890424		MOVQ AX, 0(SP)				
  0x40639e		e87d4d0000		CALL runtime.newobject(SB)		
  0x4063a3		8b0567d60b00		MOVL runtime.writeBarrier(SB), AX	
  0x4063a9		488b4c2450		MOVQ 0x50(SP), CX			
  0x4063ae		488d7928		LEAQ 0x28(CX), DI			
  0x4063b2		488b542408		MOVQ 0x8(SP), DX			
			h.extra.nextOverflow = nextOverflow
  0x4063b7		488d5a10		LEAQ 0x10(DX), BX	
			h.extra = new(mapextra)
  0x4063bb		85c0			TESTL AX, AX		
  0x4063bd		7512			JNE 0x4063d1		
  0x4063bf		48895128		MOVQ DX, 0x28(CX)	
  0x4063c3		488b442428		MOVQ 0x28(SP), AX	
			h.extra.nextOverflow = nextOverflow
  0x4063c8		48894210		MOVQ AX, 0x10(DX)	
			h.extra = new(mapextra)
  0x4063cc		4889cb			MOVQ CX, BX		
			h.extra.nextOverflow = nextOverflow
  0x4063cf		ebb8			JMP 0x406389		
  0x4063d1		4889d0			MOVQ DX, AX		
			h.extra = new(mapextra)
  0x4063d4		e8c7040400		CALL runtime.gcWriteBarrier(SB)	
  0x4063d9		4889df			MOVQ BX, DI			
  0x4063dc		488b442428		MOVQ 0x28(SP), AX		
			h.extra.nextOverflow = nextOverflow
  0x4063e1		e8ba040400		CALL runtime.gcWriteBarrier(SB)	
			h.extra = new(mapextra)
  0x4063e6		ebe4			JMP 0x4063cc		
  0x4063e8		4889c8			MOVQ CX, AX		
		h.buckets, nextOverflow = makeBucketArray(t, h.B)
  0x4063eb		e8b0040400		CALL runtime.gcWriteBarrier(SB)	
  0x4063f0		eb92			JMP 0x406384			
  0x4063f2		31db			XORL BX, BX			
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x4063f4		e939ffffff		JMP 0x406332		
  0x4063f9		4889442420		MOVQ AX, 0x20(SP)	
  0x4063fe		488b442440		MOVQ 0x40(SP), AX	
		h = (*hmap)(newobject(t.hmap))
  0x406403		488b4848		MOVQ 0x48(AX), CX		
  0x406407		48890c24		MOVQ CX, 0(SP)			
  0x40640b		e8104d0000		CALL runtime.newobject(SB)	
  0x406410		488b542408		MOVQ 0x8(SP), DX		
  0x406415		488b442420		MOVQ 0x20(SP), AX		
  0x40641a		e9a0feffff		JMP 0x4062bf			
  0x40641f		488b5c2440		MOVQ 0x40(SP), BX		
	if hint < 0 || hint > int(maxSliceCap(t.bucket.size)) {
  0x406424		488b7340		MOVQ 0x40(BX), SI	
  0x406428		488b36			MOVQ 0(SI), SI		
	if elemsize < uintptr(len(maxElems)) {
  0x40642b		4883fe21		CMPQ $0x21, SI		
  0x40642f		731c			JAE 0x40644d		
		return maxElems[elemsize]
  0x406431		488d0548f10900		LEAQ runtime.maxElems(SB), AX	
  0x406438		488b04f0		MOVQ 0(AX)(SI*8), AX		
	if hint < 0 || hint > int(maxSliceCap(t.bucket.size)) {
  0x40643c		4839c2			CMPQ AX, DX		
  0x40643f		0f8f6afeffff		JG 0x4062af		
  0x406445		4889d0			MOVQ DX, AX		
  0x406448		e964feffff		JMP 0x4062b1		
	return _MaxMem / elemsize
  0x40644d		48b8ffffffff7f000000	MOVQ $0x7fffffffff, AX	
  0x406457		4889d1			MOVQ DX, CX		
  0x40645a		31d2			XORL DX, DX		
  0x40645c		48f7f6			DIVQ SI			
  0x40645f		4889ca			MOVQ CX, DX		
	if hint < 0 || hint > int(maxSliceCap(t.bucket.size)) {
  0x406462		ebd8			JMP 0x40643c		
func makemap(t *maptype, hint int, h *hmap) *hmap {
  0x406464		e807e10300		CALL runtime.morestack_noctxt(SB)	
  0x406469		e912feffff		JMP runtime.makemap(SB)			

TEXT runtime.mapaccess2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {
  0x406470		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x406479		483b6110		CMPQ 0x10(CX), SP	
  0x40647d		0f8614020000		JBE 0x406697		
  0x406483		4883ec40		SUBQ $0x40, SP		
  0x406487		48896c2438		MOVQ BP, 0x38(SP)	
  0x40648c		488d6c2438		LEAQ 0x38(SP), BP	
  0x406491		488b442450		MOVQ 0x50(SP), AX	
	if h == nil || h.count == 0 {
  0x406496		4885c0			TESTQ AX, AX		
  0x406499		0f84c2010000		JE 0x406661		
  0x40649f		488b08			MOVQ 0(AX), CX		
  0x4064a2		4885c9			TESTQ CX, CX		
  0x4064a5		0f84b6010000		JE 0x406661		
	if h.flags&hashWriting != 0 {
  0x4064ab		0fb64808		MOVZX 0x8(AX), CX	
  0x4064af		f6c104			TESTL $0x4, CL		
  0x4064b2		0f85c4010000		JNE 0x40667c		
  0x4064b8		488b4c2448		MOVQ 0x48(SP), CX	
	alg := t.key.alg
  0x4064bd		488b5930		MOVQ 0x30(CX), BX	
  0x4064c1		488b5b18		MOVQ 0x18(BX), BX	
  0x4064c5		48895c2428		MOVQ BX, 0x28(SP)	
	hash := alg.hash(key, uintptr(h.hash0))
  0x4064ca		488b13			MOVQ 0(BX), DX		
  0x4064cd		8b700c			MOVL 0xc(AX), SI	
  0x4064d0		4889742408		MOVQ SI, 0x8(SP)	
  0x4064d5		488b742458		MOVQ 0x58(SP), SI	
  0x4064da		48893424		MOVQ SI, 0(SP)		
  0x4064de		488b3a			MOVQ 0(DX), DI		
  0x4064e1		ffd7			CALL DI			
  0x4064e3		488b442410		MOVQ 0x10(SP), AX	
  0x4064e8		488b4c2450		MOVQ 0x50(SP), CX	
	m := bucketMask(h.B)
  0x4064ed		0fb65909		MOVZX 0x9(CX), BX	
  0x4064f1		4889ca			MOVQ CX, DX		
  0x4064f4		89d9			MOVL BX, CX		
	return uintptr(1) << b
  0x4064f6		be01000000		MOVL $0x1, SI		
  0x4064fb		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x4064fe		488d4eff		LEAQ -0x1(SI), CX	
  0x406502		4889cb			MOVQ CX, BX		
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))
  0x406505		4821c1			ANDQ AX, CX		
  0x406508		488b742448		MOVQ 0x48(SP), SI	
  0x40650d		0fb77e54		MOVZX 0x54(SI), DI	
  0x406511		480fafcf		IMULQ DI, CX		
  0x406515		48034a10		ADDQ 0x10(DX), CX	
	if c := h.oldbuckets; c != nil {
  0x406519		4c8b4218		MOVQ 0x18(DX), R8	
  0x40651d		4d85c0			TESTQ R8, R8		
  0x406520		742d			JE 0x40654f		
	return h.flags&sameSizeGrow != 0
  0x406522		440fb64a08		MOVZX 0x8(DX), R9	
  0x406527		41f6c108		TESTL $0x8, R9		
		if !h.sameSizeGrow() {
  0x40652b		0f8428010000		JE 0x406659		
		oldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash&m)*uintptr(t.bucketsize)))
  0x406531		4821c3			ANDQ AX, BX		
  0x406534		480faffb		IMULQ BX, DI		
  0x406538		498d1c38		LEAQ 0(R8)(DI*1), BX	
	h := b.tophash[0]
  0x40653c		8403			TESTB AL, 0(BX)		
  0x40653e		410fb63c38		MOVZX 0(R8)(DI*1), DI	
	return h > empty && h < minTopHash
  0x406543		ffcf			DECL DI			
  0x406545		4080ff03		CMPL $0x3, DI		
		if !evacuated(oldb) {
  0x406549		0f8302010000		JAE 0x406651		
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40654f		48c1e838		SHRQ $0x38, AX		
	if top < minTopHash {
  0x406553		3c04			CMPL $0x4, AL		
  0x406555		7303			JAE 0x40655a		
		top += minTopHash
  0x406557		83c004			ADDL $0x4, AX		
  0x40655a		8844241f		MOVB AL, 0x1f(SP)	
	for ; b != nil; b = b.overflow(t) {
  0x40655e		e9c2000000		JMP 0x406625		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x406563		48ffc2			INCQ DX			
  0x406566		4883fa08		CMPQ $0x8, DX		
  0x40656a		0f83a9000000		JAE 0x406619		
			if b.tophash[i] != top {
  0x406570		0fb61c0a		MOVZX 0(DX)(CX*1), BX	
  0x406574		38d8			CMPL BL, AL		
  0x406576		75eb			JNE 0x406563		
  0x406578		4889542420		MOVQ DX, 0x20(SP)	
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
  0x40657d		0fb65e50		MOVZX 0x50(SI), BX	
  0x406581		480fafda		IMULQ DX, BX		
			if t.indirectkey {
  0x406585		0fb67e51		MOVZX 0x51(SI), DI	
	return unsafe.Pointer(uintptr(p) + x)
  0x406589		488d4c0b08		LEAQ 0x8(BX)(CX*1), CX	
			if t.indirectkey {
  0x40658e		4084ff			TESTL DI, DI		
  0x406591		7403			JE 0x406596		
				k = *((*unsafe.Pointer)(k))
  0x406593		488b09			MOVQ 0(CX), CX		
  0x406596		488b442428		MOVQ 0x28(SP), AX	
			if alg.equal(key, k) {
  0x40659b		488b5008		MOVQ 0x8(AX), DX	
  0x40659f		488b5c2458		MOVQ 0x58(SP), BX	
  0x4065a4		48891c24		MOVQ BX, 0(SP)		
  0x4065a8		48894c2408		MOVQ CX, 0x8(SP)	
  0x4065ad		488b0a			MOVQ 0(DX), CX		
  0x4065b0		ffd1			CALL CX			
  0x4065b2		0fb6442410		MOVZX 0x10(SP), AX	
  0x4065b7		84c0			TESTL AL, AL		
  0x4065b9		7516			JNE 0x4065d1		
  0x4065bb		0fb644241f		MOVZX 0x1f(SP), AX	
  0x4065c0		488b4c2430		MOVQ 0x30(SP), CX	
  0x4065c5		488b542420		MOVQ 0x20(SP), DX	
  0x4065ca		488b742448		MOVQ 0x48(SP), SI	
		for i := uintptr(0); i < bucketCnt; i++ {
  0x4065cf		eb92			JMP 0x406563		
  0x4065d1		488b442448		MOVQ 0x48(SP), AX	
				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x4065d6		0fb64850		MOVZX 0x50(AX), CX	
  0x4065da		0fb65052		MOVZX 0x52(AX), DX	
  0x4065de		488b5c2420		MOVQ 0x20(SP), BX	
  0x4065e3		480fafda		IMULQ DX, BX		
  0x4065e7		488d0ccb		LEAQ 0(BX)(CX*8), CX	
				if t.indirectvalue {
  0x4065eb		0fb64053		MOVZX 0x53(AX), AX	
  0x4065ef		488b542430		MOVQ 0x30(SP), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x4065f4		488d4c0a08		LEAQ 0x8(DX)(CX*1), CX	
				if t.indirectvalue {
  0x4065f9		84c0			TESTL AL, AL		
  0x4065fb		7417			JE 0x406614		
					v = *((*unsafe.Pointer)(v))
  0x4065fd		488b01			MOVQ 0(CX), AX		
				return v, true
  0x406600		4889442460		MOVQ AX, 0x60(SP)	
  0x406605		c644246801		MOVB $0x1, 0x68(SP)	
  0x40660a		488b6c2438		MOVQ 0x38(SP), BP	
  0x40660f		4883c440		ADDQ $0x40, SP		
  0x406613		c3			RET			
  0x406614		4889c8			MOVQ CX, AX		
				if t.indirectvalue {
  0x406617		ebe7			JMP 0x406600		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x406619		0fb75e54		MOVZX 0x54(SI), BX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40661d		488d5c19f8		LEAQ -0x8(CX)(BX*1), BX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x406622		488b0b			MOVQ 0(BX), CX		
	for ; b != nil; b = b.overflow(t) {
  0x406625		4885c9			TESTQ CX, CX		
  0x406628		740c			JE 0x406636		
  0x40662a		48894c2430		MOVQ CX, 0x30(SP)	
  0x40662f		31d2			XORL DX, DX		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x406631		e930ffffff		JMP 0x406566		
	return unsafe.Pointer(&zeroVal[0]), false
  0x406636		488d05c3dc0b00		LEAQ runtime.zeroVal(SB), AX	
  0x40663d		4889442460		MOVQ AX, 0x60(SP)		
  0x406642		c644246800		MOVB $0x0, 0x68(SP)		
  0x406647		488b6c2438		MOVQ 0x38(SP), BP		
  0x40664c		4883c440		ADDQ $0x40, SP			
  0x406650		c3			RET				
  0x406651		4889d9			MOVQ BX, CX			
			b = oldb
  0x406654		e9f6feffff		JMP 0x40654f		
			m >>= 1
  0x406659		48d1eb			SHRQ $0x1, BX		
  0x40665c		e9d0feffff		JMP 0x406531		
		return unsafe.Pointer(&zeroVal[0]), false
  0x406661		488d0598dc0b00		LEAQ runtime.zeroVal(SB), AX	
  0x406668		4889442460		MOVQ AX, 0x60(SP)		
  0x40666d		c644246800		MOVB $0x0, 0x68(SP)		
  0x406672		488b6c2438		MOVQ 0x38(SP), BP		
  0x406677		4883c440		ADDQ $0x40, SP			
  0x40667b		c3			RET				
		throw("concurrent map read and map write")
  0x40667c		488d0543630600		LEAQ 0x66343(IP), AX	
  0x406683		48890424		MOVQ AX, 0(SP)		
  0x406687		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x406690		e83bab0100		CALL runtime.throw(SB)	
  0x406695		0f0b			UD2			
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {
  0x406697		e8d4de0300		CALL runtime.morestack_noctxt(SB)	
  0x40669c		e9cffdffff		JMP runtime.mapaccess2(SB)		

TEXT runtime.mapassign(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
  0x4066b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4066b9		488d4424f8		LEAQ -0x8(SP), AX	
  0x4066be		483b4110		CMPQ 0x10(CX), AX	
  0x4066c2		0f8676050000		JBE 0x406c3e		
  0x4066c8		4881ec88000000		SUBQ $0x88, SP		
  0x4066cf		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x4066d7		488dac2480000000	LEAQ 0x80(SP), BP	
  0x4066df		488b842498000000	MOVQ 0x98(SP), AX	
	if h == nil {
  0x4066e7		4885c0			TESTQ AX, AX		
  0x4066ea		0f8430050000		JE 0x406c20		
	if h.flags&hashWriting != 0 {
  0x4066f0		0fb64808		MOVZX 0x8(AX), CX	
  0x4066f4		f6c104			TESTL $0x4, CL		
  0x4066f7		0f8508050000		JNE 0x406c05		
  0x4066fd		488b8c2490000000	MOVQ 0x90(SP), CX	
	alg := t.key.alg
  0x406705		488b5930		MOVQ 0x30(CX), BX	
  0x406709		488b5b18		MOVQ 0x18(BX), BX	
  0x40670d		48895c2460		MOVQ BX, 0x60(SP)	
	hash := alg.hash(key, uintptr(h.hash0))
  0x406712		488b13			MOVQ 0(BX), DX		
  0x406715		8b700c			MOVL 0xc(AX), SI	
  0x406718		4889742408		MOVQ SI, 0x8(SP)	
  0x40671d		488bb424a0000000	MOVQ 0xa0(SP), SI	
  0x406725		48893424		MOVQ SI, 0(SP)		
  0x406729		488b3a			MOVQ 0(DX), DI		
  0x40672c		ffd7			CALL DI			
  0x40672e		488b442410		MOVQ 0x10(SP), AX	
  0x406733		4889442430		MOVQ AX, 0x30(SP)	
  0x406738		488b8c2498000000	MOVQ 0x98(SP), CX	
	h.flags |= hashWriting
  0x406740		0fb65908		MOVZX 0x8(CX), BX	
  0x406744		83cb04			ORL $0x4, BX		
  0x406747		885908			MOVB BL, 0x8(CX)	
	if h.buckets == nil {
  0x40674a		488b5910		MOVQ 0x10(CX), BX	
  0x40674e		488d7110		LEAQ 0x10(CX), SI	
  0x406752		4885db			TESTQ BX, BX		
  0x406755		0f8519020000		JNE 0x406974		
  0x40675b		e92c040000		JMP 0x406b8c		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x406760		49ffc2			INCQ R10		
  0x406763		4983fa08		CMPQ $0x8, R10		
  0x406767		0f8382010000		JAE 0x4068ef		
			if b.tophash[i] != top {
  0x40676d		8403			TESTB AL, 0(BX)		
  0x40676f		460fb61c13		MOVZX 0(BX)(R10*1), R11	
  0x406774		4e8d2413		LEAQ 0(BX)(R10*1), R12	
  0x406778		4438d8			CMPL R11, AL		
  0x40677b		743b			JE 0x4067b8		
				if b.tophash[i] == empty && inserti == nil {
  0x40677d		4584db			TESTL R11, R11		
  0x406780		75de			JNE 0x406760		
  0x406782		4885c9			TESTQ CX, CX		
  0x406785		75d9			JNE 0x406760		
					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
  0x406787		440fb65e50		MOVZX 0x50(SI), R11	
  0x40678c		4d89d5			MOVQ R10, R13		
  0x40678f		4d0fafd3		IMULQ R11, R10		
					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x406793		440fb67652		MOVZX 0x52(SI), R14	
  0x406798		4d0faff5		IMULQ R13, R14		
  0x40679c		4f8d1cde		LEAQ 0(R14)(R11*8), R11	
  0x4067a0		4989de			MOVQ BX, R14		
	return unsafe.Pointer(uintptr(p) + x)
  0x4067a3		4d8d441a08		LEAQ 0x8(R10)(BX*1), R8	
  0x4067a8		4d8d4c1b08		LEAQ 0x8(R11)(BX*1), R9	
  0x4067ad		4c89f3			MOVQ R14, BX		
  0x4067b0		4d89ea			MOVQ R13, R10		
  0x4067b3		4c89e1			MOVQ R12, CX		
					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x4067b6		eba8			JMP 0x406760		
  0x4067b8		4c89542428		MOVQ R10, 0x28(SP)	
  0x4067bd		4c894c2440		MOVQ R9, 0x40(SP)	
  0x4067c2		4c89442450		MOVQ R8, 0x50(SP)	
  0x4067c7		48894c2458		MOVQ CX, 0x58(SP)	
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
  0x4067cc		440fb65e50		MOVZX 0x50(SI), R11	
  0x4067d1		4d0fafda		IMULQ R10, R11		
			if t.indirectkey {
  0x4067d5		440fb66651		MOVZX 0x51(SI), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x4067da		498d5c1b08		LEAQ 0x8(R11)(BX*1), BX	
			if t.indirectkey {
  0x4067df		4584e4			TESTL R12, R12		
  0x4067e2		7403			JE 0x4067e7		
				k = *((*unsafe.Pointer)(k))
  0x4067e4		488b1b			MOVQ 0(BX), BX		
  0x4067e7		48895c2448		MOVQ BX, 0x48(SP)	
  0x4067ec		488b442460		MOVQ 0x60(SP), AX	
			if !alg.equal(key, k) {
  0x4067f1		488b5008		MOVQ 0x8(AX), DX	
  0x4067f5		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x4067fd		48890c24		MOVQ CX, 0(SP)		
  0x406801		48895c2408		MOVQ BX, 0x8(SP)	
  0x406806		488b32			MOVQ 0(DX), SI		
  0x406809		ffd6			CALL SI			
  0x40680b		0fb6442410		MOVZX 0x10(SP), AX	
  0x406810		84c0			TESTL AL, AL		
  0x406812		7538			JNE 0x40684c		
  0x406814		0fb6442427		MOVZX 0x27(SP), AX	
  0x406819		488b942498000000	MOVQ 0x98(SP), DX	
  0x406821		488b5c2478		MOVQ 0x78(SP), BX	
  0x406826		488bb42490000000	MOVQ 0x90(SP), SI	
  0x40682e		488b7c2430		MOVQ 0x30(SP), DI	
  0x406833		4c8b542428		MOVQ 0x28(SP), R10	
  0x406838		488b4c2458		MOVQ 0x58(SP), CX	
  0x40683d		4c8b442450		MOVQ 0x50(SP), R8	
  0x406842		4c8b4c2440		MOVQ 0x40(SP), R9	
				continue
  0x406847		e914ffffff		JMP 0x406760		
  0x40684c		488b842490000000	MOVQ 0x90(SP), AX	
			if t.needkeyupdate {
  0x406854		0fb64857		MOVZX 0x57(AX), CX	
  0x406858		84c9			TESTL CL, CL		
  0x40685a		7562			JNE 0x4068be		
			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x40685c		0fb64850		MOVZX 0x50(AX), CX	
  0x406860		0fb65052		MOVZX 0x52(AX), DX	
  0x406864		488b5c2428		MOVQ 0x28(SP), BX	
  0x406869		480fafd3		IMULQ BX, DX		
  0x40686d		488d0cca		LEAQ 0(DX)(CX*8), CX	
  0x406871		488b542478		MOVQ 0x78(SP), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x406876		488d4c0a08		LEAQ 0x8(DX)(CX*1), CX	
			goto done
  0x40687b		488b942498000000	MOVQ 0x98(SP), DX	
	if h.flags&hashWriting == 0 {
  0x406883		0fb65a08		MOVZX 0x8(DX), BX	
  0x406887		f6c304			TESTL $0x4, BL		
  0x40688a		0f845a030000		JE 0x406bea		
	h.flags &^= hashWriting
  0x406890		83e3fb			ANDL $-0x5, BX		
  0x406893		885a08			MOVB BL, 0x8(DX)	
	if t.indirectvalue {
  0x406896		0fb64053		MOVZX 0x53(AX), AX	
  0x40689a		84c0			TESTL AL, AL		
  0x40689c		741b			JE 0x4068b9		
		val = *((*unsafe.Pointer)(val))
  0x40689e		488b01			MOVQ 0(CX), AX		
	return val
  0x4068a1		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x4068a9		488bac2480000000	MOVQ 0x80(SP), BP	
  0x4068b1		4881c488000000		ADDQ $0x88, SP		
  0x4068b8		c3			RET			
  0x4068b9		4889c8			MOVQ CX, AX		
	if t.indirectvalue {
  0x4068bc		ebe3			JMP 0x4068a1		
				typedmemmove(t.key, k, key)
  0x4068be		488b4830		MOVQ 0x30(AX), CX		
  0x4068c2		48890c24		MOVQ CX, 0(SP)			
  0x4068c6		488b4c2448		MOVQ 0x48(SP), CX		
  0x4068cb		48894c2408		MOVQ CX, 0x8(SP)		
  0x4068d0		488b8c24a0000000	MOVQ 0xa0(SP), CX		
  0x4068d8		48894c2410		MOVQ CX, 0x10(SP)		
  0x4068dd		e8ae510000		CALL runtime.typedmemmove(SB)	
  0x4068e2		488b842490000000	MOVQ 0x90(SP), AX		
  0x4068ea		e96dffffff		JMP 0x40685c			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x4068ef		440fb75654		MOVZX 0x54(SI), R10	
  0x4068f4		4989db			MOVQ BX, R11		
	return unsafe.Pointer(uintptr(p) + x)
  0x4068f7		4a8d5c13f8		LEAQ -0x8(BX)(R10*1), BX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x4068fc		488b1b			MOVQ 0(BX), BX		
		if ovf == nil {
  0x4068ff		4885db			TESTQ BX, BX		
  0x406902		740d			JE 0x406911		
  0x406904		48895c2478		MOVQ BX, 0x78(SP)	
  0x406909		4531d2			XORL R10, R10		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40690c		e952feffff		JMP 0x406763		
	return h.oldbuckets != nil
  0x406911		488b5a18		MOVQ 0x18(DX), BX	
  0x406915		4885db			TESTQ BX, BX		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x406918		0f852f020000		JNE 0x406b4d		
  0x40691e		488b1a			MOVQ 0(DX), BX		
  0x406921		48ffc3			INCQ BX			
  0x406924		440fb65209		MOVZX 0x9(DX), R10	
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x406929		4883fb08		CMPQ $0x8, BX		
  0x40692d		0f8e0d020000		JLE 0x406b40		
  0x406933		4989cc			MOVQ CX, R12		
  0x406936		4489d1			MOVL R10, CX		
	return uintptr(1) << b
  0x406939		41bd01000000		MOVL $0x1, R13		
  0x40693f		49d3e5			SHLQ CL, R13		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x406942		49d1ed			SHRQ $0x1, R13		
  0x406945		4f8d746d00		LEAQ 0(R13)(R13*2), R14	
  0x40694a		4f8d6cb500		LEAQ 0(R13)(R14*4), R13	
  0x40694f		4c39eb			CMPQ R13, BX		
  0x406952		0f97c3			SETA BL			
  0x406955		84db			TESTL BL, BL		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x406957		7473			JE 0x4069cc		
		hashGrow(t, h)
  0x406959		48893424		MOVQ SI, 0(SP)			
  0x40695d		4889542408		MOVQ DX, 0x8(SP)		
  0x406962		e8c9040000		CALL runtime.hashGrow(SB)	
  0x406967		488b442430		MOVQ 0x30(SP), AX		
  0x40696c		488b8c2498000000	MOVQ 0x98(SP), CX		
	bucket := hash & bucketMask(h.B)
  0x406974		0fb65909		MOVZX 0x9(CX), BX	
  0x406978		4889ca			MOVQ CX, DX		
  0x40697b		89d9			MOVL BX, CX		
	return uintptr(1) << b
  0x40697d		be01000000		MOVL $0x1, SI		
  0x406982		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x406985		488d5eff		LEAQ -0x1(SI), BX	
	bucket := hash & bucketMask(h.B)
  0x406989		4821c3			ANDQ AX, BX		
	return h.oldbuckets != nil
  0x40698c		488b7218		MOVQ 0x18(DX), SI	
  0x406990		4885f6			TESTQ SI, SI		
	if h.growing() {
  0x406993		0f85bc010000		JNE 0x406b55		
  0x406999		488bb42490000000	MOVQ 0x90(SP), SI	
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x4069a1		0fb77e54		MOVZX 0x54(SI), DI	
  0x4069a5		480fafdf		IMULQ DI, BX		
  0x4069a9		48035a10		ADDQ 0x10(DX), BX	
  0x4069ad		4889c7			MOVQ AX, DI		
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x4069b0		48c1e838		SHRQ $0x38, AX		
	if top < minTopHash {
  0x4069b4		3c04			CMPL $0x4, AL		
  0x4069b6		7303			JAE 0x4069bb		
		top += minTopHash
  0x4069b8		83c004			ADDL $0x4, AX		
  0x4069bb		88442427		MOVB AL, 0x27(SP)	
  0x4069bf		31c9			XORL CX, CX		
  0x4069c1		4531c0			XORL R8, R8		
  0x4069c4		4531c9			XORL R9, R9		
	for {
  0x4069c7		e938ffffff		JMP 0x406904		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x4069cc		0fb75a0a		MOVZX 0xa(DX), BX	
	if B > 15 {
  0x4069d0		80f90f			CMPL $0xf, CL		
  0x4069d3		7605			JBE 0x4069da		
  0x4069d5		b90f000000		MOVL $0xf, CX		
	return noverflow >= uint16(1)<<(B&15)
  0x4069da		83e10f			ANDL $0xf, CX		
  0x4069dd		41ba01000000		MOVL $0x1, R10		
  0x4069e3		41d3e2			SHLL CL, R10		
  0x4069e6		664439d3		CMPW R10, BX		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x4069ea		0f8369ffffff		JAE 0x406959		
	if inserti == nil {
  0x4069f0		4d85e4			TESTQ R12, R12		
  0x4069f3		0f8403010000		JE 0x406afc		
  0x4069f9		4c894c2440		MOVQ R9, 0x40(SP)	
  0x4069fe		4c89642458		MOVQ R12, 0x58(SP)	
	if t.indirectkey {
  0x406a03		0fb64e51		MOVZX 0x51(SI), CX	
  0x406a07		84c9			TESTL CL, CL		
  0x406a09		0f8594000000		JNE 0x406aa3		
	if t.indirectvalue {
  0x406a0f		0fb64e53		MOVZX 0x53(SI), CX	
  0x406a13		84c9			TESTL CL, CL		
  0x406a15		7548			JNE 0x406a5f		
	typedmemmove(t.key, insertk, key)
  0x406a17		488b4630		MOVQ 0x30(SI), AX		
  0x406a1b		48890424		MOVQ AX, 0(SP)			
  0x406a1f		4c89442408		MOVQ R8, 0x8(SP)		
  0x406a24		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x406a2c		4889442410		MOVQ AX, 0x10(SP)		
  0x406a31		e85a500000		CALL runtime.typedmemmove(SB)	
  0x406a36		0fb6442427		MOVZX 0x27(SP), AX		
  0x406a3b		488b4c2458		MOVQ 0x58(SP), CX		
	*inserti = top
  0x406a40		8801			MOVB AL, 0(CX)		
  0x406a42		488b842498000000	MOVQ 0x98(SP), AX	
	h.count++
  0x406a4a		48ff00			INCQ 0(AX)		
  0x406a4d		488b842490000000	MOVQ 0x90(SP), AX	
  0x406a55		488b4c2440		MOVQ 0x40(SP), CX	
done:
  0x406a5a		e91cfeffff		JMP 0x40687b		
  0x406a5f		4c89442450		MOVQ R8, 0x50(SP)	
		vmem := newobject(t.elem)
  0x406a64		488b4638		MOVQ 0x38(SI), AX		
  0x406a68		48890424		MOVQ AX, 0(SP)			
  0x406a6c		e8af460000		CALL runtime.newobject(SB)	
  0x406a71		488b7c2440		MOVQ 0x40(SP), DI		
		*(*unsafe.Pointer)(val) = vmem
  0x406a76		8407			TESTB AL, 0(DI)		
		vmem := newobject(t.elem)
  0x406a78		488b442408		MOVQ 0x8(SP), AX	
		*(*unsafe.Pointer)(val) = vmem
  0x406a7d		8b0d8dcf0b00		MOVL runtime.writeBarrier(SB), CX	
  0x406a83		85c9			TESTL CX, CX				
  0x406a85		7515			JNE 0x406a9c				
  0x406a87		488907			MOVQ AX, 0(DI)				
  0x406a8a		488bb42490000000	MOVQ 0x90(SP), SI			
  0x406a92		4c8b442450		MOVQ 0x50(SP), R8			
  0x406a97		e97bffffff		JMP 0x406a17				
  0x406a9c		e8fffd0300		CALL runtime.gcWriteBarrier(SB)		
  0x406aa1		ebe7			JMP 0x406a8a				
  0x406aa3		4c89442470		MOVQ R8, 0x70(SP)			
		kmem := newobject(t.key)
  0x406aa8		488b4630		MOVQ 0x30(SI), AX		
  0x406aac		48890424		MOVQ AX, 0(SP)			
  0x406ab0		e86b460000		CALL runtime.newobject(SB)	
  0x406ab5		488b7c2470		MOVQ 0x70(SP), DI		
		*(*unsafe.Pointer)(insertk) = kmem
  0x406aba		8407			TESTB AL, 0(DI)		
		kmem := newobject(t.key)
  0x406abc		488b442408		MOVQ 0x8(SP), AX	
		*(*unsafe.Pointer)(insertk) = kmem
  0x406ac1		8b0d49cf0b00		MOVL runtime.writeBarrier(SB), CX	
  0x406ac7		85c9			TESTL CX, CX				
  0x406ac9		752a			JNE 0x406af5				
  0x406acb		488907			MOVQ AX, 0(DI)				
  0x406ace		488b942498000000	MOVQ 0x98(SP), DX			
  0x406ad6		488bb42490000000	MOVQ 0x90(SP), SI			
  0x406ade		4c8b4c2440		MOVQ 0x40(SP), R9			
  0x406ae3		4c8b642458		MOVQ 0x58(SP), R12			
  0x406ae8		4989c0			MOVQ AX, R8				
  0x406aeb		0fb6442427		MOVZX 0x27(SP), AX			
		insertk = kmem
  0x406af0		e91affffff		JMP 0x406a0f		
		*(*unsafe.Pointer)(insertk) = kmem
  0x406af5		e8a6fd0300		CALL runtime.gcWriteBarrier(SB)	
  0x406afa		ebd2			JMP 0x406ace			
		newb := h.newoverflow(t, b)
  0x406afc		48891424		MOVQ DX, 0(SP)				
  0x406b00		4889742408		MOVQ SI, 0x8(SP)			
  0x406b05		4c895c2410		MOVQ R11, 0x10(SP)			
  0x406b0a		e881f4ffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x406b0f		4c8b642418		MOVQ 0x18(SP), R12			
		inserti = &newb.tophash[0]
  0x406b14		41840424		TESTB AL, 0(R12)	
  0x406b18		488bb42490000000	MOVQ 0x90(SP), SI	
		val = add(insertk, bucketCnt*uintptr(t.keysize))
  0x406b20		0fb64650		MOVZX 0x50(SI), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x406b24		4d8d442408		LEAQ 0x8(R12), R8	
  0x406b29		4d8d4cc408		LEAQ 0x8(R12)(AX*8), R9	
  0x406b2e		0fb6442427		MOVZX 0x27(SP), AX	
  0x406b33		488b942498000000	MOVQ 0x98(SP), DX	
		val = add(insertk, bucketCnt*uintptr(t.keysize))
  0x406b3b		e9b9feffff		JMP 0x4069f9		
  0x406b40		4989cc			MOVQ CX, R12		
  0x406b43		31db			XORL BX, BX		
  0x406b45		4489d1			MOVL R10, CX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x406b48		e908feffff		JMP 0x406955		
  0x406b4d		4989cc			MOVQ CX, R12		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x406b50		e99bfeffff		JMP 0x4069f0		
  0x406b55		48895c2438		MOVQ BX, 0x38(SP)	
  0x406b5a		488b842490000000	MOVQ 0x90(SP), AX	
		growWork(t, h, bucket)
  0x406b62		48890424		MOVQ AX, 0(SP)			
  0x406b66		4889542408		MOVQ DX, 0x8(SP)		
  0x406b6b		48895c2410		MOVQ BX, 0x10(SP)		
  0x406b70		e80b050000		CALL runtime.growWork(SB)	
  0x406b75		488b442430		MOVQ 0x30(SP), AX		
  0x406b7a		488b942498000000	MOVQ 0x98(SP), DX		
  0x406b82		488b5c2438		MOVQ 0x38(SP), BX		
  0x406b87		e90dfeffff		JMP 0x406999			
  0x406b8c		4889742468		MOVQ SI, 0x68(SP)		
  0x406b91		488b842490000000	MOVQ 0x90(SP), AX		
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x406b99		488b4840		MOVQ 0x40(AX), CX			
  0x406b9d		48890c24		MOVQ CX, 0(SP)				
  0x406ba1		e87a450000		CALL runtime.newobject(SB)		
  0x406ba6		8b0564ce0b00		MOVL runtime.writeBarrier(SB), AX	
  0x406bac		488b4c2408		MOVQ 0x8(SP), CX			
  0x406bb1		85c0			TESTL AX, AX				
  0x406bb3		751e			JNE 0x406bd3				
  0x406bb5		488b842498000000	MOVQ 0x98(SP), AX			
  0x406bbd		48894810		MOVQ CX, 0x10(AX)			
  0x406bc1		488b442430		MOVQ 0x30(SP), AX			
  0x406bc6		488b8c2498000000	MOVQ 0x98(SP), CX			
  0x406bce		e9a1fdffff		JMP 0x406974				
  0x406bd3		488b7c2468		MOVQ 0x68(SP), DI			
  0x406bd8		4889c8			MOVQ CX, AX				
  0x406bdb		e8c0fc0300		CALL runtime.gcWriteBarrier(SB)		
  0x406be0		488b842498000000	MOVQ 0x98(SP), AX			
  0x406be8		ebd7			JMP 0x406bc1				
		throw("concurrent map writes")
  0x406bea		488d0598460600		LEAQ 0x64698(IP), AX	
  0x406bf1		48890424		MOVQ AX, 0(SP)		
  0x406bf5		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x406bfe		e8cda50100		CALL runtime.throw(SB)	
  0x406c03		0f0b			UD2			
		throw("concurrent map writes")
  0x406c05		488d057d460600		LEAQ 0x6467d(IP), AX	
  0x406c0c		48890424		MOVQ AX, 0(SP)		
  0x406c10		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x406c19		e8b2a50100		CALL runtime.throw(SB)	
  0x406c1e		0f0b			UD2			
		panic(plainError("assignment to entry in nil map"))
  0x406c20		488d0519440500		LEAQ 0x54419(IP), AX			
  0x406c27		48890424		MOVQ AX, 0(SP)				
  0x406c2b		488d051ee10600		LEAQ runtime.statictmp_10(SB), AX	
  0x406c32		4889442408		MOVQ AX, 0x8(SP)			
  0x406c37		e8f49d0100		CALL runtime.gopanic(SB)		
  0x406c3c		0f0b			UD2					
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
  0x406c3e		e82dd90300		CALL runtime.morestack_noctxt(SB)	
  0x406c43		e968faffff		JMP runtime.mapassign(SB)		

TEXT runtime.makeBucketArray(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func makeBucketArray(t *maptype, b uint8) (buckets unsafe.Pointer, nextOverflow *bmap) {
  0x406c50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x406c59		483b6110		CMPQ 0x10(CX), SP	
  0x406c5d		0f86bc010000		JBE 0x406e1f		
  0x406c63		4883ec30		SUBQ $0x30, SP		
  0x406c67		48896c2428		MOVQ BP, 0x28(SP)	
  0x406c6c		488d6c2428		LEAQ 0x28(SP), BP	
  0x406c71		0fb64c2440		MOVZX 0x40(SP), CX	
	return uintptr(1) << b
  0x406c76		ba01000000		MOVL $0x1, DX		
  0x406c7b		48d3e2			SHLQ CL, DX		
  0x406c7e		4889542420		MOVQ DX, 0x20(SP)	
	if b >= 4 {
  0x406c83		80f904			CMPL $0x4, CL		
  0x406c86		0f8271010000		JB 0x406dfd		
  0x406c8c		488b5c2438		MOVQ 0x38(SP), BX	
		sz := t.bucket.size * nbuckets
  0x406c91		488b7340		MOVQ 0x40(BX), SI	
		nbuckets += bucketShift(b - 4)
  0x406c95		83c1fc			ADDL $-0x4, CX		
	return uintptr(1) << b
  0x406c98		bf01000000		MOVL $0x1, DI		
  0x406c9d		48d3e7			SHLQ CL, DI		
		nbuckets += bucketShift(b - 4)
  0x406ca0		4801d7			ADDQ DX, DI		
		sz := t.bucket.size * nbuckets
  0x406ca3		488b36			MOVQ 0(SI), SI		
  0x406ca6		4989f0			MOVQ SI, R8		
  0x406ca9		480faff7		IMULQ DI, SI		
	if size < _MaxSmallSize {
  0x406cad		4881fe00800000		CMPQ $0x8000, SI	
  0x406cb4		0f831c010000		JAE 0x406dd6		
		if size <= smallSizeMax-8 {
  0x406cba		4881fef8030000		CMPQ $0x3f8, SI		
  0x406cc1		0f87d8000000		JA 0x406d9f		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x406cc7		488d4e07		LEAQ 0x7(SI), CX			
  0x406ccb		48c1e903		SHRQ $0x3, CX				
  0x406ccf		4881f981000000		CMPQ $0x81, CX				
  0x406cd6		0f833c010000		JAE 0x406e18				
  0x406cdc		4c8d0d3de40900		LEAQ runtime.size_to_class8(SB), R9	
  0x406ce3		420fb60c09		MOVZX 0(CX)(R9*1), CX			
  0x406ce8		4883f943		CMPQ $0x43, CX				
  0x406cec		0f8326010000		JAE 0x406e18				
  0x406cf2		4c8d0dc7e40900		LEAQ runtime.class_to_size(SB), R9	
  0x406cf9		410fb70c49		MOVZX 0(R9)(CX*2), CX			
		if up != sz {
  0x406cfe		4839f1			CMPQ SI, CX		
  0x406d01		0f848d000000		JE 0x406d94		
			nbuckets = up / t.bucket.size
  0x406d07		4d85c0			TESTQ R8, R8		
  0x406d0a		0f84fa000000		JE 0x406e0a		
  0x406d10		4889c8			MOVQ CX, AX		
  0x406d13		4889d1			MOVQ DX, CX		
  0x406d16		31d2			XORL DX, DX		
  0x406d18		49f7f0			DIVQ R8			
  0x406d1b		4889442418		MOVQ AX, 0x18(SP)	
	buckets = newarray(t.bucket, int(nbuckets))
  0x406d20		488b4b40		MOVQ 0x40(BX), CX		
  0x406d24		48890c24		MOVQ CX, 0(SP)			
  0x406d28		4889442408		MOVQ AX, 0x8(SP)		
  0x406d2d		e84e440000		CALL runtime.newarray(SB)	
  0x406d32		488b442410		MOVQ 0x10(SP), AX		
  0x406d37		488b4c2418		MOVQ 0x18(SP), CX		
  0x406d3c		488b542420		MOVQ 0x20(SP), DX		
	if base != nbuckets {
  0x406d41		4839d1			CMPQ DX, CX		
  0x406d44		744a			JE 0x406d90		
  0x406d46		488b5c2438		MOVQ 0x38(SP), BX	
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
  0x406d4b		0fb75b54		MOVZX 0x54(BX), BX	
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
  0x406d4f		48ffc9			DECQ CX			
  0x406d52		480fafcb		IMULQ BX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x406d56		4801c1			ADDQ AX, CX		
  0x406d59		488d7c19f8		LEAQ -0x8(CX)(BX*1), DI	
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x406d5e		8407			TESTB AL, 0(DI)		
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
  0x406d60		480fafda		IMULQ DX, BX		
	return unsafe.Pointer(uintptr(p) + x)
  0x406d64		488d0c03		LEAQ 0(BX)(AX*1), CX	
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x406d68		8b15a2cc0b00		MOVL runtime.writeBarrier(SB), DX	
  0x406d6e		85d2			TESTL DX, DX				
  0x406d70		7517			JNE 0x406d89				
  0x406d72		488907			MOVQ AX, 0(DI)				
	return buckets, nextOverflow
  0x406d75		4889442448		MOVQ AX, 0x48(SP)	
  0x406d7a		48894c2450		MOVQ CX, 0x50(SP)	
  0x406d7f		488b6c2428		MOVQ 0x28(SP), BP	
  0x406d84		4883c430		ADDQ $0x30, SP		
  0x406d88		c3			RET			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x406d89		e812fb0300		CALL runtime.gcWriteBarrier(SB)	
  0x406d8e		ebe5			JMP 0x406d75			
  0x406d90		31c9			XORL CX, CX			
	if base != nbuckets {
  0x406d92		ebe1			JMP 0x406d75		
  0x406d94		4889d1			MOVQ DX, CX		
  0x406d97		4889f8			MOVQ DI, AX		
		if up != sz {
  0x406d9a		e97cffffff		JMP 0x406d1b		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x406d9f		488d8e7ffcffff		LEAQ 0xfffffc7f(SI), CX			
  0x406da6		48c1e907		SHRQ $0x7, CX				
  0x406daa		4881f9f9000000		CMPQ $0xf9, CX				
  0x406db1		735e			JAE 0x406e11				
  0x406db3		4c8d0da6e40900		LEAQ runtime.size_to_class128(SB), R9	
  0x406dba		420fb60c09		MOVZX 0(CX)(R9*1), CX			
  0x406dbf		4883f943		CMPQ $0x43, CX				
  0x406dc3		734c			JAE 0x406e11				
  0x406dc5		4c8d0df4e30900		LEAQ runtime.class_to_size(SB), R9	
  0x406dcc		410fb70c49		MOVZX 0(R9)(CX*2), CX			
		up := roundupsize(sz)
  0x406dd1		e928ffffff		JMP 0x406cfe		
	if size+_PageSize < size {
  0x406dd6		488d8e00200000		LEAQ 0x2000(SI), CX	
  0x406ddd		4839f1			CMPQ SI, CX		
  0x406de0		7308			JAE 0x406dea		
  0x406de2		4889f1			MOVQ SI, CX		
		up := roundupsize(sz)
  0x406de5		e914ffffff		JMP 0x406cfe		
	return (n + a - 1) &^ (a - 1)
  0x406dea		488d8eff1f0000		LEAQ 0x1fff(SI), CX	
  0x406df1		4881e100e0ffff		ANDQ $-0x2000, CX	
		up := roundupsize(sz)
  0x406df8		e901ffffff		JMP 0x406cfe		
  0x406dfd		488b5c2438		MOVQ 0x38(SP), BX	
  0x406e02		4889d0			MOVQ DX, AX		
	if b >= 4 {
  0x406e05		e911ffffff		JMP 0x406d1b		
			nbuckets = up / t.bucket.size
  0x406e0a		e8118d0100		CALL runtime.panicdivide(SB)	
  0x406e0f		0f0b			UD2				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x406e11		e82a8c0100		CALL runtime.panicindex(SB)	
  0x406e16		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x406e18		e8238c0100		CALL runtime.panicindex(SB)	
  0x406e1d		0f0b			UD2				
func makeBucketArray(t *maptype, b uint8) (buckets unsafe.Pointer, nextOverflow *bmap) {
  0x406e1f		e84cd70300		CALL runtime.morestack_noctxt(SB)	
  0x406e24		e927feffff		JMP runtime.makeBucketArray(SB)		

TEXT runtime.hashGrow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func hashGrow(t *maptype, h *hmap) {
  0x406e30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x406e39		483b6110		CMPQ 0x10(CX), SP	
  0x406e3d		0f862a020000		JBE 0x40706d		
  0x406e43		4883ec48		SUBQ $0x48, SP		
  0x406e47		48896c2440		MOVQ BP, 0x40(SP)	
  0x406e4c		488d6c2440		LEAQ 0x40(SP), BP	
  0x406e51		488b442458		MOVQ 0x58(SP), AX	
	if !overLoadFactor(h.count+1, h.B) {
  0x406e56		488b10			MOVQ 0(AX), DX		
  0x406e59		48ffc2			INCQ DX			
  0x406e5c		0fb64809		MOVZX 0x9(AX), CX	
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x406e60		4883fa08		CMPQ $0x8, DX		
  0x406e64		0f8ee1010000		JLE 0x40704b		
	return uintptr(1) << b
  0x406e6a		bb01000000		MOVL $0x1, BX		
  0x406e6f		48d3e3			SHLQ CL, BX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x406e72		48d1eb			SHRQ $0x1, BX		
  0x406e75		488d345b		LEAQ 0(BX)(BX*2), SI	
  0x406e79		488d1cb3		LEAQ 0(BX)(SI*4), BX	
  0x406e7d		4839da			CMPQ BX, DX		
  0x406e80		0f97c2			SETA DL			
  0x406e83		84d2			TESTL DL, DL		
	if !overLoadFactor(h.count+1, h.B) {
  0x406e85		0f84b1010000		JE 0x40703c		
  0x406e8b		88542427		MOVB DL, 0x27(SP)	
	oldbuckets := h.buckets
  0x406e8f		488b4810		MOVQ 0x10(AX), CX	
  0x406e93		48894c2428		MOVQ CX, 0x28(SP)	
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)
  0x406e98		0fb65809		MOVZX 0x9(AX), BX			
  0x406e9c		01d3			ADDL DX, BX				
  0x406e9e		885c2408		MOVB BL, 0x8(SP)			
  0x406ea2		488b5c2450		MOVQ 0x50(SP), BX			
  0x406ea7		48891c24		MOVQ BX, 0(SP)				
  0x406eab		e8a0fdffff		CALL runtime.makeBucketArray(SB)	
  0x406eb0		488b442458		MOVQ 0x58(SP), AX			
	oldbuckets := h.buckets
  0x406eb5		488d4810		LEAQ 0x10(AX), CX	
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)
  0x406eb9		488b542410		MOVQ 0x10(SP), DX	
  0x406ebe		488b5c2418		MOVQ 0x18(SP), BX	
	flags := h.flags &^ (iterator | oldIterator)
  0x406ec3		0fb67008		MOVZX 0x8(AX), SI	
  0x406ec7		89f7			MOVL SI, DI		
  0x406ec9		83e6fc			ANDL $-0x4, SI		
	if h.flags&iterator != 0 {
  0x406ecc		40f6c701		TESTL $0x1, DI		
  0x406ed0		7403			JE 0x406ed5		
		flags |= oldIterator
  0x406ed2		83ce02			ORL $0x2, SI		
	h.B += bigger
  0x406ed5		440fb64009		MOVZX 0x9(AX), R8	
  0x406eda		440fb64c2427		MOVZX 0x27(SP), R9	
  0x406ee0		4501c8			ADDL R9, R8		
  0x406ee3		44884009		MOVB R8, 0x9(AX)	
	h.flags = flags
  0x406ee7		40887008		MOVB SI, 0x8(AX)	
	h.oldbuckets = oldbuckets
  0x406eeb		8b351fcb0b00		MOVL runtime.writeBarrier(SB), SI	
  0x406ef1		488d7818		LEAQ 0x18(AX), DI			
  0x406ef5		85f6			TESTL SI, SI				
  0x406ef7		0f851f010000		JNE 0x40701c				
  0x406efd		488b4c2428		MOVQ 0x28(SP), CX			
  0x406f02		48894818		MOVQ CX, 0x18(AX)			
	h.buckets = newbuckets
  0x406f06		48895010		MOVQ DX, 0x10(AX)	
	h.nevacuate = 0
  0x406f0a		48c7402000000000	MOVQ $0x0, 0x20(AX)	
	h.noverflow = 0
  0x406f12		66c7400a0000		MOVW $0x0, 0xa(AX)	
	if h.extra != nil && h.extra.overflow != nil {
  0x406f18		488b4828		MOVQ 0x28(AX), CX	
  0x406f1c		488d5028		LEAQ 0x28(AX), DX	
  0x406f20		4885c9			TESTQ CX, CX		
  0x406f23		7448			JE 0x406f6d		
  0x406f25		488b31			MOVQ 0(CX), SI		
  0x406f28		4885f6			TESTQ SI, SI		
  0x406f2b		7440			JE 0x406f6d		
		if h.extra.oldoverflow != nil {
  0x406f2d		4c8b4108		MOVQ 0x8(CX), R8	
  0x406f31		488d7908		LEAQ 0x8(CX), DI	
  0x406f35		4d85c0			TESTQ R8, R8		
  0x406f38		0f8514010000		JNE 0x407052		
		h.extra.oldoverflow = h.extra.overflow
  0x406f3e		448b05cbca0b00		MOVL runtime.writeBarrier(SB), R8	
  0x406f45		4585c0			TESTL R8, R8				
  0x406f48		0f85bb000000		JNE 0x407009				
  0x406f4e		48897108		MOVQ SI, 0x8(CX)			
		h.extra.overflow = nil
  0x406f52		488b7828		MOVQ 0x28(AX), DI			
  0x406f56		8407			TESTB AL, 0(DI)				
  0x406f58		8b0db2ca0b00		MOVL runtime.writeBarrier(SB), CX	
  0x406f5e		85c9			TESTL CX, CX				
  0x406f60		0f8591000000		JNE 0x406ff7				
  0x406f66		48c70700000000		MOVQ $0x0, 0(DI)			
	if nextOverflow != nil {
  0x406f6d		4885db			TESTQ BX, BX		
  0x406f70		7421			JE 0x406f93		
		if h.extra == nil {
  0x406f72		488b4828		MOVQ 0x28(AX), CX	
  0x406f76		4885c9			TESTQ CX, CX		
  0x406f79		742c			JE 0x406fa7		
		h.extra.nextOverflow = nextOverflow
  0x406f7b		488b4828		MOVQ 0x28(AX), CX			
  0x406f7f		8401			TESTB AL, 0(CX)				
  0x406f81		8b1589ca0b00		MOVL runtime.writeBarrier(SB), DX	
  0x406f87		488d7910		LEAQ 0x10(CX), DI			
  0x406f8b		85d2			TESTL DX, DX				
  0x406f8d		750e			JNE 0x406f9d				
  0x406f8f		48895910		MOVQ BX, 0x10(CX)			
  0x406f93		488b6c2440		MOVQ 0x40(SP), BP			
  0x406f98		4883c448		ADDQ $0x48, SP				
  0x406f9c		c3			RET					
  0x406f9d		4889d8			MOVQ BX, AX				
  0x406fa0		e8fbf80300		CALL runtime.gcWriteBarrier(SB)		
  0x406fa5		ebec			JMP 0x406f93				
  0x406fa7		48895c2430		MOVQ BX, 0x30(SP)			
  0x406fac		4889542438		MOVQ DX, 0x38(SP)			
			h.extra = new(mapextra)
  0x406fb1		488d05088f0500		LEAQ 0x58f08(IP), AX			
  0x406fb8		48890424		MOVQ AX, 0(SP)				
  0x406fbc		e85f410000		CALL runtime.newobject(SB)		
  0x406fc1		8b0549ca0b00		MOVL runtime.writeBarrier(SB), AX	
  0x406fc7		488b4c2408		MOVQ 0x8(SP), CX			
  0x406fcc		85c0			TESTL AX, AX				
  0x406fce		7513			JNE 0x406fe3				
  0x406fd0		488b542458		MOVQ 0x58(SP), DX			
  0x406fd5		48894a28		MOVQ CX, 0x28(DX)			
  0x406fd9		4889d0			MOVQ DX, AX				
  0x406fdc		488b5c2430		MOVQ 0x30(SP), BX			
  0x406fe1		eb98			JMP 0x406f7b				
  0x406fe3		488b7c2438		MOVQ 0x38(SP), DI			
  0x406fe8		4889c8			MOVQ CX, AX				
  0x406feb		e8b0f80300		CALL runtime.gcWriteBarrier(SB)		
  0x406ff0		488b542458		MOVQ 0x58(SP), DX			
  0x406ff5		ebe2			JMP 0x406fd9				
  0x406ff7		4889c1			MOVQ AX, CX				
		h.extra.overflow = nil
  0x406ffa		31c0			XORL AX, AX			
  0x406ffc		e89ff80300		CALL runtime.gcWriteBarrier(SB)	
  0x407001		4889c8			MOVQ CX, AX			
  0x407004		e964ffffff		JMP 0x406f6d			
  0x407009		4889c1			MOVQ AX, CX			
  0x40700c		4889f0			MOVQ SI, AX			
		h.extra.oldoverflow = h.extra.overflow
  0x40700f		e88cf80300		CALL runtime.gcWriteBarrier(SB)	
  0x407014		4889c8			MOVQ CX, AX			
  0x407017		e936ffffff		JMP 0x406f52			
  0x40701c		4889c6			MOVQ AX, SI			
  0x40701f		488b442428		MOVQ 0x28(SP), AX		
	h.oldbuckets = oldbuckets
  0x407024		e877f80300		CALL runtime.gcWriteBarrier(SB)	
  0x407029		4889cf			MOVQ CX, DI			
  0x40702c		4889d0			MOVQ DX, AX			
	h.buckets = newbuckets
  0x40702f		e86cf80300		CALL runtime.gcWriteBarrier(SB)	
  0x407034		4889f0			MOVQ SI, AX			
	h.oldbuckets = oldbuckets
  0x407037		e9cefeffff		JMP 0x406f0a		
		h.flags |= sameSizeGrow
  0x40703c		0fb64808		MOVZX 0x8(AX), CX	
  0x407040		83c908			ORL $0x8, CX		
  0x407043		884808			MOVB CL, 0x8(AX)	
  0x407046		e940feffff		JMP 0x406e8b		
  0x40704b		31d2			XORL DX, DX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40704d		e931feffff		JMP 0x406e83		
			throw("oldoverflow is not nil")
  0x407052		488d0533440600		LEAQ 0x64433(IP), AX	
  0x407059		48890424		MOVQ AX, 0(SP)		
  0x40705d		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x407066		e865a10100		CALL runtime.throw(SB)	
  0x40706b		0f0b			UD2			
func hashGrow(t *maptype, h *hmap) {
  0x40706d		e8fed40300		CALL runtime.morestack_noctxt(SB)	
  0x407072		e9b9fdffff		JMP runtime.hashGrow(SB)		

TEXT runtime.growWork(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func growWork(t *maptype, h *hmap, bucket uintptr) {
  0x407080		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407089		483b6110		CMPQ 0x10(CX), SP	
  0x40708d		0f8688000000		JBE 0x40711b		
  0x407093		4883ec20		SUBQ $0x20, SP		
  0x407097		48896c2418		MOVQ BP, 0x18(SP)	
  0x40709c		488d6c2418		LEAQ 0x18(SP), BP	
  0x4070a1		488b442430		MOVQ 0x30(SP), AX	
	oldB := h.B
  0x4070a6		0fb65009		MOVZX 0x9(AX), DX	
	return h.flags&sameSizeGrow != 0
  0x4070aa		0fb65808		MOVZX 0x8(AX), BX	
  0x4070ae		f6c308			TESTL $0x8, BL		
	if !h.sameSizeGrow() {
  0x4070b1		7464			JE 0x407117		
  0x4070b3		488b5c2428		MOVQ 0x28(SP), BX	
	evacuate(t, h, bucket&h.oldbucketmask())
  0x4070b8		48891c24		MOVQ BX, 0(SP)		
  0x4070bc		4889442408		MOVQ AX, 0x8(SP)	
  0x4070c1		89d1			MOVL DX, CX		
	return uintptr(1) << b
  0x4070c3		be01000000		MOVL $0x1, SI		
  0x4070c8		48d3e6			SHLQ CL, SI		
	return h.noldbuckets() - 1
  0x4070cb		488d56ff		LEAQ -0x1(SI), DX	
  0x4070cf		488b742438		MOVQ 0x38(SP), SI	
	evacuate(t, h, bucket&h.oldbucketmask())
  0x4070d4		4821d6			ANDQ DX, SI			
  0x4070d7		4889742410		MOVQ SI, 0x10(SP)		
  0x4070dc		e84f000000		CALL runtime.evacuate(SB)	
  0x4070e1		488b442430		MOVQ 0x30(SP), AX		
	return h.oldbuckets != nil
  0x4070e6		488b5018		MOVQ 0x18(AX), DX	
  0x4070ea		4885d2			TESTQ DX, DX		
	if h.growing() {
  0x4070ed		750a			JNE 0x4070f9		
  0x4070ef		488b6c2418		MOVQ 0x18(SP), BP	
  0x4070f4		4883c420		ADDQ $0x20, SP		
  0x4070f8		c3			RET			
		evacuate(t, h, h.nevacuate)
  0x4070f9		488b4820		MOVQ 0x20(AX), CX		
  0x4070fd		48894c2410		MOVQ CX, 0x10(SP)		
  0x407102		488b4c2428		MOVQ 0x28(SP), CX		
  0x407107		48890c24		MOVQ CX, 0(SP)			
  0x40710b		4889442408		MOVQ AX, 0x8(SP)		
  0x407110		e81b000000		CALL runtime.evacuate(SB)	
  0x407115		ebd8			JMP 0x4070ef			
		oldB--
  0x407117		ffca			DECL DX			
  0x407119		eb98			JMP 0x4070b3		
func growWork(t *maptype, h *hmap, bucket uintptr) {
  0x40711b		e850d40300		CALL runtime.morestack_noctxt(SB)	
  0x407120		e95bffffff		JMP runtime.growWork(SB)		

TEXT runtime.evacuate(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
  0x407130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407139		488d4424d0		LEAQ -0x30(SP), AX	
  0x40713e		483b4110		CMPQ 0x10(CX), AX	
  0x407142		0f861e060000		JBE 0x407766		
  0x407148		4881ecb0000000		SUBQ $0xb0, SP		
  0x40714f		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x407157		488dac24a8000000	LEAQ 0xa8(SP), BP	
  0x40715f		0f57c0			XORPS X0, X0		
  0x407162		0f11442468		MOVUPS X0, 0x68(SP)	
  0x407167		0f11442478		MOVUPS X0, 0x78(SP)	
  0x40716c		0f11842488000000	MOVUPS X0, 0x88(SP)	
  0x407174		0f11842498000000	MOVUPS X0, 0x98(SP)	
  0x40717c		488b9c24c0000000	MOVQ 0xc0(SP), BX	
	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
  0x407184		488d7318		LEAQ 0x18(BX), SI	
  0x407188		4c8b8424b8000000	MOVQ 0xb8(SP), R8	
  0x407190		450fb74854		MOVZX 0x54(R8), R9	
  0x407195		4c8b9424c8000000	MOVQ 0xc8(SP), R10	
  0x40719d		4d0fafca		IMULQ R10, R9		
	return unsafe.Pointer(uintptr(p) + x)
  0x4071a1		4c030e			ADDQ 0(SI), R9		
	oldB := h.B
  0x4071a4		0fb67309		MOVZX 0x9(BX), SI	
	return h.flags&sameSizeGrow != 0
  0x4071a8		440fb65b08		MOVZX 0x8(BX), R11	
  0x4071ad		41f6c308		TESTL $0x8, R11		
	if !h.sameSizeGrow() {
  0x4071b1		0f8486050000		JE 0x40773d		
  0x4071b7		89f1			MOVL SI, CX		
	return uintptr(1) << b
  0x4071b9		41bb01000000		MOVL $0x1, R11		
  0x4071bf		49d3e3			SHLQ CL, R11		
	h := b.tophash[0]
  0x4071c2		450fb621		MOVZX 0(R9), R12	
	return h > empty && h < minTopHash
  0x4071c6		41ffcc			DECL R12		
  0x4071c9		4180fc03		CMPL $0x3, R12		
	if !evacuated(b) {
  0x4071cd		0f82af040000		JB 0x407682		
		var xy [2]evacDst
  0x4071d3		0f57c0			XORPS X0, X0		
  0x4071d6		0f11442468		MOVUPS X0, 0x68(SP)	
  0x4071db		0f11442478		MOVUPS X0, 0x78(SP)	
  0x4071e0		0f11842488000000	MOVUPS X0, 0x88(SP)	
  0x4071e8		0f11842498000000	MOVUPS X0, 0x98(SP)	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x4071f0		4c8d642468		LEAQ 0x68(SP), R12	
  0x4071f5		41840424		TESTB AL, 0(R12)	
  0x4071f9		450fb76054		MOVZX 0x54(R8), R12	
  0x4071fe		4d0fafe2		IMULQ R10, R12		
	return unsafe.Pointer(uintptr(p) + x)
  0x407202		4c036310		ADDQ 0x10(BX), R12	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x407206		4c89642468		MOVQ R12, 0x68(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x40720b		4d8d6c2408		LEAQ 0x8(R12), R13	
		x.k = add(unsafe.Pointer(x.b), dataOffset)
  0x407210		4c896c2478		MOVQ R13, 0x78(SP)	
		x.v = add(x.k, bucketCnt*uintptr(t.keysize))
  0x407215		450fb66850		MOVZX 0x50(R8), R13	
	return unsafe.Pointer(uintptr(p) + x)
  0x40721a		4f8d64ec08		LEAQ 0x8(R12)(R13*8), R12	
		x.v = add(x.k, bucketCnt*uintptr(t.keysize))
  0x40721f		4c89a42480000000	MOVQ R12, 0x80(SP)	
	return h.flags&sameSizeGrow != 0
  0x407227		440fb66308		MOVZX 0x8(BX), R12	
  0x40722c		41f6c408		TESTL $0x8, R12		
		if !h.sameSizeGrow() {
  0x407230		0f84bf040000		JE 0x4076f5		
  0x407236		884c2427		MOVB CL, 0x27(SP)	
  0x40723a		4c895c2440		MOVQ R11, 0x40(SP)	
		for ; b != nil; b = b.overflow(t) {
  0x40723f		e90b040000		JMP 0x40764f		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x407244		48ffc0			INCQ AX			
  0x407247		450fb67050		MOVZX 0x50(R8), R14	
  0x40724c		450fb67852		MOVZX 0x52(R8), R15	
	return unsafe.Pointer(uintptr(p) + x)
  0x407251		4d01f5			ADDQ R14, R13		
  0x407254		4d01fc			ADDQ R15, R12		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x407257		4883f808		CMPQ $0x8, AX		
  0x40725b		0f8de0030000		JGE 0x407641		
				top := b.tophash[i]
  0x407261		450fb63401		MOVZX 0(R9)(AX*1), R14	
				if top == empty {
  0x407266		4584f6			TESTL R14, R14		
  0x407269		7507			JNE 0x407272		
					b.tophash[i] = evacuatedEmpty
  0x40726b		41c6040101		MOVB $0x1, 0(R9)(AX*1)	
					continue
  0x407270		ebd2			JMP 0x407244		
				if top < minTopHash {
  0x407272		4180fe04		CMPL $0x4, R14		
  0x407276		0f82cf040000		JB 0x40774b		
				if t.indirectkey {
  0x40727c		450fb67851		MOVZX 0x51(R8), R15	
  0x407281		4584ff			TESTL R15, R15		
  0x407284		0f84af030000		JE 0x407639		
					k2 = *((*unsafe.Pointer)(k2))
  0x40728a		4d8b7d00		MOVQ 0(R13), R15	
  0x40728e		4889442428		MOVQ AX, 0x28(SP)	
  0x407293		4c89642450		MOVQ R12, 0x50(SP)	
  0x407298		4c897c2458		MOVQ R15, 0x58(SP)	
  0x40729d		4c896c2448		MOVQ R13, 0x48(SP)	
  0x4072a2		4c89da			MOVQ R11, DX		
	return h.flags&sameSizeGrow != 0
  0x4072a5		440fb65b08		MOVZX 0x8(BX), R11	
  0x4072aa		41f6c308		TESTL $0x8, R11		
				if !h.sameSizeGrow() {
  0x4072ae		0f8459020000		JE 0x40750d		
  0x4072b4		31ff			XORL DI, DI		
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY
  0x4072b6		448d5f02		LEAL 0x2(DI), R11	
  0x4072ba		45881c01		MOVB R11, 0(R9)(AX*1)	
				dst := &xy[useY]                 // evacuation destination
  0x4072be		440fb6df		MOVZX DI, R11		
  0x4072c2		4983fb02		CMPQ $0x2, R11		
  0x4072c6		0f8378040000		JAE 0x407744		
  0x4072cc		49c1e305		SHLQ $0x5, R11		
  0x4072d0		4c895c2438		MOVQ R11, 0x38(SP)	
				if dst.i == bucketCnt {
  0x4072d5		4a8b4c1c70		MOVQ 0x70(SP)(R11*1), CX	
  0x4072da		4883f908		CMPQ $0x8, CX			
  0x4072de		0f848e010000		JE 0x407472			
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x4072e4		4a8b4c1c68		MOVQ 0x68(SP)(R11*1), CX	
  0x4072e9		8401			TESTB AL, 0(CX)			
  0x4072eb		89f7			MOVL SI, DI			
  0x4072ed		4a8b741c70		MOVQ 0x70(SP)(R11*1), SI	
  0x4072f2		4883e607		ANDQ $0x7, SI			
  0x4072f6		44883431		MOVB R14, 0(CX)(SI*1)		
				if t.indirectkey {
  0x4072fa		410fb64851		MOVZX 0x51(R8), CX	
  0x4072ff		84c9			TESTL CL, CL		
  0x407301		0f840f010000		JE 0x407416		
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x407307		4a8b4c1c78		MOVQ 0x78(SP)(R11*1), CX		
  0x40730c		8401			TESTB AL, 0(CX)				
  0x40730e		8b35fcc60b00		MOVL runtime.writeBarrier(SB), SI	
  0x407314		85f6			TESTL SI, SI				
  0x407316		0f85e0000000		JNE 0x4073fc				
  0x40731c		4c8939			MOVQ R15, 0(CX)				
				if t.indirectvalue {
  0x40731f		410fb64853		MOVZX 0x53(R8), CX	
  0x407324		84c9			TESTL CL, CL		
  0x407326		7475			JE 0x40739d		
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x407328		4a8b8c1c80000000	MOVQ 0x80(SP)(R11*1), CX		
  0x407330		8401			TESTB AL, 0(CX)				
  0x407332		8b35d8c60b00		MOVL runtime.writeBarrier(SB), SI	
  0x407338		4d8b3424		MOVQ 0(R12), R14			
  0x40733c		85f6			TESTL SI, SI				
  0x40733e		7546			JNE 0x407386				
  0x407340		4c8931			MOVQ R14, 0(CX)				
				dst.i++
  0x407343		4e8b741c70		MOVQ 0x70(SP)(R11*1), R14	
  0x407348		49ffc6			INCQ R14			
  0x40734b		4e89741c70		MOVQ R14, 0x70(SP)(R11*1)	
				dst.k = add(dst.k, uintptr(t.keysize))
  0x407350		4e8b741c78		MOVQ 0x78(SP)(R11*1), R14	
  0x407355		450fb67850		MOVZX 0x50(R8), R15		
	return unsafe.Pointer(uintptr(p) + x)
  0x40735a		4d01fe			ADDQ R15, R14		
				dst.k = add(dst.k, uintptr(t.keysize))
  0x40735d		4e89741c78		MOVQ R14, 0x78(SP)(R11*1)	
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x407362		4e8bb41c80000000	MOVQ 0x80(SP)(R11*1), R14	
  0x40736a		450fb67852		MOVZX 0x52(R8), R15		
	return unsafe.Pointer(uintptr(p) + x)
  0x40736f		4d01fe			ADDQ R15, R14		
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x407372		4e89b41c80000000	MOVQ R14, 0x80(SP)(R11*1)	
  0x40737a		89f9			MOVL DI, CX			
  0x40737c		89ce			MOVL CX, SI			
  0x40737e		4989d3			MOVQ DX, R11			
  0x407381		e9befeffff		JMP 0x407244			
  0x407386		89fe			MOVL DI, SI			
  0x407388		4889cf			MOVQ CX, DI			
  0x40738b		4989c7			MOVQ AX, R15			
  0x40738e		4c89f0			MOVQ R14, AX			
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x407391		e80af50300		CALL runtime.gcWriteBarrier(SB)	
  0x407396		4c89f8			MOVQ R15, AX			
  0x407399		89f7			MOVL SI, DI			
  0x40739b		eba6			JMP 0x407343			
					typedmemmove(t.elem, dst.v, v)
  0x40739d		498b4038		MOVQ 0x38(R8), AX		
  0x4073a1		4a8b8c1c80000000	MOVQ 0x80(SP)(R11*1), CX	
  0x4073a9		48894c2408		MOVQ CX, 0x8(SP)		
  0x4073ae		48890424		MOVQ AX, 0(SP)			
  0x4073b2		4c89642410		MOVQ R12, 0x10(SP)		
  0x4073b7		e8d4460000		CALL runtime.typedmemmove(SB)	
  0x4073bc		488b442428		MOVQ 0x28(SP), AX		
  0x4073c1		488b542440		MOVQ 0x40(SP), DX		
  0x4073c6		488b9c24c0000000	MOVQ 0xc0(SP), BX		
  0x4073ce		0fb67c2427		MOVZX 0x27(SP), DI		
  0x4073d3		4c8b8424b8000000	MOVQ 0xb8(SP), R8		
  0x4073db		4c8b4c2460		MOVQ 0x60(SP), R9		
  0x4073e0		4c8b9424c8000000	MOVQ 0xc8(SP), R10		
  0x4073e8		4c8b5c2438		MOVQ 0x38(SP), R11		
  0x4073ed		4c8b642450		MOVQ 0x50(SP), R12		
  0x4073f2		4c8b6c2448		MOVQ 0x48(SP), R13		
  0x4073f7		e947ffffff		JMP 0x407343			
  0x4073fc		89fe			MOVL DI, SI			
  0x4073fe		4889cf			MOVQ CX, DI			
  0x407401		4989c6			MOVQ AX, R14			
  0x407404		4c89f8			MOVQ R15, AX			
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x407407		e894f40300		CALL runtime.gcWriteBarrier(SB)	
  0x40740c		4c89f0			MOVQ R14, AX			
  0x40740f		89f7			MOVL SI, DI			
  0x407411		e909ffffff		JMP 0x40731f			
					typedmemmove(t.key, dst.k, k) // copy value
  0x407416		498b4030		MOVQ 0x30(R8), AX		
  0x40741a		4a8b4c1c78		MOVQ 0x78(SP)(R11*1), CX	
  0x40741f		48894c2408		MOVQ CX, 0x8(SP)		
  0x407424		48890424		MOVQ AX, 0(SP)			
  0x407428		4c896c2410		MOVQ R13, 0x10(SP)		
  0x40742d		e85e460000		CALL runtime.typedmemmove(SB)	
  0x407432		488b442428		MOVQ 0x28(SP), AX		
  0x407437		488b542440		MOVQ 0x40(SP), DX		
  0x40743c		488b9c24c0000000	MOVQ 0xc0(SP), BX		
  0x407444		0fb67c2427		MOVZX 0x27(SP), DI		
  0x407449		4c8b8424b8000000	MOVQ 0xb8(SP), R8		
  0x407451		4c8b4c2460		MOVQ 0x60(SP), R9		
  0x407456		4c8b9424c8000000	MOVQ 0xc8(SP), R10		
  0x40745e		4c8b5c2438		MOVQ 0x38(SP), R11		
  0x407463		4c8b642450		MOVQ 0x50(SP), R12		
  0x407468		4c8b6c2448		MOVQ 0x48(SP), R13		
  0x40746d		e9adfeffff		JMP 0x40731f			
  0x407472		4488742425		MOVB R14, 0x25(SP)		
					dst.b = h.newoverflow(t, dst.b)
  0x407477		4a8b441c68		MOVQ 0x68(SP)(R11*1), AX		
  0x40747c		4889442410		MOVQ AX, 0x10(SP)			
  0x407481		48891c24		MOVQ BX, 0(SP)				
  0x407485		4c89442408		MOVQ R8, 0x8(SP)			
  0x40748a		e801ebffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x40748f		488b442418		MOVQ 0x18(SP), AX			
  0x407494		4c8b5c2438		MOVQ 0x38(SP), R11			
  0x407499		4a89441c68		MOVQ AX, 0x68(SP)(R11*1)		
					dst.i = 0
  0x40749e		4ac7441c7000000000	MOVQ $0x0, 0x70(SP)(R11*1)	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x4074a7		4a8b441c68		MOVQ 0x68(SP)(R11*1), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x4074ac		488d4808		LEAQ 0x8(AX), CX	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x4074b0		4a894c1c78		MOVQ CX, 0x78(SP)(R11*1)	
  0x4074b5		4c8b8424b8000000	MOVQ 0xb8(SP), R8		
					dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
  0x4074bd		410fb64850		MOVZX 0x50(R8), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x4074c2		488d44c808		LEAQ 0x8(AX)(CX*8), AX	
					dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
  0x4074c7		4a89841c80000000	MOVQ AX, 0x80(SP)(R11*1)	
  0x4074cf		488b442428		MOVQ 0x28(SP), AX		
  0x4074d4		488b542440		MOVQ 0x40(SP), DX		
  0x4074d9		488b9c24c0000000	MOVQ 0xc0(SP), BX		
  0x4074e1		0fb6742427		MOVZX 0x27(SP), SI		
  0x4074e6		4c8b4c2460		MOVQ 0x60(SP), R9		
  0x4074eb		4c8b9424c8000000	MOVQ 0xc8(SP), R10		
  0x4074f3		4c8b642450		MOVQ 0x50(SP), R12		
  0x4074f8		4c8b6c2448		MOVQ 0x48(SP), R13		
  0x4074fd		440fb6742425		MOVZX 0x25(SP), R14		
  0x407503		4c8b7c2458		MOVQ 0x58(SP), R15		
  0x407508		e9d7fdffff		JMP 0x4072e4			
  0x40750d		4488742426		MOVB R14, 0x26(SP)		
					hash := t.key.alg.hash(k2, uintptr(h.hash0))
  0x407512		498b4030		MOVQ 0x30(R8), AX	
  0x407516		488b4018		MOVQ 0x18(AX), AX	
  0x40751a		488b10			MOVQ 0(AX), DX		
  0x40751d		8b430c			MOVL 0xc(BX), AX	
  0x407520		4889442408		MOVQ AX, 0x8(SP)	
  0x407525		4c893c24		MOVQ R15, 0(SP)		
  0x407529		488b02			MOVQ 0(DX), AX		
  0x40752c		ffd0			CALL AX			
  0x40752e		488b442410		MOVQ 0x10(SP), AX	
  0x407533		488b8c24c0000000	MOVQ 0xc0(SP), CX	
					if h.flags&iterator != 0 && !t.reflexivekey && !t.key.alg.equal(k2, k2) {
  0x40753b		0fb65908		MOVZX 0x8(CX), BX	
  0x40753f		f6c301			TESTL $0x1, BL		
  0x407542		0f84e4000000		JE 0x40762c		
  0x407548		488b9c24b8000000	MOVQ 0xb8(SP), BX	
  0x407550		0fb67356		MOVZX 0x56(BX), SI	
  0x407554		4084f6			TESTL SI, SI		
  0x407557		7455			JE 0x4075ae		
  0x407559		0fb6742427		MOVZX 0x27(SP), SI	
						if hash&newbit != 0 {
  0x40755e		480fa3f0		BTQ SI, AX		
  0x407562		410f92c0		SETB R8			
  0x407566		0fb6442426		MOVZX 0x26(SP), AX	
  0x40756b		89f1			MOVL SI, CX		
  0x40756d		488b542440		MOVQ 0x40(SP), DX	
  0x407572		488b9c24c0000000	MOVQ 0xc0(SP), BX	
  0x40757a		4c8b4c2460		MOVQ 0x60(SP), R9	
  0x40757f		4c8b9424c8000000	MOVQ 0xc8(SP), R10	
  0x407587		4c8b642450		MOVQ 0x50(SP), R12	
  0x40758c		4c8b6c2448		MOVQ 0x48(SP), R13	
  0x407591		4c8b7c2458		MOVQ 0x58(SP), R15	
  0x407596		4489c7			MOVL R8, DI		
  0x407599		4189c6			MOVL AX, R14		
  0x40759c		488b442428		MOVQ 0x28(SP), AX	
  0x4075a1		4c8b8424b8000000	MOVQ 0xb8(SP), R8	
  0x4075a9		e908fdffff		JMP 0x4072b6		
  0x4075ae		4889442430		MOVQ AX, 0x30(SP)	
					if h.flags&iterator != 0 && !t.reflexivekey && !t.key.alg.equal(k2, k2) {
  0x4075b3		488b4330		MOVQ 0x30(BX), AX	
  0x4075b7		488b4018		MOVQ 0x18(AX), AX	
  0x4075bb		488b5008		MOVQ 0x8(AX), DX	
  0x4075bf		488b442458		MOVQ 0x58(SP), AX	
  0x4075c4		48890424		MOVQ AX, 0(SP)		
  0x4075c8		4889442408		MOVQ AX, 0x8(SP)	
  0x4075cd		488b0a			MOVQ 0(DX), CX		
  0x4075d0		ffd1			CALL CX			
  0x4075d2		0fb6442410		MOVZX 0x10(SP), AX	
  0x4075d7		84c0			TESTL AL, AL		
  0x4075d9		741a			JE 0x4075f5		
  0x4075db		488b442430		MOVQ 0x30(SP), AX	
  0x4075e0		488b8c24c0000000	MOVQ 0xc0(SP), CX	
  0x4075e8		488b9c24b8000000	MOVQ 0xb8(SP), BX	
  0x4075f0		e964ffffff		JMP 0x407559		
  0x4075f5		488b4c2430		MOVQ 0x30(SP), CX	
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x4075fa		48c1e938		SHRQ $0x38, CX		
	if top < minTopHash {
  0x4075fe		80f904			CMPL $0x4, CL		
  0x407601		7303			JAE 0x407606		
		top += minTopHash
  0x407603		83c104			ADDL $0x4, CX		
  0x407606		440fb6442426		MOVZX 0x26(SP), R8	
						useY = top & 1
  0x40760c		4183e001		ANDL $0x1, R8		
  0x407610		488b9c24b8000000	MOVQ 0xb8(SP), BX	
  0x407618		0fb6742427		MOVZX 0x27(SP), SI	
  0x40761d		89c8			MOVL CX, AX		
  0x40761f		488b8c24c0000000	MOVQ 0xc0(SP), CX	
						top = tophash(hash)
  0x407627		e93fffffff		JMP 0x40756b		
  0x40762c		488b9c24b8000000	MOVQ 0xb8(SP), BX	
					if h.flags&iterator != 0 && !t.reflexivekey && !t.key.alg.equal(k2, k2) {
  0x407634		e920ffffff		JMP 0x407559		
  0x407639		4d89ef			MOVQ R13, R15		
				if t.indirectkey {
  0x40763c		e94dfcffff		JMP 0x40728e		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x407641		450fb76054		MOVZX 0x54(R8), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x407646		4f8d6421f8		LEAQ -0x8(R9)(R12*1), R12	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40764b		4d8b0c24		MOVQ 0(R12), R9		
		for ; b != nil; b = b.overflow(t) {
  0x40764f		4d85c9			TESTQ R9, R9		
  0x407652		741a			JE 0x40766e		
  0x407654		4c894c2460		MOVQ R9, 0x60(SP)	
			v := add(k, bucketCnt*uintptr(t.keysize))
  0x407659		450fb66050		MOVZX 0x50(R8), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x40765e		4d8d6908		LEAQ 0x8(R9), R13		
  0x407662		4f8d64e108		LEAQ 0x8(R9)(R12*8), R12	
  0x407667		31c0			XORL AX, AX			
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x407669		e9e9fbffff		JMP 0x407257		
		if h.flags&oldIterator == 0 && t.bucket.kind&kindNoPointers == 0 {
  0x40766e		0fb64308		MOVZX 0x8(BX), AX	
  0x407672		a802			TESTL $0x2, AL		
  0x407674		750c			JNE 0x407682		
  0x407676		498b4040		MOVQ 0x40(R8), AX	
  0x40767a		0fb64017		MOVZX 0x17(AX), AX	
  0x40767e		a880			TESTL $0x80, AL		
  0x407680		742e			JE 0x4076b0		
	if oldbucket == h.nevacuate {
  0x407682		488b4320		MOVQ 0x20(BX), AX	
  0x407686		4939c2			CMPQ AX, R10		
  0x407689		7410			JE 0x40769b		
  0x40768b		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x407693		4881c4b0000000		ADDQ $0xb0, SP		
  0x40769a		c3			RET			
		advanceEvacuationMark(h, t, newbit)
  0x40769b		48891c24		MOVQ BX, 0(SP)				
  0x40769f		4c89442408		MOVQ R8, 0x8(SP)			
  0x4076a4		4c895c2410		MOVQ R11, 0x10(SP)			
  0x4076a9		e8c2000000		CALL runtime.advanceEvacuationMark(SB)	
  0x4076ae		ebdb			JMP 0x40768b				
			b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
  0x4076b0		410fb74054		MOVZX 0x54(R8), AX	
  0x4076b5		4889c1			MOVQ AX, CX		
  0x4076b8		490fafc2		IMULQ R10, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4076bc		48034318		ADDQ 0x18(BX), AX	
  0x4076c0		4883c008		ADDQ $0x8, AX		
			memclrHasPointers(ptr, n)
  0x4076c4		48890424		MOVQ AX, 0(SP)		
			n := uintptr(t.bucketsize) - dataOffset
  0x4076c8		488d41f8		LEAQ -0x8(CX), AX	
			memclrHasPointers(ptr, n)
  0x4076cc		4889442408		MOVQ AX, 0x8(SP)			
  0x4076d1		e8aa460000		CALL runtime.memclrHasPointers(SB)	
  0x4076d6		488b9c24c0000000	MOVQ 0xc0(SP), BX			
  0x4076de		4c8b8424b8000000	MOVQ 0xb8(SP), R8			
  0x4076e6		4c8b9424c8000000	MOVQ 0xc8(SP), R10			
  0x4076ee		4c8b5c2440		MOVQ 0x40(SP), R11			
  0x4076f3		eb8d			JMP 0x407682				
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x4076f5		4c8da42488000000	LEAQ 0x88(SP), R12	
  0x4076fd		41840424		TESTB AL, 0(R12)	
  0x407701		4f8d2413		LEAQ 0(R11)(R10*1), R12	
  0x407705		450fb76854		MOVZX 0x54(R8), R13	
  0x40770a		4d0fafec		IMULQ R12, R13		
	return unsafe.Pointer(uintptr(p) + x)
  0x40770e		4c036b10		ADDQ 0x10(BX), R13	
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x407712		4c89ac2488000000	MOVQ R13, 0x88(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x40771a		4d8d6508		LEAQ 0x8(R13), R12	
			y.k = add(unsafe.Pointer(y.b), dataOffset)
  0x40771e		4c89a42498000000	MOVQ R12, 0x98(SP)	
			y.v = add(y.k, bucketCnt*uintptr(t.keysize))
  0x407726		450fb66050		MOVZX 0x50(R8), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x40772b		4f8d64e508		LEAQ 0x8(R13)(R12*8), R12	
			y.v = add(y.k, bucketCnt*uintptr(t.keysize))
  0x407730		4c89a424a0000000	MOVQ R12, 0xa0(SP)	
  0x407738		e9f9faffff		JMP 0x407236		
		oldB--
  0x40773d		ffce			DECL SI			
  0x40773f		e973faffff		JMP 0x4071b7		
				dst := &xy[useY]                 // evacuation destination
  0x407744		e8f7820100		CALL runtime.panicindex(SB)	
  0x407749		0f0b			UD2				
					throw("bad map state")
  0x40774b		488d05e22f0600		LEAQ 0x62fe2(IP), AX	
  0x407752		48890424		MOVQ AX, 0(SP)		
  0x407756		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40775f		e86c9a0100		CALL runtime.throw(SB)	
  0x407764		0f0b			UD2			
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
  0x407766		e805ce0300		CALL runtime.morestack_noctxt(SB)	
  0x40776b		e9c0f9ffff		JMP runtime.evacuate(SB)		

TEXT runtime.advanceEvacuationMark(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap.go
func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {
  0x407770		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407779		483b6110		CMPQ 0x10(CX), SP	
  0x40777d		0f86d8000000		JBE 0x40785b		
  0x407783		4883ec08		SUBQ $0x8, SP		
  0x407787		48892c24		MOVQ BP, 0(SP)		
  0x40778b		488d2c24		LEAQ 0(SP), BP		
  0x40778f		488b4c2410		MOVQ 0x10(SP), CX	
	h.nevacuate++
  0x407794		488b5120		MOVQ 0x20(CX), DX	
  0x407798		488d5a01		LEAQ 0x1(DX), BX	
  0x40779c		48895920		MOVQ BX, 0x20(CX)	
	stop := h.nevacuate + 1024
  0x4077a0		4881c201040000		ADDQ $0x401, DX		
  0x4077a7		488b5c2420		MOVQ 0x20(SP), BX	
	if stop > newbit {
  0x4077ac		4839da			CMPQ BX, DX		
  0x4077af		0f869b000000		JBE 0x407850		
  0x4077b5		4889d8			MOVQ BX, AX		
		stop = newbit
  0x4077b8		488b542418		MOVQ 0x18(SP), DX	
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
  0x4077bd		eb07			JMP 0x4077c6		
		h.nevacuate++
  0x4077bf		48ffc6			INCQ SI			
  0x4077c2		48897120		MOVQ SI, 0x20(CX)	
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
  0x4077c6		488b7120		MOVQ 0x20(CX), SI	
  0x4077ca		4839de			CMPQ BX, SI		
  0x4077cd		7422			JE 0x4077f1		
	b := (*bmap)(add(h.oldbuckets, bucket*uintptr(t.bucketsize)))
  0x4077cf		4c8b4118		MOVQ 0x18(CX), R8	
  0x4077d3		440fb74a54		MOVZX 0x54(DX), R9	
  0x4077d8		4c0fafce		IMULQ SI, R9		
	return unsafe.Pointer(uintptr(p) + x)
  0x4077dc		4f8d1408		LEAQ 0(R8)(R9*1), R10	
	h := b.tophash[0]
  0x4077e0		418402			TESTB AL, 0(R10)	
  0x4077e3		470fb60408		MOVZX 0(R8)(R9*1), R8	
	return h > empty && h < minTopHash
  0x4077e8		41ffc8			DECL R8			
  0x4077eb		4180f803		CMPL $0x3, R8		
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
  0x4077ef		72ce			JB 0x4077bf		
	if h.nevacuate == newbit { // newbit == # of oldbuckets
  0x4077f1		4839c6			CMPQ AX, SI		
  0x4077f4		753f			JNE 0x407835		
		h.oldbuckets = nil
  0x4077f6		8b1514c20b00		MOVL runtime.writeBarrier(SB), DX	
  0x4077fc		488d7918		LEAQ 0x18(CX), DI			
  0x407800		85d2			TESTL DX, DX				
  0x407802		7543			JNE 0x407847				
  0x407804		48c7411800000000	MOVQ $0x0, 0x18(CX)			
		if h.extra != nil {
  0x40780c		488b5128		MOVQ 0x28(CX), DX	
  0x407810		4885d2			TESTQ DX, DX		
  0x407813		7416			JE 0x40782b		
			h.extra.oldoverflow = nil
  0x407815		8b1df5c10b00		MOVL runtime.writeBarrier(SB), BX	
  0x40781b		488d7a08		LEAQ 0x8(DX), DI			
  0x40781f		85db			TESTL BX, BX				
  0x407821		751b			JNE 0x40783e				
  0x407823		48c7420800000000	MOVQ $0x0, 0x8(DX)			
		h.flags &^= sameSizeGrow
  0x40782b		0fb64108		MOVZX 0x8(CX), AX	
  0x40782f		83e0f7			ANDL $-0x9, AX		
  0x407832		884108			MOVB AL, 0x8(CX)	
  0x407835		488b2c24		MOVQ 0(SP), BP		
  0x407839		4883c408		ADDQ $0x8, SP		
  0x40783d		c3			RET			
			h.extra.oldoverflow = nil
  0x40783e		31c0			XORL AX, AX			
  0x407840		e85bf00300		CALL runtime.gcWriteBarrier(SB)	
  0x407845		ebe4			JMP 0x40782b			
		h.oldbuckets = nil
  0x407847		31c0			XORL AX, AX			
  0x407849		e852f00300		CALL runtime.gcWriteBarrier(SB)	
  0x40784e		ebbc			JMP 0x40780c			
  0x407850		4889d8			MOVQ BX, AX			
  0x407853		4889d3			MOVQ DX, BX			
	if stop > newbit {
  0x407856		e95dffffff		JMP 0x4077b8		
func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {
  0x40785b		e810cd0300		CALL runtime.morestack_noctxt(SB)	
  0x407860		e90bffffff		JMP runtime.advanceEvacuationMark(SB)	

TEXT runtime.mapaccess1_fast32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap_fast.go
func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x407870		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407879		483b6110		CMPQ 0x10(CX), SP	
  0x40787d		0f8683010000		JBE 0x407a06		
  0x407883		4883ec20		SUBQ $0x20, SP		
  0x407887		48896c2418		MOVQ BP, 0x18(SP)	
  0x40788c		488d6c2418		LEAQ 0x18(SP), BP	
  0x407891		488b442430		MOVQ 0x30(SP), AX	
	if h == nil || h.count == 0 {
  0x407896		4885c0			TESTQ AX, AX		
  0x407899		0f8436010000		JE 0x4079d5		
  0x40789f		488b08			MOVQ 0(AX), CX		
  0x4078a2		4885c9			TESTQ CX, CX		
  0x4078a5		0f842a010000		JE 0x4079d5		
	if h.flags&hashWriting != 0 {
  0x4078ab		0fb64808		MOVZX 0x8(AX), CX	
  0x4078af		f6c104			TESTL $0x4, CL		
  0x4078b2		0f8533010000		JNE 0x4079eb		
	if h.B == 0 {
  0x4078b8		0fb64809		MOVZX 0x9(AX), CX	
  0x4078bc		84c9			TESTL CL, CL		
  0x4078be		757c			JNE 0x40793c		
		b = (*bmap)(h.buckets)
  0x4078c0		488b4010		MOVQ 0x10(AX), AX	
  0x4078c4		eb53			JMP 0x407919		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x4078c6		48ffc2			INCQ DX			
	return unsafe.Pointer(uintptr(p) + x)
  0x4078c9		4883c104		ADDQ $0x4, CX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x4078cd		4883fa08		CMPQ $0x8, DX		
  0x4078d1		7333			JAE 0x407906		
			if *(*uint32)(k) == key && b.tophash[i] != empty {
  0x4078d3		8b19			MOVL 0(CX), BX		
  0x4078d5		8b742438		MOVL 0x38(SP), SI	
  0x4078d9		39f3			CMPL SI, BX		
  0x4078db		75e9			JNE 0x4078c6		
  0x4078dd		0fb61c02		MOVZX 0(DX)(AX*1), BX	
  0x4078e1		84db			TESTL BL, BL		
  0x4078e3		74e1			JE 0x4078c6		
  0x4078e5		488b4c2428		MOVQ 0x28(SP), CX	
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize))
  0x4078ea		0fb64952		MOVZX 0x52(CX), CX	
  0x4078ee		480fafd1		IMULQ CX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4078f2		488d440228		LEAQ 0x28(DX)(AX*1), AX	
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize))
  0x4078f7		4889442440		MOVQ AX, 0x40(SP)	
  0x4078fc		488b6c2418		MOVQ 0x18(SP), BP	
  0x407901		4883c420		ADDQ $0x20, SP		
  0x407905		c3			RET			
  0x407906		488b4c2428		MOVQ 0x28(SP), CX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40790b		0fb75154		MOVZX 0x54(CX), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40790f		488d5410f8		LEAQ -0x8(AX)(DX*1), DX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x407914		8401			TESTB AL, 0(CX)		
  0x407916		488b02			MOVQ 0(DX), AX		
	for ; b != nil; b = b.overflow(t) {
  0x407919		4885c0			TESTQ AX, AX		
  0x40791c		7408			JE 0x407926		
	return unsafe.Pointer(uintptr(p) + x)
  0x40791e		488d4808		LEAQ 0x8(AX), CX	
  0x407922		31d2			XORL DX, DX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x407924		eba7			JMP 0x4078cd		
	return unsafe.Pointer(&zeroVal[0])
  0x407926		488d05d3c90b00		LEAQ runtime.zeroVal(SB), AX	
  0x40792d		4889442440		MOVQ AX, 0x40(SP)		
  0x407932		488b6c2418		MOVQ 0x18(SP), BP		
  0x407937		4883c420		ADDQ $0x20, SP			
  0x40793b		c3			RET				
  0x40793c		488b4c2428		MOVQ 0x28(SP), CX		
		hash := t.key.alg.hash(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))
  0x407941		488b5930		MOVQ 0x30(CX), BX	
  0x407945		488b5b18		MOVQ 0x18(BX), BX	
  0x407949		488b13			MOVQ 0(BX), DX		
  0x40794c		8b580c			MOVL 0xc(AX), BX	
  0x40794f		48895c2408		MOVQ BX, 0x8(SP)	
  0x407954		488d5c2438		LEAQ 0x38(SP), BX	
  0x407959		48891c24		MOVQ BX, 0(SP)		
  0x40795d		488b1a			MOVQ 0(DX), BX		
  0x407960		ffd3			CALL BX			
  0x407962		488b442410		MOVQ 0x10(SP), AX	
  0x407967		488b4c2430		MOVQ 0x30(SP), CX	
		m := bucketMask(h.B)
  0x40796c		0fb65909		MOVZX 0x9(CX), BX	
  0x407970		4889ca			MOVQ CX, DX		
  0x407973		89d9			MOVL BX, CX		
	return uintptr(1) << b
  0x407975		be01000000		MOVL $0x1, SI		
  0x40797a		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x40797d		488d4eff		LEAQ -0x1(SI), CX	
  0x407981		4889cb			MOVQ CX, BX		
		b = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
  0x407984		4821c1			ANDQ AX, CX		
  0x407987		488b742428		MOVQ 0x28(SP), SI	
  0x40798c		0fb77e54		MOVZX 0x54(SI), DI	
  0x407990		480fafcf		IMULQ DI, CX		
		if c := h.oldbuckets; c != nil {
  0x407994		4c8b4218		MOVQ 0x18(DX), R8	
	return unsafe.Pointer(uintptr(p) + x)
  0x407998		48034a10		ADDQ 0x10(DX), CX	
		if c := h.oldbuckets; c != nil {
  0x40799c		4d85c0			TESTQ R8, R8		
  0x40799f		7422			JE 0x4079c3		
	return h.flags&sameSizeGrow != 0
  0x4079a1		0fb65208		MOVZX 0x8(DX), DX	
  0x4079a5		f6c208			TESTL $0x8, DL		
			if !h.sameSizeGrow() {
  0x4079a8		7426			JE 0x4079d0		
			oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
  0x4079aa		4821c3			ANDQ AX, BX		
  0x4079ad		480fafdf		IMULQ DI, BX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4079b1		498d0418		LEAQ 0(R8)(BX*1), AX	
	h := b.tophash[0]
  0x4079b5		8400			TESTB AL, 0(AX)		
  0x4079b7		420fb61403		MOVZX 0(BX)(R8*1), DX	
	return h > empty && h < minTopHash
  0x4079bc		ffca			DECL DX			
  0x4079be		80fa03			CMPL $0x3, DL		
			if !evacuated(oldb) {
  0x4079c1		7308			JAE 0x4079cb		
  0x4079c3		4889c8			MOVQ CX, AX		
	for ; b != nil; b = b.overflow(t) {
  0x4079c6		e94effffff		JMP 0x407919		
  0x4079cb		4889c1			MOVQ AX, CX		
				b = oldb
  0x4079ce		ebf3			JMP 0x4079c3		
				m >>= 1
  0x4079d0		48d1eb			SHRQ $0x1, BX		
  0x4079d3		ebd5			JMP 0x4079aa		
		return unsafe.Pointer(&zeroVal[0])
  0x4079d5		488d0524c90b00		LEAQ runtime.zeroVal(SB), AX	
  0x4079dc		4889442440		MOVQ AX, 0x40(SP)		
  0x4079e1		488b6c2418		MOVQ 0x18(SP), BP		
  0x4079e6		4883c420		ADDQ $0x20, SP			
  0x4079ea		c3			RET				
		throw("concurrent map read and map write")
  0x4079eb		488d05d44f0600		LEAQ 0x64fd4(IP), AX	
  0x4079f2		48890424		MOVQ AX, 0(SP)		
  0x4079f6		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x4079ff		e8cc970100		CALL runtime.throw(SB)	
  0x407a04		0f0b			UD2			
func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x407a06		e865cb0300		CALL runtime.morestack_noctxt(SB)	
  0x407a0b		e960feffff		JMP runtime.mapaccess1_fast32(SB)	

TEXT runtime.mapaccess2_fast32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap_fast.go
func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {
  0x407a10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407a19		483b6110		CMPQ 0x10(CX), SP	
  0x407a1d		0f8696010000		JBE 0x407bb9		
  0x407a23		4883ec20		SUBQ $0x20, SP		
  0x407a27		48896c2418		MOVQ BP, 0x18(SP)	
  0x407a2c		488d6c2418		LEAQ 0x18(SP), BP	
  0x407a31		488b442430		MOVQ 0x30(SP), AX	
	if h == nil || h.count == 0 {
  0x407a36		4885c0			TESTQ AX, AX		
  0x407a39		0f8444010000		JE 0x407b83		
  0x407a3f		488b08			MOVQ 0(AX), CX		
  0x407a42		4885c9			TESTQ CX, CX		
  0x407a45		0f8438010000		JE 0x407b83		
	if h.flags&hashWriting != 0 {
  0x407a4b		0fb64808		MOVZX 0x8(AX), CX	
  0x407a4f		f6c104			TESTL $0x4, CL		
  0x407a52		0f8546010000		JNE 0x407b9e		
	if h.B == 0 {
  0x407a58		0fb64809		MOVZX 0x9(AX), CX	
  0x407a5c		84c9			TESTL CL, CL		
  0x407a5e		0f8586000000		JNE 0x407aea		
		b = (*bmap)(h.buckets)
  0x407a64		488b4010		MOVQ 0x10(AX), AX	
  0x407a68		eb58			JMP 0x407ac2		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x407a6a		48ffc2			INCQ DX			
	return unsafe.Pointer(uintptr(p) + x)
  0x407a6d		4883c104		ADDQ $0x4, CX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x407a71		4883fa08		CMPQ $0x8, DX		
  0x407a75		7338			JAE 0x407aaf		
			if *(*uint32)(k) == key && b.tophash[i] != empty {
  0x407a77		8b19			MOVL 0(CX), BX		
  0x407a79		8b742438		MOVL 0x38(SP), SI	
  0x407a7d		39f3			CMPL SI, BX		
  0x407a7f		75e9			JNE 0x407a6a		
  0x407a81		0fb61c02		MOVZX 0(DX)(AX*1), BX	
  0x407a85		84db			TESTL BL, BL		
  0x407a87		74e1			JE 0x407a6a		
  0x407a89		488b4c2428		MOVQ 0x28(SP), CX	
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize)), true
  0x407a8e		0fb64952		MOVZX 0x52(CX), CX	
  0x407a92		480fafd1		IMULQ CX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x407a96		488d440228		LEAQ 0x28(DX)(AX*1), AX	
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize)), true
  0x407a9b		4889442440		MOVQ AX, 0x40(SP)	
  0x407aa0		c644244801		MOVB $0x1, 0x48(SP)	
  0x407aa5		488b6c2418		MOVQ 0x18(SP), BP	
  0x407aaa		4883c420		ADDQ $0x20, SP		
  0x407aae		c3			RET			
  0x407aaf		488b4c2428		MOVQ 0x28(SP), CX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x407ab4		0fb75154		MOVZX 0x54(CX), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x407ab8		488d5410f8		LEAQ -0x8(AX)(DX*1), DX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x407abd		8401			TESTB AL, 0(CX)		
  0x407abf		488b02			MOVQ 0(DX), AX		
	for ; b != nil; b = b.overflow(t) {
  0x407ac2		4885c0			TESTQ AX, AX		
  0x407ac5		7408			JE 0x407acf		
	return unsafe.Pointer(uintptr(p) + x)
  0x407ac7		488d4808		LEAQ 0x8(AX), CX	
  0x407acb		31d2			XORL DX, DX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x407acd		eba2			JMP 0x407a71		
	return unsafe.Pointer(&zeroVal[0]), false
  0x407acf		488d052ac80b00		LEAQ runtime.zeroVal(SB), AX	
  0x407ad6		4889442440		MOVQ AX, 0x40(SP)		
  0x407adb		c644244800		MOVB $0x0, 0x48(SP)		
  0x407ae0		488b6c2418		MOVQ 0x18(SP), BP		
  0x407ae5		4883c420		ADDQ $0x20, SP			
  0x407ae9		c3			RET				
  0x407aea		488b4c2428		MOVQ 0x28(SP), CX		
		hash := t.key.alg.hash(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))
  0x407aef		488b5930		MOVQ 0x30(CX), BX	
  0x407af3		488b5b18		MOVQ 0x18(BX), BX	
  0x407af7		488b13			MOVQ 0(BX), DX		
  0x407afa		8b580c			MOVL 0xc(AX), BX	
  0x407afd		48895c2408		MOVQ BX, 0x8(SP)	
  0x407b02		488d5c2438		LEAQ 0x38(SP), BX	
  0x407b07		48891c24		MOVQ BX, 0(SP)		
  0x407b0b		488b1a			MOVQ 0(DX), BX		
  0x407b0e		ffd3			CALL BX			
  0x407b10		488b442410		MOVQ 0x10(SP), AX	
  0x407b15		488b4c2430		MOVQ 0x30(SP), CX	
		m := bucketMask(h.B)
  0x407b1a		0fb65909		MOVZX 0x9(CX), BX	
  0x407b1e		4889ca			MOVQ CX, DX		
  0x407b21		89d9			MOVL BX, CX		
	return uintptr(1) << b
  0x407b23		be01000000		MOVL $0x1, SI		
  0x407b28		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x407b2b		488d4eff		LEAQ -0x1(SI), CX	
  0x407b2f		4889cb			MOVQ CX, BX		
		b = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
  0x407b32		4821c1			ANDQ AX, CX		
  0x407b35		488b742428		MOVQ 0x28(SP), SI	
  0x407b3a		0fb77e54		MOVZX 0x54(SI), DI	
  0x407b3e		480fafcf		IMULQ DI, CX		
		if c := h.oldbuckets; c != nil {
  0x407b42		4c8b4218		MOVQ 0x18(DX), R8	
	return unsafe.Pointer(uintptr(p) + x)
  0x407b46		48034a10		ADDQ 0x10(DX), CX	
		if c := h.oldbuckets; c != nil {
  0x407b4a		4d85c0			TESTQ R8, R8		
  0x407b4d		7422			JE 0x407b71		
	return h.flags&sameSizeGrow != 0
  0x407b4f		0fb65208		MOVZX 0x8(DX), DX	
  0x407b53		f6c208			TESTL $0x8, DL		
			if !h.sameSizeGrow() {
  0x407b56		7426			JE 0x407b7e		
			oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
  0x407b58		4821c3			ANDQ AX, BX		
  0x407b5b		480fafdf		IMULQ DI, BX		
	return unsafe.Pointer(uintptr(p) + x)
  0x407b5f		498d0418		LEAQ 0(R8)(BX*1), AX	
	h := b.tophash[0]
  0x407b63		8400			TESTB AL, 0(AX)		
  0x407b65		420fb61403		MOVZX 0(BX)(R8*1), DX	
	return h > empty && h < minTopHash
  0x407b6a		ffca			DECL DX			
  0x407b6c		80fa03			CMPL $0x3, DL		
			if !evacuated(oldb) {
  0x407b6f		7308			JAE 0x407b79		
  0x407b71		4889c8			MOVQ CX, AX		
	for ; b != nil; b = b.overflow(t) {
  0x407b74		e949ffffff		JMP 0x407ac2		
  0x407b79		4889c1			MOVQ AX, CX		
				b = oldb
  0x407b7c		ebf3			JMP 0x407b71		
				m >>= 1
  0x407b7e		48d1eb			SHRQ $0x1, BX		
  0x407b81		ebd5			JMP 0x407b58		
		return unsafe.Pointer(&zeroVal[0]), false
  0x407b83		488d0576c70b00		LEAQ runtime.zeroVal(SB), AX	
  0x407b8a		4889442440		MOVQ AX, 0x40(SP)		
  0x407b8f		c644244800		MOVB $0x0, 0x48(SP)		
  0x407b94		488b6c2418		MOVQ 0x18(SP), BP		
  0x407b99		4883c420		ADDQ $0x20, SP			
  0x407b9d		c3			RET				
		throw("concurrent map read and map write")
  0x407b9e		488d05214e0600		LEAQ 0x64e21(IP), AX	
  0x407ba5		48890424		MOVQ AX, 0(SP)		
  0x407ba9		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x407bb2		e819960100		CALL runtime.throw(SB)	
  0x407bb7		0f0b			UD2			
func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {
  0x407bb9		e8b2c90300		CALL runtime.morestack_noctxt(SB)	
  0x407bbe		e94dfeffff		JMP runtime.mapaccess2_fast32(SB)	

TEXT runtime.mapassign_fast32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap_fast.go
func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x407bd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407bd9		483b6110		CMPQ 0x10(CX), SP	
  0x407bdd		0f8600030000		JBE 0x407ee3		
  0x407be3		4883ec40		SUBQ $0x40, SP		
  0x407be7		48896c2438		MOVQ BP, 0x38(SP)	
  0x407bec		488d6c2438		LEAQ 0x38(SP), BP	
  0x407bf1		488b442450		MOVQ 0x50(SP), AX	
	if h == nil {
  0x407bf6		4885c0			TESTQ AX, AX		
  0x407bf9		0f84c6020000		JE 0x407ec5		
	if h.flags&hashWriting != 0 {
  0x407bff		0fb64808		MOVZX 0x8(AX), CX	
  0x407c03		f6c104			TESTL $0x4, CL		
  0x407c06		0f859e020000		JNE 0x407eaa		
  0x407c0c		488b4c2448		MOVQ 0x48(SP), CX	
	hash := t.key.alg.hash(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))
  0x407c11		488b5930		MOVQ 0x30(CX), BX	
  0x407c15		488b5b18		MOVQ 0x18(BX), BX	
  0x407c19		488b13			MOVQ 0(BX), DX		
  0x407c1c		8b580c			MOVL 0xc(AX), BX	
  0x407c1f		48895c2408		MOVQ BX, 0x8(SP)	
  0x407c24		488d5c2458		LEAQ 0x58(SP), BX	
  0x407c29		48891c24		MOVQ BX, 0(SP)		
  0x407c2d		488b1a			MOVQ 0(DX), BX		
  0x407c30		ffd3			CALL BX			
  0x407c32		488b442410		MOVQ 0x10(SP), AX	
  0x407c37		4889442420		MOVQ AX, 0x20(SP)	
  0x407c3c		488b4c2450		MOVQ 0x50(SP), CX	
	h.flags |= hashWriting
  0x407c41		0fb65908		MOVZX 0x8(CX), BX	
  0x407c45		83cb04			ORL $0x4, BX		
  0x407c48		885908			MOVB BL, 0x8(CX)	
	if h.buckets == nil {
  0x407c4b		488b5910		MOVQ 0x10(CX), BX	
  0x407c4f		488d7110		LEAQ 0x10(CX), SI	
  0x407c53		4885db			TESTQ BX, BX		
  0x407c56		0f85df000000		JNE 0x407d3b		
  0x407c5c		e9dc010000		JMP 0x407e3d		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x407c61		49ffc1			INCQ R9			
  0x407c64		4983f908		CMPQ $0x8, R9		
  0x407c68		7360			JAE 0x407cca		
			if b.tophash[i] == empty {
  0x407c6a		8402			TESTB AL, 0(DX)		
  0x407c6c		460fb6140a		MOVZX 0(DX)(R9*1), R10	
  0x407c71		4584d2			TESTL R10, R10		
  0x407c74		750d			JNE 0x407c83		
				if insertb == nil {
  0x407c76		4885c9			TESTQ CX, CX		
  0x407c79		75e6			JNE 0x407c61		
  0x407c7b		4889d1			MOVQ DX, CX		
  0x407c7e		4d89c8			MOVQ R9, R8		
					insertb = b
  0x407c81		ebde			JMP 0x407c61		
  0x407c83		4989d2			MOVQ DX, R10		
	return unsafe.Pointer(uintptr(p) + x)
  0x407c86		4a8d548a08		LEAQ 0x8(DX)(R9*4), DX	
			k := *((*uint32)(add(unsafe.Pointer(b), dataOffset+i*4)))
  0x407c8b		8b12			MOVL 0(DX), DX		
			if k != key {
  0x407c8d		448b5c2458		MOVL 0x58(SP), R11	
  0x407c92		4439da			CMPL R11, DX		
  0x407c95		7405			JE 0x407c9c		
  0x407c97		4c89d2			MOVQ R10, DX		
				continue
  0x407c9a		ebc5			JMP 0x407c61		
	val := add(unsafe.Pointer(insertb), dataOffset+bucketCnt*4+inserti*uintptr(t.valuesize))
  0x407c9c		0fb64652		MOVZX 0x52(SI), AX	
  0x407ca0		4c0fafc8		IMULQ AX, R9		
	if h.flags&hashWriting == 0 {
  0x407ca4		0fb64308		MOVZX 0x8(BX), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x407ca8		4b8d4c1128		LEAQ 0x28(R9)(R10*1), CX	
	if h.flags&hashWriting == 0 {
  0x407cad		a804			TESTL $0x4, AL		
  0x407caf		0f84da010000		JE 0x407e8f		
	h.flags &^= hashWriting
  0x407cb5		83e0fb			ANDL $-0x5, AX		
  0x407cb8		884308			MOVB AL, 0x8(BX)	
	return val
  0x407cbb		48894c2460		MOVQ CX, 0x60(SP)	
  0x407cc0		488b6c2438		MOVQ 0x38(SP), BP	
  0x407cc5		4883c440		ADDQ $0x40, SP		
  0x407cc9		c3			RET			
  0x407cca		4989d1			MOVQ DX, R9		
	return unsafe.Pointer(uintptr(p) + x)
  0x407ccd		488d543af8		LEAQ -0x8(DX)(DI*1), DX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x407cd2		488b12			MOVQ 0(DX), DX		
		if ovf == nil {
  0x407cd5		4885d2			TESTQ DX, DX		
  0x407cd8		7405			JE 0x407cdf		
  0x407cda		4531c9			XORL R9, R9		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x407cdd		eb85			JMP 0x407c64		
	return h.oldbuckets != nil
  0x407cdf		488b5318		MOVQ 0x18(BX), DX	
  0x407ce3		4885d2			TESTQ DX, DX		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x407ce6		0f851b010000		JNE 0x407e07		
  0x407cec		488b13			MOVQ 0(BX), DX		
  0x407cef		48ffc2			INCQ DX			
  0x407cf2		0fb67b09		MOVZX 0x9(BX), DI	
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x407cf6		4883fa08		CMPQ $0x8, DX		
  0x407cfa		0f8efb000000		JLE 0x407dfb		
  0x407d00		4989ca			MOVQ CX, R10		
  0x407d03		89f9			MOVL DI, CX		
	return uintptr(1) << b
  0x407d05		41bb01000000		MOVL $0x1, R11		
  0x407d0b		49d3e3			SHLQ CL, R11		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x407d0e		49d1eb			SHRQ $0x1, R11		
  0x407d11		4f8d245b		LEAQ 0(R11)(R11*2), R12	
  0x407d15		4f8d1ca3		LEAQ 0(R11)(R12*4), R11	
  0x407d19		4c39da			CMPQ R11, DX		
  0x407d1c		0f97c2			SETA DL			
  0x407d1f		84d2			TESTL DL, DL		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x407d21		7458			JE 0x407d7b		
		hashGrow(t, h)
  0x407d23		48893424		MOVQ SI, 0(SP)			
  0x407d27		48895c2408		MOVQ BX, 0x8(SP)		
  0x407d2c		e8fff0ffff		CALL runtime.hashGrow(SB)	
  0x407d31		488b442420		MOVQ 0x20(SP), AX		
  0x407d36		488b4c2450		MOVQ 0x50(SP), CX		
	bucket := hash & bucketMask(h.B)
  0x407d3b		0fb65109		MOVZX 0x9(CX), DX	
  0x407d3f		4889cb			MOVQ CX, BX		
  0x407d42		89d1			MOVL DX, CX		
	return uintptr(1) << b
  0x407d44		be01000000		MOVL $0x1, SI		
  0x407d49		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x407d4c		488d56ff		LEAQ -0x1(SI), DX	
	bucket := hash & bucketMask(h.B)
  0x407d50		4821c2			ANDQ AX, DX		
	return h.oldbuckets != nil
  0x407d53		488b7318		MOVQ 0x18(BX), SI	
  0x407d57		4885f6			TESTQ SI, SI		
	if h.growing() {
  0x407d5a		0f85ac000000		JNE 0x407e0c		
  0x407d60		488b742448		MOVQ 0x48(SP), SI	
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x407d65		0fb77e54		MOVZX 0x54(SI), DI	
  0x407d69		480fafd7		IMULQ DI, DX		
  0x407d6d		48035310		ADDQ 0x10(BX), DX	
  0x407d71		31c9			XORL CX, CX		
  0x407d73		4531c0			XORL R8, R8		
	for {
  0x407d76		e95fffffff		JMP 0x407cda		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x407d7b		0fb7530a		MOVZX 0xa(BX), DX	
	if B > 15 {
  0x407d7f		80f90f			CMPL $0xf, CL		
  0x407d82		7605			JBE 0x407d89		
  0x407d84		b90f000000		MOVL $0xf, CX		
	return noverflow >= uint16(1)<<(B&15)
  0x407d89		83e10f			ANDL $0xf, CX		
  0x407d8c		bf01000000		MOVL $0x1, DI		
  0x407d91		d3e7			SHLL CL, DI		
  0x407d93		6639fa			CMPW DI, DX		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x407d96		738b			JAE 0x407d23		
	if insertb == nil {
  0x407d98		4d85d2			TESTQ R10, R10		
  0x407d9b		7432			JE 0x407dcf		
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x407d9d		48c1e838		SHRQ $0x38, AX		
	if top < minTopHash {
  0x407da1		3c04			CMPL $0x4, AL		
  0x407da3		7303			JAE 0x407da8		
		top += minTopHash
  0x407da5		83c004			ADDL $0x4, AX		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x407da8		418402			TESTB AL, 0(R10)	
  0x407dab		4d89c1			MOVQ R8, R9		
  0x407dae		4983e007		ANDQ $0x7, R8		
  0x407db2		43880402		MOVB AL, 0(R10)(R8*1)	
  0x407db6		4c89d0			MOVQ R10, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x407db9		4b8d4c8a08		LEAQ 0x8(R10)(R9*4), CX	
	*(*uint32)(insertk) = key
  0x407dbe		8b542458		MOVL 0x58(SP), DX	
  0x407dc2		8911			MOVL DX, 0(CX)		
	h.count++
  0x407dc4		48ff03			INCQ 0(BX)		
  0x407dc7		4989c2			MOVQ AX, R10		
done:
  0x407dca		e9cdfeffff		JMP 0x407c9c		
		insertb = h.newoverflow(t, b)
  0x407dcf		48891c24		MOVQ BX, 0(SP)				
  0x407dd3		4889742408		MOVQ SI, 0x8(SP)			
  0x407dd8		4c894c2410		MOVQ R9, 0x10(SP)			
  0x407ddd		e8aee1ffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x407de2		4c8b542418		MOVQ 0x18(SP), R10			
  0x407de7		488b442420		MOVQ 0x20(SP), AX			
  0x407dec		488b5c2450		MOVQ 0x50(SP), BX			
  0x407df1		488b742448		MOVQ 0x48(SP), SI			
  0x407df6		4531c0			XORL R8, R8				
		inserti = 0 // not necessary, but avoids needlessly spilling inserti
  0x407df9		eba2			JMP 0x407d9d		
  0x407dfb		4989ca			MOVQ CX, R10		
  0x407dfe		31d2			XORL DX, DX		
  0x407e00		89f9			MOVL DI, CX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x407e02		e918ffffff		JMP 0x407d1f		
  0x407e07		4989ca			MOVQ CX, R10		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x407e0a		eb8c			JMP 0x407d98		
  0x407e0c		4889542428		MOVQ DX, 0x28(SP)	
  0x407e11		488b442448		MOVQ 0x48(SP), AX	
		growWork_fast32(t, h, bucket)
  0x407e16		48890424		MOVQ AX, 0(SP)				
  0x407e1a		48895c2408		MOVQ BX, 0x8(SP)			
  0x407e1f		4889542410		MOVQ DX, 0x10(SP)			
  0x407e24		e8c7000000		CALL runtime.growWork_fast32(SB)	
  0x407e29		488b442420		MOVQ 0x20(SP), AX			
  0x407e2e		488b542428		MOVQ 0x28(SP), DX			
  0x407e33		488b5c2450		MOVQ 0x50(SP), BX			
  0x407e38		e923ffffff		JMP 0x407d60				
  0x407e3d		4889742430		MOVQ SI, 0x30(SP)			
  0x407e42		488b442448		MOVQ 0x48(SP), AX			
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x407e47		488b4840		MOVQ 0x40(AX), CX			
  0x407e4b		48890c24		MOVQ CX, 0(SP)				
  0x407e4f		e8cc320000		CALL runtime.newobject(SB)		
  0x407e54		8b05b6bb0b00		MOVL runtime.writeBarrier(SB), AX	
  0x407e5a		488b4c2408		MOVQ 0x8(SP), CX			
  0x407e5f		85c0			TESTL AX, AX				
  0x407e61		7518			JNE 0x407e7b				
  0x407e63		488b442450		MOVQ 0x50(SP), AX			
  0x407e68		48894810		MOVQ CX, 0x10(AX)			
  0x407e6c		488b442420		MOVQ 0x20(SP), AX			
  0x407e71		488b4c2450		MOVQ 0x50(SP), CX			
  0x407e76		e9c0feffff		JMP 0x407d3b				
  0x407e7b		488b7c2430		MOVQ 0x30(SP), DI			
  0x407e80		4889c8			MOVQ CX, AX				
  0x407e83		e818ea0300		CALL runtime.gcWriteBarrier(SB)		
  0x407e88		488b442450		MOVQ 0x50(SP), AX			
  0x407e8d		ebdd			JMP 0x407e6c				
		throw("concurrent map writes")
  0x407e8f		488d05f3330600		LEAQ 0x633f3(IP), AX	
  0x407e96		48890424		MOVQ AX, 0(SP)		
  0x407e9a		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x407ea3		e828930100		CALL runtime.throw(SB)	
  0x407ea8		0f0b			UD2			
		throw("concurrent map writes")
  0x407eaa		488d05d8330600		LEAQ 0x633d8(IP), AX	
  0x407eb1		48890424		MOVQ AX, 0(SP)		
  0x407eb5		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x407ebe		e80d930100		CALL runtime.throw(SB)	
  0x407ec3		0f0b			UD2			
		panic(plainError("assignment to entry in nil map"))
  0x407ec5		488d0574310500		LEAQ 0x53174(IP), AX			
  0x407ecc		48890424		MOVQ AX, 0(SP)				
  0x407ed0		488d0589ce0600		LEAQ runtime.statictmp_11(SB), AX	
  0x407ed7		4889442408		MOVQ AX, 0x8(SP)			
  0x407edc		e84f8b0100		CALL runtime.gopanic(SB)		
  0x407ee1		0f0b			UD2					
func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x407ee3		e888c60300		CALL runtime.morestack_noctxt(SB)	
  0x407ee8		e9e3fcffff		JMP runtime.mapassign_fast32(SB)	

TEXT runtime.growWork_fast32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap_fast.go
func growWork_fast32(t *maptype, h *hmap, bucket uintptr) {
  0x407ef0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407ef9		483b6110		CMPQ 0x10(CX), SP	
  0x407efd		0f8688000000		JBE 0x407f8b		
  0x407f03		4883ec20		SUBQ $0x20, SP		
  0x407f07		48896c2418		MOVQ BP, 0x18(SP)	
  0x407f0c		488d6c2418		LEAQ 0x18(SP), BP	
  0x407f11		488b442430		MOVQ 0x30(SP), AX	
	oldB := h.B
  0x407f16		0fb65009		MOVZX 0x9(AX), DX	
	return h.flags&sameSizeGrow != 0
  0x407f1a		0fb65808		MOVZX 0x8(AX), BX	
  0x407f1e		f6c308			TESTL $0x8, BL		
	if !h.sameSizeGrow() {
  0x407f21		7464			JE 0x407f87		
  0x407f23		488b5c2428		MOVQ 0x28(SP), BX	
	evacuate_fast32(t, h, bucket&h.oldbucketmask())
  0x407f28		48891c24		MOVQ BX, 0(SP)		
  0x407f2c		4889442408		MOVQ AX, 0x8(SP)	
  0x407f31		89d1			MOVL DX, CX		
	return uintptr(1) << b
  0x407f33		be01000000		MOVL $0x1, SI		
  0x407f38		48d3e6			SHLQ CL, SI		
	return h.noldbuckets() - 1
  0x407f3b		488d56ff		LEAQ -0x1(SI), DX	
  0x407f3f		488b742438		MOVQ 0x38(SP), SI	
	evacuate_fast32(t, h, bucket&h.oldbucketmask())
  0x407f44		4821d6			ANDQ DX, SI				
  0x407f47		4889742410		MOVQ SI, 0x10(SP)			
  0x407f4c		e84f000000		CALL runtime.evacuate_fast32(SB)	
  0x407f51		488b442430		MOVQ 0x30(SP), AX			
	return h.oldbuckets != nil
  0x407f56		488b5018		MOVQ 0x18(AX), DX	
  0x407f5a		4885d2			TESTQ DX, DX		
	if h.growing() {
  0x407f5d		750a			JNE 0x407f69		
  0x407f5f		488b6c2418		MOVQ 0x18(SP), BP	
  0x407f64		4883c420		ADDQ $0x20, SP		
  0x407f68		c3			RET			
		evacuate_fast32(t, h, h.nevacuate)
  0x407f69		488b4820		MOVQ 0x20(AX), CX			
  0x407f6d		48894c2410		MOVQ CX, 0x10(SP)			
  0x407f72		488b4c2428		MOVQ 0x28(SP), CX			
  0x407f77		48890c24		MOVQ CX, 0(SP)				
  0x407f7b		4889442408		MOVQ AX, 0x8(SP)			
  0x407f80		e81b000000		CALL runtime.evacuate_fast32(SB)	
  0x407f85		ebd8			JMP 0x407f5f				
		oldB--
  0x407f87		ffca			DECL DX			
  0x407f89		eb98			JMP 0x407f23		
func growWork_fast32(t *maptype, h *hmap, bucket uintptr) {
  0x407f8b		e8e0c50300		CALL runtime.morestack_noctxt(SB)	
  0x407f90		e95bffffff		JMP runtime.growWork_fast32(SB)		

TEXT runtime.evacuate_fast32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/hashmap_fast.go
func evacuate_fast32(t *maptype, h *hmap, oldbucket uintptr) {
  0x407fa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407fa9		488d4424e0		LEAQ -0x20(SP), AX	
  0x407fae		483b4110		CMPQ 0x10(CX), AX	
  0x407fb2		0f86fb030000		JBE 0x4083b3		
  0x407fb8		4881eca0000000		SUBQ $0xa0, SP		
  0x407fbf		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x407fc7		488dac2498000000	LEAQ 0x98(SP), BP	
  0x407fcf		0f57c0			XORPS X0, X0		
  0x407fd2		0f11442458		MOVUPS X0, 0x58(SP)	
  0x407fd7		0f11442468		MOVUPS X0, 0x68(SP)	
  0x407fdc		0f11442478		MOVUPS X0, 0x78(SP)	
  0x407fe1		0f11842488000000	MOVUPS X0, 0x88(SP)	
  0x407fe9		488b8424b0000000	MOVQ 0xb0(SP), AX	
	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
  0x407ff1		488d5818		LEAQ 0x18(AX), BX	
  0x407ff5		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x407ffd		0fb77e54		MOVZX 0x54(SI), DI	
  0x408001		4c8b8424b8000000	MOVQ 0xb8(SP), R8	
  0x408009		490faff8		IMULQ R8, DI		
	return unsafe.Pointer(uintptr(p) + x)
  0x40800d		48033b			ADDQ 0(BX), DI		
	oldB := h.B
  0x408010		0fb65809		MOVZX 0x9(AX), BX	
	return h.flags&sameSizeGrow != 0
  0x408014		440fb64808		MOVZX 0x8(AX), R9	
  0x408019		41f6c108		TESTL $0x8, R9		
	if !h.sameSizeGrow() {
  0x40801d		0f8467030000		JE 0x40838a		
  0x408023		89d9			MOVL BX, CX		
	return uintptr(1) << b
  0x408025		41b901000000		MOVL $0x1, R9		
  0x40802b		49d3e1			SHLQ CL, R9		
	h := b.tophash[0]
  0x40802e		440fb617		MOVZX 0(DI), R10	
	return h > empty && h < minTopHash
  0x408032		41ffca			DECL R10		
  0x408035		4180fa03		CMPL $0x3, R10		
	if !evacuated(b) {
  0x408039		0f829e020000		JB 0x4082dd		
		var xy [2]evacDst
  0x40803f		0f57c0			XORPS X0, X0		
  0x408042		0f11442458		MOVUPS X0, 0x58(SP)	
  0x408047		0f11442468		MOVUPS X0, 0x68(SP)	
  0x40804c		0f11442478		MOVUPS X0, 0x78(SP)	
  0x408051		0f11842488000000	MOVUPS X0, 0x88(SP)	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x408059		4c8d542458		LEAQ 0x58(SP), R10	
  0x40805e		418402			TESTB AL, 0(R10)	
  0x408061		440fb75654		MOVZX 0x54(SI), R10	
  0x408066		4d0fafd0		IMULQ R8, R10		
	return unsafe.Pointer(uintptr(p) + x)
  0x40806a		4c035010		ADDQ 0x10(AX), R10	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x40806e		4c89542458		MOVQ R10, 0x58(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x408073		4d8d5a08		LEAQ 0x8(R10), R11	
		x.k = add(unsafe.Pointer(x.b), dataOffset)
  0x408077		4c895c2468		MOVQ R11, 0x68(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x40807c		4983c228		ADDQ $0x28, R10		
		x.v = add(x.k, bucketCnt*4)
  0x408080		4c89542470		MOVQ R10, 0x70(SP)	
	return h.flags&sameSizeGrow != 0
  0x408085		440fb65008		MOVZX 0x8(AX), R10	
  0x40808a		41f6c208		TESTL $0x8, R10		
		if !h.sameSizeGrow() {
  0x40808e		0f84bb020000		JE 0x40834f		
  0x408094		884c2427		MOVB CL, 0x27(SP)	
  0x408098		4c894c2438		MOVQ R9, 0x38(SP)	
		for ; b != nil; b = b.overflow(t) {
  0x40809d		e90c020000		JMP 0x4082ae		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x4080a2		48ffc2			INCQ DX			
  0x4080a5		440fb66652		MOVZX 0x52(SI), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x4080aa		4983c204		ADDQ $0x4, R10		
  0x4080ae		4d01e3			ADDQ R12, R11		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x4080b1		4883fa08		CMPQ $0x8, DX		
  0x4080b5		0f8de6010000		JGE 0x4082a1		
				top := b.tophash[i]
  0x4080bb		440fb62417		MOVZX 0(DI)(DX*1), R12	
				if top == empty {
  0x4080c0		4584e4			TESTL R12, R12		
  0x4080c3		7506			JNE 0x4080cb		
					b.tophash[i] = evacuatedEmpty
  0x4080c5		c6041701		MOVB $0x1, 0(DI)(DX*1)	
					continue
  0x4080c9		ebd7			JMP 0x4080a2		
				if top < minTopHash {
  0x4080cb		4180fc04		CMPL $0x4, R12		
  0x4080cf		0f82c3020000		JB 0x408398		
  0x4080d5		4889542428		MOVQ DX, 0x28(SP)	
  0x4080da		4488642426		MOVB R12, 0x26(SP)	
  0x4080df		4c895c2440		MOVQ R11, 0x40(SP)	
  0x4080e4		4c89542448		MOVQ R10, 0x48(SP)	
	return h.flags&sameSizeGrow != 0
  0x4080e9		440fb66808		MOVZX 0x8(AX), R13	
  0x4080ee		41f6c508		TESTL $0x8, R13		
				if !h.sameSizeGrow() {
  0x4080f2		0f843d010000		JE 0x408235		
  0x4080f8		4531ed			XORL R13, R13		
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY, enforced in makemap
  0x4080fb		458d7502		LEAL 0x2(R13), R14	
  0x4080ff		44883417		MOVB R14, 0(DI)(DX*1)	
				dst := &xy[useY]                 // evacuation destination
  0x408103		450fb6ed		MOVZX R13, R13		
  0x408107		4983fd02		CMPQ $0x2, R13		
  0x40810b		0f8380020000		JAE 0x408391		
  0x408111		49c1e505		SHLQ $0x5, R13		
  0x408115		4c896c2430		MOVQ R13, 0x30(SP)	
				if dst.i == bucketCnt {
  0x40811a		4e8b742c60		MOVQ 0x60(SP)(R13*1), R14	
  0x40811f		4983fe08		CMPQ $0x8, R14			
  0x408123		0f84a8000000		JE 0x4081d1			
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x408129		4a8b442c58		MOVQ 0x58(SP)(R13*1), AX	
  0x40812e		8400			TESTB AL, 0(AX)			
  0x408130		4a8b4c2c60		MOVQ 0x60(SP)(R13*1), CX	
  0x408135		4883e107		ANDQ $0x7, CX			
  0x408139		44882408		MOVB R12, 0(AX)(CX*1)		
					*(*uint32)(dst.k) = *(*uint32)(k)
  0x40813d		4a8b442c68		MOVQ 0x68(SP)(R13*1), AX	
  0x408142		418b0a			MOVL 0(R10), CX			
  0x408145		8908			MOVL CX, 0(AX)			
				typedmemmove(t.elem, dst.v, v)
  0x408147		488b4638		MOVQ 0x38(SI), AX		
  0x40814b		4a8b4c2c70		MOVQ 0x70(SP)(R13*1), CX	
  0x408150		48894c2408		MOVQ CX, 0x8(SP)		
  0x408155		48890424		MOVQ AX, 0(SP)			
  0x408159		4c895c2410		MOVQ R11, 0x10(SP)		
  0x40815e		e82d390000		CALL runtime.typedmemmove(SB)	
  0x408163		488b442430		MOVQ 0x30(SP), AX		
				dst.i++
  0x408168		488b4c0460		MOVQ 0x60(SP)(AX*1), CX	
  0x40816d		48ffc1			INCQ CX			
  0x408170		48894c0460		MOVQ CX, 0x60(SP)(AX*1)	
				dst.k = add(dst.k, 4)
  0x408175		488b4c0468		MOVQ 0x68(SP)(AX*1), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40817a		4883c104		ADDQ $0x4, CX		
				dst.k = add(dst.k, 4)
  0x40817e		48894c0468		MOVQ CX, 0x68(SP)(AX*1)	
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x408183		488b4c0470		MOVQ 0x70(SP)(AX*1), CX	
  0x408188		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x408190		0fb65652		MOVZX 0x52(SI), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x408194		4801d1			ADDQ DX, CX		
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x408197		48894c0470		MOVQ CX, 0x70(SP)(AX*1)	
  0x40819c		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x4081a4		0fb64c2427		MOVZX 0x27(SP), CX	
  0x4081a9		488b542428		MOVQ 0x28(SP), DX	
  0x4081ae		89cb			MOVL CX, BX		
  0x4081b0		488b7c2450		MOVQ 0x50(SP), DI	
  0x4081b5		4c8b8424b8000000	MOVQ 0xb8(SP), R8	
  0x4081bd		4c8b4c2438		MOVQ 0x38(SP), R9	
  0x4081c2		4c8b542448		MOVQ 0x48(SP), R10	
  0x4081c7		4c8b5c2440		MOVQ 0x40(SP), R11	
  0x4081cc		e9d1feffff		JMP 0x4080a2		
					dst.b = h.newoverflow(t, dst.b)
  0x4081d1		4a8b4c2c58		MOVQ 0x58(SP)(R13*1), CX		
  0x4081d6		48894c2410		MOVQ CX, 0x10(SP)			
  0x4081db		48890424		MOVQ AX, 0(SP)				
  0x4081df		4889742408		MOVQ SI, 0x8(SP)			
  0x4081e4		e8a7ddffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x4081e9		488b442418		MOVQ 0x18(SP), AX			
  0x4081ee		4c8b6c2430		MOVQ 0x30(SP), R13			
  0x4081f3		4a89442c58		MOVQ AX, 0x58(SP)(R13*1)		
					dst.i = 0
  0x4081f8		4ac7442c6000000000	MOVQ $0x0, 0x60(SP)(R13*1)	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x408201		4a8b442c58		MOVQ 0x58(SP)(R13*1), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x408206		488d4808		LEAQ 0x8(AX), CX	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x40820a		4a894c2c68		MOVQ CX, 0x68(SP)(R13*1)	
	return unsafe.Pointer(uintptr(p) + x)
  0x40820f		4883c028		ADDQ $0x28, AX		
					dst.v = add(dst.k, bucketCnt*4)
  0x408213		4a89442c70		MOVQ AX, 0x70(SP)(R13*1)	
  0x408218		488bb424a8000000	MOVQ 0xa8(SP), SI		
  0x408220		4c8b542448		MOVQ 0x48(SP), R10		
  0x408225		4c8b5c2440		MOVQ 0x40(SP), R11		
  0x40822a		440fb6642426		MOVZX 0x26(SP), R12		
  0x408230		e9f4feffff		JMP 0x408129			
					hash := t.key.alg.hash(k, uintptr(h.hash0))
  0x408235		488b4e30		MOVQ 0x30(SI), CX	
  0x408239		488b4918		MOVQ 0x18(CX), CX	
  0x40823d		488b11			MOVQ 0(CX), DX		
  0x408240		8b480c			MOVL 0xc(AX), CX	
  0x408243		48894c2408		MOVQ CX, 0x8(SP)	
  0x408248		4c891424		MOVQ R10, 0(SP)		
  0x40824c		488b0a			MOVQ 0(DX), CX		
  0x40824f		ffd1			CALL CX			
  0x408251		488b442410		MOVQ 0x10(SP), AX	
  0x408256		0fb65c2427		MOVZX 0x27(SP), BX	
					if hash&newbit != 0 {
  0x40825b		480fa3d8		BTQ BX, AX		
  0x40825f		410f92c5		SETB R13		
  0x408263		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x40826b		89d9			MOVL BX, CX		
  0x40826d		488b542428		MOVQ 0x28(SP), DX	
  0x408272		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x40827a		488b7c2450		MOVQ 0x50(SP), DI	
  0x40827f		4c8b8424b8000000	MOVQ 0xb8(SP), R8	
  0x408287		4c8b4c2438		MOVQ 0x38(SP), R9	
  0x40828c		4c8b542448		MOVQ 0x48(SP), R10	
  0x408291		4c8b5c2440		MOVQ 0x40(SP), R11	
  0x408296		440fb6642426		MOVZX 0x26(SP), R12	
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY, enforced in makemap
  0x40829c		e95afeffff		JMP 0x4080fb		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x4082a1		440fb75654		MOVZX 0x54(SI), R10	
	return unsafe.Pointer(uintptr(p) + x)
  0x4082a6		4e8d5417f8		LEAQ -0x8(DI)(R10*1), R10	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x4082ab		498b3a			MOVQ 0(R10), DI		
		for ; b != nil; b = b.overflow(t) {
  0x4082ae		4885ff			TESTQ DI, DI		
  0x4082b1		7414			JE 0x4082c7		
  0x4082b3		48897c2450		MOVQ DI, 0x50(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x4082b8		4c8d5708		LEAQ 0x8(DI), R10	
  0x4082bc		4c8d5f28		LEAQ 0x28(DI), R11	
  0x4082c0		31d2			XORL DX, DX		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x4082c2		e9eafdffff		JMP 0x4080b1		
		if h.flags&oldIterator == 0 && t.bucket.kind&kindNoPointers == 0 {
  0x4082c7		0fb64808		MOVZX 0x8(AX), CX	
  0x4082cb		f6c102			TESTL $0x2, CL		
  0x4082ce		750d			JNE 0x4082dd		
  0x4082d0		488b4e40		MOVQ 0x40(SI), CX	
  0x4082d4		0fb64917		MOVZX 0x17(CX), CX	
  0x4082d8		f6c180			TESTL $0x80, CL		
  0x4082db		742e			JE 0x40830b		
	if oldbucket == h.nevacuate {
  0x4082dd		488b4820		MOVQ 0x20(AX), CX	
  0x4082e1		4939c8			CMPQ CX, R8		
  0x4082e4		7410			JE 0x4082f6		
  0x4082e6		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4082ee		4881c4a0000000		ADDQ $0xa0, SP		
  0x4082f5		c3			RET			
		advanceEvacuationMark(h, t, newbit)
  0x4082f6		48890424		MOVQ AX, 0(SP)				
  0x4082fa		4889742408		MOVQ SI, 0x8(SP)			
  0x4082ff		4c894c2410		MOVQ R9, 0x10(SP)			
  0x408304		e867f4ffff		CALL runtime.advanceEvacuationMark(SB)	
  0x408309		ebdb			JMP 0x4082e6				
			b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
  0x40830b		0fb74e54		MOVZX 0x54(SI), CX	
  0x40830f		4889ca			MOVQ CX, DX		
  0x408312		490fafc8		IMULQ R8, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x408316		48034818		ADDQ 0x18(AX), CX	
  0x40831a		4883c108		ADDQ $0x8, CX		
			memclrHasPointers(ptr, n)
  0x40831e		48890c24		MOVQ CX, 0(SP)		
			n := uintptr(t.bucketsize) - dataOffset
  0x408322		488d4af8		LEAQ -0x8(DX), CX	
			memclrHasPointers(ptr, n)
  0x408326		48894c2408		MOVQ CX, 0x8(SP)			
  0x40832b		e8503a0000		CALL runtime.memclrHasPointers(SB)	
  0x408330		488b8424b0000000	MOVQ 0xb0(SP), AX			
  0x408338		488bb424a8000000	MOVQ 0xa8(SP), SI			
  0x408340		4c8b8424b8000000	MOVQ 0xb8(SP), R8			
  0x408348		4c8b4c2438		MOVQ 0x38(SP), R9			
  0x40834d		eb8e			JMP 0x4082dd				
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x40834f		4c8d542478		LEAQ 0x78(SP), R10	
  0x408354		418402			TESTB AL, 0(R10)	
  0x408357		4f8d1401		LEAQ 0(R9)(R8*1), R10	
  0x40835b		440fb75e54		MOVZX 0x54(SI), R11	
  0x408360		4d0fafda		IMULQ R10, R11		
	return unsafe.Pointer(uintptr(p) + x)
  0x408364		4c035810		ADDQ 0x10(AX), R11	
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x408368		4c895c2478		MOVQ R11, 0x78(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x40836d		4d8d5308		LEAQ 0x8(R11), R10	
			y.k = add(unsafe.Pointer(y.b), dataOffset)
  0x408371		4c89942488000000	MOVQ R10, 0x88(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x408379		4d8d5328		LEAQ 0x28(R11), R10	
			y.v = add(y.k, bucketCnt*4)
  0x40837d		4c89942490000000	MOVQ R10, 0x90(SP)	
  0x408385		e90afdffff		JMP 0x408094		
		oldB--
  0x40838a		ffcb			DECL BX			
  0x40838c		e992fcffff		JMP 0x408023		
				dst := &xy[useY]                 // evacuation destination
  0x408391		e8aa760100		CALL runtime.panicindex(SB)	
  0x408396		0f0b			UD2				
					throw("bad map state")
  0x408398		488d0595230600		LEAQ 0x62395(IP), AX	
  0x40839f		48890424		MOVQ AX, 0(SP)		
  0x4083a3		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x4083ac		e81f8e0100		CALL runtime.throw(SB)	
  0x4083b1		0f0b			UD2			
func evacuate_fast32(t *maptype, h *hmap, oldbucket uintptr) {
  0x4083b3		e8b8c10300		CALL runtime.morestack_noctxt(SB)	
  0x4083b8		e9e3fbffff		JMP runtime.evacuate_fast32(SB)		

TEXT runtime.getitab(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x4083c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4083c9		483b6110		CMPQ 0x10(CX), SP	
  0x4083cd		0f8676040000		JBE 0x408849		
  0x4083d3		4883ec70		SUBQ $0x70, SP		
  0x4083d7		48896c2468		MOVQ BP, 0x68(SP)	
  0x4083dc		488d6c2468		LEAQ 0x68(SP), BP	
  0x4083e1		488b442478		MOVQ 0x78(SP), AX	
	if len(inter.mhdr) == 0 {
  0x4083e6		488b4840		MOVQ 0x40(AX), CX	
  0x4083ea		488b5038		MOVQ 0x38(AX), DX	
  0x4083ee		4885c9			TESTQ CX, CX		
  0x4083f1		0f8437040000		JE 0x40882e		
  0x4083f7		488b8c2480000000	MOVQ 0x80(SP), CX	
	if typ.tflag&tflagUncommon == 0 {
  0x4083ff		0fb65914		MOVZX 0x14(CX), BX	
  0x408403		f6c301			TESTL $0x1, BL		
  0x408406		0f8557010000		JNE 0x408563		
  0x40840c		0fb69c2488000000	MOVZX 0x88(SP), BX	
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x408414		84db			TESTL BL, BL		
		if canfail {
  0x408416		7416			JE 0x40842e		
			return nil
  0x408418		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x408424		488b6c2468			MOVQ 0x68(SP), BP	
  0x408429		4883c470			ADDQ $0x70, SP		
  0x40842d		c3				RET			
		name := inter.typ.nameOff(inter.mhdr[0].name)
  0x40842e		8b0a			MOVL 0(DX), CX				
  0x408430		894c2408		MOVL CX, 0x8(SP)			
  0x408434		48890424		MOVQ AX, 0(SP)				
  0x408438		e8f3690300		CALL runtime.(*_type).nameOff(SB)	
  0x40843d		488b442410		MOVQ 0x10(SP), AX			
  0x408442		4889442460		MOVQ AX, 0x60(SP)			
  0x408447		488b8c2480000000	MOVQ 0x80(SP), CX			
		panic(&TypeAssertionError{"", typ.string(), inter.typ.string(), name.name()})
  0x40844f		48890c24		MOVQ CX, 0(SP)				
  0x408453		e818650300		CALL runtime.(*_type).string(SB)	
  0x408458		488b442410		MOVQ 0x10(SP), AX			
  0x40845d		4889442430		MOVQ AX, 0x30(SP)			
  0x408462		488b4c2408		MOVQ 0x8(SP), CX			
  0x408467		48894c2458		MOVQ CX, 0x58(SP)			
  0x40846c		488b542478		MOVQ 0x78(SP), DX			
  0x408471		48891424		MOVQ DX, 0(SP)				
  0x408475		e8f6640300		CALL runtime.(*_type).string(SB)	
  0x40847a		488b442408		MOVQ 0x8(SP), AX			
  0x40847f		4889442450		MOVQ AX, 0x50(SP)			
  0x408484		488b4c2410		MOVQ 0x10(SP), CX			
  0x408489		48894c2428		MOVQ CX, 0x28(SP)			
  0x40848e		488b542460		MOVQ 0x60(SP), DX			
  0x408493		48891424		MOVQ DX, 0(SP)				
  0x408497		e8f4700300		CALL runtime.name.name(SB)		
  0x40849c		488b442410		MOVQ 0x10(SP), AX			
  0x4084a1		4889442420		MOVQ AX, 0x20(SP)			
  0x4084a6		488b4c2408		MOVQ 0x8(SP), CX			
  0x4084ab		48894c2448		MOVQ CX, 0x48(SP)			
  0x4084b0		488d15498e0500		LEAQ 0x58e49(IP), DX			
  0x4084b7		48891424		MOVQ DX, 0(SP)				
  0x4084bb		e8602c0000		CALL runtime.newobject(SB)		
  0x4084c0		488b442408		MOVQ 0x8(SP), AX			
  0x4084c5		488b4c2430		MOVQ 0x30(SP), CX			
  0x4084ca		48894818		MOVQ CX, 0x18(AX)			
  0x4084ce		8b0d3cb50b00		MOVL runtime.writeBarrier(SB), CX	
  0x4084d4		488d7810		LEAQ 0x10(AX), DI			
  0x4084d8		85c9			TESTL CX, CX				
  0x4084da		7575			JNE 0x408551				
  0x4084dc		488b4c2458		MOVQ 0x58(SP), CX			
  0x4084e1		48894810		MOVQ CX, 0x10(AX)			
  0x4084e5		488b4c2428		MOVQ 0x28(SP), CX			
  0x4084ea		48894828		MOVQ CX, 0x28(AX)			
  0x4084ee		8b0d1cb50b00		MOVL runtime.writeBarrier(SB), CX	
  0x4084f4		488d7820		LEAQ 0x20(AX), DI			
  0x4084f8		85c9			TESTL CX, CX				
  0x4084fa		7543			JNE 0x40853f				
  0x4084fc		488b4c2450		MOVQ 0x50(SP), CX			
  0x408501		48894820		MOVQ CX, 0x20(AX)			
  0x408505		488b4c2420		MOVQ 0x20(SP), CX			
  0x40850a		48894838		MOVQ CX, 0x38(AX)			
  0x40850e		8b0dfcb40b00		MOVL runtime.writeBarrier(SB), CX	
  0x408514		488d7830		LEAQ 0x30(AX), DI			
  0x408518		85c9			TESTL CX, CX				
  0x40851a		7511			JNE 0x40852d				
  0x40851c		488b4c2448		MOVQ 0x48(SP), CX			
  0x408521		48894830		MOVQ CX, 0x30(AX)			
  0x408525		4889c1			MOVQ AX, CX				
  0x408528		e9ea020000		JMP 0x408817				
  0x40852d		4889c1			MOVQ AX, CX				
  0x408530		488b442448		MOVQ 0x48(SP), AX			
  0x408535		e866e30300		CALL runtime.gcWriteBarrier(SB)		
  0x40853a		e9d8020000		JMP 0x408817				
  0x40853f		4889c1			MOVQ AX, CX				
  0x408542		488b442450		MOVQ 0x50(SP), AX			
  0x408547		e854e30300		CALL runtime.gcWriteBarrier(SB)		
  0x40854c		4889c8			MOVQ CX, AX				
  0x40854f		ebb4			JMP 0x408505				
  0x408551		4889c1			MOVQ AX, CX				
  0x408554		488b442458		MOVQ 0x58(SP), AX			
  0x408559		e842e30300		CALL runtime.gcWriteBarrier(SB)		
  0x40855e		4889c8			MOVQ CX, AX				
  0x408561		eb82			JMP 0x4084e5				
	t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&itabTable)))
  0x408563		488b15bed40900		MOVQ runtime.itabTable(SB), DX	
	if m = t.find(inter, typ); m != nil {
  0x40856a		48891424		MOVQ DX, 0(SP)				
  0x40856e		4889442408		MOVQ AX, 0x8(SP)			
  0x408573		48894c2410		MOVQ CX, 0x10(SP)			
  0x408578		e8e3020000		CALL runtime.(*itabTableType).find(SB)	
  0x40857d		488b442418		MOVQ 0x18(SP), AX			
  0x408582		4885c0			TESTQ AX, AX				
  0x408585		0f8462010000		JE 0x4086ed				
	if m.fun[0] != 0 {
  0x40858b		488b4818		MOVQ 0x18(AX), CX	
  0x40858f		4885c9			TESTQ CX, CX		
  0x408592		0f8543010000		JNE 0x4086db		
  0x408598		0fb68c2488000000	MOVZX 0x88(SP), CX	
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x4085a0		84c9			TESTL CL, CL		
	if canfail {
  0x4085a2		7416			JE 0x4085ba		
		return nil
  0x4085a4		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x4085b0		488b6c2468			MOVQ 0x68(SP), BP	
  0x4085b5		4883c470			ADDQ $0x70, SP		
  0x4085b9		c3				RET			
  0x4085ba		4889442438			MOVQ AX, 0x38(SP)	
  0x4085bf		488b842480000000		MOVQ 0x80(SP), AX	
	panic(&TypeAssertionError{concreteString: typ.string(), assertedString: inter.typ.string(), missingMethod: m.init()})
  0x4085c7		48890424		MOVQ AX, 0(SP)				
  0x4085cb		e8a0630300		CALL runtime.(*_type).string(SB)	
  0x4085d0		488b442410		MOVQ 0x10(SP), AX			
  0x4085d5		4889442430		MOVQ AX, 0x30(SP)			
  0x4085da		488b4c2408		MOVQ 0x8(SP), CX			
  0x4085df		48894c2458		MOVQ CX, 0x58(SP)			
  0x4085e4		488b542478		MOVQ 0x78(SP), DX			
  0x4085e9		48891424		MOVQ DX, 0(SP)				
  0x4085ed		e87e630300		CALL runtime.(*_type).string(SB)	
  0x4085f2		488b442410		MOVQ 0x10(SP), AX			
  0x4085f7		4889442428		MOVQ AX, 0x28(SP)			
  0x4085fc		488b4c2408		MOVQ 0x8(SP), CX			
  0x408601		48894c2450		MOVQ CX, 0x50(SP)			
  0x408606		488b542438		MOVQ 0x38(SP), DX			
  0x40860b		48891424		MOVQ DX, 0(SP)				
  0x40860f		e85c040000		CALL runtime.(*itab).init(SB)		
  0x408614		488b442410		MOVQ 0x10(SP), AX			
  0x408619		4889442420		MOVQ AX, 0x20(SP)			
  0x40861e		488b4c2408		MOVQ 0x8(SP), CX			
  0x408623		48894c2448		MOVQ CX, 0x48(SP)			
  0x408628		488d15d18c0500		LEAQ 0x58cd1(IP), DX			
  0x40862f		48891424		MOVQ DX, 0(SP)				
  0x408633		e8e82a0000		CALL runtime.newobject(SB)		
  0x408638		488b442408		MOVQ 0x8(SP), AX			
  0x40863d		488b4c2430		MOVQ 0x30(SP), CX			
  0x408642		48894818		MOVQ CX, 0x18(AX)			
  0x408646		8b0dc4b30b00		MOVL runtime.writeBarrier(SB), CX	
  0x40864c		488d7810		LEAQ 0x10(AX), DI			
  0x408650		85c9			TESTL CX, CX				
  0x408652		7575			JNE 0x4086c9				
  0x408654		488b4c2458		MOVQ 0x58(SP), CX			
  0x408659		48894810		MOVQ CX, 0x10(AX)			
  0x40865d		488b4c2428		MOVQ 0x28(SP), CX			
  0x408662		48894828		MOVQ CX, 0x28(AX)			
  0x408666		8b0da4b30b00		MOVL runtime.writeBarrier(SB), CX	
  0x40866c		488d7820		LEAQ 0x20(AX), DI			
  0x408670		85c9			TESTL CX, CX				
  0x408672		7543			JNE 0x4086b7				
  0x408674		488b4c2450		MOVQ 0x50(SP), CX			
  0x408679		48894820		MOVQ CX, 0x20(AX)			
  0x40867d		488b4c2420		MOVQ 0x20(SP), CX			
  0x408682		48894838		MOVQ CX, 0x38(AX)			
  0x408686		8b0d84b30b00		MOVL runtime.writeBarrier(SB), CX	
  0x40868c		488d7830		LEAQ 0x30(AX), DI			
  0x408690		85c9			TESTL CX, CX				
  0x408692		7511			JNE 0x4086a5				
  0x408694		488b4c2448		MOVQ 0x48(SP), CX			
  0x408699		48894830		MOVQ CX, 0x30(AX)			
  0x40869d		4889c1			MOVQ AX, CX				
  0x4086a0		e95b010000		JMP 0x408800				
  0x4086a5		4889c1			MOVQ AX, CX				
  0x4086a8		488b442448		MOVQ 0x48(SP), AX			
  0x4086ad		e8eee10300		CALL runtime.gcWriteBarrier(SB)		
  0x4086b2		e949010000		JMP 0x408800				
  0x4086b7		4889c1			MOVQ AX, CX				
  0x4086ba		488b442450		MOVQ 0x50(SP), AX			
  0x4086bf		e8dce10300		CALL runtime.gcWriteBarrier(SB)		
  0x4086c4		4889c8			MOVQ CX, AX				
  0x4086c7		ebb4			JMP 0x40867d				
  0x4086c9		4889c1			MOVQ AX, CX				
  0x4086cc		488b442458		MOVQ 0x58(SP), AX			
  0x4086d1		e8cae10300		CALL runtime.gcWriteBarrier(SB)		
  0x4086d6		4889c8			MOVQ CX, AX				
  0x4086d9		eb82			JMP 0x40865d				
		return m
  0x4086db		4889842490000000	MOVQ AX, 0x90(SP)	
  0x4086e3		488b6c2468		MOVQ 0x68(SP), BP	
  0x4086e8		4883c470		ADDQ $0x70, SP		
  0x4086ec		c3			RET			
	lock(&itabLock)
  0x4086ed		488d058cb20b00		LEAQ runtime.itabLock(SB), AX	
  0x4086f4		48890424		MOVQ AX, 0(SP)			
  0x4086f8		e8230e0000		CALL runtime.lock(SB)		
	if m = itabTable.find(inter, typ); m != nil {
  0x4086fd		488b0524d30900		MOVQ runtime.itabTable(SB), AX		
  0x408704		48890424		MOVQ AX, 0(SP)				
  0x408708		488b442478		MOVQ 0x78(SP), AX			
  0x40870d		4889442408		MOVQ AX, 0x8(SP)			
  0x408712		488b8c2480000000	MOVQ 0x80(SP), CX			
  0x40871a		48894c2410		MOVQ CX, 0x10(SP)			
  0x40871f		e83c010000		CALL runtime.(*itabTableType).find(SB)	
  0x408724		488b442418		MOVQ 0x18(SP), AX			
  0x408729		4885c0			TESTQ AX, AX				
  0x40872c		741f			JE 0x40874d				
  0x40872e		4889442438		MOVQ AX, 0x38(SP)			
		unlock(&itabLock)
  0x408733		488d0546b20b00		LEAQ runtime.itabLock(SB), AX	
  0x40873a		48890424		MOVQ AX, 0(SP)			
  0x40873e		e87d0f0000		CALL runtime.unlock(SB)		
  0x408743		488b442438		MOVQ 0x38(SP), AX		
		goto finish
  0x408748		e93efeffff		JMP 0x40858b		
  0x40874d		488b442478		MOVQ 0x78(SP), AX	
	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))
  0x408752		488b4840		MOVQ 0x40(AX), CX			
  0x408756		48ffc9			DECQ CX					
  0x408759		48c1e103		SHLQ $0x3, CX				
  0x40875d		4883c120		ADDQ $0x20, CX				
  0x408761		48890c24		MOVQ CX, 0(SP)				
  0x408765		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x40876e		488d0d2bc00b00		LEAQ runtime.memstats+160(SB), CX	
  0x408775		48894c2410		MOVQ CX, 0x10(SP)			
  0x40877a		e8212d0000		CALL runtime.persistentalloc(SB)	
  0x40877f		488b7c2418		MOVQ 0x18(SP), DI			
	m.inter = inter
  0x408784		8407			TESTB AL, 0(DI)				
  0x408786		8b0584b20b00		MOVL runtime.writeBarrier(SB), AX	
	m._type = typ
  0x40878c		488d4f08		LEAQ 0x8(DI), CX	
	m.inter = inter
  0x408790		85c0			TESTL AX, AX		
  0x408792		754a			JNE 0x4087de		
  0x408794		488b442478		MOVQ 0x78(SP), AX	
  0x408799		488907			MOVQ AX, 0(DI)		
  0x40879c		488b8c2480000000	MOVQ 0x80(SP), CX	
	m._type = typ
  0x4087a4		48894f08		MOVQ CX, 0x8(DI)	
	m.inter = inter
  0x4087a8		48897c2440		MOVQ DI, 0x40(SP)	
	m.init()
  0x4087ad		48893c24		MOVQ DI, 0(SP)			
  0x4087b1		e8ba020000		CALL runtime.(*itab).init(SB)	
  0x4087b6		488b442440		MOVQ 0x40(SP), AX		
	itabAdd(m)
  0x4087bb		48890424		MOVQ AX, 0(SP)			
  0x4087bf		e8fc000000		CALL runtime.itabAdd(SB)	
	unlock(&itabLock)
  0x4087c4		488d05b5b10b00		LEAQ runtime.itabLock(SB), AX	
  0x4087cb		48890424		MOVQ AX, 0(SP)			
  0x4087cf		e8ec0e0000		CALL runtime.unlock(SB)		
  0x4087d4		488b442440		MOVQ 0x40(SP), AX		
finish:
  0x4087d9		e9adfdffff		JMP 0x40858b		
  0x4087de		488b442478		MOVQ 0x78(SP), AX	
	m.inter = inter
  0x4087e3		e8b8e00300		CALL runtime.gcWriteBarrier(SB)	
  0x4087e8		4889fa			MOVQ DI, DX			
  0x4087eb		4889cf			MOVQ CX, DI			
  0x4087ee		488b842480000000	MOVQ 0x80(SP), AX		
	m._type = typ
  0x4087f6		e8a5e00300		CALL runtime.gcWriteBarrier(SB)	
  0x4087fb		4889d7			MOVQ DX, DI			
	m.inter = inter
  0x4087fe		eba8			JMP 0x4087a8		
	panic(&TypeAssertionError{concreteString: typ.string(), assertedString: inter.typ.string(), missingMethod: m.init()})
  0x408800		488d05d9290500		LEAQ 0x529d9(IP), AX		
  0x408807		48890424		MOVQ AX, 0(SP)			
  0x40880b		48894c2408		MOVQ CX, 0x8(SP)		
  0x408810		e81b820100		CALL runtime.gopanic(SB)	
  0x408815		0f0b			UD2				
		panic(&TypeAssertionError{"", typ.string(), inter.typ.string(), name.name()})
  0x408817		488d05c2290500		LEAQ 0x529c2(IP), AX		
  0x40881e		48890424		MOVQ AX, 0(SP)			
  0x408822		48894c2408		MOVQ CX, 0x8(SP)		
  0x408827		e804820100		CALL runtime.gopanic(SB)	
  0x40882c		0f0b			UD2				
		throw("internal error - misuse of itab")
  0x40882e		488d05953e0600		LEAQ 0x63e95(IP), AX	
  0x408835		48890424		MOVQ AX, 0(SP)		
  0x408839		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x408842		e889890100		CALL runtime.throw(SB)	
  0x408847		0f0b			UD2			
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x408849		e822bd0300		CALL runtime.morestack_noctxt(SB)	
  0x40884e		e96dfbffff		JMP runtime.getitab(SB)			

TEXT runtime.(*itabTableType).find(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func (t *itabTableType) find(inter *interfacetype, typ *_type) *itab {
  0x408860		488b442408		MOVQ 0x8(SP), AX	
	mask := t.size - 1
  0x408865		488b08			MOVQ 0(AX), CX		
  0x408868		48ffc9			DECQ CX			
  0x40886b		488b542410		MOVQ 0x10(SP), DX	
	return uintptr(inter.typ.hash ^ typ.hash)
  0x408870		8b5a10			MOVL 0x10(DX), BX	
  0x408873		488b742418		MOVQ 0x18(SP), SI	
  0x408878		335e10			XORL 0x10(SI), BX	
	h := itabHashFunc(inter, typ) & mask
  0x40887b		4821cb			ANDQ CX, BX		
  0x40887e		bf01000000		MOVL $0x1, DI		
	for i := uintptr(1); ; i++ {
  0x408883		eb0d			JMP 0x408892		
  0x408885		4c8d4701		LEAQ 0x1(DI), R8	
		h += i
  0x408889		4801fb			ADDQ DI, BX		
		h &= mask
  0x40888c		4821cb			ANDQ CX, BX		
  0x40888f		4c89c7			MOVQ R8, DI		
	return unsafe.Pointer(uintptr(p) + x)
  0x408892		4c8d44d810		LEAQ 0x10(AX)(BX*8), R8	
		m := (*itab)(atomic.Loadp(unsafe.Pointer(p)))
  0x408897		4d8b00			MOVQ 0(R8), R8		
		if m == nil {
  0x40889a		4d85c0			TESTQ R8, R8		
  0x40889d		7417			JE 0x4088b6		
		if m.inter == inter && m._type == typ {
  0x40889f		4d8b08			MOVQ 0(R8), R9		
  0x4088a2		4939d1			CMPQ DX, R9		
  0x4088a5		75de			JNE 0x408885		
  0x4088a7		4d8b4808		MOVQ 0x8(R8), R9	
  0x4088ab		4939f1			CMPQ SI, R9		
  0x4088ae		75d5			JNE 0x408885		
			return m
  0x4088b0		4c89442420		MOVQ R8, 0x20(SP)	
  0x4088b5		c3			RET			
			return nil
  0x4088b6		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x4088bf		c3			RET			

TEXT runtime.itabAdd(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func itabAdd(m *itab) {
  0x4088c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4088c9		483b6110		CMPQ 0x10(CX), SP	
  0x4088cd		0f8630010000		JBE 0x408a03		
  0x4088d3		4883ec48		SUBQ $0x48, SP		
  0x4088d7		48896c2440		MOVQ BP, 0x40(SP)	
  0x4088dc		488d6c2440		LEAQ 0x40(SP), BP	
	if getg().m.mallocing != 0 {
  0x4088e1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4088ea		488b4030		MOVQ 0x30(AX), AX	
  0x4088ee		8b80e8000000		MOVL 0xe8(AX), AX	
  0x4088f4		85c0			TESTL AX, AX		
  0x4088f6		0f85ec000000		JNE 0x4089e8		
	t := itabTable
  0x4088fc		488b0525d10900		MOVQ runtime.itabTable(SB), AX	
	if t.count >= 3*(t.size/4) { // 75% load factor
  0x408903		488b4808		MOVQ 0x8(AX), CX	
  0x408907		488b10			MOVQ 0(AX), DX		
  0x40890a		4889d3			MOVQ DX, BX		
  0x40890d		48c1ea02		SHRQ $0x2, DX		
  0x408911		488d1452		LEAQ 0(DX)(DX*2), DX	
  0x408915		4839d1			CMPQ DX, CX		
  0x408918		731d			JAE 0x408937		
	t.add(m)
  0x40891a		48890424		MOVQ AX, 0(SP)				
  0x40891e		488b442450		MOVQ 0x50(SP), AX			
  0x408923		4889442408		MOVQ AX, 0x8(SP)			
  0x408928		e8e3000000		CALL runtime.(*itabTableType).add(SB)	
}
  0x40892d		488b6c2440		MOVQ 0x40(SP), BP	
  0x408932		4883c448		ADDQ $0x48, SP		
  0x408936		c3			RET			
  0x408937		4889442420		MOVQ AX, 0x20(SP)	
		t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true))
  0x40893c		48d1e3			SHLQ $0x1, BX			
  0x40893f		488d4302		LEAQ 0x2(BX), AX		
  0x408943		48c1e003		SHLQ $0x3, AX			
  0x408947		48890424		MOVQ AX, 0(SP)			
  0x40894b		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x408954		c644241001		MOVB $0x1, 0x10(SP)		
  0x408959		e8b21c0000		CALL runtime.mallocgc(SB)	
  0x40895e		488b442418		MOVQ 0x18(SP), AX		
  0x408963		4889442428		MOVQ AX, 0x28(SP)		
  0x408968		488b4c2420		MOVQ 0x20(SP), CX		
		t2.size = t.size * 2
  0x40896d		488b11			MOVQ 0(CX), DX		
  0x408970		48d1e2			SHLQ $0x1, DX		
  0x408973		488910			MOVQ DX, 0(AX)		
		iterate_itabs(t2.add)
  0x408976		488d1553f60300		LEAQ runtime.(*itabTableType).(runtime.add)-fm(SB), DX	
  0x40897d		4889542430		MOVQ DX, 0x30(SP)					
  0x408982		4889442438		MOVQ AX, 0x38(SP)					
  0x408987		488d542430		LEAQ 0x30(SP), DX					
  0x40898c		48891424		MOVQ DX, 0(SP)						
  0x408990		e86b090000		CALL runtime.iterate_itabs(SB)				
	if t.count >= 3*(t.size/4) { // 75% load factor
  0x408995		488b442428		MOVQ 0x28(SP), AX	
		if t2.count != t.count {
  0x40899a		488b4808		MOVQ 0x8(AX), CX	
  0x40899e		488b542420		MOVQ 0x20(SP), DX	
  0x4089a3		488b5208		MOVQ 0x8(DX), DX	
  0x4089a7		4839d1			CMPQ DX, CX		
  0x4089aa		7521			JNE 0x4089cd		
		atomicstorep(unsafe.Pointer(&itabTable), unsafe.Pointer(t2))
  0x4089ac		488d0d75d00900		LEAQ runtime.itabTable(SB), CX	
  0x4089b3		48890c24		MOVQ CX, 0(SP)			
  0x4089b7		4889442408		MOVQ AX, 0x8(SP)		
  0x4089bc		e81f95ffff		CALL runtime.atomicstorep(SB)	
		t = itabTable
  0x4089c1		488b0560d00900		MOVQ runtime.itabTable(SB), AX	
  0x4089c8		e94dffffff		JMP 0x40891a			
			throw("mismatched count during itab table copy")
  0x4089cd		488d0580470600		LEAQ 0x64780(IP), AX	
  0x4089d4		48890424		MOVQ AX, 0(SP)		
  0x4089d8		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x4089e1		e8ea870100		CALL runtime.throw(SB)	
  0x4089e6		0f0b			UD2			
		throw("malloc deadlock")
  0x4089e8		488d057c1f0600		LEAQ 0x61f7c(IP), AX	
  0x4089ef		48890424		MOVQ AX, 0(SP)		
  0x4089f3		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x4089fc		e8cf870100		CALL runtime.throw(SB)	
  0x408a01		0f0b			UD2			
func itabAdd(m *itab) {
  0x408a03		e868bb0300		CALL runtime.morestack_noctxt(SB)	
  0x408a08		e9b3feffff		JMP runtime.itabAdd(SB)			

TEXT runtime.(*itabTableType).add(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func (t *itabTableType) add(m *itab) {
  0x408a10		488b442410		MOVQ 0x10(SP), AX	
	h := itabHashFunc(m.inter, m._type) & mask
  0x408a15		488b08			MOVQ 0(AX), CX		
  0x408a18		488b5008		MOVQ 0x8(AX), DX	
  0x408a1c		488b5c2408		MOVQ 0x8(SP), BX	
	mask := t.size - 1
  0x408a21		488b33			MOVQ 0(BX), SI		
  0x408a24		48ffce			DECQ SI			
	return uintptr(inter.typ.hash ^ typ.hash)
  0x408a27		8b4910			MOVL 0x10(CX), CX	
  0x408a2a		334a10			XORL 0x10(DX), CX	
	h := itabHashFunc(m.inter, m._type) & mask
  0x408a2d		4821f1			ANDQ SI, CX		
  0x408a30		ba01000000		MOVL $0x1, DX		
	for i := uintptr(1); ; i++ {
  0x408a35		eb0d			JMP 0x408a44		
  0x408a37		488d7a01		LEAQ 0x1(DX), DI	
		h += i
  0x408a3b		4801d1			ADDQ DX, CX		
		h &= mask
  0x408a3e		4821f1			ANDQ SI, CX		
  0x408a41		4889fa			MOVQ DI, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x408a44		488d7ccb10		LEAQ 0x10(BX)(CX*8), DI	
		m2 := *p
  0x408a49		8407			TESTB AL, 0(DI)		
  0x408a4b		4c8b44cb10		MOVQ 0x10(BX)(CX*8), R8	
		if m2 == m {
  0x408a50		4939c0			CMPQ AX, R8		
  0x408a53		740d			JE 0x408a62		
		if m2 == nil {
  0x408a55		4d85c0			TESTQ R8, R8		
  0x408a58		75dd			JNE 0x408a37		
			atomic.StorepNoWB(unsafe.Pointer(p), unsafe.Pointer(m))
  0x408a5a		488707			XCHGQ AX, 0(DI)		
			t.count++
  0x408a5d		48ff4308		INCQ 0x8(BX)		
			return
  0x408a61		c3			RET			
			return
  0x408a62		c3			RET			

TEXT runtime.(*itab).init(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func (m *itab) init() string {
  0x408a70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408a79		488d4424d8		LEAQ -0x28(SP), AX	
  0x408a7e		483b4110		CMPQ 0x10(CX), AX	
  0x408a82		0f860b040000		JBE 0x408e93		
  0x408a88		4881eca8000000		SUBQ $0xa8, SP		
  0x408a8f		4889ac24a0000000	MOVQ BP, 0xa0(SP)	
  0x408a97		488dac24a0000000	LEAQ 0xa0(SP), BP	
  0x408a9f		488b8424b0000000	MOVQ 0xb0(SP), AX	
	inter := m.inter
  0x408aa7		488b08			MOVQ 0(AX), CX		
  0x408aaa		48894c2470		MOVQ CX, 0x70(SP)	
	typ := m._type
  0x408aaf		488b5008		MOVQ 0x8(AX), DX	
  0x408ab3		4889542458		MOVQ DX, 0x58(SP)	
	x := typ.uncommon()
  0x408ab8		48891424		MOVQ DX, 0(SP)				
  0x408abc		e85f5f0300		CALL runtime.(*_type).uncommon(SB)	
  0x408ac1		488b442408		MOVQ 0x8(SP), AX			
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x408ac6		8b4808			MOVL 0x8(AX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x408ac9		4801c1			ADDQ AX, CX		
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x408acc		8401			TESTB AL, 0(CX)		
  0x408ace		488b542470		MOVQ 0x70(SP), DX	
	ni := len(inter.mhdr)
  0x408ad3		488b5a40		MOVQ 0x40(DX), BX	
	nt := int(x.mcount)
  0x408ad7		0fb77004		MOVZX 0x4(AX), SI	
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x408adb		4881fe00000100		CMPQ $0x10000, SI	
  0x408ae2		0f87a4030000		JA 0x408e8c		
  0x408ae8		4889842498000000	MOVQ AX, 0x98(SP)	
  0x408af0		48895c2450		MOVQ BX, 0x50(SP)	
  0x408af5		48898c2490000000	MOVQ CX, 0x90(SP)	
  0x408afd		4889742448		MOVQ SI, 0x48(SP)	
  0x408b02		31ff			XORL DI, DI		
  0x408b04		4989f8			MOVQ DI, R8		
	for k := 0; k < ni; k++ {
  0x408b07		e9d1010000		JMP 0x408cdd		
  0x408b0c		488b5c2428		MOVQ 0x28(SP), BX	
		for ; j < nt; j++ {
  0x408b11		488d5301		LEAQ 0x1(BX), DX	
  0x408b15		488b442430		MOVQ 0x30(SP), AX	
  0x408b1a		488b4c2468		MOVQ 0x68(SP), CX	
  0x408b1f		488b5c2448		MOVQ 0x48(SP), BX	
  0x408b24		4839da			CMPQ BX, DX		
  0x408b27		0f8dc8020000		JGE 0x408df5		
			t := &xmhdr[j]
  0x408b2d		0f834b030000		JAE 0x408e7e		
  0x408b33		4889542428		MOVQ DX, 0x28(SP)	
  0x408b38		48c1e204		SHLQ $0x4, DX		
  0x408b3c		4889542440		MOVQ DX, 0x40(SP)	
  0x408b41		488b8c2490000000	MOVQ 0x90(SP), CX	
			tname := typ.nameOff(t.name)
  0x408b49		8b1c11			MOVL 0(CX)(DX*1), BX			
  0x408b4c		895c2408		MOVL BX, 0x8(SP)			
  0x408b50		488b5c2458		MOVQ 0x58(SP), BX			
  0x408b55		48891c24		MOVQ BX, 0(SP)				
  0x408b59		e8d2620300		CALL runtime.(*_type).nameOff(SB)	
  0x408b5e		488b442410		MOVQ 0x10(SP), AX			
  0x408b63		4889842480000000	MOVQ AX, 0x80(SP)			
  0x408b6b		488b4c2440		MOVQ 0x40(SP), CX			
  0x408b70		488b942490000000	MOVQ 0x90(SP), DX			
			if typ.typeOff(t.mtyp) == itype && tname.name() == iname {
  0x408b78		8b5c0a04		MOVL 0x4(DX)(CX*1), BX			
  0x408b7c		895c2408		MOVL BX, 0x8(SP)			
  0x408b80		488b5c2458		MOVQ 0x58(SP), BX			
  0x408b85		48891c24		MOVQ BX, 0(SP)				
  0x408b89		e832660300		CALL runtime.(*_type).typeOff(SB)	
  0x408b8e		488b442410		MOVQ 0x10(SP), AX			
  0x408b93		488b4c2460		MOVQ 0x60(SP), CX			
  0x408b98		4839c8			CMPQ CX, AX				
  0x408b9b		0f856bffffff		JNE 0x408b0c				
  0x408ba1		488b842480000000	MOVQ 0x80(SP), AX			
  0x408ba9		48890424		MOVQ AX, 0(SP)				
  0x408bad		e8de690300		CALL runtime.name.name(SB)		
  0x408bb2		488b442410		MOVQ 0x10(SP), AX			
  0x408bb7		488b4c2408		MOVQ 0x8(SP), CX			
  0x408bbc		488b542438		MOVQ 0x38(SP), DX			
  0x408bc1		4839d0			CMPQ DX, AX				
  0x408bc4		740a			JE 0x408bd0				
  0x408bc6		488b4c2460		MOVQ 0x60(SP), CX			
  0x408bcb		e93cffffff		JMP 0x408b0c				
  0x408bd0		48890c24		MOVQ CX, 0(SP)				
  0x408bd4		488b442478		MOVQ 0x78(SP), AX			
  0x408bd9		4889442408		MOVQ AX, 0x8(SP)			
  0x408bde		e85dd70300		CALL runtime.memequal(SB)		
  0x408be3		0fb6442418		MOVZX 0x18(SP), AX			
  0x408be8		84c0			TESTL AL, AL				
  0x408bea		750a			JNE 0x408bf6				
  0x408bec		488b4c2460		MOVQ 0x60(SP), CX			
  0x408bf1		e916ffffff		JMP 0x408b0c				
  0x408bf6		488b842480000000	MOVQ 0x80(SP), AX			
				pkgPath := tname.pkgPath()
  0x408bfe		48890424		MOVQ AX, 0(SP)			
  0x408c02		e8996a0300		CALL runtime.name.pkgPath(SB)	
  0x408c07		488b442410		MOVQ 0x10(SP), AX		
  0x408c0c		488b4c2408		MOVQ 0x8(SP), CX		
				if pkgPath == "" {
  0x408c11		4885c0			TESTQ AX, AX		
  0x408c14		0f84a2010000		JE 0x408dbc		
  0x408c1a		488b942480000000	MOVQ 0x80(SP), DX	
	return (*n.bytes)&(1<<0) != 0
  0x408c22		0fb612			MOVZX 0(DX), DX		
  0x408c25		f6c201			TESTL $0x1, DL		
				if tname.isExported() || pkgPath == ipkg {
  0x408c28		753c			JNE 0x408c66		
  0x408c2a		488b542430		MOVQ 0x30(SP), DX	
  0x408c2f		4839c2			CMPQ AX, DX		
  0x408c32		740a			JE 0x408c3e		
  0x408c34		488b4c2460		MOVQ 0x60(SP), CX	
		for ; j < nt; j++ {
  0x408c39		e9cefeffff		JMP 0x408b0c		
				if tname.isExported() || pkgPath == ipkg {
  0x408c3e		48890c24		MOVQ CX, 0(SP)			
  0x408c42		488b4c2468		MOVQ 0x68(SP), CX		
  0x408c47		48894c2408		MOVQ CX, 0x8(SP)		
  0x408c4c		4889442410		MOVQ AX, 0x10(SP)		
  0x408c51		e8ead60300		CALL runtime.memequal(SB)	
  0x408c56		0fb6442418		MOVZX 0x18(SP), AX		
  0x408c5b		84c0			TESTL AL, AL			
  0x408c5d		7507			JNE 0x408c66			
  0x408c5f		488b542430		MOVQ 0x30(SP), DX		
  0x408c64		ebce			JMP 0x408c34			
  0x408c66		488b442440		MOVQ 0x40(SP), AX		
  0x408c6b		488b8c2490000000	MOVQ 0x90(SP), CX		
						ifn := typ.textOff(t.ifn)
  0x408c73		8b440108		MOVL 0x8(CX)(AX*1), AX			
  0x408c77		89442408		MOVL AX, 0x8(SP)			
  0x408c7b		488b442458		MOVQ 0x58(SP), AX			
  0x408c80		48890424		MOVQ AX, 0(SP)				
  0x408c84		e887650300		CALL runtime.(*_type).textOff(SB)	
  0x408c89		488b442420		MOVQ 0x20(SP), AX			
  0x408c8e		488b8c24b0000000	MOVQ 0xb0(SP), CX			
	return unsafe.Pointer(uintptr(p) + x)
  0x408c96		488d7cc118		LEAQ 0x18(CX)(AX*8), DI	
						*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
  0x408c9b		8407			TESTB AL, 0(DI)		
						ifn := typ.textOff(t.ifn)
  0x408c9d		488b542410		MOVQ 0x10(SP), DX	
						*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
  0x408ca2		8b1d68ad0b00		MOVL runtime.writeBarrier(SB), BX	
  0x408ca8		85db			TESTL BX, BX				
  0x408caa		0f85f9000000		JNE 0x408da9				
  0x408cb0		488954c118		MOVQ DX, 0x18(CX)(AX*8)			
	for k := 0; k < ni; k++ {
  0x408cb5		488d7801		LEAQ 0x1(AX), DI	
  0x408cb9		488b842498000000	MOVQ 0x98(SP), AX	
  0x408cc1		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x408cc9		488b542470		MOVQ 0x70(SP), DX	
  0x408cce		488b5c2450		MOVQ 0x50(SP), BX	
  0x408cd3		488b742448		MOVQ 0x48(SP), SI	
  0x408cd8		4c8b442428		MOVQ 0x28(SP), R8	
  0x408cdd		4839df			CMPQ BX, DI		
  0x408ce0		0f8d6a010000		JGE 0x408e50		
		i := &inter.mhdr[k]
  0x408ce6		4c8b4a38		MOVQ 0x38(DX), R9	
  0x408cea		4c8b5240		MOVQ 0x40(DX), R10	
  0x408cee		4c39d7			CMPQ R10, DI		
  0x408cf1		0f838e010000		JAE 0x408e85		
  0x408cf7		48897c2420		MOVQ DI, 0x20(SP)	
  0x408cfc		4c898c2488000000	MOVQ R9, 0x88(SP)	
  0x408d04		4c89442428		MOVQ R8, 0x28(SP)	
		itype := inter.typ.typeOff(i.ityp)
  0x408d09		418b44f904		MOVL 0x4(R9)(DI*8), AX			
  0x408d0e		89442408		MOVL AX, 0x8(SP)			
  0x408d12		48891424		MOVQ DX, 0(SP)				
  0x408d16		e8a5640300		CALL runtime.(*_type).typeOff(SB)	
  0x408d1b		488b442410		MOVQ 0x10(SP), AX			
  0x408d20		4889442460		MOVQ AX, 0x60(SP)			
  0x408d25		488b4c2420		MOVQ 0x20(SP), CX			
  0x408d2a		488b942488000000	MOVQ 0x88(SP), DX			
		name := inter.typ.nameOff(i.name)
  0x408d32		8b14ca			MOVL 0(DX)(CX*8), DX			
  0x408d35		89542408		MOVL DX, 0x8(SP)			
  0x408d39		488b542470		MOVQ 0x70(SP), DX			
  0x408d3e		48891424		MOVQ DX, 0(SP)				
  0x408d42		e8e9600300		CALL runtime.(*_type).nameOff(SB)	
  0x408d47		488b442410		MOVQ 0x10(SP), AX			
  0x408d4c		4889842480000000	MOVQ AX, 0x80(SP)			
		iname := name.name()
  0x408d54		48890424		MOVQ AX, 0(SP)			
  0x408d58		e833680300		CALL runtime.name.name(SB)	
  0x408d5d		488b442410		MOVQ 0x10(SP), AX		
  0x408d62		4889442438		MOVQ AX, 0x38(SP)		
  0x408d67		488b4c2408		MOVQ 0x8(SP), CX		
  0x408d6c		48894c2478		MOVQ CX, 0x78(SP)		
  0x408d71		488b942480000000	MOVQ 0x80(SP), DX		
		ipkg := name.pkgPath()
  0x408d79		48891424		MOVQ DX, 0(SP)			
  0x408d7d		e81e690300		CALL runtime.name.pkgPath(SB)	
  0x408d82		488b442410		MOVQ 0x10(SP), AX		
  0x408d87		488b4c2408		MOVQ 0x8(SP), CX		
		if ipkg == "" {
  0x408d8c		4885c0			TESTQ AX, AX		
  0x408d8f		0f849a000000		JE 0x408e2f		
  0x408d95		4889442430		MOVQ AX, 0x30(SP)	
  0x408d9a		48894c2468		MOVQ CX, 0x68(SP)	
  0x408d9f		488b542428		MOVQ 0x28(SP), DX	
		for ; j < nt; j++ {
  0x408da4		e976fdffff		JMP 0x408b1f		
  0x408da9		4889c3			MOVQ AX, BX		
  0x408dac		4889d0			MOVQ DX, AX		
						*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
  0x408daf		e8ecda0300		CALL runtime.gcWriteBarrier(SB)	
  0x408db4		4889d8			MOVQ BX, AX			
  0x408db7		e9f9feffff		JMP 0x408cb5			
  0x408dbc		488b842498000000	MOVQ 0x98(SP), AX		
					pkgPath = typ.nameOff(x.pkgpath).name()
  0x408dc4		8b08			MOVL 0(AX), CX				
  0x408dc6		894c2408		MOVL CX, 0x8(SP)			
  0x408dca		488b4c2458		MOVQ 0x58(SP), CX			
  0x408dcf		48890c24		MOVQ CX, 0(SP)				
  0x408dd3		e858600300		CALL runtime.(*_type).nameOff(SB)	
  0x408dd8		488b442410		MOVQ 0x10(SP), AX			
  0x408ddd		48890424		MOVQ AX, 0(SP)				
  0x408de1		e8aa670300		CALL runtime.name.name(SB)		
  0x408de6		488b4c2408		MOVQ 0x8(SP), CX			
  0x408deb		488b442410		MOVQ 0x10(SP), AX			
  0x408df0		e925feffff		JMP 0x408c1a				
  0x408df5		488b8424b0000000	MOVQ 0xb0(SP), AX			
		m.fun[0] = 0
  0x408dfd		48c7401800000000	MOVQ $0x0, 0x18(AX)	
		return iname
  0x408e05		488b442478		MOVQ 0x78(SP), AX	
  0x408e0a		48898424b8000000	MOVQ AX, 0xb8(SP)	
  0x408e12		488b442438		MOVQ 0x38(SP), AX	
  0x408e17		48898424c0000000	MOVQ AX, 0xc0(SP)	
  0x408e1f		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x408e27		4881c4a8000000		ADDQ $0xa8, SP		
  0x408e2e		c3			RET			
  0x408e2f		488b442470		MOVQ 0x70(SP), AX	
			ipkg = inter.pkgpath.name()
  0x408e34		488b4830		MOVQ 0x30(AX), CX		
  0x408e38		48890c24		MOVQ CX, 0(SP)			
  0x408e3c		e84f670300		CALL runtime.name.name(SB)	
  0x408e41		488b4c2408		MOVQ 0x8(SP), CX		
  0x408e46		488b442410		MOVQ 0x10(SP), AX		
  0x408e4b		e945ffffff		JMP 0x408d95			
  0x408e50		488b442458		MOVQ 0x58(SP), AX		
	m.hash = typ.hash
  0x408e55		8b4010			MOVL 0x10(AX), AX	
  0x408e58		488b8c24b0000000	MOVQ 0xb0(SP), CX	
  0x408e60		894110			MOVL AX, 0x10(CX)	
	return ""
  0x408e63		0f57c0			XORPS X0, X0		
  0x408e66		0f118424b8000000	MOVUPS X0, 0xb8(SP)	
  0x408e6e		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x408e76		4881c4a8000000		ADDQ $0xa8, SP		
  0x408e7d		c3			RET			
			t := &xmhdr[j]
  0x408e7e		e8bd6b0100		CALL runtime.panicindex(SB)	
  0x408e83		0f0b			UD2				
		i := &inter.mhdr[k]
  0x408e85		e8b66b0100		CALL runtime.panicindex(SB)	
  0x408e8a		0f0b			UD2				
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x408e8c		e81f6c0100		CALL runtime.panicslice(SB)	
  0x408e91		0f0b			UD2				
func (m *itab) init() string {
  0x408e93		e8d8b60300		CALL runtime.morestack_noctxt(SB)	
  0x408e98		e9d3fbffff		JMP runtime.(*itab).init(SB)		

TEXT runtime.itabsinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func itabsinit() {
  0x408ea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408ea9		483b6110		CMPQ 0x10(CX), SP	
  0x408ead		0f86cc000000		JBE 0x408f7f		
  0x408eb3		4883ec40		SUBQ $0x40, SP		
  0x408eb7		48896c2438		MOVQ BP, 0x38(SP)	
  0x408ebc		488d6c2438		LEAQ 0x38(SP), BP	
	lock(&itabLock)
  0x408ec1		488d05b8aa0b00		LEAQ runtime.itabLock(SB), AX	
  0x408ec8		48890424		MOVQ AX, 0(SP)			
  0x408ecc		e84f060000		CALL runtime.lock(SB)		
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x408ed1		488b05a0e70900		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x408ed8		4885c0			TESTQ AX, AX		
  0x408edb		0f8495000000		JE 0x408f76		
	return *p
  0x408ee1		488b4808		MOVQ 0x8(AX), CX	
  0x408ee5		488b00			MOVQ 0(AX), AX		
	for _, md := range activeModules() {
  0x408ee8		4889442430		MOVQ AX, 0x30(SP)	
  0x408eed		48894c2408		MOVQ CX, 0x8(SP)	
  0x408ef2		31d2			XORL DX, DX		
  0x408ef4		eb3c			JMP 0x408f32		
  0x408ef6		48897c2410		MOVQ DI, 0x10(SP)	
		for _, i := range md.itablinks {
  0x408efb		488b04fb		MOVQ 0(BX)(DI*8), AX	
			itabAdd(i)
  0x408eff		48890424		MOVQ AX, 0(SP)			
  0x408f03		e8b8f9ffff		CALL runtime.itabAdd(SB)	
  0x408f08		488b442410		MOVQ 0x10(SP), AX		
		for _, i := range md.itablinks {
  0x408f0d		488d7801		LEAQ 0x1(AX), DI	
  0x408f11		488b442430		MOVQ 0x30(SP), AX	
  0x408f16		488b4c2408		MOVQ 0x8(SP), CX	
  0x408f1b		488b542420		MOVQ 0x20(SP), DX	
  0x408f20		488b5c2428		MOVQ 0x28(SP), BX	
  0x408f25		488b742418		MOVQ 0x18(SP), SI	
  0x408f2a		4839f7			CMPQ SI, DI		
  0x408f2d		7cc7			JL 0x408ef6		
	for _, md := range activeModules() {
  0x408f2f		48ffc2			INCQ DX			
  0x408f32		4839ca			CMPQ CX, DX		
  0x408f35		7d25			JGE 0x408f5c		
  0x408f37		4889542420		MOVQ DX, 0x20(SP)	
  0x408f3c		488b1cd0		MOVQ 0(AX)(DX*8), BX	
		for _, i := range md.itablinks {
  0x408f40		488bb310010000		MOVQ 0x110(BX), SI	
  0x408f47		4889742418		MOVQ SI, 0x18(SP)	
  0x408f4c		488b9b08010000		MOVQ 0x108(BX), BX	
  0x408f53		48895c2428		MOVQ BX, 0x28(SP)	
  0x408f58		31ff			XORL DI, DI		
  0x408f5a		ebce			JMP 0x408f2a		
	unlock(&itabLock)
  0x408f5c		488d051daa0b00		LEAQ runtime.itabLock(SB), AX	
  0x408f63		48890424		MOVQ AX, 0(SP)			
  0x408f67		e854070000		CALL runtime.unlock(SB)		
}
  0x408f6c		488b6c2438		MOVQ 0x38(SP), BP	
  0x408f71		4883c440		ADDQ $0x40, SP		
  0x408f75		c3			RET			
  0x408f76		31c0			XORL AX, AX		
  0x408f78		31c9			XORL CX, CX		
	for _, md := range activeModules() {
  0x408f7a		e969ffffff		JMP 0x408ee8		
func itabsinit() {
  0x408f7f		e8ecb50300		CALL runtime.morestack_noctxt(SB)	
  0x408f84		e917ffffff		JMP runtime.itabsinit(SB)		

TEXT runtime.panicdottypeE(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func panicdottypeE(have, want, iface *_type) {
  0x408f90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408f99		483b6110		CMPQ 0x10(CX), SP	
  0x408f9d		0f8688010000		JBE 0x40912b		
  0x408fa3		4883ec50		SUBQ $0x50, SP		
  0x408fa7		48896c2448		MOVQ BP, 0x48(SP)	
  0x408fac		488d6c2448		LEAQ 0x48(SP), BP	
  0x408fb1		488b442458		MOVQ 0x58(SP), AX	
	if have != nil {
  0x408fb6		4885c0			TESTQ AX, AX		
  0x408fb9		0f853d010000		JNE 0x4090fc		
  0x408fbf		31c0			XORL AX, AX		
  0x408fc1		31c9			XORL CX, CX		
  0x408fc3		4889442418		MOVQ AX, 0x18(SP)	
  0x408fc8		48894c2430		MOVQ CX, 0x30(SP)	
  0x408fcd		488b542468		MOVQ 0x68(SP), DX	
	panic(&TypeAssertionError{iface.string(), haveString, want.string(), ""})
  0x408fd2		48891424		MOVQ DX, 0(SP)				
  0x408fd6		e895590300		CALL runtime.(*_type).string(SB)	
  0x408fdb		488b442410		MOVQ 0x10(SP), AX			
  0x408fe0		4889442428		MOVQ AX, 0x28(SP)			
  0x408fe5		488b4c2408		MOVQ 0x8(SP), CX			
  0x408fea		48894c2440		MOVQ CX, 0x40(SP)			
  0x408fef		488b542460		MOVQ 0x60(SP), DX			
  0x408ff4		48891424		MOVQ DX, 0(SP)				
  0x408ff8		e873590300		CALL runtime.(*_type).string(SB)	
  0x408ffd		488b442408		MOVQ 0x8(SP), AX			
  0x409002		4889442438		MOVQ AX, 0x38(SP)			
  0x409007		488b4c2410		MOVQ 0x10(SP), CX			
  0x40900c		48894c2420		MOVQ CX, 0x20(SP)			
  0x409011		488d15e8820500		LEAQ 0x582e8(IP), DX			
  0x409018		48891424		MOVQ DX, 0(SP)				
  0x40901c		e8ff200000		CALL runtime.newobject(SB)		
  0x409021		488b7c2408		MOVQ 0x8(SP), DI			
  0x409026		488b442428		MOVQ 0x28(SP), AX			
  0x40902b		48894708		MOVQ AX, 0x8(DI)			
  0x40902f		8b05dba90b00		MOVL runtime.writeBarrier(SB), AX	
  0x409035		85c0			TESTL AX, AX				
  0x409037		0f85b0000000		JNE 0x4090ed				
  0x40903d		488b4c2440		MOVQ 0x40(SP), CX			
  0x409042		48890f			MOVQ CX, 0(DI)				
  0x409045		488b4c2418		MOVQ 0x18(SP), CX			
  0x40904a		48894f18		MOVQ CX, 0x18(DI)			
  0x40904e		8b0dbca90b00		MOVL runtime.writeBarrier(SB), CX	
  0x409054		488d5710		LEAQ 0x10(DI), DX			
  0x409058		85c9			TESTL CX, CX				
  0x40905a		7576			JNE 0x4090d2				
  0x40905c		488b4c2430		MOVQ 0x30(SP), CX			
  0x409061		48894f10		MOVQ CX, 0x10(DI)			
  0x409065		488b4c2420		MOVQ 0x20(SP), CX			
  0x40906a		48894f28		MOVQ CX, 0x28(DI)			
  0x40906e		8b0d9ca90b00		MOVL runtime.writeBarrier(SB), CX	
  0x409074		488d5720		LEAQ 0x20(DI), DX			
  0x409078		85c9			TESTL CX, CX				
  0x40907a		753e			JNE 0x4090ba				
  0x40907c		488b4c2438		MOVQ 0x38(SP), CX			
  0x409081		48894f20		MOVQ CX, 0x20(DI)			
  0x409085		48c7473800000000	MOVQ $0x0, 0x38(DI)			
  0x40908d		8b0d7da90b00		MOVL runtime.writeBarrier(SB), CX	
  0x409093		488d5730		LEAQ 0x30(DI), DX			
  0x409097		85c9			TESTL CX, CX				
  0x409099		750d			JNE 0x4090a8				
  0x40909b		48c7473000000000	MOVQ $0x0, 0x30(DI)			
  0x4090a3		4889f9			MOVQ DI, CX				
  0x4090a6		eb6c			JMP 0x409114				
  0x4090a8		4889f8			MOVQ DI, AX				
  0x4090ab		4889d7			MOVQ DX, DI				
  0x4090ae		4889c1			MOVQ AX, CX				
  0x4090b1		31c0			XORL AX, AX				
  0x4090b3		e8e8d70300		CALL runtime.gcWriteBarrier(SB)		
  0x4090b8		eb5a			JMP 0x409114				
  0x4090ba		4889f8			MOVQ DI, AX				
  0x4090bd		4889d7			MOVQ DX, DI				
  0x4090c0		4889c1			MOVQ AX, CX				
  0x4090c3		488b442438		MOVQ 0x38(SP), AX			
  0x4090c8		e8d3d70300		CALL runtime.gcWriteBarrier(SB)		
  0x4090cd		4889cf			MOVQ CX, DI				
  0x4090d0		ebb3			JMP 0x409085				
  0x4090d2		4889f8			MOVQ DI, AX				
  0x4090d5		4889d7			MOVQ DX, DI				
  0x4090d8		4889c1			MOVQ AX, CX				
  0x4090db		488b442430		MOVQ 0x30(SP), AX			
  0x4090e0		e8bbd70300		CALL runtime.gcWriteBarrier(SB)		
  0x4090e5		4889cf			MOVQ CX, DI				
  0x4090e8		e978ffffff		JMP 0x409065				
  0x4090ed		488b442440		MOVQ 0x40(SP), AX			
  0x4090f2		e8a9d70300		CALL runtime.gcWriteBarrier(SB)		
  0x4090f7		e949ffffff		JMP 0x409045				
		haveString = have.string()
  0x4090fc		48890424		MOVQ AX, 0(SP)				
  0x409100		e86b580300		CALL runtime.(*_type).string(SB)	
  0x409105		488b442410		MOVQ 0x10(SP), AX			
  0x40910a		488b4c2408		MOVQ 0x8(SP), CX			
  0x40910f		e9affeffff		JMP 0x408fc3				
	panic(&TypeAssertionError{iface.string(), haveString, want.string(), ""})
  0x409114		488d05c5200500		LEAQ 0x520c5(IP), AX		
  0x40911b		48890424		MOVQ AX, 0(SP)			
  0x40911f		48894c2408		MOVQ CX, 0x8(SP)		
  0x409124		e807790100		CALL runtime.gopanic(SB)	
  0x409129		0f0b			UD2				
func panicdottypeE(have, want, iface *_type) {
  0x40912b		e840b40300		CALL runtime.morestack_noctxt(SB)	
  0x409130		e95bfeffff		JMP runtime.panicdottypeE(SB)		

TEXT runtime.panicdottypeI(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func panicdottypeI(have *itab, want, iface *_type) {
  0x409140		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409149		483b6110		CMPQ 0x10(CX), SP	
  0x40914d		7647			JBE 0x409196		
  0x40914f		4883ec20		SUBQ $0x20, SP		
  0x409153		48896c2418		MOVQ BP, 0x18(SP)	
  0x409158		488d6c2418		LEAQ 0x18(SP), BP	
  0x40915d		488b442428		MOVQ 0x28(SP), AX	
	if have != nil {
  0x409162		4885c0			TESTQ AX, AX		
  0x409165		742b			JE 0x409192		
		t = have._type
  0x409167		488b4008		MOVQ 0x8(AX), AX	
	panicdottypeE(t, want, iface)
  0x40916b		48890424		MOVQ AX, 0(SP)			
  0x40916f		488b442430		MOVQ 0x30(SP), AX		
  0x409174		4889442408		MOVQ AX, 0x8(SP)		
  0x409179		488b442438		MOVQ 0x38(SP), AX		
  0x40917e		4889442410		MOVQ AX, 0x10(SP)		
  0x409183		e808feffff		CALL runtime.panicdottypeE(SB)	
}
  0x409188		488b6c2418		MOVQ 0x18(SP), BP	
  0x40918d		4883c420		ADDQ $0x20, SP		
  0x409191		c3			RET			
  0x409192		31c0			XORL AX, AX		
	if have != nil {
  0x409194		ebd5			JMP 0x40916b		
func panicdottypeI(have *itab, want, iface *_type) {
  0x409196		e8d5b30300		CALL runtime.morestack_noctxt(SB)	
  0x40919b		eba3			JMP runtime.panicdottypeI(SB)		

TEXT runtime.convT2Estring(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func convT2Estring(t *_type, elem unsafe.Pointer) (e eface) {
  0x4091a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4091a9		483b6110		CMPQ 0x10(CX), SP	
  0x4091ad		0f8685000000		JBE 0x409238		
  0x4091b3		4883ec28		SUBQ $0x28, SP		
  0x4091b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4091bc		488d6c2420		LEAQ 0x20(SP), BP	
  0x4091c1		488b442438		MOVQ 0x38(SP), AX	
	if *(*string)(elem) == "" {
  0x4091c6		488b4808		MOVQ 0x8(AX), CX		
  0x4091ca		4885c9			TESTQ CX, CX			
  0x4091cd		7520			JNE 0x4091ef			
  0x4091cf		488d052ab10b00		LEAQ runtime.zeroVal(SB), AX	
	return
  0x4091d6		488b4c2430		MOVQ 0x30(SP), CX	
  0x4091db		48894c2440		MOVQ CX, 0x40(SP)	
  0x4091e0		4889442448		MOVQ AX, 0x48(SP)	
  0x4091e5		488b6c2420		MOVQ 0x20(SP), BP	
  0x4091ea		4883c428		ADDQ $0x28, SP		
  0x4091ee		c3			RET			
  0x4091ef		488b442430		MOVQ 0x30(SP), AX	
		x = mallocgc(t.size, t, true)
  0x4091f4		488b08			MOVQ 0(AX), CX			
  0x4091f7		48890c24		MOVQ CX, 0(SP)			
  0x4091fb		4889442408		MOVQ AX, 0x8(SP)		
  0x409200		c644241001		MOVB $0x1, 0x10(SP)		
  0x409205		e806140000		CALL runtime.mallocgc(SB)	
  0x40920a		488b7c2418		MOVQ 0x18(SP), DI		
  0x40920f		488b442438		MOVQ 0x38(SP), AX		
		*(*string)(x) = *(*string)(elem)
  0x409214		488b4808		MOVQ 0x8(AX), CX			
  0x409218		488b00			MOVQ 0(AX), AX				
  0x40921b		48894f08		MOVQ CX, 0x8(DI)			
  0x40921f		8b0deba70b00		MOVL runtime.writeBarrier(SB), CX	
  0x409225		85c9			TESTL CX, CX				
  0x409227		7508			JNE 0x409231				
  0x409229		488907			MOVQ AX, 0(DI)				
  0x40922c		4889f8			MOVQ DI, AX				
  0x40922f		eba5			JMP 0x4091d6				
  0x409231		e86ad60300		CALL runtime.gcWriteBarrier(SB)		
  0x409236		ebf4			JMP 0x40922c				
func convT2Estring(t *_type, elem unsafe.Pointer) (e eface) {
  0x409238		e833b30300		CALL runtime.morestack_noctxt(SB)	
  0x40923d		e95effffff		JMP runtime.convT2Estring(SB)		

TEXT runtime.assertE2I2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) {
  0x409250		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409259		483b6110		CMPQ 0x10(CX), SP	
  0x40925d		0f8686000000		JBE 0x4092e9		
  0x409263		4883ec28		SUBQ $0x28, SP		
  0x409267		48896c2420		MOVQ BP, 0x20(SP)	
  0x40926c		488d6c2420		LEAQ 0x20(SP), BP	
  0x409271		488b442438		MOVQ 0x38(SP), AX	
	if t == nil {
  0x409276		4885c0			TESTQ AX, AX		
  0x409279		7457			JE 0x4092d2		
  0x40927b		488b4c2430		MOVQ 0x30(SP), CX	
	tab := getitab(inter, t, true)
  0x409280		48890c24		MOVQ CX, 0(SP)			
  0x409284		4889442408		MOVQ AX, 0x8(SP)		
  0x409289		c644241001		MOVB $0x1, 0x10(SP)		
  0x40928e		e82df1ffff		CALL runtime.getitab(SB)	
  0x409293		488b442418		MOVQ 0x18(SP), AX		
	if tab == nil {
  0x409298		4885c0			TESTQ AX, AX		
  0x40929b		741e			JE 0x4092bb		
	return
  0x40929d		4889442448		MOVQ AX, 0x48(SP)	
  0x4092a2		488b442440		MOVQ 0x40(SP), AX	
  0x4092a7		4889442450		MOVQ AX, 0x50(SP)	
  0x4092ac		c644245801		MOVB $0x1, 0x58(SP)	
  0x4092b1		488b6c2420		MOVQ 0x20(SP), BP	
  0x4092b6		4883c428		ADDQ $0x28, SP		
  0x4092ba		c3			RET			
		return
  0x4092bb		0f57c0			XORPS X0, X0		
  0x4092be		0f11442448		MOVUPS X0, 0x48(SP)	
  0x4092c3		c644245800		MOVB $0x0, 0x58(SP)	
  0x4092c8		488b6c2420		MOVQ 0x20(SP), BP	
  0x4092cd		4883c428		ADDQ $0x28, SP		
  0x4092d1		c3			RET			
		return
  0x4092d2		0f57c0			XORPS X0, X0		
  0x4092d5		0f11442448		MOVUPS X0, 0x48(SP)	
  0x4092da		c644245800		MOVB $0x0, 0x58(SP)	
  0x4092df		488b6c2420		MOVQ 0x20(SP), BP	
  0x4092e4		4883c428		ADDQ $0x28, SP		
  0x4092e8		c3			RET			
func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) {
  0x4092e9		e882b20300		CALL runtime.morestack_noctxt(SB)	
  0x4092ee		e95dffffff		JMP runtime.assertE2I2(SB)		

TEXT runtime.iterate_itabs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
func iterate_itabs(fn func(*itab)) {
  0x409300		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409309		483b6110		CMPQ 0x10(CX), SP	
  0x40930d		7663			JBE 0x409372		
  0x40930f		4883ec20		SUBQ $0x20, SP		
  0x409313		48896c2418		MOVQ BP, 0x18(SP)	
  0x409318		488d6c2418		LEAQ 0x18(SP), BP	
	t := itabTable
  0x40931d		488b0504c70900		MOVQ runtime.itabTable(SB), AX	
  0x409324		4889442410		MOVQ AX, 0x10(SP)		
  0x409329		31c9			XORL CX, CX			
	for i := uintptr(0); i < t.size; i++ {
  0x40932b		eb03			JMP 0x409330		
  0x40932d		48ffc1			INCQ CX			
  0x409330		488b18			MOVQ 0(AX), BX		
  0x409333		4839d9			CMPQ BX, CX		
  0x409336		7330			JAE 0x409368		
	return unsafe.Pointer(uintptr(p) + x)
  0x409338		488d5cc810		LEAQ 0x10(AX)(CX*8), BX	
		m := *(**itab)(add(unsafe.Pointer(&t.entries), i*sys.PtrSize))
  0x40933d		8403			TESTB AL, 0(BX)		
  0x40933f		488b5cc810		MOVQ 0x10(AX)(CX*8), BX	
		if m != nil {
  0x409344		4885db			TESTQ BX, BX		
  0x409347		74e4			JE 0x40932d		
  0x409349		48894c2408		MOVQ CX, 0x8(SP)	
			fn(m)
  0x40934e		48891c24		MOVQ BX, 0(SP)		
  0x409352		488b542428		MOVQ 0x28(SP), DX	
  0x409357		488b02			MOVQ 0(DX), AX		
  0x40935a		ffd0			CALL AX			
  0x40935c		488b442410		MOVQ 0x10(SP), AX	
  0x409361		488b4c2408		MOVQ 0x8(SP), CX	
  0x409366		ebc5			JMP 0x40932d		
  0x409368		488b6c2418		MOVQ 0x18(SP), BP	
  0x40936d		4883c420		ADDQ $0x20, SP		
  0x409371		c3			RET			
func iterate_itabs(fn func(*itab)) {
  0x409372		e8f9b10300		CALL runtime.morestack_noctxt(SB)	
  0x409377		eb87			JMP runtime.iterate_itabs(SB)		

TEXT runtime.(*lfstack).push(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lfstack.go
func (head *lfstack) push(node *lfnode) {
  0x409380		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409389		483b6110		CMPQ 0x10(CX), SP	
  0x40938d		0f863d010000		JBE 0x4094d0		
  0x409393		4883ec30		SUBQ $0x30, SP		
  0x409397		48896c2428		MOVQ BP, 0x28(SP)	
  0x40939c		488d6c2428		LEAQ 0x28(SP), BP	
  0x4093a1		488b4c2440		MOVQ 0x40(SP), CX	
	node.pushcnt++
  0x4093a6		488b5108		MOVQ 0x8(CX), DX	
  0x4093aa		48ffc2			INCQ DX			
  0x4093ad		48895108		MOVQ DX, 0x8(CX)	
func (head *lfstack) push(node *lfnode) {
  0x4093b1		4889cb			MOVQ CX, BX		
	return uint64(uintptr(unsafe.Pointer(node)))<<(64-addrBits) | uint64(cnt&(1<<cntBits-1))
  0x4093b4		48c1e110		SHLQ $0x10, CX		
  0x4093b8		4889d6			MOVQ DX, SI		
  0x4093bb		4881e2ffff0700		ANDQ $0x7ffff, DX	
  0x4093c2		4809d1			ORQ DX, CX		
  0x4093c5		4889ca			MOVQ CX, DX		
		return (*lfnode)(unsafe.Pointer(uintptr(int64(val) >> cntBits << 3)))
  0x4093c8		48c1f913		SARQ $0x13, CX		
  0x4093cc		48c1e103		SHLQ $0x3, CX		
	if node1 := lfstackUnpack(new); node1 != node {
  0x4093d0		4839d9			CMPQ BX, CX		
  0x4093d3		7526			JNE 0x4093fb		
  0x4093d5		488b4c2438		MOVQ 0x38(SP), CX	
		old := atomic.Load64((*uint64)(head))
  0x4093da		488b31			MOVQ 0(CX), SI		
		node.next = old
  0x4093dd		488933			MOVQ SI, 0(BX)		
  0x4093e0		4889f0			MOVQ SI, AX		
		if atomic.Cas64((*uint64)(head), old, new) {
  0x4093e3		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)	
  0x4093e8		400f94c6		SETE SI			
  0x4093ec		4084f6			TESTL SI, SI		
  0x4093ef		74e9			JE 0x4093da		
  0x4093f1		488b6c2428		MOVQ 0x28(SP), BP	
  0x4093f6		4883c430		ADDQ $0x30, SP		
  0x4093fa		c3			RET			
  0x4093fb		4889742418		MOVQ SI, 0x18(SP)	
  0x409400		4889542410		MOVQ DX, 0x10(SP)	
  0x409405		48894c2420		MOVQ CX, 0x20(SP)	
		print("runtime: lfstack.push invalid packing: node=", node, " cnt=", hex(node.pushcnt), " packed=", hex(new), " -> node=", node1, "\n")
  0x40940a		e8f1860100		CALL runtime.printlock(SB)	
  0x40940f		488d0537420600		LEAQ 0x64237(IP), AX		
  0x409416		48890424		MOVQ AX, 0(SP)			
  0x40941a		48c74424082c000000	MOVQ $0x2c, 0x8(SP)		
  0x409423		e818900100		CALL runtime.printstring(SB)	
  0x409428		488b442440		MOVQ 0x40(SP), AX		
  0x40942d		48890424		MOVQ AX, 0(SP)			
  0x409431		e8ca8f0100		CALL runtime.printpointer(SB)	
  0x409436		488d051c090600		LEAQ 0x6091c(IP), AX		
  0x40943d		48890424		MOVQ AX, 0(SP)			
  0x409441		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x40944a		e8f18f0100		CALL runtime.printstring(SB)	
  0x40944f		488b442418		MOVQ 0x18(SP), AX		
  0x409454		48890424		MOVQ AX, 0(SP)			
  0x409458		e8938e0100		CALL runtime.printhex(SB)	
  0x40945d		488d056b0b0600		LEAQ 0x60b6b(IP), AX		
  0x409464		48890424		MOVQ AX, 0(SP)			
  0x409468		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x409471		e8ca8f0100		CALL runtime.printstring(SB)	
  0x409476		488b442410		MOVQ 0x10(SP), AX		
  0x40947b		48890424		MOVQ AX, 0(SP)			
  0x40947f		e86c8e0100		CALL runtime.printhex(SB)	
  0x409484		488d05bd0b0600		LEAQ 0x60bbd(IP), AX		
  0x40948b		48890424		MOVQ AX, 0(SP)			
  0x40948f		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x409498		e8a38f0100		CALL runtime.printstring(SB)	
  0x40949d		488b442420		MOVQ 0x20(SP), AX		
  0x4094a2		48890424		MOVQ AX, 0(SP)			
  0x4094a6		e8558f0100		CALL runtime.printpointer(SB)	
  0x4094ab		e8e0880100		CALL runtime.printnl(SB)	
  0x4094b0		e8cb860100		CALL runtime.printunlock(SB)	
		throw("lfstack.push")
  0x4094b5		488d056a110600		LEAQ 0x6116a(IP), AX	
  0x4094bc		48890424		MOVQ AX, 0(SP)		
  0x4094c0		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x4094c9		e8027d0100		CALL runtime.throw(SB)	
  0x4094ce		0f0b			UD2			
func (head *lfstack) push(node *lfnode) {
  0x4094d0		e89bb00300		CALL runtime.morestack_noctxt(SB)	
  0x4094d5		e9a6feffff		JMP runtime.(*lfstack).push(SB)		

TEXT runtime.(*lfstack).pop(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lfstack.go
func (head *lfstack) pop() unsafe.Pointer {
  0x4094e0		488b4c2408		MOVQ 0x8(SP), CX	
		old := atomic.Load64((*uint64)(head))
  0x4094e5		488b11			MOVQ 0(CX), DX		
		if old == 0 {
  0x4094e8		4885d2			TESTQ DX, DX		
  0x4094eb		7420			JE 0x40950d		
  0x4094ed		4889d0			MOVQ DX, AX		
		return (*lfnode)(unsafe.Pointer(uintptr(int64(val) >> cntBits << 3)))
  0x4094f0		48c1fa13		SARQ $0x13, DX		
  0x4094f4		48c1e203		SHLQ $0x3, DX		
		next := atomic.Load64(&node.next)
  0x4094f8		488b1a			MOVQ 0(DX), BX		
		if atomic.Cas64((*uint64)(head), old, next) {
  0x4094fb		f0480fb119		LOCK CMPXCHGQ BX, 0(CX)	
  0x409500		0f94c3			SETE BL			
  0x409503		84db			TESTL BL, BL		
  0x409505		74de			JE 0x4094e5		
			return unsafe.Pointer(node)
  0x409507		4889542410		MOVQ DX, 0x10(SP)	
  0x40950c		c3			RET			
			return nil
  0x40950d		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x409516		c3			RET			

TEXT runtime.lock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lock_futex.go
func lock(l *mutex) {
  0x409520		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409529		483b6110		CMPQ 0x10(CX), SP	
  0x40952d		0f867e010000		JBE 0x4096b1		
  0x409533		4883ec40		SUBQ $0x40, SP		
  0x409537		48896c2438		MOVQ BP, 0x38(SP)	
  0x40953c		488d6c2438		LEAQ 0x38(SP), BP	
	gp := getg()
  0x409541		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if gp.m.locks < 0 {
  0x40954a		488b4930		MOVQ 0x30(CX), CX	
  0x40954e		8b9100010000		MOVL 0x100(CX), DX	
  0x409554		85d2			TESTL DX, DX		
  0x409556		0f8c3a010000		JL 0x409696		
	gp.m.locks++
  0x40955c		ffc2			INCL DX			
  0x40955e		899100010000		MOVL DX, 0x100(CX)	
	v := atomic.Xchg(key32(&l.key), mutex_locked)
  0x409564		b901000000		MOVL $0x1, CX		
  0x409569		488b542448		MOVQ 0x48(SP), DX	
  0x40956e		870a			XCHGL CX, 0(DX)		
	if v == mutex_unlocked {
  0x409570		85c9			TESTL CX, CX		
  0x409572		0f8414010000		JE 0x40968c		
	if ncpu > 1 {
  0x409578		8b1d66a30b00		MOVL runtime.ncpu(SB), BX	
  0x40957e		83fb01			CMPL $0x1, BX			
  0x409581		0f8efe000000		JLE 0x409685			
  0x409587		b804000000		MOVL $0x4, AX			
		for i := 0; i < spin; i++ {
  0x40958c		4889442420		MOVQ AX, 0x20(SP)	
  0x409591		e9da000000		JMP 0x409670		
  0x409596		4889f0			MOVQ SI, AX		
			for l.key == mutex_unlocked {
  0x409599		488b32			MOVQ 0(DX), SI		
  0x40959c		4885f6			TESTQ SI, SI		
  0x40959f		751c			JNE 0x4095bd		
  0x4095a1		4889c6			MOVQ AX, SI		
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x4095a4		31c0			XORL AX, AX		
  0x4095a6		f00fb10a		LOCK CMPXCHGL CX, 0(DX)	
  0x4095aa		400f94c7		SETE DI			
  0x4095ae		4084ff			TESTL DI, DI		
  0x4095b1		74e3			JE 0x409596		
					return
  0x4095b3		488b6c2438		MOVQ 0x38(SP), BP	
  0x4095b8		4883c440		ADDQ $0x40, SP		
  0x4095bc		c3			RET			
  0x4095bd		48895c2430		MOVQ BX, 0x30(SP)	
			procyield(active_spin_cnt)
  0x4095c2		c704241e000000		MOVL $0x1e, 0(SP)		
  0x4095c9		e8a2c50300		CALL runtime.procyield(SB)	
  0x4095ce		488b442430		MOVQ 0x30(SP), AX		
		for i := 0; i < spin; i++ {
  0x4095d3		488d5801		LEAQ 0x1(AX), BX	
  0x4095d7		488b442420		MOVQ 0x20(SP), AX	
  0x4095dc		8b4c241c		MOVL 0x1c(SP), CX	
  0x4095e0		488b542448		MOVQ 0x48(SP), DX	
  0x4095e5		4839c3			CMPQ AX, BX		
  0x4095e8		7caf			JL 0x409599		
  0x4095ea		31db			XORL BX, BX		
		for i := 0; i < passive_spin; i++ {
  0x4095ec		eb48			JMP 0x409636		
  0x4095ee		4889f0			MOVQ SI, AX		
			for l.key == mutex_unlocked {
  0x4095f1		488b32			MOVQ 0(DX), SI		
  0x4095f4		4885f6			TESTQ SI, SI		
  0x4095f7		751c			JNE 0x409615		
  0x4095f9		4889c6			MOVQ AX, SI		
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x4095fc		31c0			XORL AX, AX		
  0x4095fe		f00fb10a		LOCK CMPXCHGL CX, 0(DX)	
  0x409602		400f94c7		SETE DI			
  0x409606		4084ff			TESTL DI, DI		
  0x409609		74e3			JE 0x4095ee		
					return
  0x40960b		488b6c2438		MOVQ 0x38(SP), BP	
  0x409610		4883c440		ADDQ $0x40, SP		
  0x409614		c3			RET			
  0x409615		48895c2428		MOVQ BX, 0x28(SP)	
			osyield()
  0x40961a		e831e90300		CALL runtime.osyield(SB)	
  0x40961f		488b442428		MOVQ 0x28(SP), AX		
		for i := 0; i < passive_spin; i++ {
  0x409624		488d5801		LEAQ 0x1(AX), BX	
  0x409628		488b442420		MOVQ 0x20(SP), AX	
  0x40962d		8b4c241c		MOVL 0x1c(SP), CX	
  0x409631		488b542448		MOVQ 0x48(SP), DX	
  0x409636		4883fb01		CMPQ $0x1, BX		
  0x40963a		7cb5			JL 0x4095f1		
		v = atomic.Xchg(key32(&l.key), mutex_sleeping)
  0x40963c		b902000000		MOVL $0x2, CX		
  0x409641		870a			XCHGL CX, 0(DX)		
		if v == mutex_unlocked {
  0x409643		85c9			TESTL CX, CX		
  0x409645		7434			JE 0x40967b		
		futexsleep(key32(&l.key), mutex_sleeping, -1)
  0x409647		48891424		MOVQ DX, 0(SP)			
  0x40964b		c744240802000000	MOVL $0x2, 0x8(SP)		
  0x409653		48c7442410ffffffff	MOVQ $-0x1, 0x10(SP)		
  0x40965c		e8ff550100		CALL runtime.futexsleep(SB)	
  0x409661		488b442420		MOVQ 0x20(SP), AX		
  0x409666		488b542448		MOVQ 0x48(SP), DX		
  0x40966b		b902000000		MOVL $0x2, CX			
		for i := 0; i < spin; i++ {
  0x409670		894c241c		MOVL CX, 0x1c(SP)	
  0x409674		31db			XORL BX, BX		
  0x409676		e96affffff		JMP 0x4095e5		
			return
  0x40967b		488b6c2438		MOVQ 0x38(SP), BP	
  0x409680		4883c440		ADDQ $0x40, SP		
  0x409684		c3			RET			
  0x409685		31c0			XORL AX, AX		
	if ncpu > 1 {
  0x409687		e900ffffff		JMP 0x40958c		
		return
  0x40968c		488b6c2438		MOVQ 0x38(SP), BP	
  0x409691		4883c440		ADDQ $0x40, SP		
  0x409695		c3			RET			
		throw("runtime·lock: lock count")
  0x409696		488d0572240600		LEAQ 0x62472(IP), AX	
  0x40969d		48890424		MOVQ AX, 0(SP)		
  0x4096a1		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x4096aa		e8217b0100		CALL runtime.throw(SB)	
  0x4096af		0f0b			UD2			
func lock(l *mutex) {
  0x4096b1		e8baae0300		CALL runtime.morestack_noctxt(SB)	
  0x4096b6		e965feffff		JMP runtime.lock(SB)			

TEXT runtime.unlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lock_futex.go
func unlock(l *mutex) {
  0x4096c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4096c9		483b6110		CMPQ 0x10(CX), SP	
  0x4096cd		0f86aa000000		JBE 0x40977d		
  0x4096d3		4883ec18		SUBQ $0x18, SP		
  0x4096d7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4096dc		488d6c2410		LEAQ 0x10(SP), BP	
	v := atomic.Xchg(key32(&l.key), mutex_unlocked)
  0x4096e1		31c0			XORL AX, AX		
  0x4096e3		488b4c2420		MOVQ 0x20(SP), CX	
  0x4096e8		8701			XCHGL AX, 0(CX)		
	if v == mutex_unlocked {
  0x4096ea		85c0			TESTL AX, AX		
  0x4096ec		7474			JE 0x409762		
	if v == mutex_sleeping {
  0x4096ee		83f802			CMPL $0x2, AX		
  0x4096f1		7441			JE 0x409734		
	gp := getg()
  0x4096f3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	gp.m.locks--
  0x4096fc		488b4830		MOVQ 0x30(AX), CX	
  0x409700		838100010000ff		ADDL $-0x1, 0x100(CX)	
	if gp.m.locks < 0 {
  0x409707		488b4830		MOVQ 0x30(AX), CX	
  0x40970b		8b8900010000		MOVL 0x100(CX), CX	
  0x409711		85c9			TESTL CX, CX		
  0x409713		7c32			JL 0x409747		
	if gp.m.locks == 0 && gp.preempt { // restore the preemption request in case we've cleared it in newstack
  0x409715		7513			JNE 0x40972a		
  0x409717		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x40971e		84c9			TESTL CL, CL		
  0x409720		7408			JE 0x40972a		
		gp.stackguard0 = stackPreempt
  0x409722		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x40972a		488b6c2410		MOVQ 0x10(SP), BP	
  0x40972f		4883c418		ADDQ $0x18, SP		
  0x409733		c3			RET			
		futexwakeup(key32(&l.key), 1)
  0x409734		48890c24		MOVQ CX, 0(SP)			
  0x409738		c744240801000000	MOVL $0x1, 0x8(SP)		
  0x409740		e8eb550100		CALL runtime.futexwakeup(SB)	
  0x409745		ebac			JMP 0x4096f3			
		throw("runtime·unlock: lock count")
  0x409747		488d055c270600		LEAQ 0x6275c(IP), AX	
  0x40974e		48890424		MOVQ AX, 0(SP)		
  0x409752		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x40975b		e8707a0100		CALL runtime.throw(SB)	
  0x409760		0f0b			UD2			
		throw("unlock of unlocked lock")
  0x409762		488d05af200600		LEAQ 0x620af(IP), AX	
  0x409769		48890424		MOVQ AX, 0(SP)		
  0x40976d		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x409776		e8557a0100		CALL runtime.throw(SB)	
  0x40977b		0f0b			UD2			
func unlock(l *mutex) {
  0x40977d		e8eead0300		CALL runtime.morestack_noctxt(SB)	
  0x409782		e939ffffff		JMP runtime.unlock(SB)			

TEXT runtime.notewakeup(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lock_futex.go
func notewakeup(n *note) {
  0x409790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409799		483b6110		CMPQ 0x10(CX), SP	
  0x40979d		0f86a3000000		JBE 0x409846		
  0x4097a3		4883ec20		SUBQ $0x20, SP		
  0x4097a7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4097ac		488d6c2418		LEAQ 0x18(SP), BP	
	old := atomic.Xchg(key32(&n.key), 1)
  0x4097b1		b801000000		MOVL $0x1, AX		
  0x4097b6		488b4c2428		MOVQ 0x28(SP), CX	
  0x4097bb		8701			XCHGL AX, 0(CX)		
	if old != 0 {
  0x4097bd		85c0			TESTL AX, AX		
  0x4097bf		751b			JNE 0x4097dc		
	futexwakeup(key32(&n.key), 1)
  0x4097c1		48890c24		MOVQ CX, 0(SP)			
  0x4097c5		c744240801000000	MOVL $0x1, 0x8(SP)		
  0x4097cd		e85e550100		CALL runtime.futexwakeup(SB)	
}
  0x4097d2		488b6c2418		MOVQ 0x18(SP), BP	
  0x4097d7		4883c420		ADDQ $0x20, SP		
  0x4097db		c3			RET			
  0x4097dc		89442414		MOVL AX, 0x14(SP)	
		print("notewakeup - double wakeup (", old, ")\n")
  0x4097e0		e81b830100		CALL runtime.printlock(SB)	
  0x4097e5		488d05aa290600		LEAQ 0x629aa(IP), AX		
  0x4097ec		48890424		MOVQ AX, 0(SP)			
  0x4097f0		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x4097f9		e8428c0100		CALL runtime.printstring(SB)	
  0x4097fe		8b442414		MOVL 0x14(SP), AX		
  0x409802		89c0			MOVL AX, AX			
  0x409804		48890424		MOVQ AX, 0(SP)			
  0x409808		e863890100		CALL runtime.printuint(SB)	
  0x40980d		488d0556040600		LEAQ 0x60456(IP), AX		
  0x409814		48890424		MOVQ AX, 0(SP)			
  0x409818		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x409821		e81a8c0100		CALL runtime.printstring(SB)	
  0x409826		e855830100		CALL runtime.printunlock(SB)	
		throw("notewakeup - double wakeup")
  0x40982b		488d0510240600		LEAQ 0x62410(IP), AX	
  0x409832		48890424		MOVQ AX, 0(SP)		
  0x409836		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x40983f		e88c790100		CALL runtime.throw(SB)	
  0x409844		0f0b			UD2			
func notewakeup(n *note) {
  0x409846		e825ad0300		CALL runtime.morestack_noctxt(SB)	
  0x40984b		e940ffffff		JMP runtime.notewakeup(SB)		

TEXT runtime.notesleep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lock_futex.go
func notesleep(n *note) {
  0x409850		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409859		483b6110		CMPQ 0x10(CX), SP	
  0x40985d		0f86dc000000		JBE 0x40993f		
  0x409863		4883ec30		SUBQ $0x30, SP		
  0x409867		48896c2428		MOVQ BP, 0x28(SP)	
  0x40986c		488d6c2428		LEAQ 0x28(SP), BP	
	gp := getg()
  0x409871		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != gp.m.g0 {
  0x40987a		488b4830		MOVQ 0x30(AX), CX	
  0x40987e		488b09			MOVQ 0(CX), CX		
  0x409881		4839c8			CMPQ CX, AX		
  0x409884		0f859a000000		JNE 0x409924		
	if *cgo_yield != nil {
  0x40988a		488b0d8fc10900		MOVQ 0x9c18f(IP), CX	
  0x409891		488b09			MOVQ 0(CX), CX		
  0x409894		4885c9			TESTQ CX, CX		
  0x409897		747f			JE 0x409918		
  0x409899		b980969800		MOVL $0x989680, CX	
	for atomic.Load(key32(&n.key)) == 0 {
  0x40989e		4889442420		MOVQ AX, 0x20(SP)	
  0x4098a3		48894c2418		MOVQ CX, 0x18(SP)	
  0x4098a8		eb15			JMP 0x4098bf		
  0x4098aa		488b442420		MOVQ 0x20(SP), AX	
		gp.m.blocked = false
  0x4098af		488b5030		MOVQ 0x30(AX), DX	
  0x4098b3		c6821501000000		MOVB $0x0, 0x115(DX)	
  0x4098ba		488b4c2418		MOVQ 0x18(SP), CX	
	for atomic.Load(key32(&n.key)) == 0 {
  0x4098bf		488b542438		MOVQ 0x38(SP), DX	
  0x4098c4		8b1a			MOVL 0(DX), BX		
  0x4098c6		85db			TESTL BX, BX		
  0x4098c8		7544			JNE 0x40990e		
		gp.m.blocked = true
  0x4098ca		488b5830		MOVQ 0x30(AX), BX	
  0x4098ce		c6831501000001		MOVB $0x1, 0x115(BX)	
		futexsleep(key32(&n.key), 0, ns)
  0x4098d5		48891424		MOVQ DX, 0(SP)			
  0x4098d9		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x4098e1		48894c2410		MOVQ CX, 0x10(SP)		
  0x4098e6		e875530100		CALL runtime.futexsleep(SB)	
		if *cgo_yield != nil {
  0x4098eb		488b052ec10900		MOVQ 0x9c12e(IP), AX	
  0x4098f2		488b00			MOVQ 0(AX), AX		
  0x4098f5		4885c0			TESTQ AX, AX		
  0x4098f8		74b0			JE 0x4098aa		
			asmcgocall(*cgo_yield, nil)
  0x4098fa		48890424		MOVQ AX, 0(SP)			
  0x4098fe		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x409907		e8e4c20300		CALL runtime.asmcgocall(SB)	
  0x40990c		eb9c			JMP 0x4098aa			
  0x40990e		488b6c2428		MOVQ 0x28(SP), BP		
  0x409913		4883c430		ADDQ $0x30, SP			
  0x409917		c3			RET				
  0x409918		48c7c1ffffffff		MOVQ $-0x1, CX			
	if *cgo_yield != nil {
  0x40991f		e97affffff		JMP 0x40989e		
		throw("notesleep not on g0")
  0x409924		488d05a7150600		LEAQ 0x615a7(IP), AX	
  0x40992b		48890424		MOVQ AX, 0(SP)		
  0x40992f		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x409938		e893780100		CALL runtime.throw(SB)	
  0x40993d		0f0b			UD2			
func notesleep(n *note) {
  0x40993f		e82cac0300		CALL runtime.morestack_noctxt(SB)	
  0x409944		e907ffffff		JMP runtime.notesleep(SB)		

TEXT runtime.notetsleep_internal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lock_futex.go
func notetsleep_internal(n *note, ns int64) bool {
  0x409950		4883ec30		SUBQ $0x30, SP		
  0x409954		48896c2428		MOVQ BP, 0x28(SP)	
  0x409959		488d6c2428		LEAQ 0x28(SP), BP	
	gp := getg()
  0x40995e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x409967		4889442420		MOVQ AX, 0x20(SP)	
  0x40996c		488b4c2440		MOVQ 0x40(SP), CX	
	if ns < 0 {
  0x409971		4885c9			TESTQ CX, CX		
  0x409974		0f8d8e000000		JGE 0x409a08		
		if *cgo_yield != nil {
  0x40997a		488b159fc00900		MOVQ 0x9c09f(IP), DX	
  0x409981		488b12			MOVQ 0(DX), DX		
  0x409984		4885d2			TESTQ DX, DX		
  0x409987		7405			JE 0x40998e		
  0x409989		b980969800		MOVL $0x989680, CX	
		for atomic.Load(key32(&n.key)) == 0 {
  0x40998e		48894c2440		MOVQ CX, 0x40(SP)	
  0x409993		eb15			JMP 0x4099aa		
  0x409995		488b442420		MOVQ 0x20(SP), AX	
			gp.m.blocked = false
  0x40999a		488b5030		MOVQ 0x30(AX), DX	
  0x40999e		c6821501000000		MOVB $0x0, 0x115(DX)	
  0x4099a5		488b4c2440		MOVQ 0x40(SP), CX	
		for atomic.Load(key32(&n.key)) == 0 {
  0x4099aa		488b542438		MOVQ 0x38(SP), DX	
  0x4099af		8b1a			MOVL 0(DX), BX		
  0x4099b1		85db			TESTL BX, BX		
  0x4099b3		7544			JNE 0x4099f9		
			gp.m.blocked = true
  0x4099b5		488b5830		MOVQ 0x30(AX), BX	
  0x4099b9		c6831501000001		MOVB $0x1, 0x115(BX)	
			futexsleep(key32(&n.key), 0, ns)
  0x4099c0		48891424		MOVQ DX, 0(SP)			
  0x4099c4		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x4099cc		48894c2410		MOVQ CX, 0x10(SP)		
  0x4099d1		e88a520100		CALL runtime.futexsleep(SB)	
			if *cgo_yield != nil {
  0x4099d6		488b0543c00900		MOVQ 0x9c043(IP), AX	
  0x4099dd		488b00			MOVQ 0(AX), AX		
  0x4099e0		4885c0			TESTQ AX, AX		
  0x4099e3		74b0			JE 0x409995		
				asmcgocall(*cgo_yield, nil)
  0x4099e5		48890424		MOVQ AX, 0(SP)			
  0x4099e9		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4099f2		e8f9c10300		CALL runtime.asmcgocall(SB)	
  0x4099f7		eb9c			JMP 0x409995			
		return true
  0x4099f9		c644244801		MOVB $0x1, 0x48(SP)	
  0x4099fe		488b6c2428		MOVQ 0x28(SP), BP	
  0x409a03		4883c430		ADDQ $0x30, SP		
  0x409a07		c3			RET			
  0x409a08		488b542438		MOVQ 0x38(SP), DX	
	if atomic.Load(key32(&n.key)) != 0 {
  0x409a0d		8b1a			MOVL 0(DX), BX		
  0x409a0f		85db			TESTL BX, BX		
  0x409a11		0f85d9000000		JNE 0x409af0		
	deadline := nanotime() + ns
  0x409a17		e814e00300		CALL runtime.nanotime(SB)	
  0x409a1c		488b0424		MOVQ 0(SP), AX			
  0x409a20		488b4c2440		MOVQ 0x40(SP), CX		
  0x409a25		4801c8			ADDQ CX, AX			
  0x409a28		4889442418		MOVQ AX, 0x18(SP)		
	for {
  0x409a2d		eb09			JMP 0x409a38		
  0x409a2f		4889ca			MOVQ CX, DX		
		ns = deadline - now
  0x409a32		4829c1			SUBQ AX, CX		
  0x409a35		4889d0			MOVQ DX, AX		
		if *cgo_yield != nil && ns > 10e6 {
  0x409a38		488b15e1bf0900		MOVQ 0x9bfe1(IP), DX	
  0x409a3f		488b12			MOVQ 0(DX), DX		
  0x409a42		4885d2			TESTQ DX, DX		
  0x409a45		740e			JE 0x409a55		
  0x409a47		4881f980969800		CMPQ $0x989680, CX	
  0x409a4e		7e05			JLE 0x409a55		
  0x409a50		b980969800		MOVL $0x989680, CX	
		gp.m.blocked = true
  0x409a55		488b442420		MOVQ 0x20(SP), AX	
  0x409a5a		488b5030		MOVQ 0x30(AX), DX	
  0x409a5e		c6821501000001		MOVB $0x1, 0x115(DX)	
  0x409a65		488b542438		MOVQ 0x38(SP), DX	
		futexsleep(key32(&n.key), 0, ns)
  0x409a6a		48891424		MOVQ DX, 0(SP)			
  0x409a6e		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x409a76		48894c2410		MOVQ CX, 0x10(SP)		
  0x409a7b		e8e0510100		CALL runtime.futexsleep(SB)	
		if *cgo_yield != nil {
  0x409a80		488b0599bf0900		MOVQ 0x9bf99(IP), AX	
  0x409a87		488b00			MOVQ 0(AX), AX		
  0x409a8a		4885c0			TESTQ AX, AX		
  0x409a8d		754d			JNE 0x409adc		
  0x409a8f		488b442420		MOVQ 0x20(SP), AX	
		gp.m.blocked = false
  0x409a94		488b4830		MOVQ 0x30(AX), CX	
  0x409a98		c6811501000000		MOVB $0x0, 0x115(CX)	
  0x409a9f		488b4c2438		MOVQ 0x38(SP), CX	
		if atomic.Load(key32(&n.key)) != 0 {
  0x409aa4		8b11			MOVL 0(CX), DX		
  0x409aa6		85d2			TESTL DX, DX		
  0x409aa8		7517			JNE 0x409ac1		
		now := nanotime()
  0x409aaa		e881df0300		CALL runtime.nanotime(SB)	
  0x409aaf		488b0424		MOVQ 0(SP), AX			
  0x409ab3		488b4c2418		MOVQ 0x18(SP), CX		
		if now >= deadline {
  0x409ab8		4839c8			CMPQ CX, AX		
  0x409abb		0f8c6effffff		JL 0x409a2f		
  0x409ac1		488b442438		MOVQ 0x38(SP), AX	
	return atomic.Load(key32(&n.key)) != 0
  0x409ac6		8b00			MOVL 0(AX), AX		
  0x409ac8		85c0			TESTL AX, AX		
  0x409aca		488d442448		LEAQ 0x48(SP), AX	
  0x409acf		0f9500			SETNE 0(AX)		
  0x409ad2		488b6c2428		MOVQ 0x28(SP), BP	
  0x409ad7		4883c430		ADDQ $0x30, SP		
  0x409adb		c3			RET			
			asmcgocall(*cgo_yield, nil)
  0x409adc		48890424		MOVQ AX, 0(SP)			
  0x409ae0		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x409ae9		e802c10300		CALL runtime.asmcgocall(SB)	
  0x409aee		eb9f			JMP 0x409a8f			
		return true
  0x409af0		c644244801		MOVB $0x1, 0x48(SP)	
  0x409af5		488b6c2428		MOVQ 0x28(SP), BP	
  0x409afa		4883c430		ADDQ $0x30, SP		
  0x409afe		c3			RET			

TEXT runtime.notetsleep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lock_futex.go
func notetsleep(n *note, ns int64) bool {
  0x409b00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409b09		483b6110		CMPQ 0x10(CX), SP	
  0x409b0d		7675			JBE 0x409b84		
  0x409b0f		4883ec20		SUBQ $0x20, SP		
  0x409b13		48896c2418		MOVQ BP, 0x18(SP)	
  0x409b18		488d6c2418		LEAQ 0x18(SP), BP	
	gp := getg()
  0x409b1d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != gp.m.g0 && gp.m.preemptoff != "" {
  0x409b26		488b4830		MOVQ 0x30(AX), CX	
  0x409b2a		488b11			MOVQ 0(CX), DX		
  0x409b2d		4839d0			CMPQ DX, AX		
  0x409b30		740c			JE 0x409b3e		
  0x409b32		488b81f8000000		MOVQ 0xf8(CX), AX	
  0x409b39		4885c0			TESTQ AX, AX		
  0x409b3c		752b			JNE 0x409b69		
  0x409b3e		488b442428		MOVQ 0x28(SP), AX	
	return notetsleep_internal(n, ns)
  0x409b43		48890424		MOVQ AX, 0(SP)				
  0x409b47		488b442430		MOVQ 0x30(SP), AX			
  0x409b4c		4889442408		MOVQ AX, 0x8(SP)			
  0x409b51		e8fafdffff		CALL runtime.notetsleep_internal(SB)	
  0x409b56		0fb6442410		MOVZX 0x10(SP), AX			
  0x409b5b		88442438		MOVB AL, 0x38(SP)			
  0x409b5f		488b6c2418		MOVQ 0x18(SP), BP			
  0x409b64		4883c420		ADDQ $0x20, SP				
  0x409b68		c3			RET					
		throw("notetsleep not on g0")
  0x409b69		488d05fd150600		LEAQ 0x615fd(IP), AX	
  0x409b70		48890424		MOVQ AX, 0(SP)		
  0x409b74		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x409b7d		e84e760100		CALL runtime.throw(SB)	
  0x409b82		0f0b			UD2			
func notetsleep(n *note, ns int64) bool {
  0x409b84		e8e7a90300		CALL runtime.morestack_noctxt(SB)	
  0x409b89		e972ffffff		JMP runtime.notetsleep(SB)		

TEXT runtime.notetsleepg(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/lock_futex.go
func notetsleepg(n *note, ns int64) bool {
  0x409b90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409b99		483b6110		CMPQ 0x10(CX), SP	
  0x409b9d		0f868a000000		JBE 0x409c2d		
  0x409ba3		4883ec28		SUBQ $0x28, SP		
  0x409ba7		48896c2420		MOVQ BP, 0x20(SP)	
  0x409bac		488d6c2420		LEAQ 0x20(SP), BP	
	gp := getg()
  0x409bb1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp == gp.m.g0 {
  0x409bba		488b4830		MOVQ 0x30(AX), CX	
  0x409bbe		488b09			MOVQ 0(CX), CX		
  0x409bc1		4839c8			CMPQ CX, AX		
  0x409bc4		744c			JE 0x409c12		
	entersyscallblock(0)
  0x409bc6		c7042400000000		MOVL $0x0, 0(SP)			
  0x409bcd		e87efd0100		CALL runtime.entersyscallblock(SB)	
  0x409bd2		488b442430		MOVQ 0x30(SP), AX			
	ok := notetsleep_internal(n, ns)
  0x409bd7		48890424		MOVQ AX, 0(SP)				
  0x409bdb		488b442438		MOVQ 0x38(SP), AX			
  0x409be0		4889442408		MOVQ AX, 0x8(SP)			
  0x409be5		e866fdffff		CALL runtime.notetsleep_internal(SB)	
  0x409bea		0fb6442410		MOVZX 0x10(SP), AX			
  0x409bef		8844241f		MOVB AL, 0x1f(SP)			
	exitsyscall(0)
  0x409bf3		c7042400000000		MOVL $0x0, 0(SP)		
  0x409bfa		e861ff0100		CALL runtime.exitsyscall(SB)	
	return ok
  0x409bff		0fb644241f		MOVZX 0x1f(SP), AX	
  0x409c04		88442440		MOVB AL, 0x40(SP)	
  0x409c08		488b6c2420		MOVQ 0x20(SP), BP	
  0x409c0d		4883c428		ADDQ $0x28, SP		
  0x409c11		c3			RET			
		throw("notetsleepg on g0")
  0x409c12		488d0566100600		LEAQ 0x61066(IP), AX	
  0x409c19		48890424		MOVQ AX, 0(SP)		
  0x409c1d		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x409c26		e8a5750100		CALL runtime.throw(SB)	
  0x409c2b		0f0b			UD2			
func notetsleepg(n *note, ns int64) bool {
  0x409c2d		e83ea90300		CALL runtime.morestack_noctxt(SB)	
  0x409c32		e959ffffff		JMP runtime.notetsleepg(SB)		

TEXT runtime.mallocinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func mallocinit() {
  0x409c40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409c49		488d4424e8		LEAQ -0x18(SP), AX	
  0x409c4e		483b4110		CMPQ 0x10(CX), AX	
  0x409c52		0f86e2040000		JBE 0x40a13a		
  0x409c58		4881ec98000000		SUBQ $0x98, SP		
  0x409c5f		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x409c67		488dac2490000000	LEAQ 0x90(SP), BP	
	if class_to_size[_TinySizeClass] != _TinySize {
  0x409c6f		0fb7054eb50900		MOVZX runtime.class_to_size+4(SB), AX	
  0x409c76		6683f810		CMPW $0x10, AX				
  0x409c7a		0f859f040000		JNE 0x40a11f				
	testdefersizes()
  0x409c80		e8cb610100		CALL runtime.testdefersizes(SB)	
  0x409c85		31c0			XORL AX, AX			
	for i := range class_to_size {
  0x409c87		eb20			JMP 0x409ca9		
		memstats.by_size[i].size = uint32(class_to_size[i])
  0x409c89		488d0c40		LEAQ 0(AX)(AX*2), CX			
  0x409c8d		488d152cb50900		LEAQ runtime.class_to_size(SB), DX	
  0x409c94		0fb71c42		MOVZX 0(DX)(AX*2), BX			
  0x409c98		488d3561aa0b00		LEAQ runtime.memstats(SB), SI		
  0x409c9f		899cced8100000		MOVL BX, 0x10d8(SI)(CX*8)		
	for i := range class_to_size {
  0x409ca6		48ffc0			INCQ AX			
  0x409ca9		4883f843		CMPQ $0x43, AX		
  0x409cad		7cda			JL 0x409c89		
	if physPageSize == 0 {
  0x409caf		488b05ea9c0b00		MOVQ runtime.physPageSize(SB), AX	
  0x409cb6		4885c0			TESTQ AX, AX				
  0x409cb9		0f8445040000		JE 0x40a104				
	if physPageSize < minPhysPageSize {
  0x409cbf		483d00100000		CMPQ $0x1000, AX	
  0x409cc5		0f82ac030000		JB 0x40a077		
	if physPageSize&(physPageSize-1) != 0 {
  0x409ccb		488d48ff		LEAQ -0x1(AX), CX	
  0x409ccf		4885c8			TESTQ CX, AX		
  0x409cd2		0f8538030000		JNE 0x40a010		
	var reserved bool
  0x409cd8		c644242700		MOVB $0x0, 0x27(SP)	
  0x409cdd		31c0			XORL AX, AX		
  0x409cdf		31c9			XORL CX, CX		
		for i := 0; i <= 0x7f; i++ {
  0x409ce1		eb0e			JMP 0x409cf1		
  0x409ce3		488b542448		MOVQ 0x48(SP), DX	
  0x409ce8		48ffc2			INCQ DX			
  0x409ceb		4889c1			MOVQ AX, CX		
  0x409cee		4889d0			MOVQ DX, AX		
  0x409cf1		4883f87f		CMPQ $0x7f, AX		
  0x409cf5		0f8f1c020000		JG 0x409f17		
  0x409cfb		4889442448		MOVQ AX, 0x48(SP)	
				p = uintptr(i)<<40 | uintptrMask&(0x00c0<<32)
  0x409d00		48c1e028		SHLQ $0x28, AX		
  0x409d04		48ba00000000c0000000	MOVQ $0xc000000000, DX	
  0x409d0e		4809d0			ORQ DX, AX		
			p = uintptr(sysReserve(unsafe.Pointer(p), pSize, &reserved))
  0x409d11		48890424		MOVQ AX, 0(SP)			
  0x409d15		48b80020002084000000	MOVQ $0x8420002000, AX		
  0x409d1f		4889442408		MOVQ AX, 0x8(SP)		
  0x409d24		488d5c2427		LEAQ 0x27(SP), BX		
  0x409d29		48895c2410		MOVQ BX, 0x10(SP)		
  0x409d2e		e8bd560000		CALL runtime.sysReserve(SB)	
  0x409d33		488b442418		MOVQ 0x18(SP), AX		
			if p != 0 {
  0x409d38		4885c0			TESTQ AX, AX		
  0x409d3b		74a6			JE 0x409ce3		
	if p == 0 {
  0x409d3d		4885c0			TESTQ AX, AX		
  0x409d40		0f84ce000000		JE 0x409e14		
  0x409d46		48b90020002084000000	MOVQ $0x8420002000, CX	
	return (n + a - 1) &^ (a - 1)
  0x409d50		488d90ff1f0000		LEAQ 0x1fff(AX), DX	
  0x409d57		4881e200e0ffff		ANDQ $-0x2000, DX	
	mheap_.bitmap = p1 + bitmapSize
  0x409d5e		48bb0000002004000000	MOVQ $0x420000000, BX			
  0x409d68		4801d3			ADDQ DX, BX				
  0x409d6b		48891d46380a00		MOVQ BX, runtime.mheap_+4888(SB)	
		mheap_.arena_start = p1
  0x409d72		48891d4f380a00		MOVQ BX, runtime.mheap_+4904(SB)	
  0x409d79		4889d6			MOVQ DX, SI				
	pSize -= p1 - p
  0x409d7c		4829c2			SUBQ AX, DX		
  0x409d7f		4829d1			SUBQ DX, CX		
	mheap_.arena_end = p + pSize
  0x409d82		4801c1			ADDQ AX, CX				
  0x409d85		48890d54380a00		MOVQ CX, runtime.mheap_+4928(SB)	
	mheap_.arena_used = p1
  0x409d8c		48891d3d380a00		MOVQ BX, runtime.mheap_+4912(SB)	
	mheap_.arena_alloc = p1
  0x409d93		48891d3e380a00		MOVQ BX, runtime.mheap_+4920(SB)	
	mheap_.arena_reserved = reserved
  0x409d9a		0fb64c2427		MOVZX 0x27(SP), CX			
  0x409d9f		880d43380a00		MOVB CL, runtime.mheap_+4936(SB)	
	if mheap_.arena_start&(_PageSize-1) != 0 {
  0x409da5		488b0d1c380a00		MOVQ runtime.mheap_+4904(SB), CX	
  0x409dac		48f7c1ff1f0000		TESTQ $0x1fff, CX			
  0x409db3		0f8566010000		JNE 0x409f1f				
	mheap_.init(spansStart, spansSize)
  0x409db9		488d05e0240a00		LEAQ runtime.mheap_(SB), AX	
  0x409dc0		48890424		MOVQ AX, 0(SP)			
  0x409dc4		4889742408		MOVQ SI, 0x8(SP)		
  0x409dc9		48c744241000000020	MOVQ $0x20000000, 0x10(SP)	
  0x409dd2		e8b9010100		CALL runtime.(*mheap).init(SB)	
	_g_ := getg()
  0x409dd7		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x409de0		4889842488000000	MOVQ AX, 0x88(SP)	
	_g_.m.mcache = allocmcache()
  0x409de8		e833450000		CALL runtime.allocmcache(SB)	
  0x409ded		488b842488000000	MOVQ 0x88(SP), AX		
  0x409df5		488b4030		MOVQ 0x30(AX), AX		
  0x409df9		488b0c24		MOVQ 0(SP), CX			
  0x409dfd		48898860010000		MOVQ CX, 0x160(AX)		
}
  0x409e04		488bac2490000000	MOVQ 0x90(SP), BP	
  0x409e0c		4881c498000000		ADDQ $0x98, SP		
  0x409e13		c3			RET			
  0x409e14		4889442438		MOVQ AX, 0x38(SP)	
		procBrk := sbrk0()
  0x409e19		e892e10300		CALL runtime.sbrk0(SB)	
  0x409e1e		488b0424		MOVQ 0(SP), AX		
  0x409e22		4889442428		MOVQ AX, 0x28(SP)	
			0,
  0x409e27		488d7c2468		LEAQ 0x68(SP), DI			
  0x409e2c		488d352db00600		LEAQ runtime.statictmp_16(SB), SI	
  0x409e33		48896c24f0		MOVQ BP, -0x10(SP)			
  0x409e38		488d6c24f0		LEAQ -0x10(SP), BP			
  0x409e3d		e802d00300		CALL 0x446e44				
  0x409e42		488b6d00		MOVQ 0(BP), BP				
  0x409e46		31c9			XORL CX, CX				
  0x409e48		488b542438		MOVQ 0x38(SP), DX			
  0x409e4d		48bb0020002084000000	MOVQ $0x8420002000, BX			
		for _, arenaSize := range arenaSizes {
  0x409e57		eb16			JMP 0x409e6f		
  0x409e59		488b742460		MOVQ 0x60(SP), SI	
  0x409e5e		488d4e01		LEAQ 0x1(SI), CX	
  0x409e62		4889c2			MOVQ AX, DX		
  0x409e65		488b5c2430		MOVQ 0x30(SP), BX	
  0x409e6a		488b442428		MOVQ 0x28(SP), AX	
  0x409e6f		4883f904		CMPQ $0x4, CX		
  0x409e73		0f8d96000000		JGE 0x409f0f		
  0x409e79		48894c2460		MOVQ CX, 0x60(SP)	
  0x409e7e		488b54cc68		MOVQ 0x68(SP)(CX*8), DX	
			p = round(firstmoduledata.end+(1<<18), 1<<20)
  0x409e83		488b1d66ba0900		MOVQ runtime.firstmoduledata+176(SB), BX	
	return (n + a - 1) &^ (a - 1)
  0x409e8a		4881c3ffff1300		ADDQ $0x13ffff, BX	
  0x409e91		4881e30000f0ff		ANDQ $-0x100000, BX	
			if p <= procBrk && procBrk < p+pSize {
  0x409e98		4839c3			CMPQ AX, BX		
  0x409e9b		7766			JA 0x409f03		
  0x409e9d		488d341a		LEAQ 0(DX)(BX*1), SI	
  0x409ea1		48bf0020002004000000	MOVQ $0x420002000, DI	
  0x409eab		4801fe			ADDQ DI, SI		
  0x409eae		4839f0			CMPQ SI, AX		
  0x409eb1		730e			JAE 0x409ec1		
	return (n + a - 1) &^ (a - 1)
  0x409eb3		488d98ffff1f00		LEAQ 0x1fffff(AX), BX	
  0x409eba		4881e30000f0ff		ANDQ $-0x100000, BX	
			p = uintptr(sysReserve(unsafe.Pointer(p), pSize, &reserved))
  0x409ec1		48891c24		MOVQ BX, 0(SP)		
			pSize = bitmapSize + spansSize + arenaSize + _PageSize
  0x409ec5		488d0417		LEAQ 0(DI)(DX*1), AX	
  0x409ec9		4889442430		MOVQ AX, 0x30(SP)	
			p = uintptr(sysReserve(unsafe.Pointer(p), pSize, &reserved))
  0x409ece		4889442408		MOVQ AX, 0x8(SP)		
  0x409ed3		488d4c2427		LEAQ 0x27(SP), CX		
  0x409ed8		48894c2410		MOVQ CX, 0x10(SP)		
  0x409edd		e80e550000		CALL runtime.sysReserve(SB)	
  0x409ee2		488b442418		MOVQ 0x18(SP), AX		
			if p != 0 {
  0x409ee7		4885c0			TESTQ AX, AX		
  0x409eea		0f8469ffffff		JE 0x409e59		
  0x409ef0		488b4c2430		MOVQ 0x30(SP), CX	
		if p == 0 {
  0x409ef5		4885c0			TESTQ AX, AX		
  0x409ef8		0f84f7000000		JE 0x409ff5		
  0x409efe		e94dfeffff		JMP 0x409d50		
  0x409f03		48bf0020002004000000	MOVQ $0x420002000, DI	
			if p <= procBrk && procBrk < p+pSize {
  0x409f0d		ebb2			JMP 0x409ec1		
  0x409f0f		4889d0			MOVQ DX, AX		
  0x409f12		4889d9			MOVQ BX, CX		
		for _, arenaSize := range arenaSizes {
  0x409f15		ebde			JMP 0x409ef5		
  0x409f17		4889c8			MOVQ CX, AX		
		for i := 0; i <= 0x7f; i++ {
  0x409f1a		e91efeffff		JMP 0x409d3d		
  0x409f1f		4889442440		MOVQ AX, 0x40(SP)	
  0x409f24		48895c2458		MOVQ BX, 0x58(SP)	
  0x409f29		48894c2450		MOVQ CX, 0x50(SP)	
		println("bad pagesize", hex(p), hex(p1), hex(spansSize), hex(bitmapSize), hex(_PageSize), "start", hex(mheap_.arena_start))
  0x409f2e		e8cd7b0100		CALL runtime.printlock(SB)	
  0x409f33		488d0507080600		LEAQ 0x60807(IP), AX		
  0x409f3a		48890424		MOVQ AX, 0(SP)			
  0x409f3e		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x409f47		e8f4840100		CALL runtime.printstring(SB)	
  0x409f4c		488b442440		MOVQ 0x40(SP), AX		
  0x409f51		48890424		MOVQ AX, 0(SP)			
  0x409f55		e896830100		CALL runtime.printhex(SB)	
  0x409f5a		e8e17d0100		CALL runtime.printsp(SB)	
  0x409f5f		488b442458		MOVQ 0x58(SP), AX		
  0x409f64		48890424		MOVQ AX, 0(SP)			
  0x409f68		e883830100		CALL runtime.printhex(SB)	
  0x409f6d		e8ce7d0100		CALL runtime.printsp(SB)	
  0x409f72		48c7042400000020	MOVQ $0x20000000, 0(SP)		
  0x409f7a		e871830100		CALL runtime.printhex(SB)	
  0x409f7f		e8bc7d0100		CALL runtime.printsp(SB)	
  0x409f84		48b80000000004000000	MOVQ $0x400000000, AX		
  0x409f8e		48890424		MOVQ AX, 0(SP)			
  0x409f92		e859830100		CALL runtime.printhex(SB)	
  0x409f97		e8a47d0100		CALL runtime.printsp(SB)	
  0x409f9c		48c7042400200000	MOVQ $0x2000, 0(SP)		
  0x409fa4		e847830100		CALL runtime.printhex(SB)	
  0x409fa9		488d05dbfe0500		LEAQ 0x5fedb(IP), AX		
  0x409fb0		48890424		MOVQ AX, 0(SP)			
  0x409fb4		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x409fbd		e87e840100		CALL runtime.printstring(SB)	
  0x409fc2		488b442450		MOVQ 0x50(SP), AX		
  0x409fc7		48890424		MOVQ AX, 0(SP)			
  0x409fcb		e820830100		CALL runtime.printhex(SB)	
  0x409fd0		e8bb7d0100		CALL runtime.printnl(SB)	
  0x409fd5		e8a67b0100		CALL runtime.printunlock(SB)	
		throw("misrounded allocation in mallocinit")
  0x409fda		488d05712d0600		LEAQ 0x62d71(IP), AX	
  0x409fe1		48890424		MOVQ AX, 0(SP)		
  0x409fe5		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x409fee		e8dd710100		CALL runtime.throw(SB)	
  0x409ff3		0f0b			UD2			
			throw("runtime: cannot reserve arena virtual address space")
  0x409ff5		488d058c3a0600		LEAQ 0x63a8c(IP), AX	
  0x409ffc		48890424		MOVQ AX, 0(SP)		
  0x40a000		48c744240833000000	MOVQ $0x33, 0x8(SP)	
  0x40a009		e8c2710100		CALL runtime.throw(SB)	
  0x40a00e		0f0b			UD2			
		print("system page size (", physPageSize, ") must be a power of 2\n")
  0x40a010		e8eb7a0100		CALL runtime.printlock(SB)		
  0x40a015		488d05ad0d0600		LEAQ 0x60dad(IP), AX			
  0x40a01c		48890424		MOVQ AX, 0(SP)				
  0x40a020		48c744240812000000	MOVQ $0x12, 0x8(SP)			
  0x40a029		e812840100		CALL runtime.printstring(SB)		
  0x40a02e		488b056b990b00		MOVQ runtime.physPageSize(SB), AX	
  0x40a035		48890424		MOVQ AX, 0(SP)				
  0x40a039		e832810100		CALL runtime.printuint(SB)		
  0x40a03e		488d0566150600		LEAQ 0x61566(IP), AX			
  0x40a045		48890424		MOVQ AX, 0(SP)				
  0x40a049		48c744240817000000	MOVQ $0x17, 0x8(SP)			
  0x40a052		e8e9830100		CALL runtime.printstring(SB)		
  0x40a057		e8247b0100		CALL runtime.printunlock(SB)		
		throw("bad system page size")
  0x40a05c		488d051a100600		LEAQ 0x6101a(IP), AX	
  0x40a063		48890424		MOVQ AX, 0(SP)		
  0x40a067		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x40a070		e85b710100		CALL runtime.throw(SB)	
  0x40a075		0f0b			UD2			
		print("system page size (", physPageSize, ") is smaller than minimum page size (", minPhysPageSize, ")\n")
  0x40a077		e8847a0100		CALL runtime.printlock(SB)		
  0x40a07c		488d05460d0600		LEAQ 0x60d46(IP), AX			
  0x40a083		48890424		MOVQ AX, 0(SP)				
  0x40a087		48c744240812000000	MOVQ $0x12, 0x8(SP)			
  0x40a090		e8ab830100		CALL runtime.printstring(SB)		
  0x40a095		488b0504990b00		MOVQ runtime.physPageSize(SB), AX	
  0x40a09c		48890424		MOVQ AX, 0(SP)				
  0x40a0a0		e8cb800100		CALL runtime.printuint(SB)		
  0x40a0a5		488d059a2e0600		LEAQ 0x62e9a(IP), AX			
  0x40a0ac		48890424		MOVQ AX, 0(SP)				
  0x40a0b0		48c744240825000000	MOVQ $0x25, 0x8(SP)			
  0x40a0b9		e882830100		CALL runtime.printstring(SB)		
  0x40a0be		48c7042400100000	MOVQ $0x1000, 0(SP)			
  0x40a0c6		e8b5810100		CALL runtime.printint(SB)		
  0x40a0cb		488d0598fb0500		LEAQ 0x5fb98(IP), AX			
  0x40a0d2		48890424		MOVQ AX, 0(SP)				
  0x40a0d6		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x40a0df		e85c830100		CALL runtime.printstring(SB)		
  0x40a0e4		e8977a0100		CALL runtime.printunlock(SB)		
		throw("bad system page size")
  0x40a0e9		488d058d0f0600		LEAQ 0x60f8d(IP), AX	
  0x40a0f0		48890424		MOVQ AX, 0(SP)		
  0x40a0f4		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x40a0fd		e8ce700100		CALL runtime.throw(SB)	
  0x40a102		0f0b			UD2			
		throw("failed to get system page size")
  0x40a104		488d05f6230600		LEAQ 0x623f6(IP), AX	
  0x40a10b		48890424		MOVQ AX, 0(SP)		
  0x40a10f		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x40a118		e8b3700100		CALL runtime.throw(SB)	
  0x40a11d		0f0b			UD2			
		throw("bad TinySizeClass")
  0x40a11f		488d05f30a0600		LEAQ 0x60af3(IP), AX	
  0x40a126		48890424		MOVQ AX, 0(SP)		
  0x40a12a		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x40a133		e898700100		CALL runtime.throw(SB)	
  0x40a138		0f0b			UD2			
func mallocinit() {
  0x40a13a		e831a40300		CALL runtime.morestack_noctxt(SB)	
  0x40a13f		e9fcfaffff		JMP runtime.mallocinit(SB)		

TEXT runtime.(*mheap).sysAlloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func (h *mheap) sysAlloc(n uintptr) unsafe.Pointer {
  0x40a150		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a159		483b6110		CMPQ 0x10(CX), SP	
  0x40a15d		0f8643020000		JBE 0x40a3a6		
  0x40a163		4883ec48		SUBQ $0x48, SP		
  0x40a167		48896c2440		MOVQ BP, 0x40(SP)	
  0x40a16c		488d6c2440		LEAQ 0x40(SP), BP	
  0x40a171		488b442450		MOVQ 0x50(SP), AX	
	if n > h.arena_end-h.arena_alloc {
  0x40a176		8400			TESTB AL, 0(AX)		
  0x40a178		488b8840130000		MOVQ 0x1340(AX), CX	
  0x40a17f		488b9038130000		MOVQ 0x1338(AX), DX	
  0x40a186		4889cb			MOVQ CX, BX		
  0x40a189		4829d1			SUBQ DX, CX		
  0x40a18c		488b542458		MOVQ 0x58(SP), DX	
  0x40a191		4839ca			CMPQ CX, DX		
  0x40a194		763b			JBE 0x40a1d1		
	return (n + a - 1) &^ (a - 1)
  0x40a196		488d8aff1f0010		LEAQ 0x10001fff(DX), CX	
  0x40a19d		4881e1000000f0		ANDQ $-0x10000000, CX	
		new_end := h.arena_end + p_size // Careful: can overflow
  0x40a1a4		488d3419		LEAQ 0(CX)(BX*1), SI	
		if h.arena_end <= new_end && new_end-h.arena_start-1 <= _MaxMem {
  0x40a1a8		4839f3			CMPQ SI, BX		
  0x40a1ab		7724			JA 0x40a1d1		
  0x40a1ad		488b9828130000		MOVQ 0x1328(AX), BX	
  0x40a1b4		4889f7			MOVQ SI, DI		
  0x40a1b7		4829de			SUBQ BX, SI		
  0x40a1ba		488d5eff		LEAQ -0x1(SI), BX	
  0x40a1be		48beffffffff7f000000	MOVQ $0x7fffffffff, SI	
  0x40a1c8		4839f3			CMPQ SI, BX		
  0x40a1cb		0f86af000000		JBE 0x40a280		
	if n <= h.arena_end-h.arena_alloc {
  0x40a1d1		488b8840130000		MOVQ 0x1340(AX), CX	
  0x40a1d8		488b9838130000		MOVQ 0x1338(AX), BX	
  0x40a1df		4829d9			SUBQ BX, CX		
  0x40a1e2		4839ca			CMPQ CX, DX		
  0x40a1e5		7613			JBE 0x40a1fa		
		return nil
  0x40a1e7		48c744246000000000	MOVQ $0x0, 0x60(SP)	
  0x40a1f0		488b6c2440		MOVQ 0x40(SP), BP	
  0x40a1f5		4883c448		ADDQ $0x48, SP		
  0x40a1f9		c3			RET			
  0x40a1fa		48895c2438		MOVQ BX, 0x38(SP)	
		sysMap(unsafe.Pointer(p), n, h.arena_reserved, &memstats.heap_sys)
  0x40a1ff		0fb68848130000		MOVZX 0x1348(AX), CX			
  0x40a206		884c2410		MOVB CL, 0x10(SP)			
  0x40a20a		48891c24		MOVQ BX, 0(SP)				
  0x40a20e		4889542408		MOVQ DX, 0x8(SP)			
  0x40a213		488d1d1ea50b00		LEAQ runtime.memstats+56(SB), BX	
  0x40a21a		48895c2418		MOVQ BX, 0x18(SP)			
  0x40a21f		e81c530000		CALL runtime.sysMap(SB)			
  0x40a224		488b442450		MOVQ 0x50(SP), AX			
		h.arena_alloc += n
  0x40a229		488b8838130000		MOVQ 0x1338(AX), CX	
  0x40a230		488b542458		MOVQ 0x58(SP), DX	
  0x40a235		4801d1			ADDQ DX, CX		
  0x40a238		48898838130000		MOVQ CX, 0x1338(AX)	
		if h.arena_alloc > h.arena_used {
  0x40a23f		488b9030130000		MOVQ 0x1330(AX), DX	
  0x40a246		4839d1			CMPQ DX, CX		
  0x40a249		7720			JA 0x40a26b		
  0x40a24b		488b442438		MOVQ 0x38(SP), AX	
		if p&(_PageSize-1) != 0 {
  0x40a250		48a9ff1f0000		TESTQ $0x1fff, AX	
  0x40a256		0f852f010000		JNE 0x40a38b		
		return unsafe.Pointer(p)
  0x40a25c		4889442460		MOVQ AX, 0x60(SP)	
  0x40a261		488b6c2440		MOVQ 0x40(SP), BP	
  0x40a266		4883c448		ADDQ $0x48, SP		
  0x40a26a		c3			RET			
			h.setArenaUsed(h.arena_alloc, true)
  0x40a26b		48894c2408		MOVQ CX, 0x8(SP)			
  0x40a270		48890424		MOVQ AX, 0(SP)				
  0x40a274		c644241001		MOVB $0x1, 0x10(SP)			
  0x40a279		e8f2010100		CALL runtime.(*mheap).setArenaUsed(SB)	
  0x40a27e		ebcb			JMP 0x40a24b				
  0x40a280		48894c2430		MOVQ CX, 0x30(SP)			
  0x40a285		48897c2438		MOVQ DI, 0x38(SP)			
			var reserved bool
  0x40a28a		c644242700		MOVB $0x0, 0x27(SP)	
			p := uintptr(sysReserve(unsafe.Pointer(h.arena_end), p_size, &reserved))
  0x40a28f		488b9040130000		MOVQ 0x1340(AX), DX		
  0x40a296		48891424		MOVQ DX, 0(SP)			
  0x40a29a		48894c2408		MOVQ CX, 0x8(SP)		
  0x40a29f		488d542427		LEAQ 0x27(SP), DX		
  0x40a2a4		4889542410		MOVQ DX, 0x10(SP)		
  0x40a2a9		e842510000		CALL runtime.sysReserve(SB)	
  0x40a2ae		488b442418		MOVQ 0x18(SP), AX		
			if p == 0 {
  0x40a2b3		4885c0			TESTQ AX, AX		
  0x40a2b6		0f842bffffff		JE 0x40a1e7		
  0x40a2bc		488b4c2450		MOVQ 0x50(SP), CX	
			if p == h.arena_end {
  0x40a2c1		488b9140130000		MOVQ 0x1340(CX), DX	
  0x40a2c8		4839d0			CMPQ DX, AX		
  0x40a2cb		7524			JNE 0x40a2f1		
  0x40a2cd		488b442438		MOVQ 0x38(SP), AX	
				h.arena_end = new_end
  0x40a2d2		48898140130000		MOVQ AX, 0x1340(CX)	
				h.arena_reserved = reserved
  0x40a2d9		0fb6442427		MOVZX 0x27(SP), AX	
  0x40a2de		888148130000		MOVB AL, 0x1348(CX)	
  0x40a2e4		4889c8			MOVQ CX, AX		
  0x40a2e7		488b542458		MOVQ 0x58(SP), DX	
	if n <= h.arena_end-h.arena_alloc {
  0x40a2ec		e9e0feffff		JMP 0x40a1d1		
			} else if h.arena_start <= p && p+p_size-h.arena_start-1 <= _MaxMem && h.arena_end-h.arena_alloc < strandLimit {
  0x40a2f1		488b9928130000		MOVQ 0x1328(CX), BX	
  0x40a2f8		4839c3			CMPQ AX, BX		
  0x40a2fb		0f8783000000		JA 0x40a384		
  0x40a301		488b742430		MOVQ 0x30(SP), SI	
  0x40a306		488d3c30		LEAQ 0(AX)(SI*1), DI	
  0x40a30a		4989f8			MOVQ DI, R8		
  0x40a30d		4829df			SUBQ BX, DI		
  0x40a310		488d5fff		LEAQ -0x1(DI), BX	
  0x40a314		48bfffffffff7f000000	MOVQ $0x7fffffffff, DI	
  0x40a31e		4839fb			CMPQ DI, BX		
  0x40a321		773a			JA 0x40a35d		
  0x40a323		488b9938130000		MOVQ 0x1338(CX), BX	
  0x40a32a		4829da			SUBQ BX, DX		
  0x40a32d		4881fa00000001		CMPQ $0x1000000, DX	
  0x40a334		7327			JAE 0x40a35d		
				h.arena_end = p + p_size
  0x40a336		4c898140130000		MOVQ R8, 0x1340(CX)	
	return (n + a - 1) &^ (a - 1)
  0x40a33d		4805ff1f0000		ADDQ $0x1fff, AX	
  0x40a343		482500e0ffff		ANDQ $-0x2000, AX	
				h.arena_alloc = p
  0x40a349		48898138130000		MOVQ AX, 0x1338(CX)	
				h.arena_reserved = reserved
  0x40a350		0fb6442427		MOVZX 0x27(SP), AX	
  0x40a355		888148130000		MOVB AL, 0x1348(CX)	
  0x40a35b		eb87			JMP 0x40a2e4		
				stat := uint64(p_size)
  0x40a35d		4889742428		MOVQ SI, 0x28(SP)	
				sysFree(unsafe.Pointer(p), p_size, &stat)
  0x40a362		48890424		MOVQ AX, 0(SP)			
  0x40a366		4889742408		MOVQ SI, 0x8(SP)		
  0x40a36b		488d442428		LEAQ 0x28(SP), AX		
  0x40a370		4889442410		MOVQ AX, 0x10(SP)		
  0x40a375		e8c64f0000		CALL runtime.sysFree(SB)	
  0x40a37a		488b4c2450		MOVQ 0x50(SP), CX		
  0x40a37f		e960ffffff		JMP 0x40a2e4			
  0x40a384		488b742430		MOVQ 0x30(SP), SI		
			} else if h.arena_start <= p && p+p_size-h.arena_start-1 <= _MaxMem && h.arena_end-h.arena_alloc < strandLimit {
  0x40a389		ebd2			JMP 0x40a35d		
			throw("misrounded allocation in MHeap_SysAlloc")
  0x40a38b		488d05e92d0600		LEAQ 0x62de9(IP), AX	
  0x40a392		48890424		MOVQ AX, 0(SP)		
  0x40a396		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x40a39f		e82c6e0100		CALL runtime.throw(SB)	
  0x40a3a4		0f0b			UD2			
func (h *mheap) sysAlloc(n uintptr) unsafe.Pointer {
  0x40a3a6		e8c5a10300		CALL runtime.morestack_noctxt(SB)	
  0x40a3ab		e9a0fdffff		JMP runtime.(*mheap).sysAlloc(SB)	

TEXT runtime.(*mcache).nextFree(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {
  0x40a3b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a3b9		483b6110		CMPQ 0x10(CX), SP	
  0x40a3bd		0f863c020000		JBE 0x40a5ff		
  0x40a3c3		4883ec50		SUBQ $0x50, SP		
  0x40a3c7		48896c2448		MOVQ BP, 0x48(SP)	
  0x40a3cc		488d6c2448		LEAQ 0x48(SP), BP	
  0x40a3d1		488b442458		MOVQ 0x58(SP), AX	
	s = c.alloc[spc]
  0x40a3d6		8400			TESTB AL, 0(AX)		
func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {
  0x40a3d8		0fb64c2460		MOVZX 0x60(SP), CX	
	s = c.alloc[spc]
  0x40a3dd		0fb6d1			MOVZX CL, DX		
  0x40a3e0		4881fa86000000		CMPQ $0x86, DX		
  0x40a3e7		0f830b020000		JAE 0x40a5f8		
  0x40a3ed		4889542420		MOVQ DX, 0x20(SP)	
  0x40a3f2		488b4cd028		MOVQ 0x28(AX)(DX*8), CX	
  0x40a3f7		48894c2428		MOVQ CX, 0x28(SP)	
	freeIndex := s.nextFreeIndex()
  0x40a3fc		48890c24		MOVQ CX, 0(SP)				
  0x40a400		e8cb1a0000		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x40a405		488b442408		MOVQ 0x8(SP), AX			
  0x40a40a		488b4c2428		MOVQ 0x28(SP), CX			
	if freeIndex == s.nelems {
  0x40a40f		488b5138		MOVQ 0x38(CX), DX	
  0x40a413		4839d0			CMPQ DX, AX		
  0x40a416		0f85b3000000		JNE 0x40a4cf		
		if uintptr(s.allocCount) != s.nelems {
  0x40a41c		0fb74160		MOVZX 0x60(CX), AX	
  0x40a420		0fb7c8			MOVZX AX, CX		
  0x40a423		4839d1			CMPQ DX, CX		
  0x40a426		0f8547010000		JNE 0x40a573		
		systemstack(func() {
  0x40a42c		488d05ad770300		LEAQ runtime.(*mcache).nextFree.func1(SB), AX	
  0x40a433		4889442430		MOVQ AX, 0x30(SP)				
  0x40a438		488b442458		MOVQ 0x58(SP), AX				
  0x40a43d		4889442438		MOVQ AX, 0x38(SP)				
  0x40a442		0fb64c2460		MOVZX 0x60(SP), CX				
  0x40a447		884c2440		MOVB CL, 0x40(SP)				
  0x40a44b		488d4c2430		LEAQ 0x30(SP), CX				
  0x40a450		48890c24		MOVQ CX, 0(SP)					
  0x40a454		e8c79f0300		CALL runtime.systemstack(SB)			
	if freeIndex == s.nelems {
  0x40a459		488b442420		MOVQ 0x20(SP), AX	
  0x40a45e		488b4c2458		MOVQ 0x58(SP), CX	
		s = c.alloc[spc]
  0x40a463		488b44c128		MOVQ 0x28(CX)(AX*8), AX	
  0x40a468		4889442428		MOVQ AX, 0x28(SP)	
		freeIndex = s.nextFreeIndex()
  0x40a46d		48890424		MOVQ AX, 0(SP)				
  0x40a471		e85a1a0000		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x40a476		488b442408		MOVQ 0x8(SP), AX			
  0x40a47b		488b4c2428		MOVQ 0x28(SP), CX			
  0x40a480		ba01000000		MOVL $0x1, DX				
	if freeIndex >= s.nelems {
  0x40a485		488b5938		MOVQ 0x38(CX), BX	
  0x40a489		4839d8			CMPQ BX, AX		
  0x40a48c		0f83c6000000		JAE 0x40a558		
	v = gclinkptr(freeIndex*s.elemsize + s.base())
  0x40a492		488b5968		MOVQ 0x68(CX), BX	
  0x40a496		480fafc3		IMULQ BX, AX		
	return s.startAddr
  0x40a49a		488d5918		LEAQ 0x18(CX), BX	
	v = gclinkptr(freeIndex*s.elemsize + s.base())
  0x40a49e		480303			ADDQ 0(BX), AX		
	s.allocCount++
  0x40a4a1		0fb75960		MOVZX 0x60(CX), BX	
  0x40a4a5		ffc3			INCL BX			
  0x40a4a7		66895960		MOVW BX, 0x60(CX)	
	if uintptr(s.allocCount) > s.nelems {
  0x40a4ab		0fb7f3			MOVZX BX, SI		
  0x40a4ae		488b7938		MOVQ 0x38(CX), DI	
  0x40a4b2		4839fe			CMPQ DI, SI		
  0x40a4b5		771c			JA 0x40a4d3		
	return
  0x40a4b7		4889442468		MOVQ AX, 0x68(SP)	
  0x40a4bc		48894c2470		MOVQ CX, 0x70(SP)	
  0x40a4c1		88542478		MOVB DL, 0x78(SP)	
  0x40a4c5		488b6c2448		MOVQ 0x48(SP), BP	
  0x40a4ca		4883c450		ADDQ $0x50, SP		
  0x40a4ce		c3			RET			
  0x40a4cf		31d2			XORL DX, DX		
	if freeIndex == s.nelems {
  0x40a4d1		ebb2			JMP 0x40a485		
  0x40a4d3		66895c2416		MOVW BX, 0x16(SP)	
  0x40a4d8		48897c2418		MOVQ DI, 0x18(SP)	
		println("s.allocCount=", s.allocCount, "s.nelems=", s.nelems)
  0x40a4dd		e81e760100		CALL runtime.printlock(SB)	
  0x40a4e2		488d05e3030600		LEAQ 0x603e3(IP), AX		
  0x40a4e9		48890424		MOVQ AX, 0(SP)			
  0x40a4ed		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x40a4f6		e8457f0100		CALL runtime.printstring(SB)	
  0x40a4fb		0fb7442416		MOVZX 0x16(SP), AX		
  0x40a500		0fb7c0			MOVZX AX, AX			
  0x40a503		48890424		MOVQ AX, 0(SP)			
  0x40a507		e8647c0100		CALL runtime.printuint(SB)	
  0x40a50c		488d0509ff0500		LEAQ 0x5ff09(IP), AX		
  0x40a513		48890424		MOVQ AX, 0(SP)			
  0x40a517		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x40a520		e81b7f0100		CALL runtime.printstring(SB)	
  0x40a525		488b442418		MOVQ 0x18(SP), AX		
  0x40a52a		48890424		MOVQ AX, 0(SP)			
  0x40a52e		e83d7c0100		CALL runtime.printuint(SB)	
  0x40a533		e858780100		CALL runtime.printnl(SB)	
  0x40a538		e843760100		CALL runtime.printunlock(SB)	
		throw("s.allocCount > s.nelems")
  0x40a53d		488d0561120600		LEAQ 0x61261(IP), AX	
  0x40a544		48890424		MOVQ AX, 0(SP)		
  0x40a548		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x40a551		e87a6c0100		CALL runtime.throw(SB)	
  0x40a556		0f0b			UD2			
		throw("freeIndex is not valid")
  0x40a558		488d05a90e0600		LEAQ 0x60ea9(IP), AX	
  0x40a55f		48890424		MOVQ AX, 0(SP)		
  0x40a563		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x40a56c		e85f6c0100		CALL runtime.throw(SB)	
  0x40a571		0f0b			UD2			
  0x40a573		4889542418		MOVQ DX, 0x18(SP)	
  0x40a578		6689442416		MOVW AX, 0x16(SP)	
			println("runtime: s.allocCount=", s.allocCount, "s.nelems=", s.nelems)
  0x40a57d		e87e750100		CALL runtime.printlock(SB)	
  0x40a582		488d0505120600		LEAQ 0x61205(IP), AX		
  0x40a589		48890424		MOVQ AX, 0(SP)			
  0x40a58d		48c744240817000000	MOVQ $0x17, 0x8(SP)		
  0x40a596		e8a57e0100		CALL runtime.printstring(SB)	
  0x40a59b		0fb7442416		MOVZX 0x16(SP), AX		
  0x40a5a0		0fb7c0			MOVZX AX, AX			
  0x40a5a3		48890424		MOVQ AX, 0(SP)			
  0x40a5a7		e8c47b0100		CALL runtime.printuint(SB)	
  0x40a5ac		488d0569fe0500		LEAQ 0x5fe69(IP), AX		
  0x40a5b3		48890424		MOVQ AX, 0(SP)			
  0x40a5b7		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x40a5c0		e87b7e0100		CALL runtime.printstring(SB)	
  0x40a5c5		488b442418		MOVQ 0x18(SP), AX		
  0x40a5ca		48890424		MOVQ AX, 0(SP)			
  0x40a5ce		e89d7b0100		CALL runtime.printuint(SB)	
  0x40a5d3		e8b8770100		CALL runtime.printnl(SB)	
  0x40a5d8		e8a3750100		CALL runtime.printunlock(SB)	
			throw("s.allocCount != s.nelems && freeIndex == s.nelems")
  0x40a5dd		488d05ac330600		LEAQ 0x633ac(IP), AX	
  0x40a5e4		48890424		MOVQ AX, 0(SP)		
  0x40a5e8		48c744240831000000	MOVQ $0x31, 0x8(SP)	
  0x40a5f1		e8da6b0100		CALL runtime.throw(SB)	
  0x40a5f6		0f0b			UD2			
	s = c.alloc[spc]
  0x40a5f8		e843540100		CALL runtime.panicindex(SB)	
  0x40a5fd		0f0b			UD2				
func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {
  0x40a5ff		e86c9f0300		CALL runtime.morestack_noctxt(SB)	
  0x40a604		e9a7fdffff		JMP runtime.(*mcache).nextFree(SB)	

TEXT runtime.mallocgc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  0x40a610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a619		488d4424e8		LEAQ -0x18(SP), AX	
  0x40a61e		483b4110		CMPQ 0x10(CX), AX	
  0x40a622		0f86a2090000		JBE 0x40afca		
  0x40a628		4881ec98000000		SUBQ $0x98, SP		
  0x40a62f		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x40a637		488dac2490000000	LEAQ 0x90(SP), BP	
  0x40a63f		48c7c000000000		MOVQ $0x0, AX		
  0x40a646		4889442448		MOVQ AX, 0x48(SP)	
	if gcphase == _GCmarktermination {
  0x40a64b		8b058b920b00		MOVL runtime.gcphase(SB), AX	
  0x40a651		83f802			CMPL $0x2, AX			
  0x40a654		0f8455090000		JE 0x40afaf			
	if size == 0 {
  0x40a65a		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x40a662		4885c0			TESTQ AX, AX		
  0x40a665		0f84d3080000		JE 0x40af3e		
	if debug.sbrk != 0 {
  0x40a66b		8b1577940b00		MOVL runtime.debug+40(SB), DX	
  0x40a671		85d2			TESTL DX, DX			
  0x40a673		744f			JE 0x40a6c4			
  0x40a675		488b8c24a8000000	MOVQ 0xa8(SP), CX		
		if typ != nil {
  0x40a67d		4885c9			TESTQ CX, CX		
  0x40a680		743b			JE 0x40a6bd		
			align = uintptr(typ.align)
  0x40a682		0fb64915		MOVZX 0x15(CX), CX	
		return persistentalloc(size, align, &memstats.other_sys)
  0x40a686		48890424		MOVQ AX, 0(SP)				
  0x40a68a		48894c2408		MOVQ CX, 0x8(SP)			
  0x40a68f		488d050aa10b00		LEAQ runtime.memstats+160(SB), AX	
  0x40a696		4889442410		MOVQ AX, 0x10(SP)			
  0x40a69b		e8000e0000		CALL runtime.persistentalloc(SB)	
  0x40a6a0		488b442418		MOVQ 0x18(SP), AX			
  0x40a6a5		48898424b8000000	MOVQ AX, 0xb8(SP)			
  0x40a6ad		488bac2490000000	MOVQ 0x90(SP), BP			
  0x40a6b5		4881c498000000		ADDQ $0x98, SP				
  0x40a6bc		c3			RET					
  0x40a6bd		b910000000		MOVL $0x10, CX				
		if typ != nil {
  0x40a6c2		ebc2			JMP 0x40a686		
	if gcBlackenEnabled != 0 {
  0x40a6c4		8b150a920b00		MOVL runtime.gcBlackenEnabled(SB), DX	
  0x40a6ca		85d2			TESTL DX, DX				
  0x40a6cc		0f8465080000		JE 0x40af37				
		assistG = getg()
  0x40a6d2		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
		if assistG.m.curg != nil {
  0x40a6db		488b5a30		MOVQ 0x30(DX), BX	
  0x40a6df		488b9bc0000000		MOVQ 0xc0(BX), BX	
  0x40a6e6		4885db			TESTQ BX, BX		
  0x40a6e9		0f8440080000		JE 0x40af2f		
		assistG.gcAssistBytes -= int64(size)
  0x40a6ef		488b9370010000		MOVQ 0x170(BX), DX	
  0x40a6f6		4829c2			SUBQ AX, DX		
  0x40a6f9		48899370010000		MOVQ DX, 0x170(BX)	
		if assistG.gcAssistBytes < 0 {
  0x40a700		4885d2			TESTQ DX, DX		
  0x40a703		0f8c0e080000		JL 0x40af17		
	_g_ := getg()
  0x40a709		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x40a712		488b5030		MOVQ 0x30(AX), DX	
  0x40a716		ff8200010000		INCL 0x100(DX)		
	return _g_.m
  0x40a71c		488b5030		MOVQ 0x30(AX), DX	
  0x40a720		8400			TESTB AL, 0(AX)		
	if mp.mallocing != 0 {
  0x40a722		8b82e8000000		MOVL 0xe8(DX), AX	
  0x40a728		85c0			TESTL AX, AX		
  0x40a72a		0f8564080000		JNE 0x40af94		
	if mp.gsignal == getg() {
  0x40a730		488b4250		MOVQ 0x50(DX), AX	
  0x40a734		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
  0x40a73d		4839f0			CMPQ SI, AX		
  0x40a740		0f8433080000		JE 0x40af79		
	mp.mallocing = 1
  0x40a746		c782e800000001000000	MOVL $0x1, 0xe8(DX)	
	return getg().m.mcache
  0x40a750		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40a759		488b4030		MOVQ 0x30(AX), AX	
	dataSize := size
  0x40a75d		488bb424a0000000	MOVQ 0xa0(SP), SI	
	return getg().m.mcache
  0x40a765		488b8060010000		MOVQ 0x160(AX), AX	
  0x40a76c		488bbc24a8000000	MOVQ 0xa8(SP), DI	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a774		4885ff			TESTQ DI, DI		
  0x40a777		0f848f070000		JE 0x40af0c		
  0x40a77d		440fb64717		MOVZX 0x17(DI), R8	
  0x40a782		41f6c080		TESTL $0x80, R8		
  0x40a786		410f95c0		SETNE R8		
  0x40a78a		4889542450		MOVQ DX, 0x50(SP)	
  0x40a78f		4889742438		MOVQ SI, 0x38(SP)	
  0x40a794		4889442460		MOVQ AX, 0x60(SP)	
  0x40a799		448844242f		MOVB R8, 0x2f(SP)	
  0x40a79e		48895c2468		MOVQ BX, 0x68(SP)	
	if size <= maxSmallSize {
  0x40a7a3		4881fe00800000		CMPQ $0x8000, SI	
  0x40a7aa		0f879e060000		JA 0x40ae4e		
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a7b0		4584c0			TESTL R8, R8		
		if noscan && size < maxTinySize {
  0x40a7b3		0f84b0040000		JE 0x40ac69		
  0x40a7b9		4883fe10		CMPQ $0x10, SI		
  0x40a7bd		0f83a6040000		JAE 0x40ac69		
			off := c.tinyoffset
  0x40a7c3		4c8b4818		MOVQ 0x18(AX), R9	
			if size&7 == 0 {
  0x40a7c7		48f7c607000000		TESTQ $0x7, SI		
  0x40a7ce		0f8569040000		JNE 0x40ac3d		
	return (n + a - 1) &^ (a - 1)
  0x40a7d4		4983c107		ADDQ $0x7, R9		
  0x40a7d8		4983e1f8		ANDQ $-0x8, R9		
			if off+size <= maxTinySize && c.tiny != 0 {
  0x40a7dc		4d8d1431		LEAQ 0(R9)(SI*1), R10	
  0x40a7e0		4983fa10		CMPQ $0x10, R10		
  0x40a7e4		7767			JA 0x40a84d		
  0x40a7e6		4c8b5810		MOVQ 0x10(AX), R11	
  0x40a7ea		4d85db			TESTQ R11, R11		
  0x40a7ed		745e			JE 0x40a84d		
				x = unsafe.Pointer(c.tiny + off)
  0x40a7ef		4b8d0c19		LEAQ 0(R9)(R11*1), CX	
				c.tinyoffset = off + size
  0x40a7f3		4c895018		MOVQ R10, 0x18(AX)	
				c.local_tinyallocs++
  0x40a7f7		48ff4020		INCQ 0x20(AX)		
				mp.mallocing = 0
  0x40a7fb		c782e800000000000000	MOVL $0x0, 0xe8(DX)	
	_g_ := getg()
  0x40a805		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x40a80e		8b9a00010000		MOVL 0x100(DX), BX	
  0x40a814		8d73ff			LEAL -0x1(BX), SI	
  0x40a817		89b200010000		MOVL SI, 0x100(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x40a81d		83fb01			CMPL $0x1, BX		
  0x40a820		7513			JNE 0x40a835		
  0x40a822		0fb690c0000000		MOVZX 0xc0(AX), DX	
  0x40a829		84d2			TESTL DL, DL		
  0x40a82b		7408			JE 0x40a835		
		_g_.stackguard0 = stackPreempt
  0x40a82d		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
				return x
  0x40a835		48898c24b8000000	MOVQ CX, 0xb8(SP)	
  0x40a83d		488bac2490000000	MOVQ 0x90(SP), BP	
  0x40a845		4881c498000000		ADDQ $0x98, SP		
  0x40a84c		c3			RET			
			span := c.alloc[tinySpanClass]
  0x40a84d		4c8b4850		MOVQ 0x50(AX), R9	
	theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?
  0x40a851		4d8b5140		MOVQ 0x40(R9), R10	
  0x40a855		4d0fbcda		BSFQ R10, R11		
  0x40a859		41bc40000000		MOVL $0x40, R12		
  0x40a85f		4d0f44dc		CMOVE R12, R11		
	if theBit < 64 {
  0x40a863		4983fb40		CMPQ $0x40, R11		
  0x40a867		0f8dc9030000		JGE 0x40ac36		
		result := s.freeindex + uintptr(theBit)
  0x40a86d		4d8b6130		MOVQ 0x30(R9), R12	
  0x40a871		4f8d2c1c		LEAQ 0(R12)(R11*1), R13	
		if result < s.nelems {
  0x40a875		4d8b7138		MOVQ 0x38(R9), R14	
  0x40a879		4d39f5			CMPQ R14, R13		
  0x40a87c		0f83b4030000		JAE 0x40ac36		
			freeidx := result + 1
  0x40a882		4f8d641c01		LEAQ 0x1(R12)(R11*1), R12	
			if freeidx%64 == 0 && freeidx != s.nelems {
  0x40a887		49f7c43f000000		TESTQ $0x3f, R12	
  0x40a88e		0f856b030000		JNE 0x40abff		
  0x40a894		4d39f4			CMPQ R14, R12		
  0x40a897		0f8462030000		JE 0x40abff		
  0x40a89d		31c9			XORL CX, CX		
			if v == 0 {
  0x40a89f		4885c9			TESTQ CX, CX		
  0x40a8a2		0f8417030000		JE 0x40abbf		
  0x40a8a8		4531c9			XORL R9, R9		
			(*[2]uint64)(x)[1] = 0
  0x40a8ab		0f57c0			XORPS X0, X0		
  0x40a8ae		0f1101			MOVUPS X0, 0(CX)	
			if size < c.tinyoffset || c.tiny == 0 {
  0x40a8b1		4c8b9424a0000000	MOVQ 0xa0(SP), R10	
  0x40a8b9		4c8b5818		MOVQ 0x18(AX), R11	
  0x40a8bd		4d39da			CMPQ R11, R10		
  0x40a8c0		0f83e4020000		JAE 0x40abaa		
  0x40a8c6		4989ca			MOVQ CX, R10		
				c.tiny = uintptr(x)
  0x40a8c9		48894810		MOVQ CX, 0x10(AX)	
				c.tinyoffset = size
  0x40a8cd		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x40a8d5		48894818		MOVQ CX, 0x18(AX)	
			size = maxTinySize
  0x40a8d9		48c78424a000000010000000	MOVQ $0x10, 0xa0(SP)	
  0x40a8e5		4c89542440			MOVQ R10, 0x40(SP)	
  0x40a8ea		44884c242e			MOVB R9, 0x2e(SP)	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a8ef		4584c0			TESTL R8, R8		
	if !noscan {
  0x40a8f2		0f842a020000		JE 0x40ab22		
  0x40a8f8		31c9			XORL CX, CX		
  0x40a8fa		4889742438		MOVQ SI, 0x38(SP)	
  0x40a8ff		48894c2430		MOVQ CX, 0x30(SP)	
	publicationBarrier()
  0x40a904		e877b20300		CALL runtime.publicationBarrier(SB)	
	if gcphase != _GCoff {
  0x40a909		8b05cd8f0b00		MOVL runtime.gcphase(SB), AX	
  0x40a90f		85c0			TESTL AX, AX			
  0x40a911		0f85e1010000		JNE 0x40aaf8			
  0x40a917		488b442450		MOVQ 0x50(SP), AX		
	mp.mallocing = 0
  0x40a91c		c780e800000000000000	MOVL $0x0, 0xe8(AX)	
	_g_ := getg()
  0x40a926		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	mp.locks--
  0x40a92f		8b9000010000		MOVL 0x100(AX), DX	
  0x40a935		8d5aff			LEAL -0x1(DX), BX	
  0x40a938		899800010000		MOVL BX, 0x100(AX)	
	if mp.locks == 0 && _g_.preempt {
  0x40a93e		83fa01			CMPL $0x1, DX		
  0x40a941		7513			JNE 0x40a956		
  0x40a943		0fb681c0000000		MOVZX 0xc0(CX), AX	
  0x40a94a		84c0			TESTL AL, AL		
  0x40a94c		7408			JE 0x40a956		
		_g_.stackguard0 = stackPreempt
  0x40a94e		48c74110defaffff	MOVQ $-0x522, 0x10(CX)	
	if debug.allocfreetrace != 0 {
  0x40a956		8b0564910b00		MOVL runtime.debug(SB), AX	
  0x40a95c		85c0			TESTL AX, AX			
  0x40a95e		0f8567010000		JNE 0x40aacb			
	if rate := MemProfileRate; rate > 0 {
  0x40a964		488b05ada60900		MOVQ runtime.MemProfileRate(SB), AX	
  0x40a96b		4885c0			TESTQ AX, AX				
  0x40a96e		7e24			JLE 0x40a994				
		if size < uintptr(rate) && int32(size) < c.next_sample {
  0x40a970		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x40a978		4839c1			CMPQ AX, CX		
  0x40a97b		0f83cc000000		JAE 0x40aa4d		
  0x40a981		488b442460		MOVQ 0x60(SP), AX	
  0x40a986		8b10			MOVL 0(AX), DX		
  0x40a988		39d1			CMPL DX, CX		
  0x40a98a		0f8dbd000000		JGE 0x40aa4d		
			c.next_sample -= int32(size)
  0x40a990		29ca			SUBL CX, DX		
  0x40a992		8910			MOVL DX, 0(AX)		
  0x40a994		488b442468		MOVQ 0x68(SP), AX	
	if assistG != nil {
  0x40a999		4885c0			TESTQ AX, AX		
  0x40a99c		7421			JE 0x40a9bf		
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x40a99e		488b8870010000		MOVQ 0x170(AX), CX	
  0x40a9a5		488b9424a0000000	MOVQ 0xa0(SP), DX	
  0x40a9ad		488b5c2438		MOVQ 0x38(SP), BX	
  0x40a9b2		4829da			SUBQ BX, DX		
  0x40a9b5		4829d1			SUBQ DX, CX		
  0x40a9b8		48898870010000		MOVQ CX, 0x170(AX)	
  0x40a9bf		0fb644242e		MOVZX 0x2e(SP), AX	
	if shouldhelpgc {
  0x40a9c4		84c0			TESTL AL, AL		
  0x40a9c6		741b			JE 0x40a9e3		
	if !memstats.enablegc || panicking != 0 {
  0x40a9c8		0fb60501ae0b00		MOVZX runtime.memstats+4304(SB), AX	
  0x40a9cf		84c0			TESTL AL, AL				
  0x40a9d1		740a			JE 0x40a9dd				
  0x40a9d3		8b051b8f0b00		MOVL runtime.panicking(SB), AX		
  0x40a9d9		85c0			TESTL AX, AX				
  0x40a9db		744c			JE 0x40aa29				
  0x40a9dd		31c0			XORL AX, AX				
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
  0x40a9df		84c0			TESTL AL, AL		
  0x40a9e1		751d			JNE 0x40aa00		
	return x
  0x40a9e3		488b442440		MOVQ 0x40(SP), AX	
  0x40a9e8		48898424b8000000	MOVQ AX, 0xb8(SP)	
  0x40a9f0		488bac2490000000	MOVQ 0x90(SP), BP	
  0x40a9f8		4881c498000000		ADDQ $0x98, SP		
  0x40a9ff		c3			RET			
			gcStart(gcBackgroundMode, t)
  0x40aa00		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x40aa08		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x40aa11		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x40aa1a		c744241800000000	MOVL $0x0, 0x18(SP)		
  0x40aa22		e859670000		CALL runtime.gcStart(SB)	
  0x40aa27		ebba			JMP 0x40a9e3			
	if gcphase != _GCoff {
  0x40aa29		8b05ad8e0b00		MOVL runtime.gcphase(SB), AX	
  0x40aa2f		85c0			TESTL AX, AX			
  0x40aa31		7404			JE 0x40aa37			
  0x40aa33		31c0			XORL AX, AX			
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
  0x40aa35		eba8			JMP 0x40a9df		
		return memstats.heap_live >= memstats.gc_trigger
  0x40aa37		488b0d02b40b00		MOVQ runtime.memstats+5952(SB), CX	
  0x40aa3e		488b15f3b30b00		MOVQ runtime.memstats+5944(SB), DX	
  0x40aa45		4839d1			CMPQ DX, CX				
  0x40aa48		0f93c0			SETAE AL				
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
  0x40aa4b		eb92			JMP 0x40a9df		
	_g_ := getg()
  0x40aa4d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x40aa56		488b4830		MOVQ 0x30(AX), CX	
  0x40aa5a		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x40aa60		488b4030		MOVQ 0x30(AX), AX	
  0x40aa64		4889442458		MOVQ AX, 0x58(SP)	
			profilealloc(mp, x, size)
  0x40aa69		48890424		MOVQ AX, 0(SP)			
  0x40aa6d		488b4c2440		MOVQ 0x40(SP), CX		
  0x40aa72		48894c2408		MOVQ CX, 0x8(SP)		
  0x40aa77		488b9424a0000000	MOVQ 0xa0(SP), DX		
  0x40aa7f		4889542410		MOVQ DX, 0x10(SP)		
  0x40aa84		e8e7070000		CALL runtime.profilealloc(SB)	
	_g_ := getg()
  0x40aa89		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40aa92		488b4c2458		MOVQ 0x58(SP), CX	
	mp.locks--
  0x40aa97		8b9100010000		MOVL 0x100(CX), DX	
  0x40aa9d		8d5aff			LEAL -0x1(DX), BX	
  0x40aaa0		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x40aaa6		83fa01			CMPL $0x1, DX		
  0x40aaa9		0f85e5feffff		JNE 0x40a994		
  0x40aaaf		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x40aab6		84c9			TESTL CL, CL		
  0x40aab8		0f84d6feffff		JE 0x40a994		
		_g_.stackguard0 = stackPreempt
  0x40aabe		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x40aac6		e9c9feffff		JMP 0x40a994		
  0x40aacb		488b442440		MOVQ 0x40(SP), AX	
		tracealloc(x, size, typ)
  0x40aad0		48890424		MOVQ AX, 0(SP)			
  0x40aad4		488b8c24a0000000	MOVQ 0xa0(SP), CX		
  0x40aadc		48894c2408		MOVQ CX, 0x8(SP)		
  0x40aae1		488b8c24a8000000	MOVQ 0xa8(SP), CX		
  0x40aae9		48894c2410		MOVQ CX, 0x10(SP)		
  0x40aaee		e89d300100		CALL runtime.tracealloc(SB)	
  0x40aaf3		e96cfeffff		JMP 0x40a964			
  0x40aaf8		488b442440		MOVQ 0x40(SP), AX		
		gcmarknewobject(uintptr(x), size, scanSize)
  0x40aafd		48890424		MOVQ AX, 0(SP)				
  0x40ab01		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x40ab09		4889442408		MOVQ AX, 0x8(SP)			
  0x40ab0e		488b442430		MOVQ 0x30(SP), AX			
  0x40ab13		4889442410		MOVQ AX, 0x10(SP)			
  0x40ab18		e823ca0000		CALL runtime.gcmarknewobject(SB)	
  0x40ab1d		e9f5fdffff		JMP 0x40a917				
		if typ == deferType {
  0x40ab22		488b0d1fcb0900		MOVQ runtime.deferType(SB), CX	
  0x40ab29		4839f9			CMPQ DI, CX			
  0x40ab2c		7577			JNE 0x40aba5			
  0x40ab2e		b930000000		MOVL $0x30, CX			
		heapBitsSetType(uintptr(x), size, dataSize, typ)
  0x40ab33		48894c2438		MOVQ CX, 0x38(SP)			
  0x40ab38		4c891424		MOVQ R10, 0(SP)				
  0x40ab3c		488b9424a0000000	MOVQ 0xa0(SP), DX			
  0x40ab44		4889542408		MOVQ DX, 0x8(SP)			
  0x40ab49		48894c2410		MOVQ CX, 0x10(SP)			
  0x40ab4e		48897c2418		MOVQ DI, 0x18(SP)			
  0x40ab53		e878260000		CALL runtime.heapBitsSetType(SB)	
  0x40ab58		488b8424a8000000	MOVQ 0xa8(SP), AX			
		if dataSize > typ.size {
  0x40ab60		488b08			MOVQ 0(AX), CX		
  0x40ab63		488b542438		MOVQ 0x38(SP), DX	
  0x40ab68		4839ca			CMPQ CX, DX		
  0x40ab6b		762f			JBE 0x40ab9c		
			if typ.ptrdata != 0 {
  0x40ab6d		488b5808		MOVQ 0x8(AX), BX	
  0x40ab71		4885db			TESTQ BX, BX		
  0x40ab74		741f			JE 0x40ab95		
  0x40ab76		4889d6			MOVQ DX, SI		
				scanSize = dataSize - typ.size + typ.ptrdata
  0x40ab79		4829ca			SUBQ CX, DX		
  0x40ab7c		488d0c1a		LEAQ 0(DX)(BX*1), CX	
  0x40ab80		488b542460		MOVQ 0x60(SP), DX	
		c.local_scan += scanSize
  0x40ab85		488b5a08		MOVQ 0x8(DX), BX	
  0x40ab89		4801cb			ADDQ CX, BX		
  0x40ab8c		48895a08		MOVQ BX, 0x8(DX)	
  0x40ab90		e965fdffff		JMP 0x40a8fa		
  0x40ab95		4889d6			MOVQ DX, SI		
  0x40ab98		31c9			XORL CX, CX		
			if typ.ptrdata != 0 {
  0x40ab9a		ebe4			JMP 0x40ab80		
			scanSize = typ.ptrdata
  0x40ab9c		488b4808		MOVQ 0x8(AX), CX	
  0x40aba0		4889d6			MOVQ DX, SI		
  0x40aba3		ebdb			JMP 0x40ab80		
  0x40aba5		4889f1			MOVQ SI, CX		
		if typ == deferType {
  0x40aba8		eb89			JMP 0x40ab33		
			if size < c.tinyoffset || c.tiny == 0 {
  0x40abaa		4c8b5010		MOVQ 0x10(AX), R10	
  0x40abae		4d85d2			TESTQ R10, R10		
  0x40abb1		0f840ffdffff		JE 0x40a8c6		
  0x40abb7		4989ca			MOVQ CX, R10		
  0x40abba		e91afdffff		JMP 0x40a8d9		
				v, _, shouldhelpgc = c.nextFree(tinySpanClass)
  0x40abbf		48890424		MOVQ AX, 0(SP)				
  0x40abc3		c644240805		MOVB $0x5, 0x8(SP)			
  0x40abc8		e8e3f7ffff		CALL runtime.(*mcache).nextFree(SB)	
  0x40abcd		488b4c2410		MOVQ 0x10(SP), CX			
  0x40abd2		440fb64c2420		MOVZX 0x20(SP), R9			
  0x40abd8		488b442460		MOVQ 0x60(SP), AX			
  0x40abdd		488b542450		MOVQ 0x50(SP), DX			
  0x40abe2		488b5c2468		MOVQ 0x68(SP), BX			
  0x40abe7		488b742438		MOVQ 0x38(SP), SI			
  0x40abec		488bbc24a8000000	MOVQ 0xa8(SP), DI			
  0x40abf4		440fb644242f		MOVZX 0x2f(SP), R8			
  0x40abfa		e9acfcffff		JMP 0x40a8ab				
			s.allocCache >>= uint(theBit + 1)
  0x40abff		498d4b01		LEAQ 0x1(R11), CX	
  0x40ac03		49d3ea			SHRQ CL, R10		
  0x40ac06		4883f940		CMPQ $0x40, CX		
  0x40ac0a		4d19db			SBBQ R11, R11		
  0x40ac0d		4d21da			ANDQ R11, R10		
  0x40ac10		4d895140		MOVQ R10, 0x40(R9)	
			s.freeindex = freeidx
  0x40ac14		4d896130		MOVQ R12, 0x30(R9)	
			s.allocCount++
  0x40ac18		450fb75160		MOVZX 0x60(R9), R10	
  0x40ac1d		41ffc2			INCL R10		
  0x40ac20		6645895160		MOVW R10, 0x60(R9)	
			return gclinkptr(result*s.elemsize + s.base())
  0x40ac25		498b4968		MOVQ 0x68(R9), CX	
  0x40ac29		490fafcd		IMULQ R13, CX		
  0x40ac2d		49034918		ADDQ 0x18(R9), CX	
			v := nextFreeFast(span)
  0x40ac31		e969fcffff		JMP 0x40a89f		
  0x40ac36		31c9			XORL CX, CX		
  0x40ac38		e962fcffff		JMP 0x40a89f		
			} else if size&3 == 0 {
  0x40ac3d		48f7c603000000		TESTQ $0x3, SI		
  0x40ac44		750d			JNE 0x40ac53		
	return (n + a - 1) &^ (a - 1)
  0x40ac46		4983c103		ADDQ $0x3, R9		
  0x40ac4a		4983e1fc		ANDQ $-0x4, R9		
				off = round(off, 4)
  0x40ac4e		e989fbffff		JMP 0x40a7dc		
			} else if size&1 == 0 {
  0x40ac53		0fbae600		BTL $0x0, SI		
  0x40ac57		0f827ffbffff		JB 0x40a7dc		
	return (n + a - 1) &^ (a - 1)
  0x40ac5d		49ffc1			INCQ R9			
  0x40ac60		4983e1fe		ANDQ $-0x2, R9		
				off = round(off, 2)
  0x40ac64		e973fbffff		JMP 0x40a7dc		
			if size <= smallSizeMax-8 {
  0x40ac69		4881fef8030000		CMPQ $0x3f8, SI		
  0x40ac70		0f87af010000		JA 0x40ae25		
				sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]
  0x40ac76		4c8d4e07		LEAQ 0x7(SI), R9			
  0x40ac7a		49c1e903		SHRQ $0x3, R9				
  0x40ac7e		4981f981000000		CMPQ $0x81, R9				
  0x40ac85		0f83e7020000		JAE 0x40af72				
  0x40ac8b		4c8d158ea40900		LEAQ runtime.size_to_class8(SB), R10	
  0x40ac92		470fb60c0a		MOVZX 0(R10)(R9*1), R9			
			size = uintptr(class_to_size[sizeclass])
  0x40ac97		450fb6d1		MOVZX R9, R10				
  0x40ac9b		4983fa43		CMPQ $0x43, R10				
  0x40ac9f		0f83bf020000		JAE 0x40af64				
  0x40aca5		4c8d1d14a50900		LEAQ runtime.class_to_size(SB), R11	
  0x40acac		470fb71453		MOVZX 0(R11)(R10*2), R10		
  0x40acb1		4c899424a0000000	MOVQ R10, 0xa0(SP)			
			span := c.alloc[spc]
  0x40acb9		8400			TESTB AL, 0(AX)		
	return spanClass(sizeclass<<1) | spanClass(bool2int(noscan))
  0x40acbb		41d1e1			SHLL $0x1, R9		
	return int(uint8(*(*uint8)(unsafe.Pointer(&x))))
  0x40acbe		450fb6d0		MOVZX R8, R10		
	return spanClass(sizeclass<<1) | spanClass(bool2int(noscan))
  0x40acc2		4509d1			ORL R10, R9		
			span := c.alloc[spc]
  0x40acc5		450fb6d1		MOVZX R9, R10			
  0x40acc9		4981fa86000000		CMPQ $0x86, R10			
  0x40acd0		0f8387020000		JAE 0x40af5d			
  0x40acd6		4e8b54d028		MOVQ 0x28(AX)(R10*8), R10	
	theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?
  0x40acdb		4d8b5a40		MOVQ 0x40(R10), R11	
  0x40acdf		4d0fbce3		BSFQ R11, R12		
  0x40ace3		41bd40000000		MOVL $0x40, R13		
  0x40ace9		4d0f44e5		CMOVE R13, R12		
	if theBit < 64 {
  0x40aced		4983fc40		CMPQ $0x40, R12		
  0x40acf1		0f8d27010000		JGE 0x40ae1e		
		result := s.freeindex + uintptr(theBit)
  0x40acf7		4d8b6a30		MOVQ 0x30(R10), R13	
  0x40acfb		4f8d742500		LEAQ 0(R13)(R12*1), R14	
		if result < s.nelems {
  0x40ad00		4d8b7a38		MOVQ 0x38(R10), R15	
  0x40ad04		4d39fe			CMPQ R15, R14		
  0x40ad07		0f8311010000		JAE 0x40ae1e		
			freeidx := result + 1
  0x40ad0d		4f8d6c2501		LEAQ 0x1(R13)(R12*1), R13	
			if freeidx%64 == 0 && freeidx != s.nelems {
  0x40ad12		49f7c53f000000		TESTQ $0x3f, R13	
  0x40ad19		0f85c7000000		JNE 0x40ade6		
  0x40ad1f		4d39fd			CMPQ R15, R13		
  0x40ad22		0f84be000000		JE 0x40ade6		
  0x40ad28		31c9			XORL CX, CX		
			if v == 0 {
  0x40ad2a		4885c9			TESTQ CX, CX		
  0x40ad2d		7472			JE 0x40ada1		
  0x40ad2f		4531c9			XORL R9, R9		
			x = unsafe.Pointer(v)
  0x40ad32		440fb69c24b0000000	MOVZX 0xb0(SP), R11	
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  0x40ad3b		4584db			TESTL R11, R11		
			if needzero && span.needzero != 0 {
  0x40ad3e		740a			JE 0x40ad4a		
  0x40ad40		450fb65265		MOVZX 0x65(R10), R10	
  0x40ad45		4584d2			TESTL R10, R10		
  0x40ad48		7508			JNE 0x40ad52		
  0x40ad4a		4989ca			MOVQ CX, R10		
	if !noscan {
  0x40ad4d		e993fbffff		JMP 0x40a8e5		
  0x40ad52		48894c2440		MOVQ CX, 0x40(SP)	
  0x40ad57		44884c242e		MOVB R9, 0x2e(SP)	
				memclrNoHeapPointers(unsafe.Pointer(v), size)
  0x40ad5c		48890c24		MOVQ CX, 0(SP)				
  0x40ad60		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x40ad68		4889442408		MOVQ AX, 0x8(SP)			
  0x40ad6d		e8fec00300		CALL runtime.memclrNoHeapPointers(SB)	
  0x40ad72		488b442460		MOVQ 0x60(SP), AX			
  0x40ad77		488b4c2440		MOVQ 0x40(SP), CX			
  0x40ad7c		488b542450		MOVQ 0x50(SP), DX			
  0x40ad81		488b5c2468		MOVQ 0x68(SP), BX			
  0x40ad86		488b742438		MOVQ 0x38(SP), SI			
  0x40ad8b		488bbc24a8000000	MOVQ 0xa8(SP), DI			
  0x40ad93		440fb644242f		MOVZX 0x2f(SP), R8			
  0x40ad99		440fb64c242e		MOVZX 0x2e(SP), R9			
  0x40ad9f		eba9			JMP 0x40ad4a				
				v, span, shouldhelpgc = c.nextFree(spc)
  0x40ada1		48890424		MOVQ AX, 0(SP)				
  0x40ada5		44884c2408		MOVB R9, 0x8(SP)			
  0x40adaa		e801f6ffff		CALL runtime.(*mcache).nextFree(SB)	
  0x40adaf		488b4c2410		MOVQ 0x10(SP), CX			
  0x40adb4		4c8b542418		MOVQ 0x18(SP), R10			
  0x40adb9		440fb64c2420		MOVZX 0x20(SP), R9			
  0x40adbf		488b442460		MOVQ 0x60(SP), AX			
  0x40adc4		488b542450		MOVQ 0x50(SP), DX			
  0x40adc9		488b5c2468		MOVQ 0x68(SP), BX			
  0x40adce		488b742438		MOVQ 0x38(SP), SI			
  0x40add3		488bbc24a8000000	MOVQ 0xa8(SP), DI			
  0x40addb		440fb644242f		MOVZX 0x2f(SP), R8			
  0x40ade1		e94cffffff		JMP 0x40ad32				
			s.allocCache >>= uint(theBit + 1)
  0x40ade6		498d4c2401		LEAQ 0x1(R12), CX	
  0x40adeb		49d3eb			SHRQ CL, R11		
  0x40adee		4883f940		CMPQ $0x40, CX		
  0x40adf2		4d19e4			SBBQ R12, R12		
  0x40adf5		4d21e3			ANDQ R12, R11		
  0x40adf8		4d895a40		MOVQ R11, 0x40(R10)	
			s.freeindex = freeidx
  0x40adfc		4d896a30		MOVQ R13, 0x30(R10)	
			s.allocCount++
  0x40ae00		450fb75a60		MOVZX 0x60(R10), R11	
  0x40ae05		41ffc3			INCL R11		
  0x40ae08		6645895a60		MOVW R11, 0x60(R10)	
			return gclinkptr(result*s.elemsize + s.base())
  0x40ae0d		498b4a68		MOVQ 0x68(R10), CX	
  0x40ae11		490fafce		IMULQ R14, CX		
  0x40ae15		49034a18		ADDQ 0x18(R10), CX	
			v := nextFreeFast(span)
  0x40ae19		e90cffffff		JMP 0x40ad2a		
  0x40ae1e		31c9			XORL CX, CX		
  0x40ae20		e905ffffff		JMP 0x40ad2a		
				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]
  0x40ae25		4c8d8e7ffcffff		LEAQ 0xfffffc7f(SI), R9			
  0x40ae2c		49c1e907		SHRQ $0x7, R9				
  0x40ae30		4981f9f9000000		CMPQ $0xf9, R9				
  0x40ae37		0f832e010000		JAE 0x40af6b				
  0x40ae3d		4c8d151ca40900		LEAQ runtime.size_to_class128(SB), R10	
  0x40ae44		470fb60c11		MOVZX 0(R9)(R10*1), R9			
  0x40ae49		e949feffff		JMP 0x40ac97				
		var s *mspan
  0x40ae4e		48c744244800000000	MOVQ $0x0, 0x48(SP)	
		systemstack(func() {
  0x40ae57		0f57c0			XORPS X0, X0				
  0x40ae5a		0f11442470		MOVUPS X0, 0x70(SP)			
  0x40ae5f		0f11842480000000	MOVUPS X0, 0x80(SP)			
  0x40ae67		488d05c26d0300		LEAQ runtime.mallocgc.func1(SB), AX	
  0x40ae6e		4889442470		MOVQ AX, 0x70(SP)			
  0x40ae73		488d8424a0000000	LEAQ 0xa0(SP), AX			
  0x40ae7b		4889442478		MOVQ AX, 0x78(SP)			
  0x40ae80		0fb68424b0000000	MOVZX 0xb0(SP), AX			
  0x40ae88		88842480000000		MOVB AL, 0x80(SP)			
  0x40ae8f		4488842481000000	MOVB R8, 0x81(SP)			
  0x40ae97		488d442448		LEAQ 0x48(SP), AX			
  0x40ae9c		4889842488000000	MOVQ AX, 0x88(SP)			
  0x40aea4		488d442470		LEAQ 0x70(SP), AX			
  0x40aea9		48890424		MOVQ AX, 0(SP)				
  0x40aead		e86e950300		CALL runtime.systemstack(SB)		
		s.freeindex = 1
  0x40aeb2		488b442448		MOVQ 0x48(SP), AX	
  0x40aeb7		48c7403001000000	MOVQ $0x1, 0x30(AX)	
		s.allocCount = 1
  0x40aebf		488b442448		MOVQ 0x48(SP), AX	
  0x40aec4		66c740600100		MOVW $0x1, 0x60(AX)	
		x = unsafe.Pointer(s.base())
  0x40aeca		488b442448		MOVQ 0x48(SP), AX	
	return s.startAddr
  0x40aecf		4c8b5018		MOVQ 0x18(AX), R10	
		size = s.elemsize
  0x40aed3		488b4068		MOVQ 0x68(AX), AX	
  0x40aed7		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x40aedf		488b442460		MOVQ 0x60(SP), AX	
  0x40aee4		488b542450		MOVQ 0x50(SP), DX	
  0x40aee9		488b5c2468		MOVQ 0x68(SP), BX	
  0x40aeee		488b742438		MOVQ 0x38(SP), SI	
  0x40aef3		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x40aefb		440fb644242f		MOVZX 0x2f(SP), R8	
  0x40af01		41b901000000		MOVL $0x1, R9		
  0x40af07		e9d9f9ffff		JMP 0x40a8e5		
  0x40af0c		41b801000000		MOVL $0x1, R8		
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40af12		e973f8ffff		JMP 0x40a78a		
  0x40af17		48895c2468		MOVQ BX, 0x68(SP)	
			gcAssistAlloc(assistG)
  0x40af1c		48891c24		MOVQ BX, 0(SP)			
  0x40af20		e87b9a0000		CALL runtime.gcAssistAlloc(SB)	
  0x40af25		488b5c2468		MOVQ 0x68(SP), BX		
  0x40af2a		e9daf7ffff		JMP 0x40a709			
  0x40af2f		4889d3			MOVQ DX, BX			
		if assistG.m.curg != nil {
  0x40af32		e9b8f7ffff		JMP 0x40a6ef		
  0x40af37		31db			XORL BX, BX		
	if gcBlackenEnabled != 0 {
  0x40af39		e9cbf7ffff		JMP 0x40a709		
		return unsafe.Pointer(&zerobase)
  0x40af3e		488d05bb8a0b00		LEAQ runtime.zerobase(SB), AX	
  0x40af45		48898424b8000000	MOVQ AX, 0xb8(SP)		
  0x40af4d		488bac2490000000	MOVQ 0x90(SP), BP		
  0x40af55		4881c498000000		ADDQ $0x98, SP			
  0x40af5c		c3			RET				
			span := c.alloc[spc]
  0x40af5d		e8de4a0100		CALL runtime.panicindex(SB)	
  0x40af62		0f0b			UD2				
			size = uintptr(class_to_size[sizeclass])
  0x40af64		e8d74a0100		CALL runtime.panicindex(SB)	
  0x40af69		0f0b			UD2				
				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]
  0x40af6b		e8d04a0100		CALL runtime.panicindex(SB)	
  0x40af70		0f0b			UD2				
				sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]
  0x40af72		e8c94a0100		CALL runtime.panicindex(SB)	
  0x40af77		0f0b			UD2				
		throw("malloc during signal")
  0x40af79		488d05c5010600		LEAQ 0x601c5(IP), AX	
  0x40af80		48890424		MOVQ AX, 0(SP)		
  0x40af84		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x40af8d		e83e620100		CALL runtime.throw(SB)	
  0x40af92		0f0b			UD2			
		throw("malloc deadlock")
  0x40af94		488d05d0f90500		LEAQ 0x5f9d0(IP), AX	
  0x40af9b		48890424		MOVQ AX, 0(SP)		
  0x40af9f		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x40afa8		e823620100		CALL runtime.throw(SB)	
  0x40afad		0f0b			UD2			
		throw("mallocgc called with gcphase == _GCmarktermination")
  0x40afaf		488d056e2a0600		LEAQ 0x62a6e(IP), AX	
  0x40afb6		48890424		MOVQ AX, 0(SP)		
  0x40afba		48c744240832000000	MOVQ $0x32, 0x8(SP)	
  0x40afc3		e808620100		CALL runtime.throw(SB)	
  0x40afc8		0f0b			UD2			
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  0x40afca		e8a1950300		CALL runtime.morestack_noctxt(SB)	
  0x40afcf		e93cf6ffff		JMP runtime.mallocgc(SB)		

TEXT runtime.largeAlloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func largeAlloc(size uintptr, needzero bool, noscan bool) *mspan {
  0x40afe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40afe9		483b6110		CMPQ 0x10(CX), SP	
  0x40afed		0f861a010000		JBE 0x40b10d		
  0x40aff3		4883ec38		SUBQ $0x38, SP		
  0x40aff7		48896c2430		MOVQ BP, 0x30(SP)	
  0x40affc		488d6c2430		LEAQ 0x30(SP), BP	
  0x40b001		488b442440		MOVQ 0x40(SP), AX	
	if size+_PageSize < size {
  0x40b006		488d8800200000		LEAQ 0x2000(AX), CX	
  0x40b00d		4839c1			CMPQ AX, CX		
  0x40b010		0f82dc000000		JB 0x40b0f2		
  0x40b016		4889c1			MOVQ AX, CX		
	npages := size >> _PageShift
  0x40b019		48c1e80d		SHRQ $0xd, AX		
	if size&_PageMask != 0 {
  0x40b01d		48f7c1ff1f0000		TESTQ $0x1fff, CX	
  0x40b024		7403			JE 0x40b029		
		npages++
  0x40b026		48ffc0			INCQ AX			
  0x40b029		4889442420		MOVQ AX, 0x20(SP)	
  0x40b02e		4889c1			MOVQ AX, CX		
	deductSweepCredit(npages*_PageSize, npages)
  0x40b031		48c1e00d		SHLQ $0xd, AX				
  0x40b035		48890424		MOVQ AX, 0(SP)				
  0x40b039		48894c2408		MOVQ CX, 0x8(SP)			
  0x40b03e		e8fdd80000		CALL runtime.deductSweepCredit(SB)	
	s := mheap_.alloc(npages, makeSpanClass(0, noscan), true, needzero)
  0x40b043		488d0556120a00		LEAQ runtime.mheap_(SB), AX	
  0x40b04a		48890424		MOVQ AX, 0(SP)			
  0x40b04e		488b442420		MOVQ 0x20(SP), AX		
  0x40b053		4889442408		MOVQ AX, 0x8(SP)		
  0x40b058		0fb6442449		MOVZX 0x49(SP), AX		
  0x40b05d		88442410		MOVB AL, 0x10(SP)		
  0x40b061		c644241101		MOVB $0x1, 0x11(SP)		
  0x40b066		0fb6442448		MOVZX 0x48(SP), AX		
  0x40b06b		88442412		MOVB AL, 0x12(SP)		
  0x40b06f		e89cfb0000		CALL runtime.(*mheap).alloc(SB)	
  0x40b074		488b442418		MOVQ 0x18(SP), AX		
	if s == nil {
  0x40b079		4885c0			TESTQ AX, AX		
  0x40b07c		7459			JE 0x40b0d7		
  0x40b07e		4889442428		MOVQ AX, 0x28(SP)	
	return s.startAddr
  0x40b083		488b4818		MOVQ 0x18(AX), CX	
  0x40b087		488b542440		MOVQ 0x40(SP), DX	
	s.limit = s.base() + size
  0x40b08c		4801d1			ADDQ DX, CX		
  0x40b08f		48898880000000		MOVQ CX, 0x80(AX)	
	return s.startAddr
  0x40b096		488b4818		MOVQ 0x18(AX), CX	
	heapBitsForSpan(s.base()).initSpan(s)
  0x40b09a		48890c24		MOVQ CX, 0(SP)				
  0x40b09e		e8bd100000		CALL runtime.heapBitsForSpan(SB)	
  0x40b0a3		8b442410		MOVL 0x10(SP), AX			
  0x40b0a7		488b4c2408		MOVQ 0x8(SP), CX			
  0x40b0ac		48890c24		MOVQ CX, 0(SP)				
  0x40b0b0		89442408		MOVL AX, 0x8(SP)			
  0x40b0b4		488b442428		MOVQ 0x28(SP), AX			
  0x40b0b9		4889442410		MOVQ AX, 0x10(SP)			
  0x40b0be		e87d1e0000		CALL runtime.heapBits.initSpan(SB)	
	return s
  0x40b0c3		488b442428		MOVQ 0x28(SP), AX	
  0x40b0c8		4889442450		MOVQ AX, 0x50(SP)	
  0x40b0cd		488b6c2430		MOVQ 0x30(SP), BP	
  0x40b0d2		4883c438		ADDQ $0x38, SP		
  0x40b0d6		c3			RET			
		throw("out of memory")
  0x40b0d7		488d0597f60500		LEAQ 0x5f697(IP), AX	
  0x40b0de		48890424		MOVQ AX, 0(SP)		
  0x40b0e2		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40b0eb		e8e0600100		CALL runtime.throw(SB)	
  0x40b0f0		0f0b			UD2			
		throw("out of memory")
  0x40b0f2		488d057cf60500		LEAQ 0x5f67c(IP), AX	
  0x40b0f9		48890424		MOVQ AX, 0(SP)		
  0x40b0fd		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40b106		e8c5600100		CALL runtime.throw(SB)	
  0x40b10b		0f0b			UD2			
func largeAlloc(size uintptr, needzero bool, noscan bool) *mspan {
  0x40b10d		e85e940300		CALL runtime.morestack_noctxt(SB)	
  0x40b112		e9c9feffff		JMP runtime.largeAlloc(SB)		

TEXT runtime.newobject(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func newobject(typ *_type) unsafe.Pointer {
  0x40b120		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b129		483b6110		CMPQ 0x10(CX), SP	
  0x40b12d		763d			JBE 0x40b16c		
  0x40b12f		4883ec28		SUBQ $0x28, SP		
  0x40b133		48896c2420		MOVQ BP, 0x20(SP)	
  0x40b138		488d6c2420		LEAQ 0x20(SP), BP	
  0x40b13d		488b442430		MOVQ 0x30(SP), AX	
	return mallocgc(typ.size, typ, true)
  0x40b142		488b08			MOVQ 0(AX), CX			
  0x40b145		48890c24		MOVQ CX, 0(SP)			
  0x40b149		4889442408		MOVQ AX, 0x8(SP)		
  0x40b14e		c644241001		MOVB $0x1, 0x10(SP)		
  0x40b153		e8b8f4ffff		CALL runtime.mallocgc(SB)	
  0x40b158		488b442418		MOVQ 0x18(SP), AX		
  0x40b15d		4889442438		MOVQ AX, 0x38(SP)		
  0x40b162		488b6c2420		MOVQ 0x20(SP), BP		
  0x40b167		4883c428		ADDQ $0x28, SP			
  0x40b16b		c3			RET				
func newobject(typ *_type) unsafe.Pointer {
  0x40b16c		e8ff930300		CALL runtime.morestack_noctxt(SB)	
  0x40b171		ebad			JMP runtime.newobject(SB)		

TEXT runtime.newarray(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func newarray(typ *_type, n int) unsafe.Pointer {
  0x40b180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b189		483b6110		CMPQ 0x10(CX), SP	
  0x40b18d		0f86cf000000		JBE 0x40b262		
  0x40b193		4883ec28		SUBQ $0x28, SP		
  0x40b197		48896c2420		MOVQ BP, 0x20(SP)	
  0x40b19c		488d6c2420		LEAQ 0x20(SP), BP	
  0x40b1a1		488b4c2438		MOVQ 0x38(SP), CX	
	if n == 1 {
  0x40b1a6		4883f901		CMPQ $0x1, CX		
  0x40b1aa		7469			JE 0x40b215		
	if n < 0 || uintptr(n) > maxSliceCap(typ.size) {
  0x40b1ac		4885c9			TESTQ CX, CX		
  0x40b1af		0f8c8f000000		JL 0x40b244		
  0x40b1b5		488b542430		MOVQ 0x30(SP), DX	
  0x40b1ba		488b1a			MOVQ 0(DX), BX		
	if elemsize < uintptr(len(maxElems)) {
  0x40b1bd		4883fb21		CMPQ $0x21, BX		
  0x40b1c1		733b			JAE 0x40b1fe		
		return maxElems[elemsize]
  0x40b1c3		488d05b6a30900		LEAQ runtime.maxElems(SB), AX	
  0x40b1ca		488b04d8		MOVQ 0(AX)(BX*8), AX		
	if n < 0 || uintptr(n) > maxSliceCap(typ.size) {
  0x40b1ce		4839c1			CMPQ AX, CX		
  0x40b1d1		7771			JA 0x40b244		
	return mallocgc(typ.size*uintptr(n), typ, true)
  0x40b1d3		480fafd9		IMULQ CX, BX			
  0x40b1d7		48891c24		MOVQ BX, 0(SP)			
  0x40b1db		4889542408		MOVQ DX, 0x8(SP)		
  0x40b1e0		c644241001		MOVB $0x1, 0x10(SP)		
  0x40b1e5		e826f4ffff		CALL runtime.mallocgc(SB)	
  0x40b1ea		488b442418		MOVQ 0x18(SP), AX		
  0x40b1ef		4889442440		MOVQ AX, 0x40(SP)		
  0x40b1f4		488b6c2420		MOVQ 0x20(SP), BP		
  0x40b1f9		4883c428		ADDQ $0x28, SP			
  0x40b1fd		c3			RET				
	return _MaxMem / elemsize
  0x40b1fe		48b8ffffffff7f000000	MOVQ $0x7fffffffff, AX	
  0x40b208		4889d6			MOVQ DX, SI		
  0x40b20b		31d2			XORL DX, DX		
  0x40b20d		48f7f3			DIVQ BX			
  0x40b210		4889f2			MOVQ SI, DX		
	if n < 0 || uintptr(n) > maxSliceCap(typ.size) {
  0x40b213		ebb9			JMP 0x40b1ce		
  0x40b215		488b442430		MOVQ 0x30(SP), AX	
		return mallocgc(typ.size, typ, true)
  0x40b21a		488b08			MOVQ 0(AX), CX			
  0x40b21d		48890c24		MOVQ CX, 0(SP)			
  0x40b221		4889442408		MOVQ AX, 0x8(SP)		
  0x40b226		c644241001		MOVB $0x1, 0x10(SP)		
  0x40b22b		e8e0f3ffff		CALL runtime.mallocgc(SB)	
  0x40b230		488b442418		MOVQ 0x18(SP), AX		
  0x40b235		4889442440		MOVQ AX, 0x40(SP)		
  0x40b23a		488b6c2420		MOVQ 0x20(SP), BP		
  0x40b23f		4883c428		ADDQ $0x28, SP			
  0x40b243		c3			RET				
		panic(plainError("runtime: allocation size out of range"))
  0x40b244		488d05f5fd0400		LEAQ 0x4fdf5(IP), AX			
  0x40b24b		48890424		MOVQ AX, 0(SP)				
  0x40b24f		488d051a9b0600		LEAQ runtime.statictmp_17(SB), AX	
  0x40b256		4889442408		MOVQ AX, 0x8(SP)			
  0x40b25b		e8d0570100		CALL runtime.gopanic(SB)		
  0x40b260		0f0b			UD2					
func newarray(typ *_type, n int) unsafe.Pointer {
  0x40b262		e809930300		CALL runtime.morestack_noctxt(SB)	
  0x40b267		e914ffffff		JMP runtime.newarray(SB)		

TEXT runtime.profilealloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
  0x40b270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b279		483b6110		CMPQ 0x10(CX), SP	
  0x40b27d		7646			JBE 0x40b2c5		
  0x40b27f		4883ec18		SUBQ $0x18, SP		
  0x40b283		48896c2410		MOVQ BP, 0x10(SP)	
  0x40b288		488d6c2410		LEAQ 0x10(SP), BP	
	mp.mcache.next_sample = nextSample()
  0x40b28d		e83e000000		CALL runtime.nextSample(SB)	
func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
  0x40b292		488b442420		MOVQ 0x20(SP), AX	
	mp.mcache.next_sample = nextSample()
  0x40b297		488b8060010000		MOVQ 0x160(AX), AX	
  0x40b29e		8b0c24			MOVL 0(SP), CX		
  0x40b2a1		8908			MOVL CX, 0(AX)		
func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
  0x40b2a3		488b442428		MOVQ 0x28(SP), AX	
	mProf_Malloc(x, size)
  0x40b2a8		48890424		MOVQ AX, 0(SP)		
func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
  0x40b2ac		488b442430		MOVQ 0x30(SP), AX	
	mProf_Malloc(x, size)
  0x40b2b1		4889442408		MOVQ AX, 0x8(SP)		
  0x40b2b6		e8d5220100		CALL runtime.mProf_Malloc(SB)	
}
  0x40b2bb		488b6c2410		MOVQ 0x10(SP), BP	
  0x40b2c0		4883c418		ADDQ $0x18, SP		
  0x40b2c4		c3			RET			
func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
  0x40b2c5		e8a6920300		CALL runtime.morestack_noctxt(SB)	
  0x40b2ca		eba4			JMP runtime.profilealloc(SB)		

TEXT runtime.nextSample(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func nextSample() int32 {
  0x40b2d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b2d9		483b6110		CMPQ 0x10(CX), SP	
  0x40b2dd		7630			JBE 0x40b30f		
  0x40b2df		4883ec18		SUBQ $0x18, SP		
  0x40b2e3		48896c2410		MOVQ BP, 0x10(SP)	
  0x40b2e8		488d6c2410		LEAQ 0x10(SP), BP	
	return fastexprand(MemProfileRate)
  0x40b2ed		488b05249d0900		MOVQ runtime.MemProfileRate(SB), AX	
  0x40b2f4		48890424		MOVQ AX, 0(SP)				
  0x40b2f8		e823000000		CALL runtime.fastexprand(SB)		
  0x40b2fd		8b442408		MOVL 0x8(SP), AX			
  0x40b301		89442420		MOVL AX, 0x20(SP)			
  0x40b305		488b6c2410		MOVQ 0x10(SP), BP			
  0x40b30a		4883c418		ADDQ $0x18, SP				
  0x40b30e		c3			RET					
func nextSample() int32 {
  0x40b30f		e85c920300		CALL runtime.morestack_noctxt(SB)	
  0x40b314		ebba			JMP runtime.nextSample(SB)		

TEXT runtime.fastexprand(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func fastexprand(mean int) int32 {
  0x40b320		4883ec08		SUBQ $0x8, SP		
  0x40b324		48892c24		MOVQ BP, 0(SP)		
  0x40b328		488d2c24		LEAQ 0(SP), BP		
  0x40b32c		488b442410		MOVQ 0x10(SP), AX	
	case mean > 0x7000000:
  0x40b331		483d00000007		CMPQ $0x7000000, AX	
  0x40b337		0f8e3c010000		JLE 0x40b479		
  0x40b33d		b800000007		MOVL $0x7000000, AX	
	mp := getg().m
  0x40b342		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b34b		488b4930		MOVQ 0x30(CX), CX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40b34f		8b9120010000		MOVL 0x120(CX), DX	
  0x40b355		8b9924010000		MOVL 0x124(CX), BX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40b35b		899920010000		MOVL BX, 0x120(CX)	
  0x40b361		89d6			MOVL DX, SI		
	s1 ^= s1 << 17
  0x40b363		c1e211			SHLL $0x11, DX		
  0x40b366		31f2			XORL SI, DX		
  0x40b368		89de			MOVL BX, SI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x40b36a		31d3			XORL DX, BX		
  0x40b36c		c1ea07			SHRL $0x7, DX		
  0x40b36f		31da			XORL BX, DX		
  0x40b371		89f3			MOVL SI, BX		
  0x40b373		c1ee10			SHRL $0x10, SI		
  0x40b376		31d6			XORL DX, SI		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40b378		89b124010000		MOVL SI, 0x124(CX)	
	return s0 + s1
  0x40b37e		8d0c1e			LEAL 0(SI)(BX*1), CX	
	q := fastrand()%(1<<randomBitCount) + 1
  0x40b381		81e1ffffff03		ANDL $0x3ffffff, CX	
  0x40b387		ffc1			INCL CX			
	qlog := fastlog2(float64(q)) - randomBitCount
  0x40b389		0f57c0			XORPS X0, X0		
  0x40b38c		f2480f2ac1		CVTSI2SDQ CX, X0	
	return *(*uint64)(unsafe.Pointer(&f))
  0x40b391		66480f7ec1		MOVQ X0, CX		
  0x40b396		4889ca			MOVQ CX, DX		
	xManIndex := (xBits >> (52 - fastlogNumBits)) % (1 << fastlogNumBits)
  0x40b399		48c1e92f		SHRQ $0x2f, CX		
  0x40b39d		4883e11f		ANDQ $0x1f, CX		
	low, high := fastlog2Table[xManIndex], fastlog2Table[xManIndex+1]
  0x40b3a1		488d5901		LEAQ 0x1(CX), BX	
  0x40b3a5		4883fb21		CMPQ $0x21, BX		
  0x40b3a9		0f83e4000000		JAE 0x40b493		
  0x40b3af		4889d3			MOVQ DX, BX		
	xExp := int64((xBits>>52)&0x7FF) - 1023
  0x40b3b2		48c1ea34		SHRQ $0x34, DX		
  0x40b3b6		4881e2ff070000		ANDQ $0x7ff, DX		
  0x40b3bd		4881c201fcffff		ADDQ $-0x3ff, DX	
	xManScale := (xBits >> (52 - fastlogNumBits - fastlogScaleBits)) % (1 << fastlogScaleBits)
  0x40b3c4		48c1eb1b		SHRQ $0x1b, BX		
  0x40b3c8		4889de			MOVQ BX, SI		
  0x40b3cb		4881e3ffff0f00		ANDQ $0xfffff, BX	
	low, high := fastlog2Table[xManIndex], fastlog2Table[xManIndex+1]
  0x40b3d2		488d3d87a00900		LEAQ runtime.fastlog2Table(SB), DI	
  0x40b3d9		f20f1004cf		MOVSD_XMM 0(DI)(CX*8), X0		
  0x40b3de		f20f104ccf08		MOVSD_XMM 0x8(DI)(CX*8), X1		
	return float64(xExp) + low + (high-low)*float64(xManScale)*fastlogScaleRatio
  0x40b3e4		0f57d2			XORPS X2, X2				
  0x40b3e7		f2480f2ad2		CVTSI2SDQ DX, X2			
  0x40b3ec		f20f58d0		ADDSD X0, X2				
  0x40b3f0		f20f5cc8		SUBSD X0, X1				
  0x40b3f4		48f7c6ffff0f00		TESTQ $0xfffff, SI			
  0x40b3fb		7c64			JL 0x40b461				
  0x40b3fd		0f57c0			XORPS X0, X0				
  0x40b400		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x40b405		f20f59c1		MULSD X1, X0				
  0x40b409		f20f100d8f960600	MOVSD_XMM $f64.3eb0000000000000(SB), X1	
  0x40b411		f20f59c8		MULSD X0, X1				
  0x40b415		f20f58d1		ADDSD X1, X2				
	qlog := fastlog2(float64(q)) - randomBitCount
  0x40b419		f20f1005df960600	MOVSD_XMM $f64.403a000000000000(SB), X0	
  0x40b421		f20f5cd0		SUBSD X0, X2				
	if qlog > 0 {
  0x40b425		0f57c0			XORPS X0, X0		
  0x40b428		660f2ed0		UCOMISD X0, X2		
  0x40b42c		762e			JBE 0x40b45c		
  0x40b42e		0f57c0			XORPS X0, X0		
	return int32(qlog*(minusLog2*float64(mean))) + 1
  0x40b431		0f57c9			XORPS X1, X1				
  0x40b434		f2480f2ac8		CVTSI2SDQ AX, X1			
  0x40b439		f20f1015ef960600	MOVSD_XMM $f64.bfe62e42fefa39ef(SB), X2	
  0x40b441		f20f59ca		MULSD X2, X1				
  0x40b445		f20f59c1		MULSD X1, X0				
  0x40b449		f20f2cc0		CVTTSD2SIL X0, AX			
  0x40b44d		ffc0			INCL AX					
  0x40b44f		89442418		MOVL AX, 0x18(SP)			
  0x40b453		488b2c24		MOVQ 0(SP), BP				
  0x40b457		4883c408		ADDQ $0x8, SP				
  0x40b45b		c3			RET					
  0x40b45c		0f10c2			MOVUPS X2, X0				
	if qlog > 0 {
  0x40b45f		ebd0			JMP 0x40b431		
	return float64(xExp) + low + (high-low)*float64(xManScale)*fastlogScaleRatio
  0x40b461		48d1eb			SHRQ $0x1, BX		
  0x40b464		4883e601		ANDQ $0x1, SI		
  0x40b468		4809f3			ORQ SI, BX		
  0x40b46b		0f57c0			XORPS X0, X0		
  0x40b46e		f2480f2ac3		CVTSI2SDQ BX, X0	
  0x40b473		f20f58c0		ADDSD X0, X0		
  0x40b477		eb8c			JMP 0x40b405		
	case mean == 0:
  0x40b479		4885c0			TESTQ AX, AX		
  0x40b47c		0f85c0feffff		JNE 0x40b342		
		return 0
  0x40b482		c744241800000000	MOVL $0x0, 0x18(SP)	
  0x40b48a		488b2c24		MOVQ 0(SP), BP		
  0x40b48e		4883c408		ADDQ $0x8, SP		
  0x40b492		c3			RET			
	low, high := fastlog2Table[xManIndex], fastlog2Table[xManIndex+1]
  0x40b493		e8a8450100		CALL runtime.panicindex(SB)	
  0x40b498		0f0b			UD2				

TEXT runtime.persistentalloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40b4a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b4a9		483b6110		CMPQ 0x10(CX), SP	
  0x40b4ad		0f8683000000		JBE 0x40b536		
  0x40b4b3		4883ec40		SUBQ $0x40, SP		
  0x40b4b7		48896c2438		MOVQ BP, 0x38(SP)	
  0x40b4bc		488d6c2438		LEAQ 0x38(SP), BP	
	var p *notInHeap
  0x40b4c1		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	systemstack(func() {
  0x40b4ca		48c744241000000000	MOVQ $0x0, 0x10(SP)				
  0x40b4d3		0f57c0			XORPS X0, X0					
  0x40b4d6		0f11442418		MOVUPS X0, 0x18(SP)				
  0x40b4db		0f11442428		MOVUPS X0, 0x28(SP)				
  0x40b4e0		488d05b9670300		LEAQ runtime.persistentalloc.func1(SB), AX	
  0x40b4e7		4889442410		MOVQ AX, 0x10(SP)				
func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40b4ec		488b442448		MOVQ 0x48(SP), AX	
	systemstack(func() {
  0x40b4f1		4889442418		MOVQ AX, 0x18(SP)	
func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40b4f6		488b442450		MOVQ 0x50(SP), AX	
	systemstack(func() {
  0x40b4fb		4889442420		MOVQ AX, 0x20(SP)	
func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40b500		488b442458		MOVQ 0x58(SP), AX	
	systemstack(func() {
  0x40b505		4889442428		MOVQ AX, 0x28(SP)		
  0x40b50a		488d442408		LEAQ 0x8(SP), AX		
  0x40b50f		4889442430		MOVQ AX, 0x30(SP)		
  0x40b514		488d442410		LEAQ 0x10(SP), AX		
  0x40b519		48890424		MOVQ AX, 0(SP)			
  0x40b51d		e8fe8e0300		CALL runtime.systemstack(SB)	
	return unsafe.Pointer(p)
  0x40b522		488b442408		MOVQ 0x8(SP), AX	
  0x40b527		4889442460		MOVQ AX, 0x60(SP)	
  0x40b52c		488b6c2438		MOVQ 0x38(SP), BP	
  0x40b531		4883c440		ADDQ $0x40, SP		
  0x40b535		c3			RET			
func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40b536		e835900300		CALL runtime.morestack_noctxt(SB)	
  0x40b53b		e960ffffff		JMP runtime.persistentalloc(SB)		

TEXT runtime.persistentalloc1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
func persistentalloc1(size, align uintptr, sysStat *uint64) *notInHeap {
  0x40b540		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b549		483b6118		CMPQ 0x18(CX), SP	
  0x40b54d		0f86bf020000		JBE 0x40b812		
  0x40b553		4883ec40		SUBQ $0x40, SP		
  0x40b557		48896c2438		MOVQ BP, 0x38(SP)	
  0x40b55c		488d6c2438		LEAQ 0x38(SP), BP	
  0x40b561		488b442448		MOVQ 0x48(SP), AX	
	if size == 0 {
  0x40b566		4885c0			TESTQ AX, AX		
  0x40b569		0f8488020000		JE 0x40b7f7		
  0x40b56f		488b4c2450		MOVQ 0x50(SP), CX	
	if align != 0 {
  0x40b574		4885c9			TESTQ CX, CX		
  0x40b577		0f841f020000		JE 0x40b79c		
		if align&(align-1) != 0 {
  0x40b57d		488d51ff		LEAQ -0x1(CX), DX	
  0x40b581		4885d1			TESTQ DX, CX		
  0x40b584		0f8552020000		JNE 0x40b7dc		
		if align > _PageSize {
  0x40b58a		4881f900200000		CMPQ $0x2000, CX	
  0x40b591		0f872a020000		JA 0x40b7c1		
	if size >= maxBlock {
  0x40b597		483d00000100		CMPQ $0x10000, AX	
  0x40b59d		0f83d2010000		JAE 0x40b775		
  0x40b5a3		48894c2418		MOVQ CX, 0x18(SP)	
	_g_ := getg()
  0x40b5a8		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	_g_.m.locks++
  0x40b5b1		488b5a30		MOVQ 0x30(DX), BX	
  0x40b5b5		ff8300010000		INCL 0x100(BX)		
	return _g_.m
  0x40b5bb		488b5230		MOVQ 0x30(DX), DX	
  0x40b5bf		4889542428		MOVQ DX, 0x28(SP)	
	if mp != nil && mp.p != 0 {
  0x40b5c4		4885d2			TESTQ DX, DX		
  0x40b5c7		0f847d010000		JE 0x40b74a		
  0x40b5cd		488b9ad0000000		MOVQ 0xd0(DX), BX	
  0x40b5d4		4885db			TESTQ BX, BX		
  0x40b5d7		0f846d010000		JE 0x40b74a		
		persistent = &mp.p.ptr().palloc
  0x40b5dd		8403			TESTB AL, 0(BX)		
  0x40b5df		4881c338120000		ADDQ $0x1238, BX	
  0x40b5e6		48895c2420		MOVQ BX, 0x20(SP)	
	persistent.off = round(persistent.off, align)
  0x40b5eb		488b7308		MOVQ 0x8(BX), SI	
	return (n + a - 1) &^ (a - 1)
  0x40b5ef		488d7431ff		LEAQ -0x1(CX)(SI*1), SI	
  0x40b5f4		48ffc9			DECQ CX			
  0x40b5f7		48f7d1			NOTQ CX			
  0x40b5fa		4821f1			ANDQ SI, CX		
	persistent.off = round(persistent.off, align)
  0x40b5fd		48894b08		MOVQ CX, 0x8(BX)	
	if persistent.off+size > chunk || persistent.base == nil {
  0x40b601		4801c1			ADDQ AX, CX		
  0x40b604		4881f900000400		CMPQ $0x40000, CX	
  0x40b60b		0f8625010000		JBE 0x40b736		
		persistent.base = (*notInHeap)(sysAlloc(chunk, &memstats.other_sys))
  0x40b611		48c7042400000400	MOVQ $0x40000, 0(SP)			
  0x40b619		488d0580910b00		LEAQ runtime.memstats+160(SB), AX	
  0x40b620		4889442408		MOVQ AX, 0x8(SP)			
  0x40b625		e8f6390000		CALL runtime.sysAlloc(SB)		
  0x40b62a		488b442410		MOVQ 0x10(SP), AX			
  0x40b62f		488b4c2420		MOVQ 0x20(SP), CX			
  0x40b634		488901			MOVQ AX, 0(CX)				
		if persistent.base == nil {
  0x40b637		4885c0			TESTQ AX, AX		
  0x40b63a		0f84d4000000		JE 0x40b714		
		persistent.off = 0
  0x40b640		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	p := persistent.base.add(persistent.off)
  0x40b648		488b01			MOVQ 0(CX), AX		
  0x40b64b		488b5108		MOVQ 0x8(CX), DX	
  0x40b64f		488b5c2448		MOVQ 0x48(SP), BX	
	persistent.off += size
  0x40b654		488d3413		LEAQ 0(BX)(DX*1), SI	
  0x40b658		48897108		MOVQ SI, 0x8(CX)	
	_g_ := getg()
  0x40b65c		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
  0x40b665		488b7c2428		MOVQ 0x28(SP), DI	
	mp.locks--
  0x40b66a		448b8700010000		MOVL 0x100(DI), R8	
  0x40b671		458d48ff		LEAL -0x1(R8), R9	
  0x40b675		44898f00010000		MOVL R9, 0x100(DI)	
	return (*notInHeap)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + bytes))
  0x40b67c		4801d0			ADDQ DX, AX		
	if mp.locks == 0 && _g_.preempt {
  0x40b67f		4183f801		CMPL $0x1, R8		
  0x40b683		7513			JNE 0x40b698		
  0x40b685		0fb696c0000000		MOVZX 0xc0(SI), DX	
  0x40b68c		84d2			TESTL DL, DL		
  0x40b68e		7408			JE 0x40b698		
		_g_.stackguard0 = stackPreempt
  0x40b690		48c74610defaffff	MOVQ $-0x522, 0x10(SI)	
  0x40b698		4889442430		MOVQ AX, 0x30(SP)	
	if persistent == &globalAlloc.persistentAlloc {
  0x40b69d		488d1594c00900		LEAQ runtime.globalAlloc+8(SB), DX	
  0x40b6a4		4839d1			CMPQ DX, CX				
  0x40b6a7		744f			JE 0x40b6f8				
  0x40b6a9		488b4c2458		MOVQ 0x58(SP), CX			
	if sysStat != &memstats.other_sys {
  0x40b6ae		488d15eb900b00		LEAQ runtime.memstats+160(SB), DX	
  0x40b6b5		4839d1			CMPQ DX, CX				
  0x40b6b8		750f			JNE 0x40b6c9				
	return p
  0x40b6ba		4889442460		MOVQ AX, 0x60(SP)	
  0x40b6bf		488b6c2438		MOVQ 0x38(SP), BP	
  0x40b6c4		4883c440		ADDQ $0x40, SP		
  0x40b6c8		c3			RET			
		mSysStatInc(sysStat, size)
  0x40b6c9		48890c24		MOVQ CX, 0(SP)			
  0x40b6cd		48895c2408		MOVQ BX, 0x8(SP)		
  0x40b6d2		e8192c0100		CALL runtime.mSysStatInc(SB)	
		mSysStatDec(&memstats.other_sys, size)
  0x40b6d7		488d05c2900b00		LEAQ runtime.memstats+160(SB), AX	
  0x40b6de		48890424		MOVQ AX, 0(SP)				
  0x40b6e2		488b442448		MOVQ 0x48(SP), AX			
  0x40b6e7		4889442408		MOVQ AX, 0x8(SP)			
  0x40b6ec		e8af2c0100		CALL runtime.mSysStatDec(SB)		
  0x40b6f1		488b442430		MOVQ 0x30(SP), AX			
  0x40b6f6		ebc2			JMP 0x40b6ba				
		unlock(&globalAlloc.mutex)
  0x40b6f8		488d0531c00900		LEAQ runtime.globalAlloc(SB), AX	
  0x40b6ff		48890424		MOVQ AX, 0(SP)				
  0x40b703		e8b8dfffff		CALL runtime.unlock(SB)			
  0x40b708		488b442430		MOVQ 0x30(SP), AX			
  0x40b70d		488b5c2448		MOVQ 0x48(SP), BX			
  0x40b712		eb95			JMP 0x40b6a9				
			if persistent == &globalAlloc.persistentAlloc {
  0x40b714		488d051dc00900		LEAQ runtime.globalAlloc+8(SB), AX	
  0x40b71b		4839c1			CMPQ AX, CX				
  0x40b71e		0f8582000000		JNE 0x40b7a6				
				unlock(&globalAlloc.mutex)
  0x40b724		488d0505c00900		LEAQ runtime.globalAlloc(SB), AX	
  0x40b72b		48890424		MOVQ AX, 0(SP)				
  0x40b72f		e88cdfffff		CALL runtime.unlock(SB)			
  0x40b734		eb70			JMP 0x40b7a6				
	if persistent.off+size > chunk || persistent.base == nil {
  0x40b736		488b0b			MOVQ 0(BX), CX		
  0x40b739		4885c9			TESTQ CX, CX		
  0x40b73c		0f84cffeffff		JE 0x40b611		
  0x40b742		4889d9			MOVQ BX, CX		
  0x40b745		e9fefeffff		JMP 0x40b648		
		lock(&globalAlloc.mutex)
  0x40b74a		488d05dfbf0900		LEAQ runtime.globalAlloc(SB), AX	
  0x40b751		48890424		MOVQ AX, 0(SP)				
  0x40b755		e8c6ddffff		CALL runtime.lock(SB)			
  0x40b75a		488b442448		MOVQ 0x48(SP), AX			
  0x40b75f		488b4c2418		MOVQ 0x18(SP), CX			
  0x40b764		488b542428		MOVQ 0x28(SP), DX			
  0x40b769		488d1dc8bf0900		LEAQ runtime.globalAlloc+8(SB), BX	
		persistent = &globalAlloc.persistentAlloc
  0x40b770		e971feffff		JMP 0x40b5e6		
		return (*notInHeap)(sysAlloc(size, sysStat))
  0x40b775		48890424		MOVQ AX, 0(SP)			
  0x40b779		488b442458		MOVQ 0x58(SP), AX		
  0x40b77e		4889442408		MOVQ AX, 0x8(SP)		
  0x40b783		e898380000		CALL runtime.sysAlloc(SB)	
  0x40b788		488b442410		MOVQ 0x10(SP), AX		
  0x40b78d		4889442460		MOVQ AX, 0x60(SP)		
  0x40b792		488b6c2438		MOVQ 0x38(SP), BP		
  0x40b797		4883c440		ADDQ $0x40, SP			
  0x40b79b		c3			RET				
  0x40b79c		b908000000		MOVL $0x8, CX			
	if size >= maxBlock {
  0x40b7a1		e9f1fdffff		JMP 0x40b597		
			throw("runtime: cannot allocate memory")
  0x40b7a6		488d05b80f0600		LEAQ 0x60fb8(IP), AX	
  0x40b7ad		48890424		MOVQ AX, 0(SP)		
  0x40b7b1		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x40b7ba		e8115a0100		CALL runtime.throw(SB)	
  0x40b7bf		0f0b			UD2			
			throw("persistentalloc: align is too large")
  0x40b7c1		488d05ad150600		LEAQ 0x615ad(IP), AX	
  0x40b7c8		48890424		MOVQ AX, 0(SP)		
  0x40b7cc		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x40b7d5		e8f6590100		CALL runtime.throw(SB)	
  0x40b7da		0f0b			UD2			
			throw("persistentalloc: align is not a power of 2")
  0x40b7dc		488d05e81c0600		LEAQ 0x61ce8(IP), AX	
  0x40b7e3		48890424		MOVQ AX, 0(SP)		
  0x40b7e7		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x40b7f0		e8db590100		CALL runtime.throw(SB)	
  0x40b7f5		0f0b			UD2			
		throw("persistentalloc: size == 0")
  0x40b7f7		488d0578040600		LEAQ 0x60478(IP), AX	
  0x40b7fe		48890424		MOVQ AX, 0(SP)		
  0x40b802		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x40b80b		e8c0590100		CALL runtime.throw(SB)	
  0x40b810		0f0b			UD2			
func persistentalloc1(size, align uintptr, sysStat *uint64) *notInHeap {
  0x40b812		e8e9b40200		CALL runtime.morestackc(SB)		
  0x40b817		e924fdffff		JMP runtime.persistentalloc1(SB)	

TEXT runtime.gcmarkwb_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func gcmarkwb_m(slot *uintptr, ptr uintptr) {
  0x40b820		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b829		483b6118		CMPQ 0x18(CX), SP	
  0x40b82d		0f86c0000000		JBE 0x40b8f3		
  0x40b833		4883ec10		SUBQ $0x10, SP		
  0x40b837		48896c2408		MOVQ BP, 0x8(SP)	
  0x40b83c		488d6c2408		LEAQ 0x8(SP), BP	
	if writeBarrier.needed {
  0x40b841		0fb605cc810b00		MOVZX runtime.writeBarrier+4(SB), AX	
  0x40b848		84c0			TESTL AL, AL				
  0x40b84a		742e			JE 0x40b87a				
  0x40b84c		488b442418		MOVQ 0x18(SP), AX			
  0x40b851		4889c1			MOVQ AX, CX				
		if slot1 := uintptr(unsafe.Pointer(slot)); slot1 >= minPhysPageSize {
  0x40b854		483d00100000		CMPQ $0x1000, AX	
  0x40b85a		7208			JB 0x40b864		
			if optr := *slot; optr != 0 {
  0x40b85c		488b01			MOVQ 0(CX), AX		
  0x40b85f		4885c0			TESTQ AX, AX		
  0x40b862		757a			JNE 0x40b8de		
  0x40b864		488b442420		MOVQ 0x20(SP), AX	
		if ptr != 0 && inheap(ptr) {
  0x40b869		4885c0			TESTQ AX, AX		
  0x40b86c		740c			JE 0x40b87a		
	if b == 0 || b < mheap_.arena_start || b >= mheap_.arena_used {
  0x40b86e		488b0d531d0a00		MOVQ runtime.mheap_+4904(SB), CX	
  0x40b875		4839c8			CMPQ CX, AX				
  0x40b878		730a			JAE 0x40b884				
  0x40b87a		488b6c2408		MOVQ 0x8(SP), BP			
  0x40b87f		4883c410		ADDQ $0x10, SP				
  0x40b883		c3			RET					
  0x40b884		488b15451d0a00		MOVQ runtime.mheap_+4912(SB), DX	
  0x40b88b		4839d0			CMPQ DX, AX				
  0x40b88e		73ea			JAE 0x40b87a				
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x40b890		488b15591a0a00		MOVQ runtime.mheap_+4176(SB), DX	
  0x40b897		488b1d4a1a0a00		MOVQ runtime.mheap_+4168(SB), BX	
  0x40b89e		4889c6			MOVQ AX, SI				
  0x40b8a1		4829c8			SUBQ CX, AX				
  0x40b8a4		48c1e80d		SHRQ $0xd, AX				
  0x40b8a8		4839d0			CMPQ DX, AX				
  0x40b8ab		733f			JAE 0x40b8ec				
  0x40b8ad		488b04c3		MOVQ 0(BX)(AX*8), AX			
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x40b8b1		4885c0			TESTQ AX, AX		
  0x40b8b4		74c4			JE 0x40b87a		
	return s.startAddr
  0x40b8b6		488b4818		MOVQ 0x18(AX), CX	
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x40b8ba		4839ce			CMPQ CX, SI		
  0x40b8bd		72bb			JB 0x40b87a		
  0x40b8bf		488b8880000000		MOVQ 0x80(AX), CX	
  0x40b8c6		4839ce			CMPQ CX, SI		
  0x40b8c9		73af			JAE 0x40b87a		
  0x40b8cb		0fb64064		MOVZX 0x64(AX), AX	
  0x40b8cf		3c01			CMPL $0x1, AL		
  0x40b8d1		75a7			JNE 0x40b87a		
			shade(ptr)
  0x40b8d3		48893424		MOVQ SI, 0(SP)		
  0x40b8d7		e884b10000		CALL runtime.shade(SB)	
  0x40b8dc		eb9c			JMP 0x40b87a		
				shade(optr)
  0x40b8de		48890424		MOVQ AX, 0(SP)		
  0x40b8e2		e879b10000		CALL runtime.shade(SB)	
  0x40b8e7		e978ffffff		JMP 0x40b864		
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x40b8ec		e84f410100		CALL runtime.panicindex(SB)	
  0x40b8f1		0f0b			UD2				
func gcmarkwb_m(slot *uintptr, ptr uintptr) {
  0x40b8f3		e808b40200		CALL runtime.morestackc(SB)	
  0x40b8f8		e923ffffff		JMP runtime.gcmarkwb_m(SB)	

TEXT runtime.writebarrierptr_prewrite1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func writebarrierptr_prewrite1(dst *uintptr, src uintptr) {
  0x40b900		4883ec38		SUBQ $0x38, SP		
  0x40b904		48896c2430		MOVQ BP, 0x30(SP)	
  0x40b909		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x40b90e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x40b917		488b4830		MOVQ 0x30(AX), CX	
  0x40b91b		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x40b921		488b4830		MOVQ 0x30(AX), CX	
  0x40b925		8400			TESTB AL, 0(AX)		
	if mp.inwb || mp.dying > 0 {
  0x40b927		0fb68116010000		MOVZX 0x116(CX), AX	
  0x40b92e		84c0			TESTL AL, AL		
  0x40b930		743a			JE 0x40b96c		
	_g_ := getg()
  0x40b932		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x40b93b		8b9100010000		MOVL 0x100(CX), DX	
  0x40b941		8d5aff			LEAL -0x1(DX), BX	
  0x40b944		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x40b94a		83fa01			CMPL $0x1, DX		
  0x40b94d		7513			JNE 0x40b962		
  0x40b94f		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x40b956		84c9			TESTL CL, CL		
  0x40b958		7408			JE 0x40b962		
		_g_.stackguard0 = stackPreempt
  0x40b95a		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
		return
  0x40b962		488b6c2430		MOVQ 0x30(SP), BP	
  0x40b967		4883c438		ADDQ $0x38, SP		
  0x40b96b		c3			RET			
	if mp.inwb || mp.dying > 0 {
  0x40b96c		8b8108010000		MOVL 0x108(CX), AX	
  0x40b972		85c0			TESTL AX, AX		
  0x40b974		7fbc			JG 0x40b932		
  0x40b976		48894c2408		MOVQ CX, 0x8(SP)	
	systemstack(func() {
  0x40b97b		488d058e630300		LEAQ runtime.writebarrierptr_prewrite1.func1(SB), AX	
  0x40b982		4889442410		MOVQ AX, 0x10(SP)					
  0x40b987		48894c2418		MOVQ CX, 0x18(SP)					
  0x40b98c		488b442448		MOVQ 0x48(SP), AX					
  0x40b991		4889442420		MOVQ AX, 0x20(SP)					
  0x40b996		488b442440		MOVQ 0x40(SP), AX					
  0x40b99b		4889442428		MOVQ AX, 0x28(SP)					
  0x40b9a0		488d442410		LEAQ 0x10(SP), AX					
  0x40b9a5		48890424		MOVQ AX, 0(SP)						
  0x40b9a9		e8728a0300		CALL runtime.systemstack(SB)				
func writebarrierptr_prewrite1(dst *uintptr, src uintptr) {
  0x40b9ae		488b442408		MOVQ 0x8(SP), AX	
	mp.inwb = false
  0x40b9b3		c6801601000000		MOVB $0x0, 0x116(AX)	
	_g_ := getg()
  0x40b9ba		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	mp.locks--
  0x40b9c3		8b9000010000		MOVL 0x100(AX), DX	
  0x40b9c9		8d5aff			LEAL -0x1(DX), BX	
  0x40b9cc		899800010000		MOVL BX, 0x100(AX)	
	if mp.locks == 0 && _g_.preempt {
  0x40b9d2		83fa01			CMPL $0x1, DX		
  0x40b9d5		7513			JNE 0x40b9ea		
  0x40b9d7		0fb681c0000000		MOVZX 0xc0(CX), AX	
  0x40b9de		84c0			TESTL AL, AL		
  0x40b9e0		7408			JE 0x40b9ea		
		_g_.stackguard0 = stackPreempt
  0x40b9e2		48c74110defaffff	MOVQ $-0x522, 0x10(CX)	
  0x40b9ea		488b6c2430		MOVQ 0x30(SP), BP	
  0x40b9ef		4883c438		ADDQ $0x38, SP		
  0x40b9f3		c3			RET			

TEXT runtime.writebarrierptr_prewrite(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func writebarrierptr_prewrite(dst *uintptr, src uintptr) {
  0x40ba00		4883ec18		SUBQ $0x18, SP		
  0x40ba04		48896c2410		MOVQ BP, 0x10(SP)	
  0x40ba09		488d6c2410		LEAQ 0x10(SP), BP	
	if writeBarrier.cgo {
  0x40ba0e		0fb60500800b00		MOVZX runtime.writeBarrier+5(SB), AX	
  0x40ba15		84c0			TESTL AL, AL				
  0x40ba17		755b			JNE 0x40ba74				
	if !writeBarrier.needed {
  0x40ba19		0fb605f47f0b00		MOVZX runtime.writeBarrier+4(SB), AX	
  0x40ba20		84c0			TESTL AL, AL				
  0x40ba22		7446			JE 0x40ba6a				
  0x40ba24		488b442428		MOVQ 0x28(SP), AX			
	if src != 0 && src < minPhysPageSize {
  0x40ba29		4885c0			TESTQ AX, AX		
  0x40ba2c		7408			JE 0x40ba36		
  0x40ba2e		483d00100000		CMPQ $0x1000, AX	
  0x40ba34		721d			JB 0x40ba53		
  0x40ba36		488b4c2420		MOVQ 0x20(SP), CX	
	writebarrierptr_prewrite1(dst, src)
  0x40ba3b		48890c24		MOVQ CX, 0(SP)					
  0x40ba3f		4889442408		MOVQ AX, 0x8(SP)				
  0x40ba44		e8b7feffff		CALL runtime.writebarrierptr_prewrite1(SB)	
}
  0x40ba49		488b6c2410		MOVQ 0x10(SP), BP	
  0x40ba4e		4883c418		ADDQ $0x18, SP		
  0x40ba52		c3			RET			
		systemstack(func() { throw("bad pointer in write barrier") })
  0x40ba53		488d05ee270600		LEAQ 0x627ee(IP), AX		
  0x40ba5a		48890424		MOVQ AX, 0(SP)			
  0x40ba5e		e8bd890300		CALL runtime.systemstack(SB)	
  0x40ba63		488b442428		MOVQ 0x28(SP), AX		
  0x40ba68		ebcc			JMP 0x40ba36			
		return
  0x40ba6a		488b6c2410		MOVQ 0x10(SP), BP	
  0x40ba6f		4883c418		ADDQ $0x18, SP		
  0x40ba73		c3			RET			
  0x40ba74		488b442420		MOVQ 0x20(SP), AX	
		cgoCheckWriteBarrier(dst, src)
  0x40ba79		48890424		MOVQ AX, 0(SP)				
  0x40ba7d		488b4c2428		MOVQ 0x28(SP), CX			
  0x40ba82		48894c2408		MOVQ CX, 0x8(SP)			
  0x40ba87		e8b46affff		CALL runtime.cgoCheckWriteBarrier(SB)	
  0x40ba8c		eb8b			JMP 0x40ba19				

TEXT runtime.typedmemmove(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func typedmemmove(typ *_type, dst, src unsafe.Pointer) {
  0x40ba90		4883ec30		SUBQ $0x30, SP		
  0x40ba94		48896c2428		MOVQ BP, 0x28(SP)	
  0x40ba99		488d6c2428		LEAQ 0x28(SP), BP	
  0x40ba9e		488b442438		MOVQ 0x38(SP), AX	
	if typ.kind&kindNoPointers == 0 {
  0x40baa3		0fb64817		MOVZX 0x17(AX), CX	
  0x40baa7		f6c180			TESTL $0x80, CL		
  0x40baaa		746a			JE 0x40bb16		
	memmove(dst, src, typ.size)
  0x40baac		488b08			MOVQ 0(AX), CX			
  0x40baaf		48894c2410		MOVQ CX, 0x10(SP)		
  0x40bab4		488b4c2440		MOVQ 0x40(SP), CX		
  0x40bab9		48890c24		MOVQ CX, 0(SP)			
  0x40babd		488b542448		MOVQ 0x48(SP), DX		
  0x40bac2		4889542408		MOVQ DX, 0x8(SP)		
  0x40bac7		e834b60300		CALL runtime.memmove(SB)	
	if writeBarrier.cgo {
  0x40bacc		0fb605427f0b00		MOVZX runtime.writeBarrier+5(SB), AX	
  0x40bad3		84c0			TESTL AL, AL				
  0x40bad5		750a			JNE 0x40bae1				
  0x40bad7		488b6c2428		MOVQ 0x28(SP), BP			
  0x40badc		4883c430		ADDQ $0x30, SP				
  0x40bae0		c3			RET					
  0x40bae1		488b442438		MOVQ 0x38(SP), AX			
		cgoCheckMemmove(typ, dst, src, 0, typ.size)
  0x40bae6		488b08			MOVQ 0(AX), CX				
  0x40bae9		48894c2420		MOVQ CX, 0x20(SP)			
  0x40baee		48890424		MOVQ AX, 0(SP)				
  0x40baf2		488b442440		MOVQ 0x40(SP), AX			
  0x40baf7		4889442408		MOVQ AX, 0x8(SP)			
  0x40bafc		488b442448		MOVQ 0x48(SP), AX			
  0x40bb01		4889442410		MOVQ AX, 0x10(SP)			
  0x40bb06		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x40bb0f		e8fc6affff		CALL runtime.cgoCheckMemmove(SB)	
  0x40bb14		ebc1			JMP 0x40bad7				
		bulkBarrierPreWrite(uintptr(dst), uintptr(src), typ.size)
  0x40bb16		488b08			MOVQ 0(AX), CX				
  0x40bb19		48894c2410		MOVQ CX, 0x10(SP)			
  0x40bb1e		488b4c2440		MOVQ 0x40(SP), CX			
  0x40bb23		48890c24		MOVQ CX, 0(SP)				
  0x40bb27		488b4c2448		MOVQ 0x48(SP), CX			
  0x40bb2c		48894c2408		MOVQ CX, 0x8(SP)			
  0x40bb31		e8fa0b0000		CALL runtime.bulkBarrierPreWrite(SB)	
  0x40bb36		488b442438		MOVQ 0x38(SP), AX			
  0x40bb3b		e96cffffff		JMP 0x40baac				

TEXT runtime.reflectcallmove(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func reflectcallmove(typ *_type, dst, src unsafe.Pointer, size uintptr) {
  0x40bb40		4883ec20		SUBQ $0x20, SP		
  0x40bb44		48896c2418		MOVQ BP, 0x18(SP)	
  0x40bb49		488d6c2418		LEAQ 0x18(SP), BP	
	if writeBarrier.needed && typ != nil && typ.kind&kindNoPointers == 0 && size >= sys.PtrSize {
  0x40bb4e		0fb605bf7e0b00		MOVZX runtime.writeBarrier+4(SB), AX	
  0x40bb55		84c0			TESTL AL, AL				
  0x40bb57		7476			JE 0x40bbcf				
  0x40bb59		488b442428		MOVQ 0x28(SP), AX			
  0x40bb5e		4885c0			TESTQ AX, AX				
  0x40bb61		7465			JE 0x40bbc8				
  0x40bb63		0fb64017		MOVZX 0x17(AX), AX			
  0x40bb67		a880			TESTL $0x80, AL				
  0x40bb69		7556			JNE 0x40bbc1				
  0x40bb6b		488b442440		MOVQ 0x40(SP), AX			
  0x40bb70		4883f808		CMPQ $0x8, AX				
  0x40bb74		7327			JAE 0x40bb9d				
  0x40bb76		488b4c2430		MOVQ 0x30(SP), CX			
	memmove(dst, src, size)
  0x40bb7b		48890c24		MOVQ CX, 0(SP)			
  0x40bb7f		488b4c2438		MOVQ 0x38(SP), CX		
  0x40bb84		48894c2408		MOVQ CX, 0x8(SP)		
  0x40bb89		4889442410		MOVQ AX, 0x10(SP)		
  0x40bb8e		e86db50300		CALL runtime.memmove(SB)	
}
  0x40bb93		488b6c2418		MOVQ 0x18(SP), BP	
  0x40bb98		4883c420		ADDQ $0x20, SP		
  0x40bb9c		c3			RET			
  0x40bb9d		488b4c2430		MOVQ 0x30(SP), CX	
		bulkBarrierPreWrite(uintptr(dst), uintptr(src), size)
  0x40bba2		48890c24		MOVQ CX, 0(SP)				
  0x40bba6		488b4c2438		MOVQ 0x38(SP), CX			
  0x40bbab		48894c2408		MOVQ CX, 0x8(SP)			
  0x40bbb0		4889442410		MOVQ AX, 0x10(SP)			
  0x40bbb5		e8760b0000		CALL runtime.bulkBarrierPreWrite(SB)	
  0x40bbba		488b442440		MOVQ 0x40(SP), AX			
  0x40bbbf		ebb5			JMP 0x40bb76				
  0x40bbc1		488b442440		MOVQ 0x40(SP), AX			
	if writeBarrier.needed && typ != nil && typ.kind&kindNoPointers == 0 && size >= sys.PtrSize {
  0x40bbc6		ebae			JMP 0x40bb76		
  0x40bbc8		488b442440		MOVQ 0x40(SP), AX	
  0x40bbcd		eba7			JMP 0x40bb76		
  0x40bbcf		488b442440		MOVQ 0x40(SP), AX	
  0x40bbd4		eba0			JMP 0x40bb76		

TEXT runtime.typedslicecopy(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func typedslicecopy(typ *_type, dst, src slice) int {
  0x40bbe0		4883ec58		SUBQ $0x58, SP		
  0x40bbe4		48896c2450		MOVQ BP, 0x50(SP)	
  0x40bbe9		488d6c2450		LEAQ 0x50(SP), BP	
  0x40bbee		488b442470		MOVQ 0x70(SP), AX	
  0x40bbf3		488b8c2488000000	MOVQ 0x88(SP), CX	
	if n > src.len {
  0x40bbfb		4839c8			CMPQ CX, AX		
  0x40bbfe		0f8e01010000		JLE 0x40bd05		
  0x40bc04		4889ca			MOVQ CX, DX		
	if n == 0 {
  0x40bc07		4885c9			TESTQ CX, CX		
  0x40bc0a		0f84df000000		JE 0x40bcef		
  0x40bc10		48894c2448		MOVQ CX, 0x48(SP)	
	if writeBarrier.cgo {
  0x40bc15		0fb61df97d0b00		MOVZX runtime.writeBarrier+5(SB), BX	
  0x40bc1c		84db			TESTL BL, BL				
  0x40bc1e		757a			JNE 0x40bc9a				
  0x40bc20		488b442460		MOVQ 0x60(SP), AX			
	size := uintptr(n) * typ.size
  0x40bc25		488b00			MOVQ 0(AX), AX		
  0x40bc28		480fafc1		IMULQ CX, AX		
	if writeBarrier.needed {
  0x40bc2c		0fb615e17d0b00		MOVZX runtime.writeBarrier+4(SB), DX	
  0x40bc33		84d2			TESTL DL, DL				
  0x40bc35		7537			JNE 0x40bc6e				
  0x40bc37		488b4c2468		MOVQ 0x68(SP), CX			
	memmove(dstp, srcp, size)
  0x40bc3c		48890c24		MOVQ CX, 0(SP)			
  0x40bc40		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x40bc48		48894c2408		MOVQ CX, 0x8(SP)		
  0x40bc4d		4889442410		MOVQ AX, 0x10(SP)		
  0x40bc52		e8a9b40300		CALL runtime.memmove(SB)	
	return n
  0x40bc57		488b442448		MOVQ 0x48(SP), AX	
  0x40bc5c		4889842498000000	MOVQ AX, 0x98(SP)	
  0x40bc64		488b6c2450		MOVQ 0x50(SP), BP	
  0x40bc69		4883c458		ADDQ $0x58, SP		
  0x40bc6d		c3			RET			
  0x40bc6e		4889442440		MOVQ AX, 0x40(SP)	
  0x40bc73		488b4c2468		MOVQ 0x68(SP), CX	
		bulkBarrierPreWrite(uintptr(dstp), uintptr(srcp), size)
  0x40bc78		48890c24		MOVQ CX, 0(SP)				
  0x40bc7c		488b8c2480000000	MOVQ 0x80(SP), CX			
  0x40bc84		48894c2408		MOVQ CX, 0x8(SP)			
  0x40bc89		4889442410		MOVQ AX, 0x10(SP)			
  0x40bc8e		e89d0a0000		CALL runtime.bulkBarrierPreWrite(SB)	
  0x40bc93		488b442440		MOVQ 0x40(SP), AX			
  0x40bc98		eb9d			JMP 0x40bc37				
  0x40bc9a		488b5c2460		MOVQ 0x60(SP), BX			
		cgoCheckSliceCopy(typ, dst, src, n)
  0x40bc9f		48891c24		MOVQ BX, 0(SP)				
  0x40bca3		488b742468		MOVQ 0x68(SP), SI			
  0x40bca8		4889742408		MOVQ SI, 0x8(SP)			
  0x40bcad		4889442410		MOVQ AX, 0x10(SP)			
  0x40bcb2		488b442478		MOVQ 0x78(SP), AX			
  0x40bcb7		4889442418		MOVQ AX, 0x18(SP)			
  0x40bcbc		488b842480000000	MOVQ 0x80(SP), AX			
  0x40bcc4		4889442420		MOVQ AX, 0x20(SP)			
  0x40bcc9		4889542428		MOVQ DX, 0x28(SP)			
  0x40bcce		488b942490000000	MOVQ 0x90(SP), DX			
  0x40bcd6		4889542430		MOVQ DX, 0x30(SP)			
  0x40bcdb		48894c2438		MOVQ CX, 0x38(SP)			
  0x40bce0		e8cb69ffff		CALL runtime.cgoCheckSliceCopy(SB)	
  0x40bce5		488b4c2448		MOVQ 0x48(SP), CX			
  0x40bcea		e931ffffff		JMP 0x40bc20				
		return 0
  0x40bcef		48c784249800000000000000	MOVQ $0x0, 0x98(SP)	
  0x40bcfb		488b6c2450			MOVQ 0x50(SP), BP	
  0x40bd00		4883c458			ADDQ $0x58, SP		
  0x40bd04		c3				RET			
  0x40bd05		4889ca				MOVQ CX, DX		
  0x40bd08		4889c1				MOVQ AX, CX		
	if n > src.len {
  0x40bd0b		e9f7feffff		JMP 0x40bc07		

TEXT runtime.typedmemclr(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func typedmemclr(typ *_type, ptr unsafe.Pointer) {
  0x40bd10		4883ec20		SUBQ $0x20, SP		
  0x40bd14		48896c2418		MOVQ BP, 0x18(SP)	
  0x40bd19		488d6c2418		LEAQ 0x18(SP), BP	
  0x40bd1e		488b442428		MOVQ 0x28(SP), AX	
	if typ.kind&kindNoPointers == 0 {
  0x40bd23		0fb64817		MOVZX 0x17(AX), CX	
  0x40bd27		f6c180			TESTL $0x80, CL		
  0x40bd2a		7420			JE 0x40bd4c		
	memclrNoHeapPointers(ptr, typ.size)
  0x40bd2c		488b00			MOVQ 0(AX), AX				
  0x40bd2f		4889442408		MOVQ AX, 0x8(SP)			
  0x40bd34		488b442430		MOVQ 0x30(SP), AX			
  0x40bd39		48890424		MOVQ AX, 0(SP)				
  0x40bd3d		e82eb10300		CALL runtime.memclrNoHeapPointers(SB)	
}
  0x40bd42		488b6c2418		MOVQ 0x18(SP), BP	
  0x40bd47		4883c420		ADDQ $0x20, SP		
  0x40bd4b		c3			RET			
		bulkBarrierPreWrite(uintptr(ptr), 0, typ.size)
  0x40bd4c		488b08			MOVQ 0(AX), CX				
  0x40bd4f		48894c2410		MOVQ CX, 0x10(SP)			
  0x40bd54		488b4c2430		MOVQ 0x30(SP), CX			
  0x40bd59		48890c24		MOVQ CX, 0(SP)				
  0x40bd5d		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x40bd66		e8c5090000		CALL runtime.bulkBarrierPreWrite(SB)	
  0x40bd6b		488b442428		MOVQ 0x28(SP), AX			
  0x40bd70		ebba			JMP 0x40bd2c				

TEXT runtime.memclrHasPointers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
func memclrHasPointers(ptr unsafe.Pointer, n uintptr) {
  0x40bd80		4883ec20		SUBQ $0x20, SP		
  0x40bd84		48896c2418		MOVQ BP, 0x18(SP)	
  0x40bd89		488d6c2418		LEAQ 0x18(SP), BP	
  0x40bd8e		488b442428		MOVQ 0x28(SP), AX	
	bulkBarrierPreWrite(uintptr(ptr), 0, n)
  0x40bd93		48890424		MOVQ AX, 0(SP)		
  0x40bd97		48c744240800000000	MOVQ $0x0, 0x8(SP)	
func memclrHasPointers(ptr unsafe.Pointer, n uintptr) {
  0x40bda0		488b442430		MOVQ 0x30(SP), AX	
	bulkBarrierPreWrite(uintptr(ptr), 0, n)
  0x40bda5		4889442410		MOVQ AX, 0x10(SP)			
  0x40bdaa		e881090000		CALL runtime.bulkBarrierPreWrite(SB)	
  0x40bdaf		488b442428		MOVQ 0x28(SP), AX			
	memclrNoHeapPointers(ptr, n)
  0x40bdb4		48890424		MOVQ AX, 0(SP)				
  0x40bdb8		488b442430		MOVQ 0x30(SP), AX			
  0x40bdbd		4889442408		MOVQ AX, 0x8(SP)			
  0x40bdc2		e8a9b00300		CALL runtime.memclrNoHeapPointers(SB)	
}
  0x40bdc7		488b6c2418		MOVQ 0x18(SP), BP	
  0x40bdcc		4883c420		ADDQ $0x20, SP		
  0x40bdd0		c3			RET			

TEXT runtime.(*mheap).mapBits(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func (h *mheap) mapBits(arena_used uintptr) {
  0x40bde0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40bde9		483b6110		CMPQ 0x10(CX), SP	
  0x40bded		0f86b1000000		JBE 0x40bea4		
  0x40bdf3		4883ec30		SUBQ $0x30, SP		
  0x40bdf7		48896c2428		MOVQ BP, 0x28(SP)	
  0x40bdfc		488d6c2428		LEAQ 0x28(SP), BP	
  0x40be01		488b442438		MOVQ 0x38(SP), AX	
	if h.bitmap_mapped >= n {
  0x40be06		8400			TESTB AL, 0(AX)		
func (h *mheap) mapBits(arena_used uintptr) {
  0x40be08		488b4c2440		MOVQ 0x40(SP), CX	
	n := (arena_used - mheap_.arena_start) / heapBitmapScale
  0x40be0d		482b0db4170a00		SUBQ runtime.mheap_+4904(SB), CX	
  0x40be14		48c1e905		SHRQ $0x5, CX				
	n = round(n, physPageSize)
  0x40be18		488b15817b0b00		MOVQ runtime.physPageSize(SB), DX	
	if h.bitmap_mapped >= n {
  0x40be1f		488b9820130000		MOVQ 0x1320(AX), BX	
	return (n + a - 1) &^ (a - 1)
  0x40be26		4881c1ff1f0000		ADDQ $0x1fff, CX	
  0x40be2d		4881e100e0ffff		ANDQ $-0x2000, CX	
  0x40be34		488d4c11ff		LEAQ -0x1(CX)(DX*1), CX	
  0x40be39		48ffca			DECQ DX			
  0x40be3c		48f7d2			NOTQ DX			
  0x40be3f		4821ca			ANDQ CX, DX		
	if h.bitmap_mapped >= n {
  0x40be42		4839d3			CMPQ DX, BX		
  0x40be45		720a			JB 0x40be51		
		return
  0x40be47		488b6c2428		MOVQ 0x28(SP), BP	
  0x40be4c		4883c430		ADDQ $0x30, SP		
  0x40be50		c3			RET			
  0x40be51		4889542420		MOVQ DX, 0x20(SP)	
	sysMap(unsafe.Pointer(h.bitmap-n), n-h.bitmap_mapped, h.arena_reserved, &memstats.gc_sys)
  0x40be56		488b8818130000		MOVQ 0x1318(AX), CX			
  0x40be5d		4829d1			SUBQ DX, CX				
  0x40be60		0fb6b048130000		MOVZX 0x1348(AX), SI			
  0x40be67		4088742410		MOVB SI, 0x10(SP)			
  0x40be6c		48890c24		MOVQ CX, 0(SP)				
  0x40be70		4829da			SUBQ BX, DX				
  0x40be73		4889542408		MOVQ DX, 0x8(SP)			
  0x40be78		488d1519890b00		LEAQ runtime.memstats+152(SB), DX	
  0x40be7f		4889542418		MOVQ DX, 0x18(SP)			
  0x40be84		e8b7360000		CALL runtime.sysMap(SB)			
  0x40be89		488b442420		MOVQ 0x20(SP), AX			
  0x40be8e		488b4c2438		MOVQ 0x38(SP), CX			
	h.bitmap_mapped = n
  0x40be93		48898120130000		MOVQ AX, 0x1320(CX)	
}
  0x40be9a		488b6c2428		MOVQ 0x28(SP), BP	
  0x40be9f		4883c430		ADDQ $0x30, SP		
  0x40bea3		c3			RET			
func (h *mheap) mapBits(arena_used uintptr) {
  0x40bea4		e8c7860300		CALL runtime.morestack_noctxt(SB)	
  0x40bea9		e932ffffff		JMP runtime.(*mheap).mapBits(SB)	

TEXT runtime.(*mspan).refillAllocCache(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func (s *mspan) refillAllocCache(whichByte uintptr) {
  0x40beb0		488b442408		MOVQ 0x8(SP), AX	
	bytes := (*[8]uint8)(unsafe.Pointer(s.allocBits.bytep(whichByte)))
  0x40beb5		488b4848		MOVQ 0x48(AX), CX	
  0x40beb9		488b542410		MOVQ 0x10(SP), DX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40bebe		488d1c11		LEAQ 0(CX)(DX*1), BX	
	aCache |= uint64(bytes[0])
  0x40bec2		8403			TESTB AL, 0(BX)		
	aCache |= uint64(bytes[7]) << (7 * 8)
  0x40bec4		488b0c11		MOVQ 0(CX)(DX*1), CX	
	s.allocCache = ^aCache
  0x40bec8		48f7d1			NOTQ CX			
  0x40becb		48894840		MOVQ CX, 0x40(AX)	
}
  0x40becf		c3			RET			

TEXT runtime.(*mspan).nextFreeIndex(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func (s *mspan) nextFreeIndex() uintptr {
  0x40bed0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40bed9		483b6110		CMPQ 0x10(CX), SP	
  0x40bedd		0f8657010000		JBE 0x40c03a		
  0x40bee3		4883ec30		SUBQ $0x30, SP		
  0x40bee7		48896c2428		MOVQ BP, 0x28(SP)	
  0x40beec		488d6c2428		LEAQ 0x28(SP), BP	
  0x40bef1		488b442438		MOVQ 0x38(SP), AX	
	sfreeindex := s.freeindex
  0x40bef6		488b5030		MOVQ 0x30(AX), DX	
	snelems := s.nelems
  0x40befa		488b5838		MOVQ 0x38(AX), BX	
	if sfreeindex == snelems {
  0x40befe		4839d3			CMPQ DX, BX		
  0x40bf01		0f8409010000		JE 0x40c010		
	if sfreeindex > snelems {
  0x40bf07		4839da			CMPQ BX, DX		
  0x40bf0a		0f870f010000		JA 0x40c01f		
  0x40bf10		48895c2410		MOVQ BX, 0x10(SP)	
	aCache := s.allocCache
  0x40bf15		488b7040		MOVQ 0x40(AX), SI	
	bitIndex := sys.Ctz64(aCache)
  0x40bf19		480fbcf6		BSFQ SI, SI		
  0x40bf1d		bf40000000		MOVL $0x40, DI		
  0x40bf22		480f44f7		CMOVE DI, SI		
	for bitIndex == 64 {
  0x40bf26		eb3a			JMP 0x40bf62		
  0x40bf28		48894c2418		MOVQ CX, 0x18(SP)	
		s.refillAllocCache(whichByte)
  0x40bf2d		48890424		MOVQ AX, 0(SP)		
		whichByte := sfreeindex / 8
  0x40bf31		48c1e903		SHRQ $0x3, CX		
		s.refillAllocCache(whichByte)
  0x40bf35		48894c2408		MOVQ CX, 0x8(SP)				
  0x40bf3a		e871ffffff		CALL runtime.(*mspan).refillAllocCache(SB)	
  0x40bf3f		488b442438		MOVQ 0x38(SP), AX				
		aCache = s.allocCache
  0x40bf44		488b4840		MOVQ 0x40(AX), CX	
		bitIndex = sys.Ctz64(aCache)
  0x40bf48		480fbcc9		BSFQ CX, CX		
  0x40bf4c		bf40000000		MOVL $0x40, DI		
  0x40bf51		480f44cf		CMOVE DI, CX		
  0x40bf55		488b5c2410		MOVQ 0x10(SP), BX	
  0x40bf5a		4889ce			MOVQ CX, SI		
  0x40bf5d		488b542418		MOVQ 0x18(SP), DX	
	for bitIndex == 64 {
  0x40bf62		4883fe40		CMPQ $0x40, SI		
  0x40bf66		7520			JNE 0x40bf88		
		sfreeindex = (sfreeindex + 64) &^ (64 - 1)
  0x40bf68		488d4a40		LEAQ 0x40(DX), CX	
  0x40bf6c		4883e1c0		ANDQ $-0x40, CX		
		if sfreeindex >= snelems {
  0x40bf70		4839d9			CMPQ BX, CX		
  0x40bf73		72b3			JB 0x40bf28		
			s.freeindex = snelems
  0x40bf75		48895830		MOVQ BX, 0x30(AX)	
			return snelems
  0x40bf79		48895c2440		MOVQ BX, 0x40(SP)	
  0x40bf7e		488b6c2428		MOVQ 0x28(SP), BP	
  0x40bf83		4883c430		ADDQ $0x30, SP		
  0x40bf87		c3			RET			
	result := sfreeindex + uintptr(bitIndex)
  0x40bf88		488d3c32		LEAQ 0(DX)(SI*1), DI	
	if result >= snelems {
  0x40bf8c		4839df			CMPQ BX, DI		
  0x40bf8f		736c			JAE 0x40bffd		
	s.allocCache >>= uint(bitIndex + 1)
  0x40bf91		4c8b4040		MOVQ 0x40(AX), R8	
  0x40bf95		488d4e01		LEAQ 0x1(SI), CX	
  0x40bf99		49d3e8			SHRQ CL, R8		
  0x40bf9c		4883f940		CMPQ $0x40, CX		
  0x40bfa0		4d19c9			SBBQ R9, R9		
  0x40bfa3		4d21c8			ANDQ R9, R8		
  0x40bfa6		4c894040		MOVQ R8, 0x40(AX)	
	sfreeindex = result + 1
  0x40bfaa		488d543201		LEAQ 0x1(DX)(SI*1), DX	
	if sfreeindex%64 == 0 && sfreeindex != snelems {
  0x40bfaf		48f7c23f000000		TESTQ $0x3f, DX		
  0x40bfb6		7505			JNE 0x40bfbd		
  0x40bfb8		4839da			CMPQ BX, DX		
  0x40bfbb		7513			JNE 0x40bfd0		
	s.freeindex = sfreeindex
  0x40bfbd		48895030		MOVQ DX, 0x30(AX)	
	return result
  0x40bfc1		48897c2440		MOVQ DI, 0x40(SP)	
  0x40bfc6		488b6c2428		MOVQ 0x28(SP), BP	
  0x40bfcb		4883c430		ADDQ $0x30, SP		
  0x40bfcf		c3			RET			
  0x40bfd0		48897c2420		MOVQ DI, 0x20(SP)	
  0x40bfd5		4889542418		MOVQ DX, 0x18(SP)	
		s.refillAllocCache(whichByte)
  0x40bfda		48890424		MOVQ AX, 0(SP)		
		whichByte := sfreeindex / 8
  0x40bfde		48c1ea03		SHRQ $0x3, DX		
		s.refillAllocCache(whichByte)
  0x40bfe2		4889542408		MOVQ DX, 0x8(SP)				
  0x40bfe7		e8c4feffff		CALL runtime.(*mspan).refillAllocCache(SB)	
  0x40bfec		488b442438		MOVQ 0x38(SP), AX				
  0x40bff1		488b542418		MOVQ 0x18(SP), DX				
  0x40bff6		488b7c2420		MOVQ 0x20(SP), DI				
  0x40bffb		ebc0			JMP 0x40bfbd					
		s.freeindex = snelems
  0x40bffd		48895830		MOVQ BX, 0x30(AX)	
		return snelems
  0x40c001		48895c2440		MOVQ BX, 0x40(SP)	
  0x40c006		488b6c2428		MOVQ 0x28(SP), BP	
  0x40c00b		4883c430		ADDQ $0x30, SP		
  0x40c00f		c3			RET			
		return sfreeindex
  0x40c010		4889542440		MOVQ DX, 0x40(SP)	
  0x40c015		488b6c2428		MOVQ 0x28(SP), BP	
  0x40c01a		4883c430		ADDQ $0x30, SP		
  0x40c01e		c3			RET			
		throw("s.freeindex > s.nelems")
  0x40c01f		488d05eaf40500		LEAQ 0x5f4ea(IP), AX	
  0x40c026		48890424		MOVQ AX, 0(SP)		
  0x40c02a		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x40c033		e898510100		CALL runtime.throw(SB)	
  0x40c038		0f0b			UD2			
func (s *mspan) nextFreeIndex() uintptr {
  0x40c03a		e831850300		CALL runtime.morestack_noctxt(SB)	
  0x40c03f		e98cfeffff		JMP runtime.(*mspan).nextFreeIndex(SB)	

TEXT runtime.markBitsForAddr(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func markBitsForAddr(p uintptr) markBits {
  0x40c050		4883ec08		SUBQ $0x8, SP		
  0x40c054		48892c24		MOVQ BP, 0(SP)		
  0x40c058		488d2c24		LEAQ 0(SP), BP		
  0x40c05c		488b442410		MOVQ 0x10(SP), AX	
	if p == 0 || p < mheap_.arena_start || p >= mheap_.arena_used {
  0x40c061		4885c0			TESTQ AX, AX		
  0x40c064		0f8598000000		JNE 0x40c102		
  0x40c06a		31c9			XORL CX, CX		
	return s.startAddr
  0x40c06c		488b5118		MOVQ 0x18(CX), DX	
	byteOffset := p - s.base()
  0x40c070		4829d0			SUBQ DX, AX		
	if byteOffset == 0 {
  0x40c073		4885c0			TESTQ AX, AX		
  0x40c076		7532			JNE 0x40c0aa		
  0x40c078		31c0			XORL AX, AX		
	objIndex := s.objIndex(p)
  0x40c07a		4889c2			MOVQ AX, DX		
	return b.bytep(n / 8), 1 << (n % 8)
  0x40c07d		48c1e803		SHRQ $0x3, AX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40c081		48034150		ADDQ 0x50(CX), AX	
	return s.markBitsForIndex(objIndex)
  0x40c085		4889442418		MOVQ AX, 0x18(SP)	
  0x40c08a		4889d1			MOVQ DX, CX		
	return b.bytep(n / 8), 1 << (n % 8)
  0x40c08d		4883e107		ANDQ $0x7, CX		
  0x40c091		b801000000		MOVL $0x1, AX		
  0x40c096		d3e0			SHLL CL, AX		
	return s.markBitsForIndex(objIndex)
  0x40c098		88442420		MOVB AL, 0x20(SP)	
  0x40c09c		4889542428		MOVQ DX, 0x28(SP)	
  0x40c0a1		488b2c24		MOVQ 0(SP), BP		
  0x40c0a5		4883c408		ADDQ $0x8, SP		
  0x40c0a9		c3			RET			
	if s.baseMask != 0 {
  0x40c0aa		0fb7515e		MOVZX 0x5e(CX), DX	
  0x40c0ae		6685d2			TESTW DX, DX		
  0x40c0b1		741a			JE 0x40c0cd		
		return byteOffset >> s.divShift
  0x40c0b3		0fb65166		MOVZX 0x66(CX), DX	
  0x40c0b7		4889cb			MOVQ CX, BX		
  0x40c0ba		89d1			MOVL DX, CX		
  0x40c0bc		48d3e8			SHRQ CL, AX		
  0x40c0bf		80f940			CMPL $0x40, CL		
  0x40c0c2		4819d2			SBBQ DX, DX		
  0x40c0c5		4821d0			ANDQ DX, AX		
  0x40c0c8		4889d9			MOVQ BX, CX		
	objIndex := s.objIndex(p)
  0x40c0cb		ebad			JMP 0x40c07a		
	return uintptr(((uint64(byteOffset) >> s.divShift) * uint64(s.divMul)) >> s.divShift2)
  0x40c0cd		0fb65166		MOVZX 0x66(CX), DX	
  0x40c0d1		4889cb			MOVQ CX, BX		
  0x40c0d4		89d1			MOVL DX, CX		
  0x40c0d6		48d3e8			SHRQ CL, AX		
  0x40c0d9		80f940			CMPL $0x40, CL		
  0x40c0dc		4819d2			SBBQ DX, DX		
  0x40c0df		4821d0			ANDQ DX, AX		
  0x40c0e2		0fb7535c		MOVZX 0x5c(BX), DX	
  0x40c0e6		480fafc2		IMULQ DX, AX		
  0x40c0ea		0fb64b67		MOVZX 0x67(BX), CX	
  0x40c0ee		48d3e8			SHRQ CL, AX		
  0x40c0f1		80f940			CMPL $0x40, CL		
  0x40c0f4		4819d2			SBBQ DX, DX		
  0x40c0f7		4821d0			ANDQ DX, AX		
  0x40c0fa		4889d9			MOVQ BX, CX		
	objIndex := s.objIndex(p)
  0x40c0fd		e978ffffff		JMP 0x40c07a		
	if p == 0 || p < mheap_.arena_start || p >= mheap_.arena_used {
  0x40c102		488b15bf140a00		MOVQ runtime.mheap_+4904(SB), DX	
  0x40c109		4839d0			CMPQ DX, AX				
  0x40c10c		0f8258ffffff		JB 0x40c06a				
  0x40c112		488b1db7140a00		MOVQ runtime.mheap_+4912(SB), BX	
  0x40c119		4839d8			CMPQ BX, AX				
  0x40c11c		0f8348ffffff		JAE 0x40c06a				
	return mheap_.spans[(p-mheap_.arena_start)>>_PageShift]
  0x40c122		488b1dc7110a00		MOVQ runtime.mheap_+4176(SB), BX	
  0x40c129		488b35b8110a00		MOVQ runtime.mheap_+4168(SB), SI	
  0x40c130		4889c7			MOVQ AX, DI				
  0x40c133		4829d0			SUBQ DX, AX				
  0x40c136		48c1e80d		SHRQ $0xd, AX				
  0x40c13a		4839d8			CMPQ BX, AX				
  0x40c13d		730c			JAE 0x40c14b				
  0x40c13f		488b0cc6		MOVQ 0(SI)(AX*8), CX			
  0x40c143		4889f8			MOVQ DI, AX				
	s := spanOf(p)
  0x40c146		e921ffffff		JMP 0x40c06c		
	return mheap_.spans[(p-mheap_.arena_start)>>_PageShift]
  0x40c14b		e8f0380100		CALL runtime.panicindex(SB)	
  0x40c150		0f0b			UD2				

TEXT runtime.heapBitsForSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func heapBitsForSpan(base uintptr) (hbits heapBits) {
  0x40c160		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40c169		483b6110		CMPQ 0x10(CX), SP	
  0x40c16d		0f8621010000		JBE 0x40c294		
  0x40c173		4883ec28		SUBQ $0x28, SP		
  0x40c177		48896c2420		MOVQ BP, 0x20(SP)	
  0x40c17c		488d6c2420		LEAQ 0x20(SP), BP	
	if base < mheap_.arena_start || base >= mheap_.arena_used {
  0x40c181		488b0540140a00		MOVQ runtime.mheap_+4904(SB), AX	
  0x40c188		4889442418		MOVQ AX, 0x18(SP)			
  0x40c18d		488b4c2430		MOVQ 0x30(SP), CX			
  0x40c192		4839c1			CMPQ AX, CX				
  0x40c195		723e			JB 0x40c1d5				
  0x40c197		488b1532140a00		MOVQ runtime.mheap_+4912(SB), DX	
  0x40c19e		4839d1			CMPQ DX, CX				
  0x40c1a1		7332			JAE 0x40c1d5				
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x40c1a3		4829c1			SUBQ AX, CX		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x40c1a6		488b050b140a00		MOVQ runtime.mheap_+4888(SB), AX	
  0x40c1ad		4889ca			MOVQ CX, DX				
  0x40c1b0		48c1e905		SHRQ $0x5, CX				
  0x40c1b4		4829c8			SUBQ CX, AX				
  0x40c1b7		48ffc8			DECQ AX					
	return heapBitsForAddr(base)
  0x40c1ba		4889442438		MOVQ AX, 0x38(SP)	
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x40c1bf		48c1ea03		SHRQ $0x3, DX		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x40c1c3		4883e203		ANDQ $0x3, DX		
	return heapBitsForAddr(base)
  0x40c1c7		89542440		MOVL DX, 0x40(SP)	
  0x40c1cb		488b6c2420		MOVQ 0x20(SP), BP	
  0x40c1d0		4883c428		ADDQ $0x28, SP		
  0x40c1d4		c3			RET			
		print("runtime: base ", hex(base), " not in range [", hex(mheap_.arena_start), ",", hex(mheap_.arena_used), ")\n")
  0x40c1d5		488b05f4130a00		MOVQ runtime.mheap_+4912(SB), AX	
  0x40c1dc		4889442410		MOVQ AX, 0x10(SP)			
  0x40c1e1		e81a590100		CALL runtime.printlock(SB)		
  0x40c1e6		488d05d1e60500		LEAQ 0x5e6d1(IP), AX			
  0x40c1ed		48890424		MOVQ AX, 0(SP)				
  0x40c1f1		48c74424080e000000	MOVQ $0xe, 0x8(SP)			
  0x40c1fa		e841620100		CALL runtime.printstring(SB)		
  0x40c1ff		488b442430		MOVQ 0x30(SP), AX			
  0x40c204		48890424		MOVQ AX, 0(SP)				
  0x40c208		e8e3600100		CALL runtime.printhex(SB)		
  0x40c20d		488d051be70500		LEAQ 0x5e71b(IP), AX			
  0x40c214		48890424		MOVQ AX, 0(SP)				
  0x40c218		48c74424080f000000	MOVQ $0xf, 0x8(SP)			
  0x40c221		e81a620100		CALL runtime.printstring(SB)		
  0x40c226		488b442418		MOVQ 0x18(SP), AX			
  0x40c22b		48890424		MOVQ AX, 0(SP)				
  0x40c22f		e8bc600100		CALL runtime.printhex(SB)		
  0x40c234		488d0519da0500		LEAQ 0x5da19(IP), AX			
  0x40c23b		48890424		MOVQ AX, 0(SP)				
  0x40c23f		48c744240801000000	MOVQ $0x1, 0x8(SP)			
  0x40c248		e8f3610100		CALL runtime.printstring(SB)		
  0x40c24d		488b442410		MOVQ 0x10(SP), AX			
  0x40c252		48890424		MOVQ AX, 0(SP)				
  0x40c256		e895600100		CALL runtime.printhex(SB)		
  0x40c25b		488d0508da0500		LEAQ 0x5da08(IP), AX			
  0x40c262		48890424		MOVQ AX, 0(SP)				
  0x40c266		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x40c26f		e8cc610100		CALL runtime.printstring(SB)		
  0x40c274		e807590100		CALL runtime.printunlock(SB)		
		throw("heapBitsForSpan: base out of range")
  0x40c279		488d059c090600		LEAQ 0x6099c(IP), AX	
  0x40c280		48890424		MOVQ AX, 0(SP)		
  0x40c284		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x40c28d		e83e4f0100		CALL runtime.throw(SB)	
  0x40c292		0f0b			UD2			
func heapBitsForSpan(base uintptr) (hbits heapBits) {
  0x40c294		e8d7820300		CALL runtime.morestack_noctxt(SB)	
  0x40c299		e9c2feffff		JMP runtime.heapBitsForSpan(SB)		

TEXT runtime.heapBitsForObject(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func heapBitsForObject(p, refBase, refOff uintptr) (base uintptr, hbits heapBits, s *mspan, objIndex uintptr) {
  0x40c2a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40c2a9		483b6110		CMPQ 0x10(CX), SP	
  0x40c2ad		0f8669040000		JBE 0x40c71c		
  0x40c2b3		4883ec50		SUBQ $0x50, SP		
  0x40c2b7		48896c2448		MOVQ BP, 0x48(SP)	
  0x40c2bc		488d6c2448		LEAQ 0x48(SP), BP	
	arenaStart := mheap_.arena_start
  0x40c2c1		488b0500130a00		MOVQ runtime.mheap_+4904(SB), AX	
  0x40c2c8		488b542458		MOVQ 0x58(SP), DX			
	if p < arenaStart || p >= mheap_.arena_used {
  0x40c2cd		4839c2			CMPQ AX, DX		
  0x40c2d0		733f			JAE 0x40c311		
		return
  0x40c2d2		48c744247000000000		MOVQ $0x0, 0x70(SP)	
  0x40c2db		48c744247800000000		MOVQ $0x0, 0x78(SP)	
  0x40c2e4		c784248000000000000000		MOVL $0x0, 0x80(SP)	
  0x40c2ef		48c784248800000000000000	MOVQ $0x0, 0x88(SP)	
  0x40c2fb		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x40c307		488b6c2448			MOVQ 0x48(SP), BP	
  0x40c30c		4883c450			ADDQ $0x50, SP		
  0x40c310		c3				RET			
	if p < arenaStart || p >= mheap_.arena_used {
  0x40c311		488b1db8120a00		MOVQ runtime.mheap_+4912(SB), BX	
  0x40c318		4839da			CMPQ BX, DX				
  0x40c31b		73b5			JAE 0x40c2d2				
  0x40c31d		4889d3			MOVQ DX, BX				
	off := p - arenaStart
  0x40c320		4829c2			SUBQ AX, DX		
	idx := off >> _PageShift
  0x40c323		48c1ea0d		SHRQ $0xd, DX		
	s = mheap_.spans[idx]
  0x40c327		488b35c20f0a00		MOVQ runtime.mheap_+4176(SB), SI	
  0x40c32e		488b3db30f0a00		MOVQ runtime.mheap_+4168(SB), DI	
  0x40c335		4839f2			CMPQ SI, DX				
  0x40c338		0f83d7030000		JAE 0x40c715				
  0x40c33e		488b34d7		MOVQ 0(DI)(DX*8), SI			
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x40c342		4885f6			TESTQ SI, SI		
  0x40c345		7410			JE 0x40c357		
	return s.startAddr
  0x40c347		488b7e18		MOVQ 0x18(SI), DI	
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x40c34b		4839fb			CMPQ DI, BX		
  0x40c34e		0f83a9020000		JAE 0x40c5fd		
  0x40c354		4885f6			TESTQ SI, SI		
		if s == nil || s.state == _MSpanManual {
  0x40c357		7408			JE 0x40c361		
  0x40c359		0fb64664		MOVZX 0x64(SI), AX	
  0x40c35d		3c02			CMPL $0x2, AL		
  0x40c35f		753b			JNE 0x40c39c		
			return
  0x40c361		48c744247000000000		MOVQ $0x0, 0x70(SP)	
  0x40c36a		48c744247800000000		MOVQ $0x0, 0x78(SP)	
  0x40c373		c784248000000000000000		MOVL $0x0, 0x80(SP)	
  0x40c37e		4889b42488000000		MOVQ SI, 0x88(SP)	
  0x40c386		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x40c392		488b6c2448			MOVQ 0x48(SP), BP	
  0x40c397		4883c450			ADDQ $0x50, SP		
  0x40c39b		c3				RET			
		if debug.invalidptr != 0 {
  0x40c39c		8b0542770b00		MOVL runtime.debug+36(SB), AX	
  0x40c3a2		85c0			TESTL AX, AX			
  0x40c3a4		753b			JNE 0x40c3e1			
		return
  0x40c3a6		48c744247000000000		MOVQ $0x0, 0x70(SP)	
  0x40c3af		48c744247800000000		MOVQ $0x0, 0x78(SP)	
  0x40c3b8		c784248000000000000000		MOVL $0x0, 0x80(SP)	
  0x40c3c3		4889b42488000000		MOVQ SI, 0x88(SP)	
  0x40c3cb		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x40c3d7		488b6c2448			MOVQ 0x48(SP), BP	
  0x40c3dc		4883c450			ADDQ $0x50, SP		
  0x40c3e0		c3				RET			
  0x40c3e1		4889742440			MOVQ SI, 0x40(SP)	
  0x40c3e6		4889542438			MOVQ DX, 0x38(SP)	
			printlock()
  0x40c3eb		e810570100		CALL runtime.printlock(SB)	
			print("runtime: pointer ", hex(p))
  0x40c3f0		e80b570100		CALL runtime.printlock(SB)	
  0x40c3f5		488d05c7e80500		LEAQ 0x5e8c7(IP), AX		
  0x40c3fc		48890424		MOVQ AX, 0(SP)			
  0x40c400		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x40c409		e832600100		CALL runtime.printstring(SB)	
  0x40c40e		488b442458		MOVQ 0x58(SP), AX		
  0x40c413		48890424		MOVQ AX, 0(SP)			
  0x40c417		e8d45e0100		CALL runtime.printhex(SB)	
  0x40c41c		e85f570100		CALL runtime.printunlock(SB)	
  0x40c421		488b442440		MOVQ 0x40(SP), AX		
			if s.state != mSpanInUse {
  0x40c426		0fb64864		MOVZX 0x64(AX), CX	
  0x40c42a		80f901			CMPL $0x1, CL		
  0x40c42d		0f84a2010000		JE 0x40c5d5		
				print(" to unallocated span")
  0x40c433		e8c8560100		CALL runtime.printlock(SB)	
  0x40c438		488d05b2eb0500		LEAQ 0x5ebb2(IP), AX		
  0x40c43f		48890424		MOVQ AX, 0(SP)			
  0x40c443		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x40c44c		e8ef5f0100		CALL runtime.printstring(SB)	
  0x40c451		e82a570100		CALL runtime.printunlock(SB)	
  0x40c456		488b442440		MOVQ 0x40(SP), AX		
			print(" idx=", hex(idx), " span.base()=", hex(s.base()), " span.limit=", hex(s.limit), " span.state=", s.state, "\n")
  0x40c45b		0fb64864		MOVZX 0x64(AX), CX	
  0x40c45f		48894c2430		MOVQ CX, 0x30(SP)	
  0x40c464		488b9080000000		MOVQ 0x80(AX), DX	
  0x40c46b		4889542428		MOVQ DX, 0x28(SP)	
	return s.startAddr
  0x40c470		488b4018		MOVQ 0x18(AX), AX	
  0x40c474		4889442420		MOVQ AX, 0x20(SP)	
			print(" idx=", hex(idx), " span.base()=", hex(s.base()), " span.limit=", hex(s.limit), " span.state=", s.state, "\n")
  0x40c479		e882560100		CALL runtime.printlock(SB)	
  0x40c47e		488d05e8d80500		LEAQ 0x5d8e8(IP), AX		
  0x40c485		48890424		MOVQ AX, 0(SP)			
  0x40c489		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x40c492		e8a95f0100		CALL runtime.printstring(SB)	
  0x40c497		488b442438		MOVQ 0x38(SP), AX		
  0x40c49c		48890424		MOVQ AX, 0(SP)			
  0x40c4a0		e84b5e0100		CALL runtime.printhex(SB)	
  0x40c4a5		488d0513e20500		LEAQ 0x5e213(IP), AX		
  0x40c4ac		48890424		MOVQ AX, 0(SP)			
  0x40c4b0		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x40c4b9		e8825f0100		CALL runtime.printstring(SB)	
  0x40c4be		488b442420		MOVQ 0x20(SP), AX		
  0x40c4c3		48890424		MOVQ AX, 0(SP)			
  0x40c4c7		e8245e0100		CALL runtime.printhex(SB)	
  0x40c4cc		488d0587e00500		LEAQ 0x5e087(IP), AX		
  0x40c4d3		48890424		MOVQ AX, 0(SP)			
  0x40c4d7		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x40c4e0		e85b5f0100		CALL runtime.printstring(SB)	
  0x40c4e5		488b442428		MOVQ 0x28(SP), AX		
  0x40c4ea		48890424		MOVQ AX, 0(SP)			
  0x40c4ee		e8fd5d0100		CALL runtime.printhex(SB)	
  0x40c4f3		488d056ce00500		LEAQ 0x5e06c(IP), AX		
  0x40c4fa		48890424		MOVQ AX, 0(SP)			
  0x40c4fe		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x40c507		e8345f0100		CALL runtime.printstring(SB)	
  0x40c50c		488b442430		MOVQ 0x30(SP), AX		
  0x40c511		48890424		MOVQ AX, 0(SP)			
  0x40c515		e8565c0100		CALL runtime.printuint(SB)	
  0x40c51a		e871580100		CALL runtime.printnl(SB)	
  0x40c51f		e85c560100		CALL runtime.printunlock(SB)	
  0x40c524		488b442460		MOVQ 0x60(SP), AX		
			if refBase != 0 {
  0x40c529		4885c0			TESTQ AX, AX		
  0x40c52c		0f84b4010000		JE 0x40c6e6		
				print("runtime: found in object at *(", hex(refBase), "+", hex(refOff), ")\n")
  0x40c532		e8c9550100		CALL runtime.printlock(SB)	
  0x40c537		488d0577000600		LEAQ 0x60077(IP), AX		
  0x40c53e		48890424		MOVQ AX, 0(SP)			
  0x40c542		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x40c54b		e8f05e0100		CALL runtime.printstring(SB)	
  0x40c550		488b442460		MOVQ 0x60(SP), AX		
  0x40c555		48890424		MOVQ AX, 0(SP)			
  0x40c559		e8925d0100		CALL runtime.printhex(SB)	
  0x40c55e		488d05eed60500		LEAQ 0x5d6ee(IP), AX		
  0x40c565		48890424		MOVQ AX, 0(SP)			
  0x40c569		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x40c572		e8c95e0100		CALL runtime.printstring(SB)	
  0x40c577		488b442468		MOVQ 0x68(SP), AX		
  0x40c57c		48890424		MOVQ AX, 0(SP)			
  0x40c580		e86b5d0100		CALL runtime.printhex(SB)	
  0x40c585		488d05ded60500		LEAQ 0x5d6de(IP), AX		
  0x40c58c		48890424		MOVQ AX, 0(SP)			
  0x40c590		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x40c599		e8a25e0100		CALL runtime.printstring(SB)	
  0x40c59e		e8dd550100		CALL runtime.printunlock(SB)	
				gcDumpObject("object", refBase, refOff)
  0x40c5a3		488d059dd80500		LEAQ 0x5d89d(IP), AX		
  0x40c5aa		48890424		MOVQ AX, 0(SP)			
  0x40c5ae		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x40c5b7		488b442460		MOVQ 0x60(SP), AX		
  0x40c5bc		4889442410		MOVQ AX, 0x10(SP)		
  0x40c5c1		488b442468		MOVQ 0x68(SP), AX		
  0x40c5c6		4889442418		MOVQ AX, 0x18(SP)		
  0x40c5cb		e840aa0000		CALL runtime.gcDumpObject(SB)	
  0x40c5d0		e911010000		JMP 0x40c6e6			
				print(" to unused region of span")
  0x40c5d5		e826550100		CALL runtime.printlock(SB)	
  0x40c5da		488d0585f30500		LEAQ 0x5f385(IP), AX		
  0x40c5e1		48890424		MOVQ AX, 0(SP)			
  0x40c5e5		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x40c5ee		e84d5e0100		CALL runtime.printstring(SB)	
  0x40c5f3		e888550100		CALL runtime.printunlock(SB)	
  0x40c5f8		e959feffff		JMP 0x40c456			
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x40c5fd		4c8b8680000000		MOVQ 0x80(SI), R8	
  0x40c604		4c39c3			CMPQ R8, BX		
  0x40c607		7208			JB 0x40c611		
  0x40c609		4885f6			TESTQ SI, SI		
  0x40c60c		e946fdffff		JMP 0x40c357		
  0x40c611		440fb64664		MOVZX 0x64(SI), R8	
  0x40c616		4180f801		CMPL $0x1, R8		
  0x40c61a		7408			JE 0x40c624		
  0x40c61c		4885f6			TESTQ SI, SI		
  0x40c61f		e933fdffff		JMP 0x40c357		
	if s.baseMask != 0 {
  0x40c624		0fb7565e		MOVZX 0x5e(SI), DX	
  0x40c628		6685d2			TESTW DX, DX		
  0x40c62b		746a			JE 0x40c697		
		base = base + (p-base)&uintptr(s.baseMask)
  0x40c62d		4829fb			SUBQ DI, BX		
  0x40c630		0fb7d2			MOVZX DX, DX		
  0x40c633		4821da			ANDQ BX, DX		
  0x40c636		488d1c3a		LEAQ 0(DX)(DI*1), BX	
		objIndex = (base - s.base()) >> s.divShift
  0x40c63a		0fb64e66		MOVZX 0x66(SI), CX	
  0x40c63e		48d3ea			SHRQ CL, DX		
  0x40c641		80f940			CMPL $0x40, CL		
  0x40c644		4819ff			SBBQ DI, DI		
  0x40c647		4821fa			ANDQ DI, DX		
  0x40c64a		4889d9			MOVQ BX, CX		
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x40c64d		4829c3			SUBQ AX, BX		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x40c650		488b05610f0a00		MOVQ runtime.mheap_+4888(SB), AX	
  0x40c657		4889df			MOVQ BX, DI				
  0x40c65a		48c1eb05		SHRQ $0x5, BX				
  0x40c65e		4829d8			SUBQ BX, AX				
  0x40c661		48ffc8			DECQ AX					
	return
  0x40c664		48894c2470		MOVQ CX, 0x70(SP)	
  0x40c669		4889442478		MOVQ AX, 0x78(SP)	
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x40c66e		48c1ef03		SHRQ $0x3, DI		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x40c672		4883e703		ANDQ $0x3, DI		
	return
  0x40c676		89bc2480000000		MOVL DI, 0x80(SP)	
  0x40c67d		4889b42488000000	MOVQ SI, 0x88(SP)	
  0x40c685		4889942490000000	MOVQ DX, 0x90(SP)	
  0x40c68d		488b6c2448		MOVQ 0x48(SP), BP	
  0x40c692		4883c450		ADDQ $0x50, SP		
  0x40c696		c3			RET			
		if p-base >= s.elemsize {
  0x40c697		4829fb			SUBQ DI, BX		
  0x40c69a		488b5668		MOVQ 0x68(SI), DX	
  0x40c69e		4839d3			CMPQ DX, BX		
  0x40c6a1		723b			JB 0x40c6de		
			objIndex = uintptr(p-base) >> s.divShift * uintptr(s.divMul) >> s.divShift2
  0x40c6a3		0fb64e66		MOVZX 0x66(SI), CX	
  0x40c6a7		48d3eb			SHRQ CL, BX		
  0x40c6aa		80f940			CMPL $0x40, CL		
  0x40c6ad		4d19c0			SBBQ R8, R8		
  0x40c6b0		4c21c3			ANDQ R8, BX		
  0x40c6b3		440fb7465c		MOVZX 0x5c(SI), R8	
  0x40c6b8		4c0fafc3		IMULQ BX, R8		
  0x40c6bc		0fb64e67		MOVZX 0x67(SI), CX	
  0x40c6c0		49d3e8			SHRQ CL, R8		
  0x40c6c3		80f940			CMPL $0x40, CL		
  0x40c6c6		4819db			SBBQ BX, BX		
  0x40c6c9		4921d8			ANDQ BX, R8		
			base += objIndex * s.elemsize
  0x40c6cc		490fafd0		IMULQ R8, DX		
  0x40c6d0		4801fa			ADDQ DI, DX		
  0x40c6d3		4889d3			MOVQ DX, BX		
  0x40c6d6		4c89c2			MOVQ R8, DX		
	hbits = heapBitsForAddr(base)
  0x40c6d9		e96cffffff		JMP 0x40c64a		
  0x40c6de		4889fa			MOVQ DI, DX		
  0x40c6e1		4531c0			XORL R8, R8		
		if p-base >= s.elemsize {
  0x40c6e4		ebed			JMP 0x40c6d3		
			getg().m.traceback = 2
  0x40c6e6		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40c6ef		488b4030		MOVQ 0x30(AX), AX	
  0x40c6f3		c6802901000002		MOVB $0x2, 0x129(AX)	
			throw("found bad pointer in Go heap (incorrect use of unsafe or cgo?)")
  0x40c6fa		488d05f9160600		LEAQ 0x616f9(IP), AX	
  0x40c701		48890424		MOVQ AX, 0(SP)		
  0x40c705		48c74424083e000000	MOVQ $0x3e, 0x8(SP)	
  0x40c70e		e8bd4a0100		CALL runtime.throw(SB)	
  0x40c713		0f0b			UD2			
	s = mheap_.spans[idx]
  0x40c715		e826330100		CALL runtime.panicindex(SB)	
  0x40c71a		0f0b			UD2				
func heapBitsForObject(p, refBase, refOff uintptr) (base uintptr, hbits heapBits, s *mspan, objIndex uintptr) {
  0x40c71c		e84f7e0300		CALL runtime.morestack_noctxt(SB)	
  0x40c721		e97afbffff		JMP runtime.heapBitsForObject(SB)	

TEXT runtime.bulkBarrierPreWrite(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func bulkBarrierPreWrite(dst, src, size uintptr) {
  0x40c730		4883ec60		SUBQ $0x60, SP		
  0x40c734		48896c2458		MOVQ BP, 0x58(SP)	
  0x40c739		488d6c2458		LEAQ 0x58(SP), BP	
  0x40c73e		488b442470		MOVQ 0x70(SP), AX	
  0x40c743		488b542468		MOVQ 0x68(SP), DX	
  0x40c748		4889c3			MOVQ AX, BX		
	if (dst|src|size)&(sys.PtrSize-1) != 0 {
  0x40c74b		4809d0			ORQ DX, AX		
  0x40c74e		488b742478		MOVQ 0x78(SP), SI	
  0x40c753		4809f0			ORQ SI, AX		
  0x40c756		48a907000000		TESTQ $0x7, AX		
  0x40c75c		0f8580030000		JNE 0x40cae2		
	if !writeBarrier.needed {
  0x40c762		0fb605ab720b00		MOVZX runtime.writeBarrier+4(SB), AX	
  0x40c769		84c0			TESTL AL, AL				
  0x40c76b		0f8460030000		JE 0x40cad1				
	if b == 0 || b < mheap_.arena_start || b >= mheap_.arena_used {
  0x40c771		4885d2			TESTQ DX, DX		
  0x40c774		0f852d010000		JNE 0x40c8a7		
		gp := getg().m.curg
  0x40c77a		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40c783		488b4030		MOVQ 0x30(AX), AX	
  0x40c787		488b80c0000000		MOVQ 0xc0(AX), AX	
		if gp != nil && gp.stack.lo <= dst && dst < gp.stack.hi {
  0x40c78e		4885c0			TESTQ AX, AX		
  0x40c791		7415			JE 0x40c7a8		
  0x40c793		488b08			MOVQ 0(AX), CX		
  0x40c796		4839d1			CMPQ DX, CX		
  0x40c799		770d			JA 0x40c7a8		
  0x40c79b		488b4008		MOVQ 0x8(AX), AX	
  0x40c79f		4839c2			CMPQ AX, DX		
  0x40c7a2		0f82f5000000		JB 0x40c89d		
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x40c7a8		488b05c9ae0900		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x40c7af		4885c0			TESTQ AX, AX		
  0x40c7b2		0f84dc000000		JE 0x40c894		
	return *p
  0x40c7b8		488b4808		MOVQ 0x8(AX), CX	
  0x40c7bc		488b00			MOVQ 0(AX), AX		
		for _, datap := range activeModules() {
  0x40c7bf		31ff			XORL DI, DI		
  0x40c7c1		eb03			JMP 0x40c7c6		
  0x40c7c3		48ffc7			INCQ DI			
  0x40c7c6		4839cf			CMPQ CX, DI		
  0x40c7c9		7d4d			JGE 0x40c818		
  0x40c7cb		4c8b04f8		MOVQ 0(AX)(DI*8), R8	
			if datap.data <= dst && dst < datap.edata {
  0x40c7cf		4d8b8880000000		MOVQ 0x80(R8), R9	
  0x40c7d6		4939d1			CMPQ DX, R9		
  0x40c7d9		77e8			JA 0x40c7c3		
  0x40c7db		4d8b9088000000		MOVQ 0x88(R8), R10	
  0x40c7e2		4c39d2			CMPQ R10, DX		
  0x40c7e5		73dc			JAE 0x40c7c3		
				bulkBarrierBitmap(dst, src, size, dst-datap.data, datap.gcdatamask.bytedata)
  0x40c7e7		498b8098010000		MOVQ 0x198(R8), AX			
  0x40c7ee		4889442420		MOVQ AX, 0x20(SP)			
  0x40c7f3		48891424		MOVQ DX, 0(SP)				
  0x40c7f7		48895c2408		MOVQ BX, 0x8(SP)			
  0x40c7fc		4889742410		MOVQ SI, 0x10(SP)			
  0x40c801		4c29ca			SUBQ R9, DX				
  0x40c804		4889542418		MOVQ DX, 0x18(SP)			
  0x40c809		e8f2020000		CALL runtime.bulkBarrierBitmap(SB)	
				return
  0x40c80e		488b6c2458		MOVQ 0x58(SP), BP	
  0x40c813		4883c460		ADDQ $0x60, SP		
  0x40c817		c3			RET			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x40c818		488b0559ae0900		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x40c81f		4885c0			TESTQ AX, AX		
  0x40c822		746a			JE 0x40c88e		
	return *p
  0x40c824		488b4808		MOVQ 0x8(AX), CX	
  0x40c828		488b00			MOVQ 0(AX), AX		
		for _, datap := range activeModules() {
  0x40c82b		31ff			XORL DI, DI		
  0x40c82d		eb03			JMP 0x40c832		
  0x40c82f		48ffc7			INCQ DI			
  0x40c832		4839cf			CMPQ CX, DI		
  0x40c835		7d4d			JGE 0x40c884		
  0x40c837		4c8b04f8		MOVQ 0(AX)(DI*8), R8	
			if datap.bss <= dst && dst < datap.ebss {
  0x40c83b		4d8b8890000000		MOVQ 0x90(R8), R9	
  0x40c842		4939d1			CMPQ DX, R9		
  0x40c845		77e8			JA 0x40c82f		
  0x40c847		4d8b9098000000		MOVQ 0x98(R8), R10	
  0x40c84e		4c39d2			CMPQ R10, DX		
  0x40c851		73dc			JAE 0x40c82f		
				bulkBarrierBitmap(dst, src, size, dst-datap.bss, datap.gcbssmask.bytedata)
  0x40c853		498b80a8010000		MOVQ 0x1a8(R8), AX			
  0x40c85a		4889442420		MOVQ AX, 0x20(SP)			
  0x40c85f		48891424		MOVQ DX, 0(SP)				
  0x40c863		48895c2408		MOVQ BX, 0x8(SP)			
  0x40c868		4889742410		MOVQ SI, 0x10(SP)			
  0x40c86d		4c29ca			SUBQ R9, DX				
  0x40c870		4889542418		MOVQ DX, 0x18(SP)			
  0x40c875		e886020000		CALL runtime.bulkBarrierBitmap(SB)	
				return
  0x40c87a		488b6c2458		MOVQ 0x58(SP), BP	
  0x40c87f		4883c460		ADDQ $0x60, SP		
  0x40c883		c3			RET			
		return
  0x40c884		488b6c2458		MOVQ 0x58(SP), BP	
  0x40c889		4883c460		ADDQ $0x60, SP		
  0x40c88d		c3			RET			
  0x40c88e		31c0			XORL AX, AX		
  0x40c890		31c9			XORL CX, CX		
		for _, datap := range activeModules() {
  0x40c892		eb97			JMP 0x40c82b		
  0x40c894		31c9			XORL CX, CX		
  0x40c896		31c0			XORL AX, AX		
		for _, datap := range activeModules() {
  0x40c898		e922ffffff		JMP 0x40c7bf		
			return
  0x40c89d		488b6c2458		MOVQ 0x58(SP), BP	
  0x40c8a2		4883c460		ADDQ $0x60, SP		
  0x40c8a6		c3			RET			
	if b == 0 || b < mheap_.arena_start || b >= mheap_.arena_used {
  0x40c8a7		488b051a0d0a00		MOVQ runtime.mheap_+4904(SB), AX	
  0x40c8ae		4839c2			CMPQ AX, DX				
  0x40c8b1		0f82c3feffff		JB 0x40c77a				
  0x40c8b7		488b3d120d0a00		MOVQ runtime.mheap_+4912(SB), DI	
  0x40c8be		4839fa			CMPQ DI, DX				
  0x40c8c1		0f83b3feffff		JAE 0x40c77a				
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x40c8c7		488b3d220a0a00		MOVQ runtime.mheap_+4176(SB), DI	
  0x40c8ce		4c8b05130a0a00		MOVQ runtime.mheap_+4168(SB), R8	
  0x40c8d5		4989d1			MOVQ DX, R9				
  0x40c8d8		4829c2			SUBQ AX, DX				
  0x40c8db		4889d0			MOVQ DX, AX				
  0x40c8de		48c1ea0d		SHRQ $0xd, DX				
  0x40c8e2		4839fa			CMPQ DI, DX				
  0x40c8e5		0f83f0010000		JAE 0x40cadb				
  0x40c8eb		498b14d0		MOVQ 0(R8)(DX*8), DX			
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x40c8ef		4885d2			TESTQ DX, DX		
  0x40c8f2		7409			JE 0x40c8fd		
	return s.startAddr
  0x40c8f4		488b7a18		MOVQ 0x18(DX), DI	
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x40c8f8		4939f9			CMPQ DI, R9		
  0x40c8fb		7308			JAE 0x40c905		
  0x40c8fd		4c89ca			MOVQ R9, DX		
	if !inheap(dst) {
  0x40c900		e975feffff		JMP 0x40c77a		
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x40c905		488bba80000000		MOVQ 0x80(DX), DI	
  0x40c90c		4939f9			CMPQ DI, R9		
  0x40c90f		73ec			JAE 0x40c8fd		
  0x40c911		0fb65264		MOVZX 0x64(DX), DX	
  0x40c915		80fa01			CMPL $0x1, DL		
  0x40c918		75e3			JNE 0x40c8fd		
	buf := &getg().m.p.ptr().wbBuf
  0x40c91a		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x40c923		488b5230		MOVQ 0x30(DX), DX	
  0x40c927		488bbad0000000		MOVQ 0xd0(DX), DI	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x40c92e		48897c2450		MOVQ DI, 0x50(SP)	
	buf := &getg().m.p.ptr().wbBuf
  0x40c933		8407			TESTB AL, 0(DI)		
  0x40c935		8402			TESTB AL, 0(DX)		
  0x40c937		488d9790120000		LEAQ 0x1290(DI), DX	
  0x40c93e		4889542448		MOVQ DX, 0x48(SP)	
  0x40c943		4989c0			MOVQ AX, R8		
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x40c946		48c1e803		SHRQ $0x3, AX		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x40c94a		4c8b15670c0a00		MOVQ runtime.mheap_+4888(SB), R10	
  0x40c951		49c1e805		SHRQ $0x5, R8				
  0x40c955		4d29c2			SUBQ R8, R10				
  0x40c958		4d8d42ff		LEAQ -0x1(R10), R8			
  0x40c95c		4883e003		ANDQ $0x3, AX				
	if src == 0 {
  0x40c960		4885db			TESTQ BX, BX		
  0x40c963		0f85b5000000		JNE 0x40ca1e		
  0x40c969		31c9			XORL CX, CX		
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40c96b		eb04			JMP 0x40c971		
  0x40c96d		498d4a08		LEAQ 0x8(R10), CX	
  0x40c971		4839f1			CMPQ SI, CX		
  0x40c974		0f839a000000		JAE 0x40ca14		
	return uint32(*h.bitp) >> (h.shift & 31)
  0x40c97a		410fb618		MOVZX 0(R8), BX		
  0x40c97e		4989ca			MOVQ CX, R10		
  0x40c981		89c1			MOVL AX, CX		
  0x40c983		d3eb			SHRL CL, BX		
	return h.bits()&bitPointer != 0
  0x40c985		0fbae300		BTL $0x0, BX		
			if h.isPointer() {
  0x40c989		7339			JAE 0x40c9c4		
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40c98b		4b8d1c0a		LEAQ 0(R10)(R9*1), BX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40c98f		8402			TESTB AL, 0(DX)		
  0x40c991		4c8b9f90120000		MOVQ 0x1290(DI), R11	
				if !buf.putFast(*dstx, 0) {
  0x40c998		488b1b			MOVQ 0(BX), BX		
	p[0] = old
  0x40c99b		49891b			MOVQ BX, 0(R11)		
	p[1] = new
  0x40c99e		49c7430800000000	MOVQ $0x0, 0x8(R11)	
	b.next += 2 * sys.PtrSize
  0x40c9a6		488b9f90120000		MOVQ 0x1290(DI), BX	
  0x40c9ad		4883c310		ADDQ $0x10, BX		
  0x40c9b1		48899f90120000		MOVQ BX, 0x1290(DI)	
	return b.next != b.end
  0x40c9b8		4c8b9f98120000		MOVQ 0x1298(DI), R11	
  0x40c9bf		4939db			CMPQ BX, R11		
				if !buf.putFast(*dstx, 0) {
  0x40c9c2		7410			JE 0x40c9d4		
	if h.shift < 3*heapBitsShift {
  0x40c9c4		83f803			CMPL $0x3, AX		
  0x40c9c7		7304			JAE 0x40c9cd		
		return heapBits{h.bitp, h.shift + heapBitsShift}
  0x40c9c9		ffc0			INCL AX			
			h = h.next()
  0x40c9cb		eba0			JMP 0x40c96d		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40c9cd		49ffc8			DECQ R8			
  0x40c9d0		31c0			XORL AX, AX		
			h = h.next()
  0x40c9d2		eb99			JMP 0x40c96d		
  0x40c9d4		4c89542430		MOVQ R10, 0x30(SP)	
  0x40c9d9		8944242c		MOVL AX, 0x2c(SP)	
  0x40c9dd		4c89442438		MOVQ R8, 0x38(SP)	
					wbBufFlush(nil, 0)
  0x40c9e2		0f57c0			XORPS X0, X0			
  0x40c9e5		0f110424		MOVUPS X0, 0(SP)		
  0x40c9e9		e8021b0100		CALL runtime.wbBufFlush(SB)	
  0x40c9ee		8b44242c		MOVL 0x2c(SP), AX		
  0x40c9f2		89c1			MOVL AX, CX			
  0x40c9f4		488b542448		MOVQ 0x48(SP), DX		
  0x40c9f9		488b742478		MOVQ 0x78(SP), SI		
  0x40c9fe		488b7c2450		MOVQ 0x50(SP), DI		
  0x40ca03		4c8b442438		MOVQ 0x38(SP), R8		
  0x40ca08		4c8b4c2468		MOVQ 0x68(SP), R9		
  0x40ca0d		4c8b542430		MOVQ 0x30(SP), R10		
  0x40ca12		ebb0			JMP 0x40c9c4			
  0x40ca14		488b6c2458		MOVQ 0x58(SP), BP		
  0x40ca19		4883c460		ADDQ $0x60, SP			
  0x40ca1d		c3			RET				
  0x40ca1e		31c9			XORL CX, CX			
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40ca20		eb04			JMP 0x40ca26		
  0x40ca22		498d4b08		LEAQ 0x8(R11), CX	
  0x40ca26		4839f1			CMPQ SI, CX		
  0x40ca29		73e9			JAE 0x40ca14		
	return uint32(*h.bitp) >> (h.shift & 31)
  0x40ca2b		450fb610		MOVZX 0(R8), R10	
  0x40ca2f		4989cb			MOVQ CX, R11		
  0x40ca32		89c1			MOVL AX, CX		
  0x40ca34		41d3ea			SHRL CL, R10		
	return h.bits()&bitPointer != 0
  0x40ca37		410fbae200		BTL $0x0, R10		
			if h.isPointer() {
  0x40ca3c		733e			JAE 0x40ca7c		
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40ca3e		4f8d140b		LEAQ 0(R11)(R9*1), R10	
				srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40ca42		4d8d241b		LEAQ 0(R11)(BX*1), R12	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40ca46		8402			TESTB AL, 0(DX)		
  0x40ca48		4c8baf90120000		MOVQ 0x1290(DI), R13	
				if !buf.putFast(*dstx, *srcx) {
  0x40ca4f		4d8b12			MOVQ 0(R10), R10	
  0x40ca52		4d8b2424		MOVQ 0(R12), R12	
	p[0] = old
  0x40ca56		4d895500		MOVQ R10, 0(R13)	
	p[1] = new
  0x40ca5a		4d896508		MOVQ R12, 0x8(R13)	
	b.next += 2 * sys.PtrSize
  0x40ca5e		4c8b9790120000		MOVQ 0x1290(DI), R10	
  0x40ca65		4983c210		ADDQ $0x10, R10		
  0x40ca69		4c899790120000		MOVQ R10, 0x1290(DI)	
	return b.next != b.end
  0x40ca70		4c8ba798120000		MOVQ 0x1298(DI), R12	
  0x40ca77		4d39d4			CMPQ R10, R12		
				if !buf.putFast(*dstx, *srcx) {
  0x40ca7a		7410			JE 0x40ca8c		
	if h.shift < 3*heapBitsShift {
  0x40ca7c		83f803			CMPL $0x3, AX		
  0x40ca7f		7304			JAE 0x40ca85		
		return heapBits{h.bitp, h.shift + heapBitsShift}
  0x40ca81		ffc0			INCL AX			
			h = h.next()
  0x40ca83		eb9d			JMP 0x40ca22		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40ca85		49ffc8			DECQ R8			
  0x40ca88		31c0			XORL AX, AX		
			h = h.next()
  0x40ca8a		eb96			JMP 0x40ca22		
  0x40ca8c		4c895c2430		MOVQ R11, 0x30(SP)	
  0x40ca91		89442428		MOVL AX, 0x28(SP)	
  0x40ca95		4c89442440		MOVQ R8, 0x40(SP)	
					wbBufFlush(nil, 0)
  0x40ca9a		0f57c0			XORPS X0, X0			
  0x40ca9d		0f110424		MOVUPS X0, 0(SP)		
  0x40caa1		e84a1a0100		CALL runtime.wbBufFlush(SB)	
  0x40caa6		8b442428		MOVL 0x28(SP), AX		
  0x40caaa		89c1			MOVL AX, CX			
  0x40caac		488b542448		MOVQ 0x48(SP), DX		
  0x40cab1		488b5c2470		MOVQ 0x70(SP), BX		
  0x40cab6		488b742478		MOVQ 0x78(SP), SI		
  0x40cabb		488b7c2450		MOVQ 0x50(SP), DI		
  0x40cac0		4c8b442440		MOVQ 0x40(SP), R8		
  0x40cac5		4c8b4c2468		MOVQ 0x68(SP), R9		
  0x40caca		4c8b5c2430		MOVQ 0x30(SP), R11		
  0x40cacf		ebab			JMP 0x40ca7c			
		return
  0x40cad1		488b6c2458		MOVQ 0x58(SP), BP	
  0x40cad6		4883c460		ADDQ $0x60, SP		
  0x40cada		c3			RET			
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x40cadb		e8602f0100		CALL runtime.panicindex(SB)	
  0x40cae0		0f0b			UD2				
		throw("bulkBarrierPreWrite: unaligned arguments")
  0x40cae2		488d0555070600		LEAQ 0x60755(IP), AX	
  0x40cae9		48890424		MOVQ AX, 0(SP)		
  0x40caed		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x40caf6		e8d5460100		CALL runtime.throw(SB)	
  0x40cafb		0f0b			UD2			

TEXT runtime.bulkBarrierBitmap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func bulkBarrierBitmap(dst, src, size, maskOffset uintptr, bits *uint8) {
  0x40cb00		4883ec40		SUBQ $0x40, SP		
  0x40cb04		48896c2438		MOVQ BP, 0x38(SP)	
  0x40cb09		488d6c2438		LEAQ 0x38(SP), BP	
	buf := &getg().m.p.ptr().wbBuf
  0x40cb0e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40cb17		488b4030		MOVQ 0x30(AX), AX	
  0x40cb1b		488b90d0000000		MOVQ 0xd0(AX), DX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x40cb22		4889542430		MOVQ DX, 0x30(SP)	
	buf := &getg().m.p.ptr().wbBuf
  0x40cb27		8402			TESTB AL, 0(DX)		
  0x40cb29		8400			TESTB AL, 0(AX)		
func bulkBarrierBitmap(dst, src, size, maskOffset uintptr, bits *uint8) {
  0x40cb2b		488b4c2460		MOVQ 0x60(SP), CX	
  0x40cb30		4889c8			MOVQ CX, AX		
	word := maskOffset / sys.PtrSize
  0x40cb33		48c1e903		SHRQ $0x3, CX		
	bits = addb(bits, word/8)
  0x40cb37		48c1e806		SHRQ $0x6, AX		
	mask := uint8(1) << (word % 8)
  0x40cb3b		4883e107		ANDQ $0x7, CX		
  0x40cb3f		bb01000000		MOVL $0x1, BX		
  0x40cb44		d3e3			SHLL CL, BX		
	buf := &getg().m.p.ptr().wbBuf
  0x40cb46		488db290120000		LEAQ 0x1290(DX), SI	
  0x40cb4d		4889742420		MOVQ SI, 0x20(SP)	
  0x40cb52		488b7c2468		MOVQ 0x68(SP), DI	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40cb57		4801f8			ADDQ DI, AX		
  0x40cb5a		31c9			XORL CX, CX		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40cb5c		eb07			JMP 0x40cb65		
  0x40cb5e		488d4808		LEAQ 0x8(AX), CX	
  0x40cb62		4c89c0			MOVQ R8, AX		
  0x40cb65		488b7c2458		MOVQ 0x58(SP), DI	
  0x40cb6a		4839f9			CMPQ DI, CX		
  0x40cb6d		0f8371010000		JAE 0x40cce4		
		if mask == 0 {
  0x40cb73		84db			TESTL BL, BL		
  0x40cb75		0f8559010000		JNE 0x40ccd4		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40cb7b		4c8d4001		LEAQ 0x1(AX), R8	
			if *bits == 0 {
  0x40cb7f		418400			TESTB AL, 0(R8)		
  0x40cb82		41b901000000		MOVL $0x1, R9		
  0x40cb88		420fb60408		MOVZX 0(AX)(R9*1), AX	
  0x40cb8d		84c0			TESTL AL, AL		
  0x40cb8f		7506			JNE 0x40cb97		
				i += 7 * sys.PtrSize
  0x40cb91		488d4138		LEAQ 0x38(CX), AX	
				continue
  0x40cb95		ebc7			JMP 0x40cb5e		
  0x40cb97		b801000000		MOVL $0x1, AX		
		if *bits&mask != 0 {
  0x40cb9c		410fb618		MOVZX 0(R8), BX		
  0x40cba0		84c3			TESTL AL, BL		
  0x40cba2		0f841d010000		JE 0x40ccc5		
  0x40cba8		48894c2418		MOVQ CX, 0x18(SP)	
  0x40cbad		4c89442428		MOVQ R8, 0x28(SP)	
  0x40cbb2		88442417		MOVB AL, 0x17(SP)	
  0x40cbb6		488b5c2448		MOVQ 0x48(SP), BX	
			dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40cbbb		4c8d1419		LEAQ 0(CX)(BX*1), R10	
  0x40cbbf		4c8b5c2450		MOVQ 0x50(SP), R11	
			if src == 0 {
  0x40cbc4		4d85db			TESTQ R11, R11		
  0x40cbc7		757f			JNE 0x40cc48		
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40cbc9		8406			TESTB AL, 0(SI)		
  0x40cbcb		4c8ba290120000		MOVQ 0x1290(DX), R12	
				if !buf.putFast(*dstx, 0) {
  0x40cbd2		4d8b12			MOVQ 0(R10), R10	
	p[0] = old
  0x40cbd5		4d891424		MOVQ R10, 0(R12)	
	p[1] = new
  0x40cbd9		49c744240800000000	MOVQ $0x0, 0x8(R12)	
	b.next += 2 * sys.PtrSize
  0x40cbe2		4c8b9290120000		MOVQ 0x1290(DX), R10	
  0x40cbe9		4983c210		ADDQ $0x10, R10		
  0x40cbed		4c899290120000		MOVQ R10, 0x1290(DX)	
	return b.next != b.end
  0x40cbf4		4c8ba298120000		MOVQ 0x1298(DX), R12	
  0x40cbfb		4d39d4			CMPQ R10, R12		
				if !buf.putFast(*dstx, 0) {
  0x40cbfe		740c			JE 0x40cc0c		
		mask <<= 1
  0x40cc00		d1e0			SHLL $0x1, AX		
  0x40cc02		89c3			MOVL AX, BX		
  0x40cc04		4889c8			MOVQ CX, AX		
  0x40cc07		e952ffffff		JMP 0x40cb5e		
					wbBufFlush(nil, 0)
  0x40cc0c		0f57c0			XORPS X0, X0			
  0x40cc0f		0f110424		MOVUPS X0, 0(SP)		
  0x40cc13		e8d8180100		CALL runtime.wbBufFlush(SB)	
  0x40cc18		0fb6442417		MOVZX 0x17(SP), AX		
  0x40cc1d		488b4c2418		MOVQ 0x18(SP), CX		
  0x40cc22		488b542430		MOVQ 0x30(SP), DX		
  0x40cc27		488b5c2448		MOVQ 0x48(SP), BX		
  0x40cc2c		488b742420		MOVQ 0x20(SP), SI		
  0x40cc31		488b7c2458		MOVQ 0x58(SP), DI		
  0x40cc36		4c8b442428		MOVQ 0x28(SP), R8		
  0x40cc3b		41b901000000		MOVL $0x1, R9			
  0x40cc41		4c8b5c2450		MOVQ 0x50(SP), R11		
  0x40cc46		ebb8			JMP 0x40cc00			
				srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40cc48		4e8d2419		LEAQ 0(CX)(R11*1), R12	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40cc4c		8406			TESTB AL, 0(SI)		
  0x40cc4e		4c8baa90120000		MOVQ 0x1290(DX), R13	
				if !buf.putFast(*dstx, *srcx) {
  0x40cc55		4d8b12			MOVQ 0(R10), R10	
  0x40cc58		4d8b2424		MOVQ 0(R12), R12	
	p[0] = old
  0x40cc5c		4d895500		MOVQ R10, 0(R13)	
	p[1] = new
  0x40cc60		4d896508		MOVQ R12, 0x8(R13)	
	b.next += 2 * sys.PtrSize
  0x40cc64		4c8b9290120000		MOVQ 0x1290(DX), R10	
  0x40cc6b		4983c210		ADDQ $0x10, R10		
  0x40cc6f		4c899290120000		MOVQ R10, 0x1290(DX)	
	return b.next != b.end
  0x40cc76		4c8ba298120000		MOVQ 0x1298(DX), R12	
  0x40cc7d		4d39d4			CMPQ R10, R12		
				if !buf.putFast(*dstx, *srcx) {
  0x40cc80		0f857affffff		JNE 0x40cc00		
					wbBufFlush(nil, 0)
  0x40cc86		0f57c0			XORPS X0, X0			
  0x40cc89		0f110424		MOVUPS X0, 0(SP)		
  0x40cc8d		e85e180100		CALL runtime.wbBufFlush(SB)	
  0x40cc92		0fb6442417		MOVZX 0x17(SP), AX		
  0x40cc97		488b4c2418		MOVQ 0x18(SP), CX		
  0x40cc9c		488b542430		MOVQ 0x30(SP), DX		
  0x40cca1		488b5c2448		MOVQ 0x48(SP), BX		
  0x40cca6		488b742420		MOVQ 0x20(SP), SI		
  0x40ccab		488b7c2458		MOVQ 0x58(SP), DI		
  0x40ccb0		4c8b442428		MOVQ 0x28(SP), R8		
  0x40ccb5		41b901000000		MOVL $0x1, R9			
  0x40ccbb		4c8b5c2450		MOVQ 0x50(SP), R11		
  0x40ccc0		e93bffffff		JMP 0x40cc00			
  0x40ccc5		488b5c2448		MOVQ 0x48(SP), BX		
  0x40ccca		4c8b5c2450		MOVQ 0x50(SP), R11		
		if *bits&mask != 0 {
  0x40cccf		e92cffffff		JMP 0x40cc00		
  0x40ccd4		41b901000000		MOVL $0x1, R9		
  0x40ccda		4989c0			MOVQ AX, R8		
  0x40ccdd		89d8			MOVL BX, AX		
		if mask == 0 {
  0x40ccdf		e9b8feffff		JMP 0x40cb9c		
  0x40cce4		488b6c2438		MOVQ 0x38(SP), BP	
  0x40cce9		4883c440		ADDQ $0x40, SP		
  0x40cced		c3			RET			

TEXT runtime.typeBitsBulkBarrier(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func typeBitsBulkBarrier(typ *_type, dst, src, size uintptr) {
  0x40ccf0		4883ec50		SUBQ $0x50, SP		
  0x40ccf4		48896c2448		MOVQ BP, 0x48(SP)	
  0x40ccf9		488d6c2448		LEAQ 0x48(SP), BP	
  0x40ccfe		488b442458		MOVQ 0x58(SP), AX	
	if typ == nil {
  0x40cd03		4885c0			TESTQ AX, AX		
  0x40cd06		0f8416020000		JE 0x40cf22		
	if typ.size != size {
  0x40cd0c		488b08			MOVQ 0(AX), CX		
  0x40cd0f		488b542470		MOVQ 0x70(SP), DX	
  0x40cd14		4839d1			CMPQ DX, CX		
  0x40cd17		0f8532010000		JNE 0x40ce4f		
	if typ.kind&kindGCProg != 0 {
  0x40cd1d		0fb64817		MOVZX 0x17(AX), CX	
  0x40cd21		f6c140			TESTL $0x40, CL		
  0x40cd24		0f8599000000		JNE 0x40cdc3		
	if !writeBarrier.needed {
  0x40cd2a		0fb60de36c0b00		MOVZX runtime.writeBarrier+4(SB), CX	
  0x40cd31		84c9			TESTL CL, CL				
  0x40cd33		0f8480000000		JE 0x40cdb9				
	ptrmask := typ.gcdata
  0x40cd39		488b4820		MOVQ 0x20(AX), CX	
  0x40cd3d		31d2			XORL DX, DX		
  0x40cd3f		31db			XORL BX, BX		
	for i := uintptr(0); i < typ.ptrdata; i += sys.PtrSize {
  0x40cd41		eb04			JMP 0x40cd47		
  0x40cd43		4883c208		ADDQ $0x8, DX		
  0x40cd47		488b7008		MOVQ 0x8(AX), SI	
  0x40cd4b		4839f2			CMPQ SI, DX		
  0x40cd4e		735f			JAE 0x40cdaf		
		if i&(sys.PtrSize*8-1) == 0 {
  0x40cd50		48f7c23f000000		TESTQ $0x3f, DX		
  0x40cd57		7552			JNE 0x40cdab		
			bits = uint32(*ptrmask)
  0x40cd59		0fb619			MOVZX 0(CX), BX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40cd5c		48ffc1			INCQ CX			
		if bits&1 != 0 {
  0x40cd5f		0fbae300		BTL $0x0, BX		
  0x40cd63		73de			JAE 0x40cd43		
  0x40cd65		4889542420		MOVQ DX, 0x20(SP)	
  0x40cd6a		895c241c		MOVL BX, 0x1c(SP)	
  0x40cd6e		48894c2438		MOVQ CX, 0x38(SP)	
  0x40cd73		488b442468		MOVQ 0x68(SP), AX	
			srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40cd78		488d0c02		LEAQ 0(DX)(AX*1), CX	
  0x40cd7c		488b5c2460		MOVQ 0x60(SP), BX	
			dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40cd81		488d341a		LEAQ 0(DX)(BX*1), SI	
			writebarrierptr_prewrite(dstx, *srcx)
  0x40cd85		488b09			MOVQ 0(CX), CX					
  0x40cd88		48894c2408		MOVQ CX, 0x8(SP)				
  0x40cd8d		48893424		MOVQ SI, 0(SP)					
  0x40cd91		e86aecffff		CALL runtime.writebarrierptr_prewrite(SB)	
  0x40cd96		488b442458		MOVQ 0x58(SP), AX				
  0x40cd9b		488b4c2438		MOVQ 0x38(SP), CX				
  0x40cda0		488b542420		MOVQ 0x20(SP), DX				
  0x40cda5		8b5c241c		MOVL 0x1c(SP), BX				
  0x40cda9		eb98			JMP 0x40cd43					
			bits = bits >> 1
  0x40cdab		d1eb			SHRL $0x1, BX		
  0x40cdad		ebb0			JMP 0x40cd5f		
  0x40cdaf		488b6c2448		MOVQ 0x48(SP), BP	
  0x40cdb4		4883c450		ADDQ $0x50, SP		
  0x40cdb8		c3			RET			
		return
  0x40cdb9		488b6c2448		MOVQ 0x48(SP), BP	
  0x40cdbe		4883c450		ADDQ $0x50, SP		
  0x40cdc2		c3			RET			
		println("runtime: typeBitsBulkBarrier with type ", typ.string(), " with GC prog")
  0x40cdc3		48890424		MOVQ AX, 0(SP)				
  0x40cdc7		e8a41b0300		CALL runtime.(*_type).string(SB)	
  0x40cdcc		488b442408		MOVQ 0x8(SP), AX			
  0x40cdd1		4889442440		MOVQ AX, 0x40(SP)			
  0x40cdd6		488b4c2410		MOVQ 0x10(SP), CX			
  0x40cddb		48894c2430		MOVQ CX, 0x30(SP)			
  0x40cde0		e81b4d0100		CALL runtime.printlock(SB)		
  0x40cde5		488d051a050600		LEAQ 0x6051a(IP), AX			
  0x40cdec		48890424		MOVQ AX, 0(SP)				
  0x40cdf0		48c744240828000000	MOVQ $0x28, 0x8(SP)			
  0x40cdf9		e842560100		CALL runtime.printstring(SB)		
  0x40cdfe		488b442440		MOVQ 0x40(SP), AX			
  0x40ce03		48890424		MOVQ AX, 0(SP)				
  0x40ce07		488b442430		MOVQ 0x30(SP), AX			
  0x40ce0c		4889442408		MOVQ AX, 0x8(SP)			
  0x40ce11		e82a560100		CALL runtime.printstring(SB)		
  0x40ce16		488d0503db0500		LEAQ 0x5db03(IP), AX			
  0x40ce1d		48890424		MOVQ AX, 0(SP)				
  0x40ce21		48c74424080f000000	MOVQ $0xf, 0x8(SP)			
  0x40ce2a		e811560100		CALL runtime.printstring(SB)		
  0x40ce2f		e84c4d0100		CALL runtime.printunlock(SB)		
		throw("runtime: invalid typeBitsBulkBarrier")
  0x40ce34		488d0533000600		LEAQ 0x60033(IP), AX	
  0x40ce3b		48890424		MOVQ AX, 0(SP)		
  0x40ce3f		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x40ce48		e883430100		CALL runtime.throw(SB)	
  0x40ce4d		0f0b			UD2			
		println("runtime: typeBitsBulkBarrier with type ", typ.string(), " of size ", typ.size, " but memory size", size)
  0x40ce4f		48890424		MOVQ AX, 0(SP)				
  0x40ce53		e8181b0300		CALL runtime.(*_type).string(SB)	
  0x40ce58		488b442410		MOVQ 0x10(SP), AX			
  0x40ce5d		4889442430		MOVQ AX, 0x30(SP)			
  0x40ce62		488b4c2408		MOVQ 0x8(SP), CX			
  0x40ce67		48894c2440		MOVQ CX, 0x40(SP)			
  0x40ce6c		488b542458		MOVQ 0x58(SP), DX			
  0x40ce71		488b12			MOVQ 0(DX), DX				
  0x40ce74		4889542428		MOVQ DX, 0x28(SP)			
  0x40ce79		e8824c0100		CALL runtime.printlock(SB)		
  0x40ce7e		488d0581040600		LEAQ 0x60481(IP), AX			
  0x40ce85		48890424		MOVQ AX, 0(SP)				
  0x40ce89		48c744240828000000	MOVQ $0x28, 0x8(SP)			
  0x40ce92		e8a9550100		CALL runtime.printstring(SB)		
  0x40ce97		488b442440		MOVQ 0x40(SP), AX			
  0x40ce9c		48890424		MOVQ AX, 0(SP)				
  0x40cea0		488b442430		MOVQ 0x30(SP), AX			
  0x40cea5		4889442408		MOVQ AX, 0x8(SP)			
  0x40ceaa		e891550100		CALL runtime.printstring(SB)		
  0x40ceaf		488d05e2d40500		LEAQ 0x5d4e2(IP), AX			
  0x40ceb6		48890424		MOVQ AX, 0(SP)				
  0x40ceba		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x40cec3		e878550100		CALL runtime.printstring(SB)		
  0x40cec8		488b442428		MOVQ 0x28(SP), AX			
  0x40cecd		48890424		MOVQ AX, 0(SP)				
  0x40ced1		e89a520100		CALL runtime.printuint(SB)		
  0x40ced6		488d056ede0500		LEAQ 0x5de6e(IP), AX			
  0x40cedd		48890424		MOVQ AX, 0(SP)				
  0x40cee1		48c744240812000000	MOVQ $0x12, 0x8(SP)			
  0x40ceea		e851550100		CALL runtime.printstring(SB)		
  0x40ceef		488b442470		MOVQ 0x70(SP), AX			
  0x40cef4		48890424		MOVQ AX, 0(SP)				
  0x40cef8		e873520100		CALL runtime.printuint(SB)		
  0x40cefd		e88e4e0100		CALL runtime.printnl(SB)		
  0x40cf02		e8794c0100		CALL runtime.printunlock(SB)		
		throw("runtime: invalid typeBitsBulkBarrier")
  0x40cf07		488d0560ff0500		LEAQ 0x5ff60(IP), AX	
  0x40cf0e		48890424		MOVQ AX, 0(SP)		
  0x40cf12		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x40cf1b		e8b0420100		CALL runtime.throw(SB)	
  0x40cf20		0f0b			UD2			
		throw("runtime: typeBitsBulkBarrier without type")
  0x40cf22		488d05a9040600		LEAQ 0x604a9(IP), AX	
  0x40cf29		48890424		MOVQ AX, 0(SP)		
  0x40cf2d		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x40cf36		e895420100		CALL runtime.throw(SB)	
  0x40cf3b		0f0b			UD2			

TEXT runtime.heapBits.initSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func (h heapBits) initSpan(s *mspan) {
  0x40cf40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40cf49		483b6110		CMPQ 0x10(CX), SP	
  0x40cf4d		0f8612010000		JBE 0x40d065		
  0x40cf53		4883ec28		SUBQ $0x28, SP		
  0x40cf57		48896c2420		MOVQ BP, 0x20(SP)	
  0x40cf5c		488d6c2420		LEAQ 0x20(SP), BP	
  0x40cf61		488b4c2440		MOVQ 0x40(SP), CX	
	total = s.npages << _PageShift
  0x40cf66		488b4120		MOVQ 0x20(CX), AX	
  0x40cf6a		48c1e00d		SHLQ $0xd, AX		
  0x40cf6e		4889442418		MOVQ AX, 0x18(SP)	
	size = s.elemsize
  0x40cf73		488b5168		MOVQ 0x68(CX), DX	
  0x40cf77		4889542410		MOVQ DX, 0x10(SP)	
	if size > 0 {
  0x40cf7c		4885d2			TESTQ DX, DX		
  0x40cf7f		0f86be000000		JBE 0x40d043		
  0x40cf85		4889d3			MOVQ DX, BX		
		n = total / size
  0x40cf88		31d2			XORL DX, DX		
  0x40cf8a		48f7f3			DIVQ BX			
	s.freeindex = 0
  0x40cf8d		48c7413000000000	MOVQ $0x0, 0x30(CX)	
	s.allocCache = ^uint64(0) // all 1s indicating all free.
  0x40cf95		48c74140ffffffff	MOVQ $-0x1, 0x40(CX)	
	s.nelems = n
  0x40cf9d		48894138		MOVQ AX, 0x38(CX)	
	s.gcmarkBits = nil
  0x40cfa1		0f57c0			XORPS X0, X0		
  0x40cfa4		0f114148		MOVUPS X0, 0x48(CX)	
	s.gcmarkBits = newMarkBits(s.nelems)
  0x40cfa8		488b4138		MOVQ 0x38(CX), AX		
  0x40cfac		48890424		MOVQ AX, 0(SP)			
  0x40cfb0		e88bf90000		CALL runtime.newMarkBits(SB)	
  0x40cfb5		488b442408		MOVQ 0x8(SP), AX		
  0x40cfba		488b4c2440		MOVQ 0x40(SP), CX		
  0x40cfbf		48894150		MOVQ AX, 0x50(CX)		
	s.allocBits = newAllocBits(s.nelems)
  0x40cfc3		488b4138		MOVQ 0x38(CX), AX		
  0x40cfc7		48890424		MOVQ AX, 0(SP)			
  0x40cfcb		e870fc0000		CALL runtime.newAllocBits(SB)	
  0x40cfd0		488b442408		MOVQ 0x8(SP), AX		
  0x40cfd5		488b4c2440		MOVQ 0x40(SP), CX		
  0x40cfda		48894148		MOVQ AX, 0x48(CX)		
  0x40cfde		488b442418		MOVQ 0x18(SP), AX		
	if total%heapBitmapScale != 0 {
  0x40cfe3		48a91f000000		TESTQ $0x1f, AX		
  0x40cfe9		755f			JNE 0x40d04a		
	nbyte := total / heapBitmapScale
  0x40cfeb		48c1e805		SHRQ $0x5, AX		
  0x40cfef		488b4c2410		MOVQ 0x10(SP), CX	
	if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40cff4		4883f908		CMPQ $0x8, CX		
  0x40cff8		7525			JNE 0x40d01f		
		bitp := subtractb(end, nbyte-1)
  0x40cffa		48ffc8			DECQ AX			
  0x40cffd		488b4c2430		MOVQ 0x30(SP), CX	
  0x40d002		4889ca			MOVQ CX, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))
  0x40d005		4829c1			SUBQ AX, CX		
		for {
  0x40d008		eb03			JMP 0x40d00d		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40d00a		48ffc1			INCQ CX			
			*bitp = bitPointerAll | bitScanAll
  0x40d00d		c601ff			MOVB $0xff, 0(CX)	
			if bitp == end {
  0x40d010		4839d1			CMPQ DX, CX		
  0x40d013		75f5			JNE 0x40d00a		
		return
  0x40d015		488b6c2420		MOVQ 0x20(SP), BP	
  0x40d01a		4883c428		ADDQ $0x28, SP		
  0x40d01e		c3			RET			
	memclrNoHeapPointers(unsafe.Pointer(subtractb(h.bitp, nbyte-1)), nbyte)
  0x40d01f		488d48ff		LEAQ -0x1(AX), CX	
  0x40d023		488b542430		MOVQ 0x30(SP), DX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))
  0x40d028		4829ca			SUBQ CX, DX		
	memclrNoHeapPointers(unsafe.Pointer(subtractb(h.bitp, nbyte-1)), nbyte)
  0x40d02b		48891424		MOVQ DX, 0(SP)				
  0x40d02f		4889442408		MOVQ AX, 0x8(SP)			
  0x40d034		e8379e0300		CALL runtime.memclrNoHeapPointers(SB)	
}
  0x40d039		488b6c2420		MOVQ 0x20(SP), BP	
  0x40d03e		4883c428		ADDQ $0x28, SP		
  0x40d042		c3			RET			
  0x40d043		31c0			XORL AX, AX		
	if size > 0 {
  0x40d045		e943ffffff		JMP 0x40cf8d		
		throw("initSpan: unaligned length")
  0x40d04a		488d05d7eb0500		LEAQ 0x5ebd7(IP), AX	
  0x40d051		48890424		MOVQ AX, 0(SP)		
  0x40d055		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x40d05e		e86d410100		CALL runtime.throw(SB)	
  0x40d063		0f0b			UD2			
func (h heapBits) initSpan(s *mspan) {
  0x40d065		e806750300		CALL runtime.morestack_noctxt(SB)	
  0x40d06a		e9d1feffff		JMP runtime.heapBits.initSpan(SB)	

TEXT runtime.heapBits.initCheckmarkSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func (h heapBits) initCheckmarkSpan(size, n, total uintptr) {
  0x40d070		488b442418		MOVQ 0x18(SP), AX	
	if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40d075		4883f808		CMPQ $0x8, AX		
  0x40d079		7523			JNE 0x40d09e		
  0x40d07b		488b442420		MOVQ 0x20(SP), AX	
  0x40d080		488b4c2408		MOVQ 0x8(SP), CX	
  0x40d085		31d2			XORL DX, DX		
		for i := uintptr(0); i < n; i += 4 {
  0x40d087		eb0f			JMP 0x40d098		
			*bitp &^= bitPointerAll
  0x40d089		0fb619			MOVZX 0(CX), BX		
  0x40d08c		83e3f0			ANDL $-0x10, BX		
  0x40d08f		8819			MOVB BL, 0(CX)		
		for i := uintptr(0); i < n; i += 4 {
  0x40d091		4883c204		ADDQ $0x4, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d095		48ffc9			DECQ CX			
		for i := uintptr(0); i < n; i += 4 {
  0x40d098		4839c2			CMPQ AX, DX		
  0x40d09b		72ec			JB 0x40d089		
		return
  0x40d09d		c3			RET			
  0x40d09e		488b542420		MOVQ 0x20(SP), DX	
  0x40d0a3		488b5c2408		MOVQ 0x8(SP), BX	
  0x40d0a8		8b742410		MOVL 0x10(SP), SI	
  0x40d0ac		31c9			XORL CX, CX		
	for i := uintptr(0); i < n; i++ {
  0x40d0ae		eb4e			JMP 0x40d0fe		
		*h.bitp &^= bitScan << (heapBitsShift + h.shift)
  0x40d0b0		0fb63b			MOVZX 0(BX), DI		
  0x40d0b3		448d4601		LEAL 0x1(SI), R8	
  0x40d0b7		4989c9			MOVQ CX, R9		
  0x40d0ba		4489c1			MOVL R8, CX		
  0x40d0bd		41ba10000000		MOVL $0x10, R10		
  0x40d0c3		41d3e2			SHLL CL, R10		
  0x40d0c6		83f920			CMPL $0x20, CX		
  0x40d0c9		4519c0			SBBL R8, R8		
  0x40d0cc		4521d0			ANDL R10, R8		
  0x40d0cf		41f7d0			NOTL R8			
  0x40d0d2		4121f8			ANDL DI, R8		
  0x40d0d5		448803			MOVB R8, 0(BX)		
	for i := uintptr(0); i < n; i++ {
  0x40d0d8		498d4901		LEAQ 0x1(R9), CX	
  0x40d0dc		4889c7			MOVQ AX, DI		
		h = h.forward(size / sys.PtrSize)
  0x40d0df		48c1e803		SHRQ $0x3, AX		
	n += uintptr(h.shift) / heapBitsShift
  0x40d0e3		4189f0			MOVL SI, R8		
  0x40d0e6		498d3400		LEAQ 0(R8)(AX*1), SI	
  0x40d0ea		4989f0			MOVQ SI, R8		
	return heapBits{subtractb(h.bitp, n/4), uint32(n%4) * heapBitsShift}
  0x40d0ed		48c1ee02		SHRQ $0x2, SI		
  0x40d0f1		4983e003		ANDQ $0x3, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))
  0x40d0f5		4829f3			SUBQ SI, BX		
  0x40d0f8		4889f8			MOVQ DI, AX		
  0x40d0fb		4c89c6			MOVQ R8, SI		
	for i := uintptr(0); i < n; i++ {
  0x40d0fe		4839d1			CMPQ DX, CX		
  0x40d101		72ad			JB 0x40d0b0		
  0x40d103		c3			RET			

TEXT runtime.heapBits.clearCheckmarkSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func (h heapBits) clearCheckmarkSpan(size, n, total uintptr) {
  0x40d110		488b442418		MOVQ 0x18(SP), AX	
	if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40d115		4883f808		CMPQ $0x8, AX		
  0x40d119		7522			JNE 0x40d13d		
  0x40d11b		488b442420		MOVQ 0x20(SP), AX	
  0x40d120		488b4c2408		MOVQ 0x8(SP), CX	
  0x40d125		31d2			XORL DX, DX		
		for i := uintptr(0); i < n; i += 4 {
  0x40d127		eb0f			JMP 0x40d138		
			*bitp |= bitPointerAll
  0x40d129		0fb619			MOVZX 0(CX), BX		
  0x40d12c		83cb0f			ORL $0xf, BX		
  0x40d12f		8819			MOVB BL, 0(CX)		
		for i := uintptr(0); i < n; i += 4 {
  0x40d131		4883c204		ADDQ $0x4, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d135		48ffc9			DECQ CX			
		for i := uintptr(0); i < n; i += 4 {
  0x40d138		4839c2			CMPQ AX, DX		
  0x40d13b		72ec			JB 0x40d129		
  0x40d13d		c3			RET			

TEXT runtime.(*mspan).countAlloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func (s *mspan) countAlloc() int {
  0x40d140		488b442408		MOVQ 0x8(SP), AX	
	maxIndex := s.nelems / 8
  0x40d145		488b4838		MOVQ 0x38(AX), CX	
  0x40d149		4889ca			MOVQ CX, DX		
  0x40d14c		48c1e903		SHRQ $0x3, CX		
  0x40d150		31db			XORL BX, BX		
  0x40d152		31f6			XORL SI, SI		
	for i := uintptr(0); i < maxIndex; i++ {
  0x40d154		eb25			JMP 0x40d17b		
		mrkBits := *s.gcmarkBits.bytep(i)
  0x40d156		488b7850		MOVQ 0x50(AX), DI	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40d15a		4c8d043b		LEAQ 0(BX)(DI*1), R8	
		mrkBits := *s.gcmarkBits.bytep(i)
  0x40d15e		418400			TESTB AL, 0(R8)		
	for i := uintptr(0); i < maxIndex; i++ {
  0x40d161		4c8d4301		LEAQ 0x1(BX), R8	
		count += int(oneBitCount[mrkBits])
  0x40d165		0fb63c3b		MOVZX 0(BX)(DI*1), DI			
  0x40d169		4c8d0df0810900		LEAQ runtime.oneBitCount(SB), R9	
  0x40d170		410fb63c39		MOVZX 0(R9)(DI*1), DI			
  0x40d175		4801fe			ADDQ DI, SI				
  0x40d178		4c89c3			MOVQ R8, BX				
	for i := uintptr(0); i < maxIndex; i++ {
  0x40d17b		4839cb			CMPQ CX, BX		
  0x40d17e		72d6			JB 0x40d156		
  0x40d180		4889d3			MOVQ DX, BX		
	if bitsInLastByte := s.nelems % 8; bitsInLastByte != 0 {
  0x40d183		4883e207		ANDQ $0x7, DX		
  0x40d187		48f7c307000000		TESTQ $0x7, BX		
  0x40d18e		7434			JE 0x40d1c4		
		mrkBits := *s.gcmarkBits.bytep(maxIndex)
  0x40d190		488b4050		MOVQ 0x50(AX), AX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40d194		488d1c01		LEAQ 0(CX)(AX*1), BX	
		mrkBits := *s.gcmarkBits.bytep(maxIndex)
  0x40d198		8403			TESTB AL, 0(BX)		
  0x40d19a		0fb60401		MOVZX 0(CX)(AX*1), AX	
  0x40d19e		4889d1			MOVQ DX, CX		
		mask := uint8((1 << bitsInLastByte) - 1)
  0x40d1a1		bb01000000		MOVL $0x1, BX		
  0x40d1a6		d3e3			SHLL CL, BX		
  0x40d1a8		8d53ff			LEAL -0x1(BX), DX	
		bits := mrkBits & mask
  0x40d1ab		21d0			ANDL DX, AX		
		count += int(oneBitCount[bits])
  0x40d1ad		0fb6c0			MOVZX AL, AX				
  0x40d1b0		488d15a9810900		LEAQ runtime.oneBitCount(SB), DX	
  0x40d1b7		0fb60410		MOVZX 0(AX)(DX*1), AX			
  0x40d1bb		4801f0			ADDQ SI, AX				
	return count
  0x40d1be		4889442410		MOVQ AX, 0x10(SP)	
  0x40d1c3		c3			RET			
  0x40d1c4		4889f0			MOVQ SI, AX		
	if bitsInLastByte := s.nelems % 8; bitsInLastByte != 0 {
  0x40d1c7		ebf5			JMP 0x40d1be		

TEXT runtime.heapBitsSetType(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40d1d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40d1d9		483b6110		CMPQ 0x10(CX), SP	
  0x40d1dd		0f8604060000		JBE 0x40d7e7		
  0x40d1e3		4883ec50		SUBQ $0x50, SP		
  0x40d1e7		48896c2448		MOVQ BP, 0x48(SP)	
  0x40d1ec		488d6c2448		LEAQ 0x48(SP), BP	
  0x40d1f1		488b542460		MOVQ 0x60(SP), DX	
	if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40d1f6		4883fa08		CMPQ $0x8, DX		
  0x40d1fa		0f843c050000		JE 0x40d73c		
  0x40d200		488b5c2470		MOVQ 0x70(SP), BX	
	ptrmask := typ.gcdata // start of 1-bit pointer mask (or GC program, handled below)
  0x40d205		488b7320		MOVQ 0x20(BX), SI	
  0x40d209		488b4c2458		MOVQ 0x58(SP), CX	
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x40d20e		482b0db3030a00		SUBQ runtime.mheap_+4904(SB), CX	
  0x40d215		4889cf			MOVQ CX, DI				
  0x40d218		48c1e903		SHRQ $0x3, CX				
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x40d21c		4c8b0595030a00		MOVQ runtime.mheap_+4888(SB), R8	
  0x40d223		48c1ef05		SHRQ $0x5, DI				
  0x40d227		4929f8			SUBQ DI, R8				
  0x40d22a		498d78ff		LEAQ -0x1(R8), DI			
  0x40d22e		4883e103		ANDQ $0x3, CX				
	if size == 2*sys.PtrSize {
  0x40d232		4883fa10		CMPQ $0x10, DX		
  0x40d236		0f84a3040000		JE 0x40d6df		
	if typ.kind&kindGCProg != 0 {
  0x40d23c		440fb64317		MOVZX 0x17(BX), R8	
  0x40d241		41f6c040		TESTL $0x40, R8		
  0x40d245		0f8554040000		JNE 0x40d69f		
	if typ.size < dataSize {
  0x40d24b		4c8b03			MOVQ 0(BX), R8		
  0x40d24e		488b442468		MOVQ 0x68(SP), AX	
  0x40d253		4939c0			CMPQ AX, R8		
  0x40d256		0f8320040000		JAE 0x40d67c		
		if typ.ptrdata/sys.PtrSize <= maxBits {
  0x40d25c		4c8b4b08		MOVQ 0x8(BX), R9	
  0x40d260		49c1e903		SHRQ $0x3, R9		
  0x40d264		4983f939		CMPQ $0x39, R9		
  0x40d268		0f87d0030000		JA 0x40d63e		
  0x40d26e		4989f2			MOVQ SI, R10		
  0x40d271		4531db			XORL R11, R11		
  0x40d274		4531e4			XORL R12, R12		
			for i := uintptr(0); i < nb; i += 8 {
  0x40d277		eb27			JMP 0x40d2a0		
  0x40d279		4d8d6b08		LEAQ 0x8(R11), R13	
				b |= uintptr(*p) << i
  0x40d27d		440fb636		MOVZX 0(SI), R14	
  0x40d281		4989cf			MOVQ CX, R15		
  0x40d284		4c89d9			MOVQ R11, CX		
  0x40d287		49d3e6			SHLQ CL, R14		
  0x40d28a		4883f940		CMPQ $0x40, CX		
  0x40d28e		4c89f9			MOVQ R15, CX		
  0x40d291		4d19ff			SBBQ R15, R15		
  0x40d294		4d21fe			ANDQ R15, R14		
  0x40d297		4d09f4			ORQ R14, R12		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40d29a		48ffc6			INCQ SI			
  0x40d29d		4d89eb			MOVQ R13, R11		
			for i := uintptr(0); i < nb; i += 8 {
  0x40d2a0		4d39cb			CMPQ R9, R11		
  0x40d2a3		72d4			JB 0x40d279		
  0x40d2a5		4c89c6			MOVQ R8, SI		
			nb = typ.size / sys.PtrSize
  0x40d2a8		49c1e803		SHRQ $0x3, R8		
			if nb+nb <= maxBits {
  0x40d2ac		4f8d0c00		LEAQ 0(R8)(R8*1), R9	
  0x40d2b0		4983f939		CMPQ $0x39, R9		
  0x40d2b4		0f8773030000		JA 0x40d62d		
  0x40d2ba		4d89c1			MOVQ R8, R9		
				for endnb <= sys.PtrSize*8 {
  0x40d2bd		eb20			JMP 0x40d2df		
  0x40d2bf		4989cb			MOVQ CX, R11		
  0x40d2c2		4c89c1			MOVQ R8, CX		
  0x40d2c5		4d89e5			MOVQ R12, R13		
					pbits |= pbits << endnb
  0x40d2c8		49d3e4			SHLQ CL, R12		
				for endnb <= sys.PtrSize*8 {
  0x40d2cb		4883f940		CMPQ $0x40, CX		
					pbits |= pbits << endnb
  0x40d2cf		4d19f6			SBBQ R14, R14		
  0x40d2d2		4d21f4			ANDQ R14, R12		
  0x40d2d5		4d09ec			ORQ R13, R12		
					endnb += endnb
  0x40d2d8		4c8d0409		LEAQ 0(CX)(CX*1), R8	
  0x40d2dc		4c89d9			MOVQ R11, CX		
				for endnb <= sys.PtrSize*8 {
  0x40d2df		4983f840		CMPQ $0x40, R8		
  0x40d2e3		76da			JBE 0x40d2bf		
				endnb = uintptr(maxBits/byte(nb)) * nb
  0x40d2e5		4584c9			TESTL R9, R9		
  0x40d2e8		0f84f2040000		JE 0x40d7e0		
  0x40d2ee		450fb6c1		MOVZX R9, R8		
  0x40d2f2		41bb39000000		MOVL $0x39, R11		
  0x40d2f8		450fb6db		MOVZX R11, R11		
  0x40d2fc		4989c5			MOVQ AX, R13		
  0x40d2ff		4489d8			MOVL R11, AX		
  0x40d302		4989d3			MOVQ DX, R11		
  0x40d305		31d2			XORL DX, DX		
  0x40d307		6641f7f0		DIVW R8			
  0x40d30b		0fb6d0			MOVZX AL, DX		
  0x40d30e		490fafd1		IMULQ R9, DX		
  0x40d312		4889c8			MOVQ CX, AX		
  0x40d315		4889d1			MOVQ DX, CX		
				pbits &= 1<<endnb - 1
  0x40d318		41b801000000		MOVL $0x1, R8		
  0x40d31e		49d3e0			SHLQ CL, R8		
  0x40d321		4883f940		CMPQ $0x40, CX		
  0x40d325		4d19c9			SBBQ R9, R9		
  0x40d328		4d21c8			ANDQ R9, R8		
  0x40d32b		49ffc8			DECQ R8			
  0x40d32e		4d21c4			ANDQ R8, R12		
				nb = endnb
  0x40d331		31d2			XORL DX, DX		
  0x40d333		4531c0			XORL R8, R8		
  0x40d336		4989c9			MOVQ CX, R9		
	if p != nil {
  0x40d339		4885d2			TESTQ DX, DX		
  0x40d33c		0f84e3020000		JE 0x40d625		
		b = uintptr(*p)
  0x40d342		440fb632		MOVZX 0(DX), R14	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40d346		48ffc2			INCQ DX			
  0x40d349		b908000000		MOVL $0x8, CX		
	if typ.size == dataSize {
  0x40d34e		4939f5			CMPQ SI, R13		
  0x40d351		0f859c020000		JNE 0x40d5f3		
		nw = typ.ptrdata / sys.PtrSize
  0x40d357		488b7308		MOVQ 0x8(BX), SI	
  0x40d35b		48c1ee03		SHRQ $0x3, SI		
	if nw == 0 {
  0x40d35f		4885f6			TESTQ SI, SI		
  0x40d362		0f84f9030000		JE 0x40d761		
	if nw < 2 {
  0x40d368		4883fe02		CMPQ $0x2, SI		
  0x40d36c		0f8379020000		JAE 0x40d5eb		
  0x40d372		bb02000000		MOVL $0x2, BX		
	case h.shift == 0:
  0x40d377		85c0			TESTL AX, AX		
  0x40d379		0f8516020000		JNE 0x40d595		
  0x40d37f		4c89f0			MOVQ R14, AX		
		hb = b & bitPointerAll
  0x40d382		4983e60f		ANDQ $0xf, R14		
		hb |= bitScan | bitScan<<(2*heapBitsShift) | bitScan<<(3*heapBitsShift)
  0x40d386		4981ced0000000		ORQ $0xd0, R14		
		if w += 4; w >= nw {
  0x40d38d		4883fb04		CMPQ $0x4, BX		
  0x40d391		0f878d000000		JA 0x40d424		
  0x40d397		b804000000		MOVL $0x4, AX		
	if w > nw {
  0x40d39c		4839d8			CMPQ BX, AX		
  0x40d39f		767e			JBE 0x40d41f		
  0x40d3a1		4889c2			MOVQ AX, DX		
		mask := uintptr(1)<<(4-(w-nw)) - 1
  0x40d3a4		4829d8			SUBQ BX, AX		
  0x40d3a7		488d48fc		LEAQ -0x4(AX), CX	
  0x40d3ab		48f7d9			NEGQ CX			
  0x40d3ae		b801000000		MOVL $0x1, AX		
  0x40d3b3		48d3e0			SHLQ CL, AX		
  0x40d3b6		4883f940		CMPQ $0x40, CX		
  0x40d3ba		4819db			SBBQ BX, BX		
  0x40d3bd		4821d8			ANDQ BX, AX		
  0x40d3c0		48ffc8			DECQ AX			
  0x40d3c3		4889c3			MOVQ AX, BX		
		hb &= mask | mask<<4 // apply mask to both pointer bits and scan bits
  0x40d3c6		48c1e004		SHLQ $0x4, AX		
  0x40d3ca		4809d8			ORQ BX, AX		
  0x40d3cd		4921c6			ANDQ AX, R14		
	nw = size / sys.PtrSize
  0x40d3d0		49c1eb03		SHRQ $0x3, R11		
	if w <= nw {
  0x40d3d4		4c39da			CMPQ R11, DX		
  0x40d3d7		773b			JA 0x40d414		
		*hbitp = uint8(hb)
  0x40d3d9		448837			MOVB R14, 0(DI)		
		for w += 4; w <= nw; w += 4 {
  0x40d3dc		488d4204		LEAQ 0x4(DX), AX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d3e0		488d4fff		LEAQ -0x1(DI), CX	
		for w += 4; w <= nw; w += 4 {
  0x40d3e4		eb0a			JMP 0x40d3f0		
			*hbitp = 0
  0x40d3e6		c60100			MOVB $0x0, 0(CX)	
		for w += 4; w <= nw; w += 4 {
  0x40d3e9		4883c004		ADDQ $0x4, AX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d3ed		48ffc9			DECQ CX			
		for w += 4; w <= nw; w += 4 {
  0x40d3f0		4c39d8			CMPQ R11, AX		
  0x40d3f3		76f1			JBE 0x40d3e6		
  0x40d3f5		31d2			XORL DX, DX		
	if w == nw+2 {
  0x40d3f7		498d5b02		LEAQ 0x2(R11), BX	
  0x40d3fb		4839c3			CMPQ AX, BX		
  0x40d3fe		750a			JNE 0x40d40a		
		*hbitp = *hbitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | uint8(hb)
  0x40d400		0fb601			MOVZX 0(CX), AX		
  0x40d403		83e0cc			ANDL $-0x34, AX		
  0x40d406		09c2			ORL AX, DX		
  0x40d408		8811			MOVB DL, 0(CX)		
  0x40d40a		488b6c2448		MOVQ 0x48(SP), BP	
  0x40d40f		4883c450		ADDQ $0x50, SP		
  0x40d413		c3			RET			
  0x40d414		4889d0			MOVQ DX, AX		
  0x40d417		4889f9			MOVQ DI, CX		
  0x40d41a		4c89f2			MOVQ R14, DX		
	if w <= nw {
  0x40d41d		ebd8			JMP 0x40d3f7		
  0x40d41f		4889c2			MOVQ AX, DX		
	if w > nw {
  0x40d422		ebac			JMP 0x40d3d0		
		*hbitp = uint8(hb)
  0x40d424		448837			MOVB R14, 0(DI)		
		b >>= 4
  0x40d427		48c1e804		SHRQ $0x4, AX		
		nb -= 4
  0x40d42b		488d71fc		LEAQ -0x4(CX), SI	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d42f		48ffcf			DECQ DI			
  0x40d432		b904000000		MOVL $0x4, CX		
	nb -= 4
  0x40d437		4883c6fc		ADDQ $-0x4, SI		
	for {
  0x40d43b		eb28			JMP 0x40d465		
		*hbitp = uint8(hb)
  0x40d43d		418406			TESTB AL, 0(R14)	
  0x40d440		49c7c6ffffffff		MOVQ $-0x1, R14		
  0x40d447		45882c3e		MOVB R13, 0(R14)(DI*1)	
		b >>= 4
  0x40d44b		48c1ea04		SHRQ $0x4, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d44f		4883c7fe		ADDQ $-0x2, DI		
  0x40d453		4989c5			MOVQ AX, R13		
  0x40d456		4889d0			MOVQ DX, AX		
  0x40d459		4c89ea			MOVQ R13, DX		
  0x40d45c		4989cf			MOVQ CX, R15		
  0x40d45f		4889f1			MOVQ SI, CX		
  0x40d462		4c89fe			MOVQ R15, SI		
		hb = b & bitPointerAll
  0x40d465		4989c5			MOVQ AX, R13		
  0x40d468		4883e00f		ANDQ $0xf, AX		
		hb |= bitScanAll
  0x40d46c		480df0000000		ORQ $0xf0, AX		
		if w += 4; w >= nw {
  0x40d472		4c8d7104		LEAQ 0x4(CX), R14	
  0x40d476		4939de			CMPQ BX, R14		
  0x40d479		0f8308010000		JAE 0x40d587		
		*hbitp = uint8(hb)
  0x40d47f		8807			MOVB AL, 0(DI)		
		b >>= 4
  0x40d481		49c1ed04		SHRQ $0x4, R13		
		if p != endp {
  0x40d485		4c39c2			CMPQ R8, DX		
  0x40d488		745f			JE 0x40d4e9		
			if nb < 8 {
  0x40d48a		4883fe08		CMPQ $0x8, SI		
  0x40d48e		734a			JAE 0x40d4da		
				b |= uintptr(*p) << nb
  0x40d490		0fb602			MOVZX 0(DX), AX		
  0x40d493		4989ce			MOVQ CX, R14		
  0x40d496		4889f1			MOVQ SI, CX		
  0x40d499		48d3e0			SHLQ CL, AX		
  0x40d49c		4883f940		CMPQ $0x40, CX		
  0x40d4a0		4d19ff			SBBQ R15, R15		
  0x40d4a3		4921c7			ANDQ AX, R15		
  0x40d4a6		4d09fd			ORQ R15, R13		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40d4a9		488d4201		LEAQ 0x1(DX), AX	
				p = add1(p)
  0x40d4ad		4c89ea			MOVQ R13, DX		
		hb = b & bitPointerAll
  0x40d4b0		4983e50f		ANDQ $0xf, R13		
		hb |= bitScanAll
  0x40d4b4		4981cdf0000000		ORQ $0xf0, R13		
		if w += 4; w >= nw {
  0x40d4bb		498d7608		LEAQ 0x8(R14), SI	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d4bf		4c8d77ff		LEAQ -0x1(DI), R14	
		if w += 4; w >= nw {
  0x40d4c3		4839de			CMPQ BX, SI		
  0x40d4c6		0f8271ffffff		JB 0x40d43d		
  0x40d4cc		4889f0			MOVQ SI, AX		
  0x40d4cf		4c89f7			MOVQ R14, DI		
  0x40d4d2		4d89ee			MOVQ R13, R14		
	if w > nw {
  0x40d4d5		e9c2feffff		JMP 0x40d39c		
				nb -= 8
  0x40d4da		4883c6f8		ADDQ $-0x8, SI		
  0x40d4de		4989ce			MOVQ CX, R14		
  0x40d4e1		4889d0			MOVQ DX, AX		
  0x40d4e4		4889f1			MOVQ SI, CX		
  0x40d4e7		ebc4			JMP 0x40d4ad		
		} else if p == nil {
  0x40d4e9		4885d2			TESTQ DX, DX		
  0x40d4ec		7456			JE 0x40d544		
			b |= uintptr(*p) << nb
  0x40d4ee		0fb602			MOVZX 0(DX), AX		
  0x40d4f1		4889ca			MOVQ CX, DX		
  0x40d4f4		4889f1			MOVQ SI, CX		
  0x40d4f7		48d3e0			SHLQ CL, AX		
  0x40d4fa		4883f940		CMPQ $0x40, CX		
  0x40d4fe		4d19f6			SBBQ R14, R14		
  0x40d501		4921c6			ANDQ AX, R14		
  0x40d504		4d09f5			ORQ R14, R13		
			nb += endnb
  0x40d507		4a8d0409		LEAQ 0(CX)(R9*1), AX	
			if nb < 8 {
  0x40d50b		4883f808		CMPQ $0x8, AX		
  0x40d50f		7329			JAE 0x40d53a		
				b |= uintptr(*ptrmask) << nb
  0x40d511		410fb632		MOVZX 0(R10), SI	
  0x40d515		4889c1			MOVQ AX, CX		
  0x40d518		48d3e6			SHLQ CL, SI		
  0x40d51b		4883f840		CMPQ $0x40, AX		
  0x40d51f		4d19f6			SBBQ R14, R14		
  0x40d522		4c21f6			ANDQ R14, SI		
  0x40d525		4909f5			ORQ SI, R13		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40d528		498d7201		LEAQ 0x1(R10), SI	
				p = add1(ptrmask)
  0x40d52c		4989d6			MOVQ DX, R14		
  0x40d52f		4889c1			MOVQ AX, CX		
  0x40d532		4889f0			MOVQ SI, AX		
		hb = b & bitPointerAll
  0x40d535		e973ffffff		JMP 0x40d4ad		
				nb -= 8
  0x40d53a		4a8d4409f8		LEAQ -0x8(CX)(R9*1), AX	
  0x40d53f		4c89d6			MOVQ R10, SI		
				p = ptrmask
  0x40d542		ebe8			JMP 0x40d52c		
			if nb < 8 {
  0x40d544		4883fe08		CMPQ $0x8, SI		
  0x40d548		7332			JAE 0x40d57c		
  0x40d54a		4889c8			MOVQ CX, AX		
  0x40d54d		4889f1			MOVQ SI, CX		
  0x40d550		4d89e6			MOVQ R12, R14		
				b |= pbits << nb
  0x40d553		49d3e4			SHLQ CL, R12		
  0x40d556		4883f940		CMPQ $0x40, CX		
  0x40d55a		4d19ff			SBBQ R15, R15		
  0x40d55d		4d21fc			ANDQ R15, R12		
  0x40d560		4d09ec			ORQ R13, R12		
				nb += endnb
  0x40d563		4a8d3409		LEAQ 0(CX)(R9*1), SI	
			nb -= 8 // for next iteration
  0x40d567		4c8d7ef8		LEAQ -0x8(SI), R15	
  0x40d56b		4889d6			MOVQ DX, SI		
  0x40d56e		4d89e5			MOVQ R12, R13		
  0x40d571		4889c2			MOVQ AX, DX		
  0x40d574		4d89f4			MOVQ R14, R12		
  0x40d577		4c89f8			MOVQ R15, AX		
  0x40d57a		ebb0			JMP 0x40d52c		
  0x40d57c		4889c8			MOVQ CX, AX		
  0x40d57f		4d89e6			MOVQ R12, R14		
  0x40d582		4d89ec			MOVQ R13, R12		
			if nb < 8 {
  0x40d585		ebe0			JMP 0x40d567		
  0x40d587		4c89f6			MOVQ R14, SI		
  0x40d58a		4989fe			MOVQ DI, R14		
  0x40d58d		4989c5			MOVQ AX, R13		
			break
  0x40d590		e937ffffff		JMP 0x40d4cc		
	case sys.PtrSize == 8 && h.shift == 2:
  0x40d595		83f802			CMPL $0x2, AX		
  0x40d598		0f85a8010000		JNE 0x40d746		
  0x40d59e		4c89f0			MOVQ R14, AX		
		hb = (b & (bitPointer | bitPointer<<heapBitsShift)) << (2 * heapBitsShift)
  0x40d5a1		4983e603		ANDQ $0x3, R14		
  0x40d5a5		49c1e602		SHLQ $0x2, R14		
		hb |= bitScan << (2 * heapBitsShift)
  0x40d5a9		4983ce40		ORQ $0x40, R14		
		*hbitp &^= uint8((bitPointer | bitScan | (bitPointer << heapBitsShift)) << (2 * heapBitsShift))
  0x40d5ad		0fb637			MOVZX 0(DI), SI		
  0x40d5b0		83e6b3			ANDL $-0x4d, SI		
		*hbitp |= uint8(hb)
  0x40d5b3		4409f6			ORL R14, SI		
  0x40d5b6		408837			MOVB SI, 0(DI)		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40d5b9		488d77ff		LEAQ -0x1(DI), SI	
		if w += 2; w >= nw {
  0x40d5bd		4883fb02		CMPQ $0x2, BX		
  0x40d5c1		7710			JA 0x40d5d3		
  0x40d5c3		b806000000		MOVL $0x6, AX		
  0x40d5c8		4889f7			MOVQ SI, DI		
  0x40d5cb		4531f6			XORL R14, R14		
			goto Phase3
  0x40d5ce		e9c9fdffff		JMP 0x40d39c		
		b >>= 2
  0x40d5d3		48c1e802		SHRQ $0x2, AX		
		nb -= 2
  0x40d5d7		4c8d69fe		LEAQ -0x2(CX), R13	
  0x40d5db		b902000000		MOVL $0x2, CX		
  0x40d5e0		4889f7			MOVQ SI, DI		
  0x40d5e3		4c89ee			MOVQ R13, SI		
	switch {
  0x40d5e6		e94cfeffff		JMP 0x40d437		
  0x40d5eb		4889f3			MOVQ SI, BX		
	if nw < 2 {
  0x40d5ee		e984fdffff		JMP 0x40d377		
		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
  0x40d5f3		4885f6			TESTQ SI, SI		
  0x40d5f6		0f84dd010000		JE 0x40d7d9		
  0x40d5fc		4989c7			MOVQ AX, R15		
  0x40d5ff		4c89e8			MOVQ R13, AX		
  0x40d602		4989d5			MOVQ DX, R13		
  0x40d605		31d2			XORL DX, DX		
  0x40d607		48f7f6			DIVQ SI			
  0x40d60a		4c89ea			MOVQ R13, DX		
  0x40d60d		4c8d68ff		LEAQ -0x1(AX), R13	
  0x40d611		490faff5		IMULQ R13, SI		
  0x40d615		48037308		ADDQ 0x8(BX), SI	
  0x40d619		48c1ee03		SHRQ $0x3, SI		
  0x40d61d		4c89f8			MOVQ R15, AX		
  0x40d620		e93afdffff		JMP 0x40d35f		
  0x40d625		4d89e6			MOVQ R12, R14		
	if p != nil {
  0x40d628		e921fdffff		JMP 0x40d34e		
  0x40d62d		4989d3			MOVQ DX, R11		
  0x40d630		4989c5			MOVQ AX, R13		
  0x40d633		4889c8			MOVQ CX, AX		
  0x40d636		4c89c1			MOVQ R8, CX		
			if nb+nb <= maxBits {
  0x40d639		e9f3fcffff		JMP 0x40d331		
			n := (typ.ptrdata/sys.PtrSize+7)/8 - 1
  0x40d63e		4d8d7107		LEAQ 0x7(R9), R14	
  0x40d642		49c1ee03		SHRQ $0x3, R14		
  0x40d646		4d8d7eff		LEAQ -0x1(R14), R15	
  0x40d64a		4d89c1			MOVQ R8, R9		
			endnb = typ.size/sys.PtrSize - n*8
  0x40d64d		49c1e903		SHRQ $0x3, R9		
  0x40d651		49c1e703		SHLQ $0x3, R15		
  0x40d655		4d29f9			SUBQ R15, R9		
  0x40d658		4989f2			MOVQ SI, R10		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40d65b		4e8d7436ff		LEAQ -0x1(SI)(R14*1), R14	
  0x40d660		4c89c6			MOVQ R8, SI			
  0x40d663		4989d3			MOVQ DX, R11			
  0x40d666		4989c5			MOVQ AX, R13			
  0x40d669		4c89d2			MOVQ R10, DX			
  0x40d66c		4d89f0			MOVQ R14, R8			
  0x40d66f		4531e4			XORL R12, R12			
  0x40d672		4889c8			MOVQ CX, AX			
  0x40d675		31c9			XORL CX, CX			
			endnb = typ.size/sys.PtrSize - n*8
  0x40d677		e9bdfcffff		JMP 0x40d339		
  0x40d67c		4989f2			MOVQ SI, R10		
  0x40d67f		4989d3			MOVQ DX, R11		
  0x40d682		4989c5			MOVQ AX, R13		
  0x40d685		4c89d2			MOVQ R10, DX		
  0x40d688		4531e4			XORL R12, R12		
  0x40d68b		4d89e1			MOVQ R12, R9		
  0x40d68e		4889c8			MOVQ CX, AX		
  0x40d691		4c89c6			MOVQ R8, SI		
  0x40d694		4c89c9			MOVQ R9, CX		
  0x40d697		4531c0			XORL R8, R8		
	if typ.size < dataSize {
  0x40d69a		e99afcffff		JMP 0x40d339		
		heapBitsSetTypeGCProg(h, typ.ptrdata, typ.size, dataSize, size, addb(typ.gcdata, 4))
  0x40d69f		488b4308		MOVQ 0x8(BX), AX	
  0x40d6a3		488b1b			MOVQ 0(BX), BX		
  0x40d6a6		48895c2418		MOVQ BX, 0x18(SP)	
  0x40d6ab		48893c24		MOVQ DI, 0(SP)		
  0x40d6af		894c2408		MOVL CX, 0x8(SP)	
  0x40d6b3		4889442410		MOVQ AX, 0x10(SP)	
  0x40d6b8		488b442468		MOVQ 0x68(SP), AX	
  0x40d6bd		4889442420		MOVQ AX, 0x20(SP)	
  0x40d6c2		4889542428		MOVQ DX, 0x28(SP)	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40d6c7		488d4604		LEAQ 0x4(SI), AX	
		heapBitsSetTypeGCProg(h, typ.ptrdata, typ.size, dataSize, size, addb(typ.gcdata, 4))
  0x40d6cb		4889442430		MOVQ AX, 0x30(SP)			
  0x40d6d0		e82b010000		CALL runtime.heapBitsSetTypeGCProg(SB)	
		return
  0x40d6d5		488b6c2448		MOVQ 0x48(SP), BP	
  0x40d6da		4883c450		ADDQ $0x50, SP		
  0x40d6de		c3			RET			
		if typ.size == sys.PtrSize {
  0x40d6df		488b03			MOVQ 0(BX), AX		
  0x40d6e2		4883f808		CMPQ $0x8, AX		
  0x40d6e6		751f			JNE 0x40d707		
				*h.bitp |= (bitPointer | bitScan | bitPointer<<heapBitsShift) << h.shift
  0x40d6e8		0fb607			MOVZX 0(DI), AX		
  0x40d6eb		ba13000000		MOVL $0x13, DX		
  0x40d6f0		d3e2			SHLL CL, DX		
  0x40d6f2		83f920			CMPL $0x20, CX		
  0x40d6f5		19db			SBBL BX, BX		
  0x40d6f7		21da			ANDL BX, DX		
  0x40d6f9		09d0			ORL DX, AX		
  0x40d6fb		8807			MOVB AL, 0(DI)		
			return
  0x40d6fd		488b6c2448		MOVQ 0x48(SP), BP	
  0x40d702		4883c450		ADDQ $0x50, SP		
  0x40d706		c3			RET			
		b := uint32(*ptrmask)
  0x40d707		0fb606			MOVZX 0(SI), AX		
		hb := (b & 3) | bitScan
  0x40d70a		83e003			ANDL $0x3, AX		
  0x40d70d		83c810			ORL $0x10, AX		
		*h.bitp &^= (bitPointer | bitScan | ((bitPointer | bitScan) << heapBitsShift)) << h.shift
  0x40d710		0fb617			MOVZX 0(DI), DX		
  0x40d713		bb33000000		MOVL $0x33, BX		
  0x40d718		d3e3			SHLL CL, BX		
		*h.bitp |= uint8(hb << h.shift)
  0x40d71a		83f920			CMPL $0x20, CX		
		*h.bitp &^= (bitPointer | bitScan | ((bitPointer | bitScan) << heapBitsShift)) << h.shift
  0x40d71d		19f6			SBBL SI, SI		
  0x40d71f		21f3			ANDL SI, BX		
  0x40d721		f7d3			NOTL BX			
  0x40d723		21d3			ANDL DX, BX		
		*h.bitp |= uint8(hb << h.shift)
  0x40d725		d3e0			SHLL CL, AX		
  0x40d727		83f920			CMPL $0x20, CX		
  0x40d72a		19d2			SBBL DX, DX		
  0x40d72c		21d0			ANDL DX, AX		
  0x40d72e		09d8			ORL BX, AX		
  0x40d730		8807			MOVB AL, 0(DI)		
		return
  0x40d732		488b6c2448		MOVQ 0x48(SP), BP	
  0x40d737		4883c450		ADDQ $0x50, SP		
  0x40d73b		c3			RET			
		return
  0x40d73c		488b6c2448		MOVQ 0x48(SP), BP	
  0x40d741		4883c450		ADDQ $0x50, SP		
  0x40d745		c3			RET			
		throw("heapBitsSetType: unexpected shift")
  0x40d746		488d05dcf20500		LEAQ 0x5f2dc(IP), AX	
  0x40d74d		48890424		MOVQ AX, 0(SP)		
  0x40d751		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x40d75a		e8713a0100		CALL runtime.throw(SB)	
  0x40d75f		0f0b			UD2			
		println("runtime: invalid type ", typ.string())
  0x40d761		48891c24		MOVQ BX, 0(SP)				
  0x40d765		e806120300		CALL runtime.(*_type).string(SB)	
  0x40d76a		488b442410		MOVQ 0x10(SP), AX			
  0x40d76f		4889442438		MOVQ AX, 0x38(SP)			
  0x40d774		488b4c2408		MOVQ 0x8(SP), CX			
  0x40d779		48894c2440		MOVQ CX, 0x40(SP)			
  0x40d77e		e87d430100		CALL runtime.printlock(SB)		
  0x40d783		488d05d6df0500		LEAQ 0x5dfd6(IP), AX			
  0x40d78a		48890424		MOVQ AX, 0(SP)				
  0x40d78e		48c744240817000000	MOVQ $0x17, 0x8(SP)			
  0x40d797		e8a44c0100		CALL runtime.printstring(SB)		
  0x40d79c		488b442440		MOVQ 0x40(SP), AX			
  0x40d7a1		48890424		MOVQ AX, 0(SP)				
  0x40d7a5		488b442438		MOVQ 0x38(SP), AX			
  0x40d7aa		4889442408		MOVQ AX, 0x8(SP)			
  0x40d7af		e88c4c0100		CALL runtime.printstring(SB)		
  0x40d7b4		e8d7450100		CALL runtime.printnl(SB)		
  0x40d7b9		e8c2430100		CALL runtime.printunlock(SB)		
		throw("heapBitsSetType: called with non-pointer type")
  0x40d7be		488d050dff0500		LEAQ 0x5ff0d(IP), AX	
  0x40d7c5		48890424		MOVQ AX, 0(SP)		
  0x40d7c9		48c74424082d000000	MOVQ $0x2d, 0x8(SP)	
  0x40d7d2		e8f9390100		CALL runtime.throw(SB)	
  0x40d7d7		0f0b			UD2			
		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
  0x40d7d9		e842230100		CALL runtime.panicdivide(SB)	
  0x40d7de		0f0b			UD2				
				endnb = uintptr(maxBits/byte(nb)) * nb
  0x40d7e0		e83b230100		CALL runtime.panicdivide(SB)	
  0x40d7e5		0f0b			UD2				
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40d7e7		e8846d0300		CALL runtime.morestack_noctxt(SB)	
  0x40d7ec		e9dff9ffff		JMP runtime.heapBitsSetType(SB)		

TEXT runtime.heapBitsSetTypeGCProg(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func heapBitsSetTypeGCProg(h heapBits, progSize, elemSize, dataSize, allocSize uintptr, prog *byte) {
  0x40d800		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40d809		483b6110		CMPQ 0x10(CX), SP	
  0x40d80d		0f864f030000		JBE 0x40db62		
  0x40d813		4883ec60		SUBQ $0x60, SP		
  0x40d817		48896c2458		MOVQ BP, 0x58(SP)	
  0x40d81c		488d6c2458		LEAQ 0x58(SP), BP	
  0x40d821		488b8c2490000000	MOVQ 0x90(SP), CX	
	if sys.PtrSize == 8 && allocSize%(4*sys.PtrSize) != 0 {
  0x40d829		48f7c11f000000		TESTQ $0x1f, CX		
  0x40d830		0f8511030000		JNE 0x40db47		
  0x40d836		488b942480000000	MOVQ 0x80(SP), DX	
  0x40d83e		488b842488000000	MOVQ 0x88(SP), AX	
	if elemSize == dataSize {
  0x40d846		4839c2			CMPQ AX, DX		
  0x40d849		0f84f1010000		JE 0x40da40		
		count := dataSize / elemSize
  0x40d84f		4885d2			TESTQ DX, DX		
  0x40d852		0f846b020000		JE 0x40dac3		
  0x40d858		4889d3			MOVQ DX, BX		
  0x40d85b		31d2			XORL DX, DX		
  0x40d85d		48f7f3			DIVQ BX			
		var trailer [40]byte // 3 varints (max 10 each) + some bytes
  0x40d860		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x40d869		0f57c0			XORPS X0, X0		
  0x40d86c		0f11442438		MOVUPS X0, 0x38(SP)	
  0x40d871		0f11442448		MOVUPS X0, 0x48(SP)	
  0x40d876		4889da			MOVQ BX, DX		
		if n := elemSize/sys.PtrSize - progSize/sys.PtrSize; n > 0 {
  0x40d879		48c1eb03		SHRQ $0x3, BX		
  0x40d87d		488b742478		MOVQ 0x78(SP), SI	
  0x40d882		4889f7			MOVQ SI, DI		
  0x40d885		48c1ee03		SHRQ $0x3, SI		
  0x40d889		4989d8			MOVQ BX, R8		
  0x40d88c		4829f3			SUBQ SI, BX		
  0x40d88f		4885db			TESTQ BX, BX		
  0x40d892		0f86a1010000		JBE 0x40da39		
			trailer[i] = 0
  0x40d898		66c74424300100		MOVW $0x1, 0x30(SP)	
			if n > 1 {
  0x40d89f		4883fb01		CMPQ $0x1, BX		
  0x40d8a3		0f8686010000		JBE 0x40da2f		
				trailer[i] = 0x81
  0x40d8a9		c644243281		MOVB $0x81, 0x32(SP)	
				n--
  0x40d8ae		48ffcb			DECQ BX			
  0x40d8b1		be03000000		MOVL $0x3, SI		
				for ; n >= 0x80; n >>= 7 {
  0x40d8b6		eb18			JMP 0x40d8d0		
  0x40d8b8		4989d9			MOVQ BX, R9		
					trailer[i] = byte(n | 0x80)
  0x40d8bb		4881cb80000000		ORQ $0x80, BX		
  0x40d8c2		885c3430		MOVB BL, 0x30(SP)(SI*1)	
				for ; n >= 0x80; n >>= 7 {
  0x40d8c6		49c1e907		SHRQ $0x7, R9		
					i++
  0x40d8ca		48ffc6			INCQ SI			
  0x40d8cd		4c89cb			MOVQ R9, BX		
				for ; n >= 0x80; n >>= 7 {
  0x40d8d0		4881fb80000000		CMPQ $0x80, BX		
  0x40d8d7		720b			JB 0x40d8e4		
					trailer[i] = byte(n | 0x80)
  0x40d8d9		4883fe28		CMPQ $0x28, SI		
  0x40d8dd		72d9			JB 0x40d8b8		
  0x40d8df		e9d8010000		JMP 0x40dabc		
				trailer[i] = byte(n)
  0x40d8e4		4883fe28		CMPQ $0x28, SI		
  0x40d8e8		0f83c7010000		JAE 0x40dab5		
  0x40d8ee		885c3430		MOVB BL, 0x30(SP)(SI*1)	
				i++
  0x40d8f2		488d5e01		LEAQ 0x1(SI), BX	
		trailer[i] = 0x80
  0x40d8f6		4883fb28		CMPQ $0x28, BX			
  0x40d8fa		0f83ae010000		JAE 0x40daae			
  0x40d900		c6441c3080		MOVB $0x80, 0x30(SP)(BX*1)	
		i++
  0x40d905		48ffc3			INCQ BX			
		for ; n >= 0x80; n >>= 7 {
  0x40d908		eb19			JMP 0x40d923		
  0x40d90a		4c89c6			MOVQ R8, SI		
			trailer[i] = byte(n | 0x80)
  0x40d90d		4981c880000000		ORQ $0x80, R8		
  0x40d914		4488441c30		MOVB R8, 0x30(SP)(BX*1)	
		for ; n >= 0x80; n >>= 7 {
  0x40d919		48c1ee07		SHRQ $0x7, SI		
			i++
  0x40d91d		48ffc3			INCQ BX			
  0x40d920		4989f0			MOVQ SI, R8		
		for ; n >= 0x80; n >>= 7 {
  0x40d923		4981f880000000		CMPQ $0x80, R8		
  0x40d92a		720b			JB 0x40d937		
			trailer[i] = byte(n | 0x80)
  0x40d92c		4883fb28		CMPQ $0x28, BX		
  0x40d930		72d8			JB 0x40d90a		
  0x40d932		e970010000		JMP 0x40daa7		
		trailer[i] = byte(n)
  0x40d937		4883fb28		CMPQ $0x28, BX		
  0x40d93b		0f835f010000		JAE 0x40daa0		
  0x40d941		4488441c30		MOVB R8, 0x30(SP)(BX*1)	
		i++
  0x40d946		48ffc3			INCQ BX			
		n = count - 1
  0x40d949		48ffc8			DECQ AX			
  0x40d94c		4889c6			MOVQ AX, SI		
		for ; n >= 0x80; n >>= 7 {
  0x40d94f		eb17			JMP 0x40d968		
  0x40d951		4989c0			MOVQ AX, R8		
			trailer[i] = byte(n | 0x80)
  0x40d954		480d80000000		ORQ $0x80, AX		
  0x40d95a		88441c30		MOVB AL, 0x30(SP)(BX*1)	
		for ; n >= 0x80; n >>= 7 {
  0x40d95e		49c1e807		SHRQ $0x7, R8		
			i++
  0x40d962		48ffc3			INCQ BX			
  0x40d965		4c89c0			MOVQ R8, AX		
		for ; n >= 0x80; n >>= 7 {
  0x40d968		483d80000000		CMPQ $0x80, AX		
  0x40d96e		720b			JB 0x40d97b		
			trailer[i] = byte(n | 0x80)
  0x40d970		4883fb28		CMPQ $0x28, BX		
  0x40d974		72db			JB 0x40d951		
  0x40d976		e91e010000		JMP 0x40da99		
		trailer[i] = byte(n)
  0x40d97b		4883fb28		CMPQ $0x28, BX		
  0x40d97f		0f830d010000		JAE 0x40da92		
  0x40d985		88441c30		MOVB AL, 0x30(SP)(BX*1)	
		i++
  0x40d989		488d4301		LEAQ 0x1(BX), AX	
		trailer[i] = 0
  0x40d98d		4883f828		CMPQ $0x28, AX			
  0x40d991		0f83f4000000		JAE 0x40da8b			
  0x40d997		4889742428		MOVQ SI, 0x28(SP)		
  0x40d99c		c6441c3100		MOVB $0x0, 0x31(SP)(BX*1)	
		runGCProg(prog, &trailer[0], h.bitp, 2)
  0x40d9a1		488d442430		LEAQ 0x30(SP), AX		
  0x40d9a6		4889442408		MOVQ AX, 0x8(SP)		
  0x40d9ab		488b842498000000	MOVQ 0x98(SP), AX		
  0x40d9b3		48890424		MOVQ AX, 0(SP)			
  0x40d9b7		488b442468		MOVQ 0x68(SP), AX		
  0x40d9bc		4889442410		MOVQ AX, 0x10(SP)		
  0x40d9c1		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x40d9ca		e8c1020000		CALL runtime.runGCProg(SB)	
  0x40d9cf		488b842480000000	MOVQ 0x80(SP), AX		
  0x40d9d7		488b4c2428		MOVQ 0x28(SP), CX		
		totalBits = (elemSize*(count-1) + progSize) / sys.PtrSize
  0x40d9dc		480fafc1		IMULQ CX, AX		
  0x40d9e0		488b4c2478		MOVQ 0x78(SP), CX	
  0x40d9e5		4801c8			ADDQ CX, AX		
  0x40d9e8		48c1e803		SHRQ $0x3, AX		
	endProg := unsafe.Pointer(subtractb(h.bitp, (totalBits+3)/4))
  0x40d9ec		4883c003		ADDQ $0x3, AX		
  0x40d9f0		48c1e802		SHRQ $0x2, AX		
  0x40d9f4		488b8c2490000000	MOVQ 0x90(SP), CX	
	endAlloc := unsafe.Pointer(subtractb(h.bitp, allocSize/heapBitmapScale))
  0x40d9fc		48c1e905		SHRQ $0x5, CX		
  0x40da00		488b542468		MOVQ 0x68(SP), DX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))
  0x40da05		4889d3			MOVQ DX, BX		
  0x40da08		4829c2			SUBQ AX, DX		
  0x40da0b		4829cb			SUBQ CX, BX		
  0x40da0e		4889d8			MOVQ BX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x40da11		48ffc0			INCQ AX			
	memclrNoHeapPointers(add(endAlloc, 1), uintptr(endProg)-uintptr(endAlloc))
  0x40da14		48890424		MOVQ AX, 0(SP)				
  0x40da18		4829da			SUBQ BX, DX				
  0x40da1b		4889542408		MOVQ DX, 0x8(SP)			
  0x40da20		e84b940300		CALL runtime.memclrNoHeapPointers(SB)	
}
  0x40da25		488b6c2458		MOVQ 0x58(SP), BP	
  0x40da2a		4883c460		ADDQ $0x60, SP		
  0x40da2e		c3			RET			
  0x40da2f		bb02000000		MOVL $0x2, BX		
			if n > 1 {
  0x40da34		e9bdfeffff		JMP 0x40d8f6		
  0x40da39		31db			XORL BX, BX		
		if n := elemSize/sys.PtrSize - progSize/sys.PtrSize; n > 0 {
  0x40da3b		e9b6feffff		JMP 0x40d8f6		
  0x40da40		488b842498000000	MOVQ 0x98(SP), AX	
		totalBits = runGCProg(prog, nil, h.bitp, 2)
  0x40da48		48890424		MOVQ AX, 0(SP)			
  0x40da4c		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x40da55		488b442468		MOVQ 0x68(SP), AX		
  0x40da5a		4889442410		MOVQ AX, 0x10(SP)		
  0x40da5f		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x40da68		e823020000		CALL runtime.runGCProg(SB)	
  0x40da6d		488b442420		MOVQ 0x20(SP), AX		
  0x40da72		4889c1			MOVQ AX, CX			
		if totalBits*sys.PtrSize != progSize {
  0x40da75		48c1e003		SHLQ $0x3, AX		
  0x40da79		488b542478		MOVQ 0x78(SP), DX	
  0x40da7e		4839d0			CMPQ DX, AX		
  0x40da81		7547			JNE 0x40daca		
  0x40da83		4889c8			MOVQ CX, AX		
	endProg := unsafe.Pointer(subtractb(h.bitp, (totalBits+3)/4))
  0x40da86		e961ffffff		JMP 0x40d9ec		
		trailer[i] = 0
  0x40da8b		e8b01f0100		CALL runtime.panicindex(SB)	
  0x40da90		0f0b			UD2				
		trailer[i] = byte(n)
  0x40da92		e8a91f0100		CALL runtime.panicindex(SB)	
  0x40da97		0f0b			UD2				
			trailer[i] = byte(n | 0x80)
  0x40da99		e8a21f0100		CALL runtime.panicindex(SB)	
  0x40da9e		0f0b			UD2				
		trailer[i] = byte(n)
  0x40daa0		e89b1f0100		CALL runtime.panicindex(SB)	
  0x40daa5		0f0b			UD2				
			trailer[i] = byte(n | 0x80)
  0x40daa7		e8941f0100		CALL runtime.panicindex(SB)	
  0x40daac		0f0b			UD2				
		trailer[i] = 0x80
  0x40daae		e88d1f0100		CALL runtime.panicindex(SB)	
  0x40dab3		0f0b			UD2				
				trailer[i] = byte(n)
  0x40dab5		e8861f0100		CALL runtime.panicindex(SB)	
  0x40daba		0f0b			UD2				
					trailer[i] = byte(n | 0x80)
  0x40dabc		e87f1f0100		CALL runtime.panicindex(SB)	
  0x40dac1		0f0b			UD2				
		count := dataSize / elemSize
  0x40dac3		e858200100		CALL runtime.panicdivide(SB)	
  0x40dac8		0f0b			UD2				
  0x40daca		48894c2428		MOVQ CX, 0x28(SP)		
			println("runtime: heapBitsSetTypeGCProg: total bits", totalBits, "but progSize", progSize)
  0x40dacf		e82c400100		CALL runtime.printlock(SB)	
  0x40dad4		488d05c5fa0500		LEAQ 0x5fac5(IP), AX		
  0x40dadb		48890424		MOVQ AX, 0(SP)			
  0x40dadf		48c74424082b000000	MOVQ $0x2b, 0x8(SP)		
  0x40dae8		e853490100		CALL runtime.printstring(SB)	
  0x40daed		488b442428		MOVQ 0x28(SP), AX		
  0x40daf2		48890424		MOVQ AX, 0(SP)			
  0x40daf6		e875460100		CALL runtime.printuint(SB)	
  0x40dafb		488d05cecc0500		LEAQ 0x5ccce(IP), AX		
  0x40db02		48890424		MOVQ AX, 0(SP)			
  0x40db06		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x40db0f		e82c490100		CALL runtime.printstring(SB)	
  0x40db14		488b442478		MOVQ 0x78(SP), AX		
  0x40db19		48890424		MOVQ AX, 0(SP)			
  0x40db1d		e84e460100		CALL runtime.printuint(SB)	
  0x40db22		e869420100		CALL runtime.printnl(SB)	
  0x40db27		e854400100		CALL runtime.printunlock(SB)	
			throw("heapBitsSetTypeGCProg: unexpected bit count")
  0x40db2c		488d0517fa0500		LEAQ 0x5fa17(IP), AX	
  0x40db33		48890424		MOVQ AX, 0(SP)		
  0x40db37		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x40db40		e88b360100		CALL runtime.throw(SB)	
  0x40db45		0f0b			UD2			
		throw("heapBitsSetTypeGCProg: small allocation")
  0x40db47		488d05dff50500		LEAQ 0x5f5df(IP), AX	
  0x40db4e		48890424		MOVQ AX, 0(SP)		
  0x40db52		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x40db5b		e870360100		CALL runtime.throw(SB)	
  0x40db60		0f0b			UD2			
func heapBitsSetTypeGCProg(h heapBits, progSize, elemSize, dataSize, allocSize uintptr, prog *byte) {
  0x40db62		e8096a0300		CALL runtime.morestack_noctxt(SB)	
  0x40db67		e994fcffff		JMP runtime.heapBitsSetTypeGCProg(SB)	

TEXT runtime.progToPointerMask(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func progToPointerMask(prog *byte, size uintptr) bitvector {
  0x40db70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40db79		483b6110		CMPQ 0x10(CX), SP	
  0x40db7d		0f8600010000		JBE 0x40dc83		
  0x40db83		4883ec48		SUBQ $0x48, SP		
  0x40db87		48896c2440		MOVQ BP, 0x40(SP)	
  0x40db8c		488d6c2440		LEAQ 0x40(SP), BP	
  0x40db91		488b442458		MOVQ 0x58(SP), AX	
	n := (size/sys.PtrSize + 7) / 8
  0x40db96		48c1e803		SHRQ $0x3, AX		
  0x40db9a		4883c007		ADDQ $0x7, AX		
  0x40db9e		48c1e803		SHRQ $0x3, AX		
  0x40dba2		4889442430		MOVQ AX, 0x30(SP)	
	x := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]
  0x40dba7		488d4801		LEAQ 0x1(AX), CX			
  0x40dbab		48894c2428		MOVQ CX, 0x28(SP)			
  0x40dbb0		48890c24		MOVQ CX, 0(SP)				
  0x40dbb4		48c744240801000000	MOVQ $0x1, 0x8(SP)			
  0x40dbbd		488d15cc6b0b00		LEAQ runtime.memstats+144(SB), DX	
  0x40dbc4		4889542410		MOVQ DX, 0x10(SP)			
  0x40dbc9		e8d2d8ffff		CALL runtime.persistentalloc(SB)	
  0x40dbce		488b442418		MOVQ 0x18(SP), AX			
  0x40dbd3		8400			TESTB AL, 0(AX)				
func progToPointerMask(prog *byte, size uintptr) bitvector {
  0x40dbd5		488b4c2428		MOVQ 0x28(SP), CX	
	x := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]
  0x40dbda		4881f900000040		CMPQ $0x40000000, CX	
  0x40dbe1		0f8795000000		JA 0x40dc7c		
  0x40dbe7		488b542430		MOVQ 0x30(SP), DX	
	x[len(x)-1] = 0xa1 // overflow check sentinel
  0x40dbec		4839ca			CMPQ CX, DX		
  0x40dbef		0f8380000000		JAE 0x40dc75		
  0x40dbf5		c60402a1		MOVB $0xa1, 0(DX)(AX*1)	
	n = runGCProg(prog, nil, &x[0], 1)
  0x40dbf9		4885c9			TESTQ CX, CX			
  0x40dbfc		7670			JBE 0x40dc6e			
  0x40dbfe		4889442438		MOVQ AX, 0x38(SP)		
  0x40dc03		4889442410		MOVQ AX, 0x10(SP)		
  0x40dc08		488b4c2450		MOVQ 0x50(SP), CX		
  0x40dc0d		48890c24		MOVQ CX, 0(SP)			
  0x40dc11		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x40dc1a		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x40dc23		e868000000		CALL runtime.runGCProg(SB)	
  0x40dc28		488b442420		MOVQ 0x20(SP), AX		
  0x40dc2d		488b4c2438		MOVQ 0x38(SP), CX		
  0x40dc32		488b542430		MOVQ 0x30(SP), DX		
	if x[len(x)-1] != 0xa1 {
  0x40dc37		0fb6140a		MOVZX 0(DX)(CX*1), DX	
  0x40dc3b		80faa1			CMPL $0xa1, DL		
  0x40dc3e		7513			JNE 0x40dc53		
	return bitvector{int32(n), &x[0]}
  0x40dc40		89442460		MOVL AX, 0x60(SP)	
  0x40dc44		48894c2468		MOVQ CX, 0x68(SP)	
  0x40dc49		488b6c2440		MOVQ 0x40(SP), BP	
  0x40dc4e		4883c448		ADDQ $0x48, SP		
  0x40dc52		c3			RET			
		throw("progToPointerMask: overflow")
  0x40dc53		488d05aee10500		LEAQ 0x5e1ae(IP), AX	
  0x40dc5a		48890424		MOVQ AX, 0(SP)		
  0x40dc5e		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x40dc67		e864350100		CALL runtime.throw(SB)	
  0x40dc6c		0f0b			UD2			
	n = runGCProg(prog, nil, &x[0], 1)
  0x40dc6e		e8cd1d0100		CALL runtime.panicindex(SB)	
  0x40dc73		0f0b			UD2				
	x[len(x)-1] = 0xa1 // overflow check sentinel
  0x40dc75		e8c61d0100		CALL runtime.panicindex(SB)	
  0x40dc7a		0f0b			UD2				
	x := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]
  0x40dc7c		e82f1e0100		CALL runtime.panicslice(SB)	
  0x40dc81		0f0b			UD2				
func progToPointerMask(prog *byte, size uintptr) bitvector {
  0x40dc83		e8e8680300		CALL runtime.morestack_noctxt(SB)	
  0x40dc88		e9e3feffff		JMP runtime.progToPointerMask(SB)	

TEXT runtime.runGCProg(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbitmap.go
func runGCProg(prog, trailer, dst *byte, size int) uintptr {
  0x40dc90		4883ec08		SUBQ $0x8, SP		
  0x40dc94		48892c24		MOVQ BP, 0(SP)		
  0x40dc98		488d2c24		LEAQ 0(SP), BP		
  0x40dc9c		488b542420		MOVQ 0x20(SP), DX	
  0x40dca1		488b5c2428		MOVQ 0x28(SP), BX	
  0x40dca6		488b742418		MOVQ 0x18(SP), SI	
  0x40dcab		488b7c2410		MOVQ 0x10(SP), DI	
  0x40dcb0		4889d0			MOVQ DX, AX		
  0x40dcb3		31c9			XORL CX, CX		
  0x40dcb5		4989c8			MOVQ CX, R8		
		for ; nbits >= 8; nbits -= 8 {
  0x40dcb8		eb04			JMP 0x40dcbe		
  0x40dcba		4883c1f8		ADDQ $-0x8, CX		
  0x40dcbe		4883f908		CMPQ $0x8, CX		
  0x40dcc2		7251			JB 0x40dd15		
			if size == 1 {
  0x40dcc4		4883fb01		CMPQ $0x1, BX		
  0x40dcc8		750c			JNE 0x40dcd6		
				*dst = uint8(bits)
  0x40dcca		448802			MOVB R8, 0(DX)		
				bits >>= 8
  0x40dccd		49c1e808		SHRQ $0x8, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40dcd1		48ffc2			INCQ DX			
				bits >>= 8
  0x40dcd4		ebe4			JMP 0x40dcba		
  0x40dcd6		4d89c1			MOVQ R8, R9		
				v := bits&bitPointerAll | bitScanAll
  0x40dcd9		4983e00f		ANDQ $0xf, R8		
  0x40dcdd		4981c8f0000000		ORQ $0xf0, R8		
				*dst = uint8(v)
  0x40dce4		448802			MOVB R8, 0(DX)		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40dce7		4c8d52ff		LEAQ -0x1(DX), R10	
				*dst = uint8(v)
  0x40dceb		418402			TESTB AL, 0(R10)	
  0x40dcee		4d89c8			MOVQ R9, R8		
				bits >>= 4
  0x40dcf1		49c1e904		SHRQ $0x4, R9		
				v = bits&bitPointerAll | bitScanAll
  0x40dcf5		4983e10f		ANDQ $0xf, R9		
  0x40dcf9		4981c9f0000000		ORQ $0xf0, R9		
				*dst = uint8(v)
  0x40dd00		49c7c2ffffffff		MOVQ $-0x1, R10		
  0x40dd07		46880c12		MOVB R9, 0(DX)(R10*1)	
				bits >>= 4
  0x40dd0b		49c1e808		SHRQ $0x8, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40dd0f		4883c2fe		ADDQ $-0x2, DX		
				bits >>= 4
  0x40dd13		eba5			JMP 0x40dcba		
		inst := uintptr(*p)
  0x40dd15		440fb60f		MOVZX 0(DI), R9		
  0x40dd19		4d89ca			MOVQ R9, R10		
		n := inst & 0x7F
  0x40dd1c		4983e17f		ANDQ $0x7f, R9		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40dd20		48ffc7			INCQ DI			
		if inst&0x80 == 0 {
  0x40dd23		410fbae207		BTL $0x7, R10		
  0x40dd28		0f825d010000		JB 0x40de8b		
			if n == 0 {
  0x40dd2e		49f7c27f000000		TESTQ $0x7f, R10	
  0x40dd35		0f8594000000		JNE 0x40ddcf		
				if trailer != nil {
  0x40dd3b		4885f6			TESTQ SI, SI		
  0x40dd3e		7410			JE 0x40dd50		
  0x40dd40		31ff			XORL DI, DI		
					continue
  0x40dd42		4989f9			MOVQ DI, R9		
  0x40dd45		4889f7			MOVQ SI, DI		
  0x40dd48		4c89ce			MOVQ R9, SI		
		for ; nbits >= 8; nbits -= 8 {
  0x40dd4b		e96effffff		JMP 0x40dcbe		
	if size == 1 {
  0x40dd50		4883fb01		CMPQ $0x1, BX		
  0x40dd54		753a			JNE 0x40dd90		
  0x40dd56		4889d3			MOVQ DX, BX		
		totalBits = (uintptr(unsafe.Pointer(dst))-uintptr(unsafe.Pointer(dstStart)))*8 + nbits
  0x40dd59		4829c2			SUBQ AX, DX		
  0x40dd5c		488d04d1		LEAQ 0(CX)(DX*8), AX	
  0x40dd60		4889ca			MOVQ CX, DX		
		nbits += -nbits & 7
  0x40dd63		48f7d9			NEGQ CX			
  0x40dd66		4883e107		ANDQ $0x7, CX		
  0x40dd6a		4801d1			ADDQ DX, CX		
		for ; nbits > 0; nbits -= 8 {
  0x40dd6d		eb0e			JMP 0x40dd7d		
			*dst = uint8(bits)
  0x40dd6f		448803			MOVB R8, 0(BX)		
		for ; nbits > 0; nbits -= 8 {
  0x40dd72		4883c1f8		ADDQ $-0x8, CX		
			bits >>= 8
  0x40dd76		49c1e808		SHRQ $0x8, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40dd7a		48ffc3			INCQ BX			
		for ; nbits > 0; nbits -= 8 {
  0x40dd7d		4885c9			TESTQ CX, CX		
  0x40dd80		77ed			JA 0x40dd6f		
	return totalBits
  0x40dd82		4889442430		MOVQ AX, 0x30(SP)	
  0x40dd87		488b2c24		MOVQ 0(SP), BP		
  0x40dd8b		4883c408		ADDQ $0x8, SP		
  0x40dd8f		c3			RET			
		totalBits = (uintptr(unsafe.Pointer(dstStart))-uintptr(unsafe.Pointer(dst)))*4 + nbits
  0x40dd90		4889d3			MOVQ DX, BX		
  0x40dd93		4829d0			SUBQ DX, AX		
  0x40dd96		488d0481		LEAQ 0(CX)(AX*4), AX	
  0x40dd9a		4889ca			MOVQ CX, DX		
		nbits += -nbits & 3
  0x40dd9d		48f7d9			NEGQ CX			
  0x40dda0		4883e103		ANDQ $0x3, CX		
  0x40dda4		4801d1			ADDQ DX, CX		
		for ; nbits > 0; nbits -= 4 {
  0x40dda7		eb1f			JMP 0x40ddc8		
  0x40dda9		4c89c2			MOVQ R8, DX		
			v := bits&0xf | bitScanAll
  0x40ddac		4983e00f		ANDQ $0xf, R8		
  0x40ddb0		4981c8f0000000		ORQ $0xf0, R8		
			*dst = uint8(v)
  0x40ddb7		448803			MOVB R8, 0(BX)		
		for ; nbits > 0; nbits -= 4 {
  0x40ddba		4883c1fc		ADDQ $-0x4, CX		
			bits >>= 4
  0x40ddbe		48c1ea04		SHRQ $0x4, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40ddc2		48ffcb			DECQ BX			
  0x40ddc5		4989d0			MOVQ DX, R8		
		for ; nbits > 0; nbits -= 4 {
  0x40ddc8		4885c9			TESTQ CX, CX		
  0x40ddcb		77dc			JA 0x40dda9		
  0x40ddcd		ebb3			JMP 0x40dd82		
			nbyte := n / 8
  0x40ddcf		49c1e903		SHRQ $0x3, R9		
  0x40ddd3		4531db			XORL R11, R11		
			for i := uintptr(0); i < nbyte; i++ {
  0x40ddd6		eb06			JMP 0x40ddde		
  0x40ddd8		49ffc3			INCQ R11		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40dddb		48ffc7			INCQ DI			
			for i := uintptr(0); i < nbyte; i++ {
  0x40ddde		4d39cb			CMPQ R9, R11		
  0x40dde1		7367			JAE 0x40de4a		
				bits |= uintptr(*p) << nbits
  0x40dde3		440fb627		MOVZX 0(DI), R12	
  0x40dde7		49d3e4			SHLQ CL, R12		
  0x40ddea		4883f940		CMPQ $0x40, CX		
  0x40ddee		4d19ed			SBBQ R13, R13		
  0x40ddf1		4d21ec			ANDQ R13, R12		
  0x40ddf4		4d09e0			ORQ R12, R8		
				if size == 1 {
  0x40ddf7		4883fb01		CMPQ $0x1, BX		
  0x40ddfb		750c			JNE 0x40de09		
					*dst = uint8(bits)
  0x40ddfd		448802			MOVB R8, 0(DX)		
					bits >>= 8
  0x40de00		49c1e808		SHRQ $0x8, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40de04		48ffc2			INCQ DX			
					bits >>= 8
  0x40de07		ebcf			JMP 0x40ddd8		
  0x40de09		4d89c4			MOVQ R8, R12		
					v := bits&0xf | bitScanAll
  0x40de0c		4983e00f		ANDQ $0xf, R8		
  0x40de10		4981c8f0000000		ORQ $0xf0, R8		
					*dst = uint8(v)
  0x40de17		448802			MOVB R8, 0(DX)		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40de1a		4c8d6aff		LEAQ -0x1(DX), R13	
					*dst = uint8(v)
  0x40de1e		41844500		TESTB AL, 0(R13)	
  0x40de22		4d89e0			MOVQ R12, R8		
					bits >>= 4
  0x40de25		49c1ec04		SHRQ $0x4, R12		
					v = bits&0xf | bitScanAll
  0x40de29		4983e40f		ANDQ $0xf, R12		
  0x40de2d		4981ccf0000000		ORQ $0xf0, R12		
					*dst = uint8(v)
  0x40de34		49c7c5ffffffff		MOVQ $-0x1, R13		
  0x40de3b		4588641500		MOVB R12, 0(R13)(DX*1)	
					bits >>= 4
  0x40de40		49c1e808		SHRQ $0x8, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40de44		4883c2fe		ADDQ $-0x2, DX		
					bits >>= 4
  0x40de48		eb8e			JMP 0x40ddd8		
  0x40de4a		4d89d1			MOVQ R10, R9		
			if n %= 8; n > 0 {
  0x40de4d		4983e207		ANDQ $0x7, R10		
  0x40de51		49f7c107000000		TESTQ $0x7, R9		
  0x40de58		762c			JBE 0x40de86		
				bits |= uintptr(*p) << nbits
  0x40de5a		440fb60f		MOVZX 0(DI), R9		
  0x40de5e		49d3e1			SHLQ CL, R9		
  0x40de61		4883f940		CMPQ $0x40, CX		
  0x40de65		4d19db			SBBQ R11, R11		
  0x40de68		4d21d9			ANDQ R11, R9		
  0x40de6b		4d09c8			ORQ R9, R8		
				nbits += n
  0x40de6e		4d8d0c0a		LEAQ 0(R10)(CX*1), R9	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40de72		48ffc7			INCQ DI			
				nbits += n
  0x40de75		4c89c9			MOVQ R9, CX		
  0x40de78		4989f2			MOVQ SI, R10		
  0x40de7b		4889fe			MOVQ DI, SI		
  0x40de7e		4c89d7			MOVQ R10, DI		
			continue Run
  0x40de81		e9bcfeffff		JMP 0x40dd42		
  0x40de86		4989c9			MOVQ CX, R9		
			if n %= 8; n > 0 {
  0x40de89		ebea			JMP 0x40de75		
		if n == 0 {
  0x40de8b		49f7c27f000000		TESTQ $0x7f, R10	
  0x40de92		0f8576040000		JNE 0x40e30e		
  0x40de98		4531d2			XORL R10, R10		
				x := uintptr(*p)
  0x40de9b		eb07			JMP 0x40dea4		
			for off := uint(0); ; off += 7 {
  0x40de9d		4c8d5107		LEAQ 0x7(CX), R10	
  0x40dea1		4c89e9			MOVQ R13, CX		
				x := uintptr(*p)
  0x40dea4		440fb61f		MOVZX 0(DI), R11	
  0x40dea8		4d89dc			MOVQ R11, R12		
				n |= (x & 0x7F) << off
  0x40deab		4983e37f		ANDQ $0x7f, R11		
  0x40deaf		4989cd			MOVQ CX, R13		
  0x40deb2		4c89d1			MOVQ R10, CX		
  0x40deb5		49d3e3			SHLQ CL, R11		
  0x40deb8		4883f940		CMPQ $0x40, CX		
  0x40debc		4d19f6			SBBQ R14, R14		
  0x40debf		4d21de			ANDQ R11, R14		
  0x40dec2		4d09f1			ORQ R14, R9		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40dec5		48ffc7			INCQ DI			
				if x&0x80 == 0 {
  0x40dec8		410fbae407		BTL $0x7, R12		
  0x40decd		72ce			JB 0x40de9d		
  0x40decf		31c9			XORL CX, CX		
  0x40ded1		4531d2			XORL R10, R10		
			x := uintptr(*p)
  0x40ded4		eb07			JMP 0x40dedd		
		for off := uint(0); ; off += 7 {
  0x40ded6		4c8d5107		LEAQ 0x7(CX), R10	
  0x40deda		4c89f1			MOVQ R14, CX		
			x := uintptr(*p)
  0x40dedd		440fb61f		MOVZX 0(DI), R11	
  0x40dee1		4d89dc			MOVQ R11, R12		
			c |= (x & 0x7F) << off
  0x40dee4		4983e37f		ANDQ $0x7f, R11		
  0x40dee8		4989ce			MOVQ CX, R14		
  0x40deeb		4c89d1			MOVQ R10, CX		
  0x40deee		49d3e3			SHLQ CL, R11		
  0x40def1		4883f940		CMPQ $0x40, CX		
  0x40def5		4d19ff			SBBQ R15, R15		
  0x40def8		4d21fb			ANDQ R15, R11		
  0x40defb		4d09de			ORQ R11, R14		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40defe		48ffc7			INCQ DI			
			if x&0x80 == 0 {
  0x40df01		410fbae407		BTL $0x7, R12		
  0x40df06		72ce			JB 0x40ded6		
		c *= n // now total number of bits to copy
  0x40df08		4d0faff1		IMULQ R9, R14		
		if n <= maxBits {
  0x40df0c		4983f939		CMPQ $0x39, R9		
  0x40df10		0f87f2010000		JA 0x40e108		
			if size == 1 {
  0x40df16		4883fb01		CMPQ $0x1, BX		
  0x40df1a		0f85bc010000		JNE 0x40e0dc		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40df20		4c8d52ff		LEAQ -0x1(DX), R10	
  0x40df24		4c89e9			MOVQ R13, CX		
  0x40df27		4d89c3			MOVQ R8, R11		
				for npattern < n {
  0x40df2a		eb12			JMP 0x40df3e		
					pattern <<= 8
  0x40df2c		49c1e008		SHLQ $0x8, R8		
					pattern |= uintptr(*src)
  0x40df30		450fb622		MOVZX 0(R10), R12	
  0x40df34		4d09e0			ORQ R12, R8		
					npattern += 8
  0x40df37		4983c508		ADDQ $0x8, R13		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40df3b		49ffca			DECQ R10		
				for npattern < n {
  0x40df3e		4d39cd			CMPQ R9, R13		
  0x40df41		72e9			JB 0x40df2c		
			if npattern > n {
  0x40df43		4d39cd			CMPQ R9, R13		
  0x40df46		0f8685010000		JBE 0x40e0d1		
				pattern >>= npattern - n
  0x40df4c		4d29cd			SUBQ R9, R13		
  0x40df4f		4989ca			MOVQ CX, R10		
  0x40df52		4c89e9			MOVQ R13, CX		
  0x40df55		49d3e8			SHRQ CL, R8		
  0x40df58		4883f940		CMPQ $0x40, CX		
  0x40df5c		4d19e4			SBBQ R12, R12		
  0x40df5f		4d21e0			ANDQ R12, R8		
			if npattern == 1 {
  0x40df62		4983f901		CMPQ $0x1, R9		
  0x40df66		0f85e5000000		JNE 0x40e051		
				if pattern == 1 {
  0x40df6c		4983f801		CMPQ $0x1, R8			
  0x40df70		0f85d3000000		JNE 0x40e049			
  0x40df76		b939000000		MOVL $0x39, CX			
  0x40df7b		49b8ffffffffffffff01	MOVQ $0x1ffffffffffffff, R8	
			for ; c >= npattern; c -= npattern {
  0x40df85		eb20			JMP 0x40dfa7		
						*dst = uint8(bits)
  0x40df87		44881a			MOVB R11, 0(DX)		
						bits >>= 8
  0x40df8a		49c1eb08		SHRQ $0x8, R11		
						nbits -= 8
  0x40df8e		4983c0f8		ADDQ $-0x8, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40df92		48ffc2			INCQ DX			
					for nbits >= 8 {
  0x40df95		4983f808		CMPQ $0x8, R8		
  0x40df99		73ec			JAE 0x40df87		
			for ; c >= npattern; c -= npattern {
  0x40df9b		4d29ce			SUBQ R9, R14		
  0x40df9e		4c89c9			MOVQ R9, CX		
  0x40dfa1		4d89c2			MOVQ R8, R10		
  0x40dfa4		4d89e0			MOVQ R12, R8		
  0x40dfa7		4939ce			CMPQ CX, R14		
  0x40dfaa		724c			JB 0x40dff8		
  0x40dfac		4989c9			MOVQ CX, R9		
  0x40dfaf		4c89d1			MOVQ R10, CX		
  0x40dfb2		4d89c4			MOVQ R8, R12		
				bits |= pattern << nbits
  0x40dfb5		49d3e0			SHLQ CL, R8		
  0x40dfb8		4883f940		CMPQ $0x40, CX		
  0x40dfbc		4d19ed			SBBQ R13, R13		
  0x40dfbf		4d21e8			ANDQ R13, R8		
  0x40dfc2		4d09c3			ORQ R8, R11		
				nbits += npattern
  0x40dfc5		4d8d0409		LEAQ 0(R9)(CX*1), R8	
			if size == 1 {
  0x40dfc9		4883fb01		CMPQ $0x1, BX		
				if size == 1 {
  0x40dfcd		74c6			JE 0x40df95		
  0x40dfcf		eb1f			JMP 0x40dff0		
  0x40dfd1		4d89da			MOVQ R11, R10		
						*dst = uint8(bits&0xf | bitScanAll)
  0x40dfd4		4983e30f		ANDQ $0xf, R11		
  0x40dfd8		4981cbf0000000		ORQ $0xf0, R11		
  0x40dfdf		44881a			MOVB R11, 0(DX)		
						bits >>= 4
  0x40dfe2		49c1ea04		SHRQ $0x4, R10		
						nbits -= 4
  0x40dfe6		4983c0fc		ADDQ $-0x4, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40dfea		48ffca			DECQ DX			
  0x40dfed		4d89d3			MOVQ R10, R11		
					for nbits >= 4 {
  0x40dff0		4983f804		CMPQ $0x4, R8		
  0x40dff4		73db			JAE 0x40dfd1		
  0x40dff6		eba3			JMP 0x40df9b		
			if c > 0 {
  0x40dff8		4d85f6			TESTQ R14, R14		
  0x40dffb		7647			JBE 0x40e044		
  0x40dffd		4c89f1			MOVQ R14, CX		
				pattern &= 1<<c - 1
  0x40e000		41b901000000		MOVL $0x1, R9		
  0x40e006		49d3e1			SHLQ CL, R9		
  0x40e009		4883f940		CMPQ $0x40, CX		
  0x40e00d		4d19e4			SBBQ R12, R12		
  0x40e010		4d21e1			ANDQ R12, R9		
  0x40e013		49ffc9			DECQ R9			
  0x40e016		4d21c8			ANDQ R9, R8		
  0x40e019		4c89d1			MOVQ R10, CX		
				bits |= pattern << nbits
  0x40e01c		49d3e0			SHLQ CL, R8		
  0x40e01f		4883f940		CMPQ $0x40, CX		
  0x40e023		4d19c9			SBBQ R9, R9		
  0x40e026		4d21c8			ANDQ R9, R8		
  0x40e029		4d09c3			ORQ R8, R11		
				nbits += c
  0x40e02c		4e8d0431		LEAQ 0(CX)(R14*1), R8	
  0x40e030		4c89c1			MOVQ R8, CX		
  0x40e033		4d89d8			MOVQ R11, R8		
  0x40e036		4989f1			MOVQ SI, R9		
  0x40e039		4889fe			MOVQ DI, SI		
  0x40e03c		4c89cf			MOVQ R9, DI		
			continue Run
  0x40e03f		e9fefcffff		JMP 0x40dd42		
  0x40e044		4d89d0			MOVQ R10, R8		
			if c > 0 {
  0x40e047		ebe7			JMP 0x40e030		
  0x40e049		4c89f1			MOVQ R14, CX		
					npattern = c
  0x40e04c		e956ffffff		JMP 0x40dfa7		
				if nb+nb <= maxBits {
  0x40e051		4f8d2409		LEAQ 0(R9)(R9*1), R12	
  0x40e055		4983fc39		CMPQ $0x39, R12		
  0x40e059		776b			JA 0x40e0c6		
  0x40e05b		4c89c9			MOVQ R9, CX		
					for nb <= sys.PtrSize*8 {
  0x40e05e		eb20			JMP 0x40e080		
  0x40e060		4989cc			MOVQ CX, R12		
  0x40e063		4c89c9			MOVQ R9, CX		
  0x40e066		4d89c5			MOVQ R8, R13		
						b |= b << nb
  0x40e069		49d3e0			SHLQ CL, R8		
					for nb <= sys.PtrSize*8 {
  0x40e06c		4883f940		CMPQ $0x40, CX		
						b |= b << nb
  0x40e070		4d19ff			SBBQ R15, R15		
  0x40e073		4d21f8			ANDQ R15, R8		
  0x40e076		4d09e8			ORQ R13, R8		
						nb += nb
  0x40e079		4c8d0c09		LEAQ 0(CX)(CX*1), R9	
  0x40e07d		4c89e1			MOVQ R12, CX		
					for nb <= sys.PtrSize*8 {
  0x40e080		4983f940		CMPQ $0x40, R9		
  0x40e084		76da			JBE 0x40e060		
					nb = maxBits / npattern * npattern
  0x40e086		4885c9			TESTQ CX, CX		
  0x40e089		0f8487020000		JE 0x40e316		
  0x40e08f		4989c1			MOVQ AX, R9		
  0x40e092		b839000000		MOVL $0x39, AX		
  0x40e097		4989d4			MOVQ DX, R12		
  0x40e09a		31d2			XORL DX, DX		
  0x40e09c		48f7f1			DIVQ CX			
  0x40e09f		480fafc8		IMULQ AX, CX		
					b &= 1<<nb - 1
  0x40e0a3		ba01000000		MOVL $0x1, DX		
  0x40e0a8		48d3e2			SHLQ CL, DX		
  0x40e0ab		4883f940		CMPQ $0x40, CX		
  0x40e0af		4d19ed			SBBQ R13, R13		
  0x40e0b2		4c21ea			ANDQ R13, DX		
  0x40e0b5		48ffca			DECQ DX			
  0x40e0b8		4921d0			ANDQ DX, R8		
					npattern = nb
  0x40e0bb		4c89c8			MOVQ R9, AX		
  0x40e0be		4c89e2			MOVQ R12, DX		
			for ; c >= npattern; c -= npattern {
  0x40e0c1		e9e1feffff		JMP 0x40dfa7		
  0x40e0c6		4989d4			MOVQ DX, R12		
  0x40e0c9		4c89c9			MOVQ R9, CX		
  0x40e0cc		4989c1			MOVQ AX, R9		
				if nb+nb <= maxBits {
  0x40e0cf		ebea			JMP 0x40e0bb		
  0x40e0d1		4989ca			MOVQ CX, R10		
  0x40e0d4		4d89e9			MOVQ R13, R9		
			if npattern > n {
  0x40e0d7		e986feffff		JMP 0x40df62		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40e0dc		4c8d5201		LEAQ 0x1(DX), R10	
  0x40e0e0		4c89e9			MOVQ R13, CX		
  0x40e0e3		4d89c3			MOVQ R8, R11		
				for npattern < n {
  0x40e0e6		eb16			JMP 0x40e0fe		
					pattern <<= 4
  0x40e0e8		49c1e004		SHLQ $0x4, R8		
					pattern |= uintptr(*src) & 0xf
  0x40e0ec		450fb622		MOVZX 0(R10), R12	
  0x40e0f0		4983e40f		ANDQ $0xf, R12		
  0x40e0f4		4d09e0			ORQ R12, R8		
					npattern += 4
  0x40e0f7		4983c504		ADDQ $0x4, R13		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40e0fb		49ffc2			INCQ R10		
				for npattern < n {
  0x40e0fe		4d39cd			CMPQ R9, R13		
  0x40e101		72e5			JB 0x40e0e8		
  0x40e103		e93bfeffff		JMP 0x40df43		
		off := n - nbits // n > nbits because n > maxBits and nbits <= 7
  0x40e108		4d29e9			SUBQ R13, R9		
		if size == 1 {
  0x40e10b		4883fb01		CMPQ $0x1, BX		
  0x40e10f		0f85f2000000		JNE 0x40e207		
			src = subtractb(src, (off+7)/8)
  0x40e115		4d8d5107		LEAQ 0x7(R9), R10	
  0x40e119		49c1ea03		SHRQ $0x3, R10		
  0x40e11d		4d89cb			MOVQ R9, R11		
			if frag := off & 7; frag != 0 {
  0x40e120		4983e107		ANDQ $0x7, R9		
  0x40e124		4989d4			MOVQ DX, R12		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))
  0x40e127		4c29d2			SUBQ R10, DX		
  0x40e12a		4989d2			MOVQ DX, R10		
			if frag := off & 7; frag != 0 {
  0x40e12d		49f7c307000000		TESTQ $0x7, R11		
  0x40e134		0f84c2000000		JE 0x40e1fc		
				bits |= uintptr(*src) >> (8 - frag) << nbits
  0x40e13a		0fb612			MOVZX 0(DX), DX		
  0x40e13d		498d49f8		LEAQ -0x8(R9), CX	
  0x40e141		48f7d9			NEGQ CX			
  0x40e144		48d3ea			SHRQ CL, DX		
  0x40e147		4883f940		CMPQ $0x40, CX		
  0x40e14b		4d19db			SBBQ R11, R11		
  0x40e14e		4c21da			ANDQ R11, DX		
  0x40e151		4c89e9			MOVQ R13, CX		
  0x40e154		48d3e2			SHLQ CL, DX		
  0x40e157		4883f940		CMPQ $0x40, CX		
  0x40e15b		4d19db			SBBQ R11, R11		
  0x40e15e		4c21da			ANDQ R11, DX		
  0x40e161		4909d0			ORQ DX, R8		
				nbits += frag
  0x40e164		498d1409		LEAQ 0(R9)(CX*1), DX	
				c -= frag
  0x40e168		4d29ce			SUBQ R9, R14		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40e16b		4d8d4a01		LEAQ 0x1(R10), R9	
				c -= frag
  0x40e16f		4c89f1			MOVQ R14, CX		
			for i := c / 8; i > 0; i-- {
  0x40e172		49c1ee03		SHRQ $0x3, R14		
  0x40e176		eb2e			JMP 0x40e1a6		
				bits |= uintptr(*src) << nbits
  0x40e178		450fb611		MOVZX 0(R9), R10	
  0x40e17c		4989cb			MOVQ CX, R11		
  0x40e17f		4889d1			MOVQ DX, CX		
  0x40e182		49d3e2			SHLQ CL, R10		
  0x40e185		4883f940		CMPQ $0x40, CX		
  0x40e189		4d19ed			SBBQ R13, R13		
  0x40e18c		4d21ea			ANDQ R13, R10		
  0x40e18f		4d09d0			ORQ R10, R8		
				*dst = uint8(bits)
  0x40e192		45880424		MOVB R8, 0(R12)		
			for i := c / 8; i > 0; i-- {
  0x40e196		49ffce			DECQ R14		
				bits >>= 8
  0x40e199		49c1e808		SHRQ $0x8, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40e19d		49ffc1			INCQ R9			
  0x40e1a0		49ffc4			INCQ R12		
  0x40e1a3		4c89d9			MOVQ R11, CX		
			for i := c / 8; i > 0; i-- {
  0x40e1a6		4d85f6			TESTQ R14, R14		
  0x40e1a9		77cd			JA 0x40e178		
  0x40e1ab		4989ca			MOVQ CX, R10		
			if c %= 8; c > 0 {
  0x40e1ae		4883e107		ANDQ $0x7, CX		
  0x40e1b2		49f7c207000000		TESTQ $0x7, R10		
  0x40e1b9		762d			JBE 0x40e1e8		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x40e1bb		450fb609		MOVZX 0(R9), R9		
  0x40e1bf		41ba01000000		MOVL $0x1, R10		
  0x40e1c5		49d3e2			SHLQ CL, R10		
  0x40e1c8		49ffca			DECQ R10		
  0x40e1cb		4d21ca			ANDQ R9, R10		
  0x40e1ce		4989c9			MOVQ CX, R9		
  0x40e1d1		4889d1			MOVQ DX, CX		
  0x40e1d4		49d3e2			SHLQ CL, R10		
  0x40e1d7		4883f940		CMPQ $0x40, CX		
  0x40e1db		4d19db			SBBQ R11, R11		
  0x40e1de		4d21da			ANDQ R11, R10		
  0x40e1e1		4d09d0			ORQ R10, R8		
				nbits += c
  0x40e1e4		498d1409		LEAQ 0(R9)(CX*1), DX	
  0x40e1e8		4889d1			MOVQ DX, CX		
  0x40e1eb		4c89e2			MOVQ R12, DX		
  0x40e1ee		4989f1			MOVQ SI, R9		
  0x40e1f1		4889fe			MOVQ DI, SI		
  0x40e1f4		4c89cf			MOVQ R9, DI		
		for ; nbits >= 8; nbits -= 8 {
  0x40e1f7		e946fbffff		JMP 0x40dd42		
  0x40e1fc		4989d1			MOVQ DX, R9		
  0x40e1ff		4c89ea			MOVQ R13, DX		
			if frag := off & 7; frag != 0 {
  0x40e202		e968ffffff		JMP 0x40e16f		
			src = addb(src, (off+3)/4)
  0x40e207		4d8d5103		LEAQ 0x3(R9), R10	
  0x40e20b		49c1ea02		SHRQ $0x2, R10		
  0x40e20f		4d89cb			MOVQ R9, R11		
			if frag := off & 3; frag != 0 {
  0x40e212		4983e103		ANDQ $0x3, R9		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40e216		4e8d2412		LEAQ 0(DX)(R10*1), R12	
			if frag := off & 3; frag != 0 {
  0x40e21a		49f7c303000000		TESTQ $0x3, R11		
  0x40e221		0f84dc000000		JE 0x40e303		
				bits |= (uintptr(*src) & 0xf) >> (4 - frag) << nbits
  0x40e227		41840424		TESTB AL, 0(R12)	
  0x40e22b		460fb61c12		MOVZX 0(DX)(R10*1), R11	
  0x40e230		4983e30f		ANDQ $0xf, R11		
  0x40e234		498d49fc		LEAQ -0x4(R9), CX	
  0x40e238		48f7d9			NEGQ CX			
  0x40e23b		49d3eb			SHRQ CL, R11		
  0x40e23e		4883f940		CMPQ $0x40, CX		
  0x40e242		4d19e4			SBBQ R12, R12		
  0x40e245		4d21e3			ANDQ R12, R11		
  0x40e248		4c89e9			MOVQ R13, CX		
  0x40e24b		49d3e3			SHLQ CL, R11		
  0x40e24e		4883f940		CMPQ $0x40, CX		
  0x40e252		4d19e4			SBBQ R12, R12		
  0x40e255		4d21e3			ANDQ R12, R11		
  0x40e258		4d09d8			ORQ R11, R8		
				nbits += frag
  0x40e25b		4d8d1c09		LEAQ 0(R9)(CX*1), R11	
				c -= frag
  0x40e25f		4d29ce			SUBQ R9, R14		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40e262		4e8d4c12ff		LEAQ -0x1(DX)(R10*1), R9	
				c -= frag
  0x40e267		4c89f1			MOVQ R14, CX		
			for i := c / 4; i > 0; i-- {
  0x40e26a		49c1ee02		SHRQ $0x2, R14		
  0x40e26e		eb42			JMP 0x40e2b2		
				bits |= (uintptr(*src) & 0xf) << nbits
  0x40e270		450fb611		MOVZX 0(R9), R10	
  0x40e274		4983e20f		ANDQ $0xf, R10		
  0x40e278		4989cc			MOVQ CX, R12		
  0x40e27b		4c89d9			MOVQ R11, CX		
  0x40e27e		49d3e2			SHLQ CL, R10		
  0x40e281		4883f940		CMPQ $0x40, CX		
  0x40e285		4d19ed			SBBQ R13, R13		
  0x40e288		4d21ea			ANDQ R13, R10		
  0x40e28b		4d09d0			ORQ R10, R8		
  0x40e28e		4d89c2			MOVQ R8, R10		
				*dst = uint8(bits&0xf | bitScanAll)
  0x40e291		4983e00f		ANDQ $0xf, R8		
  0x40e295		4981c8f0000000		ORQ $0xf0, R8		
  0x40e29c		448802			MOVB R8, 0(DX)		
			for i := c / 4; i > 0; i-- {
  0x40e29f		49ffce			DECQ R14		
				bits >>= 4
  0x40e2a2		49c1ea04		SHRQ $0x4, R10		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x40e2a6		49ffc9			DECQ R9			
  0x40e2a9		48ffca			DECQ DX			
  0x40e2ac		4c89e1			MOVQ R12, CX		
  0x40e2af		4d89d0			MOVQ R10, R8		
			for i := c / 4; i > 0; i-- {
  0x40e2b2		4d85f6			TESTQ R14, R14		
  0x40e2b5		77b9			JA 0x40e270		
  0x40e2b7		4989ca			MOVQ CX, R10		
			if c %= 4; c > 0 {
  0x40e2ba		4883e103		ANDQ $0x3, CX		
  0x40e2be		49f7c203000000		TESTQ $0x3, R10		
  0x40e2c5		7637			JBE 0x40e2fe		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x40e2c7		450fb609		MOVZX 0(R9), R9		
  0x40e2cb		41ba01000000		MOVL $0x1, R10		
  0x40e2d1		49d3e2			SHLQ CL, R10		
  0x40e2d4		49ffca			DECQ R10		
  0x40e2d7		4d21ca			ANDQ R9, R10		
  0x40e2da		4989c9			MOVQ CX, R9		
  0x40e2dd		4c89d9			MOVQ R11, CX		
  0x40e2e0		49d3e2			SHLQ CL, R10		
  0x40e2e3		4883f940		CMPQ $0x40, CX		
  0x40e2e7		4d19e4			SBBQ R12, R12		
  0x40e2ea		4d21e2			ANDQ R12, R10		
  0x40e2ed		4d09d0			ORQ R10, R8		
				nbits += c
  0x40e2f0		4901c9			ADDQ CX, R9		
  0x40e2f3		4989d4			MOVQ DX, R12		
  0x40e2f6		4c89ca			MOVQ R9, DX		
		for ; nbits >= 8; nbits -= 8 {
  0x40e2f9		e9eafeffff		JMP 0x40e1e8		
  0x40e2fe		4d89d9			MOVQ R11, R9		
			if c %= 4; c > 0 {
  0x40e301		ebf0			JMP 0x40e2f3		
  0x40e303		4d89e1			MOVQ R12, R9		
  0x40e306		4d89eb			MOVQ R13, R11		
			if frag := off & 3; frag != 0 {
  0x40e309		e959ffffff		JMP 0x40e267		
  0x40e30e		4989cd			MOVQ CX, R13		
		if n == 0 {
  0x40e311		e9b9fbffff		JMP 0x40decf		
					nb = maxBits / npattern * npattern
  0x40e316		e805180100		CALL runtime.panicdivide(SB)	
  0x40e31b		0f0b			UD2				

TEXT runtime.allocmcache(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcache.go
func allocmcache() *mcache {
  0x40e320		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40e329		483b6110		CMPQ 0x10(CX), SP	
  0x40e32d		0f8689000000		JBE 0x40e3bc		
  0x40e333		4883ec20		SUBQ $0x20, SP		
  0x40e337		48896c2418		MOVQ BP, 0x18(SP)	
  0x40e33c		488d6c2418		LEAQ 0x18(SP), BP	
	lock(&mheap_.lock)
  0x40e341		488d0558df0900		LEAQ runtime.mheap_(SB), AX	
  0x40e348		48890424		MOVQ AX, 0(SP)			
  0x40e34c		e8cfb1ffff		CALL runtime.lock(SB)		
	c := (*mcache)(mheap_.cachealloc.alloc())
  0x40e351		488d0560140a00		LEAQ runtime.mheap_+13592(SB), AX	
  0x40e358		48890424		MOVQ AX, 0(SP)				
  0x40e35c		e8df160000		CALL runtime.(*fixalloc).alloc(SB)	
  0x40e361		488b442408		MOVQ 0x8(SP), AX			
  0x40e366		4889442410		MOVQ AX, 0x10(SP)			
	unlock(&mheap_.lock)
  0x40e36b		488d0d2edf0900		LEAQ runtime.mheap_(SB), CX	
  0x40e372		48890c24		MOVQ CX, 0(SP)			
  0x40e376		e845b3ffff		CALL runtime.unlock(SB)		
  0x40e37b		488b442410		MOVQ 0x10(SP), AX		
  0x40e380		31c9			XORL CX, CX			
	for i := range c.alloc {
  0x40e382		eb11			JMP 0x40e395		
		c.alloc[i] = &emptymspan
  0x40e384		8400			TESTB AL, 0(AX)			
  0x40e386		488d15f3940900		LEAQ runtime.emptymspan(SB), DX	
  0x40e38d		488954c828		MOVQ DX, 0x28(AX)(CX*8)		
	for i := range c.alloc {
  0x40e392		48ffc1			INCQ CX			
  0x40e395		4881f986000000		CMPQ $0x86, CX		
  0x40e39c		7ce6			JL 0x40e384		
	c.next_sample = nextSample()
  0x40e39e		e82dcfffff		CALL runtime.nextSample(SB)	
  0x40e3a3		8b0424			MOVL 0(SP), AX			
  0x40e3a6		488b4c2410		MOVQ 0x10(SP), CX		
  0x40e3ab		8901			MOVL AX, 0(CX)			
	return c
  0x40e3ad		48894c2428		MOVQ CX, 0x28(SP)	
  0x40e3b2		488b6c2418		MOVQ 0x18(SP), BP	
  0x40e3b7		4883c420		ADDQ $0x20, SP		
  0x40e3bb		c3			RET			
func allocmcache() *mcache {
  0x40e3bc		e8af610300		CALL runtime.morestack_noctxt(SB)	
  0x40e3c1		e95affffff		JMP runtime.allocmcache(SB)		

TEXT runtime.freemcache(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcache.go
func freemcache(c *mcache) {
  0x40e3d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40e3d9		483b6110		CMPQ 0x10(CX), SP	
  0x40e3dd		763c			JBE 0x40e41b		
  0x40e3df		4883ec20		SUBQ $0x20, SP		
  0x40e3e3		48896c2418		MOVQ BP, 0x18(SP)	
  0x40e3e8		488d6c2418		LEAQ 0x18(SP), BP	
	systemstack(func() {
  0x40e3ed		488d056c3a0300		LEAQ runtime.freemcache.func1(SB), AX	
  0x40e3f4		4889442408		MOVQ AX, 0x8(SP)			
func freemcache(c *mcache) {
  0x40e3f9		488b442428		MOVQ 0x28(SP), AX	
	systemstack(func() {
  0x40e3fe		4889442410		MOVQ AX, 0x10(SP)		
  0x40e403		488d442408		LEAQ 0x8(SP), AX		
  0x40e408		48890424		MOVQ AX, 0(SP)			
  0x40e40c		e80f600300		CALL runtime.systemstack(SB)	
}
  0x40e411		488b6c2418		MOVQ 0x18(SP), BP	
  0x40e416		4883c420		ADDQ $0x20, SP		
  0x40e41a		c3			RET			
func freemcache(c *mcache) {
  0x40e41b		e850610300		CALL runtime.morestack_noctxt(SB)	
  0x40e420		ebae			JMP runtime.freemcache(SB)		

TEXT runtime.(*mcache).refill(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcache.go
func (c *mcache) refill(spc spanClass) {
  0x40e430		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40e439		483b6110		CMPQ 0x10(CX), SP	
  0x40e43d		0f8621010000		JBE 0x40e564		
  0x40e443		4883ec28		SUBQ $0x28, SP		
  0x40e447		48896c2420		MOVQ BP, 0x20(SP)	
  0x40e44c		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x40e451		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x40e45a		488b4830		MOVQ 0x30(AX), CX	
  0x40e45e		ff8100010000		INCL 0x100(CX)		
func (c *mcache) refill(spc spanClass) {
  0x40e464		488b4c2430		MOVQ 0x30(SP), CX	
	s := c.alloc[spc]
  0x40e469		8401			TESTB AL, 0(CX)		
func (c *mcache) refill(spc spanClass) {
  0x40e46b		0fb6542438		MOVZX 0x38(SP), DX	
	s := c.alloc[spc]
  0x40e470		0fb6d2			MOVZX DL, DX		
  0x40e473		4881fa86000000		CMPQ $0x86, DX		
  0x40e47a		0f83dd000000		JAE 0x40e55d		
  0x40e480		488b5cd128		MOVQ 0x28(CX)(DX*8), BX	
	if uintptr(s.allocCount) != s.nelems {
  0x40e485		0fb77360		MOVZX 0x60(BX), SI	
  0x40e489		488b7b38		MOVQ 0x38(BX), DI	
  0x40e48d		4839fe			CMPQ DI, SI		
  0x40e490		0f85ac000000		JNE 0x40e542		
  0x40e496		4889442418		MOVQ AX, 0x18(SP)	
	if s != &emptymspan {
  0x40e49b		488d35de930900		LEAQ runtime.emptymspan(SB), SI	
  0x40e4a2		4839f3			CMPQ SI, BX			
  0x40e4a5		7404			JE 0x40e4ab			
		s.incache = false
  0x40e4a7		c6436300		MOVB $0x0, 0x63(BX)	
  0x40e4ab		4889542410		MOVQ DX, 0x10(SP)	
	s = mheap_.central[spc].mcentral.cacheSpan()
  0x40e4b0		48c1e206		SHLQ $0x6, DX				
  0x40e4b4		488d0de5dd0900		LEAQ runtime.mheap_(SB), CX		
  0x40e4bb		488d8c1150130000	LEAQ 0x1350(CX)(DX*1), CX		
  0x40e4c3		48890c24		MOVQ CX, 0(SP)				
  0x40e4c7		e854010000		CALL runtime.(*mcentral).cacheSpan(SB)	
  0x40e4cc		488b442408		MOVQ 0x8(SP), AX			
	if s == nil {
  0x40e4d1		4885c0			TESTQ AX, AX		
  0x40e4d4		7451			JE 0x40e527		
	if uintptr(s.allocCount) == s.nelems {
  0x40e4d6		0fb74860		MOVZX 0x60(AX), CX	
  0x40e4da		488b5038		MOVQ 0x38(AX), DX	
  0x40e4de		4839d1			CMPQ DX, CX		
  0x40e4e1		7429			JE 0x40e50c		
  0x40e4e3		488b4c2410		MOVQ 0x10(SP), CX	
  0x40e4e8		488b542430		MOVQ 0x30(SP), DX	
	c.alloc[spc] = s
  0x40e4ed		488944ca28		MOVQ AX, 0x28(DX)(CX*8)	
  0x40e4f2		488b442418		MOVQ 0x18(SP), AX	
	_g_.m.locks--
  0x40e4f7		488b4030		MOVQ 0x30(AX), AX	
  0x40e4fb		838000010000ff		ADDL $-0x1, 0x100(AX)	
}
  0x40e502		488b6c2420		MOVQ 0x20(SP), BP	
  0x40e507		4883c428		ADDQ $0x28, SP		
  0x40e50b		c3			RET			
		throw("span has no free space")
  0x40e50c		488d053fd00500		LEAQ 0x5d03f(IP), AX	
  0x40e513		48890424		MOVQ AX, 0(SP)		
  0x40e517		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x40e520		e8ab2c0100		CALL runtime.throw(SB)	
  0x40e525		0f0b			UD2			
		throw("out of memory")
  0x40e527		488d0547c20500		LEAQ 0x5c247(IP), AX	
  0x40e52e		48890424		MOVQ AX, 0(SP)		
  0x40e532		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40e53b		e8902c0100		CALL runtime.throw(SB)	
  0x40e540		0f0b			UD2			
		throw("refill of span with free space remaining")
  0x40e542		488d056ded0500		LEAQ 0x5ed6d(IP), AX	
  0x40e549		48890424		MOVQ AX, 0(SP)		
  0x40e54d		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x40e556		e8752c0100		CALL runtime.throw(SB)	
  0x40e55b		0f0b			UD2			
	s := c.alloc[spc]
  0x40e55d		e8de140100		CALL runtime.panicindex(SB)	
  0x40e562		0f0b			UD2				
func (c *mcache) refill(spc spanClass) {
  0x40e564		e807600300		CALL runtime.morestack_noctxt(SB)	
  0x40e569		e9c2feffff		JMP runtime.(*mcache).refill(SB)	

TEXT runtime.(*mcache).releaseAll(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcache.go
func (c *mcache) releaseAll() {
  0x40e570		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40e579		483b6110		CMPQ 0x10(CX), SP	
  0x40e57d		0f8689000000		JBE 0x40e60c		
  0x40e583		4883ec20		SUBQ $0x20, SP		
  0x40e587		48896c2418		MOVQ BP, 0x18(SP)	
  0x40e58c		488d6c2418		LEAQ 0x18(SP), BP	
  0x40e591		31c0			XORL AX, AX		
	for i := range c.alloc {
  0x40e593		eb03			JMP 0x40e598		
  0x40e595		48ffc0			INCQ AX			
  0x40e598		483d86000000		CMPQ $0x86, AX		
  0x40e59e		7d56			JGE 0x40e5f6		
  0x40e5a0		488b4c2428		MOVQ 0x28(SP), CX	
		s := c.alloc[i]
  0x40e5a5		8401			TESTB AL, 0(CX)		
  0x40e5a7		488b54c128		MOVQ 0x28(CX)(AX*8), DX	
		if s != &emptymspan {
  0x40e5ac		488d1dcd920900		LEAQ runtime.emptymspan(SB), BX	
  0x40e5b3		4839da			CMPQ BX, DX			
  0x40e5b6		74dd			JE 0x40e595			
  0x40e5b8		4889442410		MOVQ AX, 0x10(SP)		
			mheap_.central[i].mcentral.uncacheSpan(s)
  0x40e5bd		48c1e006		SHLQ $0x6, AX					
  0x40e5c1		488d1dd8dc0900		LEAQ runtime.mheap_(SB), BX			
  0x40e5c8		488d840350130000	LEAQ 0x1350(BX)(AX*1), AX			
  0x40e5d0		48890424		MOVQ AX, 0(SP)					
  0x40e5d4		4889542408		MOVQ DX, 0x8(SP)				
  0x40e5d9		e882040000		CALL runtime.(*mcentral).uncacheSpan(SB)	
  0x40e5de		488b442410		MOVQ 0x10(SP), AX				
			c.alloc[i] = &emptymspan
  0x40e5e3		488d1d96920900		LEAQ runtime.emptymspan(SB), BX	
  0x40e5ea		488b4c2428		MOVQ 0x28(SP), CX		
  0x40e5ef		48895cc128		MOVQ BX, 0x28(CX)(AX*8)		
  0x40e5f4		eb9f			JMP 0x40e595			
	c.tinyoffset = 0
  0x40e5f6		0f57c0			XORPS X0, X0		
  0x40e5f9		488b442428		MOVQ 0x28(SP), AX	
  0x40e5fe		0f114010		MOVUPS X0, 0x10(AX)	
}
  0x40e602		488b6c2418		MOVQ 0x18(SP), BP	
  0x40e607		4883c420		ADDQ $0x20, SP		
  0x40e60b		c3			RET			
func (c *mcache) releaseAll() {
  0x40e60c		e85f5f0300		CALL runtime.morestack_noctxt(SB)	
  0x40e611		e95affffff		JMP runtime.(*mcache).releaseAll(SB)	

TEXT runtime.(*mcentral).cacheSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcentral.go
func (c *mcentral) cacheSpan() *mspan {
  0x40e620		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40e629		483b6110		CMPQ 0x10(CX), SP	
  0x40e62d		0f861d040000		JBE 0x40ea50		
  0x40e633		4883ec40		SUBQ $0x40, SP		
  0x40e637		48896c2438		MOVQ BP, 0x38(SP)	
  0x40e63c		488d6c2438		LEAQ 0x38(SP), BP	
  0x40e641		488b442448		MOVQ 0x48(SP), AX	
	spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize
  0x40e646		0fb64808		MOVZX 0x8(AX), CX	
	return int8(sc >> 1)
  0x40e64a		d0e9			SHRL $0x1, CL		
	spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize
  0x40e64c		480fbec9		MOVSX CL, CX					
  0x40e650		4883f943		CMPQ $0x43, CX					
  0x40e654		0f83ef030000		JAE 0x40ea49					
  0x40e65a		488d055f6a0900		LEAQ runtime.class_to_allocnpages(SB), AX	
  0x40e661		0fb60408		MOVZX 0(AX)(CX*1), AX				
  0x40e665		48c1e00d		SHLQ $0xd, AX					
  0x40e669		4889442420		MOVQ AX, 0x20(SP)				
	deductSweepCredit(spanBytes, 0)
  0x40e66e		48890424		MOVQ AX, 0(SP)				
  0x40e672		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x40e67b		e8c0a20000		CALL runtime.deductSweepCredit(SB)	
  0x40e680		488b442448		MOVQ 0x48(SP), AX			
	lock(&c.lock)
  0x40e685		48890424		MOVQ AX, 0(SP)		
  0x40e689		e892aeffff		CALL runtime.lock(SB)	
	if trace.enabled {
  0x40e68e		0fb6053b510a00		MOVZX runtime.trace+16(SB), AX	
  0x40e695		84c0			TESTL AL, AL			
  0x40e697		0f8580030000		JNE 0x40ea1d			
	sg := mheap_.sweepgen
  0x40e69d		8b0d1dec0900		MOVL runtime.mheap_+4128(SB), CX	
  0x40e6a3		894c241c		MOVL CX, 0x1c(SP)			
retry:
  0x40e6a7		e958030000		JMP 0x40ea04		
	for s = c.nonempty.first; s != nil; s = s.next {
  0x40e6ac		488b1b			MOVQ 0(BX), BX		
  0x40e6af		4885db			TESTQ BX, BX		
  0x40e6b2		0f84eb010000		JE 0x40e8a3		
  0x40e6b8		48895c2428		MOVQ BX, 0x28(SP)	
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x40e6bd		8b7358			MOVL 0x58(BX), SI		
  0x40e6c0		8d41fe			LEAL -0x2(CX), AX		
  0x40e6c3		39c6			CMPL AX, SI			
  0x40e6c5		7515			JNE 0x40e6dc			
  0x40e6c7		8d71ff			LEAL -0x1(CX), SI		
  0x40e6ca		f00fb17358		LOCK CMPXCHGL SI, 0x58(BX)	
  0x40e6cf		400f94c6		SETE SI				
  0x40e6d3		4084f6			TESTL SI, SI			
  0x40e6d6		0f856c010000		JNE 0x40e848			
		if s.sweepgen == sg-1 {
  0x40e6dc		8b7358			MOVL 0x58(BX), SI	
  0x40e6df		8d79ff			LEAL -0x1(CX), DI	
  0x40e6e2		39fe			CMPL DI, SI		
  0x40e6e4		74c6			JE 0x40e6ac		
		c.nonempty.remove(s)
  0x40e6e6		488d4210		LEAQ 0x10(DX), AX			
  0x40e6ea		48890424		MOVQ AX, 0(SP)				
  0x40e6ee		48895c2408		MOVQ BX, 0x8(SP)			
  0x40e6f3		e8b8d90000		CALL runtime.(*mSpanList).remove(SB)	
  0x40e6f8		488b442448		MOVQ 0x48(SP), AX			
		c.empty.insertBack(s)
  0x40e6fd		488d4820		LEAQ 0x20(AX), CX				
  0x40e701		48890c24		MOVQ CX, 0(SP)					
  0x40e705		488b4c2428		MOVQ 0x28(SP), CX				
  0x40e70a		48894c2408		MOVQ CX, 0x8(SP)				
  0x40e70f		e85cdc0000		CALL runtime.(*mSpanList).insertBack(SB)	
  0x40e714		488b442448		MOVQ 0x48(SP), AX				
		unlock(&c.lock)
  0x40e719		48890424		MOVQ AX, 0(SP)		
  0x40e71d		e89eafffff		CALL runtime.unlock(SB)	
  0x40e722		31c0			XORL AX, AX		
  0x40e724		488b4c2428		MOVQ 0x28(SP), CX	
		goto havespan
  0x40e729		48894c2428		MOVQ CX, 0x28(SP)	
	if trace.enabled && !traceDone {
  0x40e72e		0fb6159b500a00		MOVZX runtime.trace+16(SB), DX	
  0x40e735		84d2			TESTL DL, DL			
  0x40e737		7408			JE 0x40e741			
  0x40e739		84c0			TESTL AL, AL			
  0x40e73b		0f84f8000000		JE 0x40e839			
	cap := int32((s.npages << _PageShift) / s.elemsize)
  0x40e741		488b4120		MOVQ 0x20(CX), AX	
  0x40e745		488b5168		MOVQ 0x68(CX), DX	
  0x40e749		4885d2			TESTQ DX, DX		
  0x40e74c		0f84f0020000		JE 0x40ea42		
  0x40e752		48c1e00d		SHLQ $0xd, AX		
  0x40e756		4889d3			MOVQ DX, BX		
  0x40e759		31d2			XORL DX, DX		
  0x40e75b		48f7f3			DIVQ BX			
	n := cap - int32(s.allocCount)
  0x40e75e		0fb75160		MOVZX 0x60(CX), DX	
  0x40e762		0fb7da			MOVZX DX, BX		
  0x40e765		29d8			SUBL BX, AX		
	if n == 0 || s.freeindex == s.nelems || uintptr(s.allocCount) == s.nelems {
  0x40e767		85c0			TESTL AX, AX		
  0x40e769		0f84b8020000		JE 0x40ea27		
  0x40e76f		488b5930		MOVQ 0x30(CX), BX	
  0x40e773		488b7138		MOVQ 0x38(CX), SI	
  0x40e777		4839f3			CMPQ SI, BX		
  0x40e77a		0f84a7020000		JE 0x40ea27		
  0x40e780		0fb7d2			MOVZX DX, DX		
  0x40e783		4839d6			CMPQ DX, SI		
  0x40e786		0f849b020000		JE 0x40ea27		
	atomic.Xadd64(&c.nmalloc, int64(n))
  0x40e78c		4863c0			MOVSXD AX, AX		
  0x40e78f		488b542448		MOVQ 0x48(SP), DX	
  0x40e794		f0480fc14230		LOCK XADDQ AX, 0x30(DX)	
	usedBytes := uintptr(s.allocCount) * s.elemsize
  0x40e79a		0fb74160		MOVZX 0x60(CX), AX	
  0x40e79e		488b5168		MOVQ 0x68(CX), DX	
  0x40e7a2		480fafc2		IMULQ DX, AX		
  0x40e7a6		488b542420		MOVQ 0x20(SP), DX	
	atomic.Xadd64(&memstats.heap_live, int64(spanBytes)-int64(usedBytes))
  0x40e7ab		4829c2			SUBQ AX, DX				
  0x40e7ae		488d058b760b00		LEAQ runtime.memstats+5952(SB), AX	
  0x40e7b5		f0480fc110		LOCK XADDQ DX, 0(AX)			
	if trace.enabled {
  0x40e7ba		0fb6050f500a00		MOVZX runtime.trace+16(SB), AX	
  0x40e7c1		84c0			TESTL AL, AL			
  0x40e7c3		7568			JNE 0x40e82d			
	if gcBlackenEnabled != 0 {
  0x40e7c5		8b0509510b00		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x40e7cb		85c0			TESTL AX, AX				
  0x40e7cd		7547			JNE 0x40e816				
	s.incache = true
  0x40e7cf		c6416301		MOVB $0x1, 0x63(CX)	
	freeByteBase := s.freeindex &^ (64 - 1)
  0x40e7d3		488b4130		MOVQ 0x30(CX), AX	
	s.refillAllocCache(whichByte)
  0x40e7d7		48890c24		MOVQ CX, 0(SP)		
	freeByteBase := s.freeindex &^ (64 - 1)
  0x40e7db		4883e0c0		ANDQ $-0x40, AX		
	whichByte := freeByteBase / 8
  0x40e7df		48c1e803		SHRQ $0x3, AX		
	s.refillAllocCache(whichByte)
  0x40e7e3		4889442408		MOVQ AX, 0x8(SP)				
  0x40e7e8		e8c3d6ffff		CALL runtime.(*mspan).refillAllocCache(SB)	
  0x40e7ed		488b442428		MOVQ 0x28(SP), AX				
	s.allocCache >>= s.freeindex % 64
  0x40e7f2		488b4840		MOVQ 0x40(AX), CX	
  0x40e7f6		488b5030		MOVQ 0x30(AX), DX	
  0x40e7fa		4889cb			MOVQ CX, BX		
  0x40e7fd		4889d1			MOVQ DX, CX		
  0x40e800		48d3eb			SHRQ CL, BX		
  0x40e803		48895840		MOVQ BX, 0x40(AX)	
	return s
  0x40e807		4889442450		MOVQ AX, 0x50(SP)	
  0x40e80c		488b6c2438		MOVQ 0x38(SP), BP	
  0x40e811		4883c440		ADDQ $0x40, SP		
  0x40e815		c3			RET			
		gcController.revise()
  0x40e816		488d0503540b00		LEAQ runtime.gcController(SB), AX		
  0x40e81d		48890424		MOVQ AX, 0(SP)					
  0x40e821		e89a1a0000		CALL runtime.(*gcControllerState).revise(SB)	
  0x40e826		488b4c2428		MOVQ 0x28(SP), CX				
  0x40e82b		eba2			JMP 0x40e7cf					
		traceHeapAlloc()
  0x40e82d		e8aec70200		CALL runtime.traceHeapAlloc(SB)	
  0x40e832		488b4c2428		MOVQ 0x28(SP), CX		
  0x40e837		eb8c			JMP 0x40e7c5			
		traceGCSweepDone()
  0x40e839		e872be0200		CALL runtime.traceGCSweepDone(SB)	
  0x40e83e		488b4c2428		MOVQ 0x28(SP), CX			
  0x40e843		e9f9feffff		JMP 0x40e741				
			c.nonempty.remove(s)
  0x40e848		488d4210		LEAQ 0x10(DX), AX			
  0x40e84c		48890424		MOVQ AX, 0(SP)				
  0x40e850		48895c2408		MOVQ BX, 0x8(SP)			
  0x40e855		e856d80000		CALL runtime.(*mSpanList).remove(SB)	
  0x40e85a		488b442448		MOVQ 0x48(SP), AX			
			c.empty.insertBack(s)
  0x40e85f		488d4820		LEAQ 0x20(AX), CX				
  0x40e863		48890c24		MOVQ CX, 0(SP)					
  0x40e867		488b4c2428		MOVQ 0x28(SP), CX				
  0x40e86c		48894c2408		MOVQ CX, 0x8(SP)				
  0x40e871		e8fada0000		CALL runtime.(*mSpanList).insertBack(SB)	
  0x40e876		488b442448		MOVQ 0x48(SP), AX				
			unlock(&c.lock)
  0x40e87b		48890424		MOVQ AX, 0(SP)		
  0x40e87f		e83caeffff		CALL runtime.unlock(SB)	
  0x40e884		488b442428		MOVQ 0x28(SP), AX	
			s.sweep(true)
  0x40e889		48890424		MOVQ AX, 0(SP)			
  0x40e88d		c644240801		MOVB $0x1, 0x8(SP)		
  0x40e892		e829970000		CALL runtime.(*mspan).sweep(SB)	
  0x40e897		31c0			XORL AX, AX			
  0x40e899		488b4c2428		MOVQ 0x28(SP), CX		
			goto havespan
  0x40e89e		e986feffff		JMP 0x40e729		
	for s = c.empty.first; s != nil; s = s.next {
  0x40e8a3		488b5a20		MOVQ 0x20(DX), BX	
  0x40e8a7		eb03			JMP 0x40e8ac		
  0x40e8a9		488b1b			MOVQ 0(BX), BX		
  0x40e8ac		4885db			TESTQ BX, BX		
  0x40e8af		7429			JE 0x40e8da		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x40e8b1		8b7358			MOVL 0x58(BX), SI		
  0x40e8b4		8d41fe			LEAL -0x2(CX), AX		
  0x40e8b7		39c6			CMPL AX, SI			
  0x40e8b9		7515			JNE 0x40e8d0			
  0x40e8bb		8d71ff			LEAL -0x1(CX), SI		
  0x40e8be		f00fb17358		LOCK CMPXCHGL SI, 0x58(BX)	
  0x40e8c3		400f94c6		SETE SI				
  0x40e8c7		4084f6			TESTL SI, SI			
  0x40e8ca		0f85ac000000		JNE 0x40e97c			
		if s.sweepgen == sg-1 {
  0x40e8d0		8b7358			MOVL 0x58(BX), SI	
  0x40e8d3		8d79ff			LEAL -0x1(CX), DI	
  0x40e8d6		39fe			CMPL DI, SI		
  0x40e8d8		74cf			JE 0x40e8a9		
	if trace.enabled {
  0x40e8da		0fb605ef4e0a00		MOVZX runtime.trace+16(SB), AX	
  0x40e8e1		8844241b		MOVB AL, 0x1b(SP)		
  0x40e8e5		84c0			TESTL AL, AL			
  0x40e8e7		0f8580000000		JNE 0x40e96d			
	unlock(&c.lock)
  0x40e8ed		48891424		MOVQ DX, 0(SP)		
  0x40e8f1		e8caadffff		CALL runtime.unlock(SB)	
  0x40e8f6		488b442448		MOVQ 0x48(SP), AX	
	s = c.grow()
  0x40e8fb		48890424		MOVQ AX, 0(SP)				
  0x40e8ff		e80c040000		CALL runtime.(*mcentral).grow(SB)	
  0x40e904		488b442408		MOVQ 0x8(SP), AX			
	if s == nil {
  0x40e909		4885c0			TESTQ AX, AX		
  0x40e90c		744c			JE 0x40e95a		
  0x40e90e		4889442428		MOVQ AX, 0x28(SP)	
  0x40e913		488b442448		MOVQ 0x48(SP), AX	
	lock(&c.lock)
  0x40e918		48890424		MOVQ AX, 0(SP)		
  0x40e91c		e8ffabffff		CALL runtime.lock(SB)	
  0x40e921		488b442448		MOVQ 0x48(SP), AX	
	c.empty.insertBack(s)
  0x40e926		488d4820		LEAQ 0x20(AX), CX				
  0x40e92a		48890c24		MOVQ CX, 0(SP)					
  0x40e92e		488b4c2428		MOVQ 0x28(SP), CX				
  0x40e933		48894c2408		MOVQ CX, 0x8(SP)				
  0x40e938		e833da0000		CALL runtime.(*mSpanList).insertBack(SB)	
  0x40e93d		488b442448		MOVQ 0x48(SP), AX				
	unlock(&c.lock)
  0x40e942		48890424		MOVQ AX, 0(SP)		
  0x40e946		e875adffff		CALL runtime.unlock(SB)	
  0x40e94b		0fb644241b		MOVZX 0x1b(SP), AX	
  0x40e950		488b4c2428		MOVQ 0x28(SP), CX	
havespan:
  0x40e955		e9cffdffff		JMP 0x40e729		
		return nil
  0x40e95a		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x40e963		488b6c2438		MOVQ 0x38(SP), BP	
  0x40e968		4883c440		ADDQ $0x40, SP		
  0x40e96c		c3			RET			
		traceGCSweepDone()
  0x40e96d		e83ebd0200		CALL runtime.traceGCSweepDone(SB)	
  0x40e972		488b542448		MOVQ 0x48(SP), DX			
		traceDone = true
  0x40e977		e971ffffff		JMP 0x40e8ed		
  0x40e97c		48895c2428		MOVQ BX, 0x28(SP)	
			c.empty.remove(s)
  0x40e981		488d4220		LEAQ 0x20(DX), AX			
  0x40e985		4889442430		MOVQ AX, 0x30(SP)			
  0x40e98a		48890424		MOVQ AX, 0(SP)				
  0x40e98e		48895c2408		MOVQ BX, 0x8(SP)			
  0x40e993		e818d70000		CALL runtime.(*mSpanList).remove(SB)	
  0x40e998		488b442430		MOVQ 0x30(SP), AX			
			c.empty.insertBack(s)
  0x40e99d		48890424		MOVQ AX, 0(SP)					
  0x40e9a1		488b442428		MOVQ 0x28(SP), AX				
  0x40e9a6		4889442408		MOVQ AX, 0x8(SP)				
  0x40e9ab		e8c0d90000		CALL runtime.(*mSpanList).insertBack(SB)	
  0x40e9b0		488b442448		MOVQ 0x48(SP), AX				
			unlock(&c.lock)
  0x40e9b5		48890424		MOVQ AX, 0(SP)		
  0x40e9b9		e802adffff		CALL runtime.unlock(SB)	
  0x40e9be		488b442428		MOVQ 0x28(SP), AX	
			s.sweep(true)
  0x40e9c3		48890424		MOVQ AX, 0(SP)			
  0x40e9c7		c644240801		MOVB $0x1, 0x8(SP)		
  0x40e9cc		e8ef950000		CALL runtime.(*mspan).sweep(SB)	
  0x40e9d1		488b442428		MOVQ 0x28(SP), AX		
			freeIndex := s.nextFreeIndex()
  0x40e9d6		48890424		MOVQ AX, 0(SP)				
  0x40e9da		e8f1d4ffff		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x40e9df		488b442408		MOVQ 0x8(SP), AX			
  0x40e9e4		488b4c2428		MOVQ 0x28(SP), CX			
			if freeIndex != s.nelems {
  0x40e9e9		488b5138		MOVQ 0x38(CX), DX	
  0x40e9ed		4839d0			CMPQ DX, AX		
  0x40e9f0		7520			JNE 0x40ea12		
  0x40e9f2		488b442448		MOVQ 0x48(SP), AX	
			lock(&c.lock)
  0x40e9f7		48890424		MOVQ AX, 0(SP)		
  0x40e9fb		e820abffff		CALL runtime.lock(SB)	
  0x40ea00		8b4c241c		MOVL 0x1c(SP), CX	
			goto retry
  0x40ea04		488b542448		MOVQ 0x48(SP), DX	
	for s = c.nonempty.first; s != nil; s = s.next {
  0x40ea09		488b5a10		MOVQ 0x10(DX), BX	
  0x40ea0d		e99dfcffff		JMP 0x40e6af		
				s.freeindex = freeIndex
  0x40ea12		48894130		MOVQ AX, 0x30(CX)	
  0x40ea16		31c0			XORL AX, AX		
				goto havespan
  0x40ea18		e90cfdffff		JMP 0x40e729		
		traceGCSweepStart()
  0x40ea1d		e85ebb0200		CALL runtime.traceGCSweepStart(SB)	
  0x40ea22		e976fcffff		JMP 0x40e69d				
		throw("span has no free objects")
  0x40ea27		488d0508cf0500		LEAQ 0x5cf08(IP), AX	
  0x40ea2e		48890424		MOVQ AX, 0(SP)		
  0x40ea32		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x40ea3b		e890270100		CALL runtime.throw(SB)	
  0x40ea40		0f0b			UD2			
	cap := int32((s.npages << _PageShift) / s.elemsize)
  0x40ea42		e8d9100100		CALL runtime.panicdivide(SB)	
  0x40ea47		0f0b			UD2				
	spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize
  0x40ea49		e8f20f0100		CALL runtime.panicindex(SB)	
  0x40ea4e		0f0b			UD2				
func (c *mcentral) cacheSpan() *mspan {
  0x40ea50		e81b5b0300		CALL runtime.morestack_noctxt(SB)	
  0x40ea55		e9c6fbffff		JMP runtime.(*mcentral).cacheSpan(SB)	

TEXT runtime.(*mcentral).uncacheSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcentral.go
func (c *mcentral) uncacheSpan(s *mspan) {
  0x40ea60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ea69		483b6110		CMPQ 0x10(CX), SP	
  0x40ea6d		0f86fe000000		JBE 0x40eb71		
  0x40ea73		4883ec20		SUBQ $0x20, SP		
  0x40ea77		48896c2418		MOVQ BP, 0x18(SP)	
  0x40ea7c		488d6c2418		LEAQ 0x18(SP), BP	
  0x40ea81		488b442428		MOVQ 0x28(SP), AX	
	lock(&c.lock)
  0x40ea86		8400			TESTB AL, 0(AX)		
  0x40ea88		48890424		MOVQ AX, 0(SP)		
  0x40ea8c		e88faaffff		CALL runtime.lock(SB)	
func (c *mcentral) uncacheSpan(s *mspan) {
  0x40ea91		488b442430		MOVQ 0x30(SP), AX	
	s.incache = false
  0x40ea96		c6406300		MOVB $0x0, 0x63(AX)	
	if s.allocCount == 0 {
  0x40ea9a		0fb74860		MOVZX 0x60(AX), CX	
  0x40ea9e		6685c9			TESTW CX, CX		
  0x40eaa1		0f84af000000		JE 0x40eb56		
	cap := int32((s.npages << _PageShift) / s.elemsize)
  0x40eaa7		488b5020		MOVQ 0x20(AX), DX	
  0x40eaab		488b5868		MOVQ 0x68(AX), BX	
  0x40eaaf		4885db			TESTQ BX, BX		
  0x40eab2		0f8497000000		JE 0x40eb4f		
  0x40eab8		48c1e20d		SHLQ $0xd, DX		
  0x40eabc		4889c6			MOVQ AX, SI		
  0x40eabf		4889d0			MOVQ DX, AX		
  0x40eac2		31d2			XORL DX, DX		
  0x40eac4		48f7f3			DIVQ BX			
	n := cap - int32(s.allocCount)
  0x40eac7		0fb7c9			MOVZX CX, CX		
  0x40eaca		29c8			SUBL CX, AX		
	if n > 0 {
  0x40eacc		85c0			TESTL AX, AX		
  0x40eace		7f18			JG 0x40eae8		
  0x40ead0		488b442428		MOVQ 0x28(SP), AX	
	unlock(&c.lock)
  0x40ead5		48890424		MOVQ AX, 0(SP)		
  0x40ead9		e8e2abffff		CALL runtime.unlock(SB)	
}
  0x40eade		488b6c2418		MOVQ 0x18(SP), BP	
  0x40eae3		4883c420		ADDQ $0x20, SP		
  0x40eae7		c3			RET			
  0x40eae8		89442414		MOVL AX, 0x14(SP)	
  0x40eaec		488b442428		MOVQ 0x28(SP), AX	
		c.empty.remove(s)
  0x40eaf1		488d4820		LEAQ 0x20(AX), CX			
  0x40eaf5		48890c24		MOVQ CX, 0(SP)				
  0x40eaf9		4889742408		MOVQ SI, 0x8(SP)			
  0x40eafe		e8add50000		CALL runtime.(*mSpanList).remove(SB)	
  0x40eb03		488b442428		MOVQ 0x28(SP), AX			
		c.nonempty.insert(s)
  0x40eb08		488d4810		LEAQ 0x10(AX), CX			
  0x40eb0c		48890c24		MOVQ CX, 0(SP)				
  0x40eb10		488b4c2430		MOVQ 0x30(SP), CX			
  0x40eb15		48894c2408		MOVQ CX, 0x8(SP)			
  0x40eb1a		e831d70000		CALL runtime.(*mSpanList).insert(SB)	
  0x40eb1f		8b442414		MOVL 0x14(SP), AX			
		atomic.Xadd64(&memstats.heap_live, -int64(n)*int64(s.elemsize))
  0x40eb23		4863c0			MOVSXD AX, AX				
  0x40eb26		48f7d8			NEGQ AX					
  0x40eb29		488b4c2430		MOVQ 0x30(SP), CX			
  0x40eb2e		488b4968		MOVQ 0x68(CX), CX			
  0x40eb32		480fafc8		IMULQ AX, CX				
  0x40eb36		488d1503730b00		LEAQ runtime.memstats+5952(SB), DX	
  0x40eb3d		f0480fc10a		LOCK XADDQ CX, 0(DX)			
  0x40eb42		488b4c2428		MOVQ 0x28(SP), CX			
		atomic.Xadd64(&c.nmalloc, -int64(n))
  0x40eb47		f0480fc14130		LOCK XADDQ AX, 0x30(CX)	
  0x40eb4d		eb81			JMP 0x40ead0		
	cap := int32((s.npages << _PageShift) / s.elemsize)
  0x40eb4f		e8cc0f0100		CALL runtime.panicdivide(SB)	
  0x40eb54		0f0b			UD2				
		throw("uncaching span but s.allocCount == 0")
  0x40eb56		488d05c5e30500		LEAQ 0x5e3c5(IP), AX	
  0x40eb5d		48890424		MOVQ AX, 0(SP)		
  0x40eb61		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x40eb6a		e861260100		CALL runtime.throw(SB)	
  0x40eb6f		0f0b			UD2			
func (c *mcentral) uncacheSpan(s *mspan) {
  0x40eb71		e8fa590300		CALL runtime.morestack_noctxt(SB)	
  0x40eb76		e9e5feffff		JMP runtime.(*mcentral).uncacheSpan(SB)	

TEXT runtime.(*mcentral).freeSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcentral.go
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x40eb80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40eb89		483b6110		CMPQ 0x10(CX), SP	
  0x40eb8d		0f866b010000		JBE 0x40ecfe		
  0x40eb93		4883ec20		SUBQ $0x20, SP		
  0x40eb97		48896c2418		MOVQ BP, 0x18(SP)	
  0x40eb9c		488d6c2418		LEAQ 0x18(SP), BP	
  0x40eba1		488b442430		MOVQ 0x30(SP), AX	
	if s.incache {
  0x40eba6		0fb64863		MOVZX 0x63(AX), CX	
  0x40ebaa		84c9			TESTL CL, CL		
  0x40ebac		0f8531010000		JNE 0x40ece3		
	s.needzero = 1
  0x40ebb2		c6406501		MOVB $0x1, 0x65(AX)	
  0x40ebb6		0fb64c2438		MOVZX 0x38(SP), CX	
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x40ebbb		84c9			TESTL CL, CL		
	if preserve {
  0x40ebbd		7425			JE 0x40ebe4		
	return span.list != nil
  0x40ebbf		488b4810		MOVQ 0x10(AX), CX	
  0x40ebc3		4885c9			TESTQ CX, CX		
		if !s.inList() {
  0x40ebc6		0f84fc000000		JE 0x40ecc8		
		atomic.Store(&s.sweepgen, mheap_.sweepgen)
  0x40ebcc		8b0deee60900		MOVL runtime.mheap_+4128(SB), CX	
  0x40ebd2		874858			XCHGL CX, 0x58(AX)			
		return false
  0x40ebd5		c644244000		MOVB $0x0, 0x40(SP)	
  0x40ebda		488b6c2418		MOVQ 0x18(SP), BP	
  0x40ebdf		4883c420		ADDQ $0x20, SP		
  0x40ebe3		c3			RET			
  0x40ebe4		488b442428		MOVQ 0x28(SP), AX	
	lock(&c.lock)
  0x40ebe9		8400			TESTB AL, 0(AX)		
  0x40ebeb		48890424		MOVQ AX, 0(SP)		
  0x40ebef		e82ca9ffff		CALL runtime.lock(SB)	
  0x40ebf4		0fb6442439		MOVZX 0x39(SP), AX	
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x40ebf9		84c0			TESTL AL, AL		
	if wasempty {
  0x40ebfb		0f858a000000		JNE 0x40ec8b		
	atomic.Store(&s.sweepgen, mheap_.sweepgen)
  0x40ec01		8b05b9e60900		MOVL runtime.mheap_+4128(SB), AX	
  0x40ec07		488b4c2430		MOVQ 0x30(SP), CX			
  0x40ec0c		874158			XCHGL AX, 0x58(CX)			
	if s.allocCount != 0 {
  0x40ec0f		0fb74160		MOVZX 0x60(CX), AX	
  0x40ec13		6685c0			TESTW AX, AX		
  0x40ec16		741d			JE 0x40ec35		
  0x40ec18		488b442428		MOVQ 0x28(SP), AX	
		unlock(&c.lock)
  0x40ec1d		48890424		MOVQ AX, 0(SP)		
  0x40ec21		e89aaaffff		CALL runtime.unlock(SB)	
		return false
  0x40ec26		c644244000		MOVB $0x0, 0x40(SP)	
  0x40ec2b		488b6c2418		MOVQ 0x18(SP), BP	
  0x40ec30		4883c420		ADDQ $0x20, SP		
  0x40ec34		c3			RET			
  0x40ec35		488b442428		MOVQ 0x28(SP), AX	
	c.nonempty.remove(s)
  0x40ec3a		488d5010		LEAQ 0x10(AX), DX			
  0x40ec3e		48891424		MOVQ DX, 0(SP)				
  0x40ec42		48894c2408		MOVQ CX, 0x8(SP)			
  0x40ec47		e864d40000		CALL runtime.(*mSpanList).remove(SB)	
  0x40ec4c		488b442428		MOVQ 0x28(SP), AX			
	unlock(&c.lock)
  0x40ec51		48890424		MOVQ AX, 0(SP)		
  0x40ec55		e866aaffff		CALL runtime.unlock(SB)	
	mheap_.freeSpan(s, 0)
  0x40ec5a		488d053fd60900		LEAQ runtime.mheap_(SB), AX		
  0x40ec61		48890424		MOVQ AX, 0(SP)				
  0x40ec65		488b442430		MOVQ 0x30(SP), AX			
  0x40ec6a		4889442408		MOVQ AX, 0x8(SP)			
  0x40ec6f		c744241000000000	MOVL $0x0, 0x10(SP)			
  0x40ec77		e814c80000		CALL runtime.(*mheap).freeSpan(SB)	
	return true
  0x40ec7c		c644244001		MOVB $0x1, 0x40(SP)	
  0x40ec81		488b6c2418		MOVQ 0x18(SP), BP	
  0x40ec86		4883c420		ADDQ $0x20, SP		
  0x40ec8a		c3			RET			
  0x40ec8b		488b442428		MOVQ 0x28(SP), AX	
		c.empty.remove(s)
  0x40ec90		488d4820		LEAQ 0x20(AX), CX			
  0x40ec94		48890c24		MOVQ CX, 0(SP)				
  0x40ec98		488b4c2430		MOVQ 0x30(SP), CX			
  0x40ec9d		48894c2408		MOVQ CX, 0x8(SP)			
  0x40eca2		e809d40000		CALL runtime.(*mSpanList).remove(SB)	
  0x40eca7		488b442428		MOVQ 0x28(SP), AX			
		c.nonempty.insert(s)
  0x40ecac		488d4810		LEAQ 0x10(AX), CX			
  0x40ecb0		48890c24		MOVQ CX, 0(SP)				
  0x40ecb4		488b4c2430		MOVQ 0x30(SP), CX			
  0x40ecb9		48894c2408		MOVQ CX, 0x8(SP)			
  0x40ecbe		e88dd50000		CALL runtime.(*mSpanList).insert(SB)	
  0x40ecc3		e939ffffff		JMP 0x40ec01				
			throw("can't preserve unlinked span")
  0x40ecc8		488d0593d30500		LEAQ 0x5d393(IP), AX	
  0x40eccf		48890424		MOVQ AX, 0(SP)		
  0x40ecd3		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x40ecdc		e8ef240100		CALL runtime.throw(SB)	
  0x40ece1		0f0b			UD2			
		throw("freeSpan given cached span")
  0x40ece3		488d050acf0500		LEAQ 0x5cf0a(IP), AX	
  0x40ecea		48890424		MOVQ AX, 0(SP)		
  0x40ecee		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x40ecf7		e8d4240100		CALL runtime.throw(SB)	
  0x40ecfc		0f0b			UD2			
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x40ecfe		e86d580300		CALL runtime.morestack_noctxt(SB)	
  0x40ed03		e978feffff		JMP runtime.(*mcentral).freeSpan(SB)	

TEXT runtime.(*mcentral).grow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcentral.go
func (c *mcentral) grow() *mspan {
  0x40ed10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ed19		483b6110		CMPQ 0x10(CX), SP	
  0x40ed1d		0f860e010000		JBE 0x40ee31		
  0x40ed23		4883ec40		SUBQ $0x40, SP		
  0x40ed27		48896c2438		MOVQ BP, 0x38(SP)	
  0x40ed2c		488d6c2438		LEAQ 0x38(SP), BP	
  0x40ed31		488b4c2448		MOVQ 0x48(SP), CX	
	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
  0x40ed36		0fb64908		MOVZX 0x8(CX), CX	
  0x40ed3a		89ca			MOVL CX, DX		
	return int8(sc >> 1)
  0x40ed3c		d0e9			SHRL $0x1, CL		
	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
  0x40ed3e		480fbec9		MOVSX CL, CX					
  0x40ed42		4883f943		CMPQ $0x43, CX					
  0x40ed46		0f83de000000		JAE 0x40ee2a					
  0x40ed4c		488d1d6d630900		LEAQ runtime.class_to_allocnpages(SB), BX	
  0x40ed53		0fb6040b		MOVZX 0(BX)(CX*1), AX				
	size := uintptr(class_to_size[c.spanclass.sizeclass()])
  0x40ed57		488d1d62640900		LEAQ runtime.class_to_size(SB), BX	
  0x40ed5e		0fb70c4b		MOVZX 0(BX)(CX*2), CX			
	n := (npages << _PageShift) / size
  0x40ed62		4885c9			TESTQ CX, CX		
  0x40ed65		0f84b8000000		JE 0x40ee23		
  0x40ed6b		48894c2428		MOVQ CX, 0x28(SP)	
  0x40ed70		4889c3			MOVQ AX, BX		
  0x40ed73		48c1e00d		SHLQ $0xd, AX		
  0x40ed77		89d6			MOVL DX, SI		
  0x40ed79		31d2			XORL DX, DX		
  0x40ed7b		48f7f1			DIVQ CX			
  0x40ed7e		4889442420		MOVQ AX, 0x20(SP)	
	s := mheap_.alloc(npages, c.spanclass, false, true)
  0x40ed83		4088742410		MOVB SI, 0x10(SP)		
  0x40ed88		488d1511d50900		LEAQ runtime.mheap_(SB), DX	
  0x40ed8f		48891424		MOVQ DX, 0(SP)			
  0x40ed93		48895c2408		MOVQ BX, 0x8(SP)		
  0x40ed98		66c74424110001		MOVW $0x100, 0x11(SP)		
  0x40ed9f		e86cbe0000		CALL runtime.(*mheap).alloc(SB)	
  0x40eda4		488b4c2418		MOVQ 0x18(SP), CX		
	if s == nil {
  0x40eda9		4885c9			TESTQ CX, CX		
  0x40edac		7462			JE 0x40ee10		
  0x40edae		48894c2430		MOVQ CX, 0x30(SP)	
  0x40edb3		488b442428		MOVQ 0x28(SP), AX	
  0x40edb8		488b542420		MOVQ 0x20(SP), DX	
	s.limit = p + size*n
  0x40edbd		480fafc2		IMULQ DX, AX		
	return s.startAddr
  0x40edc1		488d5118		LEAQ 0x18(CX), DX	
	s.limit = p + size*n
  0x40edc5		480302			ADDQ 0(DX), AX		
  0x40edc8		48898180000000		MOVQ AX, 0x80(CX)	
	return s.startAddr
  0x40edcf		488b4118		MOVQ 0x18(CX), AX	
	heapBitsForSpan(s.base()).initSpan(s)
  0x40edd3		48890424		MOVQ AX, 0(SP)				
  0x40edd7		e884d3ffff		CALL runtime.heapBitsForSpan(SB)	
  0x40eddc		8b442410		MOVL 0x10(SP), AX			
  0x40ede0		488b4c2408		MOVQ 0x8(SP), CX			
  0x40ede5		48890c24		MOVQ CX, 0(SP)				
  0x40ede9		89442408		MOVL AX, 0x8(SP)			
  0x40eded		488b442430		MOVQ 0x30(SP), AX			
  0x40edf2		4889442410		MOVQ AX, 0x10(SP)			
  0x40edf7		e844e1ffff		CALL runtime.heapBits.initSpan(SB)	
	return s
  0x40edfc		488b442430		MOVQ 0x30(SP), AX	
  0x40ee01		4889442450		MOVQ AX, 0x50(SP)	
  0x40ee06		488b6c2438		MOVQ 0x38(SP), BP	
  0x40ee0b		4883c440		ADDQ $0x40, SP		
  0x40ee0f		c3			RET			
		return nil
  0x40ee10		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x40ee19		488b6c2438		MOVQ 0x38(SP), BP	
  0x40ee1e		4883c440		ADDQ $0x40, SP		
  0x40ee22		c3			RET			
	n := (npages << _PageShift) / size
  0x40ee23		e8f80c0100		CALL runtime.panicdivide(SB)	
  0x40ee28		0f0b			UD2				
	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
  0x40ee2a		e8110c0100		CALL runtime.panicindex(SB)	
  0x40ee2f		0f0b			UD2				
func (c *mcentral) grow() *mspan {
  0x40ee31		e83a570300		CALL runtime.morestack_noctxt(SB)	
  0x40ee36		e9d5feffff		JMP runtime.(*mcentral).grow(SB)	

TEXT runtime.addrspace_free(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func addrspace_free(v unsafe.Pointer, n uintptr) bool {
  0x40ee40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ee49		483b6110		CMPQ 0x10(CX), SP	
  0x40ee4d		0f8684000000		JBE 0x40eed7		
  0x40ee53		4883ec30		SUBQ $0x30, SP		
  0x40ee57		48896c2428		MOVQ BP, 0x28(SP)	
  0x40ee5c		488d6c2428		LEAQ 0x28(SP), BP	
  0x40ee61		31c0			XORL AX, AX		
	for off := uintptr(0); off < n; off += physPageSize {
  0x40ee63		eb10			JMP 0x40ee75				
  0x40ee65		488b0d344b0b00		MOVQ runtime.physPageSize(SB), CX	
  0x40ee6c		488b542420		MOVQ 0x20(SP), DX			
  0x40ee71		488d040a		LEAQ 0(DX)(CX*1), AX			
  0x40ee75		488b4c2440		MOVQ 0x40(SP), CX			
  0x40ee7a		4839c8			CMPQ CX, AX				
  0x40ee7d		7349			JAE 0x40eec8				
  0x40ee7f		4889442420		MOVQ AX, 0x20(SP)			
		errval := mincore(unsafe.Pointer(uintptr(v)+off), 1, &addrspace_vec[0])
  0x40ee84		488d0d164a0b00		LEAQ runtime.addrspace_vec(SB), CX	
  0x40ee8b		48894c2410		MOVQ CX, 0x10(SP)			
  0x40ee90		488b4c2438		MOVQ 0x38(SP), CX			
  0x40ee95		488d1401		LEAQ 0(CX)(AX*1), DX			
  0x40ee99		48891424		MOVQ DX, 0(SP)				
  0x40ee9d		48c744240801000000	MOVQ $0x1, 0x8(SP)			
  0x40eea6		e8d58a0300		CALL runtime.mincore(SB)		
  0x40eeab		8b442418		MOVL 0x18(SP), AX			
		if errval == -_EINVAL {
  0x40eeaf		83f8ea			CMPL $-0x16, AX		
  0x40eeb2		74b1			JE 0x40ee65		
		if errval != -_ENOMEM {
  0x40eeb4		83f8f4			CMPL $-0xc, AX		
  0x40eeb7		74ac			JE 0x40ee65		
			return false
  0x40eeb9		c644244800		MOVB $0x0, 0x48(SP)	
  0x40eebe		488b6c2428		MOVQ 0x28(SP), BP	
  0x40eec3		4883c430		ADDQ $0x30, SP		
  0x40eec7		c3			RET			
	return true
  0x40eec8		c644244801		MOVB $0x1, 0x48(SP)	
  0x40eecd		488b6c2428		MOVQ 0x28(SP), BP	
  0x40eed2		4883c430		ADDQ $0x30, SP		
  0x40eed6		c3			RET			
func addrspace_free(v unsafe.Pointer, n uintptr) bool {
  0x40eed7		e894560300		CALL runtime.morestack_noctxt(SB)	
  0x40eedc		e95fffffff		JMP runtime.addrspace_free(SB)		

TEXT runtime.mmap_fixed(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func mmap_fixed(v unsafe.Pointer, n uintptr, prot, flags, fd int32, offset uint32) (unsafe.Pointer, int) {
  0x40eef0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40eef9		483b6110		CMPQ 0x10(CX), SP	
  0x40eefd		0f8611010000		JBE 0x40f014		
  0x40ef03		4883ec48		SUBQ $0x48, SP		
  0x40ef07		48896c2440		MOVQ BP, 0x40(SP)	
  0x40ef0c		488d6c2440		LEAQ 0x40(SP), BP	
  0x40ef11		488b442450		MOVQ 0x50(SP), AX	
	p, err := mmap(v, n, prot, flags, fd, offset)
  0x40ef16		48890424		MOVQ AX, 0(SP)		
func mmap_fixed(v unsafe.Pointer, n uintptr, prot, flags, fd int32, offset uint32) (unsafe.Pointer, int) {
  0x40ef1a		488b4c2458		MOVQ 0x58(SP), CX	
	p, err := mmap(v, n, prot, flags, fd, offset)
  0x40ef1f		48894c2408		MOVQ CX, 0x8(SP)	
func mmap_fixed(v unsafe.Pointer, n uintptr, prot, flags, fd int32, offset uint32) (unsafe.Pointer, int) {
  0x40ef24		8b542460		MOVL 0x60(SP), DX	
	p, err := mmap(v, n, prot, flags, fd, offset)
  0x40ef28		89542410		MOVL DX, 0x10(SP)	
func mmap_fixed(v unsafe.Pointer, n uintptr, prot, flags, fd int32, offset uint32) (unsafe.Pointer, int) {
  0x40ef2c		8b5c2464		MOVL 0x64(SP), BX	
	p, err := mmap(v, n, prot, flags, fd, offset)
  0x40ef30		895c2414		MOVL BX, 0x14(SP)	
func mmap_fixed(v unsafe.Pointer, n uintptr, prot, flags, fd int32, offset uint32) (unsafe.Pointer, int) {
  0x40ef34		8b742468		MOVL 0x68(SP), SI	
	p, err := mmap(v, n, prot, flags, fd, offset)
  0x40ef38		89742418		MOVL SI, 0x18(SP)	
func mmap_fixed(v unsafe.Pointer, n uintptr, prot, flags, fd int32, offset uint32) (unsafe.Pointer, int) {
  0x40ef3c		8b7c246c		MOVL 0x6c(SP), DI	
	p, err := mmap(v, n, prot, flags, fd, offset)
  0x40ef40		897c241c		MOVL DI, 0x1c(SP)	
  0x40ef44		e82730ffff		CALL runtime.mmap(SB)	
  0x40ef49		488b442420		MOVQ 0x20(SP), AX	
  0x40ef4e		488b4c2428		MOVQ 0x28(SP), CX	
  0x40ef53		488b542450		MOVQ 0x50(SP), DX	
	if p != v && addrspace_free(v, n) {
  0x40ef58		4839d0			CMPQ DX, AX		
  0x40ef5b		7514			JNE 0x40ef71		
	return p, err
  0x40ef5d		4889442470		MOVQ AX, 0x70(SP)	
  0x40ef62		48894c2478		MOVQ CX, 0x78(SP)	
  0x40ef67		488b6c2440		MOVQ 0x40(SP), BP	
  0x40ef6c		4883c448		ADDQ $0x48, SP		
  0x40ef70		c3			RET			
  0x40ef71		4889442438		MOVQ AX, 0x38(SP)	
  0x40ef76		48894c2430		MOVQ CX, 0x30(SP)	
	if p != v && addrspace_free(v, n) {
  0x40ef7b		48891424		MOVQ DX, 0(SP)			
  0x40ef7f		488b442458		MOVQ 0x58(SP), AX		
  0x40ef84		4889442408		MOVQ AX, 0x8(SP)		
  0x40ef89		e8b2feffff		CALL runtime.addrspace_free(SB)	
  0x40ef8e		0fb6442410		MOVZX 0x10(SP), AX		
  0x40ef93		84c0			TESTL AL, AL			
  0x40ef95		746e			JE 0x40f005			
  0x40ef97		488b442430		MOVQ 0x30(SP), AX		
		if err == 0 {
  0x40ef9c		4885c0			TESTQ AX, AX		
  0x40ef9f		744a			JE 0x40efeb		
  0x40efa1		488b442450		MOVQ 0x50(SP), AX	
		p, err = mmap(v, n, prot, flags|_MAP_FIXED, fd, offset)
  0x40efa6		48890424		MOVQ AX, 0(SP)		
  0x40efaa		488b442458		MOVQ 0x58(SP), AX	
  0x40efaf		4889442408		MOVQ AX, 0x8(SP)	
  0x40efb4		8b442460		MOVL 0x60(SP), AX	
  0x40efb8		89442410		MOVL AX, 0x10(SP)	
  0x40efbc		8b442464		MOVL 0x64(SP), AX	
  0x40efc0		83c810			ORL $0x10, AX		
  0x40efc3		89442414		MOVL AX, 0x14(SP)	
  0x40efc7		8b442468		MOVL 0x68(SP), AX	
  0x40efcb		89442418		MOVL AX, 0x18(SP)	
  0x40efcf		8b44246c		MOVL 0x6c(SP), AX	
  0x40efd3		8944241c		MOVL AX, 0x1c(SP)	
  0x40efd7		e8942fffff		CALL runtime.mmap(SB)	
  0x40efdc		488b442420		MOVQ 0x20(SP), AX	
  0x40efe1		488b4c2428		MOVQ 0x28(SP), CX	
  0x40efe6		e972ffffff		JMP 0x40ef5d		
  0x40efeb		488b442438		MOVQ 0x38(SP), AX	
			munmap(p, n)
  0x40eff0		48890424		MOVQ AX, 0(SP)		
  0x40eff4		488b442458		MOVQ 0x58(SP), AX	
  0x40eff9		4889442408		MOVQ AX, 0x8(SP)	
  0x40effe		e8ed30ffff		CALL runtime.munmap(SB)	
  0x40f003		eb9c			JMP 0x40efa1		
  0x40f005		488b442438		MOVQ 0x38(SP), AX	
  0x40f00a		488b4c2430		MOVQ 0x30(SP), CX	
	if p != v && addrspace_free(v, n) {
  0x40f00f		e949ffffff		JMP 0x40ef5d		
func mmap_fixed(v unsafe.Pointer, n uintptr, prot, flags, fd int32, offset uint32) (unsafe.Pointer, int) {
  0x40f014		e857550300		CALL runtime.morestack_noctxt(SB)	
  0x40f019		e9d2feffff		JMP runtime.mmap_fixed(SB)		

TEXT runtime.sysAlloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {
  0x40f020		4883ec48		SUBQ $0x48, SP		
  0x40f024		48896c2440		MOVQ BP, 0x40(SP)	
  0x40f029		488d6c2440		LEAQ 0x40(SP), BP	
	p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x40f02e		48c7042400000000	MOVQ $0x0, 0(SP)	
func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {
  0x40f036		488b442450		MOVQ 0x50(SP), AX	
	p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x40f03b		4889442408		MOVQ AX, 0x8(SP)	
  0x40f040		48b90300000022000000	MOVQ $0x2200000003, CX	
  0x40f04a		48894c2410		MOVQ CX, 0x10(SP)	
  0x40f04f		b9ffffffff		MOVL $-0x1, CX		
  0x40f054		48894c2418		MOVQ CX, 0x18(SP)	
  0x40f059		e8122fffff		CALL runtime.mmap(SB)	
  0x40f05e		488b442420		MOVQ 0x20(SP), AX	
  0x40f063		488b4c2428		MOVQ 0x28(SP), CX	
	if err != 0 {
  0x40f068		4885c9			TESTQ CX, CX		
  0x40f06b		0f848e000000		JE 0x40f0ff		
		if err == _EACCES {
  0x40f071		4883f90d		CMPQ $0xd, CX		
  0x40f075		744a			JE 0x40f0c1		
		if err == _EAGAIN {
  0x40f077		4883f90b		CMPQ $0xb, CX		
  0x40f07b		7413			JE 0x40f090		
		return nil
  0x40f07d		48c744246000000000	MOVQ $0x0, 0x60(SP)	
  0x40f086		488b6c2440		MOVQ 0x40(SP), BP	
  0x40f08b		4883c448		ADDQ $0x48, SP		
  0x40f08f		c3			RET			
			print("runtime: mmap: too much locked memory (check 'ulimit -l').\n")
  0x40f090		e86b2a0100		CALL runtime.printlock(SB)	
  0x40f095		488d05e6ec0500		LEAQ 0x5ece6(IP), AX		
  0x40f09c		48890424		MOVQ AX, 0(SP)			
  0x40f0a0		48c74424083b000000	MOVQ $0x3b, 0x8(SP)		
  0x40f0a9		e892330100		CALL runtime.printstring(SB)	
  0x40f0ae		e8cd2a0100		CALL runtime.printunlock(SB)	
			exit(2)
  0x40f0b3		c7042402000000		MOVL $0x2, 0(SP)	
  0x40f0ba		e811870300		CALL runtime.exit(SB)	
  0x40f0bf		ebbc			JMP 0x40f07d		
  0x40f0c1		48894c2430		MOVQ CX, 0x30(SP)	
			print("runtime: mmap: access denied\n")
  0x40f0c6		e8352a0100		CALL runtime.printlock(SB)	
  0x40f0cb		488d051cd20500		LEAQ 0x5d21c(IP), AX		
  0x40f0d2		48890424		MOVQ AX, 0(SP)			
  0x40f0d6		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x40f0df		e85c330100		CALL runtime.printstring(SB)	
  0x40f0e4		e8972a0100		CALL runtime.printunlock(SB)	
			exit(2)
  0x40f0e9		c7042402000000		MOVL $0x2, 0(SP)	
  0x40f0f0		e8db860300		CALL runtime.exit(SB)	
  0x40f0f5		488b4c2430		MOVQ 0x30(SP), CX	
  0x40f0fa		e978ffffff		JMP 0x40f077		
  0x40f0ff		4889442438		MOVQ AX, 0x38(SP)	
  0x40f104		488b442458		MOVQ 0x58(SP), AX	
	mSysStatInc(sysStat, n)
  0x40f109		48890424		MOVQ AX, 0(SP)			
  0x40f10d		488b442450		MOVQ 0x50(SP), AX		
  0x40f112		4889442408		MOVQ AX, 0x8(SP)		
  0x40f117		e8d4f10000		CALL runtime.mSysStatInc(SB)	
	return p
  0x40f11c		488b442438		MOVQ 0x38(SP), AX	
  0x40f121		4889442460		MOVQ AX, 0x60(SP)	
  0x40f126		488b6c2440		MOVQ 0x40(SP), BP	
  0x40f12b		4883c448		ADDQ $0x48, SP		
  0x40f12f		c3			RET			

TEXT runtime.sysUnused(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func sysUnused(v unsafe.Pointer, n uintptr) {
  0x40f130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f139		483b6110		CMPQ 0x10(CX), SP	
  0x40f13d		0f8668010000		JBE 0x40f2ab		
  0x40f143		4883ec30		SUBQ $0x30, SP		
  0x40f147		48896c2428		MOVQ BP, 0x28(SP)	
  0x40f14c		488d6c2428		LEAQ 0x28(SP), BP	
  0x40f151		488b442438		MOVQ 0x38(SP), AX	
  0x40f156		4889c1			MOVQ AX, CX		
		if uintptr(v)%s != 0 {
  0x40f159		48a9ffff1f00		TESTQ $0x1fffff, AX	
  0x40f15f		0f8421010000		JE 0x40f286		
  0x40f165		4889c2			MOVQ AX, DX		
			head = uintptr(v) &^ (s - 1)
  0x40f168		48250000e0ff		ANDQ $-0x200000, AX	
  0x40f16e		488b5c2440		MOVQ 0x40(SP), BX	
		if (uintptr(v)+n)%s != 0 {
  0x40f173		488d3413		LEAQ 0(BX)(DX*1), SI	
  0x40f177		48f7c6ffff1f00		TESTQ $0x1fffff, SI	
  0x40f17e		0f84fb000000		JE 0x40f27f		
			tail = (uintptr(v) + n - 1) &^ (s - 1)
  0x40f184		488d5413ff		LEAQ -0x1(BX)(DX*1), DX	
  0x40f189		4881e20000e0ff		ANDQ $-0x200000, DX	
		if head != 0 && head+sys.HugePageSize == tail {
  0x40f190		4885c0			TESTQ AX, AX		
  0x40f193		7413			JE 0x40f1a8		
  0x40f195		488db000002000		LEAQ 0x200000(AX), SI	
  0x40f19c		4839d6			CMPQ DX, SI		
  0x40f19f		0f84b1000000		JE 0x40f256		
  0x40f1a5		4885c0			TESTQ AX, AX		
			if head != 0 {
  0x40f1a8		756f			JNE 0x40f219		
			if tail != 0 && tail != head {
  0x40f1aa		4885d2			TESTQ DX, DX		
  0x40f1ad		7405			JE 0x40f1b4		
  0x40f1af		4839d0			CMPQ DX, AX		
  0x40f1b2		753f			JNE 0x40f1f3		
  0x40f1b4		4889c8			MOVQ CX, AX		
	if uintptr(v)&(physPageSize-1) != 0 || n&(physPageSize-1) != 0 {
  0x40f1b7		488b15e2470b00		MOVQ runtime.physPageSize(SB), DX	
  0x40f1be		48ffca			DECQ DX					
  0x40f1c1		4885d1			TESTQ DX, CX				
  0x40f1c4		0f85c6000000		JNE 0x40f290				
  0x40f1ca		4885d3			TESTQ DX, BX				
  0x40f1cd		0f85bd000000		JNE 0x40f290				
	madvise(v, n, _MADV_DONTNEED)
  0x40f1d3		48890424		MOVQ AX, 0(SP)			
  0x40f1d7		48895c2408		MOVQ BX, 0x8(SP)		
  0x40f1dc		c744241004000000	MOVL $0x4, 0x10(SP)		
  0x40f1e4		e8078c0300		CALL runtime.madvise(SB)	
}
  0x40f1e9		488b6c2428		MOVQ 0x28(SP), BP	
  0x40f1ee		4883c430		ADDQ $0x30, SP		
  0x40f1f2		c3			RET			
				madvise(unsafe.Pointer(tail), sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x40f1f3		48891424		MOVQ DX, 0(SP)			
  0x40f1f7		48c744240800002000	MOVQ $0x200000, 0x8(SP)		
  0x40f200		c74424100f000000	MOVL $0xf, 0x10(SP)		
  0x40f208		e8e38b0300		CALL runtime.madvise(SB)	
  0x40f20d		488b4c2438		MOVQ 0x38(SP), CX		
  0x40f212		488b5c2440		MOVQ 0x40(SP), BX		
  0x40f217		eb9b			JMP 0x40f1b4			
  0x40f219		4889542418		MOVQ DX, 0x18(SP)		
  0x40f21e		4889442420		MOVQ AX, 0x20(SP)		
				madvise(unsafe.Pointer(head), sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x40f223		48890424		MOVQ AX, 0(SP)			
  0x40f227		48c744240800002000	MOVQ $0x200000, 0x8(SP)		
  0x40f230		c74424100f000000	MOVL $0xf, 0x10(SP)		
  0x40f238		e8b38b0300		CALL runtime.madvise(SB)	
  0x40f23d		488b442420		MOVQ 0x20(SP), AX		
  0x40f242		488b4c2438		MOVQ 0x38(SP), CX		
  0x40f247		488b542418		MOVQ 0x18(SP), DX		
  0x40f24c		488b5c2440		MOVQ 0x40(SP), BX		
  0x40f251		e954ffffff		JMP 0x40f1aa			
			madvise(unsafe.Pointer(head), 2*sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x40f256		48890424		MOVQ AX, 0(SP)			
  0x40f25a		48c744240800004000	MOVQ $0x400000, 0x8(SP)		
  0x40f263		c74424100f000000	MOVL $0xf, 0x10(SP)		
  0x40f26b		e8808b0300		CALL runtime.madvise(SB)	
  0x40f270		488b4c2438		MOVQ 0x38(SP), CX		
  0x40f275		488b5c2440		MOVQ 0x40(SP), BX		
  0x40f27a		e935ffffff		JMP 0x40f1b4			
  0x40f27f		31d2			XORL DX, DX			
		if (uintptr(v)+n)%s != 0 {
  0x40f281		e90affffff		JMP 0x40f190		
  0x40f286		4889c2			MOVQ AX, DX		
  0x40f289		31c0			XORL AX, AX		
		if uintptr(v)%s != 0 {
  0x40f28b		e9defeffff		JMP 0x40f16e		
		throw("unaligned sysUnused")
  0x40f290		488d051fbd0500		LEAQ 0x5bd1f(IP), AX	
  0x40f297		48890424		MOVQ AX, 0(SP)		
  0x40f29b		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x40f2a4		e8271f0100		CALL runtime.throw(SB)	
  0x40f2a9		0f0b			UD2			
func sysUnused(v unsafe.Pointer, n uintptr) {
  0x40f2ab		e8c0520300		CALL runtime.morestack_noctxt(SB)	
  0x40f2b0		e97bfeffff		JMP runtime.sysUnused(SB)		

TEXT runtime.sysUsed(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func sysUsed(v unsafe.Pointer, n uintptr) {
  0x40f2c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f2c9		483b6110		CMPQ 0x10(CX), SP	
  0x40f2cd		765c			JBE 0x40f32b		
  0x40f2cf		4883ec20		SUBQ $0x20, SP		
  0x40f2d3		48896c2418		MOVQ BP, 0x18(SP)	
  0x40f2d8		488d6c2418		LEAQ 0x18(SP), BP	
  0x40f2dd		488b442428		MOVQ 0x28(SP), AX	
		beg := (uintptr(v) + (s - 1)) &^ (s - 1)
  0x40f2e2		488d88ffff1f00		LEAQ 0x1fffff(AX), CX	
  0x40f2e9		4881e10000e0ff		ANDQ $-0x200000, CX	
  0x40f2f0		488b542430		MOVQ 0x30(SP), DX	
		end := (uintptr(v) + n) &^ (s - 1)
  0x40f2f5		4801d0			ADDQ DX, AX		
  0x40f2f8		48250000e0ff		ANDQ $-0x200000, AX	
		if beg < end {
  0x40f2fe		4839c1			CMPQ AX, CX		
  0x40f301		720a			JB 0x40f30d		
  0x40f303		488b6c2418		MOVQ 0x18(SP), BP	
  0x40f308		4883c420		ADDQ $0x20, SP		
  0x40f30c		c3			RET			
  0x40f30d		4889ca			MOVQ CX, DX		
			madvise(unsafe.Pointer(beg), end-beg, _MADV_HUGEPAGE)
  0x40f310		48890c24		MOVQ CX, 0(SP)			
  0x40f314		4829d0			SUBQ DX, AX			
  0x40f317		4889442408		MOVQ AX, 0x8(SP)		
  0x40f31c		c74424100e000000	MOVL $0xe, 0x10(SP)		
  0x40f324		e8c78a0300		CALL runtime.madvise(SB)	
  0x40f329		ebd8			JMP 0x40f303			
func sysUsed(v unsafe.Pointer, n uintptr) {
  0x40f32b		e840520300		CALL runtime.morestack_noctxt(SB)	
  0x40f330		eb8e			JMP runtime.sysUsed(SB)			

TEXT runtime.sysFree(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64) {
  0x40f340		4883ec18		SUBQ $0x18, SP		
  0x40f344		48896c2410		MOVQ BP, 0x10(SP)	
  0x40f349		488d6c2410		LEAQ 0x10(SP), BP	
  0x40f34e		488b442430		MOVQ 0x30(SP), AX	
	mSysStatDec(sysStat, n)
  0x40f353		48890424		MOVQ AX, 0(SP)		
func sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64) {
  0x40f357		488b442428		MOVQ 0x28(SP), AX	
	mSysStatDec(sysStat, n)
  0x40f35c		4889442408		MOVQ AX, 0x8(SP)		
  0x40f361		e83af00000		CALL runtime.mSysStatDec(SB)	
func sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64) {
  0x40f366		488b442420		MOVQ 0x20(SP), AX	
	munmap(v, n)
  0x40f36b		48890424		MOVQ AX, 0(SP)		
  0x40f36f		488b442428		MOVQ 0x28(SP), AX	
  0x40f374		4889442408		MOVQ AX, 0x8(SP)	
  0x40f379		e8722dffff		CALL runtime.munmap(SB)	
}
  0x40f37e		488b6c2410		MOVQ 0x10(SP), BP	
  0x40f383		4883c418		ADDQ $0x18, SP		
  0x40f387		c3			RET			

TEXT runtime.sysFault(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func sysFault(v unsafe.Pointer, n uintptr) {
  0x40f390		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f399		483b6110		CMPQ 0x10(CX), SP	
  0x40f39d		7649			JBE 0x40f3e8		
  0x40f39f		4883ec38		SUBQ $0x38, SP		
  0x40f3a3		48896c2430		MOVQ BP, 0x30(SP)	
  0x40f3a8		488d6c2430		LEAQ 0x30(SP), BP	
  0x40f3ad		488b442440		MOVQ 0x40(SP), AX	
	mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE|_MAP_FIXED, -1, 0)
  0x40f3b2		48890424		MOVQ AX, 0(SP)		
func sysFault(v unsafe.Pointer, n uintptr) {
  0x40f3b6		488b442448		MOVQ 0x48(SP), AX	
	mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE|_MAP_FIXED, -1, 0)
  0x40f3bb		4889442408		MOVQ AX, 0x8(SP)	
  0x40f3c0		48b80000000032000000	MOVQ $0x3200000000, AX	
  0x40f3ca		4889442410		MOVQ AX, 0x10(SP)	
  0x40f3cf		b8ffffffff		MOVL $-0x1, AX		
  0x40f3d4		4889442418		MOVQ AX, 0x18(SP)	
  0x40f3d9		e8922bffff		CALL runtime.mmap(SB)	
}
  0x40f3de		488b6c2430		MOVQ 0x30(SP), BP	
  0x40f3e3		4883c438		ADDQ $0x38, SP		
  0x40f3e7		c3			RET			
func sysFault(v unsafe.Pointer, n uintptr) {
  0x40f3e8		e883510300		CALL runtime.morestack_noctxt(SB)	
  0x40f3ed		eba1			JMP runtime.sysFault(SB)		

TEXT runtime.sysReserve(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer {
  0x40f3f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f3f9		483b6110		CMPQ 0x10(CX), SP	
  0x40f3fd		0f862e010000		JBE 0x40f531		
  0x40f403		4883ec38		SUBQ $0x38, SP		
  0x40f407		48896c2430		MOVQ BP, 0x30(SP)	
  0x40f40c		488d6c2430		LEAQ 0x30(SP), BP	
  0x40f411		488b442448		MOVQ 0x48(SP), AX	
	if sys.PtrSize == 8 && uint64(n) > 1<<32 {
  0x40f416		48b90000000001000000	MOVQ $0x100000000, CX	
  0x40f420		4839c8			CMPQ CX, AX		
  0x40f423		0f86a3000000		JBE 0x40f4cc		
  0x40f429		488b442440		MOVQ 0x40(SP), AX	
		p, err := mmap_fixed(v, 64<<10, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x40f42e		48890424		MOVQ AX, 0(SP)			
  0x40f432		48c744240800000100	MOVQ $0x10000, 0x8(SP)		
  0x40f43b		48b90000000022000000	MOVQ $0x2200000000, CX		
  0x40f445		48894c2410		MOVQ CX, 0x10(SP)		
  0x40f44a		b9ffffffff		MOVL $-0x1, CX			
  0x40f44f		48894c2418		MOVQ CX, 0x18(SP)		
  0x40f454		e897faffff		CALL runtime.mmap_fixed(SB)	
  0x40f459		488b442420		MOVQ 0x20(SP), AX		
  0x40f45e		488b4c2428		MOVQ 0x28(SP), CX		
  0x40f463		488b542440		MOVQ 0x40(SP), DX		
		if p != v || err != 0 {
  0x40f468		4839d0			CMPQ DX, AX		
  0x40f46b		742c			JE 0x40f499		
			if err == 0 {
  0x40f46d		4885c9			TESTQ CX, CX		
  0x40f470		7413			JE 0x40f485		
			return nil
  0x40f472		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x40f47b		488b6c2430		MOVQ 0x30(SP), BP	
  0x40f480		4883c438		ADDQ $0x38, SP		
  0x40f484		c3			RET			
				munmap(p, 64<<10)
  0x40f485		48890424		MOVQ AX, 0(SP)		
  0x40f489		48c744240800000100	MOVQ $0x10000, 0x8(SP)	
  0x40f492		e8592cffff		CALL runtime.munmap(SB)	
  0x40f497		ebd9			JMP 0x40f472		
		if p != v || err != 0 {
  0x40f499		4885c9			TESTQ CX, CX		
  0x40f49c		75cf			JNE 0x40f46d		
		munmap(p, 64<<10)
  0x40f49e		48890424		MOVQ AX, 0(SP)		
  0x40f4a2		48c744240800000100	MOVQ $0x10000, 0x8(SP)	
  0x40f4ab		e8402cffff		CALL runtime.munmap(SB)	
  0x40f4b0		488b442450		MOVQ 0x50(SP), AX	
		*reserved = false
  0x40f4b5		c60000			MOVB $0x0, 0(AX)	
		return v
  0x40f4b8		488b442440		MOVQ 0x40(SP), AX	
  0x40f4bd		4889442458		MOVQ AX, 0x58(SP)	
  0x40f4c2		488b6c2430		MOVQ 0x30(SP), BP	
  0x40f4c7		4883c438		ADDQ $0x38, SP		
  0x40f4cb		c3			RET			
  0x40f4cc		488b4c2440		MOVQ 0x40(SP), CX	
	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x40f4d1		48890c24		MOVQ CX, 0(SP)		
  0x40f4d5		4889442408		MOVQ AX, 0x8(SP)	
  0x40f4da		48b80000000022000000	MOVQ $0x2200000000, AX	
  0x40f4e4		4889442410		MOVQ AX, 0x10(SP)	
  0x40f4e9		b8ffffffff		MOVL $-0x1, AX		
  0x40f4ee		4889442418		MOVQ AX, 0x18(SP)	
  0x40f4f3		e8782affff		CALL runtime.mmap(SB)	
  0x40f4f8		488b442420		MOVQ 0x20(SP), AX	
  0x40f4fd		488b4c2428		MOVQ 0x28(SP), CX	
	if err != 0 {
  0x40f502		4885c9			TESTQ CX, CX		
  0x40f505		7413			JE 0x40f51a		
		return nil
  0x40f507		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x40f510		488b6c2430		MOVQ 0x30(SP), BP	
  0x40f515		4883c438		ADDQ $0x38, SP		
  0x40f519		c3			RET			
  0x40f51a		488b4c2450		MOVQ 0x50(SP), CX	
	*reserved = true
  0x40f51f		c60101			MOVB $0x1, 0(CX)	
	return p
  0x40f522		4889442458		MOVQ AX, 0x58(SP)	
  0x40f527		488b6c2430		MOVQ 0x30(SP), BP	
  0x40f52c		4883c438		ADDQ $0x38, SP		
  0x40f530		c3			RET			
func sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer {
  0x40f531		e83a500300		CALL runtime.morestack_noctxt(SB)	
  0x40f536		e9b5feffff		JMP runtime.sysReserve(SB)		

TEXT runtime.sysMap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mem_linux.go
func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {
  0x40f540		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f549		483b6110		CMPQ 0x10(CX), SP	
  0x40f54d		0f86f9010000		JBE 0x40f74c		
  0x40f553		4883ec48		SUBQ $0x48, SP		
  0x40f557		48896c2440		MOVQ BP, 0x40(SP)	
  0x40f55c		488d6c2440		LEAQ 0x40(SP), BP	
  0x40f561		488b442468		MOVQ 0x68(SP), AX	
	mSysStatInc(sysStat, n)
  0x40f566		48890424		MOVQ AX, 0(SP)		
func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {
  0x40f56a		488b442458		MOVQ 0x58(SP), AX	
	mSysStatInc(sysStat, n)
  0x40f56f		4889442408		MOVQ AX, 0x8(SP)		
  0x40f574		e877ed0000		CALL runtime.mSysStatInc(SB)	
func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {
  0x40f579		0fb6442460		MOVZX 0x60(SP), AX	
  0x40f57e		84c0			TESTL AL, AL		
	if !reserved {
  0x40f580		745e			JE 0x40f5e0		
  0x40f582		488b442450		MOVQ 0x50(SP), AX	
	p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)
  0x40f587		48890424		MOVQ AX, 0(SP)		
  0x40f58b		488b4c2458		MOVQ 0x58(SP), CX	
  0x40f590		48894c2408		MOVQ CX, 0x8(SP)	
  0x40f595		48b90300000032000000	MOVQ $0x3200000003, CX	
  0x40f59f		48894c2410		MOVQ CX, 0x10(SP)	
  0x40f5a4		b9ffffffff		MOVL $-0x1, CX		
  0x40f5a9		48894c2418		MOVQ CX, 0x18(SP)	
  0x40f5ae		e8bd29ffff		CALL runtime.mmap(SB)	
  0x40f5b3		488b442420		MOVQ 0x20(SP), AX	
  0x40f5b8		488b4c2428		MOVQ 0x28(SP), CX	
	if err == _ENOMEM {
  0x40f5bd		4883f90c		CMPQ $0xc, CX		
  0x40f5c1		0f849c000000		JE 0x40f663		
  0x40f5c7		488b542450		MOVQ 0x50(SP), DX	
	if p != v || err != 0 {
  0x40f5cc		4839d0			CMPQ DX, AX		
  0x40f5cf		7577			JNE 0x40f648		
  0x40f5d1		4885c9			TESTQ CX, CX		
  0x40f5d4		7572			JNE 0x40f648		
  0x40f5d6		488b6c2440		MOVQ 0x40(SP), BP	
  0x40f5db		4883c448		ADDQ $0x48, SP		
  0x40f5df		c3			RET			
  0x40f5e0		488b442450		MOVQ 0x50(SP), AX	
		p, err := mmap_fixed(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x40f5e5		48890424		MOVQ AX, 0(SP)			
  0x40f5e9		488b4c2458		MOVQ 0x58(SP), CX		
  0x40f5ee		48894c2408		MOVQ CX, 0x8(SP)		
  0x40f5f3		48b90300000022000000	MOVQ $0x2200000003, CX		
  0x40f5fd		48894c2410		MOVQ CX, 0x10(SP)		
  0x40f602		b9ffffffff		MOVL $-0x1, CX			
  0x40f607		48894c2418		MOVQ CX, 0x18(SP)		
  0x40f60c		e8dff8ffff		CALL runtime.mmap_fixed(SB)	
  0x40f611		488b442420		MOVQ 0x20(SP), AX		
  0x40f616		488b4c2428		MOVQ 0x28(SP), CX		
		if err == _ENOMEM {
  0x40f61b		4883f90c		CMPQ $0xc, CX		
  0x40f61f		0f840c010000		JE 0x40f731		
  0x40f625		4889442438		MOVQ AX, 0x38(SP)	
  0x40f62a		48894c2430		MOVQ CX, 0x30(SP)	
  0x40f62f		488b542450		MOVQ 0x50(SP), DX	
		if p != v || err != 0 {
  0x40f634		4839d0			CMPQ DX, AX		
  0x40f637		7545			JNE 0x40f67e		
  0x40f639		4885c9			TESTQ CX, CX		
  0x40f63c		7540			JNE 0x40f67e		
		return
  0x40f63e		488b6c2440		MOVQ 0x40(SP), BP	
  0x40f643		4883c448		ADDQ $0x48, SP		
  0x40f647		c3			RET			
		throw("runtime: cannot map pages in arena address space")
  0x40f648		488d057ee20500		LEAQ 0x5e27e(IP), AX	
  0x40f64f		48890424		MOVQ AX, 0(SP)		
  0x40f653		48c744240830000000	MOVQ $0x30, 0x8(SP)	
  0x40f65c		e86f1b0100		CALL runtime.throw(SB)	
  0x40f661		0f0b			UD2			
		throw("runtime: out of memory")
  0x40f663		488d0564be0500		LEAQ 0x5be64(IP), AX	
  0x40f66a		48890424		MOVQ AX, 0(SP)		
  0x40f66e		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x40f677		e8541b0100		CALL runtime.throw(SB)	
  0x40f67c		0f0b			UD2			
			print("runtime: address space conflict: map(", v, ") = ", p, " (err ", err, ")\n")
  0x40f67e		e87d240100		CALL runtime.printlock(SB)	
  0x40f683		488d052bd90500		LEAQ 0x5d92b(IP), AX		
  0x40f68a		48890424		MOVQ AX, 0(SP)			
  0x40f68e		48c744240825000000	MOVQ $0x25, 0x8(SP)		
  0x40f697		e8a42d0100		CALL runtime.printstring(SB)	
  0x40f69c		488b442450		MOVQ 0x50(SP), AX		
  0x40f6a1		48890424		MOVQ AX, 0(SP)			
  0x40f6a5		e8562d0100		CALL runtime.printpointer(SB)	
  0x40f6aa		488d052da60500		LEAQ 0x5a62d(IP), AX		
  0x40f6b1		48890424		MOVQ AX, 0(SP)			
  0x40f6b5		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x40f6be		e87d2d0100		CALL runtime.printstring(SB)	
  0x40f6c3		488b442438		MOVQ 0x38(SP), AX		
  0x40f6c8		48890424		MOVQ AX, 0(SP)			
  0x40f6cc		e82f2d0100		CALL runtime.printpointer(SB)	
  0x40f6d1		488d0509a70500		LEAQ 0x5a709(IP), AX		
  0x40f6d8		48890424		MOVQ AX, 0(SP)			
  0x40f6dc		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x40f6e5		e8562d0100		CALL runtime.printstring(SB)	
  0x40f6ea		488b442430		MOVQ 0x30(SP), AX		
  0x40f6ef		48890424		MOVQ AX, 0(SP)			
  0x40f6f3		e8882b0100		CALL runtime.printint(SB)	
  0x40f6f8		488d056ba50500		LEAQ 0x5a56b(IP), AX		
  0x40f6ff		48890424		MOVQ AX, 0(SP)			
  0x40f703		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x40f70c		e82f2d0100		CALL runtime.printstring(SB)	
  0x40f711		e86a240100		CALL runtime.printunlock(SB)	
			throw("runtime: address space conflict")
  0x40f716		488d0529d00500		LEAQ 0x5d029(IP), AX	
  0x40f71d		48890424		MOVQ AX, 0(SP)		
  0x40f721		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x40f72a		e8a11a0100		CALL runtime.throw(SB)	
  0x40f72f		0f0b			UD2			
			throw("runtime: out of memory")
  0x40f731		488d0596bd0500		LEAQ 0x5bd96(IP), AX	
  0x40f738		48890424		MOVQ AX, 0(SP)		
  0x40f73c		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x40f745		e8861a0100		CALL runtime.throw(SB)	
  0x40f74a		0f0b			UD2			
func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {
  0x40f74c		e81f4e0300		CALL runtime.morestack_noctxt(SB)	
  0x40f751		e9eafdffff		JMP runtime.sysMap(SB)			

TEXT runtime.queuefinalizer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mfinal.go
func queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype) {
  0x40f760		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f769		483b6110		CMPQ 0x10(CX), SP	
  0x40f76d		0f8621020000		JBE 0x40f994		
  0x40f773		4883ec28		SUBQ $0x28, SP		
  0x40f777		48896c2420		MOVQ BP, 0x20(SP)	
  0x40f77c		488d6c2420		LEAQ 0x20(SP), BP	
	if gcphase != _GCoff {
  0x40f781		8b0555410b00		MOVL runtime.gcphase(SB), AX	
  0x40f787		85c0			TESTL AX, AX			
  0x40f789		0f85ea010000		JNE 0x40f979			
	lock(&finlock)
  0x40f78f		488d05d2410b00		LEAQ runtime.finlock(SB), AX	
  0x40f796		48890424		MOVQ AX, 0(SP)			
  0x40f79a		e8819dffff		CALL runtime.lock(SB)		
	if finq == nil || finq.cnt == uint32(len(finq.fin)) {
  0x40f79f		488b05ba7e0900		MOVQ runtime.finq(SB), AX	
  0x40f7a6		4885c0			TESTQ AX, AX			
  0x40f7a9		740c			JE 0x40f7b7			
  0x40f7ab		8b4810			MOVL 0x10(AX), CX		
  0x40f7ae		83f965			CMPL $0x65, CX			
  0x40f7b1		0f85de000000		JNE 0x40f895			
		if finc == nil {
  0x40f7b7		488b0d927e0900		MOVQ runtime.finc(SB), CX	
  0x40f7be		4885c9			TESTQ CX, CX			
  0x40f7c1		0f85aa000000		JNE 0x40f871			
			finc = (*finblock)(persistentalloc(_FinBlockSize, 0, &memstats.gc_sys))
  0x40f7c7		48c7042400100000	MOVQ $0x1000, 0(SP)			
  0x40f7cf		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x40f7d8		488d05b94f0b00		LEAQ runtime.memstats+152(SB), AX	
  0x40f7df		4889442410		MOVQ AX, 0x10(SP)			
  0x40f7e4		e8b7bcffff		CALL runtime.persistentalloc(SB)	
  0x40f7e9		488b442418		MOVQ 0x18(SP), AX			
  0x40f7ee		4889055b7e0900		MOVQ AX, runtime.finc(SB)		
			finc.alllink = allfin
  0x40f7f5		488b0d147e0900		MOVQ runtime.allfin(SB), CX	
  0x40f7fc		488908			MOVQ CX, 0(AX)			
			allfin = finc
  0x40f7ff		488b054a7e0900		MOVQ runtime.finc(SB), AX	
  0x40f806		488905037e0900		MOVQ AX, runtime.allfin(SB)	
			if finptrmask[0] == 0 {
  0x40f80d		0fb605ec420b00		MOVZX runtime.finptrmask(SB), AX	
  0x40f814		84c0			TESTL AL, AL				
  0x40f816		7559			JNE 0x40f871				
  0x40f818		31c0			XORL AX, AX				
				for i := range finptrmask {
  0x40f81a		eb19			JMP 0x40f835		
					finptrmask[i] = finalizer1[i%len(finalizer1)]
  0x40f81c		488d0ded570900		LEAQ runtime.finalizer1(SB), CX	
  0x40f823		0fb61c19		MOVZX 0(CX)(BX*1), BX		
  0x40f827		488d35d2420b00		LEAQ runtime.finptrmask(SB), SI	
  0x40f82e		881c16			MOVB BL, 0(SI)(DX*1)		
				for i := range finptrmask {
  0x40f831		488d4201		LEAQ 0x1(DX), AX	
  0x40f835		4883f840		CMPQ $0x40, AX		
  0x40f839		7d36			JGE 0x40f871		
  0x40f83b		4889c1			MOVQ AX, CX		
					finptrmask[i] = finalizer1[i%len(finalizer1)]
  0x40f83e		48b8cdcccccccccccccc	MOVQ $0xcccccccccccccccd, AX	
  0x40f848		48f7e9			IMULQ CX			
  0x40f84b		4801ca			ADDQ CX, DX			
  0x40f84e		48c1fa02		SARQ $0x2, DX			
  0x40f852		4889cb			MOVQ CX, BX			
  0x40f855		48c1f93f		SARQ $0x3f, CX			
  0x40f859		4829ca			SUBQ CX, DX			
  0x40f85c		488d0c92		LEAQ 0(DX)(DX*4), CX		
  0x40f860		4889da			MOVQ BX, DX			
  0x40f863		4829cb			SUBQ CX, BX			
  0x40f866		4883fb05		CMPQ $0x5, BX			
  0x40f86a		72b0			JB 0x40f81c			
  0x40f86c		e901010000		JMP 0x40f972			
		block := finc
  0x40f871		488b0dd87d0900		MOVQ runtime.finc(SB), CX	
		finc = block.next
  0x40f878		488b5108		MOVQ 0x8(CX), DX		
  0x40f87c		488915cd7d0900		MOVQ DX, runtime.finc(SB)	
		block.next = finq
  0x40f883		488b15d67d0900		MOVQ runtime.finq(SB), DX	
  0x40f88a		48895108		MOVQ DX, 0x8(CX)		
		finq = block
  0x40f88e		48890dcb7d0900		MOVQ CX, runtime.finq(SB)	
	f := &finq.fin[finq.cnt]
  0x40f895		488b0dc47d0900		MOVQ runtime.finq(SB), CX	
  0x40f89c		8b5110			MOVL 0x10(CX), DX		
  0x40f89f		4883fa65		CMPQ $0x65, DX			
  0x40f8a3		0f83c2000000		JAE 0x40f96b			
	atomic.Xadd(&finq.cnt, +1) // Sync with markroots
  0x40f8a9		bb01000000		MOVL $0x1, BX		
  0x40f8ae		f00fc15910		LOCK XADDL BX, 0x10(CX)	
	f := &finq.fin[finq.cnt]
  0x40f8b3		488d1492		LEAQ 0(DX)(DX*4), DX	
	f.fn = fn
  0x40f8b7		488d7cd118		LEAQ 0x18(CX)(DX*8), DI			
  0x40f8bc		8b1d4e410b00		MOVL runtime.writeBarrier(SB), BX	
  0x40f8c2		85db			TESTL BX, BX				
  0x40f8c4		0f8592000000		JNE 0x40f95c				
  0x40f8ca		488b5c2438		MOVQ 0x38(SP), BX			
  0x40f8cf		48895cd118		MOVQ BX, 0x18(CX)(DX*8)			
  0x40f8d4		488b5c2440		MOVQ 0x40(SP), BX			
	f.nret = nret
  0x40f8d9		48895cd128		MOVQ BX, 0x28(CX)(DX*8)	
	f.fint = fint
  0x40f8de		8b1d2c410b00		MOVL runtime.writeBarrier(SB), BX	
  0x40f8e4		488d7cd130		LEAQ 0x30(CX)(DX*8), DI			
	f.ot = ot
  0x40f8e9		488d74d138		LEAQ 0x38(CX)(DX*8), SI	
	f.arg = p
  0x40f8ee		4c8d44d120		LEAQ 0x20(CX)(DX*8), R8	
	f.fint = fint
  0x40f8f3		85db			TESTL BX, BX		
  0x40f8f5		753f			JNE 0x40f936		
  0x40f8f7		488b442448		MOVQ 0x48(SP), AX	
  0x40f8fc		488944d130		MOVQ AX, 0x30(CX)(DX*8)	
  0x40f901		488b442450		MOVQ 0x50(SP), AX	
	f.ot = ot
  0x40f906		488944d138		MOVQ AX, 0x38(CX)(DX*8)	
  0x40f90b		488b442430		MOVQ 0x30(SP), AX	
	f.arg = p
  0x40f910		488944d120		MOVQ AX, 0x20(CX)(DX*8)	
	fingwake = true
  0x40f915		c6058a3f0b0001		MOVB $0x1, runtime.fingwake(SB)	
	unlock(&finlock)
  0x40f91c		488d0545400b00		LEAQ runtime.finlock(SB), AX	
  0x40f923		48890424		MOVQ AX, 0(SP)			
  0x40f927		e8949dffff		CALL runtime.unlock(SB)		
}
  0x40f92c		488b6c2420		MOVQ 0x20(SP), BP	
  0x40f931		4883c428		ADDQ $0x28, SP		
  0x40f935		c3			RET			
  0x40f936		488b442448		MOVQ 0x48(SP), AX	
	f.fint = fint
  0x40f93b		e8606f0300		CALL runtime.gcWriteBarrier(SB)	
  0x40f940		4889f7			MOVQ SI, DI			
  0x40f943		488b442450		MOVQ 0x50(SP), AX		
	f.ot = ot
  0x40f948		e8536f0300		CALL runtime.gcWriteBarrier(SB)	
  0x40f94d		4c89c7			MOVQ R8, DI			
  0x40f950		488b442430		MOVQ 0x30(SP), AX		
	f.arg = p
  0x40f955		e8466f0300		CALL runtime.gcWriteBarrier(SB)	
	f.fint = fint
  0x40f95a		ebb9			JMP 0x40f915		
  0x40f95c		488b442438		MOVQ 0x38(SP), AX	
	f.fn = fn
  0x40f961		e83a6f0300		CALL runtime.gcWriteBarrier(SB)	
  0x40f966		e969ffffff		JMP 0x40f8d4			
	f := &finq.fin[finq.cnt]
  0x40f96b		e8d0000100		CALL runtime.panicindex(SB)	
  0x40f970		0f0b			UD2				
					finptrmask[i] = finalizer1[i%len(finalizer1)]
  0x40f972		e8c9000100		CALL runtime.panicindex(SB)	
  0x40f977		0f0b			UD2				
		throw("queuefinalizer during GC")
  0x40f979		488d056ebf0500		LEAQ 0x5bf6e(IP), AX	
  0x40f980		48890424		MOVQ AX, 0(SP)		
  0x40f984		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x40f98d		e83e180100		CALL runtime.throw(SB)	
  0x40f992		0f0b			UD2			
func queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype) {
  0x40f994		e8d74b0300		CALL runtime.morestack_noctxt(SB)	
  0x40f999		e9c2fdffff		JMP runtime.queuefinalizer(SB)		

TEXT runtime.wakefing(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mfinal.go
func wakefing() *g {
  0x40f9a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f9a9		483b6110		CMPQ 0x10(CX), SP	
  0x40f9ad		767a			JBE 0x40fa29		
  0x40f9af		4883ec18		SUBQ $0x18, SP		
  0x40f9b3		48896c2410		MOVQ BP, 0x10(SP)	
  0x40f9b8		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&finlock)
  0x40f9bd		488d05a43f0b00		LEAQ runtime.finlock(SB), AX	
  0x40f9c4		48890424		MOVQ AX, 0(SP)			
  0x40f9c8		e8539bffff		CALL runtime.lock(SB)		
	if fingwait && fingwake {
  0x40f9cd		0fb605d13e0b00		MOVZX runtime.fingwait(SB), AX	
  0x40f9d4		84c0			TESTL AL, AL			
  0x40f9d6		744d			JE 0x40fa25			
  0x40f9d8		0fb605c73e0b00		MOVZX runtime.fingwake(SB), AX	
  0x40f9df		84c0			TESTL AL, AL			
  0x40f9e1		743e			JE 0x40fa21			
		fingwait = false
  0x40f9e3		c605bb3e0b0000		MOVB $0x0, runtime.fingwait(SB)	
		fingwake = false
  0x40f9ea		c605b53e0b0000		MOVB $0x0, runtime.fingwake(SB)	
		res = fing
  0x40f9f1		488b05607c0900		MOVQ runtime.fing(SB), AX	
  0x40f9f8		4889442408		MOVQ AX, 0x8(SP)		
	unlock(&finlock)
  0x40f9fd		488d0d643f0b00		LEAQ runtime.finlock(SB), CX	
  0x40fa04		48890c24		MOVQ CX, 0(SP)			
  0x40fa08		e8b39cffff		CALL runtime.unlock(SB)		
	return res
  0x40fa0d		488b442408		MOVQ 0x8(SP), AX	
  0x40fa12		4889442420		MOVQ AX, 0x20(SP)	
  0x40fa17		488b6c2410		MOVQ 0x10(SP), BP	
  0x40fa1c		4883c418		ADDQ $0x18, SP		
  0x40fa20		c3			RET			
  0x40fa21		31c0			XORL AX, AX		
	if fingwait && fingwake {
  0x40fa23		ebd3			JMP 0x40f9f8		
  0x40fa25		31c0			XORL AX, AX		
  0x40fa27		ebcf			JMP 0x40f9f8		
func wakefing() *g {
  0x40fa29		e8424b0300		CALL runtime.morestack_noctxt(SB)	
  0x40fa2e		e96dffffff		JMP runtime.wakefing(SB)		

TEXT runtime.(*fixalloc).alloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mfixalloc.go
func (f *fixalloc) alloc() unsafe.Pointer {
  0x40fa40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40fa49		483b6110		CMPQ 0x10(CX), SP	
  0x40fa4d		0f8650010000		JBE 0x40fba3		
  0x40fa53		4883ec38		SUBQ $0x38, SP		
  0x40fa57		48896c2430		MOVQ BP, 0x30(SP)	
  0x40fa5c		488d6c2430		LEAQ 0x30(SP), BP	
  0x40fa61		488b442440		MOVQ 0x40(SP), AX	
	if f.size == 0 {
  0x40fa66		488b08			MOVQ 0(AX), CX		
  0x40fa69		4885c9			TESTQ CX, CX		
  0x40fa6c		0f84f3000000		JE 0x40fb65		
	if f.list != nil {
  0x40fa72		488b5818		MOVQ 0x18(AX), BX	
  0x40fa76		4885db			TESTQ BX, BX		
  0x40fa79		7446			JE 0x40fac1		
		f.list = f.list.next
  0x40fa7b		488b0b			MOVQ 0(BX), CX		
  0x40fa7e		48894818		MOVQ CX, 0x18(AX)	
		f.inuse += f.size
  0x40fa82		488b08			MOVQ 0(AX), CX		
  0x40fa85		48034830		ADDQ 0x30(AX), CX	
  0x40fa89		48894830		MOVQ CX, 0x30(AX)	
		if f.zero {
  0x40fa8d		0fb64840		MOVZX 0x40(AX), CX	
  0x40fa91		84c9			TESTL CL, CL		
  0x40fa93		750f			JNE 0x40faa4		
		return v
  0x40fa95		48895c2448		MOVQ BX, 0x48(SP)	
  0x40fa9a		488b6c2430		MOVQ 0x30(SP), BP	
  0x40fa9f		4883c438		ADDQ $0x38, SP		
  0x40faa3		c3			RET			
  0x40faa4		48895c2428		MOVQ BX, 0x28(SP)	
			memclrNoHeapPointers(v, f.size)
  0x40faa9		488b00			MOVQ 0(AX), AX				
  0x40faac		4889442408		MOVQ AX, 0x8(SP)			
  0x40fab1		48891c24		MOVQ BX, 0(SP)				
  0x40fab5		e8b6730300		CALL runtime.memclrNoHeapPointers(SB)	
  0x40faba		488b5c2428		MOVQ 0x28(SP), BX			
  0x40fabf		ebd4			JMP 0x40fa95				
	if uintptr(f.nchunk) < f.size {
  0x40fac1		8b5828			MOVL 0x28(AX), BX	
  0x40fac4		4839cb			CMPQ CX, BX		
  0x40fac7		7260			JB 0x40fb29		
	v := unsafe.Pointer(f.chunk)
  0x40fac9		488b4820		MOVQ 0x20(AX), CX	
	if f.first != nil {
  0x40facd		488b5008		MOVQ 0x8(AX), DX	
  0x40fad1		4885d2			TESTQ DX, DX		
  0x40fad4		7530			JNE 0x40fb06		
	f.chunk = f.chunk + f.size
  0x40fad6		488b10			MOVQ 0(AX), DX		
  0x40fad9		48035020		ADDQ 0x20(AX), DX	
  0x40fadd		48895020		MOVQ DX, 0x20(AX)	
	f.nchunk -= uint32(f.size)
  0x40fae1		8b5028			MOVL 0x28(AX), DX	
  0x40fae4		488b18			MOVQ 0(AX), BX		
  0x40fae7		29da			SUBL BX, DX		
  0x40fae9		895028			MOVL DX, 0x28(AX)	
	f.inuse += f.size
  0x40faec		488b10			MOVQ 0(AX), DX		
  0x40faef		48035030		ADDQ 0x30(AX), DX	
  0x40faf3		48895030		MOVQ DX, 0x30(AX)	
	return v
  0x40faf7		48894c2448		MOVQ CX, 0x48(SP)	
  0x40fafc		488b6c2430		MOVQ 0x30(SP), BP	
  0x40fb01		4883c438		ADDQ $0x38, SP		
  0x40fb05		c3			RET			
  0x40fb06		48894c2420		MOVQ CX, 0x20(SP)	
		f.first(f.arg, v)
  0x40fb0b		488b5810		MOVQ 0x10(AX), BX	
  0x40fb0f		48891c24		MOVQ BX, 0(SP)		
  0x40fb13		48894c2408		MOVQ CX, 0x8(SP)	
  0x40fb18		488b1a			MOVQ 0(DX), BX		
  0x40fb1b		ffd3			CALL BX			
  0x40fb1d		488b442440		MOVQ 0x40(SP), AX	
  0x40fb22		488b4c2420		MOVQ 0x20(SP), CX	
  0x40fb27		ebad			JMP 0x40fad6		
		f.chunk = uintptr(persistentalloc(_FixAllocChunk, 0, f.stat))
  0x40fb29		488b4838		MOVQ 0x38(AX), CX			
  0x40fb2d		48894c2410		MOVQ CX, 0x10(SP)			
  0x40fb32		48c7042400400000	MOVQ $0x4000, 0(SP)			
  0x40fb3a		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x40fb43		e858b9ffff		CALL runtime.persistentalloc(SB)	
  0x40fb48		488b442418		MOVQ 0x18(SP), AX			
  0x40fb4d		488b4c2440		MOVQ 0x40(SP), CX			
  0x40fb52		48894120		MOVQ AX, 0x20(CX)			
		f.nchunk = _FixAllocChunk
  0x40fb56		c7412800400000		MOVL $0x4000, 0x28(CX)	
  0x40fb5d		4889c8			MOVQ CX, AX		
  0x40fb60		e964ffffff		JMP 0x40fac9		
		print("runtime: use of FixAlloc_Alloc before FixAlloc_Init\n")
  0x40fb65		e8961f0100		CALL runtime.printlock(SB)	
  0x40fb6a		488d057edf0500		LEAQ 0x5df7e(IP), AX		
  0x40fb71		48890424		MOVQ AX, 0(SP)			
  0x40fb75		48c744240834000000	MOVQ $0x34, 0x8(SP)		
  0x40fb7e		e8bd280100		CALL runtime.printstring(SB)	
  0x40fb83		e8f81f0100		CALL runtime.printunlock(SB)	
		throw("runtime: internal error")
  0x40fb88		488d05babb0500		LEAQ 0x5bbba(IP), AX	
  0x40fb8f		48890424		MOVQ AX, 0(SP)		
  0x40fb93		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x40fb9c		e82f160100		CALL runtime.throw(SB)	
  0x40fba1		0f0b			UD2			
func (f *fixalloc) alloc() unsafe.Pointer {
  0x40fba3		e8c8490300		CALL runtime.morestack_noctxt(SB)	
  0x40fba8		e993feffff		JMP runtime.(*fixalloc).alloc(SB)	

TEXT runtime.gcinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcinit() {
  0x40fbb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40fbb9		483b6110		CMPQ 0x10(CX), SP	
  0x40fbbd		0f86ba000000		JBE 0x40fc7d		
  0x40fbc3		4883ec18		SUBQ $0x18, SP		
  0x40fbc7		48896c2410		MOVQ BP, 0x10(SP)	
  0x40fbcc		488d6c2410		LEAQ 0x10(SP), BP	
	mheap_.sweepdone = 1
  0x40fbd1		c705e9d6090001000000	MOVL $0x1, runtime.mheap_+4132(SB)	
	memstats.triggerRatio = 7 / 8.0
  0x40fbdb		f20f1005dd4e0600	MOVSD_XMM $f64.3fec000000000000(SB), X0	
  0x40fbe3		f20f110545620b00	MOVSD_XMM X0, runtime.memstats+5936(SB)	
	memstats.heap_marked = uint64(float64(heapminimum) / (1 + memstats.triggerRatio))
  0x40fbeb		488b0546540900		MOVQ runtime.heapminimum(SB), AX	
  0x40fbf2		4885c0			TESTQ AX, AX				
  0x40fbf5		7c6b			JL 0x40fc62				
  0x40fbf7		0f57c0			XORPS X0, X0				
  0x40fbfa		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x40fbff		f20f100de14e0600	MOVSD_XMM $f64.3ffe000000000000(SB), X1	
  0x40fc07		f20f5ec1		DIVSD X1, X0				
  0x40fc0b		f20f100d054f0600	MOVSD_XMM $f64.43e0000000000000(SB), X1	
  0x40fc13		660f2ec8		UCOMISD X0, X1				
  0x40fc17		7631			JBE 0x40fc4a				
  0x40fc19		f2480f2cc0		CVTTSD2SIQ X0, AX			
  0x40fc1e		4889052b620b00		MOVQ AX, runtime.memstats+5968(SB)	
	_ = setGCPercent(readgogc())
  0x40fc25		e866000000		CALL runtime.readgogc(SB)		
  0x40fc2a		e8b1010000		CALL runtime/debug.setGCPercent(SB)	
	work.markDoneSema = 1
  0x40fc2f		48b80100000001000000	MOVQ $0x100000001, AX		
  0x40fc39		48890544820900		MOVQ AX, runtime.work+228(SB)	
}
  0x40fc40		488b6c2410		MOVQ 0x10(SP), BP	
  0x40fc45		4883c418		ADDQ $0x18, SP		
  0x40fc49		c3			RET			
	memstats.heap_marked = uint64(float64(heapminimum) / (1 + memstats.triggerRatio))
  0x40fc4a		f20f5cc1		SUBSD X1, X0			
  0x40fc4e		f2480f2cc0		CVTTSD2SIQ X0, AX		
  0x40fc53		48b90000000000000080	MOVQ $0x8000000000000000, CX	
  0x40fc5d		4809c8			ORQ CX, AX			
  0x40fc60		ebbc			JMP 0x40fc1e			
  0x40fc62		4889c1			MOVQ AX, CX			
  0x40fc65		4883e001		ANDQ $0x1, AX			
  0x40fc69		48d1e9			SHRQ $0x1, CX			
  0x40fc6c		4809c1			ORQ AX, CX			
  0x40fc6f		0f57c0			XORPS X0, X0			
  0x40fc72		f2480f2ac1		CVTSI2SDQ CX, X0		
  0x40fc77		f20f58c0		ADDSD X0, X0			
  0x40fc7b		eb82			JMP 0x40fbff			
func gcinit() {
  0x40fc7d		e8ee480300		CALL runtime.morestack_noctxt(SB)	
  0x40fc82		e929ffffff		JMP runtime.gcinit(SB)			

TEXT runtime.readgogc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func readgogc() int32 {
  0x40fc90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40fc99		483b6110		CMPQ 0x10(CX), SP	
  0x40fc9d		0f8697000000		JBE 0x40fd3a		
  0x40fca3		4883ec28		SUBQ $0x28, SP		
  0x40fca7		48896c2420		MOVQ BP, 0x20(SP)	
  0x40fcac		488d6c2420		LEAQ 0x20(SP), BP	
	p := gogetenv("GOGC")
  0x40fcb1		488d053ea00500		LEAQ 0x5a03e(IP), AX		
  0x40fcb8		48890424		MOVQ AX, 0(SP)			
  0x40fcbc		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x40fcc5		e8a64dffff		CALL runtime.gogetenv(SB)	
  0x40fcca		488b442418		MOVQ 0x18(SP), AX		
  0x40fccf		488b4c2410		MOVQ 0x10(SP), CX		
	if p == "off" {
  0x40fcd4		4883f803		CMPQ $0x3, AX		
  0x40fcd8		7513			JNE 0x40fced		
  0x40fcda		0fb711			MOVZX 0(CX), DX		
  0x40fcdd		6681fa6f66		CMPW $0x666f, DX	
  0x40fce2		7509			JNE 0x40fced		
  0x40fce4		0fb65102		MOVZX 0x2(CX), DX	
  0x40fce8		80fa66			CMPL $0x66, DL		
  0x40fceb		743b			JE 0x40fd28		
	if n, ok := atoi32(p); ok {
  0x40fced		48890c24		MOVQ CX, 0(SP)		
  0x40fcf1		4889442408		MOVQ AX, 0x8(SP)	
  0x40fcf6		e835790200		CALL runtime.atoi32(SB)	
  0x40fcfb		8b442410		MOVL 0x10(SP), AX	
  0x40fcff		0fb64c2414		MOVZX 0x14(SP), CX	
  0x40fd04		84c9			TESTL CL, CL		
  0x40fd06		740e			JE 0x40fd16		
		return n
  0x40fd08		89442430		MOVL AX, 0x30(SP)	
  0x40fd0c		488b6c2420		MOVQ 0x20(SP), BP	
  0x40fd11		4883c428		ADDQ $0x28, SP		
  0x40fd15		c3			RET			
	return 100
  0x40fd16		c744243064000000	MOVL $0x64, 0x30(SP)	
  0x40fd1e		488b6c2420		MOVQ 0x20(SP), BP	
  0x40fd23		4883c428		ADDQ $0x28, SP		
  0x40fd27		c3			RET			
		return -1
  0x40fd28		c7442430ffffffff	MOVL $-0x1, 0x30(SP)	
  0x40fd30		488b6c2420		MOVQ 0x20(SP), BP	
  0x40fd35		4883c428		ADDQ $0x28, SP		
  0x40fd39		c3			RET			
func readgogc() int32 {
  0x40fd3a		e831480300		CALL runtime.morestack_noctxt(SB)	
  0x40fd3f		e94cffffff		JMP runtime.readgogc(SB)		

TEXT runtime.gcenable(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcenable() {
  0x40fd50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40fd59		483b6110		CMPQ 0x10(CX), SP	
  0x40fd5d		7671			JBE 0x40fdd0		
  0x40fd5f		4883ec28		SUBQ $0x28, SP		
  0x40fd63		48896c2420		MOVQ BP, 0x20(SP)	
  0x40fd68		488d6c2420		LEAQ 0x20(SP), BP	
	c := make(chan int, 1)
  0x40fd6d		488d05ec6d0400		LEAQ 0x46dec(IP), AX		
  0x40fd74		48890424		MOVQ AX, 0(SP)			
  0x40fd78		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x40fd81		e84a30ffff		CALL runtime.makechan(SB)	
  0x40fd86		488b442410		MOVQ 0x10(SP), AX		
  0x40fd8b		4889442418		MOVQ AX, 0x18(SP)		
	go bgsweep(c)
  0x40fd90		c7042408000000		MOVL $0x8, 0(SP)		
  0x40fd97		488d0d12e20500		LEAQ 0x5e212(IP), CX		
  0x40fd9e		48894c2408		MOVQ CX, 0x8(SP)		
  0x40fda3		e848a50100		CALL runtime.newproc(SB)	
  0x40fda8		488b442418		MOVQ 0x18(SP), AX		
	<-c
  0x40fdad		48890424		MOVQ AX, 0(SP)			
  0x40fdb1		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x40fdba		e8013effff		CALL runtime.chanrecv1(SB)	
	memstats.enablegc = true // now that runtime is initialized, GC is okay
  0x40fdbf		c6050a5a0b0001		MOVB $0x1, runtime.memstats+4304(SB)	
}
  0x40fdc6		488b6c2420		MOVQ 0x20(SP), BP	
  0x40fdcb		4883c428		ADDQ $0x28, SP		
  0x40fdcf		c3			RET			
func gcenable() {
  0x40fdd0		e89b470300		CALL runtime.morestack_noctxt(SB)	
  0x40fdd5		e976ffffff		JMP runtime.gcenable(SB)		

TEXT runtime/debug.setGCPercent(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func setGCPercent(in int32) (out int32) {
  0x40fde0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40fde9		483b6110		CMPQ 0x10(CX), SP	
  0x40fded		0f862c010000		JBE 0x40ff1f		
  0x40fdf3		4883ec38		SUBQ $0x38, SP		
  0x40fdf7		48896c2430		MOVQ BP, 0x30(SP)	
  0x40fdfc		488d6c2430		LEAQ 0x30(SP), BP	
	lock(&mheap_.lock)
  0x40fe01		488d0598c40900		LEAQ runtime.mheap_(SB), AX	
  0x40fe08		48890424		MOVQ AX, 0(SP)			
  0x40fe0c		e80f97ffff		CALL runtime.lock(SB)		
	out = gcpercent
  0x40fe11		8b05c13a0b00		MOVL runtime.gcpercent(SB), AX	
  0x40fe17		8944242c		MOVL AX, 0x2c(SP)		
  0x40fe1b		8b4c2440		MOVL 0x40(SP), CX		
	if in < 0 {
  0x40fe1f		85c9			TESTL CX, CX		
  0x40fe21		7d05			JGE 0x40fe28		
  0x40fe23		b9ffffffff		MOVL $-0x1, CX		
	gcpercent = in
  0x40fe28		894c2440		MOVL CX, 0x40(SP)		
  0x40fe2c		890da63a0b00		MOVL CX, runtime.gcpercent(SB)	
	heapminimum = defaultHeapMinimum * uint64(gcpercent) / 100
  0x40fe32		4863d1			MOVSXD CX, DX				
  0x40fe35		48c1e216		SHLQ $0x16, DX				
  0x40fe39		48d1ea			SHRQ $0x1, DX				
  0x40fe3c		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX		
  0x40fe46		48f7e2			MULQ DX					
  0x40fe49		48c1ea05		SHRQ $0x5, DX				
  0x40fe4d		488915e4510900		MOVQ DX, runtime.heapminimum(SB)	
	gcSetTriggerRatio(memstats.triggerRatio)
  0x40fe54		f20f1005d45f0b00	MOVSD_XMM runtime.memstats+5936(SB), X0	
  0x40fe5c		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x40fe61		e8ea0e0000		CALL runtime.gcSetTriggerRatio(SB)	
	unlock(&mheap_.lock)
  0x40fe66		488d0d33c40900		LEAQ runtime.mheap_(SB), CX	
  0x40fe6d		48890c24		MOVQ CX, 0(SP)			
  0x40fe71		e84a98ffff		CALL runtime.unlock(SB)		
  0x40fe76		8b4c2440		MOVL 0x40(SP), CX		
	if in < 0 {
  0x40fe7a		85c9			TESTL CX, CX		
  0x40fe7c		7c12			JL 0x40fe90		
	return out
  0x40fe7e		8b44242c		MOVL 0x2c(SP), AX	
  0x40fe82		89442448		MOVL AX, 0x48(SP)	
  0x40fe86		488b6c2430		MOVQ 0x30(SP), BP	
  0x40fe8b		4883c438		ADDQ $0x38, SP		
  0x40fe8f		c3			RET			
		lock(&work.sweepWaiters.lock)
  0x40fe90		488d0541800900		LEAQ runtime.work+312(SB), AX	
  0x40fe97		48890424		MOVQ AX, 0(SP)			
  0x40fe9b		e88096ffff		CALL runtime.lock(SB)		
		if gcphase == _GCmark {
  0x40fea0		8b05363a0b00		MOVL runtime.gcphase(SB), AX	
  0x40fea6		83f801			CMPL $0x1, AX			
  0x40fea9		755f			JNE 0x40ff0a			
			gp := getg()
  0x40feab		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
			gp.schedlink = work.sweepWaiters.head
  0x40feb4		488b0d25800900		MOVQ runtime.work+320(SB), CX	
  0x40febb		488988b8000000		MOVQ CX, 0xb8(AX)		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x40fec2		488d0d17800900		LEAQ runtime.work+320(SB), CX	
  0x40fec9		8401			TESTB AL, 0(CX)			
  0x40fecb		4889050e800900		MOVQ AX, runtime.work+320(SB)	
			goparkunlock(&work.sweepWaiters.lock, "wait for GC cycle", traceEvGoBlock, 1)
  0x40fed2		488d05ff7f0900		LEAQ runtime.work+312(SB), AX	
  0x40fed9		48890424		MOVQ AX, 0(SP)			
  0x40fedd		488d0556ae0500		LEAQ 0x5ae56(IP), AX		
  0x40fee4		4889442408		MOVQ AX, 0x8(SP)		
  0x40fee9		48c744241011000000	MOVQ $0x11, 0x10(SP)		
  0x40fef2		c644241814		MOVB $0x14, 0x18(SP)		
  0x40fef7		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x40ff00		e85b300100		CALL runtime.goparkunlock(SB)	
  0x40ff05		e974ffffff		JMP 0x40fe7e			
			unlock(&work.sweepWaiters.lock)
  0x40ff0a		488d05c77f0900		LEAQ runtime.work+312(SB), AX	
  0x40ff11		48890424		MOVQ AX, 0(SP)			
  0x40ff15		e8a697ffff		CALL runtime.unlock(SB)		
  0x40ff1a		e95fffffff		JMP 0x40fe7e			
func setGCPercent(in int32) (out int32) {
  0x40ff1f		e84c460300		CALL runtime.morestack_noctxt(SB)	
  0x40ff24		e9b7feffff		JMP runtime/debug.setGCPercent(SB)	

TEXT runtime.(*gcControllerState).startCycle(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func (c *gcControllerState) startCycle() {
  0x40ff30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ff39		483b6110		CMPQ 0x10(CX), SP	
  0x40ff3d		0f866d030000		JBE 0x4102b0		
  0x40ff43		4883ec48		SUBQ $0x48, SP		
  0x40ff47		48896c2440		MOVQ BP, 0x40(SP)	
  0x40ff4c		488d6c2440		LEAQ 0x40(SP), BP	
	c.bgScanCredit = 0
  0x40ff51		0f57c0			XORPS X0, X0		
  0x40ff54		488b4c2450		MOVQ 0x50(SP), CX	
  0x40ff59		0f1101			MOVUPS X0, 0(CX)	
	c.dedicatedMarkTime = 0
  0x40ff5c		0f114110		MOVUPS X0, 0x10(CX)	
	c.idleMarkTime = 0
  0x40ff60		0f114120		MOVUPS X0, 0x20(CX)	
	if memstats.gc_trigger <= heapminimum {
  0x40ff64		488b15cd5e0b00		MOVQ runtime.memstats+5944(SB), DX	
  0x40ff6b		488b1dc6500900		MOVQ runtime.heapminimum(SB), BX	
  0x40ff72		4839da			CMPQ BX, DX				
  0x40ff75		0f8728030000		JA 0x4102a3				
		memstats.heap_marked = uint64(float64(memstats.gc_trigger) / (1 + memstats.triggerRatio))
  0x40ff7b		4885d2			TESTQ DX, DX				
  0x40ff7e		0f8c01030000		JL 0x410285				
  0x40ff84		0f57c9			XORPS X1, X1				
  0x40ff87		f2480f2aca		CVTSI2SDQ DX, X1			
  0x40ff8c		f20f10159c5e0b00	MOVSD_XMM runtime.memstats+5936(SB), X2	
  0x40ff94		f20f101d344b0600	MOVSD_XMM $f64.3ff0000000000000(SB), X3	
  0x40ff9c		f20f58d3		ADDSD X3, X2				
  0x40ffa0		f20f5eca		DIVSD X2, X1				
  0x40ffa4		f20f10156c4b0600	MOVSD_XMM $f64.43e0000000000000(SB), X2	
  0x40ffac		660f2ed1		UCOMISD X1, X2				
  0x40ffb0		0f86b4020000		JBE 0x41026a				
  0x40ffb6		f2480f2cd1		CVTTSD2SIQ X1, DX			
  0x40ffbb		4889158e5e0b00		MOVQ DX, runtime.memstats+5968(SB)	
	memstats.next_gc = memstats.heap_marked + memstats.heap_marked*uint64(gcpercent)/100
  0x40ffc2		488b15875e0b00		MOVQ runtime.memstats+5968(SB), DX	
  0x40ffc9		48631d08390b00		MOVSXD runtime.gcpercent(SB), BX	
  0x40ffd0		480fafda		IMULQ DX, BX				
  0x40ffd4		48d1eb			SHRQ $0x1, BX				
  0x40ffd7		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX		
  0x40ffe1		4889d6			MOVQ DX, SI				
  0x40ffe4		48f7e3			MULQ BX					
  0x40ffe7		48c1ea05		SHRQ $0x5, DX				
  0x40ffeb		4801f2			ADDQ SI, DX				
  0x40ffee		488915b3470b00		MOVQ DX, runtime.memstats+168(SB)	
	if gcpercent < 0 {
  0x40fff5		8b15dd380b00		MOVL runtime.gcpercent(SB), DX	
  0x40fffb		85d2			TESTL DX, DX			
  0x40fffd		7d0b			JGE 0x41000a			
		memstats.next_gc = ^uint64(0)
  0x40ffff		48c7059e470b00ffffffff	MOVQ $-0x1, runtime.memstats+168(SB)	
	if memstats.next_gc < memstats.heap_live+1024*1024 {
  0x41000a		488b0597470b00		MOVQ runtime.memstats+168(SB), AX	
  0x410011		488b15285e0b00		MOVQ runtime.memstats+5952(SB), DX	
  0x410018		4881c200001000		ADDQ $0x100000, DX			
  0x41001f		4839d0			CMPQ DX, AX				
  0x410022		7307			JAE 0x41002b				
		memstats.next_gc = memstats.heap_live + 1024*1024
  0x410024		4889157d470b00		MOVQ DX, runtime.memstats+168(SB)	
	totalUtilizationGoal := float64(gomaxprocs) * gcBackgroundUtilization
  0x41002b		8b05af380b00		MOVL runtime.gomaxprocs(SB), AX		
  0x410031		0f57c9			XORPS X1, X1				
  0x410034		f20f2ac8		CVTSI2SDL AX, X1			
  0x410038		f20f1015684a0600	MOVSD_XMM $f64.3fd0000000000000(SB), X2	
  0x410040		f20f59ca		MULSD X2, X1				
	c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal + 0.5)
  0x410044		f20f10156c4a0600	MOVSD_XMM $f64.3fe0000000000000(SB), X2	
  0x41004c		f20f58d1		ADDSD X1, X2				
  0x410050		f2480f2cc2		CVTTSD2SIQ X2, AX			
  0x410055		48894138		MOVQ AX, 0x38(CX)			
	utilError := float64(c.dedicatedMarkWorkersNeeded)/totalUtilizationGoal - 1
  0x410059		0f57d2			XORPS X2, X2		
  0x41005c		f2480f2ad0		CVTSI2SDQ AX, X2	
  0x410061		0f10e2			MOVUPS X2, X4		
  0x410064		f20f5ed1		DIVSD X1, X2		
  0x410068		f20f5cd3		SUBSD X3, X2		
	if utilError < -maxUtilError || utilError > maxUtilError {
  0x41006c		f20f101db44a0600	MOVSD_XMM $f64.bfd3333333333333(SB), X3	
  0x410074		660f2eda		UCOMISD X2, X3				
  0x410078		0f86cd010000		JBE 0x41024b				
		if float64(c.dedicatedMarkWorkersNeeded) > totalUtilizationGoal {
  0x41007e		660f2ee1		UCOMISD X1, X4		
  0x410082		7607			JBE 0x41008b		
			c.dedicatedMarkWorkersNeeded--
  0x410084		48ffc8			DECQ AX			
  0x410087		48894138		MOVQ AX, 0x38(CX)	
		c.fractionalUtilizationGoal = (totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded)) / float64(gomaxprocs)
  0x41008b		488b4138		MOVQ 0x38(CX), AX		
  0x41008f		0f57d2			XORPS X2, X2			
  0x410092		f2480f2ad0		CVTSI2SDQ AX, X2		
  0x410097		f20f5cca		SUBSD X2, X1			
  0x41009b		8b053f380b00		MOVL runtime.gomaxprocs(SB), AX	
  0x4100a1		0f57d2			XORPS X2, X2			
  0x4100a4		f20f2ad0		CVTSI2SDL AX, X2		
  0x4100a8		f20f5eca		DIVSD X2, X1			
  0x4100ac		f20f114950		MOVSD_XMM X1, 0x50(CX)		
	for _, p := range allp {
  0x4100b1		488b05f8750900		MOVQ runtime.allp(SB), AX	
  0x4100b8		488b15f9750900		MOVQ runtime.allp+8(SB), DX	
  0x4100bf		31db			XORL BX, BX			
  0x4100c1		eb10			JMP 0x4100d3			
  0x4100c3		488b34d8		MOVQ 0(AX)(BX*8), SI		
		p.gcAssistTime = 0
  0x4100c7		8406			TESTB AL, 0(SI)		
		p.gcFractionalMarkTime = 0
  0x4100c9		0f118648120000		MOVUPS X0, 0x1248(SI)	
	for _, p := range allp {
  0x4100d0		48ffc3			INCQ BX			
  0x4100d3		4839d3			CMPQ DX, BX		
  0x4100d6		7ceb			JL 0x4100c3		
	c.revise()
  0x4100d8		48890c24		MOVQ CX, 0(SP)					
  0x4100dc		e8df010000		CALL runtime.(*gcControllerState).revise(SB)	
	if debug.gcpacertrace > 0 {
  0x4100e1		8b05e9390b00		MOVL runtime.debug+16(SB), AX	
  0x4100e7		85c0			TESTL AX, AX			
  0x4100e9		7f0a			JG 0x4100f5			
  0x4100eb		488b6c2440		MOVQ 0x40(SP), BP		
  0x4100f0		4883c448		ADDQ $0x48, SP			
  0x4100f4		c3			RET				
  0x4100f5		488b442450		MOVQ 0x50(SP), AX		
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x4100fa		f20f104040		MOVSD_XMM 0x40(AX), X0	
  0x4100ff		f20f11442438		MOVSD_XMM X0, 0x38(SP)	
			" (scan ", memstats.heap_scan>>20, " MB in ",
  0x410105		488b0d3c5d0b00		MOVQ runtime.memstats+5960(SB), CX	
  0x41010c		48894c2430		MOVQ CX, 0x30(SP)			
			work.initialHeapLive>>20, "->",
  0x410111		488b15a07d0900		MOVQ runtime.work+280(SB), DX	
  0x410118		4889542428		MOVQ DX, 0x28(SP)		
			memstats.next_gc>>20, " MB)",
  0x41011d		488b1d84460b00		MOVQ runtime.memstats+168(SB), BX	
  0x410124		48895c2420		MOVQ BX, 0x20(SP)			
			" workers=", c.dedicatedMarkWorkersNeeded,
  0x410129		488b7038		MOVQ 0x38(AX), SI	
  0x41012d		4889742418		MOVQ SI, 0x18(SP)	
			"+", c.fractionalUtilizationGoal, "\n")
  0x410132		f20f104850		MOVSD_XMM 0x50(AX), X1	
  0x410137		f20f114c2410		MOVSD_XMM X1, 0x10(SP)	
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x41013d		e8be190100		CALL runtime.printlock(SB)	
  0x410142		488d0538b00500		LEAQ 0x5b038(IP), AX		
  0x410149		48890424		MOVQ AX, 0(SP)			
  0x41014d		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x410156		e8e5220100		CALL runtime.printstring(SB)	
  0x41015b		f20f10442438		MOVSD_XMM 0x38(SP), X0		
  0x410161		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x410166		e8e51c0100		CALL runtime.printfloat(SB)	
  0x41016b		488d05e19c0500		LEAQ 0x59ce1(IP), AX		
  0x410172		48890424		MOVQ AX, 0(SP)			
  0x410176		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x41017f		e8bc220100		CALL runtime.printstring(SB)	
  0x410184		488b442430		MOVQ 0x30(SP), AX		
			" (scan ", memstats.heap_scan>>20, " MB in ",
  0x410189		48c1e814		SHRQ $0x14, AX		
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x41018d		48890424		MOVQ AX, 0(SP)			
  0x410191		e8da1f0100		CALL runtime.printuint(SB)	
  0x410196		488d05c49c0500		LEAQ 0x59cc4(IP), AX		
  0x41019d		48890424		MOVQ AX, 0(SP)			
  0x4101a1		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4101aa		e891220100		CALL runtime.printstring(SB)	
  0x4101af		488b442428		MOVQ 0x28(SP), AX		
			work.initialHeapLive>>20, "->",
  0x4101b4		48c1e814		SHRQ $0x14, AX		
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x4101b8		48890424		MOVQ AX, 0(SP)			
  0x4101bc		e8af1f0100		CALL runtime.printuint(SB)	
  0x4101c1		488d05a69a0500		LEAQ 0x59aa6(IP), AX		
  0x4101c8		48890424		MOVQ AX, 0(SP)			
  0x4101cc		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4101d5		e866220100		CALL runtime.printstring(SB)	
  0x4101da		488b442420		MOVQ 0x20(SP), AX		
			memstats.next_gc>>20, " MB)",
  0x4101df		48c1e814		SHRQ $0x14, AX		
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x4101e3		48890424		MOVQ AX, 0(SP)			
  0x4101e7		e8841f0100		CALL runtime.printuint(SB)	
  0x4101ec		488d0564a40500		LEAQ 0x5a464(IP), AX		
  0x4101f3		48890424		MOVQ AX, 0(SP)			
  0x4101f7		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x410200		e83b220100		CALL runtime.printstring(SB)	
  0x410205		488b442418		MOVQ 0x18(SP), AX		
  0x41020a		48890424		MOVQ AX, 0(SP)			
  0x41020e		e86d200100		CALL runtime.printint(SB)	
  0x410213		488d05399a0500		LEAQ 0x59a39(IP), AX		
  0x41021a		48890424		MOVQ AX, 0(SP)			
  0x41021e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x410227		e814220100		CALL runtime.printstring(SB)	
  0x41022c		f20f10442410		MOVSD_XMM 0x10(SP), X0		
  0x410232		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x410237		e8141c0100		CALL runtime.printfloat(SB)	
  0x41023c		e84f1b0100		CALL runtime.printnl(SB)	
  0x410241		e83a190100		CALL runtime.printunlock(SB)	
  0x410246		e9a0feffff		JMP 0x4100eb			
	if utilError < -maxUtilError || utilError > maxUtilError {
  0x41024b		f20f101d5d480600	MOVSD_XMM $f64.3fd3333333333333(SB), X3	
  0x410253		660f2ed3		UCOMISD X3, X2				
  0x410257		0f8721feffff		JA 0x41007e				
		c.fractionalUtilizationGoal = 0
  0x41025d		0f57c9			XORPS X1, X1		
  0x410260		f20f114950		MOVSD_XMM X1, 0x50(CX)	
  0x410265		e947feffff		JMP 0x4100b1		
		memstats.heap_marked = uint64(float64(memstats.gc_trigger) / (1 + memstats.triggerRatio))
  0x41026a		f20f5cca		SUBSD X2, X1				
  0x41026e		f2480f2cd1		CVTTSD2SIQ X1, DX			
  0x410273		48bb0000000000000080	MOVQ $0x8000000000000000, BX		
  0x41027d		4809da			ORQ BX, DX				
  0x410280		e936fdffff		JMP 0x40ffbb				
  0x410285		4889d3			MOVQ DX, BX				
  0x410288		4883e201		ANDQ $0x1, DX				
  0x41028c		48d1eb			SHRQ $0x1, BX				
  0x41028f		4809da			ORQ BX, DX				
  0x410292		0f57c9			XORPS X1, X1				
  0x410295		f2480f2aca		CVTSI2SDQ DX, X1			
  0x41029a		f20f58c9		ADDSD X1, X1				
  0x41029e		e9e9fcffff		JMP 0x40ff8c				
  0x4102a3		f20f101d25480600	MOVSD_XMM $f64.3ff0000000000000(SB), X3	
	if memstats.gc_trigger <= heapminimum {
  0x4102ab		e912fdffff		JMP 0x40ffc2		
func (c *gcControllerState) startCycle() {
  0x4102b0		e8bb420300		CALL runtime.morestack_noctxt(SB)		
  0x4102b5		e976fcffff		JMP runtime.(*gcControllerState).startCycle(SB)	

TEXT runtime.(*gcControllerState).revise(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
	gcpercent := gcpercent
  0x4102c0		8b0512360b00		MOVL runtime.gcpercent(SB), AX	
	if gcpercent < 0 {
  0x4102c6		85c0			TESTL AX, AX		
  0x4102c8		7d05			JGE 0x4102cf		
  0x4102ca		b8a0860100		MOVL $0x186a0, AX	
	live := atomic.Load64(&memstats.heap_live)
  0x4102cf		488b0d6a5b0b00		MOVQ runtime.memstats+5952(SB), CX	
	if live <= memstats.next_gc {
  0x4102d6		488b15cb440b00		MOVQ runtime.memstats+168(SB), DX	
  0x4102dd		4839d1			CMPQ DX, CX				
  0x4102e0		0f879e000000		JA 0x410384				
		scanWorkExpected = int64(float64(memstats.heap_scan) * 100 / float64(100+gcpercent))
  0x4102e6		488b1d5b5b0b00		MOVQ runtime.memstats+5960(SB), BX	
  0x4102ed		4885db			TESTQ BX, BX				
  0x4102f0		7c74			JL 0x410366				
  0x4102f2		0f57c0			XORPS X0, X0				
  0x4102f5		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x4102fa		f20f100d06480600	MOVSD_XMM $f64.4059000000000000(SB), X1	
  0x410302		f20f59c8		MULSD X0, X1				
  0x410306		83c064			ADDL $0x64, AX				
  0x410309		0f57c0			XORPS X0, X0				
  0x41030c		f20f2ac0		CVTSI2SDL AX, X0			
  0x410310		f20f5ec8		DIVSD X0, X1				
  0x410314		f2480f2cc1		CVTTSD2SIQ X1, AX			
  0x410319		488b5c2408		MOVQ 0x8(SP), BX			
	scanWorkRemaining := scanWorkExpected - c.scanWork
  0x41031e		482b03			SUBQ 0(BX), AX		
	if scanWorkRemaining < 1000 {
  0x410321		483de8030000		CMPQ $0x3e8, AX		
  0x410327		7d05			JGE 0x41032e		
  0x410329		b8e8030000		MOVL $0x3e8, AX		
	heapRemaining := heapGoal - int64(live)
  0x41032e		4829ca			SUBQ CX, DX		
	if heapRemaining <= 0 {
  0x410331		4885d2			TESTQ DX, DX		
  0x410334		7f2b			JG 0x410361		
  0x410336		b901000000		MOVL $0x1, CX		
	c.assistBytesPerWork = float64(heapRemaining) / float64(scanWorkRemaining)
  0x41033b		0f57c0			XORPS X0, X0		
  0x41033e		f2480f2ac1		CVTSI2SDQ CX, X0	
  0x410343		0f57c9			XORPS X1, X1		
  0x410346		f2480f2ac8		CVTSI2SDQ AX, X1	
  0x41034b		0f10d1			MOVUPS X1, X2		
	c.assistWorkPerByte = float64(scanWorkRemaining) / float64(heapRemaining)
  0x41034e		f20f5ec8		DIVSD X0, X1		
  0x410352		f20f114b40		MOVSD_XMM X1, 0x40(BX)	
	c.assistBytesPerWork = float64(heapRemaining) / float64(scanWorkRemaining)
  0x410357		f20f5ec2		DIVSD X2, X0		
  0x41035b		f20f114348		MOVSD_XMM X0, 0x48(BX)	
}
  0x410360		c3			RET			
  0x410361		4889d1			MOVQ DX, CX		
	if heapRemaining <= 0 {
  0x410364		ebd5			JMP 0x41033b		
  0x410366		4889de			MOVQ BX, SI		
		scanWorkExpected = int64(float64(memstats.heap_scan) * 100 / float64(100+gcpercent))
  0x410369		48d1eb			SHRQ $0x1, BX		
  0x41036c		4883e601		ANDQ $0x1, SI		
  0x410370		4809de			ORQ BX, SI		
  0x410373		0f57c0			XORPS X0, X0		
  0x410376		f2480f2ac6		CVTSI2SDQ SI, X0	
  0x41037b		f20f58c0		ADDSD X0, X0		
  0x41037f		e976ffffff		JMP 0x4102fa		
		heapGoal = int64(float64(memstats.next_gc) * maxOvershoot)
  0x410384		4885d2			TESTQ DX, DX				
  0x410387		7c25			JL 0x4103ae				
  0x410389		0f57c0			XORPS X0, X0				
  0x41038c		f2480f2ac2		CVTSI2SDQ DX, X0			
  0x410391		f20f100d3f470600	MOVSD_XMM $f64.3ff199999999999a(SB), X1	
  0x410399		f20f59c8		MULSD X0, X1				
  0x41039d		f2480f2cd1		CVTTSD2SIQ X1, DX			
		scanWorkExpected = int64(memstats.heap_scan)
  0x4103a2		488b059f5a0b00		MOVQ runtime.memstats+5960(SB), AX	
  0x4103a9		e96bffffff		JMP 0x410319				
  0x4103ae		4889d0			MOVQ DX, AX				
		heapGoal = int64(float64(memstats.next_gc) * maxOvershoot)
  0x4103b1		4883e201		ANDQ $0x1, DX		
  0x4103b5		48d1e8			SHRQ $0x1, AX		
  0x4103b8		4809c2			ORQ AX, DX		
  0x4103bb		0f57c0			XORPS X0, X0		
  0x4103be		f2480f2ac2		CVTSI2SDQ DX, X0	
  0x4103c3		f20f58c0		ADDSD X0, X0		
  0x4103c7		ebc8			JMP 0x410391		

TEXT runtime.(*gcControllerState).endCycle(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func (c *gcControllerState) endCycle() float64 {
  0x4103d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4103d9		483b6110		CMPQ 0x10(CX), SP	
  0x4103dd		0f8684040000		JBE 0x410867		
  0x4103e3		4881ec80000000		SUBQ $0x80, SP		
  0x4103ea		48896c2478		MOVQ BP, 0x78(SP)	
  0x4103ef		488d6c2478		LEAQ 0x78(SP), BP	
	if work.userForced {
  0x4103f4		0fb605ad7a0900		MOVZX runtime.work+264(SB), AX	
  0x4103fb		84c0			TESTL AL, AL			
  0x4103fd		0f8546040000		JNE 0x410849			
	goalGrowthRatio := float64(gcpercent) / 100
  0x410403		8b05cf340b00		MOVL runtime.gcpercent(SB), AX		
  0x410409		0f57c0			XORPS X0, X0				
  0x41040c		f20f2ac0		CVTSI2SDL AX, X0			
  0x410410		f20f100df0460600	MOVSD_XMM $f64.4059000000000000(SB), X1	
  0x410418		f20f5ec1		DIVSD X1, X0				
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x41041c		488b051d5a0b00		MOVQ runtime.memstats+5952(SB), AX	
  0x410423		4885c0			TESTQ AX, AX				
  0x410426		0f8cff030000		JL 0x41082b				
  0x41042c		0f57c9			XORPS X1, X1				
  0x41042f		f2480f2ac8		CVTSI2SDQ AX, X1			
  0x410434		f20f11442418		MOVSD_XMM X0, 0x18(SP)			
  0x41043a		f20f114c2470		MOVSD_XMM X1, 0x70(SP)			
  0x410440		488b05095a0b00		MOVQ runtime.memstats+5968(SB), AX	
  0x410447		4885c0			TESTQ AX, AX				
  0x41044a		0f8cbd030000		JL 0x41080d				
  0x410450		0f57d2			XORPS X2, X2				
  0x410453		f2480f2ad0		CVTSI2SDQ AX, X2			
  0x410458		f20f11542468		MOVSD_XMM X2, 0x68(SP)			
	assistDuration := nanotime() - c.markStartTime
  0x41045e		e8cd750300		CALL runtime.nanotime(SB)	
  0x410463		f20f10442470		MOVSD_XMM 0x70(SP), X0		
  0x410469		f20f104c2468		MOVSD_XMM 0x68(SP), X1		
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x41046f		f20f5ec1		DIVSD X1, X0				
  0x410473		f20f100d55460600	MOVSD_XMM $f64.3ff0000000000000(SB), X1	
  0x41047b		f20f5cc1		SUBSD X1, X0				
	assistDuration := nanotime() - c.markStartTime
  0x41047f		488b0424		MOVQ 0(SP), AX		
  0x410483		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x41048b		482b4130		SUBQ 0x30(CX), AX	
	if assistDuration > 0 {
  0x41048f		4885c0			TESTQ AX, AX		
  0x410492		0f8e68030000		JLE 0x410800		
		utilization += float64(c.assistTime) / float64(assistDuration*int64(gomaxprocs))
  0x410498		488b5110		MOVQ 0x10(CX), DX			
  0x41049c		0f57d2			XORPS X2, X2				
  0x41049f		f2480f2ad2		CVTSI2SDQ DX, X2			
  0x4104a4		48631535340b00		MOVSXD runtime.gomaxprocs(SB), DX	
  0x4104ab		480fafc2		IMULQ DX, AX				
  0x4104af		0f57db			XORPS X3, X3				
  0x4104b2		f2480f2ad8		CVTSI2SDQ AX, X3			
  0x4104b7		f20f5ed3		DIVSD X3, X2				
  0x4104bb		f20f101de5450600	MOVSD_XMM $f64.3fd0000000000000(SB), X3	
  0x4104c3		f20f58da		ADDSD X2, X3				
	triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization*(actualGrowthRatio-memstats.triggerRatio)
  0x4104c7		f20f101561590b00	MOVSD_XMM runtime.memstats+5936(SB), X2	
  0x4104cf		f20f10642418		MOVSD_XMM 0x18(SP), X4			
  0x4104d5		f20f5ce2		SUBSD X2, X4				
  0x4104d9		f20f1035cf450600	MOVSD_XMM $f64.3fd3333333333333(SB), X6	
  0x4104e1		0f10fb			MOVUPS X3, X7				
  0x4104e4		f20f5ede		DIVSD X6, X3				
  0x4104e8		440f10c0		MOVUPS X0, X8				
  0x4104ec		f20f5cc2		SUBSD X2, X0				
  0x4104f0		440f10c8		MOVUPS X0, X9				
  0x4104f4		f20f59c3		MULSD X3, X0				
  0x4104f8		440f10d4		MOVUPS X4, X10				
  0x4104fc		f20f5ce0		SUBSD X0, X4				
	triggerRatio := memstats.triggerRatio + triggerGain*triggerError
  0x410500		f20f1005b0450600	MOVSD_XMM $f64.3fe0000000000000(SB), X0	
  0x410508		f20f59c4		MULSD X4, X0				
  0x41050c		f20f58c2		ADDSD X2, X0				
  0x410510		f20f11442410		MOVSD_XMM X0, 0x10(SP)			
	if debug.gcpacertrace > 0 {
  0x410516		8b05b4350b00		MOVL runtime.debug+16(SB), AX	
  0x41051c		85c0			TESTL AX, AX			
  0x41051e		0f8ea2020000		JLE 0x4107c6			
  0x410524		f2440f11442470		MOVSD_XMM X8, 0x70(SP)		
  0x41052b		f20f11542468		MOVSD_XMM X2, 0x68(SP)		
  0x410531		f2440f11542460		MOVSD_XMM X10, 0x60(SP)		
  0x410538		f20f117c2458		MOVSD_XMM X7, 0x58(SP)		
  0x41053e		f20f115c2450		MOVSD_XMM X3, 0x50(SP)		
  0x410544		f2440f114c2448		MOVSD_XMM X9, 0x48(SP)		
		H_m_prev := memstats.heap_marked
  0x41054b		488b05fe580b00		MOVQ runtime.memstats+5968(SB), AX	
  0x410552		4889442428		MOVQ AX, 0x28(SP)			
		H_T := memstats.gc_trigger
  0x410557		488b15da580b00		MOVQ runtime.memstats+5944(SB), DX	
  0x41055e		4889542438		MOVQ DX, 0x38(SP)			
		H_a := memstats.heap_live
  0x410563		488b1dd6580b00		MOVQ runtime.memstats+5952(SB), BX	
  0x41056a		48895c2430		MOVQ BX, 0x30(SP)			
		H_g := int64(float64(H_m_prev) * (1 + h_g))
  0x41056f		4885c0			TESTQ AX, AX		
  0x410572		0f8c6a020000		JL 0x4107e2		
  0x410578		0f57e4			XORPS X4, X4		
  0x41057b		f2480f2ae0		CVTSI2SDQ AX, X4	
  0x410580		f20f11642440		MOVSD_XMM X4, 0x40(SP)	
		W_a := c.scanWork
  0x410586		488b01			MOVQ 0(CX), AX		
  0x410589		4889442420		MOVQ AX, 0x20(SP)	
		print("pacer: H_m_prev=", H_m_prev,
  0x41058e		e86d150100		CALL runtime.printlock(SB)	
  0x410593		488d0598a50500		LEAQ 0x5a598(IP), AX		
  0x41059a		48890424		MOVQ AX, 0(SP)			
  0x41059e		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4105a7		e8941e0100		CALL runtime.printstring(SB)	
  0x4105ac		488b442428		MOVQ 0x28(SP), AX		
  0x4105b1		48890424		MOVQ AX, 0(SP)			
  0x4105b5		e8b61b0100		CALL runtime.printuint(SB)	
  0x4105ba		488d05a7970500		LEAQ 0x597a7(IP), AX		
  0x4105c1		48890424		MOVQ AX, 0(SP)			
  0x4105c5		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4105ce		e86d1e0100		CALL runtime.printstring(SB)	
  0x4105d3		f20f10442468		MOVSD_XMM 0x68(SP), X0		
  0x4105d9		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x4105de		e86d180100		CALL runtime.printfloat(SB)	
  0x4105e3		488d0551970500		LEAQ 0x59751(IP), AX		
  0x4105ea		48890424		MOVQ AX, 0(SP)			
  0x4105ee		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4105f7		e8441e0100		CALL runtime.printstring(SB)	
  0x4105fc		488b442438		MOVQ 0x38(SP), AX		
  0x410601		48890424		MOVQ AX, 0(SP)			
  0x410605		e8661b0100		CALL runtime.printuint(SB)	
  0x41060a		488d054d970500		LEAQ 0x5974d(IP), AX		
  0x410611		48890424		MOVQ AX, 0(SP)			
  0x410615		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x41061e		e81d1e0100		CALL runtime.printstring(SB)	
  0x410623		f20f10442470		MOVSD_XMM 0x70(SP), X0		
  0x410629		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x41062e		e81d180100		CALL runtime.printfloat(SB)	
  0x410633		488d0506970500		LEAQ 0x59706(IP), AX		
  0x41063a		48890424		MOVQ AX, 0(SP)			
  0x41063e		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x410647		e8f41d0100		CALL runtime.printstring(SB)	
  0x41064c		488b442430		MOVQ 0x30(SP), AX		
  0x410651		48890424		MOVQ AX, 0(SP)			
  0x410655		e8161b0100		CALL runtime.printuint(SB)	
  0x41065a		488d0502970500		LEAQ 0x59702(IP), AX		
  0x410661		48890424		MOVQ AX, 0(SP)			
  0x410665		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x41066e		e8cd1d0100		CALL runtime.printstring(SB)	
  0x410673		f20f10442418		MOVSD_XMM 0x18(SP), X0		
  0x410679		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x41067e		e8cd170100		CALL runtime.printfloat(SB)	
  0x410683		488d05bb960500		LEAQ 0x596bb(IP), AX		
  0x41068a		48890424		MOVQ AX, 0(SP)			
  0x41068e		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x410697		e8a41d0100		CALL runtime.printstring(SB)	
		H_g := int64(float64(H_m_prev) * (1 + h_g))
  0x41069c		f20f10052c440600	MOVSD_XMM $f64.3ff0000000000000(SB), X0	
  0x4106a4		f20f104c2418		MOVSD_XMM 0x18(SP), X1			
  0x4106aa		f20f58c1		ADDSD X1, X0				
  0x4106ae		f20f104c2440		MOVSD_XMM 0x40(SP), X1			
  0x4106b4		f20f59c1		MULSD X1, X0				
  0x4106b8		f2480f2cc0		CVTTSD2SIQ X0, AX			
		print("pacer: H_m_prev=", H_m_prev,
  0x4106bd		48890424		MOVQ AX, 0(SP)				
  0x4106c1		e8ba1b0100		CALL runtime.printint(SB)		
  0x4106c6		488d05be960500		LEAQ 0x596be(IP), AX			
  0x4106cd		48890424		MOVQ AX, 0(SP)				
  0x4106d1		48c744240805000000	MOVQ $0x5, 0x8(SP)			
  0x4106da		e8611d0100		CALL runtime.printstring(SB)		
  0x4106df		f20f10442458		MOVSD_XMM 0x58(SP), X0			
  0x4106e5		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x4106ea		e861170100		CALL runtime.printfloat(SB)		
  0x4106ef		488d059a960500		LEAQ 0x5969a(IP), AX			
  0x4106f6		48890424		MOVQ AX, 0(SP)				
  0x4106fa		48c744240805000000	MOVQ $0x5, 0x8(SP)			
  0x410703		e8381d0100		CALL runtime.printstring(SB)		
  0x410708		f20f1005a0430600	MOVSD_XMM $f64.3fd3333333333333(SB), X0	
  0x410710		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x410715		e836170100		CALL runtime.printfloat(SB)		
  0x41071a		488d052e960500		LEAQ 0x5962e(IP), AX			
  0x410721		48890424		MOVQ AX, 0(SP)				
  0x410725		48c744240805000000	MOVQ $0x5, 0x8(SP)			
  0x41072e		e80d1d0100		CALL runtime.printstring(SB)		
  0x410733		488b442420		MOVQ 0x20(SP), AX			
  0x410738		48890424		MOVQ AX, 0(SP)				
  0x41073c		e83f1b0100		CALL runtime.printint(SB)		
  0x410741		488d0547980500		LEAQ 0x59847(IP), AX			
  0x410748		48890424		MOVQ AX, 0(SP)				
  0x41074c		48c744240808000000	MOVQ $0x8, 0x8(SP)			
  0x410755		e8e61c0100		CALL runtime.printstring(SB)		
  0x41075a		f20f10442460		MOVSD_XMM 0x60(SP), X0			
  0x410760		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x410765		e8e6160100		CALL runtime.printfloat(SB)		
  0x41076a		488d050f9b0500		LEAQ 0x59b0f(IP), AX			
  0x410771		48890424		MOVQ AX, 0(SP)				
  0x410775		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x41077e		e8bd1c0100		CALL runtime.printstring(SB)		
  0x410783		f20f10442448		MOVSD_XMM 0x48(SP), X0			
  0x410789		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x41078e		e8bd160100		CALL runtime.printfloat(SB)		
  0x410793		488d0523990500		LEAQ 0x59923(IP), AX			
  0x41079a		48890424		MOVQ AX, 0(SP)				
  0x41079e		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x4107a7		e8941c0100		CALL runtime.printstring(SB)		
  0x4107ac		f20f10442450		MOVSD_XMM 0x50(SP), X0			
  0x4107b2		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x4107b7		e894160100		CALL runtime.printfloat(SB)		
  0x4107bc		e8cf150100		CALL runtime.printnl(SB)		
  0x4107c1		e8ba130100		CALL runtime.printunlock(SB)		
	return triggerRatio
  0x4107c6		f20f10442410		MOVSD_XMM 0x10(SP), X0	
  0x4107cc		f20f11842490000000	MOVSD_XMM X0, 0x90(SP)	
  0x4107d5		488b6c2478		MOVQ 0x78(SP), BP	
  0x4107da		4881c480000000		ADDQ $0x80, SP		
  0x4107e1		c3			RET			
  0x4107e2		4889c6			MOVQ AX, SI		
		H_g := int64(float64(H_m_prev) * (1 + h_g))
  0x4107e5		4883e001		ANDQ $0x1, AX				
  0x4107e9		48d1ee			SHRQ $0x1, SI				
  0x4107ec		4809f0			ORQ SI, AX				
  0x4107ef		0f57e4			XORPS X4, X4				
  0x4107f2		f2480f2ae0		CVTSI2SDQ AX, X4			
  0x4107f7		f20f58e4		ADDSD X4, X4				
  0x4107fb		e980fdffff		JMP 0x410580				
  0x410800		f20f101da0420600	MOVSD_XMM $f64.3fd0000000000000(SB), X3	
	if assistDuration > 0 {
  0x410808		e9bafcffff		JMP 0x4104c7		
  0x41080d		4889c1			MOVQ AX, CX		
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x410810		4883e001		ANDQ $0x1, AX		
  0x410814		48d1e9			SHRQ $0x1, CX		
  0x410817		4809c8			ORQ CX, AX		
  0x41081a		0f57d2			XORPS X2, X2		
  0x41081d		f2480f2ad0		CVTSI2SDQ AX, X2	
  0x410822		f20f58d2		ADDSD X2, X2		
  0x410826		e92dfcffff		JMP 0x410458		
  0x41082b		4889c1			MOVQ AX, CX		
  0x41082e		4883e001		ANDQ $0x1, AX		
  0x410832		48d1e9			SHRQ $0x1, CX		
  0x410835		4809c8			ORQ CX, AX		
  0x410838		0f57c9			XORPS X1, X1		
  0x41083b		f2480f2ac8		CVTSI2SDQ AX, X1	
  0x410840		f20f58c9		ADDSD X1, X1		
  0x410844		e9ebfbffff		JMP 0x410434		
		return memstats.triggerRatio
  0x410849		f20f1005df550b00	MOVSD_XMM runtime.memstats+5936(SB), X0	
  0x410851		f20f11842490000000	MOVSD_XMM X0, 0x90(SP)			
  0x41085a		488b6c2478		MOVQ 0x78(SP), BP			
  0x41085f		4881c480000000		ADDQ $0x80, SP				
  0x410866		c3			RET					
func (c *gcControllerState) endCycle() float64 {
  0x410867		e8043d0300		CALL runtime.morestack_noctxt(SB)		
  0x41086c		e95ffbffff		JMP runtime.(*gcControllerState).endCycle(SB)	

TEXT runtime.(*gcControllerState).enlistWorker(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func (c *gcControllerState) enlistWorker() {
  0x410880		4883ec08		SUBQ $0x8, SP		
  0x410884		48892c24		MOVQ BP, 0(SP)		
  0x410888		488d2c24		LEAQ 0(SP), BP		
  0x41088c		488b442410		MOVQ 0x10(SP), AX	
	if c.dedicatedMarkWorkersNeeded <= 0 {
  0x410891		488b4038		MOVQ 0x38(AX), AX	
  0x410895		4885c0			TESTQ AX, AX		
  0x410898		0f8e5e010000		JLE 0x4109fc		
	if gomaxprocs <= 1 {
  0x41089e		8b053c300b00		MOVL runtime.gomaxprocs(SB), AX	
  0x4108a4		83f801			CMPL $0x1, AX			
  0x4108a7		0f8e46010000		JLE 0x4109f3			
	gp := getg()
  0x4108ad		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp == nil || gp.m == nil || gp.m.p == 0 {
  0x4108b6		4885c0			TESTQ AX, AX		
  0x4108b9		0f842b010000		JE 0x4109ea		
  0x4108bf		488b4030		MOVQ 0x30(AX), AX	
  0x4108c3		4885c0			TESTQ AX, AX		
  0x4108c6		0f841e010000		JE 0x4109ea		
  0x4108cc		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x4108d3		4885c0			TESTQ AX, AX		
  0x4108d6		0f840e010000		JE 0x4109ea		
	myID := gp.m.p.ptr().id
  0x4108dc		8b4008			MOVL 0x8(AX), AX	
  0x4108df		31c9			XORL CX, CX		
	for tries := 0; tries < 5; tries++ {
  0x4108e1		eb03			JMP 0x4108e6		
  0x4108e3		48ffc1			INCQ CX			
  0x4108e6		4883f905		CMPQ $0x5, CX		
  0x4108ea		0f8df1000000		JGE 0x4109e1		
	mp := getg().m
  0x4108f0		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x4108f9		488b5230		MOVQ 0x30(DX), DX	
		id := int32(fastrandn(uint32(gomaxprocs - 1)))
  0x4108fd		8b1ddd2f0b00		MOVL runtime.gomaxprocs(SB), BX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x410903		8bb220010000		MOVL 0x120(DX), SI	
  0x410909		8bba24010000		MOVL 0x124(DX), DI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x41090f		89ba20010000		MOVL DI, 0x120(DX)	
  0x410915		4189f0			MOVL SI, R8		
	s1 ^= s1 << 17
  0x410918		c1e611			SHLL $0x11, SI		
  0x41091b		4431c6			XORL R8, SI		
  0x41091e		4189f8			MOVL DI, R8		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x410921		31f7			XORL SI, DI		
  0x410923		c1ee07			SHRL $0x7, SI		
  0x410926		31fe			XORL DI, SI		
  0x410928		4489c7			MOVL R8, DI		
  0x41092b		41c1e810		SHRL $0x10, R8		
  0x41092f		4131f0			XORL SI, R8		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x410932		44898224010000		MOVL R8, 0x124(DX)	
		id := int32(fastrandn(uint32(gomaxprocs - 1)))
  0x410939		8d53ff			LEAL -0x1(BX), DX	
	return s0 + s1
  0x41093c		428d1c07		LEAL 0(DI)(R8*1), BX	
	return uint32(uint64(fastrand()) * uint64(n) >> 32)
  0x410940		480fafda		IMULQ DX, BX		
  0x410944		48c1eb20		SHRQ $0x20, BX		
		if id >= myID {
  0x410948		39c3			CMPL AX, BX		
  0x41094a		0f8c89000000		JL 0x4109d9		
			id++
  0x410950		8d5301			LEAL 0x1(BX), DX	
		p := allp[id]
  0x410953		488b1d5e6d0900		MOVQ runtime.allp+8(SB), BX	
  0x41095a		488b354f6d0900		MOVQ runtime.allp(SB), SI	
  0x410961		4863d2			MOVSXD DX, DX			
  0x410964		4839da			CMPQ BX, DX			
  0x410967		0f8398000000		JAE 0x410a05			
  0x41096d		488b14d6		MOVQ 0(SI)(DX*8), DX		
		if p.status != _Prunning {
  0x410971		8b5a0c			MOVL 0xc(DX), BX	
  0x410974		83fb01			CMPL $0x1, BX		
  0x410977		0f8566ffffff		JNE 0x4108e3		
	mp := _p_.m.ptr()
  0x41097d		488b5240		MOVQ 0x40(DX), DX	
	if mp == nil || mp == getg().m {
  0x410981		4885d2			TESTQ DX, DX		
  0x410984		7412			JE 0x410998		
  0x410986		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x41098f		488b5b30		MOVQ 0x30(BX), BX	
  0x410993		4839da			CMPQ BX, DX		
  0x410996		7513			JNE 0x4109ab		
  0x410998		31d2			XORL DX, DX		
		if preemptone(p) {
  0x41099a		84d2			TESTL DL, DL		
  0x41099c		0f8441ffffff		JE 0x4108e3		
			return
  0x4109a2		488b2c24		MOVQ 0(SP), BP		
  0x4109a6		4883c408		ADDQ $0x8, SP		
  0x4109aa		c3			RET			
	gp := mp.curg
  0x4109ab		488b9ac0000000		MOVQ 0xc0(DX), BX	
	if gp == nil || gp == mp.g0 {
  0x4109b2		4885db			TESTQ BX, BX		
  0x4109b5		7408			JE 0x4109bf		
  0x4109b7		488b12			MOVQ 0(DX), DX		
  0x4109ba		4839d3			CMPQ DX, BX		
  0x4109bd		7504			JNE 0x4109c3		
  0x4109bf		31d2			XORL DX, DX		
		if preemptone(p) {
  0x4109c1		ebd7			JMP 0x41099a		
	gp.preempt = true
  0x4109c3		c683c000000001		MOVB $0x1, 0xc0(BX)	
	gp.stackguard0 = stackPreempt
  0x4109ca		48c74310defaffff	MOVQ $-0x522, 0x10(BX)	
  0x4109d2		ba01000000		MOVL $0x1, DX		
		if preemptone(p) {
  0x4109d7		ebc1			JMP 0x41099a		
  0x4109d9		4889da			MOVQ BX, DX		
		if id >= myID {
  0x4109dc		e972ffffff		JMP 0x410953		
  0x4109e1		488b2c24		MOVQ 0(SP), BP		
  0x4109e5		4883c408		ADDQ $0x8, SP		
  0x4109e9		c3			RET			
		return
  0x4109ea		488b2c24		MOVQ 0(SP), BP		
  0x4109ee		4883c408		ADDQ $0x8, SP		
  0x4109f2		c3			RET			
		return
  0x4109f3		488b2c24		MOVQ 0(SP), BP		
  0x4109f7		4883c408		ADDQ $0x8, SP		
  0x4109fb		c3			RET			
		return
  0x4109fc		488b2c24		MOVQ 0(SP), BP		
  0x410a00		4883c408		ADDQ $0x8, SP		
  0x410a04		c3			RET			
		p := allp[id]
  0x410a05		e836f00000		CALL runtime.panicindex(SB)	
  0x410a0a		0f0b			UD2				

TEXT runtime.(*gcControllerState).findRunnableGCWorker(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g {
  0x410a10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410a19		483b6110		CMPQ 0x10(CX), SP	
  0x410a1d		0f8658020000		JBE 0x410c7b		
  0x410a23		4883ec20		SUBQ $0x20, SP		
  0x410a27		48896c2418		MOVQ BP, 0x18(SP)	
  0x410a2c		488d6c2418		LEAQ 0x18(SP), BP	
	if gcBlackenEnabled == 0 {
  0x410a31		8b059d2e0b00		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x410a37		85c0			TESTL AX, AX				
  0x410a39		0f8421020000		JE 0x410c60				
  0x410a3f		488b442430		MOVQ 0x30(SP), AX			
	if _p_.gcBgMarkWorker == 0 {
  0x410a44		8400			TESTB AL, 0(AX)		
  0x410a46		488b8858120000		MOVQ 0x1258(AX), CX	
  0x410a4d		4885c9			TESTQ CX, CX		
  0x410a50		0f84f7010000		JE 0x410c4d		
	if p != nil && !p.gcw.empty() {
  0x410a56		488d8870120000		LEAQ 0x1270(AX), CX	
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x410a5d		8401			TESTB AL, 0(CX)		
  0x410a5f		488b8870120000		MOVQ 0x1270(AX), CX	
  0x410a66		4885c9			TESTQ CX, CX		
  0x410a69		0f84d4010000		JE 0x410c43		
  0x410a6f		488b4910		MOVQ 0x10(CX), CX	
  0x410a73		4885c9			TESTQ CX, CX		
  0x410a76		0f85c0010000		JNE 0x410c3c		
  0x410a7c		488b8878120000		MOVQ 0x1278(AX), CX	
  0x410a83		488b4910		MOVQ 0x10(CX), CX	
  0x410a87		4885c9			TESTQ CX, CX		
  0x410a8a		0f94c1			SETE CL			
  0x410a8d		84c9			TESTL CL, CL		
	if p != nil && !p.gcw.empty() {
  0x410a8f		0f849d010000		JE 0x410c32		
	return atomic.Load64((*uint64)(head)) == 0
  0x410a95		488b0d04730900		MOVQ runtime.work(SB), CX	
  0x410a9c		4885c9			TESTQ CX, CX			
	if !work.full.empty() {
  0x410a9f		0f8583010000		JNE 0x410c28		
	if work.markrootNext < work.markrootJobs {
  0x410aa5		8b0d7d730900		MOVL runtime.work+136(SB), CX	
  0x410aab		8b157b730900		MOVL runtime.work+140(SB), DX	
  0x410ab1		39d1			CMPL DX, CX			
  0x410ab3		0f8368010000		JAE 0x410c21			
  0x410ab9		b901000000		MOVL $0x1, CX			
	if !gcMarkWorkAvailable(_p_) {
  0x410abe		84c9			TESTL CL, CL		
  0x410ac0		0f8448010000		JE 0x410c0e		
  0x410ac6		488b4c2428		MOVQ 0x28(SP), CX	
	if decIfPositive(&c.dedicatedMarkWorkersNeeded) {
  0x410acb		488d5138		LEAQ 0x38(CX), DX	
		if *ptr > 0 {
  0x410acf		8402			TESTB AL, 0(DX)		
  0x410ad1		488b5138		MOVQ 0x38(CX), DX	
  0x410ad5		4885d2			TESTQ DX, DX		
  0x410ad8		0f8e29010000		JLE 0x410c07		
			if atomic.Xaddint64(ptr, -1) >= 0 {
  0x410ade		48c7c2ffffffff		MOVQ $-0x1, DX		
  0x410ae5		f0480fc15138		LOCK XADDQ DX, 0x38(CX)	
  0x410aeb		48ffca			DECQ DX			
  0x410aee		4885d2			TESTQ DX, DX		
  0x410af1		0f8c05010000		JL 0x410bfc		
  0x410af7		ba01000000		MOVL $0x1, DX		
	if decIfPositive(&c.dedicatedMarkWorkersNeeded) {
  0x410afc		84d2			TESTL DL, DL		
  0x410afe		7467			JE 0x410b67		
		_p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode
  0x410b00		48c7806012000000000000	MOVQ $0x0, 0x1260(AX)	
	gp := _p_.gcBgMarkWorker.ptr()
  0x410b0b		488b8058120000		MOVQ 0x1258(AX), AX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x410b12		4889442410		MOVQ AX, 0x10(SP)	
	casgstatus(gp, _Gwaiting, _Grunnable)
  0x410b17		48890424		MOVQ AX, 0(SP)			
  0x410b1b		48b90400000001000000	MOVQ $0x100000004, CX		
  0x410b25		48894c2408		MOVQ CX, 0x8(SP)		
  0x410b2a		e8513f0100		CALL runtime.casgstatus(SB)	
	if trace.enabled {
  0x410b2f		0fb6059a2c0a00		MOVZX runtime.trace+16(SB), AX	
  0x410b36		84c0			TESTL AL, AL			
  0x410b38		7514			JNE 0x410b4e			
	return gp
  0x410b3a		488b442410		MOVQ 0x10(SP), AX	
  0x410b3f		4889442438		MOVQ AX, 0x38(SP)	
  0x410b44		488b6c2418		MOVQ 0x18(SP), BP	
  0x410b49		4883c420		ADDQ $0x20, SP		
  0x410b4d		c3			RET			
  0x410b4e		488b442410		MOVQ 0x10(SP), AX	
		traceGoUnpark(gp, 0)
  0x410b53		48890424		MOVQ AX, 0(SP)			
  0x410b57		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x410b60		e85ba10200		CALL runtime.traceGoUnpark(SB)	
  0x410b65		ebd3			JMP 0x410b3a			
	} else if c.fractionalUtilizationGoal == 0 {
  0x410b67		f20f104150		MOVSD_XMM 0x50(CX), X0	
  0x410b6c		0f57c9			XORPS X1, X1		
  0x410b6f		660f2ec1		UCOMISD X1, X0		
  0x410b73		7502			JNE 0x410b77		
  0x410b75		7b72			JNP 0x410be9		
		delta := nanotime() - gcController.markStartTime
  0x410b77		e8b46e0300		CALL runtime.nanotime(SB)		
  0x410b7c		488b0424		MOVQ 0(SP), AX				
  0x410b80		482b05c9300b00		SUBQ runtime.gcController+48(SB), AX	
		if delta > 0 && float64(_p_.gcFractionalMarkTime)/float64(delta) > c.fractionalUtilizationGoal {
  0x410b87		4885c0			TESTQ AX, AX		
  0x410b8a		7e56			JLE 0x410be2		
  0x410b8c		488b4c2430		MOVQ 0x30(SP), CX	
  0x410b91		488b9150120000		MOVQ 0x1250(CX), DX	
  0x410b98		0f57c0			XORPS X0, X0		
  0x410b9b		f2480f2ac2		CVTSI2SDQ DX, X0	
  0x410ba0		0f57c9			XORPS X1, X1		
  0x410ba3		f2480f2ac8		CVTSI2SDQ AX, X1	
  0x410ba8		f20f5ec1		DIVSD X1, X0		
  0x410bac		488b442428		MOVQ 0x28(SP), AX	
  0x410bb1		f20f104850		MOVSD_XMM 0x50(AX), X1	
  0x410bb6		660f2ec1		UCOMISD X1, X0		
  0x410bba		7713			JA 0x410bcf		
		_p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode
  0x410bbc		48c7816012000001000000	MOVQ $0x1, 0x1260(CX)	
  0x410bc7		4889c8			MOVQ CX, AX		
	gp := _p_.gcBgMarkWorker.ptr()
  0x410bca		e93cffffff		JMP 0x410b0b		
			return nil
  0x410bcf		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x410bd8		488b6c2418		MOVQ 0x18(SP), BP	
  0x410bdd		4883c420		ADDQ $0x20, SP		
  0x410be1		c3			RET			
  0x410be2		488b4c2430		MOVQ 0x30(SP), CX	
		if delta > 0 && float64(_p_.gcFractionalMarkTime)/float64(delta) > c.fractionalUtilizationGoal {
  0x410be7		ebd3			JMP 0x410bbc		
		return nil
  0x410be9		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x410bf2		488b6c2418		MOVQ 0x18(SP), BP	
  0x410bf7		4883c420		ADDQ $0x20, SP		
  0x410bfb		c3			RET			
			atomic.Xaddint64(ptr, +1)
  0x410bfc		ba01000000		MOVL $0x1, DX		
  0x410c01		f0480fc15138		LOCK XADDQ DX, 0x38(CX)	
  0x410c07		31d2			XORL DX, DX		
	if decIfPositive(&c.dedicatedMarkWorkersNeeded) {
  0x410c09		e9eefeffff		JMP 0x410afc		
		return nil
  0x410c0e		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x410c17		488b6c2418		MOVQ 0x18(SP), BP	
  0x410c1c		4883c420		ADDQ $0x20, SP		
  0x410c20		c3			RET			
  0x410c21		31c9			XORL CX, CX		
	if !gcMarkWorkAvailable(_p_) {
  0x410c23		e996feffff		JMP 0x410abe		
  0x410c28		b901000000		MOVL $0x1, CX		
  0x410c2d		e98cfeffff		JMP 0x410abe		
  0x410c32		b901000000		MOVL $0x1, CX		
  0x410c37		e982feffff		JMP 0x410abe		
  0x410c3c		31c9			XORL CX, CX		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x410c3e		e94afeffff		JMP 0x410a8d		
  0x410c43		b901000000		MOVL $0x1, CX		
  0x410c48		e940feffff		JMP 0x410a8d		
		return nil
  0x410c4d		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x410c56		488b6c2418		MOVQ 0x18(SP), BP	
  0x410c5b		4883c420		ADDQ $0x20, SP		
  0x410c5f		c3			RET			
		throw("gcControllerState.findRunnable: blackening not enabled")
  0x410c60		488d0527cf0500		LEAQ 0x5cf27(IP), AX	
  0x410c67		48890424		MOVQ AX, 0(SP)		
  0x410c6b		48c744240836000000	MOVQ $0x36, 0x8(SP)	
  0x410c74		e857050100		CALL runtime.throw(SB)	
  0x410c79		0f0b			UD2			
func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g {
  0x410c7b		e8f0380300		CALL runtime.morestack_noctxt(SB)				
  0x410c80		e98bfdffff		JMP runtime.(*gcControllerState).findRunnableGCWorker(SB)	

TEXT runtime.pollFractionalWorkerExit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func pollFractionalWorkerExit() bool {
  0x410c90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410c99		483b6110		CMPQ 0x10(CX), SP	
  0x410c9d		0f8698000000		JBE 0x410d3b		
  0x410ca3		4883ec10		SUBQ $0x10, SP		
  0x410ca7		48896c2408		MOVQ BP, 0x8(SP)	
  0x410cac		488d6c2408		LEAQ 0x8(SP), BP	
	now := nanotime()
  0x410cb1		e87a6d0300		CALL runtime.nanotime(SB)	
  0x410cb6		488b0424		MOVQ 0(SP), AX			
	delta := now - gcController.markStartTime
  0x410cba		488b0d8f2f0b00		MOVQ runtime.gcController+48(SB), CX	
  0x410cc1		4889c2			MOVQ AX, DX				
  0x410cc4		4829c8			SUBQ CX, AX				
	if delta <= 0 {
  0x410cc7		4885c0			TESTQ AX, AX		
  0x410cca		7f0f			JG 0x410cdb		
		return true
  0x410ccc		c644241801		MOVB $0x1, 0x18(SP)	
  0x410cd1		488b6c2408		MOVQ 0x8(SP), BP	
  0x410cd6		4883c410		ADDQ $0x10, SP		
  0x410cda		c3			RET			
	p := getg().m.p.ptr()
  0x410cdb		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410ce4		488b4930		MOVQ 0x30(CX), CX	
  0x410ce8		488b89d0000000		MOVQ 0xd0(CX), CX	
	selfTime := p.gcFractionalMarkTime + (now - p.gcMarkWorkerStartTime)
  0x410cef		8401			TESTB AL, 0(CX)		
  0x410cf1		488b9968120000		MOVQ 0x1268(CX), BX	
  0x410cf8		4829da			SUBQ BX, DX		
  0x410cfb		48039150120000		ADDQ 0x1250(CX), DX	
	return float64(selfTime)/float64(delta) > 1.2*gcController.fractionalUtilizationGoal
  0x410d02		f20f1005d63d0600	MOVSD_XMM $f64.3ff3333333333333(SB), X0	
  0x410d0a		f20f59055e2f0b00	MULSD runtime.gcController+80(SB), X0	
  0x410d12		0f57c9			XORPS X1, X1				
  0x410d15		f2480f2aca		CVTSI2SDQ DX, X1			
  0x410d1a		0f57d2			XORPS X2, X2				
  0x410d1d		f2480f2ad0		CVTSI2SDQ AX, X2			
  0x410d22		f20f5eca		DIVSD X2, X1				
  0x410d26		660f2ec8		UCOMISD X0, X1				
  0x410d2a		0f97c0			SETA AL					
  0x410d2d		88442418		MOVB AL, 0x18(SP)			
  0x410d31		488b6c2408		MOVQ 0x8(SP), BP			
  0x410d36		4883c410		ADDQ $0x10, SP				
  0x410d3a		c3			RET					
func pollFractionalWorkerExit() bool {
  0x410d3b		e830380300		CALL runtime.morestack_noctxt(SB)		
  0x410d40		e94bffffff		JMP runtime.pollFractionalWorkerExit(SB)	

TEXT runtime.gcSetTriggerRatio(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcSetTriggerRatio(triggerRatio float64) {
  0x410d50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410d59		483b6110		CMPQ 0x10(CX), SP	
  0x410d5d		0f8606040000		JBE 0x411169		
  0x410d63		4883ec40		SUBQ $0x40, SP		
  0x410d67		48896c2438		MOVQ BP, 0x38(SP)	
  0x410d6c		488d6c2438		LEAQ 0x38(SP), BP	
	if triggerRatio < 0 {
  0x410d71		0f57c0			XORPS X0, X0		
  0x410d74		f20f104c2448		MOVSD_XMM 0x48(SP), X1	
  0x410d7a		660f2ec1		UCOMISD X1, X0		
  0x410d7e		0f8653020000		JBE 0x410fd7		
  0x410d84		0f57c9			XORPS X1, X1		
	memstats.triggerRatio = triggerRatio
  0x410d87		f20f110da1500b00	MOVSD_XMM X1, runtime.memstats+5936(SB)	
	if gcpercent >= 0 {
  0x410d8f		8b0d432b0b00		MOVL runtime.gcpercent(SB), CX	
  0x410d95		85c9			TESTL CX, CX			
  0x410d97		0f8c2e020000		JL 0x410fcb			
		trigger = uint64(float64(memstats.heap_marked) * (1 + triggerRatio))
  0x410d9d		488b0dac500b00		MOVQ runtime.memstats+5968(SB), CX	
  0x410da4		4885c9			TESTQ CX, CX				
  0x410da7		0f8c00020000		JL 0x410fad				
  0x410dad		0f57d2			XORPS X2, X2				
  0x410db0		f2480f2ad1		CVTSI2SDQ CX, X2			
  0x410db5		f20f101d133d0600	MOVSD_XMM $f64.3ff0000000000000(SB), X3	
  0x410dbd		f20f58d9		ADDSD X1, X3				
  0x410dc1		f20f59da		MULSD X2, X3				
  0x410dc5		f20f10154b3d0600	MOVSD_XMM $f64.43e0000000000000(SB), X2	
  0x410dcd		660f2ed3		UCOMISD X3, X2				
  0x410dd1		0f86bb010000		JBE 0x410f92				
  0x410dd7		f2480f2ccb		CVTTSD2SIQ X3, CX			
		minTrigger := heapminimum
  0x410ddc		488b1555420900		MOVQ runtime.heapminimum(SB), DX	
	return mheap_.sweepdone != 0
  0x410de3		8b1ddbc40900		MOVL runtime.mheap_+4132(SB), BX	
  0x410de9		85db			TESTL BX, BX				
		if !gosweepdone() {
  0x410deb		0f8464010000		JE 0x410f55		
		if trigger < minTrigger {
  0x410df1		4839d1			CMPQ DX, CX		
  0x410df4		0f8350010000		JAE 0x410f4a		
  0x410dfa		4889d0			MOVQ DX, AX		
		if int64(trigger) < 0 {
  0x410dfd		4885d2			TESTQ DX, DX		
  0x410e00		0f8c12020000		JL 0x411018		
	memstats.gc_trigger = trigger
  0x410e06		4889152b500b00		MOVQ DX, runtime.memstats+5944(SB)	
	if gcpercent >= 0 {
  0x410e0d		8b0dc52a0b00		MOVL runtime.gcpercent(SB), CX	
  0x410e13		85c9			TESTL CX, CX			
  0x410e15		0f8c20010000		JL 0x410f3b			
		goal = memstats.heap_marked + memstats.heap_marked*uint64(gcpercent)/100
  0x410e1b		488b1d2e500b00		MOVQ runtime.memstats+5968(SB), BX	
  0x410e22		4863c9			MOVSXD CX, CX				
  0x410e25		480fafcb		IMULQ BX, CX				
  0x410e29		48d1e9			SHRQ $0x1, CX				
  0x410e2c		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX		
  0x410e36		4889d6			MOVQ DX, SI				
  0x410e39		48f7e1			MULQ CX					
  0x410e3c		48c1ea05		SHRQ $0x5, DX				
  0x410e40		488d0c13		LEAQ 0(BX)(DX*1), CX			
		if goal < trigger {
  0x410e44		4839f1			CMPQ SI, CX		
  0x410e47		0f83e3000000		JAE 0x410f30		
  0x410e4d		4889f0			MOVQ SI, AX		
			goal = trigger
  0x410e50		4889442430		MOVQ AX, 0x30(SP)	
	memstats.next_gc = goal
  0x410e55		4889354c390b00		MOVQ SI, runtime.memstats+168(SB)	
	if trace.enabled {
  0x410e5c		0fb60d6d290a00		MOVZX runtime.trace+16(SB), CX	
  0x410e63		84c9			TESTL CL, CL			
  0x410e65		0f85b3000000		JNE 0x410f1e			
	if gcphase != _GCoff {
  0x410e6b		8b0d6b2a0b00		MOVL runtime.gcphase(SB), CX	
  0x410e71		85c9			TESTL CX, CX			
  0x410e73		0f8588000000		JNE 0x410f01			
	return mheap_.sweepdone != 0
  0x410e79		8b0d45c40900		MOVL runtime.mheap_+4132(SB), CX	
  0x410e7f		85c9			TESTL CX, CX				
	if gosweepdone() {
  0x410e81		7412			JE 0x410e95		
		mheap_.sweepPagesPerByte = 0
  0x410e83		f20f1105edc40900	MOVSD_XMM X0, runtime.mheap_+4312(SB)	
  0x410e8b		488b6c2438		MOVQ 0x38(SP), BP			
  0x410e90		4883c440		ADDQ $0x40, SP				
  0x410e94		c3			RET					
		heapLiveBasis := atomic.Load64(&memstats.heap_live)
  0x410e95		488b0da44f0b00		MOVQ runtime.memstats+5952(SB), CX	
		heapDistance := int64(trigger) - int64(heapLiveBasis)
  0x410e9c		4829c8			SUBQ CX, AX		
		heapDistance -= 1024 * 1024
  0x410e9f		48050000f0ff		ADDQ $-0x100000, AX	
		if heapDistance < _PageSize {
  0x410ea5		483d00200000		CMPQ $0x2000, AX	
  0x410eab		7d05			JGE 0x410eb2		
  0x410ead		b800200000		MOVL $0x2000, AX	
		pagesSwept := atomic.Load64(&mheap_.pagesSwept)
  0x410eb2		488b15a7c40900		MOVQ runtime.mheap_+4288(SB), DX	
		sweepDistancePages := int64(mheap_.pagesInUse) - int64(pagesSwept)
  0x410eb9		488b1d98c40900		MOVQ runtime.mheap_+4280(SB), BX	
  0x410ec0		4829d3			SUBQ DX, BX				
		if sweepDistancePages <= 0 {
  0x410ec3		4885db			TESTQ BX, BX		
  0x410ec6		7f0a			JG 0x410ed2		
			mheap_.sweepPagesPerByte = 0
  0x410ec8		f20f1105a8c40900	MOVSD_XMM X0, runtime.mheap_+4312(SB)	
  0x410ed0		ebb9			JMP 0x410e8b				
			mheap_.sweepPagesPerByte = float64(sweepDistancePages) / float64(heapDistance)
  0x410ed2		0f57c0			XORPS X0, X0				
  0x410ed5		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x410eda		0f57c9			XORPS X1, X1				
  0x410edd		f2480f2ac8		CVTSI2SDQ AX, X1			
  0x410ee2		f20f5ec1		DIVSD X1, X0				
  0x410ee6		f20f11058ac40900	MOVSD_XMM X0, runtime.mheap_+4312(SB)	
			mheap_.sweepHeapLiveBasis = heapLiveBasis
  0x410eee		48890d7bc40900		MOVQ CX, runtime.mheap_+4304(SB)	
			atomic.Store64(&mheap_.pagesSweptBasis, pagesSwept)
  0x410ef5		488d056cc40900		LEAQ runtime.mheap_+4296(SB), AX	
  0x410efc		488710			XCHGQ DX, 0(AX)				
  0x410eff		eb8a			JMP 0x410e8b				
		gcController.revise()
  0x410f01		488d05182d0b00		LEAQ runtime.gcController(SB), AX		
  0x410f08		48890424		MOVQ AX, 0(SP)					
  0x410f0c		e8aff3ffff		CALL runtime.(*gcControllerState).revise(SB)	
  0x410f11		488b442430		MOVQ 0x30(SP), AX				
  0x410f16		0f57c0			XORPS X0, X0					
  0x410f19		e95bffffff		JMP 0x410e79					
		traceNextGC()
  0x410f1e		e83da10200		CALL runtime.traceNextGC(SB)	
  0x410f23		488b442430		MOVQ 0x30(SP), AX		
  0x410f28		0f57c0			XORPS X0, X0			
  0x410f2b		e93bffffff		JMP 0x410e6b			
  0x410f30		4889f0			MOVQ SI, AX			
  0x410f33		4889ce			MOVQ CX, SI			
		if goal < trigger {
  0x410f36		e915ffffff		JMP 0x410e50		
  0x410f3b		4889d0			MOVQ DX, AX		
  0x410f3e		48c7c6ffffffff		MOVQ $-0x1, SI		
	if gcpercent >= 0 {
  0x410f45		e906ffffff		JMP 0x410e50		
  0x410f4a		4889d0			MOVQ DX, AX		
  0x410f4d		4889ca			MOVQ CX, DX		
		if trigger < minTrigger {
  0x410f50		e9a8feffff		JMP 0x410dfd		
			sweepMin := atomic.Load64(&memstats.heap_live) + sweepMinHeapDistance*uint64(gcpercent)/100
  0x410f55		488b1de44e0b00		MOVQ runtime.memstats+5952(SB), BX	
  0x410f5c		48633575290b00		MOVSXD runtime.gcpercent(SB), SI	
  0x410f63		48c1e614		SHLQ $0x14, SI				
  0x410f67		48d1ee			SHRQ $0x1, SI				
  0x410f6a		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX		
  0x410f74		4889d7			MOVQ DX, DI				
  0x410f77		48f7e6			MULQ SI					
  0x410f7a		48c1ea05		SHRQ $0x5, DX				
  0x410f7e		4801da			ADDQ BX, DX				
			if sweepMin > minTrigger {
  0x410f81		4839fa			CMPQ DI, DX		
  0x410f84		0f8767feffff		JA 0x410df1		
  0x410f8a		4889fa			MOVQ DI, DX		
  0x410f8d		e95ffeffff		JMP 0x410df1		
		trigger = uint64(float64(memstats.heap_marked) * (1 + triggerRatio))
  0x410f92		f20f5cda		SUBSD X2, X3			
  0x410f96		f2480f2ccb		CVTTSD2SIQ X3, CX		
  0x410f9b		48ba0000000000000080	MOVQ $0x8000000000000000, DX	
  0x410fa5		4809d1			ORQ DX, CX			
  0x410fa8		e92ffeffff		JMP 0x410ddc			
  0x410fad		4889ca			MOVQ CX, DX			
  0x410fb0		4883e101		ANDQ $0x1, CX			
  0x410fb4		48d1ea			SHRQ $0x1, DX			
  0x410fb7		4809d1			ORQ DX, CX			
  0x410fba		0f57d2			XORPS X2, X2			
  0x410fbd		f2480f2ad1		CVTSI2SDQ CX, X2		
  0x410fc2		f20f58d2		ADDSD X2, X2			
  0x410fc6		e9eafdffff		JMP 0x410db5			
  0x410fcb		48c7c2ffffffff		MOVQ $-0x1, DX			
	if gcpercent >= 0 {
  0x410fd2		e92ffeffff		JMP 0x410e06		
	} else if gcpercent >= 0 {
  0x410fd7		8b0dfb280b00		MOVL runtime.gcpercent(SB), CX	
  0x410fdd		85c9			TESTL CX, CX			
  0x410fdf		7c32			JL 0x411013			
		maxTriggerRatio := 0.95 * float64(gcpercent) / 100
  0x410fe1		0f57d2			XORPS X2, X2				
  0x410fe4		f20f2ad1		CVTSI2SDL CX, X2			
  0x410fe8		f20f101dd83a0600	MOVSD_XMM $f64.3fee666666666666(SB), X3	
  0x410ff0		f20f59d3		MULSD X3, X2				
  0x410ff4		f20f101d0c3b0600	MOVSD_XMM $f64.4059000000000000(SB), X3	
  0x410ffc		f20f5ed3		DIVSD X3, X2				
		if triggerRatio > maxTriggerRatio {
  0x411000		660f2eca		UCOMISD X2, X1		
  0x411004		7608			JBE 0x41100e		
  0x411006		0f10ca			MOVUPS X2, X1		
	memstats.triggerRatio = triggerRatio
  0x411009		e979fdffff		JMP 0x410d87		
  0x41100e		0f10d1			MOVUPS X1, X2		
		if triggerRatio > maxTriggerRatio {
  0x411011		ebf3			JMP 0x411006		
  0x411013		0f10d1			MOVUPS X1, X2		
	} else if gcpercent >= 0 {
  0x411016		ebee			JMP 0x411006		
  0x411018		f20f114c2448		MOVSD_XMM X1, 0x48(SP)	
  0x41101e		4889442430		MOVQ AX, 0x30(SP)	
			print("runtime: next_gc=", memstats.next_gc, " heap_marked=", memstats.heap_marked, " heap_live=", memstats.heap_live, " initialHeapLive=", work.initialHeapLive, "triggerRatio=", triggerRatio, " minTrigger=", minTrigger, "\n")
  0x411023		488b057e370b00		MOVQ runtime.memstats+168(SB), AX	
  0x41102a		4889442428		MOVQ AX, 0x28(SP)			
  0x41102f		488b0d1a4e0b00		MOVQ runtime.memstats+5968(SB), CX	
  0x411036		48894c2420		MOVQ CX, 0x20(SP)			
  0x41103b		488b15fe4d0b00		MOVQ runtime.memstats+5952(SB), DX	
  0x411042		4889542418		MOVQ DX, 0x18(SP)			
  0x411047		488b1d6a6e0900		MOVQ runtime.work+280(SB), BX		
  0x41104e		48895c2410		MOVQ BX, 0x10(SP)			
  0x411053		e8a80a0100		CALL runtime.printlock(SB)		
  0x411058		488d05539c0500		LEAQ 0x59c53(IP), AX			
  0x41105f		48890424		MOVQ AX, 0(SP)				
  0x411063		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x41106c		e8cf130100		CALL runtime.printstring(SB)		
  0x411071		488b442428		MOVQ 0x28(SP), AX			
  0x411076		48890424		MOVQ AX, 0(SP)				
  0x41107a		e8f1100100		CALL runtime.printuint(SB)		
  0x41107f		488d0505960500		LEAQ 0x59605(IP), AX			
  0x411086		48890424		MOVQ AX, 0(SP)				
  0x41108a		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x411093		e8a8130100		CALL runtime.printstring(SB)		
  0x411098		488b442420		MOVQ 0x20(SP), AX			
  0x41109d		48890424		MOVQ AX, 0(SP)				
  0x4110a1		e8ca100100		CALL runtime.printuint(SB)		
  0x4110a6		488d0517930500		LEAQ 0x59317(IP), AX			
  0x4110ad		48890424		MOVQ AX, 0(SP)				
  0x4110b1		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x4110ba		e881130100		CALL runtime.printstring(SB)		
  0x4110bf		488b442418		MOVQ 0x18(SP), AX			
  0x4110c4		48890424		MOVQ AX, 0(SP)				
  0x4110c8		e8a3100100		CALL runtime.printuint(SB)		
  0x4110cd		488d05ce9a0500		LEAQ 0x59ace(IP), AX			
  0x4110d4		48890424		MOVQ AX, 0(SP)				
  0x4110d8		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x4110e1		e85a130100		CALL runtime.printstring(SB)		
  0x4110e6		488b442410		MOVQ 0x10(SP), AX			
  0x4110eb		48890424		MOVQ AX, 0(SP)				
  0x4110ef		e87c100100		CALL runtime.printuint(SB)		
  0x4110f4		488d0594960500		LEAQ 0x59694(IP), AX			
  0x4110fb		48890424		MOVQ AX, 0(SP)				
  0x4110ff		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x411108		e833130100		CALL runtime.printstring(SB)		
  0x41110d		f20f10442448		MOVSD_XMM 0x48(SP), X0			
  0x411113		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x411118		e8330d0100		CALL runtime.printfloat(SB)		
  0x41111d		488d05fa930500		LEAQ 0x593fa(IP), AX			
  0x411124		48890424		MOVQ AX, 0(SP)				
  0x411128		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x411131		e80a130100		CALL runtime.printstring(SB)		
  0x411136		488b442430		MOVQ 0x30(SP), AX			
  0x41113b		48890424		MOVQ AX, 0(SP)				
  0x41113f		e82c100100		CALL runtime.printuint(SB)		
  0x411144		e8470c0100		CALL runtime.printnl(SB)		
  0x411149		e8320a0100		CALL runtime.printunlock(SB)		
			throw("gc_trigger underflow")
  0x41114e		488d05b49f0500		LEAQ 0x59fb4(IP), AX	
  0x411155		48890424		MOVQ AX, 0(SP)		
  0x411159		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x411162		e869000100		CALL runtime.throw(SB)	
  0x411167		0f0b			UD2			
func gcSetTriggerRatio(triggerRatio float64) {
  0x411169		e802340300		CALL runtime.morestack_noctxt(SB)	
  0x41116e		e9ddfbffff		JMP runtime.gcSetTriggerRatio(SB)	

TEXT runtime.gcStart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcStart(mode gcMode, trigger gcTrigger) {
  0x411180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411189		483b6110		CMPQ 0x10(CX), SP	
  0x41118d		0f8666050000		JBE 0x4116f9		
  0x411193		4883ec28		SUBQ $0x28, SP		
  0x411197		48896c2420		MOVQ BP, 0x20(SP)	
  0x41119c		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x4111a1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x4111aa		488b4830		MOVQ 0x30(AX), CX	
  0x4111ae		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x4111b4		488b4830		MOVQ 0x30(AX), CX	
  0x4111b8		8400			TESTB AL, 0(AX)		
	if gp := getg(); gp == mp.g0 || mp.locks > 1 || mp.preemptoff != "" {
  0x4111ba		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4111c3		488b11			MOVQ 0(CX), DX		
  0x4111c6		4839d0			CMPQ DX, AX		
  0x4111c9		0f84f9040000		JE 0x4116c8		
  0x4111cf		8b9100010000		MOVL 0x100(CX), DX	
  0x4111d5		83fa01			CMPL $0x1, DX		
  0x4111d8		0f8fea040000		JG 0x4116c8		
  0x4111de		488b99f8000000		MOVQ 0xf8(CX), BX	
  0x4111e5		4885db			TESTQ BX, BX		
  0x4111e8		0f85da040000		JNE 0x4116c8		
	mp.locks--
  0x4111ee		8d5aff			LEAL -0x1(DX), BX	
  0x4111f1		899900010000		MOVL BX, 0x100(CX)	
	if gp := getg(); gp == mp.g0 || mp.locks > 1 || mp.preemptoff != "" {
  0x4111f7		83fa01			CMPL $0x1, DX		
	if mp.locks == 0 && _g_.preempt {
  0x4111fa		751b			JNE 0x411217		
  0x4111fc		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x411203		84c9			TESTL CL, CL		
  0x411205		7410			JE 0x411217		
		_g_.stackguard0 = stackPreempt
  0x411207		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x41120f		eb06			JMP 0x411217		
		sweep.nbgsweep++
  0x411211		ff05dd650900		INCL runtime.sweep+20(SB)	
	if !memstats.enablegc || panicking != 0 {
  0x411217		0fb605b2450b00		MOVZX runtime.memstats+4304(SB), AX	
  0x41121e		84c0			TESTL AL, AL				
  0x411220		740e			JE 0x411230				
  0x411222		8b05cc260b00		MOVL runtime.panicking(SB), AX		
  0x411228		85c0			TESTL AX, AX				
  0x41122a		0f84df030000		JE 0x41160f				
  0x411230		31c0			XORL AX, AX				
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x411232		84c0			TESTL AL, AL			
  0x411234		740f			JE 0x411245			
  0x411236		e8356c0000		CALL runtime.gosweepone(SB)	
  0x41123b		488b0424		MOVQ 0(SP), AX			
  0x41123f		4883f8ff		CMPQ $-0x1, AX			
  0x411243		75cc			JNE 0x411211			
	semacquire(&work.startSema)
  0x411245		488d05386c0900		LEAQ runtime.work+228(SB), AX	
  0x41124c		48890424		MOVQ AX, 0(SP)			
  0x411250		e80bed0100		CALL runtime.semacquire(SB)	
	if !memstats.enablegc || panicking != 0 {
  0x411255		0fb60574450b00		MOVZX runtime.memstats+4304(SB), AX	
  0x41125c		84c0			TESTL AL, AL				
  0x41125e		740e			JE 0x41126e				
  0x411260		8b058e260b00		MOVL runtime.panicking(SB), AX		
  0x411266		85c0			TESTL AX, AX				
  0x411268		0f84f0020000		JE 0x41155e				
  0x41126e		31c0			XORL AX, AX				
	if !trigger.test() {
  0x411270		84c0			TESTL AL, AL		
  0x411272		0f84cc020000		JE 0x411544		
  0x411278		488b442438		MOVQ 0x38(SP), AX	
	work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle
  0x41127d		4885c0			TESTQ AX, AX			
  0x411280		0f85b2020000		JNE 0x411538			
  0x411286		b801000000		MOVL $0x1, AX			
  0x41128b		8805176c0900		MOVB AL, runtime.work+264(SB)	
  0x411291		488b442430		MOVQ 0x30(SP), AX		
	if mode == gcBackgroundMode {
  0x411296		4885c0			TESTQ AX, AX		
  0x411299		7514			JNE 0x4112af		
		if debug.gcstoptheworld == 1 {
  0x41129b		8b0d3b280b00		MOVL runtime.debug+28(SB), CX	
  0x4112a1		83f901			CMPL $0x1, CX			
  0x4112a4		0f857b020000		JNE 0x411525			
  0x4112aa		b801000000		MOVL $0x1, AX			
	semacquire(&worldsema)
  0x4112af		4889442430		MOVQ AX, 0x30(SP)		
  0x4112b4		488d0d513d0900		LEAQ runtime.worldsema(SB), CX	
  0x4112bb		48890c24		MOVQ CX, 0(SP)			
  0x4112bf		e89cec0100		CALL runtime.semacquire(SB)	
	if trace.enabled {
  0x4112c4		0fb60505250a00		MOVZX runtime.trace+16(SB), AX	
  0x4112cb		84c0			TESTL AL, AL			
  0x4112cd		0f8548020000		JNE 0x41151b			
  0x4112d3		488b442430		MOVQ 0x30(SP), AX		
	if mode == gcBackgroundMode {
  0x4112d8		4885c0			TESTQ AX, AX		
  0x4112db		0f8430020000		JE 0x411511		
	gcResetMarkState()
  0x4112e1		e8aa1c0000		CALL runtime.gcResetMarkState(SB)	
	work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs
  0x4112e6		8b05f4250b00		MOVL runtime.gomaxprocs(SB), AX	
  0x4112ec		8905fa6b0900		MOVL AX, runtime.work+332(SB)	
  0x4112f2		8905f86b0900		MOVL AX, runtime.work+336(SB)	
	if work.stwprocs > ncpu {
  0x4112f8		8b05ee6b0900		MOVL runtime.work+332(SB), AX	
  0x4112fe		8b0de0250b00		MOVL runtime.ncpu(SB), CX	
  0x411304		39c8			CMPL CX, AX			
  0x411306		7e06			JLE 0x41130e			
		work.stwprocs = ncpu
  0x411308		890dde6b0900		MOVL CX, runtime.work+332(SB)	
	work.heap0 = atomic.Load64(&memstats.heap_live)
  0x41130e		488b052b4b0b00		MOVQ runtime.memstats+5952(SB), AX	
  0x411315		4889050c6c0900		MOVQ AX, runtime.work+392(SB)		
	work.pauseNS = 0
  0x41131c		48c705f16b090000000000	MOVQ $0x0, runtime.work+376(SB)	
  0x411327		488b442430		MOVQ 0x30(SP), AX		
	work.mode = mode
  0x41132c		4889056d6b0900		MOVQ AX, runtime.work+256(SB)	
	now := nanotime()
  0x411333		e8f8660300		CALL runtime.nanotime(SB)	
  0x411338		488b0424		MOVQ 0(SP), AX			
  0x41133c		4889442408		MOVQ AX, 0x8(SP)		
	work.tSweepTerm = now
  0x411341		488905b06b0900		MOVQ AX, runtime.work+344(SB)	
	work.pauseStart = now
  0x411348		488b442408		MOVQ 0x8(SP), AX		
  0x41134d		488905cc6b0900		MOVQ AX, runtime.work+384(SB)	
	if trace.enabled {
  0x411354		0fb60575240a00		MOVZX runtime.trace+16(SB), AX	
  0x41135b		84c0			TESTL AL, AL			
  0x41135d		0f859c010000		JNE 0x4114ff			
	systemstack(stopTheWorldWithSema)
  0x411363		488d059ece0500		LEAQ 0x5ce9e(IP), AX		
  0x41136a		48890424		MOVQ AX, 0(SP)			
  0x41136e		e8ad300300		CALL runtime.systemstack(SB)	
	systemstack(func() {
  0x411373		488d0526cd0500		LEAQ 0x5cd26(IP), AX		
  0x41137a		48890424		MOVQ AX, 0(SP)			
  0x41137e		e89d300300		CALL runtime.systemstack(SB)	
	clearpools()
  0x411383		e8b81c0000		CALL runtime.clearpools(SB)	
	work.cycles++
  0x411388		ff055a6b0900		INCL runtime.work+328(SB)	
  0x41138e		488b442430		MOVQ 0x30(SP), AX		
	if mode == gcBackgroundMode {
  0x411393		4885c0			TESTQ AX, AX		
	if mode == gcBackgroundMode { // Do as much work concurrently as possible
  0x411396		7470			JE 0x411408		
		if trace.enabled {
  0x411398		0fb60531240a00		MOVZX runtime.trace+16(SB), AX	
  0x41139f		84c0			TESTL AL, AL			
  0x4113a1		7551			JNE 0x4113f4			
		t := nanotime()
  0x4113a3		e888660300		CALL runtime.nanotime(SB)	
  0x4113a8		488b0424		MOVQ 0(SP), AX			
		work.tMark, work.tMarkTerm = t, t
  0x4113ac		4889054d6b0900		MOVQ AX, runtime.work+352(SB)	
  0x4113b3		4889054e6b0900		MOVQ AX, runtime.work+360(SB)	
		work.heapGoal = work.heap0
  0x4113ba		488b05676b0900		MOVQ runtime.work+392(SB), AX	
  0x4113c1		488905786b0900		MOVQ AX, runtime.work+416(SB)	
		gcMarkTermination(memstats.triggerRatio)
  0x4113c8		f20f1005604a0b00	MOVSD_XMM runtime.memstats+5936(SB), X0	
  0x4113d0		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x4113d5		e8c6050000		CALL runtime.gcMarkTermination(SB)	
	semrelease(&work.startSema)
  0x4113da		488d05a36a0900		LEAQ runtime.work+228(SB), AX	
  0x4113e1		48890424		MOVQ AX, 0(SP)			
  0x4113e5		e8a6ee0100		CALL runtime.semrelease(SB)	
}
  0x4113ea		488b6c2420		MOVQ 0x20(SP), BP	
  0x4113ef		4883c428		ADDQ $0x28, SP		
  0x4113f3		c3			RET			
			traceGCSTWDone()
  0x4113f4		e827910200		CALL runtime.traceGCSTWDone(SB)	
			traceGCSTWStart(0)
  0x4113f9		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x411401		e8aa900200		CALL runtime.traceGCSTWStart(SB)	
  0x411406		eb9b			JMP 0x4113a3				
		gcController.startCycle()
  0x411408		488d0511280b00		LEAQ runtime.gcController(SB), AX			
  0x41140f		48890424		MOVQ AX, 0(SP)						
  0x411413		e818ebffff		CALL runtime.(*gcControllerState).startCycle(SB)	
		work.heapGoal = memstats.next_gc
  0x411418		488b0589330b00		MOVQ runtime.memstats+168(SB), AX	
  0x41141f		4889051a6b0900		MOVQ AX, runtime.work+416(SB)		
	atomic.Store(&gcphase, x)
  0x411426		b801000000		MOVL $0x1, AX			
  0x41142b		488d0daa240b00		LEAQ runtime.gcphase(SB), CX	
  0x411432		8701			XCHGL AX, 0(CX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x411434		8b05a2240b00		MOVL runtime.gcphase(SB), AX		
  0x41143a		83f801			CMPL $0x1, AX				
  0x41143d		0f85b1000000		JNE 0x4114f4				
  0x411443		b801000000		MOVL $0x1, AX				
  0x411448		8805c6250b00		MOVB AL, runtime.writeBarrier+4(SB)	
  0x41144e		84c0			TESTL AL, AL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x411450		0f8492000000		JE 0x4114e8				
  0x411456		b801000000		MOVL $0x1, AX				
  0x41145b		8805af250b00		MOVB AL, runtime.writeBarrier(SB)	
	work.nproc = ^uint32(0)
  0x411461		c705c5690900ffffffff	MOVL $-0x1, runtime.work+144(SB)	
	work.nwait = ^uint32(0)
  0x41146b		c705cb690900ffffffff	MOVL $-0x1, runtime.work+160(SB)	
		gcMarkRootPrepare()
  0x411475		e846290000		CALL runtime.gcMarkRootPrepare(SB)	
		gcMarkTinyAllocs()
  0x41147a		e891610000		CALL runtime.gcMarkTinyAllocs(SB)	
		atomic.Store(&gcBlackenEnabled, 1)
  0x41147f		b801000000		MOVL $0x1, AX				
  0x411484		488d0d49240b00		LEAQ runtime.gcBlackenEnabled(SB), CX	
  0x41148b		8701			XCHGL AX, 0(CX)				
		gcController.markStartTime = now
  0x41148d		488b442408		MOVQ 0x8(SP), AX			
  0x411492		488905b7270b00		MOVQ AX, runtime.gcController+48(SB)	
		systemstack(func() {
  0x411499		488d05b00a0300		LEAQ runtime.gcStart.func2(SB), AX	
  0x4114a0		4889442410		MOVQ AX, 0x10(SP)			
  0x4114a5		488d442408		LEAQ 0x8(SP), AX			
  0x4114aa		4889442418		MOVQ AX, 0x18(SP)			
  0x4114af		488d442410		LEAQ 0x10(SP), AX			
  0x4114b4		48890424		MOVQ AX, 0(SP)				
  0x4114b8		e8632f0300		CALL runtime.systemstack(SB)		
		work.pauseNS += now - work.pauseStart
  0x4114bd		488b442408		MOVQ 0x8(SP), AX		
  0x4114c2		482b05576a0900		SUBQ runtime.work+384(SB), AX	
  0x4114c9		480305486a0900		ADDQ runtime.work+376(SB), AX	
  0x4114d0		488905416a0900		MOVQ AX, runtime.work+376(SB)	
		work.tMark = now
  0x4114d7		488b442408		MOVQ 0x8(SP), AX		
  0x4114dc		4889051d6a0900		MOVQ AX, runtime.work+352(SB)	
  0x4114e3		e9f2feffff		JMP 0x4113da			
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x4114e8		0fb60526250b00		MOVZX runtime.writeBarrier+5(SB), AX	
  0x4114ef		e967ffffff		JMP 0x41145b				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x4114f4		83f802			CMPL $0x2, AX		
  0x4114f7		0f94c0			SETE AL			
  0x4114fa		e949ffffff		JMP 0x411448		
		traceGCSTWStart(1)
  0x4114ff		48c7042401000000	MOVQ $0x1, 0(SP)			
  0x411507		e8a48f0200		CALL runtime.traceGCSTWStart(SB)	
  0x41150c		e952feffff		JMP 0x411363				
		gcBgMarkStartWorkers()
  0x411511		e8ea0f0000		CALL runtime.gcBgMarkStartWorkers(SB)	
  0x411516		e9c6fdffff		JMP 0x4112e1				
		traceGCStart()
  0x41151b		e8b08e0200		CALL runtime.traceGCStart(SB)	
  0x411520		e9aefdffff		JMP 0x4112d3			
		} else if debug.gcstoptheworld == 2 {
  0x411525		83f902			CMPL $0x2, CX		
  0x411528		0f8581fdffff		JNE 0x4112af		
  0x41152e		b802000000		MOVL $0x2, AX		
	semacquire(&worldsema)
  0x411533		e977fdffff		JMP 0x4112af		
	work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle
  0x411538		4883f803		CMPQ $0x3, AX		
  0x41153c		0f94c0			SETE AL			
  0x41153f		e947fdffff		JMP 0x41128b		
		semrelease(&work.startSema)
  0x411544		488d0539690900		LEAQ runtime.work+228(SB), AX	
  0x41154b		48890424		MOVQ AX, 0(SP)			
  0x41154f		e83ced0100		CALL runtime.semrelease(SB)	
		return
  0x411554		488b6c2420		MOVQ 0x20(SP), BP	
  0x411559		4883c428		ADDQ $0x28, SP		
  0x41155d		c3			RET			
  0x41155e		488b442438		MOVQ 0x38(SP), AX	
	if t.kind == gcTriggerAlways {
  0x411563		4885c0			TESTQ AX, AX		
  0x411566		750a			JNE 0x411572		
  0x411568		b801000000		MOVL $0x1, AX		
	if !trigger.test() {
  0x41156d		e9fefcffff		JMP 0x411270		
	if gcphase != _GCoff {
  0x411572		8b0d64230b00		MOVL runtime.gcphase(SB), CX	
  0x411578		85c9			TESTL CX, CX			
  0x41157a		7407			JE 0x411583			
  0x41157c		31c0			XORL AX, AX			
	if !trigger.test() {
  0x41157e		e9edfcffff		JMP 0x411270		
	case gcTriggerHeap:
  0x411583		4883f801		CMPQ $0x1, AX		
  0x411587		751b			JNE 0x4115a4		
		return memstats.heap_live >= memstats.gc_trigger
  0x411589		488b0db0480b00		MOVQ runtime.memstats+5952(SB), CX	
  0x411590		488b15a1480b00		MOVQ runtime.memstats+5944(SB), DX	
  0x411597		4839d1			CMPQ DX, CX				
  0x41159a		0f93c1			SETAE CL				
  0x41159d		89c8			MOVL CX, AX				
	if !trigger.test() {
  0x41159f		e9ccfcffff		JMP 0x411270		
	case gcTriggerTime:
  0x4115a4		4883f802		CMPQ $0x2, AX		
  0x4115a8		753d			JNE 0x4115e7		
		if gcpercent < 0 {
  0x4115aa		8b0d28230b00		MOVL runtime.gcpercent(SB), CX	
  0x4115b0		85c9			TESTL CX, CX			
  0x4115b2		7d07			JGE 0x4115bb			
  0x4115b4		31c0			XORL AX, AX			
	if !trigger.test() {
  0x4115b6		e9b5fcffff		JMP 0x411270		
		lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
  0x4115bb		488b0d5e480b00		MOVQ runtime.memstats+5920(SB), CX	
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x4115c2		4885c9			TESTQ CX, CX				
  0x4115c5		741c			JE 0x4115e3				
  0x4115c7		488b542440		MOVQ 0x40(SP), DX			
  0x4115cc		4829ca			SUBQ CX, DX				
  0x4115cf		488b0d5a3a0900		MOVQ runtime.forcegcperiod(SB), CX	
  0x4115d6		4839ca			CMPQ CX, DX				
  0x4115d9		0f9fc1			SETG CL					
  0x4115dc		89c8			MOVL CX, AX				
	if !trigger.test() {
  0x4115de		e98dfcffff		JMP 0x411270		
  0x4115e3		31c9			XORL CX, CX		
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x4115e5		ebf5			JMP 0x4115dc		
	case gcTriggerCycle:
  0x4115e7		4883f803		CMPQ $0x3, AX		
  0x4115eb		7518			JNE 0x411605		
		return int32(t.n-work.cycles) > 0
  0x4115ed		8b0df5680900		MOVL runtime.work+328(SB), CX	
  0x4115f3		8b542448		MOVL 0x48(SP), DX		
  0x4115f7		29ca			SUBL CX, DX			
  0x4115f9		85d2			TESTL DX, DX			
  0x4115fb		0f9fc1			SETG CL				
  0x4115fe		89c8			MOVL CX, AX			
	if !trigger.test() {
  0x411600		e96bfcffff		JMP 0x411270		
  0x411605		b801000000		MOVL $0x1, AX		
  0x41160a		e961fcffff		JMP 0x411270		
  0x41160f		488b442438		MOVQ 0x38(SP), AX	
	if t.kind == gcTriggerAlways {
  0x411614		4885c0			TESTQ AX, AX		
  0x411617		750a			JNE 0x411623		
  0x411619		b801000000		MOVL $0x1, AX		
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x41161e		e90ffcffff		JMP 0x411232		
	if gcphase != _GCoff {
  0x411623		8b0db3220b00		MOVL runtime.gcphase(SB), CX	
  0x411629		85c9			TESTL CX, CX			
  0x41162b		7407			JE 0x411634			
  0x41162d		31c0			XORL AX, AX			
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x41162f		e9fefbffff		JMP 0x411232		
	case gcTriggerHeap:
  0x411634		4883f801		CMPQ $0x1, AX		
  0x411638		751b			JNE 0x411655		
		return memstats.heap_live >= memstats.gc_trigger
  0x41163a		488b0dff470b00		MOVQ runtime.memstats+5952(SB), CX	
  0x411641		488b15f0470b00		MOVQ runtime.memstats+5944(SB), DX	
  0x411648		4839d1			CMPQ DX, CX				
  0x41164b		0f93c1			SETAE CL				
  0x41164e		89c8			MOVL CX, AX				
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x411650		e9ddfbffff		JMP 0x411232		
	case gcTriggerTime:
  0x411655		4883f802		CMPQ $0x2, AX		
  0x411659		7545			JNE 0x4116a0		
		if gcpercent < 0 {
  0x41165b		8b0d77220b00		MOVL runtime.gcpercent(SB), CX	
  0x411661		85c9			TESTL CX, CX			
  0x411663		7d07			JGE 0x41166c			
  0x411665		31c0			XORL AX, AX			
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x411667		e9c6fbffff		JMP 0x411232		
		lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
  0x41166c		488b0dad470b00		MOVQ runtime.memstats+5920(SB), CX	
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x411673		4885c9			TESTQ CX, CX				
  0x411676		741f			JE 0x411697				
  0x411678		488b542440		MOVQ 0x40(SP), DX			
  0x41167d		4889d3			MOVQ DX, BX				
  0x411680		4829ca			SUBQ CX, DX				
  0x411683		488b0da6390900		MOVQ runtime.forcegcperiod(SB), CX	
  0x41168a		4839ca			CMPQ CX, DX				
  0x41168d		0f9fc1			SETG CL					
  0x411690		89c8			MOVL CX, AX				
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x411692		e99bfbffff		JMP 0x411232		
  0x411697		488b5c2440		MOVQ 0x40(SP), BX	
  0x41169c		31c9			XORL CX, CX		
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x41169e		ebf0			JMP 0x411690		
	case gcTriggerCycle:
  0x4116a0		4883f803		CMPQ $0x3, AX		
  0x4116a4		7518			JNE 0x4116be		
		return int32(t.n-work.cycles) > 0
  0x4116a6		8b0d3c680900		MOVL runtime.work+328(SB), CX	
  0x4116ac		8b542448		MOVL 0x48(SP), DX		
  0x4116b0		29ca			SUBL CX, DX			
  0x4116b2		85d2			TESTL DX, DX			
  0x4116b4		0f9fc1			SETG CL				
  0x4116b7		89c8			MOVL CX, AX			
	for trigger.test() && gosweepone() != ^uintptr(0) {
  0x4116b9		e974fbffff		JMP 0x411232		
  0x4116be		b801000000		MOVL $0x1, AX		
  0x4116c3		e96afbffff		JMP 0x411232		
	mp.locks--
  0x4116c8		8b9100010000		MOVL 0x100(CX), DX	
  0x4116ce		8d5aff			LEAL -0x1(DX), BX	
  0x4116d1		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x4116d7		83fa01			CMPL $0x1, DX		
  0x4116da		7513			JNE 0x4116ef		
  0x4116dc		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x4116e3		84c9			TESTL CL, CL		
  0x4116e5		7408			JE 0x4116ef		
		_g_.stackguard0 = stackPreempt
  0x4116e7		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
		return
  0x4116ef		488b6c2420		MOVQ 0x20(SP), BP	
  0x4116f4		4883c428		ADDQ $0x28, SP		
  0x4116f8		c3			RET			
func gcStart(mode gcMode, trigger gcTrigger) {
  0x4116f9		e8722e0300		CALL runtime.morestack_noctxt(SB)	
  0x4116fe		e97dfaffff		JMP runtime.gcStart(SB)			

TEXT runtime.gcMarkDone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcMarkDone() {
  0x411710		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411719		483b6110		CMPQ 0x10(CX), SP	
  0x41171d		0f8669020000		JBE 0x41198c		
  0x411723		4883ec20		SUBQ $0x20, SP		
  0x411727		48896c2418		MOVQ BP, 0x18(SP)	
  0x41172c		488d6c2418		LEAQ 0x18(SP), BP	
	semacquire(&work.markDoneSema)
  0x411731		488d0550670900		LEAQ runtime.work+232(SB), AX	
  0x411738		48890424		MOVQ AX, 0(SP)			
  0x41173c		e81fe80100		CALL runtime.semacquire(SB)	
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  0x411741		8b0595210b00		MOVL runtime.gcphase(SB), AX	
  0x411747		83f801			CMPL $0x1, AX			
  0x41174a		0f8511020000		JNE 0x411961			
  0x411750		8b05ea660900		MOVL runtime.work+160(SB), AX	
  0x411756		8b0dd4660900		MOVL runtime.work+144(SB), CX	
  0x41175c		39c8			CMPL CX, AX			
  0x41175e		0f85fd010000		JNE 0x411961			
	return atomic.Load64((*uint64)(head)) == 0
  0x411764		488b0535660900		MOVQ runtime.work(SB), AX	
  0x41176b		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x41176e		0f850e020000		JNE 0x411982		
	if work.markrootNext < work.markrootJobs {
  0x411774		8b05ae660900		MOVL runtime.work+136(SB), AX	
  0x41177a		8b0dac660900		MOVL runtime.work+140(SB), CX	
  0x411780		39c8			CMPL CX, AX			
  0x411782		0f83f3010000		JAE 0x41197b			
  0x411788		b801000000		MOVL $0x1, AX			
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  0x41178d		84c0			TESTL AL, AL		
  0x41178f		0f85cc010000		JNE 0x411961		
	atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, -0xffffffff)
  0x411795		48b801000000ffffffff	MOVQ $0xffffffff00000001, AX		
  0x41179f		488d0db2240b00		LEAQ runtime.gcController+56(SB), CX	
  0x4117a6		f0480fc101		LOCK XADDQ AX, 0(CX)			
	prevFractionalGoal := gcController.fractionalUtilizationGoal
  0x4117ab		f20f1005bd240b00	MOVSD_XMM runtime.gcController+80(SB), X0	
	gcController.fractionalUtilizationGoal = 0
  0x4117b3		0f57c9			XORPS X1, X1					
  0x4117b6		f20f110db2240b00	MOVSD_XMM X1, runtime.gcController+80(SB)	
	if !gcBlackenPromptly {
  0x4117be		0fb605e2200b00		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x4117c5		84c0			TESTL AL, AL				
  0x4117c7		0f85bb000000		JNE 0x411888				
  0x4117cd		f20f11442410		MOVSD_XMM X0, 0x10(SP)			
		gcBlackenPromptly = true
  0x4117d3		c605cd200b0001		MOVB $0x1, runtime.gcBlackenPromptly(SB)	
		atomic.Xadd(&work.nwait, -1)
  0x4117da		b8ffffffff		MOVL $-0x1, AX			
  0x4117df		488d0d5a660900		LEAQ runtime.work+160(SB), CX	
  0x4117e6		f00fc101		LOCK XADDL AX, 0(CX)		
		semrelease(&work.markDoneSema)
  0x4117ea		488d0597660900		LEAQ runtime.work+232(SB), AX	
  0x4117f1		48890424		MOVQ AX, 0(SP)			
  0x4117f5		e896ea0100		CALL runtime.semrelease(SB)	
		systemstack(func() {
  0x4117fa		488d058fc80500		LEAQ 0x5c88f(IP), AX		
  0x411801		48890424		MOVQ AX, 0(SP)			
  0x411805		e8162c0300		CALL runtime.systemstack(SB)	
		gcMarkRootCheck()
  0x41180a		e851270000		CALL runtime.gcMarkRootCheck(SB)	
		atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 0xffffffff)
  0x41180f		b8ffffffff		MOVL $-0x1, AX				
  0x411814		488d0d3d240b00		LEAQ runtime.gcController+56(SB), CX	
  0x41181b		f0480fc101		LOCK XADDQ AX, 0(CX)			
  0x411820		f20f10442410		MOVSD_XMM 0x10(SP), X0			
		gcController.fractionalUtilizationGoal = prevFractionalGoal
  0x411826		f20f110542240b00	MOVSD_XMM X0, runtime.gcController+80(SB)	
		incnwait := atomic.Xadd(&work.nwait, +1)
  0x41182e		b801000000		MOVL $0x1, AX			
  0x411833		488d0d06660900		LEAQ runtime.work+160(SB), CX	
  0x41183a		f00fc101		LOCK XADDL AX, 0(CX)		
  0x41183e		ffc0			INCL AX				
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x411840		8b0dea650900		MOVL runtime.work+144(SB), CX	
  0x411846		39c1			CMPL AX, CX			
  0x411848		7529			JNE 0x411873			
	return atomic.Load64((*uint64)(head)) == 0
  0x41184a		488b054f650900		MOVQ runtime.work(SB), AX	
  0x411851		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x411854		752b			JNE 0x411881		
	if work.markrootNext < work.markrootJobs {
  0x411856		8b05cc650900		MOVL runtime.work+136(SB), AX	
  0x41185c		8b0dca650900		MOVL runtime.work+140(SB), CX	
  0x411862		39c8			CMPL CX, AX			
  0x411864		7317			JAE 0x41187d			
  0x411866		b801000000		MOVL $0x1, AX			
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x41186b		84c0			TESTL AL, AL		
  0x41186d		0f84befeffff		JE 0x411731		
  0x411873		488b6c2418		MOVQ 0x18(SP), BP	
  0x411878		4883c420		ADDQ $0x20, SP		
  0x41187c		c3			RET			
  0x41187d		31c0			XORL AX, AX		
  0x41187f		ebea			JMP 0x41186b		
  0x411881		b801000000		MOVL $0x1, AX		
  0x411886		ebe3			JMP 0x41186b		
		now := nanotime()
  0x411888		e8a3610300		CALL runtime.nanotime(SB)	
  0x41188d		488b0424		MOVQ 0(SP), AX			
		work.tMarkTerm = now
  0x411891		48890570660900		MOVQ AX, runtime.work+360(SB)	
		work.pauseStart = now
  0x411898		48890581660900		MOVQ AX, runtime.work+384(SB)	
		getg().m.preemptoff = "gcing"
  0x41189f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x4118a8		488b4030		MOVQ 0x30(AX), AX			
  0x4118ac		48c780f800000005000000	MOVQ $0x5, 0xf8(AX)			
  0x4118b7		8b0d53210b00		MOVL runtime.writeBarrier(SB), CX	
  0x4118bd		488db8f0000000		LEAQ 0xf0(AX), DI			
  0x4118c4		85c9			TESTL CX, CX				
  0x4118c6		0f8584000000		JNE 0x411950				
  0x4118cc		488d0dfe840500		LEAQ 0x584fe(IP), CX			
  0x4118d3		488988f0000000		MOVQ CX, 0xf0(AX)			
		if trace.enabled {
  0x4118da		0fb605ef1e0a00		MOVZX runtime.trace+16(SB), AX	
  0x4118e1		84c0			TESTL AL, AL			
  0x4118e3		755c			JNE 0x411941			
		systemstack(stopTheWorldWithSema)
  0x4118e5		488d051cc90500		LEAQ 0x5c91c(IP), AX		
  0x4118ec		48890424		MOVQ AX, 0(SP)			
  0x4118f0		e82b2b0300		CALL runtime.systemstack(SB)	
		work.markrootDone = true
  0x4118f5		c6058465090001		MOVB $0x1, runtime.work+224(SB)	
		atomic.Store(&gcBlackenEnabled, 0)
  0x4118fc		31c0			XORL AX, AX				
  0x4118fe		488d0dcf1f0b00		LEAQ runtime.gcBlackenEnabled(SB), CX	
  0x411905		8701			XCHGL AX, 0(CX)				
		gcWakeAllAssists()
  0x411907		e8c4360000		CALL runtime.gcWakeAllAssists(SB)	
		semrelease(&work.markDoneSema)
  0x41190c		488d0575650900		LEAQ runtime.work+232(SB), AX	
  0x411913		48890424		MOVQ AX, 0(SP)			
  0x411917		e874e90100		CALL runtime.semrelease(SB)	
		nextTriggerRatio := gcController.endCycle()
  0x41191c		488d05fd220b00		LEAQ runtime.gcController(SB), AX		
  0x411923		48890424		MOVQ AX, 0(SP)					
  0x411927		e8a4eaffff		CALL runtime.(*gcControllerState).endCycle(SB)	
  0x41192c		f20f10442408		MOVSD_XMM 0x8(SP), X0				
		gcMarkTermination(nextTriggerRatio)
  0x411932		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x411937		e864000000		CALL runtime.gcMarkTermination(SB)	
  0x41193c		e932ffffff		JMP 0x411873				
			traceGCSTWStart(0)
  0x411941		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x411949		e8628b0200		CALL runtime.traceGCSTWStart(SB)	
  0x41194e		eb95			JMP 0x4118e5				
		getg().m.preemptoff = "gcing"
  0x411950		488d057a840500		LEAQ 0x5847a(IP), AX		
  0x411957		e8444f0300		CALL runtime.gcWriteBarrier(SB)	
  0x41195c		e979ffffff		JMP 0x4118da			
		semrelease(&work.markDoneSema)
  0x411961		488d0520650900		LEAQ runtime.work+232(SB), AX	
  0x411968		48890424		MOVQ AX, 0(SP)			
  0x41196c		e81fe90100		CALL runtime.semrelease(SB)	
		return
  0x411971		488b6c2418		MOVQ 0x18(SP), BP	
  0x411976		4883c420		ADDQ $0x20, SP		
  0x41197a		c3			RET			
  0x41197b		31c0			XORL AX, AX		
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  0x41197d		e90bfeffff		JMP 0x41178d		
  0x411982		b801000000		MOVL $0x1, AX		
  0x411987		e901feffff		JMP 0x41178d		
func gcMarkDone() {
  0x41198c		e8df2b0300		CALL runtime.morestack_noctxt(SB)	
  0x411991		e97afdffff		JMP runtime.gcMarkDone(SB)		

TEXT runtime.gcMarkTermination(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcMarkTermination(nextTriggerRatio float64) {
  0x4119a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4119a9		488d8424b8feffff	LEAQ 0xfffffeb8(SP), AX	
  0x4119b1		483b4110		CMPQ 0x10(CX), AX	
  0x4119b5		0f86300b0000		JBE 0x4124eb		
  0x4119bb		4881ecc8010000		SUBQ $0x1c8, SP		
  0x4119c2		4889ac24c0010000	MOVQ BP, 0x1c0(SP)	
  0x4119ca		488dac24c0010000	LEAQ 0x1c0(SP), BP	
	atomic.Store(&gcBlackenEnabled, 0)
  0x4119d2		31c0			XORL AX, AX				
  0x4119d4		488d0df91e0b00		LEAQ runtime.gcBlackenEnabled(SB), CX	
  0x4119db		8701			XCHGL AX, 0(CX)				
	gcBlackenPromptly = false
  0x4119dd		c605c31e0b0000		MOVB $0x0, runtime.gcBlackenPromptly(SB)	
	atomic.Store(&gcphase, x)
  0x4119e4		b802000000		MOVL $0x2, AX			
  0x4119e9		488d0dec1e0b00		LEAQ runtime.gcphase(SB), CX	
  0x4119f0		8701			XCHGL AX, 0(CX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x4119f2		8b05e41e0b00		MOVL runtime.gcphase(SB), AX		
  0x4119f8		83f801			CMPL $0x1, AX				
  0x4119fb		0f85c40a0000		JNE 0x4124c5				
  0x411a01		b801000000		MOVL $0x1, AX				
  0x411a06		880508200b00		MOVB AL, runtime.writeBarrier+4(SB)	
  0x411a0c		84c0			TESTL AL, AL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x411a0e		0f84a50a0000		JE 0x4124b9				
  0x411a14		b801000000		MOVL $0x1, AX				
  0x411a19		8805f11f0b00		MOVB AL, runtime.writeBarrier(SB)	
	work.heap1 = memstats.heap_live
  0x411a1f		488b051a440b00		MOVQ runtime.memstats+5952(SB), AX	
  0x411a26		48890503650900		MOVQ AX, runtime.work+400(SB)		
	startTime := nanotime()
  0x411a2d		e8fe5f0300		CALL runtime.nanotime(SB)	
  0x411a32		488b0424		MOVQ 0(SP), AX			
  0x411a36		4889442448		MOVQ AX, 0x48(SP)		
	_g_ := getg()
  0x411a3b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x411a44		488b4830		MOVQ 0x30(AX), CX	
  0x411a48		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x411a4e		488b4830		MOVQ 0x30(AX), CX	
  0x411a52		48898c2478010000	MOVQ CX, 0x178(SP)	
  0x411a5a		8400			TESTB AL, 0(AX)		
	mp.preemptoff = "gcing"
  0x411a5c		48c781f800000005000000	MOVQ $0x5, 0xf8(CX)			
  0x411a67		8b05a31f0b00		MOVL runtime.writeBarrier(SB), AX	
  0x411a6d		488db9f0000000		LEAQ 0xf0(CX), DI			
  0x411a74		4889bc2498010000	MOVQ DI, 0x198(SP)			
  0x411a7c		85c0			TESTL AX, AX				
  0x411a7e		0f85240a0000		JNE 0x4124a8				
  0x411a84		488d0546830500		LEAQ 0x58346(IP), AX			
  0x411a8b		488981f0000000		MOVQ AX, 0xf0(CX)			
	_g_ := getg()
  0x411a92		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x411a9b		4889842488010000	MOVQ AX, 0x188(SP)	
	_g_.m.traceback = 2
  0x411aa3		488b4830		MOVQ 0x30(AX), CX	
  0x411aa7		c6812901000002		MOVB $0x2, 0x129(CX)	
	gp := _g_.m.curg
  0x411aae		488b4830		MOVQ 0x30(AX), CX	
  0x411ab2		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x411ab9		48898c2480010000	MOVQ CX, 0x180(SP)	
	casgstatus(gp, _Grunning, _Gwaiting)
  0x411ac1		48890c24		MOVQ CX, 0(SP)			
  0x411ac5		48ba0200000004000000	MOVQ $0x400000002, DX		
  0x411acf		4889542408		MOVQ DX, 0x8(SP)		
  0x411ad4		e8a72f0100		CALL runtime.casgstatus(SB)	
  0x411ad9		488b842480010000	MOVQ 0x180(SP), AX		
	gp.waitreason = "garbage collection"
  0x411ae1		48c780b000000012000000	MOVQ $0x12, 0xb0(AX)			
  0x411aec		8b0d1e1f0b00		MOVL runtime.writeBarrier(SB), CX	
  0x411af2		488db8a8000000		LEAQ 0xa8(AX), DI			
  0x411af9		85c9			TESTL CX, CX				
  0x411afb		0f8596090000		JNE 0x412497				
  0x411b01		488d0d9d920500		LEAQ 0x5929d(IP), CX			
  0x411b08		488988a8000000		MOVQ CX, 0xa8(AX)			
	systemstack(func() {
  0x411b0f		488d053a050300		LEAQ runtime.gcMarkTermination.func1(SB), AX	
  0x411b16		48898424b0010000	MOVQ AX, 0x1b0(SP)				
  0x411b1e		488d442448		LEAQ 0x48(SP), AX				
  0x411b23		48898424b8010000	MOVQ AX, 0x1b8(SP)				
  0x411b2b		488d8c24b0010000	LEAQ 0x1b0(SP), CX				
  0x411b33		48890c24		MOVQ CX, 0(SP)					
  0x411b37		e8e4280300		CALL runtime.systemstack(SB)			
	systemstack(func() {
  0x411b3c		488d054d050300		LEAQ runtime.gcMarkTermination.func2(SB), AX	
  0x411b43		48898424a0010000	MOVQ AX, 0x1a0(SP)				
  0x411b4b		488d442448		LEAQ 0x48(SP), AX				
  0x411b50		48898424a8010000	MOVQ AX, 0x1a8(SP)				
  0x411b58		488d8424a0010000	LEAQ 0x1a0(SP), AX				
  0x411b60		48890424		MOVQ AX, 0(SP)					
  0x411b64		e8b7280300		CALL runtime.systemstack(SB)			
func gcMarkTermination(nextTriggerRatio float64) {
  0x411b69		488b842488010000	MOVQ 0x188(SP), AX	
	_g_.m.traceback = 0
  0x411b71		488b4030		MOVQ 0x30(AX), AX	
  0x411b75		c6802901000000		MOVB $0x0, 0x129(AX)	
  0x411b7c		488b842480010000	MOVQ 0x180(SP), AX	
	casgstatus(gp, _Gwaiting, _Grunning)
  0x411b84		48890424		MOVQ AX, 0(SP)			
  0x411b88		48b80400000002000000	MOVQ $0x200000004, AX		
  0x411b92		4889442408		MOVQ AX, 0x8(SP)		
  0x411b97		e8e42e0100		CALL runtime.casgstatus(SB)	
	if trace.enabled {
  0x411b9c		0fb6052d1c0a00		MOVZX runtime.trace+16(SB), AX	
  0x411ba3		84c0			TESTL AL, AL			
  0x411ba5		0f85e2080000		JNE 0x41248d			
  0x411bab		488b8c2478010000	MOVQ 0x178(SP), CX		
	mp.preemptoff = ""
  0x411bb3		48c781f800000000000000	MOVQ $0x0, 0xf8(CX)			
  0x411bbe		8b154c1e0b00		MOVL runtime.writeBarrier(SB), DX	
  0x411bc4		85d2			TESTL DX, DX				
  0x411bc6		0f85ad080000		JNE 0x412479				
  0x411bcc		48c781f000000000000000	MOVQ $0x0, 0xf0(CX)			
	if gcphase != _GCoff {
  0x411bd7		8b05ff1c0b00		MOVL runtime.gcphase(SB), AX	
  0x411bdd		85c0			TESTL AX, AX			
  0x411bdf		0f85eb080000		JNE 0x4124d0			
  0x411be5		f20f108424d0010000	MOVSD_XMM 0x1d0(SP), X0		
	gcSetTriggerRatio(nextTriggerRatio)
  0x411bee		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x411bf3		e858f1ffff		CALL runtime.gcSetTriggerRatio(SB)	
	now := nanotime()
  0x411bf8		e8335e0300		CALL runtime.nanotime(SB)	
  0x411bfd		488b0424		MOVQ 0(SP), AX			
  0x411c01		4889442468		MOVQ AX, 0x68(SP)		
	sec, nsec, _ := time_now()
  0x411c06		e8d5770200		CALL time.now(SB)	
  0x411c0b		488b0424		MOVQ 0(SP), AX		
	unixNow := sec*1e9 + int64(nsec)
  0x411c0f		48634c2408		MOVSXD 0x8(SP), CX	
	work.pauseNS += now - work.pauseStart
  0x411c14		488b1505630900		MOVQ runtime.work+384(SB), DX	
  0x411c1b		488b5c2468		MOVQ 0x68(SP), BX		
  0x411c20		4889de			MOVQ BX, SI			
  0x411c23		4829d3			SUBQ DX, BX			
  0x411c26		48031deb620900		ADDQ runtime.work+376(SB), BX	
  0x411c2d		48891de4620900		MOVQ BX, runtime.work+376(SB)	
	work.tEnd = now
  0x411c34		488935d5620900		MOVQ SI, runtime.work+368(SB)	
	unixNow := sec*1e9 + int64(nsec)
  0x411c3b		4869c000ca9a3b		IMULQ $0x3b9aca00, AX, AX	
  0x411c42		4801c8			ADDQ CX, AX			
	atomic.Store64(&memstats.last_gc_unix, uint64(unixNow)) // must be Unix time to make sense to user
  0x411c45		488d0d642b0b00		LEAQ runtime.memstats+176(SB), CX	
  0x411c4c		4889c2			MOVQ AX, DX				
  0x411c4f		488701			XCHGQ AX, 0(CX)				
	atomic.Store64(&memstats.last_gc_nanotime, uint64(now)) // monotonic time for us
  0x411c52		488d05c7410b00		LEAQ runtime.memstats+5920(SB), AX	
  0x411c59		4889f1			MOVQ SI, CX				
  0x411c5c		488730			XCHGQ SI, 0(AX)				
	memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS)
  0x411c5f		0fb6055a3b0b00		MOVZX runtime.memstats+4288(SB), AX	
  0x411c66		488b1dab620900		MOVQ runtime.work+376(SB), BX		
  0x411c6d		488d354c2b0b00		LEAQ runtime.memstats+192(SB), SI	
  0x411c74		48891cc6		MOVQ BX, 0(SI)(AX*8)			
	memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)
  0x411c78		0fb605413b0b00		MOVZX runtime.memstats+4288(SB), AX	
  0x411c7f		488d1d3a330b00		LEAQ runtime.memstats+2240(SB), BX	
  0x411c86		488914c3		MOVQ DX, 0(BX)(AX*8)			
	memstats.pause_total_ns += uint64(work.pauseNS)
  0x411c8a		488b05272b0b00		MOVQ runtime.memstats+184(SB), AX	
  0x411c91		48030580620900		ADDQ runtime.work+376(SB), AX		
  0x411c98		488905192b0b00		MOVQ AX, runtime.memstats+184(SB)	
	sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)
  0x411c9f		48630546620900		MOVSXD runtime.work+332(SB), AX	
  0x411ca6		488b1553620900		MOVQ runtime.work+352(SB), DX	
  0x411cad		482b1544620900		SUBQ runtime.work+344(SB), DX	
  0x411cb4		480fafd0		IMULQ AX, DX			
  0x411cb8		4889542440		MOVQ DX, 0x40(SP)		
	markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime
  0x411cbd		488b1d741f0b00		MOVQ runtime.gcController+24(SB), BX	
  0x411cc4		48031d651f0b00		ADDQ runtime.gcController+16(SB), BX	
  0x411ccb		48031d6e1f0b00		ADDQ runtime.gcController+32(SB), BX	
	markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm)
  0x411cd2		488b3537620900		MOVQ runtime.work+368(SB), SI	
  0x411cd9		482b3528620900		SUBQ runtime.work+360(SB), SI	
  0x411ce0		480fafc6		IMULQ SI, AX			
  0x411ce4		4889442470		MOVQ AX, 0x70(SP)		
	cycleCpu := sweepTermCpu + markCpu + markTermCpu
  0x411ce9		4801d3			ADDQ DX, BX		
  0x411cec		4801c3			ADDQ AX, BX		
	work.totaltime += cycleCpu
  0x411cef		48031dba610900		ADDQ runtime.work+272(SB), BX	
  0x411cf6		48891db3610900		MOVQ BX, runtime.work+272(SB)	
	totalCpu := sched.totaltime + (now-sched.procresizetime)*int64(gomaxprocs)
  0x411cfd		488b35345d0900		MOVQ runtime.sched+280(SB), SI		
  0x411d04		4829f1			SUBQ SI, CX				
  0x411d07		486335d21b0b00		MOVSXD runtime.gomaxprocs(SB), SI	
  0x411d0e		480faff1		IMULQ CX, SI				
  0x411d12		480335275d0900		ADDQ runtime.sched+288(SB), SI		
	memstats.gc_cpu_fraction = float64(work.totaltime) / float64(totalCpu)
  0x411d19		0f57c0			XORPS X0, X0				
  0x411d1c		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x411d21		0f57c9			XORPS X1, X1				
  0x411d24		f2480f2ace		CVTSI2SDQ SI, X1			
  0x411d29		f20f5ec1		DIVSD X1, X0				
  0x411d2d		f20f1105933a0b00	MOVSD_XMM X0, runtime.memstats+4296(SB)	
	sweep.npausesweep = 0
  0x411d35		48c705b45a090000000000	MOVQ $0x0, runtime.sweep+20(SB)	
	if work.userForced {
  0x411d40		0fb60d61610900		MOVZX runtime.work+264(SB), CX	
  0x411d47		84c9			TESTL CL, CL			
  0x411d49		7406			JE 0x411d51			
		memstats.numforcedgc++
  0x411d4b		ff05733a0b00		INCL runtime.memstats+4292(SB)	
	lock(&work.sweepWaiters.lock)
  0x411d51		488d0580610900		LEAQ runtime.work+312(SB), AX	
  0x411d58		48890424		MOVQ AX, 0(SP)			
  0x411d5c		e8bf77ffff		CALL runtime.lock(SB)		
	memstats.numgc++
  0x411d61		ff05593a0b00		INCL runtime.memstats+4288(SB)	
	injectglist(work.sweepWaiters.head.ptr())
  0x411d67		488b0572610900		MOVQ runtime.work+320(SB), AX	
  0x411d6e		48890424		MOVQ AX, 0(SP)			
  0x411d72		e8f9690100		CALL runtime.injectglist(SB)	
	work.sweepWaiters.head = 0
  0x411d77		48c7055e61090000000000	MOVQ $0x0, runtime.work+320(SB)	
	unlock(&work.sweepWaiters.lock)
  0x411d82		488d054f610900		LEAQ runtime.work+312(SB), AX	
  0x411d89		48890424		MOVQ AX, 0(SP)			
  0x411d8d		e82e79ffff		CALL runtime.unlock(SB)		
	mProf_NextCycle()
  0x411d92		e819b60000		CALL runtime.mProf_NextCycle(SB)	
	systemstack(func() { startTheWorldWithSema(true) })
  0x411d97		488d05fac20500		LEAQ 0x5c2fa(IP), AX		
  0x411d9e		48890424		MOVQ AX, 0(SP)			
  0x411da2		e879260300		CALL runtime.systemstack(SB)	
	mProf_Flush()
  0x411da7		e884b60000		CALL runtime.mProf_Flush(SB)	
	prepareFreeWorkbufs()
  0x411dac		e83f7e0000		CALL runtime.prepareFreeWorkbufs(SB)	
	systemstack(freeStackSpans)
  0x411db1		488d05b8c20500		LEAQ 0x5c2b8(IP), AX		
  0x411db8		48890424		MOVQ AX, 0(SP)			
  0x411dbc		e85f260300		CALL runtime.systemstack(SB)	
	if debug.gctrace > 0 {
  0x411dc1		8b05191d0b00		MOVL runtime.debug+32(SB), AX	
  0x411dc7		85c0			TESTL AX, AX			
  0x411dc9		0f8e2a060000		JLE 0x4123f9			
		util := int(memstats.gc_cpu_fraction * 100)
  0x411dcf		f20f1005312d0600	MOVSD_XMM $f64.4059000000000000(SB), X0	
  0x411dd7		f20f5905e9390b00	MULSD runtime.memstats+4296(SB), X0	
  0x411ddf		f20f118424b8000000	MOVSD_XMM X0, 0xb8(SP)			
		var sbuf [24]byte
  0x411de8		48c78424c000000000000000	MOVQ $0x0, 0xc0(SP)	
  0x411df4		0f57c9				XORPS X1, X1		
  0x411df7		0f118c24c8000000		MOVUPS X1, 0xc8(SP)	
		printlock()
  0x411dff		e8fcfc0000		CALL runtime.printlock(SB)	
			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",
  0x411e04		488b05ed600900		MOVQ runtime.work+344(SB), AX		
  0x411e0b		482b05ae1b0b00		SUBQ runtime.runtimeInitTime(SB), AX	
  0x411e12		4889c1			MOVQ AX, CX				
  0x411e15		48b8b6696caf05bd3786	MOVQ $0x8637bd05af6c69b6, AX		
  0x411e1f		48f7e1			MULQ CX					
  0x411e22		48c1ea13		SHRQ $0x13, DX				
  0x411e26		4889542418		MOVQ DX, 0x18(SP)			
  0x411e2b		488d8424c0000000	LEAQ 0xc0(SP), AX			
  0x411e33		48890424		MOVQ AX, 0(SP)				
  0x411e37		48c744240818000000	MOVQ $0x18, 0x8(SP)			
  0x411e40		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x411e49		48c744242003000000	MOVQ $0x3, 0x20(SP)			
  0x411e52		e8f9140000		CALL runtime.itoaDiv(SB)		
		print("gc ", memstats.numgc,
  0x411e57		8b0563390b00		MOVL runtime.memstats+4288(SB), AX	
  0x411e5d		48898424b0000000	MOVQ AX, 0xb0(SP)			
			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",
  0x411e65		488b4c2438		MOVQ 0x38(SP), CX			
  0x411e6a		488b542430		MOVQ 0x30(SP), DX			
  0x411e6f		488b5c2428		MOVQ 0x28(SP), BX			
  0x411e74		488db42430010000	LEAQ 0x130(SP), SI			
  0x411e7c		48893424		MOVQ SI, 0(SP)				
  0x411e80		48895c2408		MOVQ BX, 0x8(SP)			
  0x411e85		4889542410		MOVQ DX, 0x10(SP)			
  0x411e8a		48894c2418		MOVQ CX, 0x18(SP)			
  0x411e8f		e83c520200		CALL runtime.slicebytetostring(SB)	
  0x411e94		488b442428		MOVQ 0x28(SP), AX			
  0x411e99		48898424a8000000	MOVQ AX, 0xa8(SP)			
  0x411ea1		488b4c2420		MOVQ 0x20(SP), CX			
  0x411ea6		48898c2490010000	MOVQ CX, 0x190(SP)			
		print("gc ", memstats.numgc,
  0x411eae		e84dfc0000		CALL runtime.printlock(SB)	
  0x411eb3		488d05f17d0500		LEAQ 0x57df1(IP), AX		
  0x411eba		48890424		MOVQ AX, 0(SP)			
  0x411ebe		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x411ec7		e874050100		CALL runtime.printstring(SB)	
  0x411ecc		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x411ed4		48890424		MOVQ AX, 0(SP)			
  0x411ed8		e893020100		CALL runtime.printuint(SB)	
  0x411edd		488d057e7d0500		LEAQ 0x57d7e(IP), AX		
  0x411ee4		48890424		MOVQ AX, 0(SP)			
  0x411ee8		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x411ef1		e84a050100		CALL runtime.printstring(SB)	
  0x411ef6		488b842490010000	MOVQ 0x190(SP), AX		
  0x411efe		48890424		MOVQ AX, 0(SP)			
  0x411f02		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x411f0a		4889442408		MOVQ AX, 0x8(SP)		
  0x411f0f		e82c050100		CALL runtime.printstring(SB)	
  0x411f14		488d055f7d0500		LEAQ 0x57d5f(IP), AX		
  0x411f1b		48890424		MOVQ AX, 0(SP)			
  0x411f1f		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x411f28		e813050100		CALL runtime.printstring(SB)	
  0x411f2d		f20f108424b8000000	MOVSD_XMM 0xb8(SP), X0		
		util := int(memstats.gc_cpu_fraction * 100)
  0x411f36		f2480f2cc0		CVTTSD2SIQ X0, AX	
		print("gc ", memstats.numgc,
  0x411f3b		48890424		MOVQ AX, 0(SP)			
  0x411f3f		e83c030100		CALL runtime.printint(SB)	
  0x411f44		488d054e7d0500		LEAQ 0x57d4e(IP), AX		
  0x411f4b		48890424		MOVQ AX, 0(SP)			
  0x411f4f		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x411f58		e8e3040100		CALL runtime.printstring(SB)	
  0x411f5d		e81efc0000		CALL runtime.printunlock(SB)	
		prev := work.tSweepTerm
  0x411f62		488b058f5f0900		MOVQ runtime.work+344(SB), AX	
		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {
  0x411f69		48c78424d800000000000000	MOVQ $0x0, 0xd8(SP)		
  0x411f75		0f57c0				XORPS X0, X0			
  0x411f78		0f118424e0000000		MOVUPS X0, 0xe0(SP)		
  0x411f80		488b0d795f0900			MOVQ runtime.work+352(SB), CX	
  0x411f87		48898c24d8000000		MOVQ CX, 0xd8(SP)		
  0x411f8f		488b0d725f0900			MOVQ runtime.work+360(SB), CX	
  0x411f96		48898c24e0000000		MOVQ CX, 0xe0(SP)		
  0x411f9e		488b0d6b5f0900			MOVQ runtime.work+368(SB), CX	
  0x411fa5		48898c24e8000000		MOVQ CX, 0xe8(SP)		
  0x411fad		31c9				XORL CX, CX			
  0x411faf		e9ad000000			JMP 0x412061			
			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))
  0x411fb4		488d8c24c0000000	LEAQ 0xc0(SP), CX			
  0x411fbc		48890c24		MOVQ CX, 0(SP)				
  0x411fc0		48c744240818000000	MOVQ $0x18, 0x8(SP)			
  0x411fc9		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x411fd2		4829c2			SUBQ AX, DX				
  0x411fd5		4889542418		MOVQ DX, 0x18(SP)			
  0x411fda		e851140000		CALL runtime.fmtNSAsMS(SB)		
  0x411fdf		488b442420		MOVQ 0x20(SP), AX			
  0x411fe4		488b4c2428		MOVQ 0x28(SP), CX			
  0x411fe9		488b542430		MOVQ 0x30(SP), DX			
  0x411fee		488d9c2410010000	LEAQ 0x110(SP), BX			
  0x411ff6		48891c24		MOVQ BX, 0(SP)				
  0x411ffa		4889442408		MOVQ AX, 0x8(SP)			
  0x411fff		48894c2410		MOVQ CX, 0x10(SP)			
  0x412004		4889542418		MOVQ DX, 0x18(SP)			
  0x412009		e8c2500200		CALL runtime.slicebytetostring(SB)	
  0x41200e		488b442420		MOVQ 0x20(SP), AX			
  0x412013		4889842490010000	MOVQ AX, 0x190(SP)			
  0x41201b		488b4c2428		MOVQ 0x28(SP), CX			
  0x412020		48898c24a8000000	MOVQ CX, 0xa8(SP)			
  0x412028		e8d3fa0000		CALL runtime.printlock(SB)		
  0x41202d		488b842490010000	MOVQ 0x190(SP), AX			
  0x412035		48890424		MOVQ AX, 0(SP)				
  0x412039		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x412041		4889442408		MOVQ AX, 0x8(SP)			
  0x412046		e8f5030100		CALL runtime.printstring(SB)		
  0x41204b		e830fb0000		CALL runtime.printunlock(SB)		
  0x412050		488b442478		MOVQ 0x78(SP), AX			
		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {
  0x412055		488d4801		LEAQ 0x1(AX), CX	
  0x412059		0f57c0			XORPS X0, X0		
  0x41205c		488b442458		MOVQ 0x58(SP), AX	
  0x412061		4883f903		CMPQ $0x3, CX		
  0x412065		7d52			JGE 0x4120b9		
  0x412067		48894c2478		MOVQ CX, 0x78(SP)	
  0x41206c		488b94ccd8000000	MOVQ 0xd8(SP)(CX*8), DX	
  0x412074		4889542458		MOVQ DX, 0x58(SP)	
			if i != 0 {
  0x412079		4885c9			TESTQ CX, CX		
  0x41207c		0f8432ffffff		JE 0x411fb4		
  0x412082		4889442450		MOVQ AX, 0x50(SP)	
				print("+")
  0x412087		e874fa0000		CALL runtime.printlock(SB)	
  0x41208c		488d05c07b0500		LEAQ 0x57bc0(IP), AX		
  0x412093		48890424		MOVQ AX, 0(SP)			
  0x412097		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4120a0		e89b030100		CALL runtime.printstring(SB)	
  0x4120a5		e8d6fa0000		CALL runtime.printunlock(SB)	
  0x4120aa		488b442450		MOVQ 0x50(SP), AX		
  0x4120af		488b542458		MOVQ 0x58(SP), DX		
  0x4120b4		e9fbfeffff		JMP 0x411fb4			
		print(" ms clock, ")
  0x4120b9		e842fa0000		CALL runtime.printlock(SB)	
  0x4120be		488d0536830500		LEAQ 0x58336(IP), AX		
  0x4120c5		48890424		MOVQ AX, 0(SP)			
  0x4120c9		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x4120d2		e869030100		CALL runtime.printstring(SB)	
  0x4120d7		e8a4fa0000		CALL runtime.printunlock(SB)	
		for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {
  0x4120dc		48c784245001000000000000	MOVQ $0x0, 0x150(SP)			
  0x4120e8		0f57c0				XORPS X0, X0				
  0x4120eb		0f11842458010000		MOVUPS X0, 0x158(SP)			
  0x4120f3		0f11842468010000		MOVUPS X0, 0x168(SP)			
  0x4120fb		488b442440			MOVQ 0x40(SP), AX			
  0x412100		4889842450010000		MOVQ AX, 0x150(SP)			
  0x412108		488b05211b0b00			MOVQ runtime.gcController+16(SB), AX	
  0x41210f		4889842458010000		MOVQ AX, 0x158(SP)			
  0x412117		488b05221b0b00			MOVQ runtime.gcController+32(SB), AX	
  0x41211e		480305131b0b00			ADDQ runtime.gcController+24(SB), AX	
  0x412125		4889842460010000		MOVQ AX, 0x160(SP)			
  0x41212d		488b05141b0b00			MOVQ runtime.gcController+40(SB), AX	
  0x412134		4889842468010000		MOVQ AX, 0x168(SP)			
  0x41213c		488b442470			MOVQ 0x70(SP), AX			
  0x412141		4889842470010000		MOVQ AX, 0x170(SP)			
  0x412149		31c0				XORL AX, AX				
  0x41214b		e9a9000000			JMP 0x4121f9				
			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))
  0x412150		488d8424c0000000	LEAQ 0xc0(SP), AX			
  0x412158		48890424		MOVQ AX, 0(SP)				
  0x41215c		48c744240818000000	MOVQ $0x18, 0x8(SP)			
  0x412165		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x41216e		488b4c2460		MOVQ 0x60(SP), CX			
  0x412173		48894c2418		MOVQ CX, 0x18(SP)			
  0x412178		e8b3120000		CALL runtime.fmtNSAsMS(SB)		
  0x41217d		488b442430		MOVQ 0x30(SP), AX			
  0x412182		488b4c2428		MOVQ 0x28(SP), CX			
  0x412187		488b542420		MOVQ 0x20(SP), DX			
  0x41218c		488d9c24f0000000	LEAQ 0xf0(SP), BX			
  0x412194		48891c24		MOVQ BX, 0(SP)				
  0x412198		4889542408		MOVQ DX, 0x8(SP)			
  0x41219d		48894c2410		MOVQ CX, 0x10(SP)			
  0x4121a2		4889442418		MOVQ AX, 0x18(SP)			
  0x4121a7		e8244f0200		CALL runtime.slicebytetostring(SB)	
  0x4121ac		488b442428		MOVQ 0x28(SP), AX			
  0x4121b1		48898424a8000000	MOVQ AX, 0xa8(SP)			
  0x4121b9		488b4c2420		MOVQ 0x20(SP), CX			
  0x4121be		48898c2490010000	MOVQ CX, 0x190(SP)			
  0x4121c6		e835f90000		CALL runtime.printlock(SB)		
  0x4121cb		488b842490010000	MOVQ 0x190(SP), AX			
  0x4121d3		48890424		MOVQ AX, 0(SP)				
  0x4121d7		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x4121df		4889442408		MOVQ AX, 0x8(SP)			
  0x4121e4		e857020100		CALL runtime.printstring(SB)		
  0x4121e9		e892f90000		CALL runtime.printunlock(SB)		
  0x4121ee		488b842480000000	MOVQ 0x80(SP), AX			
		for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {
  0x4121f6		48ffc0			INCQ AX				
  0x4121f9		4883f805		CMPQ $0x5, AX			
  0x4121fd		0f8d87000000		JGE 0x41228a			
  0x412203		4889842480000000	MOVQ AX, 0x80(SP)		
  0x41220b		488b8cc450010000	MOVQ 0x150(SP)(AX*8), CX	
  0x412213		48894c2460		MOVQ CX, 0x60(SP)		
			if i == 2 || i == 3 {
  0x412218		4883f802		CMPQ $0x2, AX		
  0x41221c		7528			JNE 0x412246		
				print("/")
  0x41221e		e8ddf80000		CALL runtime.printlock(SB)	
  0x412223		488d052d7a0500		LEAQ 0x57a2d(IP), AX		
  0x41222a		48890424		MOVQ AX, 0(SP)			
  0x41222e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x412237		e804020100		CALL runtime.printstring(SB)	
  0x41223c		e83ff90000		CALL runtime.printunlock(SB)	
  0x412241		e90affffff		JMP 0x412150			
			if i == 2 || i == 3 {
  0x412246		4883f803		CMPQ $0x3, AX		
  0x41224a		74d2			JE 0x41221e		
			} else if i != 0 {
  0x41224c		4885c0			TESTQ AX, AX		
  0x41224f		0f84fbfeffff		JE 0x412150		
				print("+")
  0x412255		e8a6f80000		CALL runtime.printlock(SB)	
  0x41225a		488d05f2790500		LEAQ 0x579f2(IP), AX		
  0x412261		48890424		MOVQ AX, 0(SP)			
  0x412265		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x41226e		e8cd010100		CALL runtime.printstring(SB)	
  0x412273		e808f90000		CALL runtime.printunlock(SB)	
  0x412278		488b842480000000	MOVQ 0x80(SP), AX		
  0x412280		488b4c2460		MOVQ 0x60(SP), CX		
  0x412285		e9c6feffff		JMP 0x412150			
		print(" ms cpu, ",
  0x41228a		4863055f5c0900		MOVSXD runtime.work+336(SB), AX	
  0x412291		48898424a0000000	MOVQ AX, 0xa0(SP)		
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x412299		488b0d885c0900		MOVQ runtime.work+392(SB), CX	
  0x4122a0		48898c24b0000000	MOVQ CX, 0xb0(SP)		
  0x4122a8		488b15815c0900		MOVQ runtime.work+400(SB), DX	
  0x4122af		4889942498000000	MOVQ DX, 0x98(SP)		
  0x4122b7		488b1d7a5c0900		MOVQ runtime.work+408(SB), BX	
  0x4122be		48899c2490000000	MOVQ BX, 0x90(SP)		
			work.heapGoal>>20, " MB goal, ",
  0x4122c6		488b35735c0900		MOVQ runtime.work+416(SB), SI	
  0x4122cd		4889b42488000000	MOVQ SI, 0x88(SP)		
		print(" ms cpu, ",
  0x4122d5		e826f80000		CALL runtime.printlock(SB)	
  0x4122da		488d05a67d0500		LEAQ 0x57da6(IP), AX		
  0x4122e1		48890424		MOVQ AX, 0(SP)			
  0x4122e5		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4122ee		e84d010100		CALL runtime.printstring(SB)	
  0x4122f3		488b8424b0000000	MOVQ 0xb0(SP), AX		
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x4122fb		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x4122ff		48890424		MOVQ AX, 0(SP)			
  0x412303		e868fe0000		CALL runtime.printuint(SB)	
  0x412308		488d055f790500		LEAQ 0x5795f(IP), AX		
  0x41230f		48890424		MOVQ AX, 0(SP)			
  0x412313		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41231c		e81f010100		CALL runtime.printstring(SB)	
  0x412321		488b842498000000	MOVQ 0x98(SP), AX		
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x412329		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x41232d		48890424		MOVQ AX, 0(SP)			
  0x412331		e83afe0000		CALL runtime.printuint(SB)	
  0x412336		488d0531790500		LEAQ 0x57931(IP), AX		
  0x41233d		48890424		MOVQ AX, 0(SP)			
  0x412341		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41234a		e8f1000100		CALL runtime.printstring(SB)	
  0x41234f		488b842490000000	MOVQ 0x90(SP), AX		
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x412357		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x41235b		48890424		MOVQ AX, 0(SP)			
  0x41235f		e80cfe0000		CALL runtime.printuint(SB)	
  0x412364		488d05df790500		LEAQ 0x579df(IP), AX		
  0x41236b		48890424		MOVQ AX, 0(SP)			
  0x41236f		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x412378		e8c3000100		CALL runtime.printstring(SB)	
  0x41237d		488b842488000000	MOVQ 0x88(SP), AX		
			work.heapGoal>>20, " MB goal, ",
  0x412385		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x412389		48890424		MOVQ AX, 0(SP)			
  0x41238d		e8defd0000		CALL runtime.printuint(SB)	
  0x412392		488d05dd7e0500		LEAQ 0x57edd(IP), AX		
  0x412399		48890424		MOVQ AX, 0(SP)			
  0x41239d		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x4123a6		e895000100		CALL runtime.printstring(SB)	
  0x4123ab		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x4123b3		48890424		MOVQ AX, 0(SP)			
  0x4123b7		e8c4fe0000		CALL runtime.printint(SB)	
  0x4123bc		488d05a1780500		LEAQ 0x578a1(IP), AX		
  0x4123c3		48890424		MOVQ AX, 0(SP)			
  0x4123c7		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4123d0		e86b000100		CALL runtime.printstring(SB)	
  0x4123d5		e8a6f70000		CALL runtime.printunlock(SB)	
		if work.userForced {
  0x4123da		0fb605c75a0900		MOVZX runtime.work+264(SB), AX	
  0x4123e1		84c0			TESTL AL, AL			
  0x4123e3		756c			JNE 0x412451			
		print("\n")
  0x4123e5		e816f70000		CALL runtime.printlock(SB)	
  0x4123ea		e8a1f90000		CALL runtime.printnl(SB)	
  0x4123ef		e88cf70000		CALL runtime.printunlock(SB)	
		printunlock()
  0x4123f4		e887f70000		CALL runtime.printunlock(SB)	
	semrelease(&worldsema)
  0x4123f9		488d050c2c0900		LEAQ runtime.worldsema(SB), AX	
  0x412400		48890424		MOVQ AX, 0(SP)			
  0x412404		e887de0100		CALL runtime.semrelease(SB)	
	_g_ := getg()
  0x412409		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x412412		488b8c2478010000	MOVQ 0x178(SP), CX	
	mp.locks--
  0x41241a		8b9100010000		MOVL 0x100(CX), DX	
  0x412420		8d5aff			LEAL -0x1(DX), BX	
  0x412423		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x412429		83fa01			CMPL $0x1, DX		
  0x41242c		7513			JNE 0x412441		
  0x41242e		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x412435		84c9			TESTL CL, CL		
  0x412437		7408			JE 0x412441		
		_g_.stackguard0 = stackPreempt
  0x412439		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x412441		488bac24c0010000	MOVQ 0x1c0(SP), BP	
  0x412449		4881c4c8010000		ADDQ $0x1c8, SP		
  0x412450		c3			RET			
			print(" (forced)")
  0x412451		e8aaf60000		CALL runtime.printlock(SB)	
  0x412456		488d05e27b0500		LEAQ 0x57be2(IP), AX		
  0x41245d		48890424		MOVQ AX, 0(SP)			
  0x412461		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x41246a		e8d1ff0000		CALL runtime.printstring(SB)	
  0x41246f		e80cf70000		CALL runtime.printunlock(SB)	
  0x412474		e96cffffff		JMP 0x4123e5			
  0x412479		488bbc2498010000	MOVQ 0x198(SP), DI		
	mp.preemptoff = ""
  0x412481		31c0			XORL AX, AX			
  0x412483		e818440300		CALL runtime.gcWriteBarrier(SB)	
  0x412488		e94af7ffff		JMP 0x411bd7			
		traceGCDone()
  0x41248d		e8be7f0200		CALL runtime.traceGCDone(SB)	
  0x412492		e914f7ffff		JMP 0x411bab			
	gp.waitreason = "garbage collection"
  0x412497		488d0507890500		LEAQ 0x58907(IP), AX		
  0x41249e		e8fd430300		CALL runtime.gcWriteBarrier(SB)	
  0x4124a3		e967f6ffff		JMP 0x411b0f			
	mp.preemptoff = "gcing"
  0x4124a8		488d0522790500		LEAQ 0x57922(IP), AX		
  0x4124af		e8ec430300		CALL runtime.gcWriteBarrier(SB)	
  0x4124b4		e9d9f5ffff		JMP 0x411a92			
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x4124b9		0fb60555150b00		MOVZX runtime.writeBarrier+5(SB), AX	
  0x4124c0		e954f5ffff		JMP 0x411a19				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x4124c5		83f802			CMPL $0x2, AX		
  0x4124c8		0f94c0			SETE AL			
  0x4124cb		e936f5ffff		JMP 0x411a06		
		throw("gc done but gcphase != _GCoff")
  0x4124d0		488d05869d0500		LEAQ 0x59d86(IP), AX	
  0x4124d7		48890424		MOVQ AX, 0(SP)		
  0x4124db		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x4124e4		e8e7ec0000		CALL runtime.throw(SB)	
  0x4124e9		0f0b			UD2			
func gcMarkTermination(nextTriggerRatio float64) {
  0x4124eb		e880200300		CALL runtime.morestack_noctxt(SB)	
  0x4124f0		e9abf4ffff		JMP runtime.gcMarkTermination(SB)	

TEXT runtime.gcBgMarkStartWorkers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcBgMarkStartWorkers() {
  0x412500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412509		483b6110		CMPQ 0x10(CX), SP	
  0x41250d		0f86ae000000		JBE 0x4125c1		
  0x412513		4883ec38		SUBQ $0x38, SP		
  0x412517		48896c2430		MOVQ BP, 0x30(SP)	
  0x41251c		488d6c2430		LEAQ 0x30(SP), BP	
	for _, p := range allp {
  0x412521		488b0590510900		MOVQ runtime.allp+8(SB), AX	
  0x412528		4889442420		MOVQ AX, 0x20(SP)		
  0x41252d		488b0d7c510900		MOVQ runtime.allp(SB), CX	
  0x412534		48894c2428		MOVQ CX, 0x28(SP)		
  0x412539		31d2			XORL DX, DX			
  0x41253b		eb03			JMP 0x412540			
  0x41253d		48ffc2			INCQ DX				
  0x412540		4839c2			CMPQ AX, DX			
  0x412543		7d72			JGE 0x4125b7			
  0x412545		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		if p.gcBgMarkWorker == 0 {
  0x412549		8403			TESTB AL, 0(BX)		
  0x41254b		488bb358120000		MOVQ 0x1258(BX), SI	
  0x412552		4885f6			TESTQ SI, SI		
  0x412555		75e6			JNE 0x41253d		
  0x412557		4889542418		MOVQ DX, 0x18(SP)	
			go gcBgMarkWorker(p)
  0x41255c		48895c2410		MOVQ BX, 0x10(SP)		
  0x412561		c7042408000000		MOVL $0x8, 0(SP)		
  0x412568		488d0511bb0500		LEAQ 0x5bb11(IP), AX		
  0x41256f		4889442408		MOVQ AX, 0x8(SP)		
  0x412574		e8777d0100		CALL runtime.newproc(SB)	
			notetsleepg(&work.bgMarkReady, -1)
  0x412579		488d0510590900		LEAQ runtime.work+240(SB), AX	
  0x412580		48890424		MOVQ AX, 0(SP)			
  0x412584		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x41258d		e8fe75ffff		CALL runtime.notetsleepg(SB)	
	n.key = 0
  0x412592		488d05f7580900		LEAQ runtime.work+240(SB), AX	
  0x412599		8400			TESTB AL, 0(AX)			
  0x41259b		48c705ea58090000000000	MOVQ $0x0, runtime.work+240(SB)	
  0x4125a6		488b442420		MOVQ 0x20(SP), AX		
  0x4125ab		488b4c2428		MOVQ 0x28(SP), CX		
  0x4125b0		488b542418		MOVQ 0x18(SP), DX		
	for _, p := range allp {
  0x4125b5		eb86			JMP 0x41253d		
  0x4125b7		488b6c2430		MOVQ 0x30(SP), BP	
  0x4125bc		4883c438		ADDQ $0x38, SP		
  0x4125c0		c3			RET			
func gcBgMarkStartWorkers() {
  0x4125c1		e8aa1f0300		CALL runtime.morestack_noctxt(SB)	
  0x4125c6		e935ffffff		JMP runtime.gcBgMarkStartWorkers(SB)	

TEXT runtime.gcBgMarkWorker(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcBgMarkWorker(_p_ *p) {
  0x4125d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4125d9		488d4424f8		LEAQ -0x8(SP), AX	
  0x4125de		483b4110		CMPQ 0x10(CX), AX	
  0x4125e2		0f86e8040000		JBE 0x412ad0		
  0x4125e8		4881ec88000000		SUBQ $0x88, SP		
  0x4125ef		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x4125f7		488dac2480000000	LEAQ 0x80(SP), BP	
	gp := getg()
  0x4125ff		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412608		48894c2450		MOVQ CX, 0x50(SP)	
	gp.m.preemptoff = "GC worker init"
  0x41260d		488b5130		MOVQ 0x30(CX), DX			
  0x412611		48c782f80000000e000000	MOVQ $0xe, 0xf8(DX)			
  0x41261c		8b1dee130b00		MOVL runtime.writeBarrier(SB), BX	
  0x412622		488dbaf0000000		LEAQ 0xf0(DX), DI			
  0x412629		85db			TESTL BX, BX				
  0x41262b		0f8544030000		JNE 0x412975				
  0x412631		488d05fa810500		LEAQ 0x581fa(IP), AX			
  0x412638		488982f0000000		MOVQ AX, 0xf0(DX)			
	park := new(parkInfo)
  0x41263f		488d05bab50400		LEAQ 0x4b5ba(IP), AX		
  0x412646		48890424		MOVQ AX, 0(SP)			
  0x41264a		e8d18affff		CALL runtime.newobject(SB)	
  0x41264f		488b442450		MOVQ 0x50(SP), AX		
	gp.m.preemptoff = ""
  0x412654		488b4830		MOVQ 0x30(AX), CX	
	park := new(parkInfo)
  0x412658		488b542408		MOVQ 0x8(SP), DX	
	gp.m.preemptoff = ""
  0x41265d		48c781f800000000000000	MOVQ $0x0, 0xf8(CX)			
  0x412668		8b1da2130b00		MOVL runtime.writeBarrier(SB), BX	
  0x41266e		488db9f0000000		LEAQ 0xf0(CX), DI			
  0x412675		85db			TESTL BX, BX				
  0x412677		0f85ec020000		JNE 0x412969				
  0x41267d		48c781f000000000000000	MOVQ $0x0, 0xf0(CX)			
  0x412688		4889542460		MOVQ DX, 0x60(SP)			
	_g_ := getg()
  0x41268d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x412696		488b4830		MOVQ 0x30(AX), CX	
  0x41269a		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x4126a0		488b4030		MOVQ 0x30(AX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x4126a4		488902			MOVQ AX, 0(DX)		
  0x4126a7		488b842490000000	MOVQ 0x90(SP), AX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4126af		48894208		MOVQ AX, 0x8(DX)	
	notewakeup(&work.bgMarkReady)
  0x4126b3		488d05d6570900		LEAQ runtime.work+240(SB), AX	
  0x4126ba		48890424		MOVQ AX, 0(SP)			
  0x4126be		e8cd70ffff		CALL runtime.notewakeup(SB)	
		gopark(func(g *g, parkp unsafe.Pointer) bool {
  0x4126c3		488d05aeb90500		LEAQ 0x5b9ae(IP), AX	
  0x4126ca		48890424		MOVQ AX, 0(SP)		
  0x4126ce		488b4c2460		MOVQ 0x60(SP), CX	
  0x4126d3		48894c2408		MOVQ CX, 0x8(SP)	
  0x4126d8		488d1563830500		LEAQ 0x58363(IP), DX	
  0x4126df		4889542410		MOVQ DX, 0x10(SP)	
  0x4126e4		48c744241810000000	MOVQ $0x10, 0x18(SP)	
  0x4126ed		c644242014		MOVB $0x14, 0x20(SP)	
  0x4126f2		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x4126fb		e8f0060100		CALL runtime.gopark(SB)	
  0x412700		488b842490000000	MOVQ 0x90(SP), AX	
		if _p_.gcBgMarkWorker.ptr() != gp {
  0x412708		8400			TESTB AL, 0(AX)		
  0x41270a		488b8858120000		MOVQ 0x1258(AX), CX	
  0x412711		488d9058120000		LEAQ 0x1258(AX), DX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x412718		488b5c2450		MOVQ 0x50(SP), BX	
		if _p_.gcBgMarkWorker.ptr() != gp {
  0x41271d		4839d9			CMPQ BX, CX		
  0x412720		0f8533020000		JNE 0x412959		
	_g_ := getg()
  0x412726		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x41272f		488b7130		MOVQ 0x30(CX), SI	
  0x412733		ff8600010000		INCL 0x100(SI)		
	return _g_.m
  0x412739		488b4930		MOVQ 0x30(CX), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x41273d		488b742460		MOVQ 0x60(SP), SI	
  0x412742		48890e			MOVQ CX, 0(SI)		
		if gcBlackenEnabled == 0 {
  0x412745		8b0d89110b00		MOVL runtime.gcBlackenEnabled(SB), CX	
  0x41274b		85c9			TESTL CX, CX				
  0x41274d		0f8462030000		JE 0x412ab5				
  0x412753		4889542458		MOVQ DX, 0x58(SP)			
		startTime := nanotime()
  0x412758		e8d3520300		CALL runtime.nanotime(SB)	
  0x41275d		488b0424		MOVQ 0(SP), AX			
  0x412761		488b8c2490000000	MOVQ 0x90(SP), CX		
		_p_.gcMarkWorkerStartTime = startTime
  0x412769		48898168120000		MOVQ AX, 0x1268(CX)	
		decnwait := atomic.Xadd(&work.nwait, -1)
  0x412770		baffffffff		MOVL $-0x1, DX			
  0x412775		488d1dc4560900		LEAQ runtime.work+160(SB), BX	
  0x41277c		f00fc113		LOCK XADDL DX, 0(BX)		
  0x412780		ffca			DECL DX				
		if decnwait == work.nproc {
  0x412782		8b35a8560900		MOVL runtime.work+144(SB), SI	
  0x412788		39f2			CMPL SI, DX			
  0x41278a		0f84a7020000		JE 0x412a37			
  0x412790		4889442440		MOVQ AX, 0x40(SP)		
		systemstack(func() {
  0x412795		488d0574fb0200		LEAQ runtime.gcBgMarkWorker.func2(SB), AX	
  0x41279c		4889442468		MOVQ AX, 0x68(SP)				
  0x4127a1		488b542450		MOVQ 0x50(SP), DX				
  0x4127a6		4889542470		MOVQ DX, 0x70(SP)				
  0x4127ab		48894c2478		MOVQ CX, 0x78(SP)				
  0x4127b0		488d5c2468		LEAQ 0x68(SP), BX				
  0x4127b5		48891c24		MOVQ BX, 0(SP)					
  0x4127b9		e8621c0300		CALL runtime.systemstack(SB)			
		if gcBlackenPromptly {
  0x4127be		0fb605e2100b00		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x4127c5		84c0			TESTL AL, AL				
  0x4127c7		0f856f010000		JNE 0x41293c				
		duration := nanotime() - startTime
  0x4127cd		e85e520300		CALL runtime.nanotime(SB)	
  0x4127d2		488b0424		MOVQ 0(SP), AX			
  0x4127d6		488b4c2440		MOVQ 0x40(SP), CX		
  0x4127db		4829c8			SUBQ CX, AX			
  0x4127de		488b8c2490000000	MOVQ 0x90(SP), CX		
		switch _p_.gcMarkWorkerMode {
  0x4127e6		488b9160120000		MOVQ 0x1260(CX), DX	
		case gcMarkWorkerDedicatedMode:
  0x4127ed		4885d2			TESTQ DX, DX		
  0x4127f0		0f8508010000		JNE 0x4128fe		
			atomic.Xaddint64(&gcController.dedicatedMarkTime, duration)
  0x4127f6		488d153b140b00		LEAQ runtime.gcController+24(SB), DX	
  0x4127fd		f0480fc102		LOCK XADDQ AX, 0(DX)			
			atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 1)
  0x412802		b801000000		MOVL $0x1, AX				
  0x412807		488d154a140b00		LEAQ runtime.gcController+56(SB), DX	
  0x41280e		f0480fc102		LOCK XADDQ AX, 0(DX)			
		incnwait := atomic.Xadd(&work.nwait, +1)
  0x412813		b801000000		MOVL $0x1, AX			
  0x412818		488d1521560900		LEAQ runtime.work+160(SB), DX	
  0x41281f		f00fc102		LOCK XADDL AX, 0(DX)		
  0x412823		ffc0			INCL AX				
		if incnwait > work.nproc {
  0x412825		8b1505560900		MOVL runtime.work+144(SB), DX	
  0x41282b		39d0			CMPL DX, AX			
  0x41282d		0f8753010000		JA 0x412986			
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x412833		0f858afeffff		JNE 0x4126c3		
	return atomic.Load64((*uint64)(head)) == 0
  0x412839		488b0560550900		MOVQ runtime.work(SB), AX	
  0x412840		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x412843		0f85ab000000		JNE 0x4128f4		
	if work.markrootNext < work.markrootJobs {
  0x412849		8b05d9550900		MOVL runtime.work+136(SB), AX	
  0x41284f		8b15d7550900		MOVL runtime.work+140(SB), DX	
  0x412855		39d0			CMPL DX, AX			
  0x412857		0f8390000000		JAE 0x4128ed			
  0x41285d		b801000000		MOVL $0x1, AX			
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x412862		84c0			TESTL AL, AL		
  0x412864		0f8559feffff		JNE 0x4126c3		
  0x41286a		488b442458		MOVQ 0x58(SP), AX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41286f		8400			TESTB AL, 0(AX)		
  0x412871		31c0			XORL AX, AX		
  0x412873		48898158120000		MOVQ AX, 0x1258(CX)	
  0x41287a		488b442460		MOVQ 0x60(SP), AX	
			releasem(park.m.ptr())
  0x41287f		488b10			MOVQ 0(AX), DX		
	_g_ := getg()
  0x412882		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
	mp.locks--
  0x41288b		8bb200010000		MOVL 0x100(DX), SI	
  0x412891		8d7eff			LEAL -0x1(SI), DI	
  0x412894		89ba00010000		MOVL DI, 0x100(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x41289a		83fe01			CMPL $0x1, SI		
  0x41289d		7513			JNE 0x4128b2		
  0x41289f		0fb693c0000000		MOVZX 0xc0(BX), DX	
  0x4128a6		84d2			TESTL DL, DL		
  0x4128a8		7408			JE 0x4128b2		
		_g_.stackguard0 = stackPreempt
  0x4128aa		48c74310defaffff	MOVQ $-0x522, 0x10(BX)	
			gcMarkDone()
  0x4128b2		e859eeffff		CALL runtime.gcMarkDone(SB)	
	_g_ := getg()
  0x4128b7		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x4128c0		488b4830		MOVQ 0x30(AX), CX	
  0x4128c4		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x4128ca		488b4030		MOVQ 0x30(AX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x4128ce		488b4c2460		MOVQ 0x60(SP), CX	
  0x4128d3		488901			MOVQ AX, 0(CX)		
  0x4128d6		488b842490000000	MOVQ 0x90(SP), AX	
  0x4128de		4889c2			MOVQ AX, DX		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4128e1		48894108		MOVQ AX, 0x8(CX)	
  0x4128e5		4889d1			MOVQ DX, CX		
		gopark(func(g *g, parkp unsafe.Pointer) bool {
  0x4128e8		e9d6fdffff		JMP 0x4126c3		
  0x4128ed		31c0			XORL AX, AX		
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x4128ef		e96effffff		JMP 0x412862		
  0x4128f4		b801000000		MOVL $0x1, AX		
  0x4128f9		e964ffffff		JMP 0x412862		
		case gcMarkWorkerFractionalMode:
  0x4128fe		4883fa01		CMPQ $0x1, DX		
  0x412902		751d			JNE 0x412921		
			atomic.Xaddint64(&gcController.fractionalMarkTime, duration)
  0x412904		488d1535130b00		LEAQ runtime.gcController+32(SB), DX	
  0x41290b		4889c3			MOVQ AX, BX				
  0x41290e		f0480fc102		LOCK XADDQ AX, 0(DX)			
			atomic.Xaddint64(&_p_.gcFractionalMarkTime, duration)
  0x412913		f0480fc19950120000	LOCK XADDQ BX, 0x1250(CX)	
		switch _p_.gcMarkWorkerMode {
  0x41291c		e9f2feffff		JMP 0x412813		
		case gcMarkWorkerIdleMode:
  0x412921		4883fa02		CMPQ $0x2, DX		
  0x412925		0f85e8feffff		JNE 0x412813		
			atomic.Xaddint64(&gcController.idleMarkTime, duration)
  0x41292b		488d1516130b00		LEAQ runtime.gcController+40(SB), DX	
  0x412932		f0480fc102		LOCK XADDQ AX, 0(DX)			
		switch _p_.gcMarkWorkerMode {
  0x412937		e9d7feffff		JMP 0x412813		
  0x41293c		488b842490000000	MOVQ 0x90(SP), AX	
			_p_.gcw.dispose()
  0x412944		488d8870120000		LEAQ 0x1270(AX), CX			
  0x41294b		48890c24		MOVQ CX, 0(SP)				
  0x41294f		e82c690000		CALL runtime.(*gcWork).dispose(SB)	
  0x412954		e974feffff		JMP 0x4127cd				
  0x412959		488bac2480000000	MOVQ 0x80(SP), BP			
  0x412961		4881c488000000		ADDQ $0x88, SP				
  0x412968		c3			RET					
	gp.m.preemptoff = ""
  0x412969		31c0			XORL AX, AX			
  0x41296b		e8303f0300		CALL runtime.gcWriteBarrier(SB)	
  0x412970		e913fdffff		JMP 0x412688			
	gp.m.preemptoff = "GC worker init"
  0x412975		488d05b67e0500		LEAQ 0x57eb6(IP), AX		
  0x41297c		e81f3f0300		CALL runtime.gcWriteBarrier(SB)	
  0x412981		e9b9fcffff		JMP 0x41263f			
  0x412986		89442434		MOVL AX, 0x34(SP)		
  0x41298a		8954243c		MOVL DX, 0x3c(SP)		
			println("runtime: p.gcMarkWorkerMode=", _p_.gcMarkWorkerMode,
  0x41298e		488b8160120000		MOVQ 0x1260(CX), AX		
  0x412995		4889442448		MOVQ AX, 0x48(SP)		
  0x41299a		e861f10000		CALL runtime.printlock(SB)	
  0x41299f		488d0565990500		LEAQ 0x59965(IP), AX		
  0x4129a6		48890424		MOVQ AX, 0(SP)			
  0x4129aa		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x4129b3		e888fa0000		CALL runtime.printstring(SB)	
  0x4129b8		488b442448		MOVQ 0x48(SP), AX		
  0x4129bd		48890424		MOVQ AX, 0(SP)			
  0x4129c1		e8baf80000		CALL runtime.printint(SB)	
  0x4129c6		488d05197d0500		LEAQ 0x57d19(IP), AX		
  0x4129cd		48890424		MOVQ AX, 0(SP)			
  0x4129d1		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4129da		e861fa0000		CALL runtime.printstring(SB)	
  0x4129df		8b442434		MOVL 0x34(SP), AX		
  0x4129e3		48890424		MOVQ AX, 0(SP)			
  0x4129e7		e884f70000		CALL runtime.printuint(SB)	
  0x4129ec		488d05e67c0500		LEAQ 0x57ce6(IP), AX		
  0x4129f3		48890424		MOVQ AX, 0(SP)			
  0x4129f7		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x412a00		e83bfa0000		CALL runtime.printstring(SB)	
  0x412a05		8b44243c		MOVL 0x3c(SP), AX		
  0x412a09		48890424		MOVQ AX, 0(SP)			
  0x412a0d		e85ef70000		CALL runtime.printuint(SB)	
  0x412a12		e879f30000		CALL runtime.printnl(SB)	
  0x412a17		e864f10000		CALL runtime.printunlock(SB)	
			throw("work.nwait > work.nproc")
  0x412a1c		488d050c8e0500		LEAQ 0x58e0c(IP), AX	
  0x412a23		48890424		MOVQ AX, 0(SP)		
  0x412a27		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x412a30		e89be70000		CALL runtime.throw(SB)	
  0x412a35		0f0b			UD2			
  0x412a37		89542438		MOVL DX, 0x38(SP)	
  0x412a3b		8974243c		MOVL SI, 0x3c(SP)	
			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)
  0x412a3f		e8bcf00000		CALL runtime.printlock(SB)	
  0x412a44		488d05fb880500		LEAQ 0x588fb(IP), AX		
  0x412a4b		48890424		MOVQ AX, 0(SP)			
  0x412a4f		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x412a58		e8e3f90000		CALL runtime.printstring(SB)	
  0x412a5d		8b442438		MOVL 0x38(SP), AX		
  0x412a61		48890424		MOVQ AX, 0(SP)			
  0x412a65		e806f70000		CALL runtime.printuint(SB)	
  0x412a6a		488d05687c0500		LEAQ 0x57c68(IP), AX		
  0x412a71		48890424		MOVQ AX, 0(SP)			
  0x412a75		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x412a7e		e8bdf90000		CALL runtime.printstring(SB)	
  0x412a83		8b44243c		MOVL 0x3c(SP), AX		
  0x412a87		48890424		MOVQ AX, 0(SP)			
  0x412a8b		e8e0f60000		CALL runtime.printuint(SB)	
  0x412a90		e8fbf20000		CALL runtime.printnl(SB)	
  0x412a95		e8e6f00000		CALL runtime.printunlock(SB)	
			throw("work.nwait was > work.nproc")
  0x412a9a		488d05c6940500		LEAQ 0x594c6(IP), AX	
  0x412aa1		48890424		MOVQ AX, 0(SP)		
  0x412aa5		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x412aae		e81de70000		CALL runtime.throw(SB)	
  0x412ab3		0f0b			UD2			
			throw("gcBgMarkWorker: blackening not enabled")
  0x412ab5		488d05d8a50500		LEAQ 0x5a5d8(IP), AX	
  0x412abc		48890424		MOVQ AX, 0(SP)		
  0x412ac0		48c744240826000000	MOVQ $0x26, 0x8(SP)	
  0x412ac9		e802e70000		CALL runtime.throw(SB)	
  0x412ace		0f0b			UD2			
func gcBgMarkWorker(_p_ *p) {
  0x412ad0		e89b1a0300		CALL runtime.morestack_noctxt(SB)	
  0x412ad5		e9f6faffff		JMP runtime.gcBgMarkWorker(SB)		

TEXT runtime.gcMark(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcMark(start_time int64) {
  0x412ae0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412ae9		483b6110		CMPQ 0x10(CX), SP	
  0x412aed		0f86dc020000		JBE 0x412dcf		
  0x412af3		4883ec20		SUBQ $0x20, SP		
  0x412af7		48896c2418		MOVQ BP, 0x18(SP)	
  0x412afc		488d6c2418		LEAQ 0x18(SP), BP	
	if debug.allocfreetrace > 0 {
  0x412b01		8b05b90f0b00		MOVL runtime.debug(SB), AX	
  0x412b07		85c0			TESTL AX, AX			
  0x412b09		0f8f4a020000		JG 0x412d59			
	if gcphase != _GCmarktermination {
  0x412b0f		8b05c70d0b00		MOVL runtime.gcphase(SB), AX	
  0x412b15		83f802			CMPL $0x2, AX			
  0x412b18		0f8596020000		JNE 0x412db4			
  0x412b1e		488b442428		MOVQ 0x28(SP), AX		
	work.tstart = start_time
  0x412b23		4889050e530900		MOVQ AX, runtime.work+152(SB)	
	gcMarkRootPrepare()
  0x412b2a		e891120000		CALL runtime.gcMarkRootPrepare(SB)	
	work.ndone = 0
  0x412b2f		48c7050653090000000000	MOVQ $0x0, runtime.work+160(SB)	
	work.nproc = uint32(gcprocs())
  0x412b3a		e8a1160100		CALL runtime.gcprocs(SB)	
  0x412b3f		8b0424			MOVL 0(SP), AX			
  0x412b42		8905e8520900		MOVL AX, runtime.work+144(SB)	
	if work.full == 0 && work.nDataRoots+work.nBSSRoots+work.nSpanRoots+work.nStackRoots == 0 {
  0x412b48		488b0551520900		MOVQ runtime.work(SB), AX	
  0x412b4f		4885c0			TESTQ AX, AX			
  0x412b52		0f85f5010000		JNE 0x412d4d			
  0x412b58		488b0501530900		MOVQ runtime.work+192(SB), AX	
  0x412b5f		48030502530900		ADDQ runtime.work+200(SB), AX	
  0x412b66		48030503530900		ADDQ runtime.work+208(SB), AX	
  0x412b6d		48030504530900		ADDQ runtime.work+216(SB), AX	
  0x412b74		4885c0			TESTQ AX, AX			
  0x412b77		0f85d0010000		JNE 0x412d4d			
		work.helperDrainBlock = false
  0x412b7d		c605cc52090000		MOVB $0x0, runtime.work+176(SB)	
	if work.nproc > 1 {
  0x412b84		8b05a6520900		MOVL runtime.work+144(SB), AX	
  0x412b8a		83f801			CMPL $0x1, AX			
  0x412b8d		0f8793010000		JA 0x412d26			
	gchelperstart()
  0x412b93		e828070000		CALL runtime.gchelperstart(SB)	
	gcw := &getg().m.p.ptr().gcw
  0x412b98		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x412ba1		488b4030		MOVQ 0x30(AX), AX	
  0x412ba5		488b88d0000000		MOVQ 0xd0(AX), CX	
  0x412bac		8401			TESTB AL, 0(CX)		
  0x412bae		8400			TESTB AL, 0(AX)		
  0x412bb0		488d8170120000		LEAQ 0x1270(CX), AX	
  0x412bb7		4889442410		MOVQ AX, 0x10(SP)	
	if work.helperDrainBlock {
  0x412bbc		0fb60d8d520900		MOVZX runtime.work+176(SB), CX	
  0x412bc3		84c9			TESTL CL, CL			
  0x412bc5		0f8444010000		JE 0x412d0f			
		gcDrain(gcw, gcDrainBlock)
  0x412bcb		48890424		MOVQ AX, 0(SP)			
  0x412bcf		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x412bd8		e8f3320000		CALL runtime.gcDrain(SB)	
  0x412bdd		488b442410		MOVQ 0x10(SP), AX		
	gcw.dispose()
  0x412be2		48890424		MOVQ AX, 0(SP)				
  0x412be6		e895660000		CALL runtime.(*gcWork).dispose(SB)	
	if debug.gccheckmark > 0 {
  0x412beb		8b05db0e0b00		MOVL runtime.debug+12(SB), AX	
  0x412bf1		85c0			TESTL AX, AX			
  0x412bf3		0f8f0c010000		JG 0x412d05			
	if work.full != 0 {
  0x412bf9		488b05a0510900		MOVQ runtime.work(SB), AX	
  0x412c00		4885c0			TESTQ AX, AX			
  0x412c03		0f8590010000		JNE 0x412d99			
	if work.nproc > 1 {
  0x412c09		8b0521520900		MOVL runtime.work+144(SB), AX	
  0x412c0f		83f801			CMPL $0x1, AX			
  0x412c12		0f87d8000000		JA 0x412cf0			
	work.markrootDone = true
  0x412c18		c6056152090001		MOVB $0x1, runtime.work+224(SB)	
	for _, p := range allp {
  0x412c1f		488b058a4a0900		MOVQ runtime.allp(SB), AX	
  0x412c26		488b0d8b4a0900		MOVQ runtime.allp+8(SB), CX	
  0x412c2d		31d2			XORL DX, DX			
  0x412c2f		eb03			JMP 0x412c34			
  0x412c31		48ffc2			INCQ DX				
  0x412c34		4839ca			CMPQ CX, DX			
  0x412c37		7d6c			JGE 0x412ca5			
  0x412c39		488b1cd0		MOVQ 0(AX)(DX*8), BX		
		gcw := &p.gcw
  0x412c3d		8403			TESTB AL, 0(BX)		
  0x412c3f		488db370120000		LEAQ 0x1270(BX), SI	
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x412c46		8406			TESTB AL, 0(SI)		
  0x412c48		488bb370120000		MOVQ 0x1270(BX), SI	
  0x412c4f		4885f6			TESTQ SI, SI		
  0x412c52		744a			JE 0x412c9e		
  0x412c54		488b7610		MOVQ 0x10(SI), SI	
  0x412c58		4885f6			TESTQ SI, SI		
  0x412c5b		753d			JNE 0x412c9a		
  0x412c5d		488bb378120000		MOVQ 0x1278(BX), SI	
  0x412c64		488b7610		MOVQ 0x10(SI), SI	
  0x412c68		4885f6			TESTQ SI, SI		
  0x412c6b		400f94c6		SETE SI			
  0x412c6f		4084f6			TESTL SI, SI		
		if !gcw.empty() {
  0x412c72		0f8406010000		JE 0x412d7e		
		if gcw.scanWork != 0 || gcw.bytesMarked != 0 {
  0x412c78		488bb388120000		MOVQ 0x1288(BX), SI	
  0x412c7f		4885f6			TESTQ SI, SI		
  0x412c82		0f85db000000		JNE 0x412d63		
  0x412c88		488b9b80120000		MOVQ 0x1280(BX), BX	
  0x412c8f		4885db			TESTQ BX, BX		
  0x412c92		0f85cb000000		JNE 0x412d63		
  0x412c98		eb97			JMP 0x412c31		
  0x412c9a		31f6			XORL SI, SI		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x412c9c		ebd1			JMP 0x412c6f		
  0x412c9e		be01000000		MOVL $0x1, SI		
  0x412ca3		ebca			JMP 0x412c6f		
	cachestats()
  0x412ca5		e866b40000		CALL runtime.cachestats(SB)	
	memstats.heap_marked = work.bytesMarked
  0x412caa		488b056f510900		MOVQ runtime.work+128(SB), AX		
  0x412cb1		48890598310b00		MOVQ AX, runtime.memstats+5968(SB)	
	memstats.heap_live = work.bytesMarked
  0x412cb8		488b0561510900		MOVQ runtime.work+128(SB), AX		
  0x412cbf		4889057a310b00		MOVQ AX, runtime.memstats+5952(SB)	
	memstats.heap_scan = uint64(gcController.scanWork)
  0x412cc6		488b05530f0b00		MOVQ runtime.gcController(SB), AX	
  0x412ccd		48890574310b00		MOVQ AX, runtime.memstats+5960(SB)	
	if trace.enabled {
  0x412cd4		0fb605f50a0a00		MOVZX runtime.trace+16(SB), AX	
  0x412cdb		84c0			TESTL AL, AL			
  0x412cdd		750a			JNE 0x412ce9			
  0x412cdf		488b6c2418		MOVQ 0x18(SP), BP		
  0x412ce4		4883c420		ADDQ $0x20, SP			
  0x412ce8		c3			RET				
		traceHeapAlloc()
  0x412ce9		e8f2820200		CALL runtime.traceHeapAlloc(SB)	
  0x412cee		ebef			JMP 0x412cdf			
		notesleep(&work.alldone)
  0x412cf0		488d0551510900		LEAQ runtime.work+168(SB), AX	
  0x412cf7		48890424		MOVQ AX, 0(SP)			
  0x412cfb		e8506bffff		CALL runtime.notesleep(SB)	
  0x412d00		e913ffffff		JMP 0x412c18			
		gcMarkRootCheck()
  0x412d05		e856120000		CALL runtime.gcMarkRootCheck(SB)	
  0x412d0a		e9eafeffff		JMP 0x412bf9				
		gcDrain(gcw, gcDrainNoBlock)
  0x412d0f		48890424		MOVQ AX, 0(SP)			
  0x412d13		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x412d1c		e8af310000		CALL runtime.gcDrain(SB)	
  0x412d21		e9b7feffff		JMP 0x412bdd			
	n.key = 0
  0x412d26		488d051b510900		LEAQ runtime.work+168(SB), AX	
  0x412d2d		8400			TESTB AL, 0(AX)			
  0x412d2f		48c7050e51090000000000	MOVQ $0x0, runtime.work+168(SB)	
		helpgc(int32(work.nproc))
  0x412d3a		8b05f0500900		MOVL runtime.work+144(SB), AX	
  0x412d40		890424			MOVL AX, 0(SP)			
  0x412d43		e8c8150100		CALL runtime.helpgc(SB)		
  0x412d48		e946feffff		JMP 0x412b93			
		work.helperDrainBlock = true
  0x412d4d		c605fc50090001		MOVB $0x1, runtime.work+176(SB)	
  0x412d54		e92bfeffff		JMP 0x412b84			
		tracegc()
  0x412d59		e8f2b10000		CALL runtime.tracegc(SB)	
  0x412d5e		e9acfdffff		JMP 0x412b0f			
			throw("P has unflushed stats at end of mark termination")
  0x412d63		488d0533ab0500		LEAQ 0x5ab33(IP), AX	
  0x412d6a		48890424		MOVQ AX, 0(SP)		
  0x412d6e		48c744240830000000	MOVQ $0x30, 0x8(SP)	
  0x412d77		e854e40000		CALL runtime.throw(SB)	
  0x412d7c		0f0b			UD2			
			throw("P has cached GC work at end of mark termination")
  0x412d7e		488d05e9aa0500		LEAQ 0x5aae9(IP), AX	
  0x412d85		48890424		MOVQ AX, 0(SP)		
  0x412d89		48c74424082f000000	MOVQ $0x2f, 0x8(SP)	
  0x412d92		e839e40000		CALL runtime.throw(SB)	
  0x412d97		0f0b			UD2			
		throw("work.full != 0")
  0x412d99		488d05727b0500		LEAQ 0x57b72(IP), AX	
  0x412da0		48890424		MOVQ AX, 0(SP)		
  0x412da4		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x412dad		e81ee40000		CALL runtime.throw(SB)	
  0x412db2		0f0b			UD2			
		throw("in gcMark expecting to see gcphase as _GCmarktermination")
  0x412db4		488d05e4ae0500		LEAQ 0x5aee4(IP), AX	
  0x412dbb		48890424		MOVQ AX, 0(SP)		
  0x412dbf		48c744240838000000	MOVQ $0x38, 0x8(SP)	
  0x412dc8		e803e40000		CALL runtime.throw(SB)	
  0x412dcd		0f0b			UD2			
func gcMark(start_time int64) {
  0x412dcf		e89c170300		CALL runtime.morestack_noctxt(SB)	
  0x412dd4		e907fdffff		JMP runtime.gcMark(SB)			

TEXT runtime.gcSweep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcSweep(mode gcMode) {
  0x412de0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412de9		483b6110		CMPQ 0x10(CX), SP	
  0x412ded		0f8684010000		JBE 0x412f77		
  0x412df3		4883ec20		SUBQ $0x20, SP		
  0x412df7		48896c2418		MOVQ BP, 0x18(SP)	
  0x412dfc		488d6c2418		LEAQ 0x18(SP), BP	
	if gcphase != _GCoff {
  0x412e01		8b05d50a0b00		MOVL runtime.gcphase(SB), AX	
  0x412e07		85c0			TESTL AX, AX			
  0x412e09		0f854d010000		JNE 0x412f5c			
	lock(&mheap_.lock)
  0x412e0f		488d058a940900		LEAQ runtime.mheap_(SB), AX	
  0x412e16		48890424		MOVQ AX, 0(SP)			
  0x412e1a		e80167ffff		CALL runtime.lock(SB)		
	mheap_.sweepgen += 2
  0x412e1f		83059aa4090002		ADDL $0x2, runtime.mheap_+4128(SB)	
	mheap_.sweepdone = 0
  0x412e26		c70594a4090000000000	MOVL $0x0, runtime.mheap_+4132(SB)	
	if mheap_.sweepSpans[mheap_.sweepgen/2%2].index != 0 {
  0x412e30		8b058aa40900		MOVL runtime.mheap_+4128(SB), AX	
  0x412e36		d1e8			SHRL $0x1, AX				
  0x412e38		83e001			ANDL $0x1, AX				
  0x412e3b		488d0480		LEAQ 0(AX)(AX*4), AX			
  0x412e3f		488d0dbaa40900		LEAQ runtime.mheap_+4192(SB), CX	
  0x412e46		8b44c120		MOVL 0x20(CX)(AX*8), AX			
  0x412e4a		85c0			TESTL AX, AX				
  0x412e4c		0f85ef000000		JNE 0x412f41				
	mheap_.pagesSwept = 0
  0x412e52		48c70503a5090000000000	MOVQ $0x0, runtime.mheap_+4288(SB)	
	unlock(&mheap_.lock)
  0x412e5d		488d053c940900		LEAQ runtime.mheap_(SB), AX	
  0x412e64		48890424		MOVQ AX, 0(SP)			
  0x412e68		e85368ffff		CALL runtime.unlock(SB)		
  0x412e6d		488b442428		MOVQ 0x28(SP), AX		
	if !_ConcurrentSweep || mode == gcForceBlockMode {
  0x412e72		4883f802		CMPQ $0x2, AX		
  0x412e76		756d			JNE 0x412ee5		
		lock(&mheap_.lock)
  0x412e78		488d0521940900		LEAQ runtime.mheap_(SB), AX	
  0x412e7f		48890424		MOVQ AX, 0(SP)			
  0x412e83		e89866ffff		CALL runtime.lock(SB)		
		mheap_.sweepPagesPerByte = 0
  0x412e88		0f57c0			XORPS X0, X0				
  0x412e8b		f20f1105e5a40900	MOVSD_XMM X0, runtime.mheap_+4312(SB)	
		unlock(&mheap_.lock)
  0x412e93		488d0506940900		LEAQ runtime.mheap_(SB), AX	
  0x412e9a		48890424		MOVQ AX, 0(SP)			
  0x412e9e		e81d68ffff		CALL runtime.unlock(SB)		
		for sweepone() != ^uintptr(0) {
  0x412ea3		eb06			JMP 0x412eab		
			sweep.npausesweep++
  0x412ea5		ff054d490900		INCL runtime.sweep+24(SB)	
		for sweepone() != ^uintptr(0) {
  0x412eab		e8104c0000		CALL runtime.sweepone(SB)	
  0x412eb0		488b0424		MOVQ 0(SP), AX			
  0x412eb4		4883f8ff		CMPQ $-0x1, AX			
  0x412eb8		75eb			JNE 0x412ea5			
		prepareFreeWorkbufs()
  0x412eba		e8316d0000		CALL runtime.prepareFreeWorkbufs(SB)	
		for freeSomeWbufs(false) {
  0x412ebf		c6042400		MOVB $0x0, 0(SP)		
  0x412ec3		e8d86d0000		CALL runtime.freeSomeWbufs(SB)	
  0x412ec8		0fb6442408		MOVZX 0x8(SP), AX		
  0x412ecd		84c0			TESTL AL, AL			
  0x412ecf		75ee			JNE 0x412ebf			
		mProf_NextCycle()
  0x412ed1		e8daa40000		CALL runtime.mProf_NextCycle(SB)	
		mProf_Flush()
  0x412ed6		e855a50000		CALL runtime.mProf_Flush(SB)	
		return
  0x412edb		488b6c2418		MOVQ 0x18(SP), BP	
  0x412ee0		4883c420		ADDQ $0x20, SP		
  0x412ee4		c3			RET			
	lock(&sweep.lock)
  0x412ee5		488d05f4480900		LEAQ runtime.sweep(SB), AX	
  0x412eec		48890424		MOVQ AX, 0(SP)			
  0x412ef0		e82b66ffff		CALL runtime.lock(SB)		
	if sweep.parked {
  0x412ef5		0fb605f4480900		MOVZX runtime.sweep+16(SB), AX	
  0x412efc		84c0			TESTL AL, AL			
  0x412efe		751a			JNE 0x412f1a			
	unlock(&sweep.lock)
  0x412f00		488d05d9480900		LEAQ runtime.sweep(SB), AX	
  0x412f07		48890424		MOVQ AX, 0(SP)			
  0x412f0b		e8b067ffff		CALL runtime.unlock(SB)		
}
  0x412f10		488b6c2418		MOVQ 0x18(SP), BP	
  0x412f15		4883c420		ADDQ $0x20, SP		
  0x412f19		c3			RET			
		sweep.parked = false
  0x412f1a		c605cf48090000		MOVB $0x0, runtime.sweep+16(SB)	
		ready(sweep.g, 0, true)
  0x412f21		488b05c0480900		MOVQ runtime.sweep+8(SB), AX	
  0x412f28		48890424		MOVQ AX, 0(SP)			
  0x412f2c		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x412f35		c644241001		MOVB $0x1, 0x10(SP)		
  0x412f3a		e811100100		CALL runtime.ready(SB)		
  0x412f3f		ebbf			JMP 0x412f00			
		throw("non-empty swept list")
  0x412f41		488d0511820500		LEAQ 0x58211(IP), AX	
  0x412f48		48890424		MOVQ AX, 0(SP)		
  0x412f4c		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x412f55		e876e20000		CALL runtime.throw(SB)	
  0x412f5a		0f0b			UD2			
		throw("gcSweep being done but phase is not GCoff")
  0x412f5c		488d0546a40500		LEAQ 0x5a446(IP), AX	
  0x412f63		48890424		MOVQ AX, 0(SP)		
  0x412f67		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x412f70		e85be20000		CALL runtime.throw(SB)	
  0x412f75		0f0b			UD2			
func gcSweep(mode gcMode) {
  0x412f77		e8f4150300		CALL runtime.morestack_noctxt(SB)	
  0x412f7c		e95ffeffff		JMP runtime.gcSweep(SB)			

TEXT runtime.gcResetMarkState(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gcResetMarkState() {
  0x412f90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412f99		483b6110		CMPQ 0x10(CX), SP	
  0x412f9d		0f868a000000		JBE 0x41302d		
  0x412fa3		4883ec10		SUBQ $0x10, SP		
  0x412fa7		48896c2408		MOVQ BP, 0x8(SP)	
  0x412fac		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&allglock)
  0x412fb1		488d0560090b00		LEAQ runtime.allglock(SB), AX	
  0x412fb8		48890424		MOVQ AX, 0(SP)			
  0x412fbc		e85f65ffff		CALL runtime.lock(SB)		
	for _, gp := range allgs {
  0x412fc1		488b05d0460900		MOVQ runtime.allgs+8(SB), AX	
  0x412fc8		488b0dc1460900		MOVQ runtime.allgs(SB), CX	
  0x412fcf		31d2			XORL DX, DX			
  0x412fd1		eb1b			JMP 0x412fee			
  0x412fd3		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		gp.gcscanvalid = false // stack has not been scanned
  0x412fd7		66c783c30000000000	MOVW $0x0, 0xc3(BX)	
		gp.gcAssistBytes = 0
  0x412fe0		48c7837001000000000000	MOVQ $0x0, 0x170(BX)	
	for _, gp := range allgs {
  0x412feb		48ffc2			INCQ DX			
  0x412fee		4839c2			CMPQ AX, DX		
  0x412ff1		7ce0			JL 0x412fd3		
	unlock(&allglock)
  0x412ff3		488d051e090b00		LEAQ runtime.allglock(SB), AX	
  0x412ffa		48890424		MOVQ AX, 0(SP)			
  0x412ffe		e8bd66ffff		CALL runtime.unlock(SB)		
	work.bytesMarked = 0
  0x413003		48c705124e090000000000	MOVQ $0x0, runtime.work+128(SB)	
	work.initialHeapLive = atomic.Load64(&memstats.heap_live)
  0x41300e		488b052b2e0b00		MOVQ runtime.memstats+5952(SB), AX	
  0x413015		4889059c4e0900		MOVQ AX, runtime.work+280(SB)		
	work.markrootDone = false
  0x41301c		c6055d4e090000		MOVB $0x0, runtime.work+224(SB)	
}
  0x413023		488b6c2408		MOVQ 0x8(SP), BP	
  0x413028		4883c410		ADDQ $0x10, SP		
  0x41302c		c3			RET			
func gcResetMarkState() {
  0x41302d		e83e150300		CALL runtime.morestack_noctxt(SB)	
  0x413032		e959ffffff		JMP runtime.gcResetMarkState(SB)	

TEXT runtime.clearpools(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func clearpools() {
  0x413040		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413049		483b6110		CMPQ 0x10(CX), SP	
  0x41304d		0f865d010000		JBE 0x4131b0		
  0x413053		4883ec10		SUBQ $0x10, SP		
  0x413057		48896c2408		MOVQ BP, 0x8(SP)	
  0x41305c		488d6c2408		LEAQ 0x8(SP), BP	
	if poolcleanup != nil {
  0x413061		488b1518460900		MOVQ runtime.poolcleanup(SB), DX	
  0x413068		4885d2			TESTQ DX, DX				
  0x41306b		0f8535010000		JNE 0x4131a6				
	lock(&sched.sudoglock)
  0x413071		488d0538490900		LEAQ runtime.sched+144(SB), AX	
  0x413078		48890424		MOVQ AX, 0(SP)			
  0x41307c		e89f64ffff		CALL runtime.lock(SB)		
	for sg = sched.sudogcache; sg != nil; sg = sgnext {
  0x413081		488b0530490900		MOVQ runtime.sched+152(SB), AX	
  0x413088		eb03			JMP 0x41308d			
  0x41308a		4889c8			MOVQ CX, AX			
  0x41308d		4885c0			TESTQ AX, AX			
  0x413090		7425			JE 0x4130b7			
		sgnext = sg.next
  0x413092		488b4810		MOVQ 0x10(AX), CX	
  0x413096		488d7810		LEAQ 0x10(AX), DI	
		sg.next = nil
  0x41309a		8b1570090b00		MOVL runtime.writeBarrier(SB), DX	
  0x4130a0		85d2			TESTL DX, DX				
  0x4130a2		750a			JNE 0x4130ae				
  0x4130a4		48c7401000000000	MOVQ $0x0, 0x10(AX)			
  0x4130ac		ebdc			JMP 0x41308a				
  0x4130ae		31c0			XORL AX, AX				
  0x4130b0		e8eb370300		CALL runtime.gcWriteBarrier(SB)		
  0x4130b5		ebd3			JMP 0x41308a				
	sched.sudogcache = nil
  0x4130b7		8b0d53090b00		MOVL runtime.writeBarrier(SB), CX	
  0x4130bd		85c9			TESTL CX, CX				
  0x4130bf		0f85ce000000		JNE 0x413193				
  0x4130c5		48c705e848090000000000	MOVQ $0x0, runtime.sched+152(SB)	
	unlock(&sched.sudoglock)
  0x4130d0		488d05d9480900		LEAQ runtime.sched+144(SB), AX	
  0x4130d7		48890424		MOVQ AX, 0(SP)			
  0x4130db		e8e065ffff		CALL runtime.unlock(SB)		
	lock(&sched.deferlock)
  0x4130e0		488d05d9480900		LEAQ runtime.sched+160(SB), AX	
  0x4130e7		48890424		MOVQ AX, 0(SP)			
  0x4130eb		e83064ffff		CALL runtime.lock(SB)		
  0x4130f0		31c0			XORL AX, AX			
	for i := range sched.deferpool {
  0x4130f2		eb57			JMP 0x41314b		
  0x4130f4		4889da			MOVQ BX, DX		
		for d = sched.deferpool[i]; d != nil; d = dlink {
  0x4130f7		4885d2			TESTQ DX, DX		
  0x4130fa		7436			JE 0x413132		
			dlink = d.link
  0x4130fc		488b5a28		MOVQ 0x28(DX), BX	
  0x413100		488d7228		LEAQ 0x28(DX), SI	
			d.link = nil
  0x413104		448b0505090b00		MOVL runtime.writeBarrier(SB), R8	
  0x41310b		4585c0			TESTL R8, R8				
  0x41310e		750a			JNE 0x41311a				
  0x413110		48c7422800000000	MOVQ $0x0, 0x28(DX)			
  0x413118		ebda			JMP 0x4130f4				
  0x41311a		4889fa			MOVQ DI, DX				
  0x41311d		4889f7			MOVQ SI, DI				
  0x413120		4989c0			MOVQ AX, R8				
  0x413123		31c0			XORL AX, AX				
  0x413125		e876370300		CALL runtime.gcWriteBarrier(SB)		
  0x41312a		4c89c0			MOVQ R8, AX				
  0x41312d		4889d7			MOVQ DX, DI				
  0x413130		ebc2			JMP 0x4130f4				
		sched.deferpool[i] = nil
  0x413132		8b15d8080b00			MOVL runtime.writeBarrier(SB), DX	
  0x413138		85d2				TESTL DX, DX				
  0x41313a		752e				JNE 0x41316a				
  0x41313c		48c784c1a800000000000000	MOVQ $0x0, 0xa8(CX)(AX*8)		
	for i := range sched.deferpool {
  0x413148		48ffc0			INCQ AX			
  0x41314b		4883f805		CMPQ $0x5, AX		
  0x41314f		7d28			JGE 0x413179		
		for d = sched.deferpool[i]; d != nil; d = dlink {
  0x413151		488d0dc8470900		LEAQ runtime.sched(SB), CX	
  0x413158		488b94c1a8000000	MOVQ 0xa8(CX)(AX*8), DX		
  0x413160		488dbcc1a8000000	LEAQ 0xa8(CX)(AX*8), DI		
  0x413168		eb8d			JMP 0x4130f7			
  0x41316a		4889c2			MOVQ AX, DX			
		sched.deferpool[i] = nil
  0x41316d		31c0			XORL AX, AX			
  0x41316f		e82c370300		CALL runtime.gcWriteBarrier(SB)	
  0x413174		4889d0			MOVQ DX, AX			
  0x413177		ebcf			JMP 0x413148			
	unlock(&sched.deferlock)
  0x413179		488d0540480900		LEAQ runtime.sched+160(SB), AX	
  0x413180		48890424		MOVQ AX, 0(SP)			
  0x413184		e83765ffff		CALL runtime.unlock(SB)		
}
  0x413189		488b6c2408		MOVQ 0x8(SP), BP	
  0x41318e		4883c410		ADDQ $0x10, SP		
  0x413192		c3			RET			
	sched.sudogcache = nil
  0x413193		488d3d1e480900		LEAQ runtime.sched+152(SB), DI	
  0x41319a		31c0			XORL AX, AX			
  0x41319c		e8ff360300		CALL runtime.gcWriteBarrier(SB)	
  0x4131a1		e92affffff		JMP 0x4130d0			
		poolcleanup()
  0x4131a6		488b02			MOVQ 0(DX), AX		
  0x4131a9		ffd0			CALL AX			
  0x4131ab		e9c1feffff		JMP 0x413071		
func clearpools() {
  0x4131b0		e8bb130300		CALL runtime.morestack_noctxt(SB)	
  0x4131b5		e986feffff		JMP runtime.clearpools(SB)		

TEXT runtime.gchelper(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gchelper() {
  0x4131c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4131c9		483b6110		CMPQ 0x10(CX), SP	
  0x4131cd		0f86e2000000		JBE 0x4132b5		
  0x4131d3		4883ec28		SUBQ $0x28, SP		
  0x4131d7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4131dc		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x4131e1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4131ea		4889442418		MOVQ AX, 0x18(SP)	
	_g_.m.traceback = 2
  0x4131ef		488b4830		MOVQ 0x30(AX), CX	
  0x4131f3		c6812901000002		MOVB $0x2, 0x129(CX)	
	gchelperstart()
  0x4131fa		e8c1000000		CALL runtime.gchelperstart(SB)	
	if gcphase == _GCmarktermination {
  0x4131ff		8b05d7060b00		MOVL runtime.gcphase(SB), AX	
  0x413205		83f802			CMPL $0x2, AX			
  0x413208		754d			JNE 0x413257			
  0x41320a		488b442418		MOVQ 0x18(SP), AX		
		gcw := &_g_.m.p.ptr().gcw
  0x41320f		488b4830		MOVQ 0x30(AX), CX	
  0x413213		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x41321a		8402			TESTB AL, 0(DX)		
  0x41321c		8400			TESTB AL, 0(AX)		
  0x41321e		8401			TESTB AL, 0(CX)		
  0x413220		488d8a70120000		LEAQ 0x1270(DX), CX	
  0x413227		48894c2410		MOVQ CX, 0x10(SP)	
		if work.helperDrainBlock {
  0x41322c		0fb6151d4c0900		MOVZX runtime.work+176(SB), DX	
  0x413233		84d2			TESTL DL, DL			
  0x413235		746a			JE 0x4132a1			
			gcDrain(gcw, gcDrainBlock) // blocks in getfull
  0x413237		48890c24		MOVQ CX, 0(SP)			
  0x41323b		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x413244		e8872c0000		CALL runtime.gcDrain(SB)	
  0x413249		488b442410		MOVQ 0x10(SP), AX		
		gcw.dispose()
  0x41324e		48890424		MOVQ AX, 0(SP)				
  0x413252		e829600000		CALL runtime.(*gcWork).dispose(SB)	
	nproc := atomic.Load(&work.nproc) // work.nproc can change right after we increment work.ndone
  0x413257		8b05d34b0900		MOVL runtime.work+144(SB), AX	
	if atomic.Xadd(&work.ndone, +1) == nproc-1 {
  0x41325d		b901000000		MOVL $0x1, CX			
  0x413262		488d15db4b0900		LEAQ runtime.work+164(SB), DX	
  0x413269		f00fc10a		LOCK XADDL CX, 0(DX)		
  0x41326d		ffc1			INCL CX				
  0x41326f		ffc8			DECL AX				
  0x413271		39c8			CMPL CX, AX			
  0x413273		741a			JE 0x41328f			
  0x413275		488b442418		MOVQ 0x18(SP), AX		
	_g_.m.traceback = 0
  0x41327a		488b4030		MOVQ 0x30(AX), AX	
  0x41327e		c6802901000000		MOVB $0x0, 0x129(AX)	
}
  0x413285		488b6c2420		MOVQ 0x20(SP), BP	
  0x41328a		4883c428		ADDQ $0x28, SP		
  0x41328e		c3			RET			
		notewakeup(&work.alldone)
  0x41328f		488d05b24b0900		LEAQ runtime.work+168(SB), AX	
  0x413296		48890424		MOVQ AX, 0(SP)			
  0x41329a		e8f164ffff		CALL runtime.notewakeup(SB)	
  0x41329f		ebd4			JMP 0x413275			
			gcDrain(gcw, gcDrainNoBlock)
  0x4132a1		48890c24		MOVQ CX, 0(SP)			
  0x4132a5		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4132ae		e81d2c0000		CALL runtime.gcDrain(SB)	
  0x4132b3		eb94			JMP 0x413249			
func gchelper() {
  0x4132b5		e8b6120300		CALL runtime.morestack_noctxt(SB)	
  0x4132ba		e901ffffff		JMP runtime.gchelper(SB)		

TEXT runtime.gchelperstart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func gchelperstart() {
  0x4132c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4132c9		483b6110		CMPQ 0x10(CX), SP	
  0x4132cd		766e			JBE 0x41333d		
  0x4132cf		4883ec18		SUBQ $0x18, SP		
  0x4132d3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4132d8		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x4132dd		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.helpgc < 0 || _g_.m.helpgc >= _MaxGcproc {
  0x4132e6		488b4830		MOVQ 0x30(AX), CX	
  0x4132ea		8b9110010000		MOVL 0x110(CX), DX	
  0x4132f0		83fa20			CMPL $0x20, DX		
  0x4132f3		732d			JAE 0x413322		
	if _g_ != _g_.m.g0 {
  0x4132f5		488b09			MOVQ 0(CX), CX		
  0x4132f8		4839c8			CMPQ CX, AX		
  0x4132fb		750a			JNE 0x413307		
  0x4132fd		488b6c2410		MOVQ 0x10(SP), BP	
  0x413302		4883c418		ADDQ $0x18, SP		
  0x413306		c3			RET			
		throw("gchelper not running on g0 stack")
  0x413307		488d05d5940500		LEAQ 0x594d5(IP), AX	
  0x41330e		48890424		MOVQ AX, 0(SP)		
  0x413312		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x41331b		e8b0de0000		CALL runtime.throw(SB)	
  0x413320		0f0b			UD2			
		throw("gchelperstart: bad m->helpgc")
  0x413322		488d05a98d0500		LEAQ 0x58da9(IP), AX	
  0x413329		48890424		MOVQ AX, 0(SP)		
  0x41332d		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x413336		e895de0000		CALL runtime.throw(SB)	
  0x41333b		0f0b			UD2			
func gchelperstart() {
  0x41333d		e82e120300		CALL runtime.morestack_noctxt(SB)	
  0x413342		e979ffffff		JMP runtime.gchelperstart(SB)		

TEXT runtime.itoaDiv(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func itoaDiv(buf []byte, val uint64, dec int) []byte {
  0x413350		4883ec08		SUBQ $0x8, SP		
  0x413354		48892c24		MOVQ BP, 0(SP)		
  0x413358		488d2c24		LEAQ 0(SP), BP		
  0x41335c		488b4c2418		MOVQ 0x18(SP), CX	
	i := len(buf) - 1
  0x413361		488d51ff		LEAQ -0x1(CX), DX	
  0x413365		488b5c2430		MOVQ 0x30(SP), BX	
  0x41336a		4889d6			MOVQ DX, SI		
	idec := i - dec
  0x41336d		4829da			SUBQ BX, DX		
  0x413370		488b5c2410		MOVQ 0x10(SP), BX	
  0x413375		488b7c2428		MOVQ 0x28(SP), DI	
	for val >= 10 || i >= idec {
  0x41337a		eb06			JMP 0x413382		
  0x41337c		4889d7			MOVQ DX, DI		
  0x41337f		4c89c2			MOVQ R8, DX		
  0x413382		4883ff0a		CMPQ $0xa, DI		
  0x413386		7249			JB 0x4133d1		
		buf[i] = byte(val%10 + '0')
  0x413388		48b8cdcccccccccccccc	MOVQ $0xcccccccccccccccd, AX	
  0x413392		4989d0			MOVQ DX, R8			
  0x413395		48f7e7			MULQ DI				
  0x413398		48c1ea03		SHRQ $0x3, DX			
  0x41339c		4c8d0c92		LEAQ 0(DX)(DX*4), R9		
  0x4133a0		49d1e1			SHLQ $0x1, R9			
  0x4133a3		4c29cf			SUBQ R9, DI			
  0x4133a6		4839ce			CMPQ CX, SI			
  0x4133a9		7378			JAE 0x413423			
  0x4133ab		4883c730		ADDQ $0x30, DI			
  0x4133af		40883c33		MOVB DI, 0(BX)(SI*1)		
		i--
  0x4133b3		488d7eff		LEAQ -0x1(SI), DI	
		if i == idec {
  0x4133b7		4c39c7			CMPQ R8, DI		
  0x4133ba		7510			JNE 0x4133cc		
			buf[i] = '.'
  0x4133bc		4839cf			CMPQ CX, DI			
  0x4133bf		735b			JAE 0x41341c			
  0x4133c1		c6441eff2e		MOVB $0x2e, -0x1(SI)(BX*1)	
			i--
  0x4133c6		4883c6fe		ADDQ $-0x2, SI		
  0x4133ca		ebb0			JMP 0x41337c		
  0x4133cc		4889fe			MOVQ DI, SI		
		if i == idec {
  0x4133cf		ebab			JMP 0x41337c		
	for val >= 10 || i >= idec {
  0x4133d1		4839d6			CMPQ DX, SI		
  0x4133d4		7db2			JGE 0x413388		
	buf[i] = byte(val + '0')
  0x4133d6		4839ce			CMPQ CX, SI		
  0x4133d9		733a			JAE 0x413415		
  0x4133db		488d4730		LEAQ 0x30(DI), AX	
  0x4133df		880433			MOVB AL, 0(BX)(SI*1)	
	return buf[i:]
  0x4133e2		488b442420		MOVQ 0x20(SP), AX	
  0x4133e7		4829f0			SUBQ SI, AX		
  0x4133ea		4889c2			MOVQ AX, DX		
  0x4133ed		48f7d8			NEGQ AX			
  0x4133f0		48c1f83f		SARQ $0x3f, AX		
  0x4133f4		4821f0			ANDQ SI, AX		
  0x4133f7		4801d8			ADDQ BX, AX		
  0x4133fa		4889442438		MOVQ AX, 0x38(SP)	
  0x4133ff		4829f1			SUBQ SI, CX		
  0x413402		48894c2440		MOVQ CX, 0x40(SP)	
  0x413407		4889542448		MOVQ DX, 0x48(SP)	
  0x41340c		488b2c24		MOVQ 0(SP), BP		
  0x413410		4883c408		ADDQ $0x8, SP		
  0x413414		c3			RET			
	buf[i] = byte(val + '0')
  0x413415		e826c60000		CALL runtime.panicindex(SB)	
  0x41341a		0f0b			UD2				
			buf[i] = '.'
  0x41341c		e81fc60000		CALL runtime.panicindex(SB)	
  0x413421		0f0b			UD2				
		buf[i] = byte(val%10 + '0')
  0x413423		e818c60000		CALL runtime.panicindex(SB)	
  0x413428		0f0b			UD2				

TEXT runtime.fmtNSAsMS(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
func fmtNSAsMS(buf []byte, ns uint64) []byte {
  0x413430		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413439		483b6110		CMPQ 0x10(CX), SP	
  0x41343d		0f866c010000		JBE 0x4135af		
  0x413443		4883ec48		SUBQ $0x48, SP		
  0x413447		48896c2440		MOVQ BP, 0x40(SP)	
  0x41344c		488d6c2440		LEAQ 0x40(SP), BP	
  0x413451		488b442468		MOVQ 0x68(SP), AX	
	if ns >= 10e6 {
  0x413456		483d80969800		CMPQ $0x989680, AX	
  0x41345c		0f83d7000000		JAE 0x413539		
	x := ns / 1e3
  0x413462		48d1e8			SHRQ $0x1, AX			
  0x413465		48b93cdf4f8d976e1283	MOVQ $0x83126e978d4fdf3c, CX	
  0x41346f		48f7e1			MULQ CX				
  0x413472		48c1ea08		SHRQ $0x8, DX			
	if x == 0 {
  0x413476		48f7c2ffffffff		TESTQ $-0x1, DX		
  0x41347d		747f			JE 0x4134fe		
  0x41347f		b803000000		MOVL $0x3, AX		
	for x >= 100 {
  0x413484		eb1b			JMP 0x4134a1		
  0x413486		4889c1			MOVQ AX, CX		
  0x413489		4889d0			MOVQ DX, AX		
		x /= 10
  0x41348c		48bbcdcccccccccccccc	MOVQ $0xcccccccccccccccd, BX	
  0x413496		48f7e3			MULQ BX				
  0x413499		48c1ea03		SHRQ $0x3, DX			
		dec--
  0x41349d		488d41ff		LEAQ -0x1(CX), AX	
	for x >= 100 {
  0x4134a1		4883fa64		CMPQ $0x64, DX		
  0x4134a5		73df			JAE 0x413486		
  0x4134a7		488b4c2450		MOVQ 0x50(SP), CX	
	return itoaDiv(buf, x, dec)
  0x4134ac		48890c24		MOVQ CX, 0(SP)			
  0x4134b0		488b4c2458		MOVQ 0x58(SP), CX		
  0x4134b5		48894c2408		MOVQ CX, 0x8(SP)		
  0x4134ba		488b4c2460		MOVQ 0x60(SP), CX		
  0x4134bf		48894c2410		MOVQ CX, 0x10(SP)		
  0x4134c4		4889542418		MOVQ DX, 0x18(SP)		
  0x4134c9		4889442420		MOVQ AX, 0x20(SP)		
  0x4134ce		e87dfeffff		CALL runtime.itoaDiv(SB)	
  0x4134d3		488b442428		MOVQ 0x28(SP), AX		
  0x4134d8		488b4c2430		MOVQ 0x30(SP), CX		
  0x4134dd		488b542438		MOVQ 0x38(SP), DX		
  0x4134e2		4889442470		MOVQ AX, 0x70(SP)		
  0x4134e7		48894c2478		MOVQ CX, 0x78(SP)		
  0x4134ec		4889942480000000	MOVQ DX, 0x80(SP)		
  0x4134f4		488b6c2440		MOVQ 0x40(SP), BP		
  0x4134f9		4883c448		ADDQ $0x48, SP			
  0x4134fd		c3			RET				
  0x4134fe		488b442458		MOVQ 0x58(SP), AX		
		buf[0] = '0'
  0x413503		4885c0			TESTQ AX, AX		
  0x413506		0f869c000000		JBE 0x4135a8		
  0x41350c		488b442450		MOVQ 0x50(SP), AX	
  0x413511		c60030			MOVB $0x30, 0(AX)	
		return buf[:1]
  0x413514		4889442470		MOVQ AX, 0x70(SP)	
  0x413519		48c744247801000000	MOVQ $0x1, 0x78(SP)	
  0x413522		488b442460		MOVQ 0x60(SP), AX	
  0x413527		4889842480000000	MOVQ AX, 0x80(SP)	
  0x41352f		488b6c2440		MOVQ 0x40(SP), BP	
  0x413534		4883c448		ADDQ $0x48, SP		
  0x413538		c3			RET			
  0x413539		4889c1			MOVQ AX, CX		
		return itoaDiv(buf, ns/1e6, 0)
  0x41353c		48b8b6696caf05bd3786	MOVQ $0x8637bd05af6c69b6, AX	
  0x413546		48f7e1			MULQ CX				
  0x413549		48c1ea13		SHRQ $0x13, DX			
  0x41354d		4889542418		MOVQ DX, 0x18(SP)		
  0x413552		488b4c2450		MOVQ 0x50(SP), CX		
  0x413557		48890c24		MOVQ CX, 0(SP)			
  0x41355b		488b4c2458		MOVQ 0x58(SP), CX		
  0x413560		48894c2408		MOVQ CX, 0x8(SP)		
  0x413565		488b4c2460		MOVQ 0x60(SP), CX		
  0x41356a		48894c2410		MOVQ CX, 0x10(SP)		
  0x41356f		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x413578		e8d3fdffff		CALL runtime.itoaDiv(SB)	
  0x41357d		488b4c2438		MOVQ 0x38(SP), CX		
  0x413582		488b542428		MOVQ 0x28(SP), DX		
  0x413587		488b5c2430		MOVQ 0x30(SP), BX		
  0x41358c		4889542470		MOVQ DX, 0x70(SP)		
  0x413591		48895c2478		MOVQ BX, 0x78(SP)		
  0x413596		48898c2480000000	MOVQ CX, 0x80(SP)		
  0x41359e		488b6c2440		MOVQ 0x40(SP), BP		
  0x4135a3		4883c448		ADDQ $0x48, SP			
  0x4135a7		c3			RET				
		buf[0] = '0'
  0x4135a8		e893c40000		CALL runtime.panicindex(SB)	
  0x4135ad		0f0b			UD2				
func fmtNSAsMS(buf []byte, ns uint64) []byte {
  0x4135af		e8bc0f0300		CALL runtime.morestack_noctxt(SB)	
  0x4135b4		e977feffff		JMP runtime.fmtNSAsMS(SB)		

TEXT runtime.(*mTreap).insert(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgclarge.go
func (root *mTreap) insert(span *mspan) {
  0x4135c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4135c9		483b6110		CMPQ 0x10(CX), SP	
  0x4135cd		0f86c6020000		JBE 0x413899		
  0x4135d3		4883ec40		SUBQ $0x40, SP		
  0x4135d7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4135dc		488d6c2438		LEAQ 0x38(SP), BP	
  0x4135e1		488b442450		MOVQ 0x50(SP), AX	
	npages := span.npages
  0x4135e6		488b4820		MOVQ 0x20(AX), CX	
  0x4135ea		488b542448		MOVQ 0x48(SP), DX	
	for t := *pt; t != nil; t = *pt {
  0x4135ef		488b1a			MOVQ 0(DX), BX		
  0x4135f2		4889d6			MOVQ DX, SI		
  0x4135f5		31ff			XORL DI, DI		
  0x4135f7		eb0c			JMP 0x413605		
  0x4135f9		4c8b03			MOVQ 0(BX), R8		
  0x4135fc		4889d7			MOVQ DX, DI		
  0x4135ff		4889da			MOVQ BX, DX		
  0x413602		4c89c3			MOVQ R8, BX		
  0x413605		4885db			TESTQ BX, BX		
  0x413608		744b			JE 0x413655		
		if t.npagesKey < npages {
  0x41360a		488b5318		MOVQ 0x18(BX), DX	
  0x41360e		4839ca			CMPQ CX, DX		
  0x413611		7305			JAE 0x413618		
  0x413613		4889da			MOVQ BX, DX		
			pt = &t.right
  0x413616		ebe1			JMP 0x4135f9		
		} else if t.npagesKey > npages {
  0x413618		760f			JBE 0x413629		
			pt = &t.left
  0x41361a		488d5308		LEAQ 0x8(BX), DX	
  0x41361e		4889d7			MOVQ DX, DI		
  0x413621		4889da			MOVQ BX, DX		
  0x413624		4889fb			MOVQ DI, BX		
	for t := *pt; t != nil; t = *pt {
  0x413627		ebd0			JMP 0x4135f9		
		} else if uintptr(unsafe.Pointer(t.spanKey)) < uintptr(unsafe.Pointer(span)) {
  0x413629		488b5320		MOVQ 0x20(BX), DX	
  0x41362d		4889c7			MOVQ AX, DI		
  0x413630		4839c2			CMPQ AX, DX		
  0x413633		730e			JAE 0x413643		
  0x413635		4889d8			MOVQ BX, AX		
			pt = &t.right
  0x413638		4889da			MOVQ BX, DX		
  0x41363b		4889c3			MOVQ AX, BX		
  0x41363e		4889f8			MOVQ DI, AX		
	for t := *pt; t != nil; t = *pt {
  0x413641		ebdb			JMP 0x41361e		
		} else if uintptr(unsafe.Pointer(t.spanKey)) > uintptr(unsafe.Pointer(span)) {
  0x413643		0f8635020000		JBE 0x41387e		
			pt = &t.left
  0x413649		488d5308		LEAQ 0x8(BX), DX	
  0x41364d		4889d8			MOVQ BX, AX		
  0x413650		4889d3			MOVQ DX, BX		
	for t := *pt; t != nil; t = *pt {
  0x413653		ebe3			JMP 0x413638		
  0x413655		4889542418		MOVQ DX, 0x18(SP)	
  0x41365a		48897c2420		MOVQ DI, 0x20(SP)	
	t := (*treapNode)(mheap_.treapalloc.alloc())
  0x41365f		488d059ac10900		LEAQ runtime.mheap_+13664(SB), AX	
  0x413666		48890424		MOVQ AX, 0(SP)				
  0x41366a		e8d1c3ffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x41366f		488b442408		MOVQ 0x8(SP), AX			
  0x413674		4889442430		MOVQ AX, 0x30(SP)			
	t.left = nil
  0x413679		0f57c0			XORPS X0, X0		
  0x41367c		0f1100			MOVUPS X0, 0(AX)	
	t.parent = nil
  0x41367f		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	t.spanKey = nil
  0x413687		48c7402000000000	MOVQ $0x0, 0x20(AX)	
	t.npagesKey = 0
  0x41368f		48c7401800000000	MOVQ $0x0, 0x18(AX)	
	t.priority = 0
  0x413697		c7402800000000		MOVL $0x0, 0x28(AX)	
  0x41369e		488b4c2450		MOVQ 0x50(SP), CX	
	t.npagesKey = span.npages
  0x4136a3		488b5120		MOVQ 0x20(CX), DX	
  0x4136a7		48895018		MOVQ DX, 0x18(AX)	
	mp := getg().m
  0x4136ab		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x4136b4		488b5230		MOVQ 0x30(DX), DX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x4136b8		8b9a20010000		MOVL 0x120(DX), BX	
  0x4136be		8bb224010000		MOVL 0x124(DX), SI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x4136c4		89b220010000		MOVL SI, 0x120(DX)	
  0x4136ca		89df			MOVL BX, DI		
	s1 ^= s1 << 17
  0x4136cc		c1e311			SHLL $0x11, BX		
  0x4136cf		31fb			XORL DI, BX		
  0x4136d1		89f7			MOVL SI, DI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x4136d3		31de			XORL BX, SI		
  0x4136d5		c1eb07			SHRL $0x7, BX		
  0x4136d8		31f3			XORL SI, BX		
  0x4136da		89fe			MOVL DI, SI		
  0x4136dc		c1ef10			SHRL $0x10, DI		
  0x4136df		31df			XORL BX, DI		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x4136e1		89ba24010000		MOVL DI, 0x124(DX)	
	return s0 + s1
  0x4136e7		8d143e			LEAL 0(SI)(DI*1), DX	
	t.priority = fastrand()
  0x4136ea		895028			MOVL DX, 0x28(AX)	
	t.spanKey = span
  0x4136ed		48894820		MOVQ CX, 0x20(AX)	
  0x4136f1		488b4c2420		MOVQ 0x20(SP), CX	
	t.parent = last
  0x4136f6		48894810		MOVQ CX, 0x10(AX)	
  0x4136fa		488b4c2418		MOVQ 0x18(SP), CX	
	*pt = t // t now at a leaf.
  0x4136ff		488901			MOVQ AX, 0(CX)		
	for t.parent != nil && t.parent.priority > t.priority {
  0x413702		eb05			JMP 0x413709		
  0x413704		488b442430		MOVQ 0x30(SP), AX	
  0x413709		488b4810		MOVQ 0x10(AX), CX	
  0x41370d		4885c9			TESTQ CX, CX		
  0x413710		7456			JE 0x413768		
  0x413712		8b5128			MOVL 0x28(CX), DX	
  0x413715		8b5828			MOVL 0x28(AX), BX	
  0x413718		39da			CMPL BX, DX		
  0x41371a		764c			JBE 0x413768		
		if t != nil && t.spanKey.npages != t.npagesKey {
  0x41371c		488b5020		MOVQ 0x20(AX), DX	
  0x413720		488b5220		MOVQ 0x20(DX), DX	
  0x413724		488b5818		MOVQ 0x18(AX), BX	
  0x413728		4839da			CMPQ BX, DX		
  0x41372b		7560			JNE 0x41378d		
		if t.parent.left == t {
  0x41372d		488b5108		MOVQ 0x8(CX), DX	
  0x413731		4839c2			CMPQ AX, DX		
  0x413734		741d			JE 0x413753		
			if t.parent.right != t {
  0x413736		488b11			MOVQ 0(CX), DX		
  0x413739		4839c2			CMPQ AX, DX		
  0x41373c		7534			JNE 0x413772		
			root.rotateLeft(t.parent)
  0x41373e		48894c2408		MOVQ CX, 0x8(SP)			
  0x413743		488b442448		MOVQ 0x48(SP), AX			
  0x413748		48890424		MOVQ AX, 0(SP)				
  0x41374c		e8df040000		CALL runtime.(*mTreap).rotateLeft(SB)	
  0x413751		ebb1			JMP 0x413704				
			root.rotateRight(t.parent)
  0x413753		48894c2408		MOVQ CX, 0x8(SP)			
  0x413758		488b442448		MOVQ 0x48(SP), AX			
  0x41375d		48890424		MOVQ AX, 0(SP)				
  0x413761		e89a050000		CALL runtime.(*mTreap).rotateRight(SB)	
  0x413766		eb9c			JMP 0x413704				
  0x413768		488b6c2438		MOVQ 0x38(SP), BP			
  0x41376d		4883c440		ADDQ $0x40, SP				
  0x413771		c3			RET					
				throw("treap insert finds a broken treap")
  0x413772		488d05d9930500		LEAQ 0x593d9(IP), AX	
  0x413779		48890424		MOVQ AX, 0(SP)		
  0x41377d		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x413786		e845da0000		CALL runtime.throw(SB)	
  0x41378b		0f0b			UD2			
  0x41378d		48895c2410		MOVQ BX, 0x10(SP)	
			println("runtime: insert t=", t, "t.npagesKey=", t.npagesKey)
  0x413792		e869e30000		CALL runtime.printlock(SB)	
  0x413797		488d05b9770500		LEAQ 0x577b9(IP), AX		
  0x41379e		48890424		MOVQ AX, 0(SP)			
  0x4137a2		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4137ab		e890ec0000		CALL runtime.printstring(SB)	
  0x4137b0		488b442430		MOVQ 0x30(SP), AX		
  0x4137b5		48890424		MOVQ AX, 0(SP)			
  0x4137b9		e842ec0000		CALL runtime.printpointer(SB)	
  0x4137be		488d0535700500		LEAQ 0x57035(IP), AX		
  0x4137c5		48890424		MOVQ AX, 0(SP)			
  0x4137c9		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x4137d2		e869ec0000		CALL runtime.printstring(SB)	
  0x4137d7		488b442410		MOVQ 0x10(SP), AX		
  0x4137dc		48890424		MOVQ AX, 0(SP)			
  0x4137e0		e88be90000		CALL runtime.printuint(SB)	
  0x4137e5		e8a6e50000		CALL runtime.printnl(SB)	
  0x4137ea		e891e30000		CALL runtime.printunlock(SB)	
  0x4137ef		488b442430		MOVQ 0x30(SP), AX		
			println("runtime:      t.spanKey=", t.spanKey, "t.spanKey.npages=", t.spanKey.npages)
  0x4137f4		488b4020		MOVQ 0x20(AX), AX		
  0x4137f8		4889442428		MOVQ AX, 0x28(SP)		
  0x4137fd		488b4820		MOVQ 0x20(AX), CX		
  0x413801		48894c2410		MOVQ CX, 0x10(SP)		
  0x413806		e8f5e20000		CALL runtime.printlock(SB)	
  0x41380b		488d0599820500		LEAQ 0x58299(IP), AX		
  0x413812		48890424		MOVQ AX, 0(SP)			
  0x413816		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x41381f		e81cec0000		CALL runtime.printstring(SB)	
  0x413824		488b442428		MOVQ 0x28(SP), AX		
  0x413829		48890424		MOVQ AX, 0(SP)			
  0x41382d		e8ceeb0000		CALL runtime.printpointer(SB)	
  0x413832		488d05b5750500		LEAQ 0x575b5(IP), AX		
  0x413839		48890424		MOVQ AX, 0(SP)			
  0x41383d		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x413846		e8f5eb0000		CALL runtime.printstring(SB)	
  0x41384b		488b442410		MOVQ 0x10(SP), AX		
  0x413850		48890424		MOVQ AX, 0(SP)			
  0x413854		e817e90000		CALL runtime.printuint(SB)	
  0x413859		e832e50000		CALL runtime.printnl(SB)	
  0x41385e		e81de30000		CALL runtime.printunlock(SB)	
			throw("span and treap sizes do not match?")
  0x413863		488d053a940500		LEAQ 0x5943a(IP), AX	
  0x41386a		48890424		MOVQ AX, 0(SP)		
  0x41386e		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x413877		e854d90000		CALL runtime.throw(SB)	
  0x41387c		0f0b			UD2			
			throw("inserting span already in treap")
  0x41387e		488d05268e0500		LEAQ 0x58e26(IP), AX	
  0x413885		48890424		MOVQ AX, 0(SP)		
  0x413889		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x413892		e839d90000		CALL runtime.throw(SB)	
  0x413897		0f0b			UD2			
func (root *mTreap) insert(span *mspan) {
  0x413899		e8d20c0300		CALL runtime.morestack_noctxt(SB)	
  0x41389e		e91dfdffff		JMP runtime.(*mTreap).insert(SB)	

TEXT runtime.(*mTreap).removeNode(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgclarge.go
func (root *mTreap) removeNode(t *treapNode) {
  0x4138b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4138b9		483b6110		CMPQ 0x10(CX), SP	
  0x4138bd		0f8619010000		JBE 0x4139dc		
  0x4138c3		4883ec18		SUBQ $0x18, SP		
  0x4138c7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4138cc		488d6c2410		LEAQ 0x10(SP), BP	
  0x4138d1		488b442428		MOVQ 0x28(SP), AX	
	if t.spanKey.npages != t.npagesKey {
  0x4138d6		488b4820		MOVQ 0x20(AX), CX	
  0x4138da		488b4920		MOVQ 0x20(CX), CX	
  0x4138de		488b5018		MOVQ 0x18(AX), DX	
  0x4138e2		4839d1			CMPQ DX, CX		
  0x4138e5		0f85d6000000		JNE 0x4139c1		
  0x4138eb		eb05			JMP 0x4138f2		
  0x4138ed		488b442428		MOVQ 0x28(SP), AX	
	for t.right != nil || t.left != nil {
  0x4138f2		488b08			MOVQ 0(AX), CX		
  0x4138f5		4885c9			TESTQ CX, CX		
  0x4138f8		743f			JE 0x413939		
		if t.right == nil || t.left != nil && t.left.priority < t.right.priority {
  0x4138fa		7413			JE 0x41390f		
  0x4138fc		488b5008		MOVQ 0x8(AX), DX	
  0x413900		4885d2			TESTQ DX, DX		
  0x413903		741f			JE 0x413924		
  0x413905		8b5228			MOVL 0x28(DX), DX	
  0x413908		8b4928			MOVL 0x28(CX), CX	
  0x41390b		39ca			CMPL CX, DX		
  0x41390d		7315			JAE 0x413924		
  0x41390f		488b4c2420		MOVQ 0x20(SP), CX	
			root.rotateRight(t)
  0x413914		48890c24		MOVQ CX, 0(SP)				
  0x413918		4889442408		MOVQ AX, 0x8(SP)			
  0x41391d		e8de030000		CALL runtime.(*mTreap).rotateRight(SB)	
  0x413922		ebc9			JMP 0x4138ed				
  0x413924		488b4c2420		MOVQ 0x20(SP), CX			
			root.rotateLeft(t)
  0x413929		48890c24		MOVQ CX, 0(SP)				
  0x41392d		4889442408		MOVQ AX, 0x8(SP)			
  0x413932		e8f9020000		CALL runtime.(*mTreap).rotateLeft(SB)	
  0x413937		ebb4			JMP 0x4138ed				
	for t.right != nil || t.left != nil {
  0x413939		488b5008		MOVQ 0x8(AX), DX	
  0x41393d		4885d2			TESTQ DX, DX		
  0x413940		7405			JE 0x413947		
  0x413942		4885c9			TESTQ CX, CX		
  0x413945		ebb3			JMP 0x4138fa		
	if t.parent != nil {
  0x413947		488b4810		MOVQ 0x10(AX), CX	
  0x41394b		4885c9			TESTQ CX, CX		
  0x41394e		7463			JE 0x4139b3		
		if t.parent.left == t {
  0x413950		488b5108		MOVQ 0x8(CX), DX	
  0x413954		4839c2			CMPQ AX, DX		
  0x413957		7551			JNE 0x4139aa		
			t.parent.left = nil
  0x413959		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	t.spanKey = nil
  0x413961		48c7402000000000	MOVQ $0x0, 0x20(AX)	
	t.npagesKey = 0
  0x413969		48c7401800000000	MOVQ $0x0, 0x18(AX)	
	f.inuse -= f.size
  0x413971		488d0d88be0900		LEAQ runtime.mheap_+13664(SB), CX	
  0x413978		8401			TESTB AL, 0(CX)				
  0x41397a		488b0dafbe0900		MOVQ runtime.mheap_+13712(SB), CX	
  0x413981		482b0d78be0900		SUBQ runtime.mheap_+13664(SB), CX	
  0x413988		48890da1be0900		MOVQ CX, runtime.mheap_+13712(SB)	
	v.next = f.list
  0x41398f		488b0d82be0900		MOVQ runtime.mheap_+13688(SB), CX	
  0x413996		488908			MOVQ CX, 0(AX)				
	f.list = v
  0x413999		48890578be0900		MOVQ AX, runtime.mheap_+13688(SB)	
  0x4139a0		488b6c2410		MOVQ 0x10(SP), BP			
  0x4139a5		4883c418		ADDQ $0x18, SP				
  0x4139a9		c3			RET					
			t.parent.right = nil
  0x4139aa		48c70100000000		MOVQ $0x0, 0(CX)	
  0x4139b1		ebae			JMP 0x413961		
  0x4139b3		488b4c2420		MOVQ 0x20(SP), CX	
		root.treap = nil
  0x4139b8		48c70100000000		MOVQ $0x0, 0(CX)	
  0x4139bf		eba0			JMP 0x413961		
		throw("span and treap node npages do not match")
  0x4139c1		488d0528980500		LEAQ 0x59828(IP), AX	
  0x4139c8		48890424		MOVQ AX, 0(SP)		
  0x4139cc		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x4139d5		e8f6d70000		CALL runtime.throw(SB)	
  0x4139da		0f0b			UD2			
func (root *mTreap) removeNode(t *treapNode) {
  0x4139dc		e88f0b0300		CALL runtime.morestack_noctxt(SB)	
  0x4139e1		e9cafeffff		JMP runtime.(*mTreap).removeNode(SB)	

TEXT runtime.(*mTreap).remove(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgclarge.go
func (root *mTreap) remove(npages uintptr) *mspan {
  0x4139f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4139f9		483b6110		CMPQ 0x10(CX), SP	
  0x4139fd		0f86a3000000		JBE 0x413aa6		
  0x413a03		4883ec20		SUBQ $0x20, SP		
  0x413a07		48896c2418		MOVQ BP, 0x18(SP)	
  0x413a0c		488d6c2418		LEAQ 0x18(SP), BP	
  0x413a11		488b442428		MOVQ 0x28(SP), AX	
	t := root.treap
  0x413a16		488b08			MOVQ 0(AX), CX		
  0x413a19		488b542430		MOVQ 0x30(SP), DX	
	for t != nil {
  0x413a1e		4885c9			TESTQ CX, CX		
  0x413a21		7455			JE 0x413a78		
		if t.spanKey == nil {
  0x413a23		488b5920		MOVQ 0x20(CX), BX	
  0x413a27		4885db			TESTQ BX, BX		
  0x413a2a		745f			JE 0x413a8b		
		if t.npagesKey < npages {
  0x413a2c		488b7118		MOVQ 0x18(CX), SI	
  0x413a30		4839d6			CMPQ DX, SI		
  0x413a33		7305			JAE 0x413a3a		
			t = t.right
  0x413a35		488b09			MOVQ 0(CX), CX		
  0x413a38		ebe4			JMP 0x413a1e		
  0x413a3a		48895c2410		MOVQ BX, 0x10(SP)	
		} else if t.left != nil && t.left.npagesKey >= npages {
  0x413a3f		488b7108		MOVQ 0x8(CX), SI	
  0x413a43		4885f6			TESTQ SI, SI		
  0x413a46		740e			JE 0x413a56		
  0x413a48		488b7e18		MOVQ 0x18(SI), DI	
  0x413a4c		4839d7			CMPQ DX, DI		
  0x413a4f		7205			JB 0x413a56		
  0x413a51		4889f1			MOVQ SI, CX		
	for t != nil {
  0x413a54		ebc8			JMP 0x413a1e		
			root.removeNode(t)
  0x413a56		48890424		MOVQ AX, 0(SP)				
  0x413a5a		48894c2408		MOVQ CX, 0x8(SP)			
  0x413a5f		e84cfeffff		CALL runtime.(*mTreap).removeNode(SB)	
			return result
  0x413a64		488b442410		MOVQ 0x10(SP), AX	
  0x413a69		4889442438		MOVQ AX, 0x38(SP)	
  0x413a6e		488b6c2418		MOVQ 0x18(SP), BP	
  0x413a73		4883c420		ADDQ $0x20, SP		
  0x413a77		c3			RET			
	return nil
  0x413a78		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x413a81		488b6c2418		MOVQ 0x18(SP), BP	
  0x413a86		4883c420		ADDQ $0x20, SP		
  0x413a8a		c3			RET			
			throw("treap node with nil spanKey found")
  0x413a8b		488d05e1900500		LEAQ 0x590e1(IP), AX	
  0x413a92		48890424		MOVQ AX, 0(SP)		
  0x413a96		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x413a9f		e82cd70000		CALL runtime.throw(SB)	
  0x413aa4		0f0b			UD2			
func (root *mTreap) remove(npages uintptr) *mspan {
  0x413aa6		e8c50a0300		CALL runtime.morestack_noctxt(SB)	
  0x413aab		e940ffffff		JMP runtime.(*mTreap).remove(SB)	

TEXT runtime.(*mTreap).removeSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgclarge.go
func (root *mTreap) removeSpan(span *mspan) {
  0x413ab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413ab9		483b6110		CMPQ 0x10(CX), SP	
  0x413abd		7676			JBE 0x413b35		
  0x413abf		4883ec18		SUBQ $0x18, SP		
  0x413ac3		48896c2410		MOVQ BP, 0x10(SP)	
  0x413ac8		488d6c2410		LEAQ 0x10(SP), BP	
  0x413acd		488b442428		MOVQ 0x28(SP), AX	
	npages := span.npages
  0x413ad2		488b4820		MOVQ 0x20(AX), CX	
  0x413ad6		488b542420		MOVQ 0x20(SP), DX	
	t := root.treap
  0x413adb		488b1a			MOVQ 0(DX), BX		
	for t.spanKey != span {
  0x413ade		488b7320		MOVQ 0x20(BX), SI	
  0x413ae2		4839c6			CMPQ AX, SI		
  0x413ae5		7436			JE 0x413b1d		
		if t.npagesKey < npages {
  0x413ae7		488b7b18		MOVQ 0x18(BX), DI	
  0x413aeb		4839cf			CMPQ CX, DI		
  0x413aee		7305			JAE 0x413af5		
			t = t.right
  0x413af0		488b1b			MOVQ 0(BX), BX		
  0x413af3		ebe9			JMP 0x413ade		
		} else if t.npagesKey > npages {
  0x413af5		7606			JBE 0x413afd		
			t = t.left
  0x413af7		488b5b08		MOVQ 0x8(BX), BX	
  0x413afb		ebe1			JMP 0x413ade		
		} else if uintptr(unsafe.Pointer(t.spanKey)) < uintptr(unsafe.Pointer(span)) {
  0x413afd		4889c7			MOVQ AX, DI		
  0x413b00		4839c6			CMPQ AX, SI		
  0x413b03		730b			JAE 0x413b10		
			t = t.right
  0x413b05		488b03			MOVQ 0(BX), AX		
  0x413b08		4889c3			MOVQ AX, BX		
  0x413b0b		4889f8			MOVQ DI, AX		
	for t.spanKey != span {
  0x413b0e		ebce			JMP 0x413ade		
		} else if uintptr(unsafe.Pointer(t.spanKey)) > uintptr(unsafe.Pointer(span)) {
  0x413b10		7606			JBE 0x413b18		
			t = t.left
  0x413b12		488b4308		MOVQ 0x8(BX), AX	
  0x413b16		ebf0			JMP 0x413b08		
  0x413b18		4889d8			MOVQ BX, AX		
		} else if uintptr(unsafe.Pointer(t.spanKey)) > uintptr(unsafe.Pointer(span)) {
  0x413b1b		ebeb			JMP 0x413b08		
	root.removeNode(t)
  0x413b1d		48891424		MOVQ DX, 0(SP)				
  0x413b21		48895c2408		MOVQ BX, 0x8(SP)			
  0x413b26		e885fdffff		CALL runtime.(*mTreap).removeNode(SB)	
}
  0x413b2b		488b6c2410		MOVQ 0x10(SP), BP	
  0x413b30		4883c418		ADDQ $0x18, SP		
  0x413b34		c3			RET			
func (root *mTreap) removeSpan(span *mspan) {
  0x413b35		e8360a0300		CALL runtime.morestack_noctxt(SB)	
  0x413b3a		e971ffffff		JMP runtime.(*mTreap).removeSpan(SB)	

TEXT runtime.scavengetreap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgclarge.go
func scavengetreap(treap *treapNode, now, limit uint64) uintptr {
  0x413b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413b49		483b6110		CMPQ 0x10(CX), SP	
  0x413b4d		0f86c9000000		JBE 0x413c1c		
  0x413b53		4883ec30		SUBQ $0x30, SP		
  0x413b57		48896c2428		MOVQ BP, 0x28(SP)	
  0x413b5c		488d6c2428		LEAQ 0x28(SP), BP	
  0x413b61		488b442438		MOVQ 0x38(SP), AX	
	if treap == nil {
  0x413b66		4885c0			TESTQ AX, AX		
  0x413b69		0f849a000000		JE 0x413c09		
	return scavengeTreapNode(treap, now, limit) +
  0x413b6f		48890424		MOVQ AX, 0(SP)				
  0x413b73		488b4c2440		MOVQ 0x40(SP), CX			
  0x413b78		48894c2408		MOVQ CX, 0x8(SP)			
  0x413b7d		488b542448		MOVQ 0x48(SP), DX			
  0x413b82		4889542410		MOVQ DX, 0x10(SP)			
  0x413b87		e8847f0000		CALL runtime.scavengeTreapNode(SB)	
  0x413b8c		488b442418		MOVQ 0x18(SP), AX			
  0x413b91		4889442420		MOVQ AX, 0x20(SP)			
  0x413b96		488b4c2438		MOVQ 0x38(SP), CX			
		scavengetreap(treap.left, now, limit) +
  0x413b9b		488b5108		MOVQ 0x8(CX), DX		
  0x413b9f		48891424		MOVQ DX, 0(SP)			
  0x413ba3		488b542440		MOVQ 0x40(SP), DX		
  0x413ba8		4889542408		MOVQ DX, 0x8(SP)		
  0x413bad		488b5c2448		MOVQ 0x48(SP), BX		
  0x413bb2		48895c2410		MOVQ BX, 0x10(SP)		
  0x413bb7		e884ffffff		CALL runtime.scavengetreap(SB)	
  0x413bbc		488b442420		MOVQ 0x20(SP), AX		
	return scavengeTreapNode(treap, now, limit) +
  0x413bc1		4803442418		ADDQ 0x18(SP), AX	
  0x413bc6		4889442420		MOVQ AX, 0x20(SP)	
  0x413bcb		488b4c2438		MOVQ 0x38(SP), CX	
		scavengetreap(treap.right, now, limit)
  0x413bd0		488b09			MOVQ 0(CX), CX			
  0x413bd3		48890c24		MOVQ CX, 0(SP)			
  0x413bd7		488b4c2440		MOVQ 0x40(SP), CX		
  0x413bdc		48894c2408		MOVQ CX, 0x8(SP)		
  0x413be1		488b4c2448		MOVQ 0x48(SP), CX		
  0x413be6		48894c2410		MOVQ CX, 0x10(SP)		
  0x413beb		e850ffffff		CALL runtime.scavengetreap(SB)	
  0x413bf0		488b442420		MOVQ 0x20(SP), AX		
		scavengetreap(treap.left, now, limit) +
  0x413bf5		4803442418		ADDQ 0x18(SP), AX	
	return scavengeTreapNode(treap, now, limit) +
  0x413bfa		4889442450		MOVQ AX, 0x50(SP)	
  0x413bff		488b6c2428		MOVQ 0x28(SP), BP	
  0x413c04		4883c430		ADDQ $0x30, SP		
  0x413c08		c3			RET			
		return 0
  0x413c09		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x413c12		488b6c2428		MOVQ 0x28(SP), BP	
  0x413c17		4883c430		ADDQ $0x30, SP		
  0x413c1b		c3			RET			
func scavengetreap(treap *treapNode, now, limit uint64) uintptr {
  0x413c1c		e84f090300		CALL runtime.morestack_noctxt(SB)	
  0x413c21		e91affffff		JMP runtime.scavengetreap(SB)		

TEXT runtime.(*mTreap).rotateLeft(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgclarge.go
func (root *mTreap) rotateLeft(x *treapNode) {
  0x413c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413c39		483b6110		CMPQ 0x10(CX), SP	
  0x413c3d		0f86a4000000		JBE 0x413ce7		
  0x413c43		4883ec18		SUBQ $0x18, SP		
  0x413c47		48896c2410		MOVQ BP, 0x10(SP)	
  0x413c4c		488d6c2410		LEAQ 0x10(SP), BP	
  0x413c51		488b442428		MOVQ 0x28(SP), AX	
	a, y := x.left, x.right
  0x413c56		488b08			MOVQ 0(AX), CX		
	p := x.parent
  0x413c59		488b5010		MOVQ 0x10(AX), DX	
	a, y := x.left, x.right
  0x413c5d		488b5808		MOVQ 0x8(AX), BX	
	b, c := y.left, y.right
  0x413c61		488b7108		MOVQ 0x8(CX), SI	
  0x413c65		488b39			MOVQ 0(CX), DI		
	y.left = x
  0x413c68		48894108		MOVQ AX, 0x8(CX)	
	x.parent = y
  0x413c6c		48894810		MOVQ CX, 0x10(AX)	
	y.right = c
  0x413c70		488939			MOVQ DI, 0(CX)		
	if c != nil {
  0x413c73		4885ff			TESTQ DI, DI		
  0x413c76		7404			JE 0x413c7c		
		c.parent = y
  0x413c78		48894f10		MOVQ CX, 0x10(DI)	
	x.left = a
  0x413c7c		48895808		MOVQ BX, 0x8(AX)	
	if a != nil {
  0x413c80		4885db			TESTQ BX, BX		
  0x413c83		7404			JE 0x413c89		
		a.parent = x
  0x413c85		48894310		MOVQ AX, 0x10(BX)	
	x.right = b
  0x413c89		488930			MOVQ SI, 0(AX)		
	if b != nil {
  0x413c8c		4885f6			TESTQ SI, SI		
  0x413c8f		7404			JE 0x413c95		
		b.parent = x
  0x413c91		48894610		MOVQ AX, 0x10(SI)	
	y.parent = p
  0x413c95		48895110		MOVQ DX, 0x10(CX)	
	if p == nil {
  0x413c99		4885d2			TESTQ DX, DX		
  0x413c9c		7424			JE 0x413cc2		
	} else if p.left == x {
  0x413c9e		488b5a08		MOVQ 0x8(DX), BX	
  0x413ca2		4839c3			CMPQ AX, BX		
  0x413ca5		750e			JNE 0x413cb5		
		p.left = y
  0x413ca7		48894a08		MOVQ CX, 0x8(DX)	
  0x413cab		488b6c2410		MOVQ 0x10(SP), BP	
  0x413cb0		4883c418		ADDQ $0x18, SP		
  0x413cb4		c3			RET			
		if p.right != x {
  0x413cb5		488b1a			MOVQ 0(DX), BX		
  0x413cb8		4839c3			CMPQ AX, BX		
  0x413cbb		750f			JNE 0x413ccc		
		p.right = y
  0x413cbd		48890a			MOVQ CX, 0(DX)		
  0x413cc0		ebe9			JMP 0x413cab		
  0x413cc2		488b442420		MOVQ 0x20(SP), AX	
		root.treap = y
  0x413cc7		488908			MOVQ CX, 0(AX)		
  0x413cca		ebdf			JMP 0x413cab		
			throw("large span treap rotateLeft")
  0x413ccc		488d05c9800500		LEAQ 0x580c9(IP), AX	
  0x413cd3		48890424		MOVQ AX, 0(SP)		
  0x413cd7		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x413ce0		e8ebd40000		CALL runtime.throw(SB)	
  0x413ce5		0f0b			UD2			
func (root *mTreap) rotateLeft(x *treapNode) {
  0x413ce7		e884080300		CALL runtime.morestack_noctxt(SB)	
  0x413cec		e93fffffff		JMP runtime.(*mTreap).rotateLeft(SB)	

TEXT runtime.(*mTreap).rotateRight(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgclarge.go
func (root *mTreap) rotateRight(y *treapNode) {
  0x413d00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413d09		483b6110		CMPQ 0x10(CX), SP	
  0x413d0d		0f86a0000000		JBE 0x413db3		
  0x413d13		4883ec18		SUBQ $0x18, SP		
  0x413d17		48896c2410		MOVQ BP, 0x10(SP)	
  0x413d1c		488d6c2410		LEAQ 0x10(SP), BP	
  0x413d21		488b442428		MOVQ 0x28(SP), AX	
	x, c := y.left, y.right
  0x413d26		488b4808		MOVQ 0x8(AX), CX	
	p := y.parent
  0x413d2a		488b5010		MOVQ 0x10(AX), DX	
	x, c := y.left, y.right
  0x413d2e		488b18			MOVQ 0(AX), BX		
	a, b := x.left, x.right
  0x413d31		488b7108		MOVQ 0x8(CX), SI	
  0x413d35		488b39			MOVQ 0(CX), DI		
	if a != nil {
  0x413d38		4885f6			TESTQ SI, SI		
  0x413d3b		7404			JE 0x413d41		
		a.parent = x
  0x413d3d		48894e10		MOVQ CX, 0x10(SI)	
	x.right = y
  0x413d41		488901			MOVQ AX, 0(CX)		
	y.parent = x
  0x413d44		48894810		MOVQ CX, 0x10(AX)	
	y.left = b
  0x413d48		48897808		MOVQ DI, 0x8(AX)	
	if b != nil {
  0x413d4c		4885ff			TESTQ DI, DI		
  0x413d4f		7404			JE 0x413d55		
		b.parent = y
  0x413d51		48894710		MOVQ AX, 0x10(DI)	
	y.right = c
  0x413d55		488918			MOVQ BX, 0(AX)		
	if c != nil {
  0x413d58		4885db			TESTQ BX, BX		
  0x413d5b		7404			JE 0x413d61		
		c.parent = y
  0x413d5d		48894310		MOVQ AX, 0x10(BX)	
	x.parent = p
  0x413d61		48895110		MOVQ DX, 0x10(CX)	
	if p == nil {
  0x413d65		4885d2			TESTQ DX, DX		
  0x413d68		7424			JE 0x413d8e		
	} else if p.left == y {
  0x413d6a		488b5a08		MOVQ 0x8(DX), BX	
  0x413d6e		4839c3			CMPQ AX, BX		
  0x413d71		750e			JNE 0x413d81		
		p.left = x
  0x413d73		48894a08		MOVQ CX, 0x8(DX)	
  0x413d77		488b6c2410		MOVQ 0x10(SP), BP	
  0x413d7c		4883c418		ADDQ $0x18, SP		
  0x413d80		c3			RET			
		if p.right != y {
  0x413d81		488b1a			MOVQ 0(DX), BX		
  0x413d84		4839c3			CMPQ AX, BX		
  0x413d87		750f			JNE 0x413d98		
		p.right = x
  0x413d89		48890a			MOVQ CX, 0(DX)		
  0x413d8c		ebe9			JMP 0x413d77		
  0x413d8e		488b442420		MOVQ 0x20(SP), AX	
		root.treap = x
  0x413d93		488908			MOVQ CX, 0(AX)		
  0x413d96		ebdf			JMP 0x413d77		
			throw("large span treap rotateRight")
  0x413d98		488d0587830500		LEAQ 0x58387(IP), AX	
  0x413d9f		48890424		MOVQ AX, 0(SP)		
  0x413da3		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x413dac		e81fd40000		CALL runtime.throw(SB)	
  0x413db1		0f0b			UD2			
func (root *mTreap) rotateRight(y *treapNode) {
  0x413db3		e8b8070300		CALL runtime.morestack_noctxt(SB)	
  0x413db8		e943ffffff		JMP runtime.(*mTreap).rotateRight(SB)	

TEXT runtime.gcMarkRootPrepare(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
	if gcphase == _GCmarktermination {
  0x413dc0		8b0516fb0a00		MOVL runtime.gcphase(SB), AX	
  0x413dc6		83f802			CMPL $0x2, AX			
  0x413dc9		0f8581010000		JNE 0x413f50			
		work.nFlushCacheRoots = int(gomaxprocs)
  0x413dcf		4863050afb0a00		MOVSXD runtime.gomaxprocs(SB), AX	
  0x413dd6		4889057b400900		MOVQ AX, runtime.work+184(SB)		
	work.nBSSRoots = 0
  0x413ddd		0f57c0			XORPS X0, X0			
  0x413de0		0f110579400900		MOVUPS X0, runtime.work+192(SB)	
	if !work.markrootDone {
  0x413de7		0fb60592400900		MOVZX runtime.work+224(SB), AX	
  0x413dee		84c0			TESTL AL, AL			
  0x413df0		0f85aa000000		JNE 0x413ea0			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x413df6		488b057b380900		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x413dfd		4885c0			TESTQ AX, AX		
  0x413e00		0f8441010000		JE 0x413f47		
	return *p
  0x413e06		488b4808		MOVQ 0x8(AX), CX	
  0x413e0a		488b00			MOVQ 0(AX), AX		
		for _, datap := range activeModules() {
  0x413e0d		31d2			XORL DX, DX		
  0x413e0f		eb03			JMP 0x413e14		
  0x413e11		48ffc2			INCQ DX			
  0x413e14		4839ca			CMPQ CX, DX		
  0x413e17		7d32			JGE 0x413e4b		
  0x413e19		488b1cd0		MOVQ 0(AX)(DX*8), BX	
			nDataRoots := nBlocks(datap.edata - datap.data)
  0x413e1d		488bb388000000		MOVQ 0x88(BX), SI	
  0x413e24		482bb380000000		SUBQ 0x80(BX), SI	
			if nDataRoots > work.nDataRoots {
  0x413e2b		488b1d2e400900		MOVQ runtime.work+192(SB), BX	
		return int((bytes + rootBlockBytes - 1) / rootBlockBytes)
  0x413e32		4881c6ffff0300		ADDQ $0x3ffff, SI	
  0x413e39		48c1ee12		SHRQ $0x12, SI		
			if nDataRoots > work.nDataRoots {
  0x413e3d		4839de			CMPQ BX, SI		
  0x413e40		7ecf			JLE 0x413e11		
				work.nDataRoots = nDataRoots
  0x413e42		48893517400900		MOVQ SI, runtime.work+192(SB)	
  0x413e49		ebc6			JMP 0x413e11			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x413e4b		488b0526380900		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x413e52		4885c0			TESTQ AX, AX		
  0x413e55		0f84e3000000		JE 0x413f3e		
	return *p
  0x413e5b		488b08			MOVQ 0(AX), CX		
  0x413e5e		488b4008		MOVQ 0x8(AX), AX	
		for _, datap := range activeModules() {
  0x413e62		31d2			XORL DX, DX		
  0x413e64		eb03			JMP 0x413e69		
  0x413e66		48ffc2			INCQ DX			
  0x413e69		4839c2			CMPQ AX, DX		
  0x413e6c		7d32			JGE 0x413ea0		
  0x413e6e		488b1cd1		MOVQ 0(CX)(DX*8), BX	
			nBSSRoots := nBlocks(datap.ebss - datap.bss)
  0x413e72		488bb398000000		MOVQ 0x98(BX), SI	
  0x413e79		482bb390000000		SUBQ 0x90(BX), SI	
			if nBSSRoots > work.nBSSRoots {
  0x413e80		488b1de13f0900		MOVQ runtime.work+200(SB), BX	
		return int((bytes + rootBlockBytes - 1) / rootBlockBytes)
  0x413e87		4881c6ffff0300		ADDQ $0x3ffff, SI	
  0x413e8e		48c1ee12		SHRQ $0x12, SI		
			if nBSSRoots > work.nBSSRoots {
  0x413e92		4839de			CMPQ BX, SI		
  0x413e95		7ecf			JLE 0x413e66		
				work.nBSSRoots = nBSSRoots
  0x413e97		488935ca3f0900		MOVQ SI, runtime.work+200(SB)	
  0x413e9e		ebc6			JMP 0x413e66			
	if !work.markrootDone {
  0x413ea0		0fb605d93f0900		MOVZX runtime.work+224(SB), AX	
  0x413ea7		84c0			TESTL AL, AL			
  0x413ea9		7457			JE 0x413f02			
		work.nStackRoots = 0
  0x413eab		0f1105be3f0900		MOVUPS X0, runtime.work+208(SB)	
		if debug.gcrescanstacks > 0 {
  0x413eb2		8b0520fc0a00		MOVL runtime.debug+24(SB), AX	
  0x413eb8		85c0			TESTL AX, AX			
  0x413eba		7e0e			JLE 0x413eca			
			work.nStackRoots = int(atomic.Loaduintptr(&allglen))
  0x413ebc		488b054dfa0a00		MOVQ runtime.allglen(SB), AX	
  0x413ec3		488905ae3f0900		MOVQ AX, runtime.work+216(SB)	
	work.markrootNext = 0
  0x413eca		c705543f090000000000	MOVL $0x0, runtime.work+136(SB)	
	work.markrootJobs = uint32(fixedRootCount + work.nFlushCacheRoots + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)
  0x413ed4		488b057d3f0900		MOVQ runtime.work+184(SB), AX	
  0x413edb		4803057e3f0900		ADDQ runtime.work+192(SB), AX	
  0x413ee2		4803057f3f0900		ADDQ runtime.work+200(SB), AX	
  0x413ee9		480305803f0900		ADDQ runtime.work+208(SB), AX	
  0x413ef0		480305813f0900		ADDQ runtime.work+216(SB), AX	
  0x413ef7		4883c002		ADDQ $0x2, AX			
  0x413efb		89052b3f0900		MOVL AX, runtime.work+140(SB)	
}
  0x413f01		c3			RET			
		work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/2%2].numBlocks()
  0x413f02		8b05b8930900		MOVL runtime.mheap_+4128(SB), AX	
  0x413f08		d1e8			SHRL $0x1, AX				
  0x413f0a		83e001			ANDL $0x1, AX				
  0x413f0d		488d0480		LEAQ 0(AX)(AX*4), AX			
	return int((atomic.Load(&b.index) + gcSweepBlockEntries - 1) / gcSweepBlockEntries)
  0x413f11		488d0de8930900		LEAQ runtime.mheap_+4192(SB), CX	
  0x413f18		488d44c120		LEAQ 0x20(CX)(AX*8), AX			
  0x413f1d		8b00			MOVL 0(AX), AX				
  0x413f1f		05ff010000		ADDL $0x1ff, AX				
  0x413f24		c1e809			SHRL $0x9, AX				
		work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/2%2].numBlocks()
  0x413f27		488905423f0900		MOVQ AX, runtime.work+208(SB)	
		work.nStackRoots = int(atomic.Loaduintptr(&allglen))
  0x413f2e		488b05dbf90a00		MOVQ runtime.allglen(SB), AX	
  0x413f35		4889053c3f0900		MOVQ AX, runtime.work+216(SB)	
  0x413f3c		eb8c			JMP 0x413eca			
  0x413f3e		31c9			XORL CX, CX			
  0x413f40		31c0			XORL AX, AX			
		for _, datap := range activeModules() {
  0x413f42		e91bffffff		JMP 0x413e62		
  0x413f47		31c9			XORL CX, CX		
  0x413f49		31c0			XORL AX, AX		
		for _, datap := range activeModules() {
  0x413f4b		e9bdfeffff		JMP 0x413e0d		
		work.nFlushCacheRoots = 0
  0x413f50		48c705fd3e090000000000	MOVQ $0x0, runtime.work+184(SB)	
  0x413f5b		e97dfeffff		JMP 0x413ddd			

TEXT runtime.gcMarkRootCheck(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcMarkRootCheck() {
  0x413f60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413f69		483b6110		CMPQ 0x10(CX), SP	
  0x413f6d		0f8689020000		JBE 0x4141fc		
  0x413f73		4883ec38		SUBQ $0x38, SP		
  0x413f77		48896c2430		MOVQ BP, 0x30(SP)	
  0x413f7c		488d6c2430		LEAQ 0x30(SP), BP	
	if work.markrootNext < work.markrootJobs {
  0x413f81		8b05a13e0900		MOVL runtime.work+136(SB), AX	
  0x413f87		8b0d9f3e0900		MOVL runtime.work+140(SB), CX	
  0x413f8d		39c8			CMPL CX, AX			
  0x413f8f		0f82ee010000		JB 0x414183			
	lock(&allglock)
  0x413f95		488d057cf90a00		LEAQ runtime.allglock(SB), AX	
  0x413f9c		48890424		MOVQ AX, 0(SP)			
  0x413fa0		e87b55ffff		CALL runtime.lock(SB)		
	if gcphase == _GCmarktermination && debug.gcrescanstacks > 0 {
  0x413fa5		8b0531f90a00		MOVL runtime.gcphase(SB), AX	
  0x413fab		83f802			CMPL $0x2, AX			
  0x413fae		7565			JNE 0x414015			
  0x413fb0		8b0522fb0a00		MOVL runtime.debug+24(SB), AX	
  0x413fb6		85c0			TESTL AX, AX			
  0x413fb8		7e5b			JLE 0x414015			
  0x413fba		31c0			XORL AX, AX			
		for i := 0; i < len(allgs); i++ {
  0x413fbc		eb03			JMP 0x413fc1			
  0x413fbe		48ffc0			INCQ AX				
  0x413fc1		488b0dd0360900		MOVQ runtime.allgs+8(SB), CX	
  0x413fc8		488b15c1360900		MOVQ runtime.allgs(SB), DX	
  0x413fcf		4839c8			CMPQ CX, AX			
  0x413fd2		7d27			JGE 0x413ffb			
			gp = allgs[i]
  0x413fd4		488b0cc2		MOVQ 0(DX)(AX*8), CX	
			if !(gp.gcscandone && gp.gcscanvalid) && readgstatus(gp) != _Gdead {
  0x413fd8		0fb691c3000000		MOVZX 0xc3(CX), DX	
  0x413fdf		84d2			TESTL DL, DL		
  0x413fe1		740b			JE 0x413fee		
  0x413fe3		0fb691c4000000		MOVZX 0xc4(CX), DX	
  0x413fea		84d2			TESTL DL, DL		
  0x413fec		75d0			JNE 0x413fbe		
	return atomic.Load(&gp.atomicstatus)
  0x413fee		8b9190000000		MOVL 0x90(CX), DX	
			if !(gp.gcscandone && gp.gcscanvalid) && readgstatus(gp) != _Gdead {
  0x413ff4		83fa06			CMPL $0x6, DX		
  0x413ff7		7555			JNE 0x41404e		
  0x413ff9		ebc3			JMP 0x413fbe		
	unlock(&allglock)
  0x413ffb		488d0516f90a00		LEAQ runtime.allglock(SB), AX	
  0x414002		48890424		MOVQ AX, 0(SP)			
  0x414006		e8b556ffff		CALL runtime.unlock(SB)		
	return
  0x41400b		488b6c2430		MOVQ 0x30(SP), BP	
  0x414010		4883c438		ADDQ $0x38, SP		
  0x414014		c3			RET			
  0x414015		31c0			XORL AX, AX		
		for i := 0; i < work.nStackRoots; i++ {
  0x414017		eb03			JMP 0x41401c			
  0x414019		48ffc0			INCQ AX				
  0x41401c		488b0d553e0900		MOVQ runtime.work+216(SB), CX	
  0x414023		4839c8			CMPQ CX, AX			
  0x414026		7dd3			JGE 0x413ffb			
			gp = allgs[i]
  0x414028		488b0d61360900		MOVQ runtime.allgs(SB), CX	
  0x41402f		488b1562360900		MOVQ runtime.allgs+8(SB), DX	
  0x414036		4839d0			CMPQ DX, AX			
  0x414039		0f833d010000		JAE 0x41417c			
  0x41403f		488b0cc1		MOVQ 0(CX)(AX*8), CX		
			if !gp.gcscandone {
  0x414043		0fb691c3000000		MOVZX 0xc3(CX), DX	
  0x41404a		84d2			TESTL DL, DL		
  0x41404c		75cb			JNE 0x414019		
  0x41404e		48894c2428		MOVQ CX, 0x28(SP)	
	return atomic.Load(&gp.atomicstatus)
  0x414053		8b8190000000		MOVL 0x90(CX), AX	
  0x414059		89442414		MOVL AX, 0x14(SP)	
	println("gp", gp, "goid", gp.goid,
  0x41405d		488b9198000000		MOVQ 0x98(CX), DX	
  0x414064		4889542420		MOVQ DX, 0x20(SP)	
		"gcscandone", gp.gcscandone,
  0x414069		0fb699c3000000		MOVZX 0xc3(CX), BX	
  0x414070		885c2413		MOVB BL, 0x13(SP)	
		"gcscanvalid", gp.gcscanvalid)
  0x414074		0fb6b1c4000000		MOVZX 0xc4(CX), SI	
  0x41407b		4088742412		MOVB SI, 0x12(SP)	
	println("gp", gp, "goid", gp.goid,
  0x414080		e87bda0000		CALL runtime.printlock(SB)	
  0x414085		488d05225c0500		LEAQ 0x55c22(IP), AX		
  0x41408c		48890424		MOVQ AX, 0(SP)			
  0x414090		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x414099		e8a2e30000		CALL runtime.printstring(SB)	
  0x41409e		488b442428		MOVQ 0x28(SP), AX		
  0x4140a3		48890424		MOVQ AX, 0(SP)			
  0x4140a7		e854e30000		CALL runtime.printpointer(SB)	
  0x4140ac		488d05525d0500		LEAQ 0x55d52(IP), AX		
  0x4140b3		48890424		MOVQ AX, 0(SP)			
  0x4140b7		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x4140c0		e87be30000		CALL runtime.printstring(SB)	
  0x4140c5		488b442420		MOVQ 0x20(SP), AX		
  0x4140ca		48890424		MOVQ AX, 0(SP)			
  0x4140ce		e8ade10000		CALL runtime.printint(SB)	
  0x4140d3		488d050d5f0500		LEAQ 0x55f0d(IP), AX		
  0x4140da		48890424		MOVQ AX, 0(SP)			
  0x4140de		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4140e7		e854e30000		CALL runtime.printstring(SB)	
  0x4140ec		8b442414		MOVL 0x14(SP), AX		
  0x4140f0		89c0			MOVL AX, AX			
  0x4140f2		48890424		MOVQ AX, 0(SP)			
  0x4140f6		e875e00000		CALL runtime.printuint(SB)	
  0x4140fb		488d0504640500		LEAQ 0x56404(IP), AX		
  0x414102		48890424		MOVQ AX, 0(SP)			
  0x414106		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x41410f		e82ce30000		CALL runtime.printstring(SB)	
  0x414114		0fb6442413		MOVZX 0x13(SP), AX		
  0x414119		880424			MOVB AL, 0(SP)			
  0x41411c		e8bfdc0000		CALL runtime.printbool(SB)	
  0x414121		488d0556650500		LEAQ 0x56556(IP), AX		
  0x414128		48890424		MOVQ AX, 0(SP)			
  0x41412c		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x414135		e806e30000		CALL runtime.printstring(SB)	
  0x41413a		0fb6442412		MOVZX 0x12(SP), AX		
  0x41413f		880424			MOVB AL, 0(SP)			
  0x414142		e899dc0000		CALL runtime.printbool(SB)	
  0x414147		e844dc0000		CALL runtime.printnl(SB)	
  0x41414c		e82fda0000		CALL runtime.printunlock(SB)	
	unlock(&allglock) // Avoid self-deadlock with traceback.
  0x414151		488d05c0f70a00		LEAQ runtime.allglock(SB), AX	
  0x414158		48890424		MOVQ AX, 0(SP)			
  0x41415c		e85f55ffff		CALL runtime.unlock(SB)		
	throw("scan missed a g")
  0x414161		488d055d680500		LEAQ 0x5685d(IP), AX	
  0x414168		48890424		MOVQ AX, 0(SP)		
  0x41416c		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x414175		e856d00000		CALL runtime.throw(SB)	
  0x41417a		0f0b			UD2			
			gp = allgs[i]
  0x41417c		e8bfb80000		CALL runtime.panicindex(SB)	
  0x414181		0f0b			UD2				
  0x414183		8944241c		MOVL AX, 0x1c(SP)		
  0x414187		894c2418		MOVL CX, 0x18(SP)		
		print(work.markrootNext, " of ", work.markrootJobs, " markroot jobs done\n")
  0x41418b		e870d90000		CALL runtime.printlock(SB)	
  0x414190		8b44241c		MOVL 0x1c(SP), AX		
  0x414194		48890424		MOVQ AX, 0(SP)			
  0x414198		e8d3df0000		CALL runtime.printuint(SB)	
  0x41419d		488d052a5b0500		LEAQ 0x55b2a(IP), AX		
  0x4141a4		48890424		MOVQ AX, 0(SP)			
  0x4141a8		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4141b1		e88ae20000		CALL runtime.printstring(SB)	
  0x4141b6		8b442418		MOVL 0x18(SP), AX		
  0x4141ba		48890424		MOVQ AX, 0(SP)			
  0x4141be		e8addf0000		CALL runtime.printuint(SB)	
  0x4141c3		488d05136e0500		LEAQ 0x56e13(IP), AX		
  0x4141ca		48890424		MOVQ AX, 0(SP)			
  0x4141ce		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x4141d7		e864e20000		CALL runtime.printstring(SB)	
  0x4141dc		e89fd90000		CALL runtime.printunlock(SB)	
		throw("left over markroot jobs")
  0x4141e1		488d05c0740500		LEAQ 0x574c0(IP), AX	
  0x4141e8		48890424		MOVQ AX, 0(SP)		
  0x4141ec		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4141f5		e8d6cf0000		CALL runtime.throw(SB)	
  0x4141fa		0f0b			UD2			
func gcMarkRootCheck() {
  0x4141fc		e86f030300		CALL runtime.morestack_noctxt(SB)	
  0x414201		e95afdffff		JMP runtime.gcMarkRootCheck(SB)		

TEXT runtime.markroot(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func markroot(gcw *gcWork, i uint32) {
  0x414210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414219		483b6110		CMPQ 0x10(CX), SP	
  0x41421d		0f863f030000		JBE 0x414562		
  0x414223		4883ec78		SUBQ $0x78, SP		
  0x414227		48896c2470		MOVQ BP, 0x70(SP)	
  0x41422c		488d6c2470		LEAQ 0x70(SP), BP	
	baseData := baseFlushCache + uint32(work.nFlushCacheRoots)
  0x414231		488b05203c0900		MOVQ runtime.work+184(SB), AX	
  0x414238		8d4802			LEAL 0x2(AX), CX		
	baseBSS := baseData + uint32(work.nDataRoots)
  0x41423b		488b151e3c0900		MOVQ runtime.work+192(SB), DX	
  0x414242		01d0			ADDL DX, AX			
	baseSpans := baseBSS + uint32(work.nBSSRoots)
  0x414244		488b151d3c0900		MOVQ runtime.work+200(SB), DX	
  0x41424b		01c2			ADDL AX, DX			
	baseStacks := baseSpans + uint32(work.nSpanRoots)
  0x41424d		488b1d1c3c0900		MOVQ runtime.work+208(SB), BX	
  0x414254		01d3			ADDL DX, BX			
	end := baseStacks + uint32(work.nStackRoots)
  0x414256		488b351b3c0900		MOVQ runtime.work+216(SB), SI	
  0x41425d		01de			ADDL BX, SI			
  0x41425f		8bbc2488000000		MOVL 0x88(SP), DI		
	case baseFlushCache <= i && i < baseData:
  0x414266		83ff02			CMPL $0x2, DI		
  0x414269		7208			JB 0x414273		
  0x41426b		39cf			CMPL CX, DI		
  0x41426d		0f82bc020000		JB 0x41452f		
	baseBSS := baseData + uint32(work.nDataRoots)
  0x414273		83c002			ADDL $0x2, AX		
	case baseData <= i && i < baseBSS:
  0x414276		39f9			CMPL DI, CX		
  0x414278		0f87af000000		JA 0x41432d		
  0x41427e		39c7			CMPL AX, DI		
  0x414280		0f83a7000000		JAE 0x41432d		
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x414286		488b05eb330900		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x41428d		4885c0			TESTQ AX, AX		
  0x414290		0f848e000000		JE 0x414324		
	return *p
  0x414296		488b10			MOVQ 0(AX), DX		
  0x414299		488b4008		MOVQ 0x8(AX), AX	
		for _, datap := range activeModules() {
  0x41429d		894c2428		MOVL CX, 0x28(SP)	
  0x4142a1		4889442430		MOVQ AX, 0x30(SP)	
  0x4142a6		4889542450		MOVQ DX, 0x50(SP)	
  0x4142ab		31db			XORL BX, BX		
  0x4142ad		eb66			JMP 0x414315		
  0x4142af		48895c2440		MOVQ BX, 0x40(SP)	
  0x4142b4		488b04da		MOVQ 0(DX)(BX*8), AX	
			markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, int(i-baseData))
  0x4142b8		488bb080000000		MOVQ 0x80(AX), SI		
  0x4142bf		4c8b8088000000		MOVQ 0x88(AX), R8		
  0x4142c6		488b8098010000		MOVQ 0x198(AX), AX		
  0x4142cd		4889442410		MOVQ AX, 0x10(SP)		
  0x4142d2		48893424		MOVQ SI, 0(SP)			
  0x4142d6		4929f0			SUBQ SI, R8			
  0x4142d9		4c89442408		MOVQ R8, 0x8(SP)		
  0x4142de		488b842480000000	MOVQ 0x80(SP), AX		
  0x4142e6		4889442418		MOVQ AX, 0x18(SP)		
  0x4142eb		29cf			SUBL CX, DI			
  0x4142ed		48897c2420		MOVQ DI, 0x20(SP)		
  0x4142f2		e879020000		CALL runtime.markrootBlock(SB)	
  0x4142f7		488b442440		MOVQ 0x40(SP), AX		
		for _, datap := range activeModules() {
  0x4142fc		488d5801		LEAQ 0x1(AX), BX	
  0x414300		488b442430		MOVQ 0x30(SP), AX	
  0x414305		8b4c2428		MOVL 0x28(SP), CX	
  0x414309		488b542450		MOVQ 0x50(SP), DX	
  0x41430e		8bbc2488000000		MOVL 0x88(SP), DI	
  0x414315		4839c3			CMPQ AX, BX		
  0x414318		7c95			JL 0x4142af		
  0x41431a		488b6c2470		MOVQ 0x70(SP), BP	
  0x41431f		4883c478		ADDQ $0x78, SP		
  0x414323		c3			RET			
  0x414324		31c0			XORL AX, AX		
  0x414326		31d2			XORL DX, DX		
  0x414328		e970ffffff		JMP 0x41429d		
	baseSpans := baseBSS + uint32(work.nBSSRoots)
  0x41432d		8d4a02			LEAL 0x2(DX), CX	
	case baseBSS <= i && i < baseSpans:
  0x414330		39f8			CMPL DI, AX		
  0x414332		0f87aa000000		JA 0x4143e2		
  0x414338		39cf			CMPL CX, DI		
  0x41433a		0f83a2000000		JAE 0x4143e2		
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x414340		488b0d31330900		MOVQ runtime.modulesSlice(SB), CX	
	if p == nil {
  0x414347		4885c9			TESTQ CX, CX		
  0x41434a		0f8489000000		JE 0x4143d9		
	return *p
  0x414350		488b11			MOVQ 0(CX), DX		
  0x414353		488b4908		MOVQ 0x8(CX), CX	
		for _, datap := range activeModules() {
  0x414357		8944242c		MOVL AX, 0x2c(SP)	
  0x41435b		4889542450		MOVQ DX, 0x50(SP)	
  0x414360		48894c2438		MOVQ CX, 0x38(SP)	
  0x414365		31db			XORL BX, BX		
  0x414367		eb66			JMP 0x4143cf		
  0x414369		48895c2440		MOVQ BX, 0x40(SP)	
  0x41436e		488b0cda		MOVQ 0(DX)(BX*8), CX	
			markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, int(i-baseBSS))
  0x414372		488bb190000000		MOVQ 0x90(CX), SI		
  0x414379		4c8b8198000000		MOVQ 0x98(CX), R8		
  0x414380		488b89a8010000		MOVQ 0x1a8(CX), CX		
  0x414387		48894c2410		MOVQ CX, 0x10(SP)		
  0x41438c		48893424		MOVQ SI, 0(SP)			
  0x414390		4929f0			SUBQ SI, R8			
  0x414393		4c89442408		MOVQ R8, 0x8(SP)		
  0x414398		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x4143a0		48894c2418		MOVQ CX, 0x18(SP)		
  0x4143a5		29c7			SUBL AX, DI			
  0x4143a7		48897c2420		MOVQ DI, 0x20(SP)		
  0x4143ac		e8bf010000		CALL runtime.markrootBlock(SB)	
  0x4143b1		488b442440		MOVQ 0x40(SP), AX		
		for _, datap := range activeModules() {
  0x4143b6		488d5801		LEAQ 0x1(AX), BX	
  0x4143ba		8b44242c		MOVL 0x2c(SP), AX	
  0x4143be		488b4c2438		MOVQ 0x38(SP), CX	
  0x4143c3		488b542450		MOVQ 0x50(SP), DX	
  0x4143c8		8bbc2488000000		MOVL 0x88(SP), DI	
  0x4143cf		4839cb			CMPQ CX, BX		
  0x4143d2		7c95			JL 0x414369		
  0x4143d4		e941ffffff		JMP 0x41431a		
  0x4143d9		31d2			XORL DX, DX		
  0x4143db		31c9			XORL CX, CX		
  0x4143dd		e975ffffff		JMP 0x414357		
	case i == fixedRootFinalizers:
  0x4143e2		85ff			TESTL DI, DI		
  0x4143e4		7567			JNE 0x41444d		
		if work.markrootDone {
  0x4143e6		0fb605933a0900		MOVZX runtime.work+224(SB), AX	
  0x4143ed		84c0			TESTL AL, AL			
  0x4143ef		0f8525ffffff		JNE 0x41431a			
		for fb := allfin; fb != nil; fb = fb.alllink {
  0x4143f5		488b0514320900		MOVQ runtime.allfin(SB), AX	
  0x4143fc		eb45			JMP 0x414443			
  0x4143fe		4889442448		MOVQ AX, 0x48(SP)		
			cnt := uintptr(atomic.Load(&fb.cnt))
  0x414403		8b4810			MOVL 0x10(AX), CX	
			scanblock(uintptr(unsafe.Pointer(&fb.fin[0])), cnt*unsafe.Sizeof(fb.fin[0]), &finptrmask[0], gcw)
  0x414406		488d5018		LEAQ 0x18(AX), DX		
  0x41440a		488d1deff60a00		LEAQ runtime.finptrmask(SB), BX	
  0x414411		48895c2410		MOVQ BX, 0x10(SP)		
  0x414416		48891424		MOVQ DX, 0(SP)			
			cnt := uintptr(atomic.Load(&fb.cnt))
  0x41441a		89c9			MOVL CX, CX		
			scanblock(uintptr(unsafe.Pointer(&fb.fin[0])), cnt*unsafe.Sizeof(fb.fin[0]), &finptrmask[0], gcw)
  0x41441c		488d0c89		LEAQ 0(CX)(CX*4), CX		
  0x414420		48c1e103		SHLQ $0x3, CX			
  0x414424		48894c2408		MOVQ CX, 0x8(SP)		
  0x414429		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x414431		48894c2418		MOVQ CX, 0x18(SP)		
  0x414436		e805210000		CALL runtime.scanblock(SB)	
  0x41443b		488b442448		MOVQ 0x48(SP), AX		
		for fb := allfin; fb != nil; fb = fb.alllink {
  0x414440		488b00			MOVQ 0(AX), AX		
  0x414443		4885c0			TESTQ AX, AX		
  0x414446		75b6			JNE 0x4143fe		
  0x414448		e9cdfeffff		JMP 0x41431a		
	case i == fixedRootFreeGStacks:
  0x41444d		83ff01			CMPL $0x1, DI		
  0x414450		7524			JNE 0x414476		
		if !work.markrootDone {
  0x414452		0fb605273a0900		MOVZX runtime.work+224(SB), AX	
  0x414459		84c0			TESTL AL, AL			
  0x41445b		0f85b9feffff		JNE 0x41431a			
			systemstack(markrootFreeGStacks)
  0x414461		488d05909c0500		LEAQ 0x59c90(IP), AX		
  0x414468		48890424		MOVQ AX, 0(SP)			
  0x41446c		e8afff0200		CALL runtime.systemstack(SB)	
  0x414471		e9a4feffff		JMP 0x41431a			
	baseStacks := baseSpans + uint32(work.nSpanRoots)
  0x414476		8d4302			LEAL 0x2(BX), AX	
	case baseSpans <= i && i < baseStacks:
  0x414479		39f9			CMPL DI, CX		
  0x41447b		7708			JA 0x414485		
  0x41447d		39c7			CMPL AX, DI		
  0x41447f		0f828d000000		JB 0x414512		
		if baseStacks <= i && i < end {
  0x414485		39f8			CMPL DI, AX		
  0x414487		0f87ba000000		JA 0x414547		
	end := baseStacks + uint32(work.nStackRoots)
  0x41448d		8d4e02			LEAL 0x2(SI), CX	
		if baseStacks <= i && i < end {
  0x414490		39cf			CMPL CX, DI		
  0x414492		0f83af000000		JAE 0x414547		
			gp = allgs[i-baseStacks]
  0x414498		488b0df9310900		MOVQ runtime.allgs+8(SB), CX	
  0x41449f		488b15ea310900		MOVQ runtime.allgs(SB), DX	
  0x4144a6		29c7			SUBL AX, DI			
  0x4144a8		4839cf			CMPQ CX, DI			
  0x4144ab		0f838f000000		JAE 0x414540			
  0x4144b1		488b04fa		MOVQ 0(DX)(DI*8), AX		
	return atomic.Load(&gp.atomicstatus)
  0x4144b5		8b8890000000		MOVL 0x90(AX), CX	
		if (status == _Gwaiting || status == _Gsyscall) && gp.waitsince == 0 {
  0x4144bb		83f904			CMPL $0x4, CX		
  0x4144be		754b			JNE 0x41450b		
  0x4144c0		488b88a0000000		MOVQ 0xa0(AX), CX	
  0x4144c7		4885c9			TESTQ CX, CX		
  0x4144ca		750e			JNE 0x4144da		
			gp.waitsince = work.tstart
  0x4144cc		488b0d65390900		MOVQ runtime.work+152(SB), CX	
  0x4144d3		488988a0000000		MOVQ CX, 0xa0(AX)		
		systemstack(func() {
  0x4144da		488d0dffdf0200		LEAQ runtime.markroot.func1(SB), CX	
  0x4144e1		48894c2458		MOVQ CX, 0x58(SP)			
  0x4144e6		4889442460		MOVQ AX, 0x60(SP)			
  0x4144eb		488b842480000000	MOVQ 0x80(SP), AX			
  0x4144f3		4889442468		MOVQ AX, 0x68(SP)			
  0x4144f8		488d442458		LEAQ 0x58(SP), AX			
  0x4144fd		48890424		MOVQ AX, 0(SP)				
  0x414501		e81aff0200		CALL runtime.systemstack(SB)		
	switch {
  0x414506		e90ffeffff		JMP 0x41431a		
		if (status == _Gwaiting || status == _Gsyscall) && gp.waitsince == 0 {
  0x41450b		83f903			CMPL $0x3, CX		
  0x41450e		74b0			JE 0x4144c0		
  0x414510		ebc8			JMP 0x4144da		
  0x414512		488b842480000000	MOVQ 0x80(SP), AX	
		markrootSpans(gcw, int(i-baseSpans))
  0x41451a		48890424		MOVQ AX, 0(SP)			
  0x41451e		29cf			SUBL CX, DI			
  0x414520		48897c2408		MOVQ DI, 0x8(SP)		
  0x414525		e836020000		CALL runtime.markrootSpans(SB)	
	switch {
  0x41452a		e9ebfdffff		JMP 0x41431a		
		flushmcache(int(i - baseFlushCache))
  0x41452f		8d47fe			LEAL -0x2(DI), AX		
  0x414532		48890424		MOVQ AX, 0(SP)			
  0x414536		e8559c0000		CALL runtime.flushmcache(SB)	
	switch {
  0x41453b		e9dafdffff		JMP 0x41431a		
			gp = allgs[i-baseStacks]
  0x414540		e8fbb40000		CALL runtime.panicindex(SB)	
  0x414545		0f0b			UD2				
			throw("markroot: bad index")
  0x414547		488d0571690500		LEAQ 0x56971(IP), AX	
  0x41454e		48890424		MOVQ AX, 0(SP)		
  0x414552		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x41455b		e870cc0000		CALL runtime.throw(SB)	
  0x414560		0f0b			UD2			
func markroot(gcw *gcWork, i uint32) {
  0x414562		e809000300		CALL runtime.morestack_noctxt(SB)	
  0x414567		e9a4fcffff		JMP runtime.markroot(SB)		

TEXT runtime.markrootBlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func markrootBlock(b0, n0 uintptr, ptrmask0 *uint8, gcw *gcWork, shard int) {
  0x414570		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414579		483b6110		CMPQ 0x10(CX), SP	
  0x41457d		0f8684000000		JBE 0x414607		
  0x414583		4883ec28		SUBQ $0x28, SP		
  0x414587		48896c2420		MOVQ BP, 0x20(SP)	
  0x41458c		488d6c2420		LEAQ 0x20(SP), BP	
  0x414591		488b442450		MOVQ 0x50(SP), AX	
  0x414596		4889c1			MOVQ AX, CX		
	b := b0 + uintptr(shard)*rootBlockBytes
  0x414599		48c1e012		SHLQ $0x12, AX		
  0x41459d		488b542430		MOVQ 0x30(SP), DX	
  0x4145a2		488d1c10		LEAQ 0(AX)(DX*1), BX	
  0x4145a6		488b742438		MOVQ 0x38(SP), SI	
	if b >= b0+n0 {
  0x4145ab		4801d6			ADDQ DX, SI		
  0x4145ae		4839f3			CMPQ SI, BX		
  0x4145b1		734a			JAE 0x4145fd		
	ptrmask := (*uint8)(add(unsafe.Pointer(ptrmask0), uintptr(shard)*(rootBlockBytes/(8*sys.PtrSize))))
  0x4145b3		48c1e10c		SHLQ $0xc, CX		
	if b+n > b0+n0 {
  0x4145b7		488d840200000400	LEAQ 0x40000(DX)(AX*1), AX	
  0x4145bf		488b542440		MOVQ 0x40(SP), DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4145c4		4801d1			ADDQ DX, CX		
	if b+n > b0+n0 {
  0x4145c7		4839f0			CMPQ SI, AX		
  0x4145ca		762a			JBE 0x4145f6		
		n = b0 + n0 - b
  0x4145cc		4829de			SUBQ BX, SI		
	scanblock(b, n, ptrmask, gcw)
  0x4145cf		48891c24		MOVQ BX, 0(SP)			
  0x4145d3		4889742408		MOVQ SI, 0x8(SP)		
  0x4145d8		48894c2410		MOVQ CX, 0x10(SP)		
  0x4145dd		488b442448		MOVQ 0x48(SP), AX		
  0x4145e2		4889442418		MOVQ AX, 0x18(SP)		
  0x4145e7		e8541f0000		CALL runtime.scanblock(SB)	
}
  0x4145ec		488b6c2420		MOVQ 0x20(SP), BP	
  0x4145f1		4883c428		ADDQ $0x28, SP		
  0x4145f5		c3			RET			
  0x4145f6		be00000400		MOVL $0x40000, SI	
	if b+n > b0+n0 {
  0x4145fb		ebd2			JMP 0x4145cf		
		return
  0x4145fd		488b6c2420		MOVQ 0x20(SP), BP	
  0x414602		4883c428		ADDQ $0x28, SP		
  0x414606		c3			RET			
func markrootBlock(b0, n0 uintptr, ptrmask0 *uint8, gcw *gcWork, shard int) {
  0x414607		e864ff0200		CALL runtime.morestack_noctxt(SB)	
  0x41460c		e95fffffff		JMP runtime.markrootBlock(SB)		

TEXT runtime.markrootFreeGStacks(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func markrootFreeGStacks() {
  0x414620		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414629		483b6110		CMPQ 0x10(CX), SP	
  0x41462d		0f861e010000		JBE 0x414751		
  0x414633		4883ec28		SUBQ $0x28, SP		
  0x414637		48896c2420		MOVQ BP, 0x20(SP)	
  0x41463c		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&sched.gflock)
  0x414641		488d0548330900		LEAQ runtime.sched+112(SB), AX	
  0x414648		48890424		MOVQ AX, 0(SP)			
  0x41464c		e8cf4effff		CALL runtime.lock(SB)		
	list := sched.gfreeStack
  0x414651		488b0540330900		MOVQ runtime.sched+120(SB), AX	
  0x414658		4889442410		MOVQ AX, 0x10(SP)		
	sched.gfreeStack = nil
  0x41465d		8b0dadf30a00		MOVL runtime.writeBarrier(SB), CX	
  0x414663		85c9			TESTL CX, CX				
  0x414665		0f85d3000000		JNE 0x41473e				
  0x41466b		48c7052233090000000000	MOVQ $0x0, runtime.sched+120(SB)	
	unlock(&sched.gflock)
  0x414676		488d0513330900		LEAQ runtime.sched+112(SB), AX	
  0x41467d		48890424		MOVQ AX, 0(SP)			
  0x414681		e83a50ffff		CALL runtime.unlock(SB)		
  0x414686		488b442410		MOVQ 0x10(SP), AX		
	if list == nil {
  0x41468b		4885c0			TESTQ AX, AX		
  0x41468e		0f84a0000000		JE 0x414734		
  0x414694		4889c1			MOVQ AX, CX		
  0x414697		4889ca			MOVQ CX, DX		
	for gp := list; gp != nil; gp = gp.schedlink.ptr() {
  0x41469a		eb1f			JMP 0x4146bb		
  0x41469c		4889442418		MOVQ AX, 0x18(SP)	
		shrinkstack(gp)
  0x4146a1		48890424		MOVQ AX, 0(SP)			
  0x4146a5		e826230200		CALL runtime.shrinkstack(SB)	
  0x4146aa		488b542418		MOVQ 0x18(SP), DX		
	for gp := list; gp != nil; gp = gp.schedlink.ptr() {
  0x4146af		488b82b8000000		MOVQ 0xb8(DX), AX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x4146b6		488b4c2410		MOVQ 0x10(SP), CX	
	for gp := list; gp != nil; gp = gp.schedlink.ptr() {
  0x4146bb		4885c0			TESTQ AX, AX		
  0x4146be		75dc			JNE 0x41469c		
  0x4146c0		4889542408		MOVQ DX, 0x8(SP)	
	lock(&sched.gflock)
  0x4146c5		488d05c4320900		LEAQ runtime.sched+112(SB), AX	
  0x4146cc		48890424		MOVQ AX, 0(SP)			
  0x4146d0		e84b4effff		CALL runtime.lock(SB)		
  0x4146d5		488b442408		MOVQ 0x8(SP), AX		
	tail.schedlink.set(sched.gfreeNoStack)
  0x4146da		488d88b8000000		LEAQ 0xb8(AX), CX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4146e1		8401			TESTB AL, 0(CX)		
	tail.schedlink.set(sched.gfreeNoStack)
  0x4146e3		488b0db6320900		MOVQ runtime.sched+128(SB), CX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4146ea		488988b8000000		MOVQ CX, 0xb8(AX)	
	sched.gfreeNoStack = list
  0x4146f1		8b0519f30a00		MOVL runtime.writeBarrier(SB), AX	
  0x4146f7		85c0			TESTL AX, AX				
  0x4146f9		7526			JNE 0x414721				
  0x4146fb		488b442410		MOVQ 0x10(SP), AX			
  0x414700		48890599320900		MOVQ AX, runtime.sched+128(SB)		
	unlock(&sched.gflock)
  0x414707		488d0582320900		LEAQ runtime.sched+112(SB), AX	
  0x41470e		48890424		MOVQ AX, 0(SP)			
  0x414712		e8a94fffff		CALL runtime.unlock(SB)		
}
  0x414717		488b6c2420		MOVQ 0x20(SP), BP	
  0x41471c		4883c428		ADDQ $0x28, SP		
  0x414720		c3			RET			
	sched.gfreeNoStack = list
  0x414721		488d3d78320900		LEAQ runtime.sched+128(SB), DI	
  0x414728		488b442410		MOVQ 0x10(SP), AX		
  0x41472d		e86e210300		CALL runtime.gcWriteBarrier(SB)	
  0x414732		ebd3			JMP 0x414707			
		return
  0x414734		488b6c2420		MOVQ 0x20(SP), BP	
  0x414739		4883c428		ADDQ $0x28, SP		
  0x41473d		c3			RET			
	sched.gfreeStack = nil
  0x41473e		488d3d53320900		LEAQ runtime.sched+120(SB), DI	
  0x414745		31c0			XORL AX, AX			
  0x414747		e854210300		CALL runtime.gcWriteBarrier(SB)	
  0x41474c		e925ffffff		JMP 0x414676			
func markrootFreeGStacks() {
  0x414751		e81afe0200		CALL runtime.morestack_noctxt(SB)	
  0x414756		e9c5feffff		JMP runtime.markrootFreeGStacks(SB)	

TEXT runtime.markrootSpans(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func markrootSpans(gcw *gcWork, shard int) {
  0x414760		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414769		483b6110		CMPQ 0x10(CX), SP	
  0x41476d		0f861f020000		JBE 0x414992		
  0x414773		4883ec68		SUBQ $0x68, SP		
  0x414777		48896c2460		MOVQ BP, 0x60(SP)	
  0x41477c		488d6c2460		LEAQ 0x60(SP), BP	
	if work.markrootDone {
  0x414781		0fb605f8360900		MOVZX runtime.work+224(SB), AX	
  0x414788		84c0			TESTL AL, AL			
  0x41478a		0f85e7010000		JNE 0x414977			
	sg := mheap_.sweepgen
  0x414790		8b052a8b0900		MOVL runtime.mheap_+4128(SB), AX	
  0x414796		89442428		MOVL AX, 0x28(SP)			
	spans := mheap_.sweepSpans[mheap_.sweepgen/2%2].block(shard)
  0x41479a		d1e8			SHRL $0x1, AX				
  0x41479c		83e001			ANDL $0x1, AX				
  0x41479f		488d0480		LEAQ 0(AX)(AX*4), AX			
  0x4147a3		488d15568b0900		LEAQ runtime.mheap_+4192(SB), DX	
  0x4147aa		488d04c2		LEAQ 0(DX)(AX*8), AX			
  0x4147ae		48890424		MOVQ AX, 0(SP)				
  0x4147b2		488b442478		MOVQ 0x78(SP), AX			
  0x4147b7		4889442408		MOVQ AX, 0x8(SP)			
  0x4147bc		e88f440000		CALL runtime.(*gcSweepBuf).block(SB)	
  0x4147c1		488b442418		MOVQ 0x18(SP), AX			
  0x4147c6		4889442430		MOVQ AX, 0x30(SP)			
  0x4147cb		488b4c2410		MOVQ 0x10(SP), CX			
  0x4147d0		48894c2440		MOVQ CX, 0x40(SP)			
  0x4147d5		31d2			XORL DX, DX				
	for _, s := range spans {
  0x4147d7		eb03			JMP 0x4147dc		
  0x4147d9		48ffc2			INCQ DX			
  0x4147dc		4839c2			CMPQ AX, DX		
  0x4147df		0f8d1b010000		JGE 0x414900		
  0x4147e5		488b1cd1		MOVQ 0(CX)(DX*8), BX	
		if s.state != mSpanInUse {
  0x4147e9		0fb67364		MOVZX 0x64(BX), SI	
  0x4147ed		4080fe01		CMPL $0x1, SI		
  0x4147f1		75e6			JNE 0x4147d9		
		if !useCheckmark && s.sweepgen != sg {
  0x4147f3		0fb635c5f00a00		MOVZX runtime.useCheckmark(SB), SI	
  0x4147fa		4084f6			TESTL SI, SI				
  0x4147fd		0f84ed000000		JE 0x4148f0				
		if s.specials == nil {
  0x414803		488bb390000000		MOVQ 0x90(BX), SI	
  0x41480a		4885f6			TESTQ SI, SI		
  0x41480d		74ca			JE 0x4147d9		
  0x41480f		4889542438		MOVQ DX, 0x38(SP)	
  0x414814		48895c2448		MOVQ BX, 0x48(SP)	
		lock(&s.speciallock)
  0x414819		488d8388000000		LEAQ 0x88(BX), AX	
  0x414820		4889442458		MOVQ AX, 0x58(SP)	
  0x414825		48890424		MOVQ AX, 0(SP)		
  0x414829		e8f24cffff		CALL runtime.lock(SB)	
  0x41482e		488b442448		MOVQ 0x48(SP), AX	
		for sp := s.specials; sp != nil; sp = sp.next {
  0x414833		488b8890000000		MOVQ 0x90(AX), CX	
  0x41483a		eb03			JMP 0x41483f		
  0x41483c		488b09			MOVQ 0(CX), CX		
  0x41483f		4885c9			TESTQ CX, CX		
  0x414842		0f8486000000		JE 0x4148ce		
			if sp.kind != _KindSpecialFinalizer {
  0x414848		0fb6510a		MOVZX 0xa(CX), DX	
  0x41484c		80fa01			CMPL $0x1, DL		
  0x41484f		75eb			JNE 0x41483c		
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x414851		0fb75108		MOVZX 0x8(CX), DX	
  0x414855		488b5868		MOVQ 0x68(AX), BX	
	return s.startAddr
  0x414859		488b7018		MOVQ 0x18(AX), SI	
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x41485d		4885db			TESTQ BX, BX		
  0x414860		0f84a4000000		JE 0x41490a		
  0x414866		48894c2450		MOVQ CX, 0x50(SP)	
  0x41486b		4889d0			MOVQ DX, AX		
  0x41486e		31d2			XORL DX, DX		
  0x414870		48f7f3			DIVQ BX			
  0x414873		480fafc3		IMULQ BX, AX		
  0x414877		488d0c06		LEAQ 0(SI)(AX*1), CX	
			scanobject(p, gcw)
  0x41487b		48890c24		MOVQ CX, 0(SP)			
  0x41487f		488b4c2470		MOVQ 0x70(SP), CX		
  0x414884		48894c2408		MOVQ CX, 0x8(SP)		
  0x414889		e8421e0000		CALL runtime.scanobject(SB)	
  0x41488e		488b4c2450		MOVQ 0x50(SP), CX		
			scanblock(uintptr(unsafe.Pointer(&spf.fn)), sys.PtrSize, &oneptrmask[0], gcw)
  0x414893		488d5110		LEAQ 0x10(CX), DX		
  0x414897		488d1d62070900		LEAQ 0x90762(IP), BX		
  0x41489e		48895c2410		MOVQ BX, 0x10(SP)		
  0x4148a3		48891424		MOVQ DX, 0(SP)			
  0x4148a7		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4148b0		488b542470		MOVQ 0x70(SP), DX		
  0x4148b5		4889542418		MOVQ DX, 0x18(SP)		
  0x4148ba		e8811c0000		CALL runtime.scanblock(SB)	
  0x4148bf		488b442448		MOVQ 0x48(SP), AX		
  0x4148c4		488b4c2450		MOVQ 0x50(SP), CX		
  0x4148c9		e96effffff		JMP 0x41483c			
  0x4148ce		488b442458		MOVQ 0x58(SP), AX		
		unlock(&s.speciallock)
  0x4148d3		48890424		MOVQ AX, 0(SP)		
  0x4148d7		e8e44dffff		CALL runtime.unlock(SB)	
  0x4148dc		488b442430		MOVQ 0x30(SP), AX	
  0x4148e1		488b4c2440		MOVQ 0x40(SP), CX	
  0x4148e6		488b542438		MOVQ 0x38(SP), DX	
  0x4148eb		e9e9feffff		JMP 0x4147d9		
		if !useCheckmark && s.sweepgen != sg {
  0x4148f0		8b7358			MOVL 0x58(BX), SI	
  0x4148f3		8b7c2428		MOVL 0x28(SP), DI	
  0x4148f7		39fe			CMPL DI, SI		
  0x4148f9		7516			JNE 0x414911		
  0x4148fb		e903ffffff		JMP 0x414803		
  0x414900		488b6c2460		MOVQ 0x60(SP), BP	
  0x414905		4883c468		ADDQ $0x68, SP		
  0x414909		c3			RET			
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x41490a		e811b20000		CALL runtime.panicdivide(SB)	
  0x41490f		0f0b			UD2				
  0x414911		8974242c		MOVL SI, 0x2c(SP)		
			print("sweep ", s.sweepgen, " ", sg, "\n")
  0x414915		e8e6d10000		CALL runtime.printlock(SB)	
  0x41491a		488d052c550500		LEAQ 0x5552c(IP), AX		
  0x414921		48890424		MOVQ AX, 0(SP)			
  0x414925		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x41492e		e80ddb0000		CALL runtime.printstring(SB)	
  0x414933		8b44242c		MOVL 0x2c(SP), AX		
  0x414937		48890424		MOVQ AX, 0(SP)			
  0x41493b		e830d80000		CALL runtime.printuint(SB)	
  0x414940		e8fbd30000		CALL runtime.printsp(SB)	
  0x414945		8b442428		MOVL 0x28(SP), AX		
  0x414949		48890424		MOVQ AX, 0(SP)			
  0x41494d		e81ed80000		CALL runtime.printuint(SB)	
  0x414952		e839d40000		CALL runtime.printnl(SB)	
  0x414957		e824d20000		CALL runtime.printunlock(SB)	
			throw("gc: unswept span")
  0x41495c		488d056f610500		LEAQ 0x5616f(IP), AX	
  0x414963		48890424		MOVQ AX, 0(SP)		
  0x414967		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x414970		e85bc80000		CALL runtime.throw(SB)	
  0x414975		0f0b			UD2			
		throw("markrootSpans during second markroot")
  0x414977		488d05a8840500		LEAQ 0x584a8(IP), AX	
  0x41497e		48890424		MOVQ AX, 0(SP)		
  0x414982		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x41498b		e840c80000		CALL runtime.throw(SB)	
  0x414990		0f0b			UD2			
func markrootSpans(gcw *gcWork, shard int) {
  0x414992		e8d9fb0200		CALL runtime.morestack_noctxt(SB)	
  0x414997		e9c4fdffff		JMP runtime.markrootSpans(SB)		

TEXT runtime.gcAssistAlloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcAssistAlloc(gp *g) {
  0x4149a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4149a9		483b6110		CMPQ 0x10(CX), SP	
  0x4149ad		0f8636020000		JBE 0x414be9		
  0x4149b3		4883ec38		SUBQ $0x38, SP		
  0x4149b7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4149bc		488d6c2430		LEAQ 0x30(SP), BP	
  0x4149c1		488b442440		MOVQ 0x40(SP), AX	
	if getg() == gp.m.g0 {
  0x4149c6		488b4830		MOVQ 0x30(AX), CX	
  0x4149ca		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x4149d3		488b09			MOVQ 0(CX), CX		
  0x4149d6		4839ca			CMPQ CX, DX		
  0x4149d9		0f8400020000		JE 0x414bdf		
	if mp := getg().m; mp.locks > 0 || mp.preemptoff != "" {
  0x4149df		488b4a30		MOVQ 0x30(DX), CX	
  0x4149e3		8b9100010000		MOVL 0x100(CX), DX	
  0x4149e9		85d2			TESTL DX, DX		
  0x4149eb		0f8fe4010000		JG 0x414bd5		
  0x4149f1		488b89f8000000		MOVQ 0xf8(CX), CX	
  0x4149f8		4885c9			TESTQ CX, CX		
  0x4149fb		0f85d4010000		JNE 0x414bd5		
  0x414a01		31c9			XORL CX, CX		
	debtBytes := -gp.gcAssistBytes
  0x414a03		eb0a			JMP 0x414a0f		
  0x414a05		488b442440		MOVQ 0x40(SP), AX	
  0x414a0a		0fb64c240f		MOVZX 0xf(SP), CX	
  0x414a0f		488b9070010000		MOVQ 0x170(AX), DX	
  0x414a16		48f7da			NEGQ DX			
	scanWork := int64(gcController.assistWorkPerByte * float64(debtBytes))
  0x414a19		0f57c0			XORPS X0, X0				
  0x414a1c		f2480f2ac2		CVTSI2SDQ DX, X0			
  0x414a21		f20f590537f20a00	MULSD runtime.gcController+64(SB), X0	
  0x414a29		f2480f2cd8		CVTTSD2SIQ X0, BX			
	if scanWork < gcOverAssistWork {
  0x414a2e		4881fb00000100		CMPQ $0x10000, BX	
  0x414a35		7d1e			JGE 0x414a55		
		debtBytes = int64(gcController.assistBytesPerWork * float64(scanWork))
  0x414a37		f20f100529f20a00	MOVSD_XMM runtime.gcController+72(SB), X0	
  0x414a3f		f20f100dc9000600	MOVSD_XMM $f64.40f0000000000000(SB), X1		
  0x414a47		f20f59c8		MULSD X0, X1					
  0x414a4b		f2480f2cd1		CVTTSD2SIQ X1, DX				
  0x414a50		bb00000100		MOVL $0x10000, BX				
	bgScanCredit := atomic.Loadint64(&gcController.bgScanCredit)
  0x414a55		488b35ccf10a00		MOVQ runtime.gcController+8(SB), SI	
	if bgScanCredit > 0 {
  0x414a5c		4885f6			TESTQ SI, SI		
  0x414a5f		7e4d			JLE 0x414aae		
		if bgScanCredit < scanWork {
  0x414a61		4839de			CMPQ BX, SI		
  0x414a64		0f8d55010000		JGE 0x414bbf		
			gp.gcAssistBytes += 1 + int64(gcController.assistBytesPerWork*float64(stolen))
  0x414a6a		0f57c0			XORPS X0, X0				
  0x414a6d		f2480f2ac6		CVTSI2SDQ SI, X0			
  0x414a72		f20f5905eef10a00	MULSD runtime.gcController+72(SB), X0	
  0x414a7a		f2480f2cd0		CVTTSD2SIQ X0, DX			
  0x414a7f		48039070010000		ADDQ 0x170(AX), DX			
  0x414a86		48ffc2			INCQ DX					
  0x414a89		48899070010000		MOVQ DX, 0x170(AX)			
  0x414a90		4889f2			MOVQ SI, DX				
		atomic.Xaddint64(&gcController.bgScanCredit, -stolen)
  0x414a93		48f7de			NEGQ SI					
  0x414a96		488d3d8bf10a00		LEAQ runtime.gcController+8(SB), DI	
  0x414a9d		f0480fc137		LOCK XADDQ SI, 0(DI)			
		scanWork -= stolen
  0x414aa2		4829d3			SUBQ DX, BX		
		if scanWork == 0 {
  0x414aa5		4885db			TESTQ BX, BX		
  0x414aa8		0f84fc000000		JE 0x414baa		
	if trace.enabled && !traced {
  0x414aae		0fb6151bed0900		MOVZX runtime.trace+16(SB), DX	
  0x414ab5		84d2			TESTL DL, DL			
  0x414ab7		740d			JE 0x414ac6			
	if traced {
  0x414ab9		84c9			TESTL CL, CL		
	if trace.enabled && !traced {
  0x414abb		0f84cb000000		JE 0x414b8c		
  0x414ac1		b901000000		MOVL $0x1, CX		
  0x414ac6		884c240f		MOVB CL, 0xf(SP)	
	systemstack(func() {
  0x414aca		488d153fdb0200		LEAQ runtime.gcAssistAlloc.func1(SB), DX	
  0x414ad1		4889542418		MOVQ DX, 0x18(SP)				
  0x414ad6		4889442420		MOVQ AX, 0x20(SP)				
  0x414adb		48895c2428		MOVQ BX, 0x28(SP)				
  0x414ae0		488d5c2418		LEAQ 0x18(SP), BX				
  0x414ae5		48891c24		MOVQ BX, 0(SP)					
  0x414ae9		e832f90200		CALL runtime.systemstack(SB)			
func gcAssistAlloc(gp *g) {
  0x414aee		488b442440		MOVQ 0x40(SP), AX	
	completed := gp.param != nil
  0x414af3		488b8888000000		MOVQ 0x88(AX), CX	
  0x414afa		488db888000000		LEAQ 0x88(AX), DI	
	gp.param = nil
  0x414b01		8b1509ef0a00		MOVL runtime.writeBarrier(SB), DX	
  0x414b07		85d2			TESTL DX, DX				
  0x414b09		7572			JNE 0x414b7d				
  0x414b0b		48c7808800000000000000	MOVQ $0x0, 0x88(AX)			
	completed := gp.param != nil
  0x414b16		4885c9			TESTQ CX, CX		
	if completed {
  0x414b19		7556			JNE 0x414b71		
	if gp.gcAssistBytes < 0 {
  0x414b1b		488b8870010000		MOVQ 0x170(AX), CX	
  0x414b22		4885c9			TESTQ CX, CX		
  0x414b25		7d30			JGE 0x414b57		
		if gp.preempt {
  0x414b27		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x414b2e		84c9			TESTL CL, CL		
  0x414b30		7414			JE 0x414b46		
			Gosched()
  0x414b32		e889e20000		CALL runtime.Gosched(SB)	
  0x414b37		488b442440		MOVQ 0x40(SP), AX		
  0x414b3c		0fb64c240f		MOVZX 0xf(SP), CX		
			goto retry
  0x414b41		e9c9feffff		JMP 0x414a0f		
		if !gcParkAssist() {
  0x414b46		e815050000		CALL runtime.gcParkAssist(SB)	
  0x414b4b		0fb60424		MOVZX 0(SP), AX			
  0x414b4f		84c0			TESTL AL, AL			
  0x414b51		0f84aefeffff		JE 0x414a05			
  0x414b57		0fb644240f		MOVZX 0xf(SP), AX		
	if traced {
  0x414b5c		84c0			TESTL AL, AL		
  0x414b5e		750a			JNE 0x414b6a		
  0x414b60		488b6c2430		MOVQ 0x30(SP), BP	
  0x414b65		4883c438		ADDQ $0x38, SP		
  0x414b69		c3			RET			
		traceGCMarkAssistDone()
  0x414b6a		e8815c0200		CALL runtime.traceGCMarkAssistDone(SB)	
  0x414b6f		ebef			JMP 0x414b60				
		gcMarkDone()
  0x414b71		e89acbffff		CALL runtime.gcMarkDone(SB)	
  0x414b76		488b442440		MOVQ 0x40(SP), AX		
  0x414b7b		eb9e			JMP 0x414b1b			
  0x414b7d		4889c2			MOVQ AX, DX			
	gp.param = nil
  0x414b80		31c0			XORL AX, AX			
  0x414b82		e8191d0300		CALL runtime.gcWriteBarrier(SB)	
  0x414b87		4889d0			MOVQ DX, AX			
  0x414b8a		eb8a			JMP 0x414b16			
  0x414b8c		48895c2410		MOVQ BX, 0x10(SP)		
		traceGCMarkAssistStart()
  0x414b91		e8fa5b0200		CALL runtime.traceGCMarkAssistStart(SB)	
  0x414b96		488b442440		MOVQ 0x40(SP), AX			
  0x414b9b		488b5c2410		MOVQ 0x10(SP), BX			
  0x414ba0		b901000000		MOVL $0x1, CX				
  0x414ba5		e91cffffff		JMP 0x414ac6				
	if traced {
  0x414baa		84c9			TESTL CL, CL		
			if traced {
  0x414bac		750a			JNE 0x414bb8		
			return
  0x414bae		488b6c2430		MOVQ 0x30(SP), BP	
  0x414bb3		4883c438		ADDQ $0x38, SP		
  0x414bb7		c3			RET			
				traceGCMarkAssistDone()
  0x414bb8		e8335c0200		CALL runtime.traceGCMarkAssistDone(SB)	
  0x414bbd		ebef			JMP 0x414bae				
			gp.gcAssistBytes += debtBytes
  0x414bbf		48039070010000		ADDQ 0x170(AX), DX	
  0x414bc6		48899070010000		MOVQ DX, 0x170(AX)	
  0x414bcd		4889de			MOVQ BX, SI		
  0x414bd0		e9bbfeffff		JMP 0x414a90		
		return
  0x414bd5		488b6c2430		MOVQ 0x30(SP), BP	
  0x414bda		4883c438		ADDQ $0x38, SP		
  0x414bde		c3			RET			
		return
  0x414bdf		488b6c2430		MOVQ 0x30(SP), BP	
  0x414be4		4883c438		ADDQ $0x38, SP		
  0x414be8		c3			RET			
func gcAssistAlloc(gp *g) {
  0x414be9		e882f90200		CALL runtime.morestack_noctxt(SB)	
  0x414bee		e9adfdffff		JMP runtime.gcAssistAlloc(SB)		

TEXT runtime.gcAssistAlloc1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcAssistAlloc1(gp *g, scanWork int64) {
  0x414c00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414c09		483b6118		CMPQ 0x18(CX), SP	
  0x414c0d		0f86a5030000		JBE 0x414fb8		
  0x414c13		4883ec50		SUBQ $0x50, SP		
  0x414c17		48896c2448		MOVQ BP, 0x48(SP)	
  0x414c1c		488d6c2448		LEAQ 0x48(SP), BP	
  0x414c21		488b4c2458		MOVQ 0x58(SP), CX	
	gp.param = nil
  0x414c26		8401			TESTB AL, 0(CX)				
  0x414c28		8b15e2ed0a00		MOVL runtime.writeBarrier(SB), DX	
  0x414c2e		488db988000000		LEAQ 0x88(CX), DI			
  0x414c35		85d2			TESTL DX, DX				
  0x414c37		0f854b020000		JNE 0x414e88				
  0x414c3d		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
	if atomic.Load(&gcBlackenEnabled) == 0 {
  0x414c48		8b0586ec0a00		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x414c4e		85c0			TESTL AX, AX				
  0x414c50		7515			JNE 0x414c67				
		gp.gcAssistBytes = 0
  0x414c52		48c7817001000000000000	MOVQ $0x0, 0x170(CX)	
		return
  0x414c5d		488b6c2448		MOVQ 0x48(SP), BP	
  0x414c62		4883c450		ADDQ $0x50, SP		
  0x414c66		c3			RET			
  0x414c67		48897c2440		MOVQ DI, 0x40(SP)	
	startTime := nanotime()
  0x414c6c		e8bf2d0300		CALL runtime.nanotime(SB)	
  0x414c71		488b0424		MOVQ 0(SP), AX			
	decnwait := atomic.Xadd(&work.nwait, -1)
  0x414c75		b9ffffffff		MOVL $-0x1, CX			
  0x414c7a		488d15bf310900		LEAQ runtime.work+160(SB), DX	
  0x414c81		f00fc10a		LOCK XADDL CX, 0(DX)		
  0x414c85		ffc9			DECL CX				
	if decnwait == work.nproc {
  0x414c87		8b1da3310900		MOVL runtime.work+144(SB), BX	
  0x414c8d		39d9			CMPL BX, CX			
  0x414c8f		0f84a5020000		JE 0x414f3a			
  0x414c95		4889442430		MOVQ AX, 0x30(SP)		
  0x414c9a		488b442458		MOVQ 0x58(SP), AX		
	casgstatus(gp, _Grunning, _Gwaiting)
  0x414c9f		48890424		MOVQ AX, 0(SP)			
  0x414ca3		48b90200000004000000	MOVQ $0x400000002, CX		
  0x414cad		48894c2408		MOVQ CX, 0x8(SP)		
  0x414cb2		e8c9fd0000		CALL runtime.casgstatus(SB)	
  0x414cb7		488b442458		MOVQ 0x58(SP), AX		
	gp.waitreason = "GC assist marking"
  0x414cbc		48c780b000000011000000	MOVQ $0x11, 0xb0(AX)			
  0x414cc7		8b0d43ed0a00		MOVL runtime.writeBarrier(SB), CX	
  0x414ccd		488db8a8000000		LEAQ 0xa8(AX), DI			
  0x414cd4		85c9			TESTL CX, CX				
  0x414cd6		0f859b010000		JNE 0x414e77				
  0x414cdc		488d0df25e0500		LEAQ 0x55ef2(IP), CX			
  0x414ce3		488988a8000000		MOVQ CX, 0xa8(AX)			
	gcw := &getg().m.p.ptr().gcw
  0x414cea		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x414cf3		488b4030		MOVQ 0x30(AX), AX	
  0x414cf7		488b88d0000000		MOVQ 0xd0(AX), CX	
  0x414cfe		8401			TESTB AL, 0(CX)		
  0x414d00		8400			TESTB AL, 0(AX)		
  0x414d02		488d8170120000		LEAQ 0x1270(CX), AX	
  0x414d09		4889442438		MOVQ AX, 0x38(SP)	
	workDone := gcDrainN(gcw, scanWork)
  0x414d0e		48890424		MOVQ AX, 0(SP)			
  0x414d12		488b4c2460		MOVQ 0x60(SP), CX		
  0x414d17		48894c2408		MOVQ CX, 0x8(SP)		
  0x414d1c		e81f160000		CALL runtime.gcDrainN(SB)	
  0x414d21		488b442410		MOVQ 0x10(SP), AX		
  0x414d26		4889442428		MOVQ AX, 0x28(SP)		
	if gcBlackenPromptly {
  0x414d2b		0fb60d75eb0a00		MOVZX runtime.gcBlackenPromptly(SB), CX	
  0x414d32		84c9			TESTL CL, CL				
  0x414d34		0f852a010000		JNE 0x414e64				
  0x414d3a		488b442458		MOVQ 0x58(SP), AX			
	casgstatus(gp, _Gwaiting, _Grunning)
  0x414d3f		48890424		MOVQ AX, 0(SP)			
  0x414d43		48b90400000002000000	MOVQ $0x200000004, CX		
  0x414d4d		48894c2408		MOVQ CX, 0x8(SP)		
  0x414d52		e829fd0000		CALL runtime.casgstatus(SB)	
  0x414d57		488b442428		MOVQ 0x28(SP), AX		
	gp.gcAssistBytes += 1 + int64(gcController.assistBytesPerWork*float64(workDone))
  0x414d5c		0f57c0			XORPS X0, X0				
  0x414d5f		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x414d64		f20f5905fcee0a00	MULSD runtime.gcController+72(SB), X0	
  0x414d6c		f2480f2cc0		CVTTSD2SIQ X0, AX			
  0x414d71		488b4c2458		MOVQ 0x58(SP), CX			
  0x414d76		48038170010000		ADDQ 0x170(CX), AX			
  0x414d7d		48ffc0			INCQ AX					
  0x414d80		48898170010000		MOVQ AX, 0x170(CX)			
	incnwait := atomic.Xadd(&work.nwait, +1)
  0x414d87		b801000000		MOVL $0x1, AX			
  0x414d8c		488d15ad300900		LEAQ runtime.work+160(SB), DX	
  0x414d93		f00fc102		LOCK XADDL AX, 0(DX)		
  0x414d97		ffc0			INCL AX				
	if incnwait > work.nproc {
  0x414d99		8b1591300900		MOVL runtime.work+144(SB), DX	
  0x414d9f		39d0			CMPL DX, AX			
  0x414da1		0f87ed000000		JA 0x414e94			
	if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x414da7		752d			JNE 0x414dd6		
	return atomic.Load64((*uint64)(head)) == 0
  0x414da9		488b15f02f0900		MOVQ runtime.work(SB), DX	
  0x414db0		4885d2			TESTQ DX, DX			
	if !work.full.empty() {
  0x414db3		0f85a1000000		JNE 0x414e5a		
	if work.markrootNext < work.markrootJobs {
  0x414db9		8b1569300900		MOVL runtime.work+136(SB), DX	
  0x414dbf		8b1d67300900		MOVL runtime.work+140(SB), BX	
  0x414dc5		39da			CMPL BX, DX			
  0x414dc7		0f8386000000		JAE 0x414e53			
  0x414dcd		b801000000		MOVL $0x1, AX			
	if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x414dd2		84c0			TESTL AL, AL		
  0x414dd4		745b			JE 0x414e31		
	duration := nanotime() - startTime
  0x414dd6		e8552c0300		CALL runtime.nanotime(SB)	
  0x414ddb		488b442458		MOVQ 0x58(SP), AX		
	_p_ := gp.m.p.ptr()
  0x414de0		488b4030		MOVQ 0x30(AX), AX	
  0x414de4		488b80d0000000		MOVQ 0xd0(AX), AX	
	_p_.gcAssistTime += duration
  0x414deb		8400			TESTB AL, 0(AX)		
	duration := nanotime() - startTime
  0x414ded		488b0c24		MOVQ 0(SP), CX		
  0x414df1		488b542430		MOVQ 0x30(SP), DX	
  0x414df6		4829d1			SUBQ DX, CX		
	_p_.gcAssistTime += duration
  0x414df9		48038848120000		ADDQ 0x1248(AX), CX	
  0x414e00		48898848120000		MOVQ CX, 0x1248(AX)	
	if _p_.gcAssistTime > gcAssistTimeSlack {
  0x414e07		4881f988130000		CMPQ $0x1388, CX	
  0x414e0e		7e17			JLE 0x414e27		
		atomic.Xaddint64(&gcController.assistTime, _p_.gcAssistTime)
  0x414e10		488d1519ee0a00		LEAQ runtime.gcController+16(SB), DX	
  0x414e17		f0480fc10a		LOCK XADDQ CX, 0(DX)			
		_p_.gcAssistTime = 0
  0x414e1c		48c7804812000000000000	MOVQ $0x0, 0x1248(AX)	
  0x414e27		488b6c2448		MOVQ 0x48(SP), BP	
  0x414e2c		4883c450		ADDQ $0x50, SP		
  0x414e30		c3			RET			
		gp.param = unsafe.Pointer(gp)
  0x414e31		8b15d9eb0a00		MOVL runtime.writeBarrier(SB), DX	
  0x414e37		85d2			TESTL DX, DX				
  0x414e39		7509			JNE 0x414e44				
  0x414e3b		48898988000000		MOVQ CX, 0x88(CX)			
  0x414e42		eb92			JMP 0x414dd6				
  0x414e44		488b7c2440		MOVQ 0x40(SP), DI			
  0x414e49		4889c8			MOVQ CX, AX				
  0x414e4c		e84f1a0300		CALL runtime.gcWriteBarrier(SB)		
  0x414e51		eb83			JMP 0x414dd6				
  0x414e53		31c0			XORL AX, AX				
	if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x414e55		e978ffffff		JMP 0x414dd2		
  0x414e5a		b801000000		MOVL $0x1, AX		
  0x414e5f		e96effffff		JMP 0x414dd2		
  0x414e64		488b442438		MOVQ 0x38(SP), AX	
		gcw.dispose()
  0x414e69		48890424		MOVQ AX, 0(SP)				
  0x414e6d		e80e440000		CALL runtime.(*gcWork).dispose(SB)	
  0x414e72		e9c3feffff		JMP 0x414d3a				
	gp.waitreason = "GC assist marking"
  0x414e77		488d05575d0500		LEAQ 0x55d57(IP), AX		
  0x414e7e		e81d1a0300		CALL runtime.gcWriteBarrier(SB)	
  0x414e83		e962feffff		JMP 0x414cea			
	gp.param = nil
  0x414e88		31c0			XORL AX, AX			
  0x414e8a		e8111a0300		CALL runtime.gcWriteBarrier(SB)	
  0x414e8f		e9b4fdffff		JMP 0x414c48			
  0x414e94		8944241c		MOVL AX, 0x1c(SP)		
  0x414e98		89542424		MOVL DX, 0x24(SP)		
		println("runtime: work.nwait=", incnwait,
  0x414e9c		e85fcc0000		CALL runtime.printlock(SB)		
  0x414ea1		488d059e640500		LEAQ 0x5649e(IP), AX			
  0x414ea8		48890424		MOVQ AX, 0(SP)				
  0x414eac		48c744240815000000	MOVQ $0x15, 0x8(SP)			
  0x414eb5		e886d50000		CALL runtime.printstring(SB)		
  0x414eba		8b44241c		MOVL 0x1c(SP), AX			
  0x414ebe		48890424		MOVQ AX, 0(SP)				
  0x414ec2		e8a9d20000		CALL runtime.printuint(SB)		
  0x414ec7		488d050b580500		LEAQ 0x5580b(IP), AX			
  0x414ece		48890424		MOVQ AX, 0(SP)				
  0x414ed2		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x414edb		e860d50000		CALL runtime.printstring(SB)		
  0x414ee0		8b442424		MOVL 0x24(SP), AX			
  0x414ee4		48890424		MOVQ AX, 0(SP)				
  0x414ee8		e883d20000		CALL runtime.printuint(SB)		
  0x414eed		488d05d5600500		LEAQ 0x560d5(IP), AX			
  0x414ef4		48890424		MOVQ AX, 0(SP)				
  0x414ef8		48c744240814000000	MOVQ $0x14, 0x8(SP)			
  0x414f01		e83ad50000		CALL runtime.printstring(SB)		
  0x414f06		0fb6059ae90a00		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x414f0d		880424			MOVB AL, 0(SP)				
  0x414f10		e8cbce0000		CALL runtime.printbool(SB)		
  0x414f15		e876ce0000		CALL runtime.printnl(SB)		
  0x414f1a		e861cc0000		CALL runtime.printunlock(SB)		
		throw("work.nwait > work.nproc")
  0x414f1f		488d0509690500		LEAQ 0x56909(IP), AX	
  0x414f26		48890424		MOVQ AX, 0(SP)		
  0x414f2a		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x414f33		e898c20000		CALL runtime.throw(SB)	
  0x414f38		0f0b			UD2			
  0x414f3a		894c2420		MOVL CX, 0x20(SP)	
  0x414f3e		895c2424		MOVL BX, 0x24(SP)	
		println("runtime: work.nwait =", decnwait, "work.nproc=", work.nproc)
  0x414f42		e8b9cb0000		CALL runtime.printlock(SB)	
  0x414f47		488d0596650500		LEAQ 0x56596(IP), AX		
  0x414f4e		48890424		MOVQ AX, 0(SP)			
  0x414f52		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x414f5b		e8e0d40000		CALL runtime.printstring(SB)	
  0x414f60		8b442420		MOVL 0x20(SP), AX		
  0x414f64		48890424		MOVQ AX, 0(SP)			
  0x414f68		e803d20000		CALL runtime.printuint(SB)	
  0x414f6d		488d0565570500		LEAQ 0x55765(IP), AX		
  0x414f74		48890424		MOVQ AX, 0(SP)			
  0x414f78		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x414f81		e8bad40000		CALL runtime.printstring(SB)	
  0x414f86		8b442424		MOVL 0x24(SP), AX		
  0x414f8a		48890424		MOVQ AX, 0(SP)			
  0x414f8e		e8ddd10000		CALL runtime.printuint(SB)	
  0x414f93		e8f8cd0000		CALL runtime.printnl(SB)	
  0x414f98		e8e3cb0000		CALL runtime.printunlock(SB)	
		throw("nwait > work.nprocs")
  0x414f9d		488d05415f0500		LEAQ 0x55f41(IP), AX	
  0x414fa4		48890424		MOVQ AX, 0(SP)		
  0x414fa8		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x414fb1		e81ac20000		CALL runtime.throw(SB)	
  0x414fb6		0f0b			UD2			
func gcAssistAlloc1(gp *g, scanWork int64) {
  0x414fb8		e8431d0200		CALL runtime.morestackc(SB)	
  0x414fbd		e93efcffff		JMP runtime.gcAssistAlloc1(SB)	

TEXT runtime.gcWakeAllAssists(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcWakeAllAssists() {
  0x414fd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414fd9		483b6110		CMPQ 0x10(CX), SP	
  0x414fdd		766c			JBE 0x41504b		
  0x414fdf		4883ec10		SUBQ $0x10, SP		
  0x414fe3		48896c2408		MOVQ BP, 0x8(SP)	
  0x414fe8		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&work.assistQueue.lock)
  0x414fed		488d05cc2e0900		LEAQ runtime.work+288(SB), AX	
  0x414ff4		48890424		MOVQ AX, 0(SP)			
  0x414ff8		e82345ffff		CALL runtime.lock(SB)		
	injectglist(work.assistQueue.head.ptr())
  0x414ffd		488b05c42e0900		MOVQ runtime.work+296(SB), AX	
  0x415004		48890424		MOVQ AX, 0(SP)			
  0x415008		e863370100		CALL runtime.injectglist(SB)	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41500d		488d05b42e0900		LEAQ runtime.work+296(SB), AX	
  0x415014		8400			TESTB AL, 0(AX)			
  0x415016		31c0			XORL AX, AX			
  0x415018		488905a92e0900		MOVQ AX, runtime.work+296(SB)	
  0x41501f		488d05aa2e0900		LEAQ runtime.work+304(SB), AX	
  0x415026		8400			TESTB AL, 0(AX)			
  0x415028		31c0			XORL AX, AX			
  0x41502a		4889059f2e0900		MOVQ AX, runtime.work+304(SB)	
	unlock(&work.assistQueue.lock)
  0x415031		488d05882e0900		LEAQ runtime.work+288(SB), AX	
  0x415038		48890424		MOVQ AX, 0(SP)			
  0x41503c		e87f46ffff		CALL runtime.unlock(SB)		
}
  0x415041		488b6c2408		MOVQ 0x8(SP), BP	
  0x415046		4883c410		ADDQ $0x10, SP		
  0x41504a		c3			RET			
func gcWakeAllAssists() {
  0x41504b		e820f50200		CALL runtime.morestack_noctxt(SB)	
  0x415050		e97bffffff		JMP runtime.gcWakeAllAssists(SB)	

TEXT runtime.gcParkAssist(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcParkAssist() bool {
  0x415060		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415069		483b6110		CMPQ 0x10(CX), SP	
  0x41506d		0f8653010000		JBE 0x4151c6		
  0x415073		4883ec30		SUBQ $0x30, SP		
  0x415077		48896c2428		MOVQ BP, 0x28(SP)	
  0x41507c		488d6c2428		LEAQ 0x28(SP), BP	
	lock(&work.assistQueue.lock)
  0x415081		488d05382e0900		LEAQ runtime.work+288(SB), AX	
  0x415088		48890424		MOVQ AX, 0(SP)			
  0x41508c		e88f44ffff		CALL runtime.lock(SB)		
	if atomic.Load(&gcBlackenEnabled) == 0 {
  0x415091		8b053de80a00		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x415097		85c0			TESTL AX, AX				
  0x415099		0f8408010000		JE 0x4151a7				
	gp := getg()
  0x41509f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	oldHead, oldTail := work.assistQueue.head, work.assistQueue.tail
  0x4150a8		488b0d192e0900		MOVQ runtime.work+296(SB), CX	
  0x4150af		488b151a2e0900		MOVQ runtime.work+304(SB), DX	
	if oldHead == 0 {
  0x4150b6		4885c9			TESTQ CX, CX		
  0x4150b9		0f85ca000000		JNE 0x415189		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4150bf		488d1d022e0900		LEAQ runtime.work+296(SB), BX	
  0x4150c6		8403			TESTB AL, 0(BX)			
  0x4150c8		4889c3			MOVQ AX, BX			
  0x4150cb		488905f62d0900		MOVQ AX, runtime.work+296(SB)	
  0x4150d2		488d05f72d0900		LEAQ runtime.work+304(SB), AX	
  0x4150d9		8400			TESTB AL, 0(AX)			
  0x4150db		4889d8			MOVQ BX, AX			
  0x4150de		48891deb2d0900		MOVQ BX, runtime.work+304(SB)	
	gp.schedlink.set(nil)
  0x4150e5		488d98b8000000		LEAQ 0xb8(AX), BX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4150ec		8403			TESTB AL, 0(BX)		
  0x4150ee		31db			XORL BX, BX		
  0x4150f0		488998b8000000		MOVQ BX, 0xb8(AX)	
	if atomic.Loadint64(&gcController.bgScanCredit) > 0 {
  0x4150f7		488b052aeb0a00		MOVQ runtime.gcController+8(SB), AX	
  0x4150fe		4885c0			TESTQ AX, AX				
  0x415101		7e44			JLE 0x415147				
		work.assistQueue.head = oldHead
  0x415103		48890dbe2d0900		MOVQ CX, runtime.work+296(SB)	
		work.assistQueue.tail = oldTail
  0x41510a		488915bf2d0900		MOVQ DX, runtime.work+304(SB)	
		if oldTail != 0 {
  0x415111		4885d2			TESTQ DX, DX		
  0x415114		7412			JE 0x415128		
			oldTail.ptr().schedlink.set(nil)
  0x415116		488d82b8000000		LEAQ 0xb8(DX), AX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41511d		8400			TESTB AL, 0(AX)		
  0x41511f		31c0			XORL AX, AX		
  0x415121		488982b8000000		MOVQ AX, 0xb8(DX)	
		unlock(&work.assistQueue.lock)
  0x415128		488d05912d0900		LEAQ runtime.work+288(SB), AX	
  0x41512f		48890424		MOVQ AX, 0(SP)			
  0x415133		e88845ffff		CALL runtime.unlock(SB)		
		return false
  0x415138		c644243800		MOVB $0x0, 0x38(SP)	
  0x41513d		488b6c2428		MOVQ 0x28(SP), BP	
  0x415142		4883c430		ADDQ $0x30, SP		
  0x415146		c3			RET			
	goparkunlock(&work.assistQueue.lock, "GC assist wait", traceEvGoBlockGC, 2)
  0x415147		488d05722d0900		LEAQ runtime.work+288(SB), AX	
  0x41514e		48890424		MOVQ AX, 0(SP)			
  0x415152		488d05cb560500		LEAQ 0x556cb(IP), AX		
  0x415159		4889442408		MOVQ AX, 0x8(SP)		
  0x41515e		48c74424100e000000	MOVQ $0xe, 0x10(SP)		
  0x415167		c64424182a		MOVB $0x2a, 0x18(SP)		
  0x41516c		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x415175		e8e6dd0000		CALL runtime.goparkunlock(SB)	
	return true
  0x41517a		c644243801		MOVB $0x1, 0x38(SP)	
  0x41517f		488b6c2428		MOVQ 0x28(SP), BP	
  0x415184		4883c430		ADDQ $0x30, SP		
  0x415188		c3			RET			
  0x415189		4889d6			MOVQ DX, SI		
		oldTail.ptr().schedlink.set(gp)
  0x41518c		488dbab8000000		LEAQ 0xb8(DX), DI	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x415193		8407			TESTB AL, 0(DI)		
  0x415195		4889c3			MOVQ AX, BX		
  0x415198		488982b8000000		MOVQ AX, 0xb8(DX)	
  0x41519f		4889f2			MOVQ SI, DX		
	work.assistQueue.tail.set(gp)
  0x4151a2		e92bffffff		JMP 0x4150d2		
		unlock(&work.assistQueue.lock)
  0x4151a7		488d05122d0900		LEAQ runtime.work+288(SB), AX	
  0x4151ae		48890424		MOVQ AX, 0(SP)			
  0x4151b2		e80945ffff		CALL runtime.unlock(SB)		
		return true
  0x4151b7		c644243801		MOVB $0x1, 0x38(SP)	
  0x4151bc		488b6c2428		MOVQ 0x28(SP), BP	
  0x4151c1		4883c430		ADDQ $0x30, SP		
  0x4151c5		c3			RET			
func gcParkAssist() bool {
  0x4151c6		e8a5f30200		CALL runtime.morestack_noctxt(SB)	
  0x4151cb		e990feffff		JMP runtime.gcParkAssist(SB)		

TEXT runtime.gcFlushBgCredit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcFlushBgCredit(scanWork int64) {
  0x4151d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4151d9		483b6110		CMPQ 0x10(CX), SP	
  0x4151dd		0f86ae010000		JBE 0x415391		
  0x4151e3		4883ec38		SUBQ $0x38, SP		
  0x4151e7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4151ec		488d6c2430		LEAQ 0x30(SP), BP	
	if work.assistQueue.head == 0 {
  0x4151f1		488b05d02c0900		MOVQ runtime.work+296(SB), AX	
  0x4151f8		4885c0			TESTQ AX, AX			
  0x4151fb		0f8475010000		JE 0x415376			
  0x415201		488b442440		MOVQ 0x40(SP), AX		
	scanBytes := int64(float64(scanWork) * gcController.assistBytesPerWork)
  0x415206		0f57c0			XORPS X0, X0				
  0x415209		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x41520e		f20f590552ea0a00	MULSD runtime.gcController+72(SB), X0	
  0x415216		f20f11442420		MOVSD_XMM X0, 0x20(SP)			
	lock(&work.assistQueue.lock)
  0x41521c		488d059d2c0900		LEAQ runtime.work+288(SB), AX	
  0x415223		48890424		MOVQ AX, 0(SP)			
  0x415227		e8f442ffff		CALL runtime.lock(SB)		
  0x41522c		f20f10442420		MOVSD_XMM 0x20(SP), X0		
	scanBytes := int64(float64(scanWork) * gcController.assistBytesPerWork)
  0x415232		f2480f2cc0		CVTTSD2SIQ X0, AX	
	gp := work.assistQueue.head.ptr()
  0x415237		488b0d8a2c0900		MOVQ runtime.work+296(SB), CX	
	for gp != nil && scanBytes > 0 {
  0x41523e		eb3d			JMP 0x41527d		
  0x415240		4889442418		MOVQ AX, 0x18(SP)	
			gp.gcAssistBytes = 0
  0x415245		48c7817001000000000000	MOVQ $0x0, 0x170(CX)	
			gp = gp.schedlink.ptr()
  0x415250		488b81b8000000		MOVQ 0xb8(CX), AX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x415257		4889442428		MOVQ AX, 0x28(SP)	
			ready(xgp, 0, false)
  0x41525c		48890c24		MOVQ CX, 0(SP)		
  0x415260		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x415269		c644241000		MOVB $0x0, 0x10(SP)	
  0x41526e		e8ddec0000		CALL runtime.ready(SB)	
  0x415273		488b4c2428		MOVQ 0x28(SP), CX	
  0x415278		488b442418		MOVQ 0x18(SP), AX	
	for gp != nil && scanBytes > 0 {
  0x41527d		4885c9			TESTQ CX, CX		
  0x415280		0f84e2000000		JE 0x415368		
  0x415286		4885c0			TESTQ AX, AX		
  0x415289		0f8ece000000		JLE 0x41535d		
		if scanBytes+gp.gcAssistBytes >= 0 {
  0x41528f		488b9170010000		MOVQ 0x170(CX), DX	
  0x415296		4801d0			ADDQ DX, AX		
  0x415299		4885c0			TESTQ AX, AX		
  0x41529c		7da2			JGE 0x415240		
			gp.gcAssistBytes += scanBytes
  0x41529e		48898170010000		MOVQ AX, 0x170(CX)	
			gp = gp.schedlink.ptr()
  0x4152a5		488b81b8000000		MOVQ 0xb8(CX), AX	
			if gp == nil {
  0x4152ac		4885c0			TESTQ AX, AX		
  0x4152af		0f84a3000000		JE 0x415358		
				xgp.schedlink = 0
  0x4152b5		48c781b800000000000000	MOVQ $0x0, 0xb8(CX)	
				work.assistQueue.tail.ptr().schedlink.set(xgp)
  0x4152c0		488b15092c0900		MOVQ runtime.work+304(SB), DX	
  0x4152c7		488d9ab8000000		LEAQ 0xb8(DX), BX		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4152ce		8403			TESTB AL, 0(BX)			
  0x4152d0		4889cb			MOVQ CX, BX			
  0x4152d3		48898ab8000000		MOVQ CX, 0xb8(DX)		
  0x4152da		488d0def2b0900		LEAQ runtime.work+304(SB), CX	
  0x4152e1		8401			TESTB AL, 0(CX)			
  0x4152e3		48891de62b0900		MOVQ BX, runtime.work+304(SB)	
			break
  0x4152ea		31c9			XORL CX, CX		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4152ec		488d15d52b0900		LEAQ runtime.work+296(SB), DX	
  0x4152f3		8402			TESTB AL, 0(DX)			
  0x4152f5		4889c2			MOVQ AX, DX			
  0x4152f8		488905c92b0900		MOVQ AX, runtime.work+296(SB)	
	if gp == nil {
  0x4152ff		4885d2			TESTQ DX, DX		
  0x415302		7440			JE 0x415344		
	if scanBytes > 0 {
  0x415304		4885c9			TESTQ CX, CX		
  0x415307		7e21			JLE 0x41532a		
		scanWork = int64(float64(scanBytes) * gcController.assistWorkPerByte)
  0x415309		0f57c0			XORPS X0, X0				
  0x41530c		f2480f2ac1		CVTSI2SDQ CX, X0			
  0x415311		f20f590547e90a00	MULSD runtime.gcController+64(SB), X0	
  0x415319		f2480f2cc0		CVTTSD2SIQ X0, AX			
		atomic.Xaddint64(&gcController.bgScanCredit, scanWork)
  0x41531e		488d0d03e90a00		LEAQ runtime.gcController+8(SB), CX	
  0x415325		f0480fc101		LOCK XADDQ AX, 0(CX)			
	unlock(&work.assistQueue.lock)
  0x41532a		488d058f2b0900		LEAQ runtime.work+288(SB), AX	
  0x415331		48890424		MOVQ AX, 0(SP)			
  0x415335		e88643ffff		CALL runtime.unlock(SB)		
}
  0x41533a		488b6c2430		MOVQ 0x30(SP), BP	
  0x41533f		4883c438		ADDQ $0x38, SP		
  0x415343		c3			RET			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x415344		488d05852b0900		LEAQ runtime.work+304(SB), AX	
  0x41534b		8400			TESTB AL, 0(AX)			
  0x41534d		31c0			XORL AX, AX			
  0x41534f		4889057a2b0900		MOVQ AX, runtime.work+304(SB)	
	if scanBytes > 0 {
  0x415356		ebac			JMP 0x415304		
  0x415358		4889c8			MOVQ CX, AX		
				gp = xgp
  0x41535b		eb8d			JMP 0x4152ea		
  0x41535d		4889c2			MOVQ AX, DX		
  0x415360		4889c8			MOVQ CX, AX		
  0x415363		4889d1			MOVQ DX, CX		
	for gp != nil && scanBytes > 0 {
  0x415366		eb84			JMP 0x4152ec		
  0x415368		4889c2			MOVQ AX, DX		
  0x41536b		4889c8			MOVQ CX, AX		
  0x41536e		4889d1			MOVQ DX, CX		
  0x415371		e976ffffff		JMP 0x4152ec		
  0x415376		488b442440		MOVQ 0x40(SP), AX	
		atomic.Xaddint64(&gcController.bgScanCredit, scanWork)
  0x41537b		488d0da6e80a00		LEAQ runtime.gcController+8(SB), CX	
  0x415382		f0480fc101		LOCK XADDQ AX, 0(CX)			
		return
  0x415387		488b6c2430		MOVQ 0x30(SP), BP	
  0x41538c		4883c438		ADDQ $0x38, SP		
  0x415390		c3			RET			
func gcFlushBgCredit(scanWork int64) {
  0x415391		e8daf10200		CALL runtime.morestack_noctxt(SB)	
  0x415396		e935feffff		JMP runtime.gcFlushBgCredit(SB)		

TEXT runtime.scanstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func scanstack(gp *g, gcw *gcWork) {
  0x4153a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4153a9		488d8424f0feffff	LEAQ 0xfffffef0(SP), AX	
  0x4153b1		483b4118		CMPQ 0x18(CX), AX	
  0x4153b5		0f8664040000		JBE 0x41581f		
  0x4153bb		4881ec90010000		SUBQ $0x190, SP		
  0x4153c2		4889ac2488010000	MOVQ BP, 0x188(SP)	
  0x4153ca		488dac2488010000	LEAQ 0x188(SP), BP	
  0x4153d2		488b842498010000	MOVQ 0x198(SP), AX	
	if gp.gcscanvalid {
  0x4153da		0fb688c4000000		MOVZX 0xc4(AX), CX	
  0x4153e1		84c9			TESTL CL, CL		
  0x4153e3		0f85c5010000		JNE 0x4155ae		
	return atomic.Load(&gp.atomicstatus)
  0x4153e9		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp)&_Gscan == 0 {
  0x4153ef		0fbae10c		BTL $0xc, CX		
  0x4153f3		0f836d030000		JAE 0x415766		
	return atomic.Load(&gp.atomicstatus)
  0x4153f9		8b8890000000		MOVL 0x90(AX), CX	
	switch readgstatus(gp) &^ _Gscan {
  0x4153ff		81e1ffefffff		ANDL $-0x1001, CX	
  0x415405		83f902			CMPL $0x2, CX		
  0x415408		0f877b010000		JA 0x415589		
	case _Grunnable, _Gsyscall, _Gwaiting:
  0x41540e		83f901			CMPL $0x1, CX		
  0x415411		0f8568010000		JNE 0x41557f		
	if gp == getg() {
  0x415417		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415420		4839c8			CMPQ CX, AX		
  0x415423		0f84b0010000		JE 0x4155d9		
	mp := gp.m
  0x415429		488b4830		MOVQ 0x30(AX), CX	
	if mp != nil && mp.helpgc != 0 {
  0x41542d		4885c9			TESTQ CX, CX		
  0x415430		740e			JE 0x415440		
  0x415432		8b8910010000		MOVL 0x110(CX), CX	
  0x415438		85c9			TESTL CX, CX		
  0x41543a		0f857e010000		JNE 0x4155be		
	if !work.markrootDone {
  0x415440		0fb60d392a0900		MOVZX runtime.work+224(SB), CX	
  0x415447		84c9			TESTL CL, CL			
  0x415449		0f841a010000		JE 0x415569			
	if gp.sched.ctxt != nil {
  0x41544f		488b4850		MOVQ 0x50(AX), CX	
  0x415453		488d5050		LEAQ 0x50(AX), DX	
  0x415457		4885c9			TESTQ CX, CX		
  0x41545a		0f85d1000000		JNE 0x415531		
	var cache pcvalueCache
  0x415460		488d7c2470		LEAQ 0x70(SP), DI	
  0x415465		0f57c0			XORPS X0, X0		
  0x415468		48896c24f0		MOVQ BP, -0x10(SP)	
  0x41546d		488d6c24f0		LEAQ -0x10(SP), BP	
  0x415472		e80d160300		CALL 0x446a84		
  0x415477		488b6d00		MOVQ 0(BP), BP		
	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  0x41547b		488d0dded10200		LEAQ runtime.scanstack.func1(SB), CX	
  0x415482		48898c2470010000	MOVQ CX, 0x170(SP)			
  0x41548a		488d4c2470		LEAQ 0x70(SP), CX			
  0x41548f		48898c2478010000	MOVQ CX, 0x178(SP)			
  0x415497		488b8c24a0010000	MOVQ 0x1a0(SP), CX			
  0x41549f		48898c2480010000	MOVQ CX, 0x180(SP)			
	gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, scanframe, nil, 0)
  0x4154a7		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x4154af		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x4154b8		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4154c1		4889442418		MOVQ AX, 0x18(SP)		
  0x4154c6		0f11442420		MOVUPS X0, 0x20(SP)		
  0x4154cb		48c7442430ffffff7f	MOVQ $0x7fffffff, 0x30(SP)	
  0x4154d4		488d8c2470010000	LEAQ 0x170(SP), CX		
  0x4154dc		48894c2438		MOVQ CX, 0x38(SP)		
  0x4154e1		0f11442440		MOVUPS X0, 0x40(SP)		
  0x4154e6		e8455e0200		CALL runtime.gentraceback(SB)	
  0x4154eb		488b842498010000	MOVQ 0x198(SP), AX		
	tracebackdefers(gp, scanframe, nil)
  0x4154f3		48890424		MOVQ AX, 0(SP)				
  0x4154f7		488d8c2470010000	LEAQ 0x170(SP), CX			
  0x4154ff		48894c2408		MOVQ CX, 0x8(SP)			
  0x415504		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x41550d		e81e5c0200		CALL runtime.tracebackdefers(SB)	
  0x415512		488b842498010000	MOVQ 0x198(SP), AX			
	gp.gcscanvalid = true
  0x41551a		c680c400000001		MOVB $0x1, 0xc4(AX)	
}
  0x415521		488bac2488010000	MOVQ 0x188(SP), BP	
  0x415529		4881c490010000		ADDQ $0x190, SP		
  0x415530		c3			RET			
		scanblock(uintptr(unsafe.Pointer(&gp.sched.ctxt)), sys.PtrSize, &oneptrmask[0], gcw)
  0x415531		488d05c8fa0800		LEAQ 0x8fac8(IP), AX		
  0x415538		4889442410		MOVQ AX, 0x10(SP)		
  0x41553d		48891424		MOVQ DX, 0(SP)			
  0x415541		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x41554a		488b8424a0010000	MOVQ 0x1a0(SP), AX		
  0x415552		4889442418		MOVQ AX, 0x18(SP)		
  0x415557		e8e40f0000		CALL runtime.scanblock(SB)	
  0x41555c		488b842498010000	MOVQ 0x198(SP), AX		
  0x415564		e9f7feffff		JMP 0x415460			
		shrinkstack(gp)
  0x415569		48890424		MOVQ AX, 0(SP)			
  0x41556d		e85e140200		CALL runtime.shrinkstack(SB)	
  0x415572		488b842498010000	MOVQ 0x198(SP), AX		
  0x41557a		e9d0feffff		JMP 0x41544f			
	switch readgstatus(gp) &^ _Gscan {
  0x41557f		83f902			CMPL $0x2, CX		
	case _Grunning:
  0x415582		7470			JE 0x4155f4		
  0x415584		e924010000		JMP 0x4156ad		
	case _Grunnable, _Gsyscall, _Gwaiting:
  0x415589		8d51fd			LEAL -0x3(CX), DX	
  0x41558c		83fa01			CMPL $0x1, DX		
  0x41558f		0f8682feffff		JBE 0x415417		
	case _Gdead:
  0x415595		83f906			CMPL $0x6, CX		
  0x415598		0f850f010000		JNE 0x4156ad		
		return
  0x41559e		488bac2488010000	MOVQ 0x188(SP), BP	
  0x4155a6		4881c490010000		ADDQ $0x190, SP		
  0x4155ad		c3			RET			
		return
  0x4155ae		488bac2488010000	MOVQ 0x188(SP), BP	
  0x4155b6		4881c490010000		ADDQ $0x190, SP		
  0x4155bd		c3			RET			
		throw("can't scan gchelper stack")
  0x4155be		488d051e640500		LEAQ 0x5641e(IP), AX	
  0x4155c5		48890424		MOVQ AX, 0(SP)		
  0x4155c9		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x4155d2		e8f9bb0000		CALL runtime.throw(SB)	
  0x4155d7		0f0b			UD2			
		throw("can't scan our own stack")
  0x4155d9		488d05ae620500		LEAQ 0x562ae(IP), AX	
  0x4155e0		48890424		MOVQ AX, 0(SP)		
  0x4155e4		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x4155ed		e8debb0000		CALL runtime.throw(SB)	
  0x4155f2		0f0b			UD2			
	return atomic.Load(&gp.atomicstatus)
  0x4155f4		8b8890000000		MOVL 0x90(AX), CX	
  0x4155fa		894c245c		MOVL CX, 0x5c(SP)	
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4155fe		488b9098000000		MOVQ 0x98(AX), DX		
  0x415605		4889542468		MOVQ DX, 0x68(SP)		
  0x41560a		e8f1c40000		CALL runtime.printlock(SB)	
  0x41560f		488d0528500500		LEAQ 0x55028(IP), AX		
  0x415616		48890424		MOVQ AX, 0(SP)			
  0x41561a		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x415623		e818ce0000		CALL runtime.printstring(SB)	
  0x415628		488b842498010000	MOVQ 0x198(SP), AX		
  0x415630		48890424		MOVQ AX, 0(SP)			
  0x415634		e8c7cd0000		CALL runtime.printpointer(SB)	
  0x415639		488d0552480500		LEAQ 0x54852(IP), AX		
  0x415640		48890424		MOVQ AX, 0(SP)			
  0x415644		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x41564d		e8eecd0000		CALL runtime.printstring(SB)	
  0x415652		488b442468		MOVQ 0x68(SP), AX		
  0x415657		48890424		MOVQ AX, 0(SP)			
  0x41565b		e820cc0000		CALL runtime.printint(SB)	
  0x415660		488d05ad570500		LEAQ 0x557ad(IP), AX		
  0x415667		48890424		MOVQ AX, 0(SP)			
  0x41566b		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x415674		e8c7cd0000		CALL runtime.printstring(SB)	
  0x415679		8b44245c		MOVL 0x5c(SP), AX		
  0x41567d		89c0			MOVL AX, AX			
  0x41567f		48890424		MOVQ AX, 0(SP)			
  0x415683		e8e8ca0000		CALL runtime.printuint(SB)	
  0x415688		e803c70000		CALL runtime.printnl(SB)	
  0x41568d		e8eec40000		CALL runtime.printunlock(SB)	
		throw("scanstack: goroutine not stopped")
  0x415692		488d056a720500		LEAQ 0x5726a(IP), AX	
  0x415699		48890424		MOVQ AX, 0(SP)		
  0x41569d		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x4156a6		e825bb0000		CALL runtime.throw(SB)	
  0x4156ab		0f0b			UD2			
	return atomic.Load(&gp.atomicstatus)
  0x4156ad		8b8890000000		MOVL 0x90(AX), CX	
  0x4156b3		894c2464		MOVL CX, 0x64(SP)	
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4156b7		488b9098000000		MOVQ 0x98(AX), DX		
  0x4156be		4889542468		MOVQ DX, 0x68(SP)		
  0x4156c3		e838c40000		CALL runtime.printlock(SB)	
  0x4156c8		488d056f4f0500		LEAQ 0x54f6f(IP), AX		
  0x4156cf		48890424		MOVQ AX, 0(SP)			
  0x4156d3		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x4156dc		e85fcd0000		CALL runtime.printstring(SB)	
  0x4156e1		488b842498010000	MOVQ 0x198(SP), AX		
  0x4156e9		48890424		MOVQ AX, 0(SP)			
  0x4156ed		e80ecd0000		CALL runtime.printpointer(SB)	
  0x4156f2		488d0599470500		LEAQ 0x54799(IP), AX		
  0x4156f9		48890424		MOVQ AX, 0(SP)			
  0x4156fd		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x415706		e835cd0000		CALL runtime.printstring(SB)	
  0x41570b		488b442468		MOVQ 0x68(SP), AX		
  0x415710		48890424		MOVQ AX, 0(SP)			
  0x415714		e867cb0000		CALL runtime.printint(SB)	
  0x415719		488d05f4560500		LEAQ 0x556f4(IP), AX		
  0x415720		48890424		MOVQ AX, 0(SP)			
  0x415724		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x41572d		e80ecd0000		CALL runtime.printstring(SB)	
  0x415732		8b442464		MOVL 0x64(SP), AX		
  0x415736		89c0			MOVL AX, AX			
  0x415738		48890424		MOVQ AX, 0(SP)			
  0x41573c		e82fca0000		CALL runtime.printuint(SB)	
  0x415741		e84ac60000		CALL runtime.printnl(SB)	
  0x415746		e835c40000		CALL runtime.printunlock(SB)	
		throw("mark - bad status")
  0x41574b		488d050b550500		LEAQ 0x5550b(IP), AX	
  0x415752		48890424		MOVQ AX, 0(SP)		
  0x415756		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x41575f		e86cba0000		CALL runtime.throw(SB)	
  0x415764		0f0b			UD2			
	return atomic.Load(&gp.atomicstatus)
  0x415766		8b8890000000		MOVL 0x90(AX), CX	
  0x41576c		894c2460		MOVL CX, 0x60(SP)	
		print("runtime:scanstack: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", hex(readgstatus(gp)), "\n")
  0x415770		488b9098000000		MOVQ 0x98(AX), DX		
  0x415777		4889542468		MOVQ DX, 0x68(SP)		
  0x41577c		e87fc30000		CALL runtime.printlock(SB)	
  0x415781		488d05725d0500		LEAQ 0x55d72(IP), AX		
  0x415788		48890424		MOVQ AX, 0(SP)			
  0x41578c		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x415795		e8a6cc0000		CALL runtime.printstring(SB)	
  0x41579a		488b842498010000	MOVQ 0x198(SP), AX		
  0x4157a2		48890424		MOVQ AX, 0(SP)			
  0x4157a6		e855cc0000		CALL runtime.printpointer(SB)	
  0x4157ab		488d05e0460500		LEAQ 0x546e0(IP), AX		
  0x4157b2		48890424		MOVQ AX, 0(SP)			
  0x4157b6		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4157bf		e87ccc0000		CALL runtime.printstring(SB)	
  0x4157c4		488b442468		MOVQ 0x68(SP), AX		
  0x4157c9		48890424		MOVQ AX, 0(SP)			
  0x4157cd		e8aeca0000		CALL runtime.printint(SB)	
  0x4157d2		488d053b560500		LEAQ 0x5563b(IP), AX		
  0x4157d9		48890424		MOVQ AX, 0(SP)			
  0x4157dd		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4157e6		e855cc0000		CALL runtime.printstring(SB)	
  0x4157eb		8b442460		MOVL 0x60(SP), AX		
  0x4157ef		89c0			MOVL AX, AX			
  0x4157f1		48890424		MOVQ AX, 0(SP)			
  0x4157f5		e8f6ca0000		CALL runtime.printhex(SB)	
  0x4157fa		e891c50000		CALL runtime.printnl(SB)	
  0x4157ff		e87cc30000		CALL runtime.printunlock(SB)	
		throw("scanstack - bad status")
  0x415804		488d051b5d0500		LEAQ 0x55d1b(IP), AX	
  0x41580b		48890424		MOVQ AX, 0(SP)		
  0x41580f		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x415818		e8b3b90000		CALL runtime.throw(SB)	
  0x41581d		0f0b			UD2			
func scanstack(gp *g, gcw *gcWork) {
  0x41581f		e8dc140200		CALL runtime.morestackc(SB)	
  0x415824		e977fbffff		JMP runtime.scanstack(SB)	

TEXT runtime.scanframeworker(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func scanframeworker(frame *stkframe, cache *pcvalueCache, gcw *gcWork) {
  0x415830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415839		488d4424e8		LEAQ -0x18(SP), AX	
  0x41583e		483b4110		CMPQ 0x10(CX), AX	
  0x415842		0f8677060000		JBE 0x415ebf		
  0x415848		4881ec98000000		SUBQ $0x98, SP		
  0x41584f		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x415857		488dac2490000000	LEAQ 0x90(SP), BP	
  0x41585f		488b8424a0000000	MOVQ 0xa0(SP), AX	
	f := frame.fn
  0x415867		488b4808		MOVQ 0x8(AX), CX	
  0x41586b		488b10			MOVQ 0(AX), DX		
	targetpc := frame.continpc
  0x41586e		488b5818		MOVQ 0x18(AX), BX	
	if targetpc == 0 {
  0x415872		4885db			TESTQ BX, BX		
  0x415875		0f8401020000		JE 0x415a7c		
	if targetpc != f.entry {
  0x41587b		488b32			MOVQ 0(DX), SI		
  0x41587e		4839f3			CMPQ SI, BX		
  0x415881		7403			JE 0x415886		
		targetpc--
  0x415883		48ffcb			DECQ BX			
  0x415886		48895c2438		MOVQ BX, 0x38(SP)	
  0x41588b		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x415893		4889942480000000	MOVQ DX, 0x80(SP)	
	pcdata := pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, cache)
  0x41589b		48891424		MOVQ DX, 0(SP)			
  0x41589f		48894c2408		MOVQ CX, 0x8(SP)		
  0x4158a4		c744241000000000	MOVL $0x0, 0x10(SP)		
  0x4158ac		48895c2418		MOVQ BX, 0x18(SP)		
  0x4158b1		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x4158b9		4889442420		MOVQ AX, 0x20(SP)		
  0x4158be		e87d350200		CALL runtime.pcdatavalue(SB)	
  0x4158c3		488d442410		LEAQ 0x10(SP), AX		
  0x4158c8		8b4c2428		MOVL 0x28(SP), CX		
	if pcdata == -1 {
  0x4158cc		83f9ff			CMPL $-0x1, CX		
  0x4158cf		7502			JNE 0x4158d3		
  0x4158d1		31c9			XORL CX, CX		
	size := frame.varp - frame.sp
  0x4158d3		894c2434		MOVL CX, 0x34(SP)	
  0x4158d7		488b9424a0000000	MOVQ 0xa0(SP), DX	
  0x4158df		488b5a38		MOVQ 0x38(DX), BX	
  0x4158e3		482b5a28		SUBQ 0x28(DX), BX	
	if size > minsize {
  0x4158e7		4885db			TESTQ BX, BX		
  0x4158ea		0f87cd000000		JA 0x4159bd		
	if frame.arglen > 0 {
  0x4158f0		488b4248		MOVQ 0x48(DX), AX	
  0x4158f4		4885c0			TESTQ AX, AX		
  0x4158f7		763a			JBE 0x415933		
		if frame.argmap != nil {
  0x4158f9		488b4250		MOVQ 0x50(DX), AX	
  0x4158fd		4885c0			TESTQ AX, AX		
  0x415900		7441			JE 0x415943		
			bv = *frame.argmap
  0x415902		488b4808		MOVQ 0x8(AX), CX	
  0x415906		8b00			MOVL 0(AX), AX		
		scanblock(frame.argp, uintptr(bv.n)*sys.PtrSize, bv.bytedata, gcw)
  0x415908		488b5240		MOVQ 0x40(DX), DX		
  0x41590c		48891424		MOVQ DX, 0(SP)			
  0x415910		4863c0			MOVSXD AX, AX			
  0x415913		48c1e003		SHLQ $0x3, AX			
  0x415917		4889442408		MOVQ AX, 0x8(SP)		
  0x41591c		48894c2410		MOVQ CX, 0x10(SP)		
  0x415921		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x415929		4889442418		MOVQ AX, 0x18(SP)		
  0x41592e		e80d0c0000		CALL runtime.scanblock(SB)	
  0x415933		488bac2490000000	MOVQ 0x90(SP), BP		
  0x41593b		4881c498000000		ADDQ $0x98, SP			
  0x415942		c3			RET				
  0x415943		488b842480000000	MOVQ 0x80(SP), AX		
			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
  0x41594b		48890424		MOVQ AX, 0(SP)			
  0x41594f		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x415957		48894c2408		MOVQ CX, 0x8(SP)		
  0x41595c		c744241000000000	MOVL $0x0, 0x10(SP)		
  0x415964		e887350200		CALL runtime.funcdata(SB)	
  0x415969		488b442418		MOVQ 0x18(SP), AX		
			if stkmap == nil || stkmap.n <= 0 {
  0x41596e		4885c0			TESTQ AX, AX		
  0x415971		0f843a020000		JE 0x415bb1		
  0x415977		8b08			MOVL 0(AX), CX		
  0x415979		85c9			TESTL CX, CX		
  0x41597b		0f8e30020000		JLE 0x415bb1		
  0x415981		4889442478		MOVQ AX, 0x78(SP)	
  0x415986		8b542434		MOVL 0x34(SP), DX	
			if pcdata < 0 || pcdata >= stkmap.n {
  0x41598a		85d2			TESTL DX, DX		
  0x41598c		0f8cfa000000		JL 0x415a8c		
  0x415992		39ca			CMPL CX, DX		
  0x415994		0f8df2000000		JGE 0x415a8c		
			bv = stackmapdata(stkmap, pcdata)
  0x41599a		48890424		MOVQ AX, 0(SP)			
  0x41599e		89542408		MOVL DX, 0x8(SP)		
  0x4159a2		e849380200		CALL runtime.stackmapdata(SB)	
  0x4159a7		8b442410		MOVL 0x10(SP), AX		
  0x4159ab		488b4c2418		MOVQ 0x18(SP), CX		
  0x4159b0		488b9424a0000000	MOVQ 0xa0(SP), DX		
  0x4159b8		e94bffffff		JMP 0x415908			
  0x4159bd		4889442470		MOVQ AX, 0x70(SP)		
  0x4159c2		48895c2440		MOVQ BX, 0x40(SP)		
  0x4159c7		488b842480000000	MOVQ 0x80(SP), AX		
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps))
  0x4159cf		48890424		MOVQ AX, 0(SP)			
  0x4159d3		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x4159db		48894c2408		MOVQ CX, 0x8(SP)		
  0x4159e0		c744241001000000	MOVL $0x1, 0x10(SP)		
  0x4159e8		e803350200		CALL runtime.funcdata(SB)	
  0x4159ed		488b442418		MOVQ 0x18(SP), AX		
		if stkmap == nil || stkmap.n <= 0 {
  0x4159f2		4885c0			TESTQ AX, AX		
  0x4159f5		0f84d0030000		JE 0x415dcb		
  0x4159fb		8b08			MOVL 0(AX), CX		
  0x4159fd		85c9			TESTL CX, CX		
  0x4159ff		0f8ec6030000		JLE 0x415dcb		
  0x415a05		4889442478		MOVQ AX, 0x78(SP)	
  0x415a0a		8b542434		MOVL 0x34(SP), DX	
		if pcdata < 0 || pcdata >= stkmap.n {
  0x415a0e		85d2			TESTL DX, DX		
  0x415a10		0f8c90020000		JL 0x415ca6		
  0x415a16		39ca			CMPL CX, DX		
  0x415a18		0f8d88020000		JGE 0x415ca6		
		bv := stackmapdata(stkmap, pcdata)
  0x415a1e		48890424		MOVQ AX, 0(SP)			
  0x415a22		89542408		MOVL DX, 0x8(SP)		
  0x415a26		e8c5370200		CALL runtime.stackmapdata(SB)	
  0x415a2b		488b442418		MOVQ 0x18(SP), AX		
  0x415a30		488b4c2470		MOVQ 0x70(SP), CX		
		size = uintptr(bv.n) * sys.PtrSize
  0x415a35		486309			MOVSXD 0(CX), CX	
  0x415a38		48c1e103		SHLQ $0x3, CX		
  0x415a3c		488b9424a0000000	MOVQ 0xa0(SP), DX	
		scanblock(frame.varp-size, size, bv.bytedata, gcw)
  0x415a44		488b5a38		MOVQ 0x38(DX), BX		
  0x415a48		4829cb			SUBQ CX, BX			
  0x415a4b		48891c24		MOVQ BX, 0(SP)			
  0x415a4f		48894c2408		MOVQ CX, 0x8(SP)		
  0x415a54		4889442410		MOVQ AX, 0x10(SP)		
  0x415a59		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x415a61		4889442418		MOVQ AX, 0x18(SP)		
  0x415a66		e8d50a0000		CALL runtime.scanblock(SB)	
  0x415a6b		8b4c2434		MOVL 0x34(SP), CX		
  0x415a6f		488b9424a0000000	MOVQ 0xa0(SP), DX		
  0x415a77		e974feffff		JMP 0x4158f0			
		return
  0x415a7c		488bac2490000000	MOVQ 0x90(SP), BP	
  0x415a84		4881c498000000		ADDQ $0x98, SP		
  0x415a8b		c3			RET			
  0x415a8c		488b842480000000	MOVQ 0x80(SP), AX	
				print("runtime: pcdata is ", pcdata, " and ", stkmap.n, " args stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
  0x415a94		48890424		MOVQ AX, 0(SP)			
  0x415a98		488b842488000000	MOVQ 0x88(SP), AX		
  0x415aa0		4889442408		MOVQ AX, 0x8(SP)		
  0x415aa5		e8562e0200		CALL runtime.funcname(SB)	
  0x415aaa		488b442478		MOVQ 0x78(SP), AX		
  0x415aaf		486300			MOVSXD 0(AX), AX		
  0x415ab2		4889442460		MOVQ AX, 0x60(SP)		
  0x415ab7		488b4c2410		MOVQ 0x10(SP), CX		
  0x415abc		48894c2468		MOVQ CX, 0x68(SP)		
  0x415ac1		488b542418		MOVQ 0x18(SP), DX		
  0x415ac6		4889542458		MOVQ DX, 0x58(SP)		
  0x415acb		e830c00000		CALL runtime.printlock(SB)	
  0x415ad0		488d0593540500		LEAQ 0x55493(IP), AX		
  0x415ad7		48890424		MOVQ AX, 0(SP)			
  0x415adb		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x415ae4		e857c90000		CALL runtime.printstring(SB)	
  0x415ae9		8b442434		MOVL 0x34(SP), AX		
  0x415aed		4863c0			MOVSXD AX, AX			
  0x415af0		48890424		MOVQ AX, 0(SP)			
  0x415af4		e887c70000		CALL runtime.printint(SB)	
  0x415af9		488d0554420500		LEAQ 0x54254(IP), AX		
  0x415b00		48890424		MOVQ AX, 0(SP)			
  0x415b04		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x415b0d		e82ec90000		CALL runtime.printstring(SB)	
  0x415b12		488b442460		MOVQ 0x60(SP), AX		
  0x415b17		48890424		MOVQ AX, 0(SP)			
  0x415b1b		e860c70000		CALL runtime.printint(SB)	
  0x415b20		488d055b640500		LEAQ 0x5645b(IP), AX		
  0x415b27		48890424		MOVQ AX, 0(SP)			
  0x415b2b		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x415b34		e807c90000		CALL runtime.printstring(SB)	
  0x415b39		488b442468		MOVQ 0x68(SP), AX		
  0x415b3e		48890424		MOVQ AX, 0(SP)			
  0x415b42		488b442458		MOVQ 0x58(SP), AX		
  0x415b47		4889442408		MOVQ AX, 0x8(SP)		
  0x415b4c		e8efc80000		CALL runtime.printstring(SB)	
  0x415b51		488d054b480500		LEAQ 0x5484b(IP), AX		
  0x415b58		48890424		MOVQ AX, 0(SP)			
  0x415b5c		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x415b65		e8d6c80000		CALL runtime.printstring(SB)	
  0x415b6a		488b442438		MOVQ 0x38(SP), AX		
  0x415b6f		48890424		MOVQ AX, 0(SP)			
  0x415b73		e8f8c50000		CALL runtime.printuint(SB)	
  0x415b78		488d05eb400500		LEAQ 0x540eb(IP), AX		
  0x415b7f		48890424		MOVQ AX, 0(SP)			
  0x415b83		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x415b8c		e8afc80000		CALL runtime.printstring(SB)	
  0x415b91		e8eabf0000		CALL runtime.printunlock(SB)	
				throw("scanframe: bad symbol table")
  0x415b96		488d0528630500		LEAQ 0x56328(IP), AX	
  0x415b9d		48890424		MOVQ AX, 0(SP)		
  0x415ba1		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x415baa		e821b60000		CALL runtime.throw(SB)	
  0x415baf		0f0b			UD2			
  0x415bb1		488b842480000000	MOVQ 0x80(SP), AX	
				print("runtime: frame ", funcname(f), " untyped args ", hex(frame.argp), "+", hex(frame.arglen), "\n")
  0x415bb9		48890424		MOVQ AX, 0(SP)			
  0x415bbd		488b842488000000	MOVQ 0x88(SP), AX		
  0x415bc5		4889442408		MOVQ AX, 0x8(SP)		
  0x415bca		e8312d0200		CALL runtime.funcname(SB)	
  0x415bcf		488b442410		MOVQ 0x10(SP), AX		
  0x415bd4		4889442468		MOVQ AX, 0x68(SP)		
  0x415bd9		488b4c2418		MOVQ 0x18(SP), CX		
  0x415bde		48894c2458		MOVQ CX, 0x58(SP)		
  0x415be3		488b9424a0000000	MOVQ 0xa0(SP), DX		
  0x415beb		488b5a40		MOVQ 0x40(DX), BX		
  0x415bef		48895c2450		MOVQ BX, 0x50(SP)		
  0x415bf4		488b5248		MOVQ 0x48(DX), DX		
  0x415bf8		4889542448		MOVQ DX, 0x48(SP)		
  0x415bfd		e8febe0000		CALL runtime.printlock(SB)	
  0x415c02		488d05ad4d0500		LEAQ 0x54dad(IP), AX		
  0x415c09		48890424		MOVQ AX, 0(SP)			
  0x415c0d		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x415c16		e825c80000		CALL runtime.printstring(SB)	
  0x415c1b		488b442468		MOVQ 0x68(SP), AX		
  0x415c20		48890424		MOVQ AX, 0(SP)			
  0x415c24		488b442458		MOVQ 0x58(SP), AX		
  0x415c29		4889442408		MOVQ AX, 0x8(SP)		
  0x415c2e		e80dc80000		CALL runtime.printstring(SB)	
  0x415c33		488d05ce4b0500		LEAQ 0x54bce(IP), AX		
  0x415c3a		48890424		MOVQ AX, 0(SP)			
  0x415c3e		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x415c47		e8f4c70000		CALL runtime.printstring(SB)	
  0x415c4c		488b442450		MOVQ 0x50(SP), AX		
  0x415c51		48890424		MOVQ AX, 0(SP)			
  0x415c55		e896c60000		CALL runtime.printhex(SB)	
  0x415c5a		488d05f23f0500		LEAQ 0x53ff2(IP), AX		
  0x415c61		48890424		MOVQ AX, 0(SP)			
  0x415c65		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x415c6e		e8cdc70000		CALL runtime.printstring(SB)	
  0x415c73		488b442448		MOVQ 0x48(SP), AX		
  0x415c78		48890424		MOVQ AX, 0(SP)			
  0x415c7c		e86fc60000		CALL runtime.printhex(SB)	
  0x415c81		e80ac10000		CALL runtime.printnl(SB)	
  0x415c86		e8f5be0000		CALL runtime.printunlock(SB)	
				throw("missing stackmap")
  0x415c8b		488d05804e0500		LEAQ 0x54e80(IP), AX	
  0x415c92		48890424		MOVQ AX, 0(SP)		
  0x415c96		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x415c9f		e82cb50000		CALL runtime.throw(SB)	
  0x415ca4		0f0b			UD2			
  0x415ca6		488b842480000000	MOVQ 0x80(SP), AX	
			print("runtime: pcdata is ", pcdata, " and ", stkmap.n, " locals stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
  0x415cae		48890424		MOVQ AX, 0(SP)			
  0x415cb2		488b842488000000	MOVQ 0x88(SP), AX		
  0x415cba		4889442408		MOVQ AX, 0x8(SP)		
  0x415cbf		e83c2c0200		CALL runtime.funcname(SB)	
  0x415cc4		488b442478		MOVQ 0x78(SP), AX		
  0x415cc9		486300			MOVSXD 0(AX), AX		
  0x415ccc		4889442460		MOVQ AX, 0x60(SP)		
  0x415cd1		488b4c2410		MOVQ 0x10(SP), CX		
  0x415cd6		48894c2468		MOVQ CX, 0x68(SP)		
  0x415cdb		488b542418		MOVQ 0x18(SP), DX		
  0x415ce0		4889542458		MOVQ DX, 0x58(SP)		
  0x415ce5		e816be0000		CALL runtime.printlock(SB)	
  0x415cea		488d0579520500		LEAQ 0x55279(IP), AX		
  0x415cf1		48890424		MOVQ AX, 0(SP)			
  0x415cf5		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x415cfe		e83dc70000		CALL runtime.printstring(SB)	
  0x415d03		8b442434		MOVL 0x34(SP), AX		
  0x415d07		4863c0			MOVSXD AX, AX			
  0x415d0a		48890424		MOVQ AX, 0(SP)			
  0x415d0e		e86dc50000		CALL runtime.printint(SB)	
  0x415d13		488d053a400500		LEAQ 0x5403a(IP), AX		
  0x415d1a		48890424		MOVQ AX, 0(SP)			
  0x415d1e		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x415d27		e814c70000		CALL runtime.printstring(SB)	
  0x415d2c		488b442460		MOVQ 0x60(SP), AX		
  0x415d31		48890424		MOVQ AX, 0(SP)			
  0x415d35		e846c50000		CALL runtime.printint(SB)	
  0x415d3a		488d05b2660500		LEAQ 0x566b2(IP), AX		
  0x415d41		48890424		MOVQ AX, 0(SP)			
  0x415d45		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x415d4e		e8edc60000		CALL runtime.printstring(SB)	
  0x415d53		488b442468		MOVQ 0x68(SP), AX		
  0x415d58		48890424		MOVQ AX, 0(SP)			
  0x415d5c		488b442458		MOVQ 0x58(SP), AX		
  0x415d61		4889442408		MOVQ AX, 0x8(SP)		
  0x415d66		e8d5c60000		CALL runtime.printstring(SB)	
  0x415d6b		488d0531460500		LEAQ 0x54631(IP), AX		
  0x415d72		48890424		MOVQ AX, 0(SP)			
  0x415d76		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x415d7f		e8bcc60000		CALL runtime.printstring(SB)	
  0x415d84		488b442438		MOVQ 0x38(SP), AX		
  0x415d89		48890424		MOVQ AX, 0(SP)			
  0x415d8d		e8dec30000		CALL runtime.printuint(SB)	
  0x415d92		488d05d13e0500		LEAQ 0x53ed1(IP), AX		
  0x415d99		48890424		MOVQ AX, 0(SP)			
  0x415d9d		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x415da6		e895c60000		CALL runtime.printstring(SB)	
  0x415dab		e8d0bd0000		CALL runtime.printunlock(SB)	
			throw("scanframe: bad symbol table")
  0x415db0		488d050e610500		LEAQ 0x5610e(IP), AX	
  0x415db7		48890424		MOVQ AX, 0(SP)		
  0x415dbb		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x415dc4		e807b40000		CALL runtime.throw(SB)	
  0x415dc9		0f0b			UD2			
  0x415dcb		488b842480000000	MOVQ 0x80(SP), AX	
			print("runtime: frame ", funcname(f), " untyped locals ", hex(frame.varp-size), "+", hex(size), "\n")
  0x415dd3		48890424		MOVQ AX, 0(SP)			
  0x415dd7		488b842488000000	MOVQ 0x88(SP), AX		
  0x415ddf		4889442408		MOVQ AX, 0x8(SP)		
  0x415de4		e8172b0200		CALL runtime.funcname(SB)	
  0x415de9		488b442410		MOVQ 0x10(SP), AX		
  0x415dee		4889442468		MOVQ AX, 0x68(SP)		
  0x415df3		488b4c2418		MOVQ 0x18(SP), CX		
  0x415df8		48894c2458		MOVQ CX, 0x58(SP)		
  0x415dfd		488b9424a0000000	MOVQ 0xa0(SP), DX		
  0x415e05		488b5238		MOVQ 0x38(DX), DX		
  0x415e09		4889542450		MOVQ DX, 0x50(SP)		
  0x415e0e		e8edbc0000		CALL runtime.printlock(SB)	
  0x415e13		488d059c4b0500		LEAQ 0x54b9c(IP), AX		
  0x415e1a		48890424		MOVQ AX, 0(SP)			
  0x415e1e		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x415e27		e814c60000		CALL runtime.printstring(SB)	
  0x415e2c		488b442468		MOVQ 0x68(SP), AX		
  0x415e31		48890424		MOVQ AX, 0(SP)			
  0x415e35		488b442458		MOVQ 0x58(SP), AX		
  0x415e3a		4889442408		MOVQ AX, 0x8(SP)		
  0x415e3f		e8fcc50000		CALL runtime.printstring(SB)	
  0x415e44		488d05d74b0500		LEAQ 0x54bd7(IP), AX		
  0x415e4b		48890424		MOVQ AX, 0(SP)			
  0x415e4f		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x415e58		e8e3c50000		CALL runtime.printstring(SB)	
  0x415e5d		488b442450		MOVQ 0x50(SP), AX		
  0x415e62		488b4c2440		MOVQ 0x40(SP), CX		
  0x415e67		4829c8			SUBQ CX, AX			
  0x415e6a		48890424		MOVQ AX, 0(SP)			
  0x415e6e		e87dc40000		CALL runtime.printhex(SB)	
  0x415e73		488d05d93d0500		LEAQ 0x53dd9(IP), AX		
  0x415e7a		48890424		MOVQ AX, 0(SP)			
  0x415e7e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x415e87		e8b4c50000		CALL runtime.printstring(SB)	
  0x415e8c		488b442440		MOVQ 0x40(SP), AX		
  0x415e91		48890424		MOVQ AX, 0(SP)			
  0x415e95		e856c40000		CALL runtime.printhex(SB)	
  0x415e9a		e8f1be0000		CALL runtime.printnl(SB)	
  0x415e9f		e8dcbc0000		CALL runtime.printunlock(SB)	
			throw("missing stackmap")
  0x415ea4		488d05674c0500		LEAQ 0x54c67(IP), AX	
  0x415eab		48890424		MOVQ AX, 0(SP)		
  0x415eaf		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x415eb8		e813b30000		CALL runtime.throw(SB)	
  0x415ebd		0f0b			UD2			
func scanframeworker(frame *stkframe, cache *pcvalueCache, gcw *gcWork) {
  0x415ebf		e8ace60200		CALL runtime.morestack_noctxt(SB)	
  0x415ec4		e967f9ffff		JMP runtime.scanframeworker(SB)		

TEXT runtime.gcDrain(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
  0x415ed0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415ed9		483b6110		CMPQ 0x10(CX), SP	
  0x415edd		0f8647040000		JBE 0x41632a		
  0x415ee3		4883ec50		SUBQ $0x50, SP		
  0x415ee7		48896c2448		MOVQ BP, 0x48(SP)	
  0x415eec		488d6c2448		LEAQ 0x48(SP), BP	
	if !writeBarrier.needed {
  0x415ef1		0fb6051cdb0a00		MOVZX runtime.writeBarrier+4(SB), AX	
  0x415ef8		84c0			TESTL AL, AL				
  0x415efa		0f840f040000		JE 0x41630f				
	gp := getg().m.curg
  0x415f00		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x415f09		488b4030		MOVQ 0x30(AX), AX	
  0x415f0d		488b80c0000000		MOVQ 0xc0(AX), AX	
  0x415f14		488b4c2458		MOVQ 0x58(SP), CX	
	initScanWork := gcw.scanWork
  0x415f19		488b5118		MOVQ 0x18(CX), DX	
  0x415f1d		488b5c2460		MOVQ 0x60(SP), BX	
	if flags&(gcDrainIdle|gcDrainFractional) != 0 {
  0x415f22		48f7c318000000		TESTQ $0x18, BX		
  0x415f29		0f84c8030000		JE 0x4162f7		
	idle := flags&gcDrainIdle != 0
  0x415f2f		0fbae303		BTL $0x3, BX		
		if idle {
  0x415f33		0f83a5030000		JAE 0x4162de		
  0x415f39		488d3570820500		LEAQ 0x58270(IP), SI	
		checkWork = initScanWork + drainCheckThreshold
  0x415f40		488dbaa0860100		LEAQ 0x186a0(DX), DI	
	if work.markrootNext < work.markrootJobs {
  0x415f47		4889442438		MOVQ AX, 0x38(SP)		
  0x415f4c		4889742440		MOVQ SI, 0x40(SP)		
  0x415f51		448b05d01e0900		MOVL runtime.work+136(SB), R8	
  0x415f58		448b0dcd1e0900		MOVL runtime.work+140(SB), R9	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x415f5f		0fbae300		BTL $0x0, BX		
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x415f63		0fbae302		BTL $0x2, BX		
	if work.markrootNext < work.markrootJobs {
  0x415f67		4539c8			CMPL R9, R8		
  0x415f6a		0f8365030000		JAE 0x4162d5		
  0x415f70		4889542410		MOVQ DX, 0x10(SP)	
  0x415f75		48897c2418		MOVQ DI, 0x18(SP)	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x415f7a		0fbae300		BTL $0x0, BX		
		for !(preemptible && gp.preempt) {
  0x415f7e		eb1e			JMP 0x415f9e		
  0x415f80		488b442438		MOVQ 0x38(SP), AX	
  0x415f85		488b4c2458		MOVQ 0x58(SP), CX	
  0x415f8a		488b542410		MOVQ 0x10(SP), DX	
  0x415f8f		488b5c2460		MOVQ 0x60(SP), BX	
  0x415f94		488b742440		MOVQ 0x40(SP), SI	
  0x415f99		488b7c2418		MOVQ 0x18(SP), DI	
  0x415f9e		7311			JAE 0x415fb1		
  0x415fa0		440fb680c0000000	MOVZX 0xc0(AX), R8	
  0x415fa8		4584c0			TESTL R8, R8		
  0x415fab		0f851b030000		JNE 0x4162cc		
			job := atomic.Xadd(&work.markrootNext, +1) - 1
  0x415fb1		41b801000000		MOVL $0x1, R8			
  0x415fb7		4c8d0d6a1e0900		LEAQ runtime.work+136(SB), R9	
  0x415fbe		f0450fc101		LOCK XADDL R8, 0(R9)		
			if job >= work.markrootJobs {
  0x415fc3		448b15621e0900		MOVL runtime.work+140(SB), R10	
  0x415fca		4539d0			CMPL R10, R8			
  0x415fcd		0f8396000000		JAE 0x416069			
			markroot(gcw, job)
  0x415fd3		48890c24		MOVQ CX, 0(SP)			
  0x415fd7		4489442408		MOVL R8, 0x8(SP)		
  0x415fdc		e82fe2ffff		CALL runtime.markroot(SB)	
  0x415fe1		488b542440		MOVQ 0x40(SP), DX		
			if check != nil && check() {
  0x415fe6		4885d2			TESTQ DX, DX		
  0x415fe9		750b			JNE 0x415ff6		
  0x415feb		488b442460		MOVQ 0x60(SP), AX	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x415ff0		0fbae000		BTL $0x0, AX		
			if check != nil && check() {
  0x415ff4		eb8a			JMP 0x415f80		
  0x415ff6		488b02			MOVQ 0(DX), AX		
  0x415ff9		ffd0			CALL AX			
  0x415ffb		0fb60424		MOVZX 0(SP), AX		
  0x415fff		84c0			TESTL AL, AL		
  0x416001		7513			JNE 0x416016		
  0x416003		488b442460		MOVQ 0x60(SP), AX	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x416008		0fbae000		BTL $0x0, AX		
  0x41600c		488b542440		MOVQ 0x40(SP), DX	
			if check != nil && check() {
  0x416011		e96affffff		JMP 0x415f80		
  0x416016		488b442410		MOVQ 0x10(SP), AX	
				goto done
  0x41601b		488b4c2458		MOVQ 0x58(SP), CX	
	if gcw.scanWork > 0 {
  0x416020		488b5118		MOVQ 0x18(CX), DX	
  0x416024		4885d2			TESTQ DX, DX		
  0x416027		7e1f			JLE 0x416048		
		atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
  0x416029		488d1df0db0a00		LEAQ runtime.gcController(SB), BX	
  0x416030		f0480fc113		LOCK XADDQ DX, 0(BX)			
  0x416035		488b542460		MOVQ 0x60(SP), DX			
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x41603a		0fbae202		BTL $0x2, DX		
		if flushBgCredit {
  0x41603e		7212			JB 0x416052		
		gcw.scanWork = 0
  0x416040		48c7411800000000	MOVQ $0x0, 0x18(CX)	
  0x416048		488b6c2448		MOVQ 0x48(SP), BP	
  0x41604d		4883c450		ADDQ $0x50, SP		
  0x416051		c3			RET			
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x416052		488b5118		MOVQ 0x18(CX), DX			
  0x416056		4829c2			SUBQ AX, DX				
  0x416059		48891424		MOVQ DX, 0(SP)				
  0x41605d		e86ef1ffff		CALL runtime.gcFlushBgCredit(SB)	
  0x416062		488b4c2458		MOVQ 0x58(SP), CX			
  0x416067		ebd7			JMP 0x416040				
	preemptible := flags&gcDrainUntilPreempt != 0
  0x416069		0fbae300		BTL $0x0, BX		
	blocking := flags&(gcDrainUntilPreempt|gcDrainIdle|gcDrainFractional|gcDrainNoBlock) == 0
  0x41606d		48f7c31b000000		TESTQ $0x1b, BX		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x416074		0fbae300		BTL $0x0, BX		
	for !(preemptible && gp.preempt) {
  0x416078		eb17			JMP 0x416091		
  0x41607a		488b442438		MOVQ 0x38(SP), AX	
  0x41607f		488b4c2458		MOVQ 0x58(SP), CX	
  0x416084		488b5c2460		MOVQ 0x60(SP), BX	
  0x416089		4889f7			MOVQ SI, DI		
  0x41608c		488b742440		MOVQ 0x40(SP), SI	
  0x416091		7311			JAE 0x4160a4		
  0x416093		440fb680c0000000	MOVZX 0xc0(AX), R8	
  0x41609b		4584c0			TESTL R8, R8		
  0x41609e		0f8520020000		JNE 0x4162c4		
  0x4160a4		4889542430		MOVQ DX, 0x30(SP)	
  0x4160a9		48897c2418		MOVQ DI, 0x18(SP)	
		if work.full == 0 {
  0x4160ae		4c8b05eb1c0900		MOVQ runtime.work(SB), R8	
  0x4160b5		4d85c0			TESTQ R8, R8			
  0x4160b8		0f84d3010000		JE 0x416291			
	blocking := flags&(gcDrainUntilPreempt|gcDrainIdle|gcDrainFractional|gcDrainNoBlock) == 0
  0x4160be		48f7c31b000000		TESTQ $0x1b, BX		
		if blocking {
  0x4160c5		0f8495010000		JE 0x416260		
	wbuf := w.wbuf1
  0x4160cb		4c8b01			MOVQ 0(CX), R8		
	if wbuf == nil {
  0x4160ce		4d85c0			TESTQ R8, R8		
  0x4160d1		0f8481010000		JE 0x416258		
	if wbuf.nobj == 0 {
  0x4160d7		4d8b4810		MOVQ 0x10(R8), R9	
  0x4160db		4d85c9			TESTQ R9, R9		
  0x4160de		0f8555010000		JNE 0x416239		
  0x4160e4		4531c0			XORL R8, R8		
			if b == 0 {
  0x4160e7		4d85c0			TESTQ R8, R8		
  0x4160ea		0f8418010000		JE 0x416208		
		if b == 0 {
  0x4160f0		4d85c0			TESTQ R8, R8		
  0x4160f3		0f8407010000		JE 0x416200		
		scanobject(b, gcw)
  0x4160f9		4c890424		MOVQ R8, 0(SP)			
  0x4160fd		48894c2408		MOVQ CX, 0x8(SP)		
  0x416102		e8c9050000		CALL runtime.scanobject(SB)	
  0x416107		488b442458		MOVQ 0x58(SP), AX		
		if gcw.scanWork >= gcCreditSlack {
  0x41610c		488b4818		MOVQ 0x18(AX), CX	
  0x416110		4881f9d0070000		CMPQ $0x7d0, CX		
  0x416117		0f8cc6000000		JL 0x4161e3		
			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
  0x41611d		488d1dfcda0a00		LEAQ runtime.gcController(SB), BX	
  0x416124		f0480fc10b		LOCK XADDQ CX, 0(BX)			
  0x416129		488b4c2460		MOVQ 0x60(SP), CX			
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x41612e		0fbae102		BTL $0x2, CX		
			if flushBgCredit {
  0x416132		0f8285000000		JB 0x4161bd		
  0x416138		488b542430		MOVQ 0x30(SP), DX	
			checkWork -= gcw.scanWork
  0x41613d		488b5818		MOVQ 0x18(AX), BX	
			gcw.scanWork = 0
  0x416141		48c7401800000000	MOVQ $0x0, 0x18(AX)	
  0x416149		488b742418		MOVQ 0x18(SP), SI	
			checkWork -= gcw.scanWork
  0x41614e		4829de			SUBQ BX, SI		
			if checkWork <= 0 {
  0x416151		4885f6			TESTQ SI, SI		
  0x416154		7f59			JG 0x4161af		
  0x416156		488b5c2440		MOVQ 0x40(SP), BX	
				if check != nil && check() {
  0x41615b		4885db			TESTQ BX, BX		
  0x41615e		7510			JNE 0x416170		
				checkWork += drainCheckThreshold
  0x416160		4881c6a0860100		ADDQ $0x186a0, SI	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x416167		0fbae100		BTL $0x0, CX		
	for !(preemptible && gp.preempt) {
  0x41616b		e90affffff		JMP 0x41607a		
  0x416170		4889742428		MOVQ SI, 0x28(SP)	
  0x416175		4889542420		MOVQ DX, 0x20(SP)	
				if check != nil && check() {
  0x41617a		488b03			MOVQ 0(BX), AX		
  0x41617d		4889da			MOVQ BX, DX		
  0x416180		ffd0			CALL AX			
  0x416182		0fb60424		MOVZX 0(SP), AX		
  0x416186		84c0			TESTL AL, AL		
  0x416188		751b			JNE 0x4161a5		
  0x41618a		488b442458		MOVQ 0x58(SP), AX	
  0x41618f		488b4c2460		MOVQ 0x60(SP), CX	
  0x416194		488b542420		MOVQ 0x20(SP), DX	
  0x416199		488b5c2440		MOVQ 0x40(SP), BX	
  0x41619e		488b742428		MOVQ 0x28(SP), SI	
  0x4161a3		ebbb			JMP 0x416160		
  0x4161a5		488b442420		MOVQ 0x20(SP), AX	
					break
  0x4161aa		e96cfeffff		JMP 0x41601b		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x4161af		0fbae100		BTL $0x0, CX		
  0x4161b3		488b5c2440		MOVQ 0x40(SP), BX	
			if checkWork <= 0 {
  0x4161b8		e9bdfeffff		JMP 0x41607a		
				gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x4161bd		488b4818		MOVQ 0x18(AX), CX			
  0x4161c1		488b542430		MOVQ 0x30(SP), DX			
  0x4161c6		4829d1			SUBQ DX, CX				
  0x4161c9		48890c24		MOVQ CX, 0(SP)				
  0x4161cd		e8feefffff		CALL runtime.gcFlushBgCredit(SB)	
  0x4161d2		488b442458		MOVQ 0x58(SP), AX			
  0x4161d7		488b4c2460		MOVQ 0x60(SP), CX			
  0x4161dc		31d2			XORL DX, DX				
				initScanWork = 0
  0x4161de		e95affffff		JMP 0x41613d		
  0x4161e3		488b4c2460		MOVQ 0x60(SP), CX	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x4161e8		0fbae100		BTL $0x0, CX		
  0x4161ec		488b5c2440		MOVQ 0x40(SP), BX	
  0x4161f1		488b742418		MOVQ 0x18(SP), SI	
  0x4161f6		488b542430		MOVQ 0x30(SP), DX	
		if gcw.scanWork >= gcCreditSlack {
  0x4161fb		e97afeffff		JMP 0x41607a		
  0x416200		4889d0			MOVQ DX, AX		
			break
  0x416203		e913feffff		JMP 0x41601b		
				b = gcw.tryGet()
  0x416208		48890c24		MOVQ CX, 0(SP)				
  0x41620c		e88f2e0000		CALL runtime.(*gcWork).tryGet(SB)	
  0x416211		4c8b442408		MOVQ 0x8(SP), R8			
  0x416216		488b442438		MOVQ 0x38(SP), AX			
  0x41621b		488b4c2458		MOVQ 0x58(SP), CX			
  0x416220		488b542430		MOVQ 0x30(SP), DX			
  0x416225		488b5c2460		MOVQ 0x60(SP), BX			
  0x41622a		488b742440		MOVQ 0x40(SP), SI			
  0x41622f		488b7c2418		MOVQ 0x18(SP), DI			
  0x416234		e9b7feffff		JMP 0x4160f0				
	wbuf.nobj--
  0x416239		4d8d51ff		LEAQ -0x1(R9), R10	
  0x41623d		4d895010		MOVQ R10, 0x10(R8)	
	return wbuf.obj[wbuf.nobj]
  0x416241		4981fafd000000		CMPQ $0xfd, R10		
  0x416248		0f83ba000000		JAE 0x416308		
  0x41624e		4f8b44c810		MOVQ 0x10(R8)(R9*8), R8	
			b = gcw.tryGetFast()
  0x416253		e98ffeffff		JMP 0x4160e7		
  0x416258		4531c0			XORL R8, R8		
  0x41625b		e987feffff		JMP 0x4160e7		
			b = gcw.get()
  0x416260		48890c24		MOVQ CX, 0(SP)			
  0x416264		e8272f0000		CALL runtime.(*gcWork).get(SB)	
  0x416269		4c8b442408		MOVQ 0x8(SP), R8		
  0x41626e		488b442438		MOVQ 0x38(SP), AX		
  0x416273		488b4c2458		MOVQ 0x58(SP), CX		
  0x416278		488b542430		MOVQ 0x30(SP), DX		
  0x41627d		488b5c2460		MOVQ 0x60(SP), BX		
  0x416282		488b742440		MOVQ 0x40(SP), SI		
  0x416287		488b7c2418		MOVQ 0x18(SP), DI		
  0x41628c		e95ffeffff		JMP 0x4160f0			
			gcw.balance()
  0x416291		48890c24		MOVQ CX, 0(SP)				
  0x416295		e8c6300000		CALL runtime.(*gcWork).balance(SB)	
  0x41629a		488b5c2460		MOVQ 0x60(SP), BX			
	blocking := flags&(gcDrainUntilPreempt|gcDrainIdle|gcDrainFractional|gcDrainNoBlock) == 0
  0x41629f		48f7c31b000000		TESTQ $0x1b, BX		
  0x4162a6		488b442438		MOVQ 0x38(SP), AX	
  0x4162ab		488b4c2458		MOVQ 0x58(SP), CX	
  0x4162b0		488b542430		MOVQ 0x30(SP), DX	
  0x4162b5		488b742440		MOVQ 0x40(SP), SI	
  0x4162ba		488b7c2418		MOVQ 0x18(SP), DI	
			gcw.balance()
  0x4162bf		e901feffff		JMP 0x4160c5		
  0x4162c4		4889d0			MOVQ DX, AX		
	for !(preemptible && gp.preempt) {
  0x4162c7		e94ffdffff		JMP 0x41601b		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x4162cc		0fbae300		BTL $0x0, BX		
		for !(preemptible && gp.preempt) {
  0x4162d0		e998fdffff		JMP 0x41606d		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x4162d5		0fbae300		BTL $0x0, BX		
	if work.markrootNext < work.markrootJobs {
  0x4162d9		e98ffdffff		JMP 0x41606d		
		} else if flags&gcDrainFractional != 0 {
  0x4162de		0fbae304		BTL $0x4, BX		
  0x4162e2		730c			JAE 0x4162f0		
  0x4162e4		488d35bd7e0500		LEAQ 0x57ebd(IP), SI	
	if work.markrootNext < work.markrootJobs {
  0x4162eb		e950fcffff		JMP 0x415f40		
  0x4162f0		31f6			XORL SI, SI		
		} else if flags&gcDrainFractional != 0 {
  0x4162f2		e949fcffff		JMP 0x415f40			
  0x4162f7		48bfffffffffffffff7f	MOVQ $0x7fffffffffffffff, DI	
  0x416301		31f6			XORL SI, SI			
	if flags&(gcDrainIdle|gcDrainFractional) != 0 {
  0x416303		e93ffcffff		JMP 0x415f47		
	return wbuf.obj[wbuf.nobj]
  0x416308		e833970000		CALL runtime.panicindex(SB)	
  0x41630d		0f0b			UD2				
		throw("gcDrain phase incorrect")
  0x41630f		488d0564530500		LEAQ 0x55364(IP), AX	
  0x416316		48890424		MOVQ AX, 0(SP)		
  0x41631a		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x416323		e8a8ae0000		CALL runtime.throw(SB)	
  0x416328		0f0b			UD2			
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
  0x41632a		e841e20200		CALL runtime.morestack_noctxt(SB)	
  0x41632f		e99cfbffff		JMP runtime.gcDrain(SB)			

TEXT runtime.gcDrainN(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcDrainN(gcw *gcWork, scanWork int64) int64 {
  0x416340		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416349		483b6118		CMPQ 0x18(CX), SP	
  0x41634d		0f86e2010000		JBE 0x416535		
  0x416353		4883ec28		SUBQ $0x28, SP		
  0x416357		48896c2420		MOVQ BP, 0x20(SP)	
  0x41635c		488d6c2420		LEAQ 0x20(SP), BP	
	if !writeBarrier.needed {
  0x416361		0fb605acd60a00		MOVZX runtime.writeBarrier+4(SB), AX	
  0x416368		84c0			TESTL AL, AL				
  0x41636a		0f84aa010000		JE 0x41651a				
	gp := getg().m.curg
  0x416370		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x416379		488b4030		MOVQ 0x30(AX), AX	
  0x41637d		488b4c2430		MOVQ 0x30(SP), CX	
	workFlushed := -gcw.scanWork
  0x416382		488b5118		MOVQ 0x18(CX), DX	
  0x416386		48f7da			NEGQ DX			
	gp := getg().m.curg
  0x416389		488b80c0000000		MOVQ 0xc0(AX), AX	
  0x416390		4889442418		MOVQ AX, 0x18(SP)	
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x416395		eb0d			JMP 0x4163a4		
  0x416397		488b4c2430		MOVQ 0x30(SP), CX	
  0x41639c		4889c2			MOVQ AX, DX		
  0x41639f		488b442418		MOVQ 0x18(SP), AX	
  0x4163a4		0fb698c0000000		MOVZX 0xc0(AX), BX	
  0x4163ab		84db			TESTL BL, BL		
  0x4163ad		0f8590000000		JNE 0x416443		
  0x4163b3		488b5918		MOVQ 0x18(CX), BX	
  0x4163b7		4801d3			ADDQ DX, BX		
  0x4163ba		488b742438		MOVQ 0x38(SP), SI	
  0x4163bf		4839f3			CMPQ SI, BX		
  0x4163c2		7d7f			JGE 0x416443		
  0x4163c4		4889542410		MOVQ DX, 0x10(SP)	
		if work.full == 0 {
  0x4163c9		488b1dd0190900		MOVQ runtime.work(SB), BX	
  0x4163d0		4885db			TESTQ BX, BX			
  0x4163d3		0f8418010000		JE 0x4164f1			
	wbuf := w.wbuf1
  0x4163d9		488b19			MOVQ 0(CX), BX		
	if wbuf == nil {
  0x4163dc		4885db			TESTQ BX, BX		
  0x4163df		0f8405010000		JE 0x4164ea		
	if wbuf.nobj == 0 {
  0x4163e5		488b7b10		MOVQ 0x10(BX), DI	
  0x4163e9		4885ff			TESTQ DI, DI		
  0x4163ec		0f85dd000000		JNE 0x4164cf		
  0x4163f2		31db			XORL BX, BX		
		if b == 0 {
  0x4163f4		4885db			TESTQ BX, BX		
  0x4163f7		0f84ab000000		JE 0x4164a8		
		if b == 0 {
  0x4163fd		4885db			TESTQ BX, BX		
  0x416400		7557			JNE 0x416459		
			if work.markrootNext < work.markrootJobs {
  0x416402		8b1d201a0900		MOVL runtime.work+136(SB), BX	
  0x416408		8b3d1e1a0900		MOVL runtime.work+140(SB), DI	
  0x41640e		39fb			CMPL DI, BX			
  0x416410		7331			JAE 0x416443			
				job := atomic.Xadd(&work.markrootNext, +1) - 1
  0x416412		bb01000000		MOVL $0x1, BX			
  0x416417		488d3d0a1a0900		LEAQ runtime.work+136(SB), DI	
  0x41641e		f00fc11f		LOCK XADDL BX, 0(DI)		
				if job < work.markrootJobs {
  0x416422		8b3d041a0900		MOVL runtime.work+140(SB), DI	
  0x416428		39fb			CMPL DI, BX			
  0x41642a		7317			JAE 0x416443			
					markroot(gcw, job)
  0x41642c		48890c24		MOVQ CX, 0(SP)			
  0x416430		895c2408		MOVL BX, 0x8(SP)		
  0x416434		e8d7ddffff		CALL runtime.markroot(SB)	
  0x416439		488b442410		MOVQ 0x10(SP), AX		
					continue
  0x41643e		e954ffffff		JMP 0x416397		
	return workFlushed + gcw.scanWork
  0x416443		488b4118		MOVQ 0x18(CX), AX	
  0x416447		4801d0			ADDQ DX, AX		
  0x41644a		4889442440		MOVQ AX, 0x40(SP)	
  0x41644f		488b6c2420		MOVQ 0x20(SP), BP	
  0x416454		4883c428		ADDQ $0x28, SP		
  0x416458		c3			RET			
		scanobject(b, gcw)
  0x416459		48891c24		MOVQ BX, 0(SP)			
  0x41645d		48894c2408		MOVQ CX, 0x8(SP)		
  0x416462		e869020000		CALL runtime.scanobject(SB)	
  0x416467		488b442430		MOVQ 0x30(SP), AX		
		if gcw.scanWork >= gcCreditSlack {
  0x41646c		488b4818		MOVQ 0x18(AX), CX	
  0x416470		4881f9d0070000		CMPQ $0x7d0, CX		
  0x416477		7c28			JL 0x4164a1		
			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
  0x416479		488d15a0d70a00		LEAQ runtime.gcController(SB), DX	
  0x416480		f0480fc10a		LOCK XADDQ CX, 0(DX)			
			workFlushed += gcw.scanWork
  0x416485		488b4818		MOVQ 0x18(AX), CX	
			gcw.scanWork = 0
  0x416489		48c7401800000000	MOVQ $0x0, 0x18(AX)	
  0x416491		488b542410		MOVQ 0x10(SP), DX	
			workFlushed += gcw.scanWork
  0x416496		4801d1			ADDQ DX, CX		
			gcw.scanWork = 0
  0x416499		4889c8			MOVQ CX, AX		
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x41649c		e9f6feffff		JMP 0x416397		
  0x4164a1		488b4c2410		MOVQ 0x10(SP), CX	
		if gcw.scanWork >= gcCreditSlack {
  0x4164a6		ebf1			JMP 0x416499		
			b = gcw.tryGet()
  0x4164a8		48890c24		MOVQ CX, 0(SP)				
  0x4164ac		e8ef2b0000		CALL runtime.(*gcWork).tryGet(SB)	
  0x4164b1		488b5c2408		MOVQ 0x8(SP), BX			
  0x4164b6		488b442418		MOVQ 0x18(SP), AX			
  0x4164bb		488b4c2430		MOVQ 0x30(SP), CX			
  0x4164c0		488b542410		MOVQ 0x10(SP), DX			
  0x4164c5		488b742438		MOVQ 0x38(SP), SI			
  0x4164ca		e92effffff		JMP 0x4163fd				
	wbuf.nobj--
  0x4164cf		4c8d47ff		LEAQ -0x1(DI), R8	
  0x4164d3		4c894310		MOVQ R8, 0x10(BX)	
	return wbuf.obj[wbuf.nobj]
  0x4164d7		4981f8fd000000		CMPQ $0xfd, R8		
  0x4164de		7333			JAE 0x416513		
  0x4164e0		488b5cfb10		MOVQ 0x10(BX)(DI*8), BX	
		b := gcw.tryGetFast()
  0x4164e5		e90affffff		JMP 0x4163f4		
  0x4164ea		31db			XORL BX, BX		
  0x4164ec		e903ffffff		JMP 0x4163f4		
			gcw.balance()
  0x4164f1		48890c24		MOVQ CX, 0(SP)				
  0x4164f5		e8662e0000		CALL runtime.(*gcWork).balance(SB)	
  0x4164fa		488b442418		MOVQ 0x18(SP), AX			
  0x4164ff		488b4c2430		MOVQ 0x30(SP), CX			
  0x416504		488b542410		MOVQ 0x10(SP), DX			
  0x416509		488b742438		MOVQ 0x38(SP), SI			
  0x41650e		e9c6feffff		JMP 0x4163d9				
	return wbuf.obj[wbuf.nobj]
  0x416513		e828950000		CALL runtime.panicindex(SB)	
  0x416518		0f0b			UD2				
		throw("gcDrainN phase incorrect")
  0x41651a		488d059d530500		LEAQ 0x5539d(IP), AX	
  0x416521		48890424		MOVQ AX, 0(SP)		
  0x416525		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x41652e		e89dac0000		CALL runtime.throw(SB)	
  0x416533		0f0b			UD2			
func gcDrainN(gcw *gcWork, scanWork int64) int64 {
  0x416535		e8c6070200		CALL runtime.morestackc(SB)	
  0x41653a		e901feffff		JMP runtime.gcDrainN(SB)	

TEXT runtime.scanblock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork) {
  0x416540		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416549		483b6110		CMPQ 0x10(CX), SP	
  0x41654d		0f866e010000		JBE 0x4166c1		
  0x416553		4883ec70		SUBQ $0x70, SP		
  0x416557		48896c2468		MOVQ BP, 0x68(SP)	
  0x41655c		488d6c2468		LEAQ 0x68(SP), BP	
	arena_start := mheap_.arena_start
  0x416561		488b0560700900		MOVQ runtime.mheap_+4904(SB), AX	
  0x416568		4889442460		MOVQ AX, 0x60(SP)			
	arena_used := mheap_.arena_used
  0x41656d		488b0d5c700900		MOVQ runtime.mheap_+4912(SB), CX	
  0x416574		48894c2458		MOVQ CX, 0x58(SP)			
  0x416579		31d2			XORL DX, DX				
	for i := uintptr(0); i < n; {
  0x41657b		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x416583		4839da			CMPQ BX, DX		
  0x416586		0f832b010000		JAE 0x4166b7		
  0x41658c		4889d6			MOVQ DX, SI		
		bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))
  0x41658f		48c1ea06		SHRQ $0x6, DX		
  0x416593		488bbc2488000000	MOVQ 0x88(SP), DI	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x41659b		4c8d0417		LEAQ 0(DI)(DX*1), R8	
		bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))
  0x41659f		418400			TESTB AL, 0(R8)		
  0x4165a2		0fb61417		MOVZX 0(DI)(DX*1), DX	
		if bits == 0 {
  0x4165a6		85d2			TESTL DX, DX		
  0x4165a8		7506			JNE 0x4165b0		
			i += sys.PtrSize * 8
  0x4165aa		488d5640		LEAQ 0x40(SI), DX	
			continue
  0x4165ae		ebcb			JMP 0x41657b		
  0x4165b0		4531c0			XORL R8, R8		
		for j := 0; j < 8 && i < n; j++ {
  0x4165b3		eb09			JMP 0x4165be		
  0x4165b5		49ffc0			INCQ R8			
			bits >>= 1
  0x4165b8		d1ea			SHRL $0x1, DX		
			i += sys.PtrSize
  0x4165ba		4883c608		ADDQ $0x8, SI		
		for j := 0; j < 8 && i < n; j++ {
  0x4165be		4983f808		CMPQ $0x8, R8		
  0x4165c2		0f8de7000000		JGE 0x4166af		
  0x4165c8		4839de			CMPQ BX, SI		
  0x4165cb		0f83de000000		JAE 0x4166af		
			if bits&1 != 0 {
  0x4165d1		0fbae200		BTL $0x0, DX		
  0x4165d5		0f83ca000000		JAE 0x4166a5		
  0x4165db		4c8b4c2478		MOVQ 0x78(SP), R9	
				obj := *(*uintptr)(unsafe.Pointer(b + i))
  0x4165e0		4e8d140e		LEAQ 0(SI)(R9*1), R10	
  0x4165e4		4d8b12			MOVQ 0(R10), R10	
				if obj != 0 && arena_start <= obj && obj < arena_used {
  0x4165e7		4d85d2			TESTQ R10, R10		
  0x4165ea		74c9			JE 0x4165b5		
  0x4165ec		4c39d0			CMPQ R10, AX		
  0x4165ef		77c4			JA 0x4165b5		
  0x4165f1		4939ca			CMPQ CX, R10		
  0x4165f4		73bf			JAE 0x4165b5		
  0x4165f6		4c89442448		MOVQ R8, 0x48(SP)	
  0x4165fb		4889742450		MOVQ SI, 0x50(SP)	
  0x416600		89542444		MOVL DX, 0x44(SP)	
					if obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != 0 {
  0x416604		4c891424		MOVQ R10, 0(SP)				
  0x416608		4c894c2408		MOVQ R9, 0x8(SP)			
  0x41660d		4889742410		MOVQ SI, 0x10(SP)			
  0x416612		e8895cffff		CALL runtime.heapBitsForObject(SB)	
  0x416617		488b442418		MOVQ 0x18(SP), AX			
  0x41661c		488b4c2430		MOVQ 0x30(SP), CX			
  0x416621		488b542438		MOVQ 0x38(SP), DX			
  0x416626		8b5c2428		MOVL 0x28(SP), BX			
  0x41662a		488b742420		MOVQ 0x20(SP), SI			
  0x41662f		4885c0			TESTQ AX, AX				
  0x416632		7532			JNE 0x416666				
  0x416634		488b442460		MOVQ 0x60(SP), AX			
  0x416639		488b4c2458		MOVQ 0x58(SP), CX			
  0x41663e		8b542444		MOVL 0x44(SP), DX			
  0x416642		488b9c2480000000	MOVQ 0x80(SP), BX			
  0x41664a		488b742450		MOVQ 0x50(SP), SI			
  0x41664f		488bbc2488000000	MOVQ 0x88(SP), DI			
  0x416657		4c8b442448		MOVQ 0x48(SP), R8			
  0x41665c		4c8b4c2478		MOVQ 0x78(SP), R9			
			bits >>= 1
  0x416661		e94fffffff		JMP 0x4165b5		
						greyobject(obj, b, i, hbits, span, gcw, objIndex)
  0x416666		48890424		MOVQ AX, 0(SP)			
  0x41666a		488b442478		MOVQ 0x78(SP), AX		
  0x41666f		4889442408		MOVQ AX, 0x8(SP)		
  0x416674		488b7c2450		MOVQ 0x50(SP), DI		
  0x416679		48897c2410		MOVQ DI, 0x10(SP)		
  0x41667e		4889742418		MOVQ SI, 0x18(SP)		
  0x416683		895c2420		MOVL BX, 0x20(SP)		
  0x416687		48894c2428		MOVQ CX, 0x28(SP)		
  0x41668c		488b8c2490000000	MOVQ 0x90(SP), CX		
  0x416694		48894c2430		MOVQ CX, 0x30(SP)		
  0x416699		4889542438		MOVQ DX, 0x38(SP)		
  0x41669e		e89d040000		CALL runtime.greyobject(SB)	
  0x4166a3		eb8f			JMP 0x416634			
  0x4166a5		4c8b4c2478		MOVQ 0x78(SP), R9		
			if bits&1 != 0 {
  0x4166aa		e906ffffff		JMP 0x4165b5		
  0x4166af		4889f2			MOVQ SI, DX		
	for i := uintptr(0); i < n; {
  0x4166b2		e9c4feffff		JMP 0x41657b		
  0x4166b7		488b6c2468		MOVQ 0x68(SP), BP	
  0x4166bc		4883c470		ADDQ $0x70, SP		
  0x4166c0		c3			RET			
func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork) {
  0x4166c1		e8aade0200		CALL runtime.morestack_noctxt(SB)	
  0x4166c6		e975feffff		JMP runtime.scanblock(SB)		

TEXT runtime.scanobject(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func scanobject(b uintptr, gcw *gcWork) {
  0x4166d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4166d9		488d4424e0		LEAQ -0x20(SP), AX	
  0x4166de		483b4110		CMPQ 0x10(CX), AX	
  0x4166e2		0f866a030000		JBE 0x416a52		
  0x4166e8		4881eca0000000		SUBQ $0xa0, SP		
  0x4166ef		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x4166f7		488dac2498000000	LEAQ 0x98(SP), BP	
	arena_start := mheap_.arena_start
  0x4166ff		488b05c26e0900		MOVQ runtime.mheap_+4904(SB), AX	
	arena_used := mheap_.arena_used
  0x416706		488b15c36e0900		MOVQ runtime.mheap_+4912(SB), DX	
  0x41670d		488b9c24a8000000	MOVQ 0xa8(SP), BX			
  0x416715		4889de			MOVQ BX, SI				
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x416718		4829c3			SUBQ AX, BX		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x41671b		488b3d966e0900		MOVQ runtime.mheap_+4888(SB), DI	
  0x416722		4989d8			MOVQ BX, R8				
  0x416725		48c1eb05		SHRQ $0x5, BX				
  0x416729		4829df			SUBQ BX, DI				
  0x41672c		488d5fff		LEAQ -0x1(DI), BX			
	return mheap_.spans[(p-mheap_.arena_start)>>_PageShift]
  0x416730		488b3db96b0900		MOVQ runtime.mheap_+4176(SB), DI	
  0x416737		4c8b0daa6b0900		MOVQ runtime.mheap_+4168(SB), R9	
  0x41673e		4d89c2			MOVQ R8, R10				
  0x416741		49c1e80d		SHRQ $0xd, R8				
  0x416745		4939f8			CMPQ DI, R8				
  0x416748		0f83fd020000		JAE 0x416a4b				
  0x41674e		4b8b3cc1		MOVQ 0(R9)(R8*8), DI			
	n := s.elemsize
  0x416752		4c8b4768		MOVQ 0x68(DI), R8	
	if n == 0 {
  0x416756		4d85c0			TESTQ R8, R8		
  0x416759		0f84d1020000		JE 0x416a30		
  0x41675f		4889442468		MOVQ AX, 0x68(SP)	
  0x416764		4889542460		MOVQ DX, 0x60(SP)	
	if n > maxObletBytes {
  0x416769		4981f800000200		CMPQ $0x20000, R8	
  0x416770		0f86ab020000		JBE 0x416a21		
	return s.startAddr
  0x416776		4c8b4f18		MOVQ 0x18(DI), R9	
  0x41677a		4c8d5f18		LEAQ 0x18(DI), R11	
		if b == s.base() {
  0x41677e		4c39ce			CMPQ R9, SI		
  0x416781		0f85d9000000		JNE 0x416860		
			if s.spanclass.noscan() {
  0x416787		440fb64f62		MOVZX 0x62(DI), R9	
	return sc&1 != 0
  0x41678c		41f6c101		TESTL $0x1, R9		
			if s.spanclass.noscan() {
  0x416790		0f8568020000		JNE 0x4169fe		
  0x416796		4c89542470		MOVQ R10, 0x70(SP)	
  0x41679b		48899c2490000000	MOVQ BX, 0x90(SP)	
  0x4167a3		48897c2478		MOVQ DI, 0x78(SP)	
  0x4167a8		4c899c2488000000	MOVQ R11, 0x88(SP)	
			for oblet := b + maxObletBytes; oblet < s.base()+s.elemsize; oblet += maxObletBytes {
  0x4167b0		4c8d8600000200		LEAQ 0x20000(SI), R8	
  0x4167b7		eb07			JMP 0x4167c0		
  0x4167b9		4981c000000200		ADDQ $0x20000, R8	
  0x4167c0		4c8b4f68		MOVQ 0x68(DI), R9	
  0x4167c4		4d030b			ADDQ 0(R11), R9		
  0x4167c7		4d39c8			CMPQ R9, R8		
  0x4167ca		0f8390000000		JAE 0x416860		
  0x4167d0		4c8b8c24b0000000	MOVQ 0xb0(SP), R9	
	wbuf := w.wbuf1
  0x4167d8		4d8b21			MOVQ 0(R9), R12		
	if wbuf == nil {
  0x4167db		4d85e4			TESTQ R12, R12		
  0x4167de		747c			JE 0x41685c		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x4167e0		4d8b6c2410		MOVQ 0x10(R12), R13	
  0x4167e5		4981fdfd000000		CMPQ $0xfd, R13		
  0x4167ec		7557			JNE 0x416845		
  0x4167ee		31c9			XORL CX, CX		
				if !gcw.putFast(oblet) {
  0x4167f0		84c9			TESTL CL, CL		
  0x4167f2		75c5			JNE 0x4167b9		
  0x4167f4		4c89442448		MOVQ R8, 0x48(SP)	
					gcw.put(oblet)
  0x4167f9		4c890c24		MOVQ R9, 0(SP)			
  0x4167fd		4c89442408		MOVQ R8, 0x8(SP)		
  0x416802		e8a9250000		CALL runtime.(*gcWork).put(SB)	
  0x416807		488b442468		MOVQ 0x68(SP), AX		
  0x41680c		488b542460		MOVQ 0x60(SP), DX		
  0x416811		488b9c2490000000	MOVQ 0x90(SP), BX		
  0x416819		488bb424a8000000	MOVQ 0xa8(SP), SI		
  0x416821		488b7c2478		MOVQ 0x78(SP), DI		
  0x416826		4c8b442448		MOVQ 0x48(SP), R8		
  0x41682b		4c8b8c24b0000000	MOVQ 0xb0(SP), R9		
  0x416833		4c8b542470		MOVQ 0x70(SP), R10		
  0x416838		4c8b9c2488000000	MOVQ 0x88(SP), R11		
  0x416840		e974ffffff		JMP 0x4167b9			
	wbuf.obj[wbuf.nobj] = obj
  0x416845		0f83de010000		JAE 0x416a29			
  0x41684b		4f8944ec18		MOVQ R8, 0x18(R12)(R13*8)	
	wbuf.nobj++
  0x416850		49ff442410		INCQ 0x10(R12)		
  0x416855		b901000000		MOVL $0x1, CX		
				if !gcw.putFast(oblet) {
  0x41685a		eb94			JMP 0x4167f0		
  0x41685c		31c9			XORL CX, CX		
  0x41685e		eb90			JMP 0x4167f0		
		n = s.base() + s.elemsize - b
  0x416860		488b7f68		MOVQ 0x68(DI), DI	
  0x416864		49033b			ADDQ 0(R11), DI		
  0x416867		4829f7			SUBQ SI, DI		
		if n > maxObletBytes {
  0x41686a		4881ff00000200		CMPQ $0x20000, DI	
  0x416871		0f867f010000		JBE 0x4169f6		
  0x416877		b900000200		MOVL $0x20000, CX	
	for i = 0; i < n; i += sys.PtrSize {
  0x41687c		48894c2450		MOVQ CX, 0x50(SP)	
	off := (addr - mheap_.arena_start) / sys.PtrSize
  0x416881		49c1ea03		SHRQ $0x3, R10		
	return heapBits{(*uint8)(unsafe.Pointer(mheap_.bitmap - off/4 - 1)), uint32(off & 3)}
  0x416885		4983e203		ANDQ $0x3, R10		
  0x416889		31ff			XORL DI, DI		
	for i = 0; i < n; i += sys.PtrSize {
  0x41688b		eb0a			JMP 0x416897		
  0x41688d		4883c708		ADDQ $0x8, DI		
  0x416891		4c89d1			MOVQ R10, CX		
  0x416894		4589c2			MOVL R8, R10		
  0x416897		4839cf			CMPQ CX, DI		
  0x41689a		0f8351010000		JAE 0x4169f1		
		if i != 0 {
  0x4168a0		4885ff			TESTQ DI, DI		
  0x4168a3		0f8440010000		JE 0x4169e9		
	if h.shift < 3*heapBitsShift {
  0x4168a9		4183fa03		CMPL $0x3, R10		
  0x4168ad		0f832b010000		JAE 0x4169de		
		return heapBits{h.bitp, h.shift + heapBitsShift}
  0x4168b3		458d4201		LEAL 0x1(R10), R8	
	return uint32(*h.bitp) >> (h.shift & 31)
  0x4168b7		440fb60b		MOVZX 0(BX), R9		
  0x4168bb		4989ca			MOVQ CX, R10		
  0x4168be		4489c1			MOVL R8, CX		
  0x4168c1		41d3e9			SHRL CL, R9		
		if i != 1*sys.PtrSize && bits&bitScan == 0 {
  0x4168c4		4883ff08		CMPQ $0x8, DI		
  0x4168c8		740b			JE 0x4168d5		
  0x4168ca		410fbae104		BTL $0x4, R9		
  0x4168cf		0f83db000000		JAE 0x4169b0		
		if bits&bitPointer == 0 {
  0x4168d5		410fbae100		BTL $0x0, R9		
  0x4168da		73b1			JAE 0x41688d		
		obj := *(*uintptr)(unsafe.Pointer(b + i))
  0x4168dc		4c8d0c37		LEAQ 0(DI)(SI*1), R9	
  0x4168e0		4d8b09			MOVQ 0(R9), R9		
		if obj != 0 && arena_start <= obj && obj < arena_used && obj-b >= n {
  0x4168e3		4d85c9			TESTQ R9, R9		
  0x4168e6		74a5			JE 0x41688d		
  0x4168e8		4c39c8			CMPQ R9, AX		
  0x4168eb		77a0			JA 0x41688d		
  0x4168ed		4939d1			CMPQ DX, R9		
  0x4168f0		739b			JAE 0x41688d		
  0x4168f2		4d89cb			MOVQ R9, R11		
  0x4168f5		4929f1			SUBQ SI, R9		
  0x4168f8		4d39d1			CMPQ R10, R9		
  0x4168fb		7290			JB 0x41688d		
  0x4168fd		48897c2458		MOVQ DI, 0x58(SP)	
  0x416902		894c2444		MOVL CX, 0x44(SP)	
  0x416906		48899c2480000000	MOVQ BX, 0x80(SP)	
			if obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != 0 {
  0x41690e		4c891c24		MOVQ R11, 0(SP)				
  0x416912		4889742408		MOVQ SI, 0x8(SP)			
  0x416917		48897c2410		MOVQ DI, 0x10(SP)			
  0x41691c		e87f59ffff		CALL runtime.heapBitsForObject(SB)	
  0x416921		488b442418		MOVQ 0x18(SP), AX			
  0x416926		488b4c2430		MOVQ 0x30(SP), CX			
  0x41692b		488b542438		MOVQ 0x38(SP), DX			
  0x416930		8b5c2428		MOVL 0x28(SP), BX			
  0x416934		488b742420		MOVQ 0x20(SP), SI			
  0x416939		4885c0			TESTQ AX, AX				
  0x41693c		7530			JNE 0x41696e				
  0x41693e		488b442468		MOVQ 0x68(SP), AX			
  0x416943		8b4c2444		MOVL 0x44(SP), CX			
  0x416947		488b542460		MOVQ 0x60(SP), DX			
  0x41694c		488b9c2480000000	MOVQ 0x80(SP), BX			
  0x416954		488bb424a8000000	MOVQ 0xa8(SP), SI			
  0x41695c		488b7c2458		MOVQ 0x58(SP), DI			
  0x416961		4189c8			MOVL CX, R8				
  0x416964		4c8b542450		MOVQ 0x50(SP), R10			
	for i = 0; i < n; i += sys.PtrSize {
  0x416969		e91fffffff		JMP 0x41688d		
				greyobject(obj, b, i, hbits, span, gcw, objIndex)
  0x41696e		48890424		MOVQ AX, 0(SP)			
  0x416972		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x41697a		4889442408		MOVQ AX, 0x8(SP)		
  0x41697f		488b7c2458		MOVQ 0x58(SP), DI		
  0x416984		48897c2410		MOVQ DI, 0x10(SP)		
  0x416989		4889742418		MOVQ SI, 0x18(SP)		
  0x41698e		895c2420		MOVL BX, 0x20(SP)		
  0x416992		48894c2428		MOVQ CX, 0x28(SP)		
  0x416997		488b8c24b0000000	MOVQ 0xb0(SP), CX		
  0x41699f		48894c2430		MOVQ CX, 0x30(SP)		
  0x4169a4		4889542438		MOVQ DX, 0x38(SP)		
  0x4169a9		e892010000		CALL runtime.greyobject(SB)	
  0x4169ae		eb8e			JMP 0x41693e			
  0x4169b0		488b8424b0000000	MOVQ 0xb0(SP), AX		
	gcw.bytesMarked += uint64(n)
  0x4169b8		488b4810		MOVQ 0x10(AX), CX	
  0x4169bc		4c01d1			ADDQ R10, CX		
  0x4169bf		48894810		MOVQ CX, 0x10(AX)	
	gcw.scanWork += int64(i)
  0x4169c3		488b4818		MOVQ 0x18(AX), CX	
  0x4169c7		4801f9			ADDQ DI, CX		
  0x4169ca		48894818		MOVQ CX, 0x18(AX)	
}
  0x4169ce		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4169d6		4881c4a0000000		ADDQ $0xa0, SP		
  0x4169dd		c3			RET			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x4169de		48ffcb			DECQ BX			
  0x4169e1		4531c0			XORL R8, R8		
			hbits = hbits.next()
  0x4169e4		e9cefeffff		JMP 0x4168b7		
  0x4169e9		4589d0			MOVL R10, R8		
		if i != 0 {
  0x4169ec		e9c6feffff		JMP 0x4168b7		
  0x4169f1		4989ca			MOVQ CX, R10		
	for i = 0; i < n; i += sys.PtrSize {
  0x4169f4		ebba			JMP 0x4169b0		
  0x4169f6		4889f9			MOVQ DI, CX		
		if n > maxObletBytes {
  0x4169f9		e97efeffff		JMP 0x41687c		
  0x4169fe		488b8424b0000000	MOVQ 0xb0(SP), AX	
				gcw.bytesMarked += uint64(n)
  0x416a06		488b4810		MOVQ 0x10(AX), CX	
  0x416a0a		4c01c1			ADDQ R8, CX		
  0x416a0d		48894810		MOVQ CX, 0x10(AX)	
				return
  0x416a11		488bac2498000000	MOVQ 0x98(SP), BP	
  0x416a19		4881c4a0000000		ADDQ $0xa0, SP		
  0x416a20		c3			RET			
  0x416a21		4c89c1			MOVQ R8, CX		
	if n > maxObletBytes {
  0x416a24		e953feffff		JMP 0x41687c		
	wbuf.obj[wbuf.nobj] = obj
  0x416a29		e812900000		CALL runtime.panicindex(SB)	
  0x416a2e		0f0b			UD2				
		throw("scanobject n == 0")
  0x416a30		488d05bf420500		LEAQ 0x542bf(IP), AX	
  0x416a37		48890424		MOVQ AX, 0(SP)		
  0x416a3b		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x416a44		e887a70000		CALL runtime.throw(SB)	
  0x416a49		0f0b			UD2			
	return mheap_.spans[(p-mheap_.arena_start)>>_PageShift]
  0x416a4b		e8f08f0000		CALL runtime.panicindex(SB)	
  0x416a50		0f0b			UD2				
func scanobject(b uintptr, gcw *gcWork) {
  0x416a52		e819db0200		CALL runtime.morestack_noctxt(SB)	
  0x416a57		e974fcffff		JMP runtime.scanobject(SB)		

TEXT runtime.shade(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func shade(b uintptr) {
  0x416a60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416a69		483b6110		CMPQ 0x10(CX), SP	
  0x416a6d		0f86c1000000		JBE 0x416b34		
  0x416a73		4883ec50		SUBQ $0x50, SP		
  0x416a77		48896c2448		MOVQ BP, 0x48(SP)	
  0x416a7c		488d6c2448		LEAQ 0x48(SP), BP	
  0x416a81		488b442458		MOVQ 0x58(SP), AX	
	if obj, hbits, span, objIndex := heapBitsForObject(b, 0, 0); obj != 0 {
  0x416a86		48890424		MOVQ AX, 0(SP)				
  0x416a8a		0f57c0			XORPS X0, X0				
  0x416a8d		0f11442408		MOVUPS X0, 0x8(SP)			
  0x416a92		e80958ffff		CALL runtime.heapBitsForObject(SB)	
  0x416a97		488b442418		MOVQ 0x18(SP), AX			
  0x416a9c		488b4c2430		MOVQ 0x30(SP), CX			
  0x416aa1		488b542438		MOVQ 0x38(SP), DX			
  0x416aa6		488b5c2420		MOVQ 0x20(SP), BX			
  0x416aab		8b742428		MOVL 0x28(SP), SI			
  0x416aaf		4885c0			TESTQ AX, AX				
  0x416ab2		750a			JNE 0x416abe				
  0x416ab4		488b6c2448		MOVQ 0x48(SP), BP			
  0x416ab9		4883c450		ADDQ $0x50, SP				
  0x416abd		c3			RET					
		gcw := &getg().m.p.ptr().gcw
  0x416abe		64488b3c25f8ffffff	MOVQ FS:0xfffffff8, DI	
  0x416ac7		488b7f30		MOVQ 0x30(DI), DI	
  0x416acb		4c8b87d0000000		MOVQ 0xd0(DI), R8	
  0x416ad2		418400			TESTB AL, 0(R8)		
  0x416ad5		8407			TESTB AL, 0(DI)		
		greyobject(obj, 0, 0, hbits, span, gcw, objIndex)
  0x416ad7		48890424		MOVQ AX, 0(SP)		
  0x416adb		0f57c0			XORPS X0, X0		
  0x416ade		0f11442408		MOVUPS X0, 0x8(SP)	
  0x416ae3		48895c2418		MOVQ BX, 0x18(SP)	
  0x416ae8		89742420		MOVL SI, 0x20(SP)	
  0x416aec		48894c2428		MOVQ CX, 0x28(SP)	
		gcw := &getg().m.p.ptr().gcw
  0x416af1		498d8070120000		LEAQ 0x1270(R8), AX	
  0x416af8		4889442440		MOVQ AX, 0x40(SP)	
		greyobject(obj, 0, 0, hbits, span, gcw, objIndex)
  0x416afd		4889442430		MOVQ AX, 0x30(SP)		
  0x416b02		4889542438		MOVQ DX, 0x38(SP)		
  0x416b07		e834000000		CALL runtime.greyobject(SB)	
		if gcphase == _GCmarktermination || gcBlackenPromptly {
  0x416b0c		8b05cacd0a00		MOVL runtime.gcphase(SB), AX	
  0x416b12		83f802			CMPL $0x2, AX			
  0x416b15		7510			JNE 0x416b27			
  0x416b17		488b442440		MOVQ 0x40(SP), AX		
			gcw.dispose()
  0x416b1c		48890424		MOVQ AX, 0(SP)				
  0x416b20		e85b270000		CALL runtime.(*gcWork).dispose(SB)	
  0x416b25		eb8d			JMP 0x416ab4				
		if gcphase == _GCmarktermination || gcBlackenPromptly {
  0x416b27		0fb60579cd0a00		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x416b2e		84c0			TESTL AL, AL				
  0x416b30		75e5			JNE 0x416b17				
  0x416b32		eb80			JMP 0x416ab4				
func shade(b uintptr) {
  0x416b34		e837da0200		CALL runtime.morestack_noctxt(SB)	
  0x416b39		e922ffffff		JMP runtime.shade(SB)			

TEXT runtime.greyobject(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func greyobject(obj, base, off uintptr, hbits heapBits, span *mspan, gcw *gcWork, objIndex uintptr) {
  0x416b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416b49		483b6110		CMPQ 0x10(CX), SP	
  0x416b4d		0f86a4040000		JBE 0x416ff7		
  0x416b53		4883ec28		SUBQ $0x28, SP		
  0x416b57		48896c2420		MOVQ BP, 0x20(SP)	
  0x416b5c		488d6c2420		LEAQ 0x20(SP), BP	
  0x416b61		488b442430		MOVQ 0x30(SP), AX	
	if obj&(sys.PtrSize-1) != 0 {
  0x416b66		48a907000000		TESTQ $0x7, AX		
  0x416b6c		0f856a040000		JNE 0x416fdc		
	if useCheckmark {
  0x416b72		0fb61546cd0a00		MOVZX runtime.useCheckmark(SB), DX	
  0x416b79		488b5c2458		MOVQ 0x58(SP), BX			
	bytep, mask := s.gcmarkBits.bitp(objIndex)
  0x416b7e		488b7350		MOVQ 0x50(BX), SI	
  0x416b82		488b4c2468		MOVQ 0x68(SP), CX	
  0x416b87		4889cf			MOVQ CX, DI		
	return b.bytep(n / 8), 1 << (n % 8)
  0x416b8a		48c1e903		SHRQ $0x3, CX		
  0x416b8e		4989f8			MOVQ DI, R8		
  0x416b91		4883e707		ANDQ $0x7, DI		
  0x416b95		4989c9			MOVQ CX, R9		
  0x416b98		4889f9			MOVQ DI, CX		
  0x416b9b		41ba01000000		MOVL $0x1, R10		
  0x416ba1		41d3e2			SHLL CL, R10		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x416ba4		498d3c31		LEAQ 0(R9)(SI*1), DI	
	if useCheckmark {
  0x416ba8		84d2			TESTL DL, DL		
  0x416baa		0f844b010000		JE 0x416cfb		
	return *m.bytep&m.mask != 0
  0x416bb0		8407			TESTB AL, 0(DI)		
  0x416bb2		410fb61431		MOVZX 0(R9)(SI*1), DX	
  0x416bb7		4484d2			TESTL R10, DL		
		if !mbits.isMarked() {
  0x416bba		0f84e8020000		JE 0x416ea8		
		if hbits.isCheckmarked(span.elemsize) {
  0x416bc0		488b5368		MOVQ 0x68(BX), DX	
	if size == sys.PtrSize {
  0x416bc4		4883fa08		CMPQ $0x8, DX		
  0x416bc8		0f85ff000000		JNE 0x416ccd		
  0x416bce		488b742448		MOVQ 0x48(SP), SI	
		return (*h.bitp>>h.shift)&bitPointer != 0
  0x416bd3		0fb63e			MOVZX 0(SI), DI		
  0x416bd6		8b4c2450		MOVL 0x50(SP), CX	
  0x416bda		40d2ef			SHRL CL, DI		
  0x416bdd		83f908			CMPL $0x8, CX		
  0x416be0		4519c0			SBBL R8, R8		
  0x416be3		4421c7			ANDL R8, DI		
  0x416be6		40f6c701		TESTL $0x1, DI		
  0x416bea		400f95c7		SETNE DI		
		if hbits.isCheckmarked(span.elemsize) {
  0x416bee		4084ff			TESTL DI, DI		
  0x416bf1		0f85cc000000		JNE 0x416cc3		
	if size == sys.PtrSize {
  0x416bf7		4883fa08		CMPQ $0x8, DX		
	if size == sys.PtrSize {
  0x416bfb		0f859f000000		JNE 0x416ca0		
		atomic.Or8(h.bitp, bitPointer<<h.shift)
  0x416c01		ba01000000		MOVL $0x1, DX		
  0x416c06		d3e2			SHLL CL, DX		
  0x416c08		83f920			CMPL $0x20, CX		
  0x416c0b		19ff			SBBL DI, DI		
  0x416c0d		21fa			ANDL DI, DX		
  0x416c0f		f00816			LOCK ORB DL, 0(SI)	
		if !hbits.isCheckmarked(span.elemsize) {
  0x416c12		488b5368		MOVQ 0x68(BX), DX	
	if size == sys.PtrSize {
  0x416c16		4883fa08		CMPQ $0x8, DX		
  0x416c1a		756e			JNE 0x416c8a		
		return (*h.bitp>>h.shift)&bitPointer != 0
  0x416c1c		0fb616			MOVZX 0(SI), DX		
  0x416c1f		d2ea			SHRL CL, DL		
  0x416c21		83f908			CMPL $0x8, CX		
  0x416c24		19db			SBBL BX, BX		
  0x416c26		21da			ANDL BX, DX		
  0x416c28		f6c201			TESTL $0x1, DL		
  0x416c2b		0f95c2			SETNE DL		
		if !hbits.isCheckmarked(span.elemsize) {
  0x416c2e		84d2			TESTL DL, DL		
  0x416c30		0f8457020000		JE 0x416e8d		
  0x416c36		488b4c2460		MOVQ 0x60(SP), CX	
	wbuf := w.wbuf1
  0x416c3b		488b11			MOVQ 0(CX), DX		
	if wbuf == nil {
  0x416c3e		4885d2			TESTQ DX, DX		
  0x416c41		7443			JE 0x416c86		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x416c43		488b5a10		MOVQ 0x10(DX), BX	
  0x416c47		4881fbfd000000		CMPQ $0xfd, BX		
  0x416c4e		7520			JNE 0x416c70		
  0x416c50		31d2			XORL DX, DX		
	if !gcw.putFast(obj) {
  0x416c52		84d2			TESTL DL, DL		
  0x416c54		740a			JE 0x416c60		
  0x416c56		488b6c2420		MOVQ 0x20(SP), BP	
  0x416c5b		4883c428		ADDQ $0x28, SP		
  0x416c5f		c3			RET			
		gcw.put(obj)
  0x416c60		48890c24		MOVQ CX, 0(SP)			
  0x416c64		4889442408		MOVQ AX, 0x8(SP)		
  0x416c69		e842210000		CALL runtime.(*gcWork).put(SB)	
  0x416c6e		ebe6			JMP 0x416c56			
	wbuf.obj[wbuf.nobj] = obj
  0x416c70		0f83f0000000		JAE 0x416d66		
  0x416c76		488944da18		MOVQ AX, 0x18(DX)(BX*8)	
	wbuf.nobj++
  0x416c7b		48ff4210		INCQ 0x10(DX)		
  0x416c7f		ba01000000		MOVL $0x1, DX		
	if !gcw.putFast(obj) {
  0x416c84		ebcc			JMP 0x416c52		
  0x416c86		31d2			XORL DX, DX		
  0x416c88		ebc8			JMP 0x416c52		
	return (*h.bitp>>(heapBitsShift+h.shift))&bitScan != 0
  0x416c8a		0fb61e			MOVZX 0(SI), BX		
  0x416c8d		ffc1			INCL CX			
  0x416c8f		d2eb			SHRL CL, BL		
  0x416c91		83f908			CMPL $0x8, CX		
  0x416c94		19f6			SBBL SI, SI		
  0x416c96		21f3			ANDL SI, BX		
  0x416c98		f6c310			TESTL $0x10, BL		
  0x416c9b		0f95c2			SETNE DL		
		if !hbits.isCheckmarked(span.elemsize) {
  0x416c9e		eb8e			JMP 0x416c2e		
	atomic.Or8(h.bitp, bitScan<<(heapBitsShift+h.shift))
  0x416ca0		8d5101			LEAL 0x1(CX), DX	
  0x416ca3		89cf			MOVL CX, DI		
  0x416ca5		89d1			MOVL DX, CX		
  0x416ca7		41b810000000		MOVL $0x10, R8		
  0x416cad		41d3e0			SHLL CL, R8		
  0x416cb0		83f920			CMPL $0x20, CX		
  0x416cb3		19d2			SBBL DX, DX		
  0x416cb5		4121d0			ANDL DX, R8		
  0x416cb8		f0440806		LOCK ORB R8, 0(SI)	
  0x416cbc		89f9			MOVL DI, CX		
		hbits.setCheckmarked(span.elemsize)
  0x416cbe		e94fffffff		JMP 0x416c12		
			return
  0x416cc3		488b6c2420		MOVQ 0x20(SP), BP	
  0x416cc8		4883c428		ADDQ $0x28, SP		
  0x416ccc		c3			RET			
  0x416ccd		488b742448		MOVQ 0x48(SP), SI	
	return (*h.bitp>>(heapBitsShift+h.shift))&bitScan != 0
  0x416cd2		440fb606		MOVZX 0(SI), R8		
  0x416cd6		448b4c2450		MOVL 0x50(SP), R9	
  0x416cdb		418d4901		LEAL 0x1(R9), CX	
  0x416cdf		41d2e8			SHRL CL, R8		
  0x416ce2		83f908			CMPL $0x8, CX		
  0x416ce5		4519d2			SBBL R10, R10		
  0x416ce8		4521d0			ANDL R10, R8		
  0x416ceb		41f6c010		TESTL $0x10, R8		
  0x416cef		400f95c7		SETNE DI		
  0x416cf3		4489c9			MOVL R9, CX		
		if hbits.isCheckmarked(span.elemsize) {
  0x416cf6		e9f3feffff		JMP 0x416bee		
		if debug.gccheckmark > 0 && span.isFree(objIndex) {
  0x416cfb		8b0dcbcd0a00		MOVL runtime.debug+12(SB), CX	
  0x416d01		85c9			TESTL CX, CX			
  0x416d03		7e09			JLE 0x416d0e			
	if index < s.freeindex {
  0x416d05		488b4b30		MOVQ 0x30(BX), CX	
  0x416d09		4939c8			CMPQ CX, R8		
  0x416d0c		7342			JAE 0x416d50		
	return *m.bytep&m.mask != 0
  0x416d0e		8407			TESTB AL, 0(DI)		
  0x416d10		410fb60c31		MOVZX 0(R9)(SI*1), CX	
  0x416d15		4484d1			TESTL R10, CL		
		if mbits.isMarked() {
  0x416d18		752c			JNE 0x416d46		
		atomic.Or8(mbits.bytep, mbits.mask)
  0x416d1a		f0440817		LOCK ORB R10, 0(DI)	
		if span.spanclass.noscan() {
  0x416d1e		0fb64b62		MOVZX 0x62(BX), CX	
	return sc&1 != 0
  0x416d22		f6c101			TESTL $0x1, CL		
		if span.spanclass.noscan() {
  0x416d25		0f840bffffff		JE 0x416c36		
  0x416d2b		488b442460		MOVQ 0x60(SP), AX	
			gcw.bytesMarked += uint64(span.elemsize)
  0x416d30		488b4810		MOVQ 0x10(AX), CX	
  0x416d34		48034b68		ADDQ 0x68(BX), CX	
  0x416d38		48894810		MOVQ CX, 0x10(AX)	
			return
  0x416d3c		488b6c2420		MOVQ 0x20(SP), BP	
  0x416d41		4883c428		ADDQ $0x28, SP		
  0x416d45		c3			RET			
			return
  0x416d46		488b6c2420		MOVQ 0x20(SP), BP	
  0x416d4b		4883c428		ADDQ $0x28, SP		
  0x416d4f		c3			RET			
	bytep, mask := s.allocBits.bitp(index)
  0x416d50		488b4b48		MOVQ 0x48(BX), CX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x416d54		498d1409		LEAQ 0(R9)(CX*1), DX	
	return *bytep&mask == 0
  0x416d58		8402			TESTB AL, 0(DX)		
  0x416d5a		410fb60c09		MOVZX 0(R9)(CX*1), CX	
  0x416d5f		4484d1			TESTL R10, CL		
		if debug.gccheckmark > 0 && span.isFree(objIndex) {
  0x416d62		7409			JE 0x416d6d		
  0x416d64		eba8			JMP 0x416d0e		
	wbuf.obj[wbuf.nobj] = obj
  0x416d66		e8d58c0000		CALL runtime.panicindex(SB)	
  0x416d6b		0f0b			UD2				
			print("runtime: marking free object ", hex(obj), " found at *(", hex(base), "+", hex(off), ")\n")
  0x416d6d		e88ead0000		CALL runtime.printlock(SB)	
  0x416d72		488d0558550500		LEAQ 0x55558(IP), AX		
  0x416d79		48890424		MOVQ AX, 0(SP)			
  0x416d7d		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x416d86		e8b5b60000		CALL runtime.printstring(SB)	
  0x416d8b		488b442430		MOVQ 0x30(SP), AX		
  0x416d90		48890424		MOVQ AX, 0(SP)			
  0x416d94		e857b50000		CALL runtime.printhex(SB)	
  0x416d99		488d055a370500		LEAQ 0x5375a(IP), AX		
  0x416da0		48890424		MOVQ AX, 0(SP)			
  0x416da4		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x416dad		e88eb60000		CALL runtime.printstring(SB)	
  0x416db2		488b442438		MOVQ 0x38(SP), AX		
  0x416db7		48890424		MOVQ AX, 0(SP)			
  0x416dbb		e830b50000		CALL runtime.printhex(SB)	
  0x416dc0		488d058c2e0500		LEAQ 0x52e8c(IP), AX		
  0x416dc7		48890424		MOVQ AX, 0(SP)			
  0x416dcb		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x416dd4		e867b60000		CALL runtime.printstring(SB)	
  0x416dd9		488b442440		MOVQ 0x40(SP), AX		
  0x416dde		48890424		MOVQ AX, 0(SP)			
  0x416de2		e809b50000		CALL runtime.printhex(SB)	
  0x416de7		488d057c2e0500		LEAQ 0x52e7c(IP), AX		
  0x416dee		48890424		MOVQ AX, 0(SP)			
  0x416df2		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x416dfb		e840b60000		CALL runtime.printstring(SB)	
  0x416e00		e87bad0000		CALL runtime.printunlock(SB)	
			gcDumpObject("base", base, off)
  0x416e05		488d05f62e0500		LEAQ 0x52ef6(IP), AX		
  0x416e0c		48890424		MOVQ AX, 0(SP)			
  0x416e10		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x416e19		488b442438		MOVQ 0x38(SP), AX		
  0x416e1e		4889442410		MOVQ AX, 0x10(SP)		
  0x416e23		488b442440		MOVQ 0x40(SP), AX		
  0x416e28		4889442418		MOVQ AX, 0x18(SP)		
  0x416e2d		e8de010000		CALL runtime.gcDumpObject(SB)	
			gcDumpObject("obj", obj, ^uintptr(0))
  0x416e32		488d057b2e0500		LEAQ 0x52e7b(IP), AX		
  0x416e39		48890424		MOVQ AX, 0(SP)			
  0x416e3d		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x416e46		488b442430		MOVQ 0x30(SP), AX		
  0x416e4b		4889442410		MOVQ AX, 0x10(SP)		
  0x416e50		48c7442418ffffffff	MOVQ $-0x1, 0x18(SP)		
  0x416e59		e8b2010000		CALL runtime.gcDumpObject(SB)	
			getg().m.traceback = 2
  0x416e5e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x416e67		488b4030		MOVQ 0x30(AX), AX	
  0x416e6b		c6802901000002		MOVB $0x2, 0x129(AX)	
			throw("marking free object")
  0x416e72		488d0533400500		LEAQ 0x54033(IP), AX	
  0x416e79		48890424		MOVQ AX, 0(SP)		
  0x416e7d		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x416e86		e845a30000		CALL runtime.throw(SB)	
  0x416e8b		0f0b			UD2			
			throw("setCheckmarked and isCheckmarked disagree")
  0x416e8d		488d0567650500		LEAQ 0x56567(IP), AX	
  0x416e94		48890424		MOVQ AX, 0(SP)		
  0x416e98		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x416ea1		e82aa30000		CALL runtime.throw(SB)	
  0x416ea6		0f0b			UD2			
			printlock()
  0x416ea8		e853ac0000		CALL runtime.printlock(SB)	
			print("runtime:greyobject: checkmarks finds unexpected unmarked object obj=", hex(obj), "\n")
  0x416ead		e84eac0000		CALL runtime.printlock(SB)	
  0x416eb2		488d05bd6f0500		LEAQ 0x56fbd(IP), AX		
  0x416eb9		48890424		MOVQ AX, 0(SP)			
  0x416ebd		48c744240844000000	MOVQ $0x44, 0x8(SP)		
  0x416ec6		e875b50000		CALL runtime.printstring(SB)	
  0x416ecb		488b442430		MOVQ 0x30(SP), AX		
  0x416ed0		48890424		MOVQ AX, 0(SP)			
  0x416ed4		e817b40000		CALL runtime.printhex(SB)	
  0x416ed9		e8b2ae0000		CALL runtime.printnl(SB)	
  0x416ede		e89dac0000		CALL runtime.printunlock(SB)	
			print("runtime: found obj at *(", hex(base), "+", hex(off), ")\n")
  0x416ee3		e818ac0000		CALL runtime.printlock(SB)	
  0x416ee8		488d052f4a0500		LEAQ 0x54a2f(IP), AX		
  0x416eef		48890424		MOVQ AX, 0(SP)			
  0x416ef3		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x416efc		e83fb50000		CALL runtime.printstring(SB)	
  0x416f01		488b442438		MOVQ 0x38(SP), AX		
  0x416f06		48890424		MOVQ AX, 0(SP)			
  0x416f0a		e8e1b30000		CALL runtime.printhex(SB)	
  0x416f0f		488d053d2d0500		LEAQ 0x52d3d(IP), AX		
  0x416f16		48890424		MOVQ AX, 0(SP)			
  0x416f1a		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x416f23		e818b50000		CALL runtime.printstring(SB)	
  0x416f28		488b442440		MOVQ 0x40(SP), AX		
  0x416f2d		48890424		MOVQ AX, 0(SP)			
  0x416f31		e8bab30000		CALL runtime.printhex(SB)	
  0x416f36		488d052d2d0500		LEAQ 0x52d2d(IP), AX		
  0x416f3d		48890424		MOVQ AX, 0(SP)			
  0x416f41		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x416f4a		e8f1b40000		CALL runtime.printstring(SB)	
  0x416f4f		e82cac0000		CALL runtime.printunlock(SB)	
			gcDumpObject("base", base, off)
  0x416f54		488d05a72d0500		LEAQ 0x52da7(IP), AX		
  0x416f5b		48890424		MOVQ AX, 0(SP)			
  0x416f5f		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x416f68		488b442438		MOVQ 0x38(SP), AX		
  0x416f6d		4889442410		MOVQ AX, 0x10(SP)		
  0x416f72		488b442440		MOVQ 0x40(SP), AX		
  0x416f77		4889442418		MOVQ AX, 0x18(SP)		
  0x416f7c		e88f000000		CALL runtime.gcDumpObject(SB)	
			gcDumpObject("obj", obj, ^uintptr(0))
  0x416f81		488d052c2d0500		LEAQ 0x52d2c(IP), AX		
  0x416f88		48890424		MOVQ AX, 0(SP)			
  0x416f8c		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x416f95		488b442430		MOVQ 0x30(SP), AX		
  0x416f9a		4889442410		MOVQ AX, 0x10(SP)		
  0x416f9f		48c7442418ffffffff	MOVQ $-0x1, 0x18(SP)		
  0x416fa8		e863000000		CALL runtime.gcDumpObject(SB)	
			getg().m.traceback = 2
  0x416fad		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x416fb6		488b4030		MOVQ 0x30(AX), AX	
  0x416fba		c6802901000002		MOVB $0x2, 0x129(AX)	
			throw("checkmark found unmarked object")
  0x416fc1		488d05a5560500		LEAQ 0x556a5(IP), AX	
  0x416fc8		48890424		MOVQ AX, 0(SP)		
  0x416fcc		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x416fd5		e8f6a10000		CALL runtime.throw(SB)	
  0x416fda		0f0b			UD2			
		throw("greyobject: obj not pointer-aligned")
  0x416fdc		488d054c5d0500		LEAQ 0x55d4c(IP), AX	
  0x416fe3		48890424		MOVQ AX, 0(SP)		
  0x416fe7		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x416ff0		e8dba10000		CALL runtime.throw(SB)	
  0x416ff5		0f0b			UD2			
func greyobject(obj, base, off uintptr, hbits heapBits, span *mspan, gcw *gcWork, objIndex uintptr) {
  0x416ff7		e874d50200		CALL runtime.morestack_noctxt(SB)	
  0x416ffc		e93ffbffff		JMP runtime.greyobject(SB)		

TEXT runtime.gcDumpObject(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcDumpObject(label string, obj, off uintptr) {
  0x417010		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417019		483b6110		CMPQ 0x10(CX), SP	
  0x41701d		0f860b050000		JBE 0x41752e		
  0x417023		4883ec68		SUBQ $0x68, SP		
  0x417027		48896c2460		MOVQ BP, 0x60(SP)	
  0x41702c		488d6c2460		LEAQ 0x60(SP), BP	
	if obj < mheap_.arena_start || obj >= mheap_.arena_used {
  0x417031		488b0590650900		MOVQ runtime.mheap_+4904(SB), AX	
  0x417038		488b8c2480000000	MOVQ 0x80(SP), CX			
  0x417040		4839c1			CMPQ AX, CX				
  0x417043		0f826f040000		JB 0x4174b8				
  0x417049		488b1580650900		MOVQ runtime.mheap_+4912(SB), DX	
  0x417050		4839d1			CMPQ DX, CX				
  0x417053		0f835f040000		JAE 0x4174b8				
	k := obj >> _PageShift
  0x417059		48c1e90d		SHRQ $0xd, CX		
	x -= mheap_.arena_start >> _PageShift
  0x41705d		48c1e80d		SHRQ $0xd, AX		
  0x417061		4889cb			MOVQ CX, BX		
  0x417064		4829c1			SUBQ AX, CX		
	s := mheap_.spans[x]
  0x417067		488b0582620900		MOVQ runtime.mheap_+4176(SB), AX	
  0x41706e		488b3573620900		MOVQ runtime.mheap_+4168(SB), SI	
  0x417075		4839c1			CMPQ AX, CX				
  0x417078		0f83a9040000		JAE 0x417527				
  0x41707e		48895c2448		MOVQ BX, 0x48(SP)			
  0x417083		488b04ce		MOVQ 0(SI)(CX*8), AX			
  0x417087		4889442450		MOVQ AX, 0x50(SP)			
	print(label, "=", hex(obj), " k=", hex(k))
  0x41708c		e86faa0000		CALL runtime.printlock(SB)	
  0x417091		488b442470		MOVQ 0x70(SP), AX		
  0x417096		48890424		MOVQ AX, 0(SP)			
  0x41709a		488b4c2478		MOVQ 0x78(SP), CX		
  0x41709f		48894c2408		MOVQ CX, 0x8(SP)		
  0x4170a4		e897b30000		CALL runtime.printstring(SB)	
  0x4170a9		488d05aa2b0500		LEAQ 0x52baa(IP), AX		
  0x4170b0		48890424		MOVQ AX, 0(SP)			
  0x4170b4		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4170bd		e87eb30000		CALL runtime.printstring(SB)	
  0x4170c2		488b842480000000	MOVQ 0x80(SP), AX		
  0x4170ca		48890424		MOVQ AX, 0(SP)			
  0x4170ce		e81db20000		CALL runtime.printhex(SB)	
  0x4170d3		488d05b92b0500		LEAQ 0x52bb9(IP), AX		
  0x4170da		48890424		MOVQ AX, 0(SP)			
  0x4170de		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4170e7		e854b30000		CALL runtime.printstring(SB)	
  0x4170ec		488b442448		MOVQ 0x48(SP), AX		
  0x4170f1		48890424		MOVQ AX, 0(SP)			
  0x4170f5		e8f6b10000		CALL runtime.printhex(SB)	
  0x4170fa		e881aa0000		CALL runtime.printunlock(SB)	
  0x4170ff		488b442450		MOVQ 0x50(SP), AX		
	if s == nil {
  0x417104		4885c0			TESTQ AX, AX		
  0x417107		0f847e030000		JE 0x41748b		
	print(" s.base()=", hex(s.base()), " s.limit=", hex(s.limit), " s.spanclass=", s.spanclass, " s.elemsize=", s.elemsize, " s.state=")
  0x41710d		0fb64862		MOVZX 0x62(AX), CX	
  0x417111		48894c2440		MOVQ CX, 0x40(SP)	
  0x417116		488b9080000000		MOVQ 0x80(AX), DX	
  0x41711d		4889542448		MOVQ DX, 0x48(SP)	
  0x417122		488b5868		MOVQ 0x68(AX), BX	
  0x417126		48895c2438		MOVQ BX, 0x38(SP)	
	return s.startAddr
  0x41712b		488b7018		MOVQ 0x18(AX), SI	
  0x41712f		4889742418		MOVQ SI, 0x18(SP)	
	print(" s.base()=", hex(s.base()), " s.limit=", hex(s.limit), " s.spanclass=", s.spanclass, " s.elemsize=", s.elemsize, " s.state=")
  0x417134		e8c7a90000		CALL runtime.printlock(SB)	
  0x417139		488d057c310500		LEAQ 0x5317c(IP), AX		
  0x417140		48890424		MOVQ AX, 0(SP)			
  0x417144		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41714d		e8eeb20000		CALL runtime.printstring(SB)	
  0x417152		488b442418		MOVQ 0x18(SP), AX		
  0x417157		48890424		MOVQ AX, 0(SP)			
  0x41715b		e890b10000		CALL runtime.printhex(SB)	
  0x417160		488d05322f0500		LEAQ 0x52f32(IP), AX		
  0x417167		48890424		MOVQ AX, 0(SP)			
  0x41716b		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x417174		e8c7b20000		CALL runtime.printstring(SB)	
  0x417179		488b442448		MOVQ 0x48(SP), AX		
  0x41717e		48890424		MOVQ AX, 0(SP)			
  0x417182		e869b10000		CALL runtime.printhex(SB)	
  0x417187		488d0524350500		LEAQ 0x53524(IP), AX		
  0x41718e		48890424		MOVQ AX, 0(SP)			
  0x417192		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x41719b		e8a0b20000		CALL runtime.printstring(SB)	
  0x4171a0		488b442440		MOVQ 0x40(SP), AX		
  0x4171a5		48890424		MOVQ AX, 0(SP)			
  0x4171a9		e8c2af0000		CALL runtime.printuint(SB)	
  0x4171ae		488d058d330500		LEAQ 0x5338d(IP), AX		
  0x4171b5		48890424		MOVQ AX, 0(SP)			
  0x4171b9		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x4171c2		e879b20000		CALL runtime.printstring(SB)	
  0x4171c7		488b442438		MOVQ 0x38(SP), AX		
  0x4171cc		48890424		MOVQ AX, 0(SP)			
  0x4171d0		e89baf0000		CALL runtime.printuint(SB)	
  0x4171d5		488d05c62e0500		LEAQ 0x52ec6(IP), AX		
  0x4171dc		48890424		MOVQ AX, 0(SP)			
  0x4171e0		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4171e9		e852b20000		CALL runtime.printstring(SB)	
  0x4171ee		e88da90000		CALL runtime.printunlock(SB)	
  0x4171f3		488b442450		MOVQ 0x50(SP), AX		
	if 0 <= s.state && int(s.state) < len(mSpanStateNames) {
  0x4171f8		0fb64864		MOVZX 0x64(AX), CX			
  0x4171fc		884c2417		MOVB CL, 0x17(SP)			
  0x417200		84c9			TESTL CL, CL				
  0x417202		721a			JB 0x41721e				
  0x417204		0fb6d1			MOVZX CL, DX				
  0x417207		488b1d7ae90800		MOVQ runtime.mSpanStateNames+8(SB), BX	
  0x41720e		488b356be90800		MOVQ runtime.mSpanStateNames(SB), SI	
  0x417215		4839da			CMPQ BX, DX				
  0x417218		0f8c2a020000		JL 0x417448				
		print("unknown(", s.state, ")\n")
  0x41721e		e8dda80000		CALL runtime.printlock(SB)	
  0x417223		488d050d2e0500		LEAQ 0x52e0d(IP), AX		
  0x41722a		48890424		MOVQ AX, 0(SP)			
  0x41722e		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x417237		e804b20000		CALL runtime.printstring(SB)	
  0x41723c		0fb6442417		MOVZX 0x17(SP), AX		
  0x417241		0fb6c0			MOVZX AL, AX			
  0x417244		48890424		MOVQ AX, 0(SP)			
  0x417248		e823af0000		CALL runtime.printuint(SB)	
  0x41724d		488d05162a0500		LEAQ 0x52a16(IP), AX		
  0x417254		48890424		MOVQ AX, 0(SP)			
  0x417258		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x417261		e8dab10000		CALL runtime.printstring(SB)	
  0x417266		e815a90000		CALL runtime.printunlock(SB)	
  0x41726b		488b442450		MOVQ 0x50(SP), AX		
	size := s.elemsize
  0x417270		488b4868		MOVQ 0x68(AX), CX	
	if s.state == _MSpanManual && size == 0 {
  0x417274		0fb64064		MOVZX 0x64(AX), AX	
  0x417278		3c02			CMPL $0x2, AL		
  0x41727a		0f85bb010000		JNE 0x41743b		
  0x417280		4885c9			TESTQ CX, CX		
  0x417283		0f85b2010000		JNE 0x41743b		
  0x417289		488b842488000000	MOVQ 0x88(SP), AX	
		size = off + sys.PtrSize
  0x417291		488d4808		LEAQ 0x8(AX), CX	
  0x417295		48894c2420		MOVQ CX, 0x20(SP)	
  0x41729a		31d2			XORL DX, DX		
  0x41729c		31db			XORL BX, BX		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x41729e		eb04			JMP 0x4172a4		
  0x4172a0		4883c208		ADDQ $0x8, DX		
  0x4172a4		4839ca			CMPQ CX, DX		
  0x4172a7		0f835b010000		JAE 0x417408		
		if !(i < 128*sys.PtrSize || off-16*sys.PtrSize < i && i < off+16*sys.PtrSize) {
  0x4172ad		4881fa00040000		CMPQ $0x400, DX		
  0x4172b4		721c			JB 0x4172d2		
  0x4172b6		488d7080		LEAQ -0x80(AX), SI	
  0x4172ba		4839d6			CMPQ DX, SI		
  0x4172bd		730c			JAE 0x4172cb		
  0x4172bf		488db080000000		LEAQ 0x80(AX), SI	
  0x4172c6		4839f2			CMPQ SI, DX		
  0x4172c9		7207			JB 0x4172d2		
  0x4172cb		bb01000000		MOVL $0x1, BX		
			continue
  0x4172d0		ebce			JMP 0x4172a0		
  0x4172d2		4889542428		MOVQ DX, 0x28(SP)	
		if skipped {
  0x4172d7		84db			TESTL BL, BL		
  0x4172d9		0f85fc000000		JNE 0x4173db		
  0x4172df		488b842480000000	MOVQ 0x80(SP), AX	
		print(" *(", label, "+", i, ") = ", hex(*(*uintptr)(unsafe.Pointer(obj + i))))
  0x4172e7		488d0c02		LEAQ 0(DX)(AX*1), CX		
  0x4172eb		488b09			MOVQ 0(CX), CX			
  0x4172ee		48894c2448		MOVQ CX, 0x48(SP)		
  0x4172f3		e808a80000		CALL runtime.printlock(SB)	
  0x4172f8		488d0588290500		LEAQ 0x52988(IP), AX		
  0x4172ff		48890424		MOVQ AX, 0(SP)			
  0x417303		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x41730c		e82fb10000		CALL runtime.printstring(SB)	
  0x417311		488b442470		MOVQ 0x70(SP), AX		
  0x417316		48890424		MOVQ AX, 0(SP)			
  0x41731a		488b4c2478		MOVQ 0x78(SP), CX		
  0x41731f		48894c2408		MOVQ CX, 0x8(SP)		
  0x417324		e817b10000		CALL runtime.printstring(SB)	
  0x417329		488d0523290500		LEAQ 0x52923(IP), AX		
  0x417330		48890424		MOVQ AX, 0(SP)			
  0x417334		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x41733d		e8feb00000		CALL runtime.printstring(SB)	
  0x417342		488b442428		MOVQ 0x28(SP), AX		
  0x417347		48890424		MOVQ AX, 0(SP)			
  0x41734b		e820ae0000		CALL runtime.printuint(SB)	
  0x417350		488d0587290500		LEAQ 0x52987(IP), AX		
  0x417357		48890424		MOVQ AX, 0(SP)			
  0x41735b		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x417364		e8d7b00000		CALL runtime.printstring(SB)	
  0x417369		488b442448		MOVQ 0x48(SP), AX		
  0x41736e		48890424		MOVQ AX, 0(SP)			
  0x417372		e879af0000		CALL runtime.printhex(SB)	
  0x417377		e804a80000		CALL runtime.printunlock(SB)	
  0x41737c		488b442428		MOVQ 0x28(SP), AX		
  0x417381		488b8c2488000000	MOVQ 0x88(SP), CX		
		if i == off {
  0x417389		4839c8			CMPQ CX, AX		
  0x41738c		7428			JE 0x4173b6		
		print("\n")
  0x41738e		e86da70000		CALL runtime.printlock(SB)	
  0x417393		e8f8a90000		CALL runtime.printnl(SB)	
  0x417398		e8e3a70000		CALL runtime.printunlock(SB)	
  0x41739d		488b842488000000	MOVQ 0x88(SP), AX		
  0x4173a5		488b4c2420		MOVQ 0x20(SP), CX		
  0x4173aa		488b542428		MOVQ 0x28(SP), DX		
  0x4173af		31db			XORL BX, BX			
  0x4173b1		e9eafeffff		JMP 0x4172a0			
			print(" <==")
  0x4173b6		e845a70000		CALL runtime.printlock(SB)	
  0x4173bb		488d05f8280500		LEAQ 0x528f8(IP), AX		
  0x4173c2		48890424		MOVQ AX, 0(SP)			
  0x4173c6		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4173cf		e86cb00000		CALL runtime.printstring(SB)	
  0x4173d4		e8a7a70000		CALL runtime.printunlock(SB)	
  0x4173d9		ebb3			JMP 0x41738e			
			print(" ...\n")
  0x4173db		e820a70000		CALL runtime.printlock(SB)	
  0x4173e0		488d054f290500		LEAQ 0x5294f(IP), AX		
  0x4173e7		48890424		MOVQ AX, 0(SP)			
  0x4173eb		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4173f4		e847b00000		CALL runtime.printstring(SB)	
  0x4173f9		e882a70000		CALL runtime.printunlock(SB)	
  0x4173fe		488b542428		MOVQ 0x28(SP), DX		
			skipped = false
  0x417403		e9d7feffff		JMP 0x4172df		
		if skipped {
  0x417408		84db			TESTL BL, BL		
	if skipped {
  0x41740a		750a			JNE 0x417416		
  0x41740c		488b6c2460		MOVQ 0x60(SP), BP	
  0x417411		4883c468		ADDQ $0x68, SP		
  0x417415		c3			RET			
		print(" ...\n")
  0x417416		e8e5a60000		CALL runtime.printlock(SB)	
  0x41741b		488d0514290500		LEAQ 0x52914(IP), AX		
  0x417422		48890424		MOVQ AX, 0(SP)			
  0x417426		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x41742f		e80cb00000		CALL runtime.printstring(SB)	
  0x417434		e847a70000		CALL runtime.printunlock(SB)	
  0x417439		ebd1			JMP 0x41740c			
  0x41743b		488b842488000000	MOVQ 0x88(SP), AX		
	if s.state == _MSpanManual && size == 0 {
  0x417443		e94dfeffff		JMP 0x417295		
		print(mSpanStateNames[s.state], "\n")
  0x417448		48c1e204		SHLQ $0x4, DX			
  0x41744c		488b441608		MOVQ 0x8(SI)(DX*1), AX		
  0x417451		4889442430		MOVQ AX, 0x30(SP)		
  0x417456		488b0c16		MOVQ 0(SI)(DX*1), CX		
  0x41745a		48894c2458		MOVQ CX, 0x58(SP)		
  0x41745f		e89ca60000		CALL runtime.printlock(SB)	
  0x417464		488b442458		MOVQ 0x58(SP), AX		
  0x417469		48890424		MOVQ AX, 0(SP)			
  0x41746d		488b442430		MOVQ 0x30(SP), AX		
  0x417472		4889442408		MOVQ AX, 0x8(SP)		
  0x417477		e8c4af0000		CALL runtime.printstring(SB)	
  0x41747c		e80fa90000		CALL runtime.printnl(SB)	
  0x417481		e8faa60000		CALL runtime.printunlock(SB)	
  0x417486		e9e0fdffff		JMP 0x41726b			
		print(" s=nil\n")
  0x41748b		e870a60000		CALL runtime.printlock(SB)	
  0x417490		488d05ed290500		LEAQ 0x529ed(IP), AX		
  0x417497		48890424		MOVQ AX, 0(SP)			
  0x41749b		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4174a4		e897af0000		CALL runtime.printstring(SB)	
  0x4174a9		e8d2a60000		CALL runtime.printunlock(SB)	
		return
  0x4174ae		488b6c2460		MOVQ 0x60(SP), BP	
  0x4174b3		4883c468		ADDQ $0x68, SP		
  0x4174b7		c3			RET			
		print(label, "=", hex(obj), " is not in the Go heap\n")
  0x4174b8		e843a60000		CALL runtime.printlock(SB)	
  0x4174bd		488b442470		MOVQ 0x70(SP), AX		
  0x4174c2		48890424		MOVQ AX, 0(SP)			
  0x4174c6		488b442478		MOVQ 0x78(SP), AX		
  0x4174cb		4889442408		MOVQ AX, 0x8(SP)		
  0x4174d0		e86baf0000		CALL runtime.printstring(SB)	
  0x4174d5		488d057e270500		LEAQ 0x5277e(IP), AX		
  0x4174dc		48890424		MOVQ AX, 0(SP)			
  0x4174e0		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4174e9		e852af0000		CALL runtime.printstring(SB)	
  0x4174ee		488b842480000000	MOVQ 0x80(SP), AX		
  0x4174f6		48890424		MOVQ AX, 0(SP)			
  0x4174fa		e8f1ad0000		CALL runtime.printhex(SB)	
  0x4174ff		488d058e400500		LEAQ 0x5408e(IP), AX		
  0x417506		48890424		MOVQ AX, 0(SP)			
  0x41750a		48c744240817000000	MOVQ $0x17, 0x8(SP)		
  0x417513		e828af0000		CALL runtime.printstring(SB)	
  0x417518		e863a60000		CALL runtime.printunlock(SB)	
		return
  0x41751d		488b6c2460		MOVQ 0x60(SP), BP	
  0x417522		4883c468		ADDQ $0x68, SP		
  0x417526		c3			RET			
	s := mheap_.spans[x]
  0x417527		e814850000		CALL runtime.panicindex(SB)	
  0x41752c		0f0b			UD2				
func gcDumpObject(label string, obj, off uintptr) {
  0x41752e		e83dd00200		CALL runtime.morestack_noctxt(SB)	
  0x417533		e9d8faffff		JMP runtime.gcDumpObject(SB)		

TEXT runtime.gcmarknewobject(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcmarknewobject(obj, size, scanSize uintptr) {
  0x417540		4883ec28		SUBQ $0x28, SP		
  0x417544		48896c2420		MOVQ BP, 0x20(SP)	
  0x417549		488d6c2420		LEAQ 0x20(SP), BP	
	if useCheckmark && !gcBlackenPromptly { // The world should be stopped so this should not happen.
  0x41754e		0fb6056ac30a00		MOVZX runtime.useCheckmark(SB), AX	
  0x417555		84c0			TESTL AL, AL				
  0x417557		740f			JE 0x417568				
  0x417559		0fb60547c30a00		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x417560		84c0			TESTL AL, AL				
  0x417562		0f8482000000		JE 0x4175ea				
  0x417568		488b442430		MOVQ 0x30(SP), AX			
	markBitsForAddr(obj).setMarked()
  0x41756d		48890424		MOVQ AX, 0(SP)				
  0x417571		e8da4affff		CALL runtime.markBitsForAddr(SB)	
  0x417576		0fb6442410		MOVZX 0x10(SP), AX			
  0x41757b		488b4c2408		MOVQ 0x8(SP), CX			
	atomic.Or8(m.bytep, m.mask)
  0x417580		f00801			LOCK ORB AL, 0(CX)	
	gcw := &getg().m.p.ptr().gcw
  0x417583		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41758c		488b4030		MOVQ 0x30(AX), AX	
  0x417590		488b88d0000000		MOVQ 0xd0(AX), CX	
  0x417597		8401			TESTB AL, 0(CX)		
  0x417599		8400			TESTB AL, 0(AX)		
  0x41759b		488d8170120000		LEAQ 0x1270(CX), AX	
	gcw.bytesMarked += uint64(size)
  0x4175a2		8400			TESTB AL, 0(AX)		
  0x4175a4		488b542438		MOVQ 0x38(SP), DX	
  0x4175a9		48039180120000		ADDQ 0x1280(CX), DX	
  0x4175b0		48899180120000		MOVQ DX, 0x1280(CX)	
  0x4175b7		488b542440		MOVQ 0x40(SP), DX	
	gcw.scanWork += int64(scanSize)
  0x4175bc		48039188120000		ADDQ 0x1288(CX), DX	
  0x4175c3		48899188120000		MOVQ DX, 0x1288(CX)	
	if gcBlackenPromptly {
  0x4175ca		0fb60dd6c20a00		MOVZX runtime.gcBlackenPromptly(SB), CX	
  0x4175d1		84c9			TESTL CL, CL				
  0x4175d3		750a			JNE 0x4175df				
  0x4175d5		488b6c2420		MOVQ 0x20(SP), BP			
  0x4175da		4883c428		ADDQ $0x28, SP				
  0x4175de		c3			RET					
		gcw.dispose()
  0x4175df		48890424		MOVQ AX, 0(SP)				
  0x4175e3		e8981c0000		CALL runtime.(*gcWork).dispose(SB)	
  0x4175e8		ebeb			JMP 0x4175d5				
		throw("gcmarknewobject called while doing checkmark")
  0x4175ea		488d0530600500		LEAQ 0x56030(IP), AX	
  0x4175f1		48890424		MOVQ AX, 0(SP)		
  0x4175f5		48c74424082c000000	MOVQ $0x2c, 0x8(SP)	
  0x4175fe		e8cd9b0000		CALL runtime.throw(SB)	
  0x417603		0f0b			UD2			

TEXT runtime.gcMarkTinyAllocs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func gcMarkTinyAllocs() {
  0x417610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417619		483b6110		CMPQ 0x10(CX), SP	
  0x41761d		0f86fa000000		JBE 0x41771d		
  0x417623		4883ec78		SUBQ $0x78, SP		
  0x417627		48896c2470		MOVQ BP, 0x70(SP)	
  0x41762c		488d6c2470		LEAQ 0x70(SP), BP	
	for _, p := range allp {
  0x417631		488b0580000900		MOVQ runtime.allp+8(SB), AX	
  0x417638		4889442448		MOVQ AX, 0x48(SP)		
  0x41763d		488b0d6c000900		MOVQ runtime.allp(SB), CX	
  0x417644		48894c2468		MOVQ CX, 0x68(SP)		
  0x417649		31d2			XORL DX, DX			
  0x41764b		eb03			JMP 0x417650			
  0x41764d		48ffc2			INCQ DX				
  0x417650		4839c2			CMPQ AX, DX			
  0x417653		0f8dba000000		JGE 0x417713			
  0x417659		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		c := p.mcache
  0x41765d		488b7348		MOVQ 0x48(BX), SI	
		if c == nil || c.tiny == 0 {
  0x417661		4885f6			TESTQ SI, SI		
  0x417664		74e7			JE 0x41764d		
  0x417666		488b7e10		MOVQ 0x10(SI), DI	
  0x41766a		4885ff			TESTQ DI, DI		
  0x41766d		74de			JE 0x41764d		
  0x41766f		4889542440		MOVQ DX, 0x40(SP)	
  0x417674		48895c2450		MOVQ BX, 0x50(SP)	
  0x417679		4889742460		MOVQ SI, 0x60(SP)	
		_, hbits, span, objIndex := heapBitsForObject(c.tiny, 0, 0)
  0x41767e		48893c24		MOVQ DI, 0(SP)				
  0x417682		0f57c0			XORPS X0, X0				
  0x417685		0f11442408		MOVUPS X0, 0x8(SP)			
  0x41768a		e8114cffff		CALL runtime.heapBitsForObject(SB)	
  0x41768f		8b442428		MOVL 0x28(SP), AX			
  0x417693		488b4c2430		MOVQ 0x30(SP), CX			
  0x417698		488b542438		MOVQ 0x38(SP), DX			
  0x41769d		488b5c2420		MOVQ 0x20(SP), BX			
  0x4176a2		488b742460		MOVQ 0x60(SP), SI			
		greyobject(c.tiny, 0, 0, hbits, span, gcw, objIndex)
  0x4176a7		488b7610		MOVQ 0x10(SI), SI	
  0x4176ab		48893424		MOVQ SI, 0(SP)		
  0x4176af		0f57c0			XORPS X0, X0		
  0x4176b2		0f11442408		MOVUPS X0, 0x8(SP)	
  0x4176b7		48895c2418		MOVQ BX, 0x18(SP)	
  0x4176bc		89442420		MOVL AX, 0x20(SP)	
  0x4176c0		48894c2428		MOVQ CX, 0x28(SP)	
  0x4176c5		488b442450		MOVQ 0x50(SP), AX	
		gcw := &p.gcw
  0x4176ca		480570120000		ADDQ $0x1270, AX	
  0x4176d0		4889442458		MOVQ AX, 0x58(SP)	
		greyobject(c.tiny, 0, 0, hbits, span, gcw, objIndex)
  0x4176d5		4889442430		MOVQ AX, 0x30(SP)		
  0x4176da		4889542438		MOVQ DX, 0x38(SP)		
  0x4176df		e85cf4ffff		CALL runtime.greyobject(SB)	
		if gcBlackenPromptly {
  0x4176e4		0fb605bcc10a00		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x4176eb		84c0			TESTL AL, AL				
  0x4176ed		7514			JNE 0x417703				
  0x4176ef		488b442448		MOVQ 0x48(SP), AX			
  0x4176f4		488b4c2468		MOVQ 0x68(SP), CX			
  0x4176f9		488b542440		MOVQ 0x40(SP), DX			
	for _, p := range allp {
  0x4176fe		e94affffff		JMP 0x41764d		
  0x417703		488b442458		MOVQ 0x58(SP), AX	
			gcw.dispose()
  0x417708		48890424		MOVQ AX, 0(SP)				
  0x41770c		e86f1b0000		CALL runtime.(*gcWork).dispose(SB)	
  0x417711		ebdc			JMP 0x4176ef				
  0x417713		488b6c2470		MOVQ 0x70(SP), BP			
  0x417718		4883c478		ADDQ $0x78, SP				
  0x41771c		c3			RET					
func gcMarkTinyAllocs() {
  0x41771d		e84ece0200		CALL runtime.morestack_noctxt(SB)	
  0x417722		e9e9feffff		JMP runtime.gcMarkTinyAllocs(SB)	

TEXT runtime.initCheckmarks(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func initCheckmarks() {
  0x417730		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417739		483b6110		CMPQ 0x10(CX), SP	
  0x41773d		0f86d1000000		JBE 0x417814		
  0x417743		4883ec50		SUBQ $0x50, SP		
  0x417747		48896c2448		MOVQ BP, 0x48(SP)	
  0x41774c		488d6c2448		LEAQ 0x48(SP), BP	
	useCheckmark = true
  0x417751		c60567c10a0001		MOVB $0x1, runtime.useCheckmark(SB)	
	for _, s := range mheap_.allspans {
  0x417758		488b05795b0900		MOVQ runtime.mheap_+4152(SB), AX	
  0x41775f		4889442430		MOVQ AX, 0x30(SP)			
  0x417764		488b0d655b0900		MOVQ runtime.mheap_+4144(SB), CX	
  0x41776b		48894c2440		MOVQ CX, 0x40(SP)			
  0x417770		31d2			XORL DX, DX				
  0x417772		eb03			JMP 0x417777				
  0x417774		48ffc2			INCQ DX					
  0x417777		4839c2			CMPQ AX, DX				
  0x41777a		0f8d8a000000		JGE 0x41780a				
  0x417780		488b1cd1		MOVQ 0(CX)(DX*8), BX			
		if s.state == _MSpanInUse {
  0x417784		0fb67364		MOVZX 0x64(BX), SI	
  0x417788		4080fe01		CMPL $0x1, SI		
  0x41778c		75e6			JNE 0x417774		
  0x41778e		4889542428		MOVQ DX, 0x28(SP)	
  0x417793		48895c2438		MOVQ BX, 0x38(SP)	
	return s.startAddr
  0x417798		488b4318		MOVQ 0x18(BX), AX	
			heapBitsForSpan(s.base()).initCheckmarkSpan(s.layout())
  0x41779c		48890424		MOVQ AX, 0(SP)				
  0x4177a0		e8bb49ffff		CALL runtime.heapBitsForSpan(SB)	
  0x4177a5		8b442410		MOVL 0x10(SP), AX			
  0x4177a9		488b4c2408		MOVQ 0x8(SP), CX			
  0x4177ae		488b542438		MOVQ 0x38(SP), DX			
	total = s.npages << _PageShift
  0x4177b3		488b5a20		MOVQ 0x20(DX), BX	
  0x4177b7		48c1e30d		SHLQ $0xd, BX		
	size = s.elemsize
  0x4177bb		488b5268		MOVQ 0x68(DX), DX	
	if size > 0 {
  0x4177bf		4885d2			TESTQ DX, DX		
  0x4177c2		763d			JBE 0x417801		
  0x4177c4		89c6			MOVL AX, SI		
  0x4177c6		4889d8			MOVQ BX, AX		
  0x4177c9		4889d7			MOVQ DX, DI		
		n = total / size
  0x4177cc		31d2			XORL DX, DX		
  0x4177ce		48f7f7			DIVQ DI			
			heapBitsForSpan(s.base()).initCheckmarkSpan(s.layout())
  0x4177d1		48890c24		MOVQ CX, 0(SP)					
  0x4177d5		89742408		MOVL SI, 0x8(SP)				
  0x4177d9		48897c2410		MOVQ DI, 0x10(SP)				
  0x4177de		4889442418		MOVQ AX, 0x18(SP)				
  0x4177e3		48895c2420		MOVQ BX, 0x20(SP)				
  0x4177e8		e88358ffff		CALL runtime.heapBits.initCheckmarkSpan(SB)	
  0x4177ed		488b442430		MOVQ 0x30(SP), AX				
  0x4177f2		488b4c2440		MOVQ 0x40(SP), CX				
  0x4177f7		488b542428		MOVQ 0x28(SP), DX				
  0x4177fc		e973ffffff		JMP 0x417774					
  0x417801		89c6			MOVL AX, SI					
  0x417803		4889d7			MOVQ DX, DI					
  0x417806		31c0			XORL AX, AX					
	if size > 0 {
  0x417808		ebc7			JMP 0x4177d1		
  0x41780a		488b6c2448		MOVQ 0x48(SP), BP	
  0x41780f		4883c450		ADDQ $0x50, SP		
  0x417813		c3			RET			
func initCheckmarks() {
  0x417814		e857cd0200		CALL runtime.morestack_noctxt(SB)	
  0x417819		e912ffffff		JMP runtime.initCheckmarks(SB)		

TEXT runtime.clearCheckmarks(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
func clearCheckmarks() {
  0x417820		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417829		483b6110		CMPQ 0x10(CX), SP	
  0x41782d		0f86d1000000		JBE 0x417904		
  0x417833		4883ec50		SUBQ $0x50, SP		
  0x417837		48896c2448		MOVQ BP, 0x48(SP)	
  0x41783c		488d6c2448		LEAQ 0x48(SP), BP	
	useCheckmark = false
  0x417841		c60577c00a0000		MOVB $0x0, runtime.useCheckmark(SB)	
	for _, s := range mheap_.allspans {
  0x417848		488b05895a0900		MOVQ runtime.mheap_+4152(SB), AX	
  0x41784f		4889442430		MOVQ AX, 0x30(SP)			
  0x417854		488b0d755a0900		MOVQ runtime.mheap_+4144(SB), CX	
  0x41785b		48894c2440		MOVQ CX, 0x40(SP)			
  0x417860		31d2			XORL DX, DX				
  0x417862		eb03			JMP 0x417867				
  0x417864		48ffc2			INCQ DX					
  0x417867		4839c2			CMPQ AX, DX				
  0x41786a		0f8d8a000000		JGE 0x4178fa				
  0x417870		488b1cd1		MOVQ 0(CX)(DX*8), BX			
		if s.state == _MSpanInUse {
  0x417874		0fb67364		MOVZX 0x64(BX), SI	
  0x417878		4080fe01		CMPL $0x1, SI		
  0x41787c		75e6			JNE 0x417864		
  0x41787e		4889542428		MOVQ DX, 0x28(SP)	
  0x417883		48895c2438		MOVQ BX, 0x38(SP)	
	return s.startAddr
  0x417888		488b4318		MOVQ 0x18(BX), AX	
			heapBitsForSpan(s.base()).clearCheckmarkSpan(s.layout())
  0x41788c		48890424		MOVQ AX, 0(SP)				
  0x417890		e8cb48ffff		CALL runtime.heapBitsForSpan(SB)	
  0x417895		8b442410		MOVL 0x10(SP), AX			
  0x417899		488b4c2408		MOVQ 0x8(SP), CX			
  0x41789e		488b542438		MOVQ 0x38(SP), DX			
	total = s.npages << _PageShift
  0x4178a3		488b5a20		MOVQ 0x20(DX), BX	
  0x4178a7		48c1e30d		SHLQ $0xd, BX		
	size = s.elemsize
  0x4178ab		488b5268		MOVQ 0x68(DX), DX	
	if size > 0 {
  0x4178af		4885d2			TESTQ DX, DX		
  0x4178b2		763d			JBE 0x4178f1		
  0x4178b4		89c6			MOVL AX, SI		
  0x4178b6		4889d8			MOVQ BX, AX		
  0x4178b9		4889d7			MOVQ DX, DI		
		n = total / size
  0x4178bc		31d2			XORL DX, DX		
  0x4178be		48f7f7			DIVQ DI			
			heapBitsForSpan(s.base()).clearCheckmarkSpan(s.layout())
  0x4178c1		48890c24		MOVQ CX, 0(SP)					
  0x4178c5		89742408		MOVL SI, 0x8(SP)				
  0x4178c9		48897c2410		MOVQ DI, 0x10(SP)				
  0x4178ce		4889442418		MOVQ AX, 0x18(SP)				
  0x4178d3		48895c2420		MOVQ BX, 0x20(SP)				
  0x4178d8		e83358ffff		CALL runtime.heapBits.clearCheckmarkSpan(SB)	
  0x4178dd		488b442430		MOVQ 0x30(SP), AX				
  0x4178e2		488b4c2440		MOVQ 0x40(SP), CX				
  0x4178e7		488b542428		MOVQ 0x28(SP), DX				
  0x4178ec		e973ffffff		JMP 0x417864					
  0x4178f1		89c6			MOVL AX, SI					
  0x4178f3		4889d7			MOVQ DX, DI					
  0x4178f6		31c0			XORL AX, AX					
	if size > 0 {
  0x4178f8		ebc7			JMP 0x4178c1		
  0x4178fa		488b6c2448		MOVQ 0x48(SP), BP	
  0x4178ff		4883c450		ADDQ $0x50, SP		
  0x417903		c3			RET			
func clearCheckmarks() {
  0x417904		e867cc0200		CALL runtime.morestack_noctxt(SB)	
  0x417909		e912ffffff		JMP runtime.clearCheckmarks(SB)		

TEXT runtime.finishsweep_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
func finishsweep_m() {
  0x417910		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417919		483b6110		CMPQ 0x10(CX), SP	
  0x41791d		7634			JBE 0x417953		
  0x41791f		4883ec10		SUBQ $0x10, SP		
  0x417923		48896c2408		MOVQ BP, 0x8(SP)	
  0x417928		488d6c2408		LEAQ 0x8(SP), BP	
	for sweepone() != ^uintptr(0) {
  0x41792d		eb06			JMP 0x417935		
		sweep.npausesweep++
  0x41792f		ff05c3fe0800		INCL runtime.sweep+24(SB)	
	for sweepone() != ^uintptr(0) {
  0x417935		e886010000		CALL runtime.sweepone(SB)	
  0x41793a		488b0424		MOVQ 0(SP), AX			
  0x41793e		4883f8ff		CMPQ $-0x1, AX			
  0x417942		75eb			JNE 0x41792f			
	nextMarkBitArenaEpoch()
  0x417944		e847530000		CALL runtime.nextMarkBitArenaEpoch(SB)	
}
  0x417949		488b6c2408		MOVQ 0x8(SP), BP	
  0x41794e		4883c410		ADDQ $0x10, SP		
  0x417952		c3			RET			
func finishsweep_m() {
  0x417953		e818cc0200		CALL runtime.morestack_noctxt(SB)	
  0x417958		ebb6			JMP runtime.finishsweep_m(SB)		

TEXT runtime.bgsweep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
func bgsweep(c chan int) {
  0x417960		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417969		483b6110		CMPQ 0x10(CX), SP	
  0x41796d		0f8641010000		JBE 0x417ab4		
  0x417973		4883ec30		SUBQ $0x30, SP		
  0x417977		48896c2428		MOVQ BP, 0x28(SP)	
  0x41797c		488d6c2428		LEAQ 0x28(SP), BP	
	sweep.g = getg()
  0x417981		8b0d89c00a00		MOVL runtime.writeBarrier(SB), CX	
  0x417987		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x417990		85c9			TESTL CX, CX				
  0x417992		0f850b010000		JNE 0x417aa3				
  0x417998		48890549fe0800		MOVQ AX, runtime.sweep+8(SB)		
	lock(&sweep.lock)
  0x41799f		488d053afe0800		LEAQ runtime.sweep(SB), AX	
  0x4179a6		48890424		MOVQ AX, 0(SP)			
  0x4179aa		e8711bffff		CALL runtime.lock(SB)		
	sweep.parked = true
  0x4179af		c6053afe080001		MOVB $0x1, runtime.sweep+16(SB)	
  0x4179b6		488b442438		MOVQ 0x38(SP), AX		
	c <- 1
  0x4179bb		48890424		MOVQ AX, 0(SP)				
  0x4179bf		488d0592d10500		LEAQ runtime.statictmp_18(SB), AX	
  0x4179c6		4889442408		MOVQ AX, 0x8(SP)			
  0x4179cb		e870b6feff		CALL runtime.chansend1(SB)		
	goparkunlock(&sweep.lock, "GC sweep wait", traceEvGoBlock, 1)
  0x4179d0		488d0509fe0800		LEAQ runtime.sweep(SB), AX	
  0x4179d7		48890424		MOVQ AX, 0(SP)			
  0x4179db		488d0d2b2d0500		LEAQ 0x52d2b(IP), CX		
  0x4179e2		48894c2408		MOVQ CX, 0x8(SP)		
  0x4179e7		48c74424100d000000	MOVQ $0xd, 0x10(SP)		
  0x4179f0		c644241814		MOVB $0x14, 0x18(SP)		
  0x4179f5		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x4179fe		e85db50000		CALL runtime.goparkunlock(SB)	
	for {
  0x417a03		eb0b			JMP 0x417a10		
			sweep.nbgsweep++
  0x417a05		ff05e9fd0800		INCL runtime.sweep+20(SB)	
			Gosched()
  0x417a0b		e8b0b30000		CALL runtime.Gosched(SB)	
		for gosweepone() != ^uintptr(0) {
  0x417a10		e85b040000		CALL runtime.gosweepone(SB)	
  0x417a15		488b0424		MOVQ 0(SP), AX			
  0x417a19		4883f8ff		CMPQ $-0x1, AX			
  0x417a1d		75e6			JNE 0x417a05			
  0x417a1f		eb05			JMP 0x417a26			
			Gosched()
  0x417a21		e89ab30000		CALL runtime.Gosched(SB)	
		for freeSomeWbufs(true) {
  0x417a26		c6042401		MOVB $0x1, 0(SP)		
  0x417a2a		e871220000		CALL runtime.freeSomeWbufs(SB)	
  0x417a2f		0fb6442408		MOVZX 0x8(SP), AX		
  0x417a34		84c0			TESTL AL, AL			
  0x417a36		75e9			JNE 0x417a21			
		lock(&sweep.lock)
  0x417a38		488d05a1fd0800		LEAQ runtime.sweep(SB), AX	
  0x417a3f		48890424		MOVQ AX, 0(SP)			
  0x417a43		e8d81affff		CALL runtime.lock(SB)		
	return mheap_.sweepdone != 0
  0x417a48		8b0576580900		MOVL runtime.mheap_+4132(SB), AX	
  0x417a4e		85c0			TESTL AX, AX				
		if !gosweepdone() {
  0x417a50		743c			JE 0x417a8e		
		sweep.parked = true
  0x417a52		c60597fd080001		MOVB $0x1, runtime.sweep+16(SB)	
		goparkunlock(&sweep.lock, "GC sweep wait", traceEvGoBlock, 1)
  0x417a59		488d0580fd0800		LEAQ runtime.sweep(SB), AX	
  0x417a60		48890424		MOVQ AX, 0(SP)			
  0x417a64		488d0da22c0500		LEAQ 0x52ca2(IP), CX		
  0x417a6b		48894c2408		MOVQ CX, 0x8(SP)		
  0x417a70		48c74424100d000000	MOVQ $0xd, 0x10(SP)		
  0x417a79		c644241814		MOVB $0x14, 0x18(SP)		
  0x417a7e		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x417a87		e8d4b40000		CALL runtime.goparkunlock(SB)	
  0x417a8c		eb82			JMP 0x417a10			
			unlock(&sweep.lock)
  0x417a8e		488d054bfd0800		LEAQ runtime.sweep(SB), AX	
  0x417a95		48890424		MOVQ AX, 0(SP)			
  0x417a99		e8221cffff		CALL runtime.unlock(SB)		
			continue
  0x417a9e		e96dffffff		JMP 0x417a10		
	sweep.g = getg()
  0x417aa3		488d3d3efd0800		LEAQ runtime.sweep+8(SB), DI	
  0x417aaa		e8f1ed0200		CALL runtime.gcWriteBarrier(SB)	
  0x417aaf		e9ebfeffff		JMP 0x41799f			
func bgsweep(c chan int) {
  0x417ab4		e8b7ca0200		CALL runtime.morestack_noctxt(SB)	
  0x417ab9		e9a2feffff		JMP runtime.bgsweep(SB)			

TEXT runtime.sweepone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
func sweepone() uintptr {
  0x417ac0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417ac9		483b6110		CMPQ 0x10(CX), SP	
  0x417acd		0f868b030000		JBE 0x417e5e		
  0x417ad3		4883ec60		SUBQ $0x60, SP		
  0x417ad7		48896c2458		MOVQ BP, 0x58(SP)	
  0x417adc		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x417ae1		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x417aea		488b5130		MOVQ 0x30(CX), DX	
	sweepRatio := mheap_.sweepPagesPerByte // For debugging
  0x417aee		f20f100582580900	MOVSD_XMM runtime.mheap_+4312(SB), X0	
	_g_.m.locks++
  0x417af6		ff8200010000		INCL 0x100(DX)		
	if atomic.Load(&mheap_.sweepdone) != 0 {
  0x417afc		8b15c2570900		MOVL runtime.mheap_+4132(SB), DX	
  0x417b02		85d2			TESTL DX, DX				
  0x417b04		0f8582020000		JNE 0x417d8c				
  0x417b0a		48894c2450		MOVQ CX, 0x50(SP)			
  0x417b0f		f20f11442428		MOVSD_XMM X0, 0x28(SP)			
	atomic.Xadd(&mheap_.sweepers, +1)
  0x417b15		ba01000000		MOVL $0x1, DX				
  0x417b1a		488d1da7570900		LEAQ runtime.mheap_+4136(SB), BX	
  0x417b21		f00fc113		LOCK XADDL DX, 0(BX)			
	sg := mheap_.sweepgen
  0x417b25		8b1595570900		MOVL runtime.mheap_+4128(SB), DX	
	for {
  0x417b2b		eb02			JMP 0x417b2f		
  0x417b2d		89f2			MOVL SI, DX		
		s := mheap_.sweepSpans[1-sg/2%2].pop()
  0x417b2f		89d6			MOVL DX, SI		
  0x417b31		d1ea			SHRL $0x1, DX		
  0x417b33		83e201			ANDL $0x1, DX		
  0x417b36		ffca			DECL DX			
  0x417b38		f7da			NEGL DX			
  0x417b3a		4883fa02		CMPQ $0x2, DX		
  0x417b3e		0f8313030000		JAE 0x417e57		
  0x417b44		488d1492		LEAQ 0(DX)(DX*4), DX	
	cursor := atomic.Xadd(&b.index, -1)
  0x417b48		488d3d51470900		LEAQ runtime.mheap_(SB), DI	
  0x417b4f		4c8d84d780100000	LEAQ 0x1080(DI)(DX*8), R8	
  0x417b57		41b9ffffffff		MOVL $-0x1, R9			
  0x417b5d		f0450fc108		LOCK XADDL R9, 0(R8)		
  0x417b62		41ffc9			DECL R9				
	if int32(cursor) < 0 {
  0x417b65		4585c9			TESTL R9, R9		
  0x417b68		0f8dea010000		JGE 0x417d58		
		atomic.Xadd(&b.index, +1)
  0x417b6e		ba01000000		MOVL $0x1, DX		
  0x417b73		f0410fc110		LOCK XADDL DX, 0(R8)	
  0x417b78		31c0			XORL AX, AX		
		if s == nil {
  0x417b7a		4885c0			TESTQ AX, AX		
  0x417b7d		0f84bb010000		JE 0x417d3e		
		if s.state != mSpanInUse {
  0x417b83		0fb65064		MOVZX 0x64(AX), DX	
  0x417b87		80fa01			CMPL $0x1, DL		
  0x417b8a		740f			JE 0x417b9b		
			if s.sweepgen != sg {
  0x417b8c		448b4058		MOVL 0x58(AX), R8	
  0x417b90		4139f0			CMPL SI, R8		
  0x417b93		0f8511020000		JNE 0x417daa		
  0x417b99		eb92			JMP 0x417b2d		
		if s.sweepgen != sg-2 || !atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x417b9b		8b5058			MOVL 0x58(AX), DX		
  0x417b9e		448d46fe		LEAL -0x2(SI), R8		
  0x417ba2		4439c2			CMPL R8, DX			
  0x417ba5		7586			JNE 0x417b2d			
  0x417ba7		8d56ff			LEAL -0x1(SI), DX		
  0x417baa		4989c1			MOVQ AX, R9			
  0x417bad		4489c0			MOVL R8, AX			
  0x417bb0		f0410fb15158		LOCK CMPXCHGL DX, 0x58(R9)	
  0x417bb6		0f94c2			SETE DL				
  0x417bb9		84d2			TESTL DL, DL			
  0x417bbb		0f846cffffff		JE 0x417b2d			
		npages = s.npages
  0x417bc1		498b4120		MOVQ 0x20(R9), AX	
  0x417bc5		4889442430		MOVQ AX, 0x30(SP)	
		if !s.sweep(false) {
  0x417bca		4c890c24		MOVQ R9, 0(SP)			
  0x417bce		c644240800		MOVB $0x0, 0x8(SP)		
  0x417bd3		e8e8030000		CALL runtime.(*mspan).sweep(SB)	
  0x417bd8		0fb6442410		MOVZX 0x10(SP), AX		
  0x417bdd		84c0			TESTL AL, AL			
  0x417bdf		0f8452010000		JE 0x417d37			
  0x417be5		488b442430		MOVQ 0x30(SP), AX		
	if atomic.Xadd(&mheap_.sweepers, -1) == 0 && atomic.Load(&mheap_.sweepdone) != 0 {
  0x417bea		b9ffffffff		MOVL $-0x1, CX				
  0x417bef		488d15d2560900		LEAQ runtime.mheap_+4136(SB), DX	
  0x417bf6		f00fc10a		LOCK XADDL CX, 0(DX)			
  0x417bfa		ffc9			DECL CX					
  0x417bfc		85c9			TESTL CX, CX				
  0x417bfe		7514			JNE 0x417c14				
  0x417c00		8b0dbe560900		MOVL runtime.mheap_+4132(SB), CX	
  0x417c06		85c9			TESTL CX, CX				
  0x417c08		740a			JE 0x417c14				
		if debug.gcpacertrace > 0 {
  0x417c0a		8b0dc0be0a00		MOVL runtime.debug+16(SB), CX	
  0x417c10		85c9			TESTL CX, CX			
  0x417c12		7f1f			JG 0x417c33			
  0x417c14		488b4c2450		MOVQ 0x50(SP), CX		
	_g_.m.locks--
  0x417c19		488b4930		MOVQ 0x30(CX), CX	
  0x417c1d		838100010000ff		ADDL $-0x1, 0x100(CX)	
	return npages
  0x417c24		4889442468		MOVQ AX, 0x68(SP)	
  0x417c29		488b6c2458		MOVQ 0x58(SP), BP	
  0x417c2e		4883c460		ADDQ $0x60, SP		
  0x417c32		c3			RET			
  0x417c33		4889442430		MOVQ AX, 0x30(SP)	
			print("pacer: sweep done at heap size ", memstats.heap_live>>20, "MB; allocated ", (memstats.heap_live-mheap_.sweepHeapLiveBasis)>>20, "MB during sweep; swept ", mheap_.pagesSwept, " pages at ", sweepRatio, " pages/byte\n")
  0x417c38		488b0501e20a00		MOVQ runtime.memstats+5952(SB), AX	
  0x417c3f		4889442448		MOVQ AX, 0x48(SP)			
  0x417c44		488b0d25570900		MOVQ runtime.mheap_+4304(SB), CX	
  0x417c4b		48894c2440		MOVQ CX, 0x40(SP)			
  0x417c50		488b1509570900		MOVQ runtime.mheap_+4288(SB), DX	
  0x417c57		4889542438		MOVQ DX, 0x38(SP)			
  0x417c5c		e89f9e0000		CALL runtime.printlock(SB)		
  0x417c61		488d05a04a0500		LEAQ 0x54aa0(IP), AX			
  0x417c68		48890424		MOVQ AX, 0(SP)				
  0x417c6c		48c74424081f000000	MOVQ $0x1f, 0x8(SP)			
  0x417c75		e8c6a70000		CALL runtime.printstring(SB)		
  0x417c7a		488b442448		MOVQ 0x48(SP), AX			
  0x417c7f		48c1e814		SHRQ $0x14, AX				
  0x417c83		48890424		MOVQ AX, 0(SP)				
  0x417c87		e8e4a40000		CALL runtime.printuint(SB)		
  0x417c8c		488d05ad2b0500		LEAQ 0x52bad(IP), AX			
  0x417c93		48890424		MOVQ AX, 0(SP)				
  0x417c97		48c74424080e000000	MOVQ $0xe, 0x8(SP)			
  0x417ca0		e89ba70000		CALL runtime.printstring(SB)		
  0x417ca5		488b442448		MOVQ 0x48(SP), AX			
  0x417caa		488b4c2440		MOVQ 0x40(SP), CX			
  0x417caf		4829c8			SUBQ CX, AX				
  0x417cb2		48c1e814		SHRQ $0x14, AX				
  0x417cb6		48890424		MOVQ AX, 0(SP)				
  0x417cba		e8b1a40000		CALL runtime.printuint(SB)		
  0x417cbf		488d05fc380500		LEAQ 0x538fc(IP), AX			
  0x417cc6		48890424		MOVQ AX, 0(SP)				
  0x417cca		48c744240817000000	MOVQ $0x17, 0x8(SP)			
  0x417cd3		e868a70000		CALL runtime.printstring(SB)		
  0x417cd8		488b442438		MOVQ 0x38(SP), AX			
  0x417cdd		48890424		MOVQ AX, 0(SP)				
  0x417ce1		e88aa40000		CALL runtime.printuint(SB)		
  0x417ce6		488d05a7250500		LEAQ 0x525a7(IP), AX			
  0x417ced		48890424		MOVQ AX, 0(SP)				
  0x417cf1		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x417cfa		e841a70000		CALL runtime.printstring(SB)		
  0x417cff		f20f10442428		MOVSD_XMM 0x28(SP), X0			
  0x417d05		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x417d0a		e841a10000		CALL runtime.printfloat(SB)		
  0x417d0f		488d0514280500		LEAQ 0x52814(IP), AX			
  0x417d16		48890424		MOVQ AX, 0(SP)				
  0x417d1a		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x417d23		e818a70000		CALL runtime.printstring(SB)		
  0x417d28		e8539e0000		CALL runtime.printunlock(SB)		
  0x417d2d		488b442430		MOVQ 0x30(SP), AX			
  0x417d32		e9ddfeffff		JMP 0x417c14				
  0x417d37		31c0			XORL AX, AX				
		break
  0x417d39		e9acfeffff		JMP 0x417bea		
			atomic.Store(&mheap_.sweepdone, 1)
  0x417d3e		ba01000000		MOVL $0x1, DX				
  0x417d43		488d357a550900		LEAQ runtime.mheap_+4132(SB), SI	
  0x417d4a		8716			XCHGL DX, 0(SI)				
  0x417d4c		48c7c0ffffffff		MOVQ $-0x1, AX				
			break
  0x417d53		e992feffff		JMP 0x417bea		
  0x417d58		4589c8			MOVL R9, R8		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x417d5b		41c1e909		SHRL $0x9, R9		
	blockp := (**gcSweepBlock)(add(b.spine, sys.PtrSize*uintptr(top)))
  0x417d5f		488b94d768100000	MOVQ 0x1068(DI)(DX*8), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x417d67		4e8d14ca		LEAQ 0(DX)(R9*8), R10	
	block := *blockp
  0x417d6b		418402			TESTB AL, 0(R10)	
  0x417d6e		4a8b14ca		MOVQ 0(DX)(R9*8), DX	
	s := block.spans[bottom]
  0x417d72		8402			TESTB AL, 0(DX)		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x417d74		4181e0ff010000		ANDL $0x1ff, R8		
	s := block.spans[bottom]
  0x417d7b		4a8b04c2		MOVQ 0(DX)(R8*8), AX	
	block.spans[bottom] = nil
  0x417d7f		4ac704c200000000	MOVQ $0x0, 0(DX)(R8*8)	
		s := mheap_.sweepSpans[1-sg/2%2].pop()
  0x417d87		e9eefdffff		JMP 0x417b7a		
		_g_.m.locks--
  0x417d8c		488b4130		MOVQ 0x30(CX), AX	
  0x417d90		838000010000ff		ADDL $-0x1, 0x100(AX)	
		return ^uintptr(0)
  0x417d97		48c7442468ffffffff	MOVQ $-0x1, 0x68(SP)	
  0x417da0		488b6c2458		MOVQ 0x58(SP), BP	
  0x417da5		4883c460		ADDQ $0x60, SP		
  0x417da9		c3			RET			
  0x417daa		89742424		MOVL SI, 0x24(SP)	
  0x417dae		8854241f		MOVB DL, 0x1f(SP)	
  0x417db2		4489442420		MOVL R8, 0x20(SP)	
				print("runtime: bad span s.state=", s.state, " s.sweepgen=", s.sweepgen, " sweepgen=", sg, "\n")
  0x417db7		e8449d0000		CALL runtime.printlock(SB)	
  0x417dbc		488d05cd3e0500		LEAQ 0x53ecd(IP), AX		
  0x417dc3		48890424		MOVQ AX, 0(SP)			
  0x417dc7		48c74424081a000000	MOVQ $0x1a, 0x8(SP)		
  0x417dd0		e86ba60000		CALL runtime.printstring(SB)	
  0x417dd5		0fb644241f		MOVZX 0x1f(SP), AX		
  0x417dda		0fb6c0			MOVZX AL, AX			
  0x417ddd		48890424		MOVQ AX, 0(SP)			
  0x417de1		e88aa30000		CALL runtime.printuint(SB)	
  0x417de6		488d0561270500		LEAQ 0x52761(IP), AX		
  0x417ded		48890424		MOVQ AX, 0(SP)			
  0x417df1		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x417dfa		e841a60000		CALL runtime.printstring(SB)	
  0x417dff		8b442420		MOVL 0x20(SP), AX		
  0x417e03		48890424		MOVQ AX, 0(SP)			
  0x417e07		e864a30000		CALL runtime.printuint(SB)	
  0x417e0c		488d05d1240500		LEAQ 0x524d1(IP), AX		
  0x417e13		48890424		MOVQ AX, 0(SP)			
  0x417e17		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x417e20		e81ba60000		CALL runtime.printstring(SB)	
  0x417e25		8b442424		MOVL 0x24(SP), AX		
  0x417e29		48890424		MOVQ AX, 0(SP)			
  0x417e2d		e83ea30000		CALL runtime.printuint(SB)	
  0x417e32		e8599f0000		CALL runtime.printnl(SB)	
  0x417e37		e8449d0000		CALL runtime.printunlock(SB)	
				throw("non in-use span in unswept list")
  0x417e3c		488d05a6480500		LEAQ 0x548a6(IP), AX	
  0x417e43		48890424		MOVQ AX, 0(SP)		
  0x417e47		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x417e50		e87b930000		CALL runtime.throw(SB)	
  0x417e55		0f0b			UD2			
		s := mheap_.sweepSpans[1-sg/2%2].pop()
  0x417e57		e8e47b0000		CALL runtime.panicindex(SB)	
  0x417e5c		0f0b			UD2				
func sweepone() uintptr {
  0x417e5e		e80dc70200		CALL runtime.morestack_noctxt(SB)	
  0x417e63		e958fcffff		JMP runtime.sweepone(SB)		

TEXT runtime.gosweepone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
func gosweepone() uintptr {
  0x417e70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417e79		483b6110		CMPQ 0x10(CX), SP	
  0x417e7d		764f			JBE 0x417ece		
  0x417e7f		4883ec28		SUBQ $0x28, SP		
  0x417e83		48896c2420		MOVQ BP, 0x20(SP)	
  0x417e88		488d6c2420		LEAQ 0x20(SP), BP	
	var ret uintptr
  0x417e8d		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	systemstack(func() {
  0x417e96		488d0523a80200		LEAQ runtime.gosweepone.func1(SB), AX	
  0x417e9d		4889442410		MOVQ AX, 0x10(SP)			
  0x417ea2		488d442408		LEAQ 0x8(SP), AX			
  0x417ea7		4889442418		MOVQ AX, 0x18(SP)			
  0x417eac		488d442410		LEAQ 0x10(SP), AX			
  0x417eb1		48890424		MOVQ AX, 0(SP)				
  0x417eb5		e866c50200		CALL runtime.systemstack(SB)		
	return ret
  0x417eba		488b442408		MOVQ 0x8(SP), AX	
  0x417ebf		4889442430		MOVQ AX, 0x30(SP)	
  0x417ec4		488b6c2420		MOVQ 0x20(SP), BP	
  0x417ec9		4883c428		ADDQ $0x28, SP		
  0x417ecd		c3			RET			
func gosweepone() uintptr {
  0x417ece		e89dc60200		CALL runtime.morestack_noctxt(SB)	
  0x417ed3		eb9b			JMP runtime.gosweepone(SB)		

TEXT runtime.(*mspan).ensureSwept(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
func (s *mspan) ensureSwept() {
  0x417ee0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417ee9		483b6110		CMPQ 0x10(CX), SP	
  0x417eed		0f86bd000000		JBE 0x417fb0		
  0x417ef3		4883ec28		SUBQ $0x28, SP		
  0x417ef7		48896c2420		MOVQ BP, 0x20(SP)	
  0x417efc		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x417f01		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if _g_.m.locks == 0 && _g_.m.mallocing == 0 && _g_ != _g_.m.g0 {
  0x417f0a		488b5130		MOVQ 0x30(CX), DX	
  0x417f0e		8b9a00010000		MOVL 0x100(DX), BX	
  0x417f14		85db			TESTL BX, BX		
  0x417f16		7512			JNE 0x417f2a		
  0x417f18		8b9ae8000000		MOVL 0xe8(DX), BX	
  0x417f1e		85db			TESTL BX, BX		
  0x417f20		7508			JNE 0x417f2a		
  0x417f22		488b12			MOVQ 0(DX), DX		
  0x417f25		4839d1			CMPQ DX, CX		
  0x417f28		756b			JNE 0x417f95		
	sg := mheap_.sweepgen
  0x417f2a		8b0d90530900		MOVL runtime.mheap_+4128(SB), CX	
  0x417f30		488b542430		MOVQ 0x30(SP), DX			
	if atomic.Load(&s.sweepgen) == sg {
  0x417f35		8b5a58			MOVL 0x58(DX), BX	
  0x417f38		39cb			CMPL CX, BX		
  0x417f3a		744f			JE 0x417f8b		
	if atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x417f3c		8d41fe			LEAL -0x2(CX), AX		
  0x417f3f		8d59ff			LEAL -0x1(CX), BX		
  0x417f42		f00fb15a58		LOCK CMPXCHGL BX, 0x58(DX)	
  0x417f47		0f94c3			SETE BL				
  0x417f4a		84db			TESTL BL, BL			
  0x417f4c		7525			JNE 0x417f73			
  0x417f4e		894c241c		MOVL CX, 0x1c(SP)		
	for atomic.Load(&s.sweepgen) != sg {
  0x417f52		eb0e			JMP 0x417f62		
		osyield()
  0x417f54		e8f7ff0200		CALL runtime.osyield(SB)	
  0x417f59		8b4c241c		MOVL 0x1c(SP), CX		
  0x417f5d		488b542430		MOVQ 0x30(SP), DX		
	for atomic.Load(&s.sweepgen) != sg {
  0x417f62		8b4258			MOVL 0x58(DX), AX	
  0x417f65		39c8			CMPL CX, AX		
  0x417f67		75eb			JNE 0x417f54		
  0x417f69		488b6c2420		MOVQ 0x20(SP), BP	
  0x417f6e		4883c428		ADDQ $0x28, SP		
  0x417f72		c3			RET			
		s.sweep(false)
  0x417f73		48891424		MOVQ DX, 0(SP)			
  0x417f77		c644240800		MOVB $0x0, 0x8(SP)		
  0x417f7c		e83f000000		CALL runtime.(*mspan).sweep(SB)	
		return
  0x417f81		488b6c2420		MOVQ 0x20(SP), BP	
  0x417f86		4883c428		ADDQ $0x28, SP		
  0x417f8a		c3			RET			
		return
  0x417f8b		488b6c2420		MOVQ 0x20(SP), BP	
  0x417f90		4883c428		ADDQ $0x28, SP		
  0x417f94		c3			RET			
		throw("MSpan_EnsureSwept: m is not locked")
  0x417f95		488d051a4c0500		LEAQ 0x54c1a(IP), AX	
  0x417f9c		48890424		MOVQ AX, 0(SP)		
  0x417fa0		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x417fa9		e822920000		CALL runtime.throw(SB)	
  0x417fae		0f0b			UD2			
func (s *mspan) ensureSwept() {
  0x417fb0		e8bbc50200		CALL runtime.morestack_noctxt(SB)	
  0x417fb5		e926ffffff		JMP runtime.(*mspan).ensureSwept(SB)	

TEXT runtime.(*mspan).sweep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
func (s *mspan) sweep(preserve bool) bool {
  0x417fc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417fc9		488d4424b8		LEAQ -0x48(SP), AX	
  0x417fce		483b4110		CMPQ 0x10(CX), AX	
  0x417fd2		0f8651090000		JBE 0x418929		
  0x417fd8		4881ecc8000000		SUBQ $0xc8, SP		
  0x417fdf		4889ac24c0000000	MOVQ BP, 0xc0(SP)	
  0x417fe7		488dac24c0000000	LEAQ 0xc0(SP), BP	
  0x417fef		0f57c0			XORPS X0, X0		
  0x417ff2		0f11842490000000	MOVUPS X0, 0x90(SP)	
  0x417ffa		0f118424a0000000	MOVUPS X0, 0xa0(SP)	
  0x418002		0f118424b0000000	MOVUPS X0, 0xb0(SP)	
	_g_ := getg()
  0x41800a		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	if _g_.m.locks == 0 && _g_.m.mallocing == 0 && _g_ != _g_.m.g0 {
  0x418013		488b5a30		MOVQ 0x30(DX), BX	
  0x418017		8bb300010000		MOVL 0x100(BX), SI	
  0x41801d		85f6			TESTL SI, SI		
  0x41801f		7516			JNE 0x418037		
  0x418021		8bb3e8000000		MOVL 0xe8(BX), SI	
  0x418027		85f6			TESTL SI, SI		
  0x418029		750c			JNE 0x418037		
  0x41802b		488b1b			MOVQ 0(BX), BX		
  0x41802e		4839da			CMPQ BX, DX		
  0x418031		0f85d7080000		JNE 0x41890e		
	sweepgen := mheap_.sweepgen
  0x418037		8b1d83520900		MOVL runtime.mheap_+4128(SB), BX	
  0x41803d		895c2430		MOVL BX, 0x30(SP)			
  0x418041		488bb424d0000000	MOVQ 0xd0(SP), SI			
	if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x418049		0fb67e64		MOVZX 0x64(SI), DI	
  0x41804d		40887c242b		MOVB DI, 0x2b(SP)	
  0x418052		4080ff01		CMPL $0x1, DI		
  0x418056		0f8509080000		JNE 0x418865		
  0x41805c		448b4658		MOVL 0x58(SI), R8	
  0x418060		448d4bff		LEAL -0x1(BX), R9	
  0x418064		4539c1			CMPL R8, R9		
  0x418067		0f85f8070000		JNE 0x418865		
  0x41806d		44894c2434		MOVL R9, 0x34(SP)	
	if trace.enabled {
  0x418072		0fb63d57b70900		MOVZX runtime.trace+16(SB), DI	
  0x418079		4084ff			TESTL DI, DI			
  0x41807c		0f850b060000		JNE 0x41868d			
	atomic.Xadd64(&mheap_.pagesSwept, int64(s.npages))
  0x418082		488b7e20		MOVQ 0x20(SI), DI			
  0x418086		4c8d05d3520900		LEAQ runtime.mheap_+4288(SB), R8	
  0x41808d		f0490fc138		LOCK XADDQ DI, 0(R8)			
	c := _g_.m.mcache
  0x418092		488b5230		MOVQ 0x30(DX), DX	
	specialp := &s.specials
  0x418096		488dbe90000000		LEAQ 0x90(SI), DI	
	special := *specialp
  0x41809d		8407			TESTB AL, 0(DI)		
	spc := s.spanclass
  0x41809f		440fb64662		MOVZX 0x62(SI), R8	
  0x4180a4		4488442426		MOVB R8, 0x26(SP)	
	size := s.elemsize
  0x4180a9		4c8b5668		MOVQ 0x68(SI), R10	
  0x4180ad		4c89542438		MOVQ R10, 0x38(SP)	
	c := _g_.m.mcache
  0x4180b2		488b9260010000		MOVQ 0x160(DX), DX	
  0x4180b9		4889942480000000	MOVQ DX, 0x80(SP)	
	special := *specialp
  0x4180c1		4c8b9e90000000		MOVQ 0x90(SI), R11	
	for special != nil {
  0x4180c8		eb09			JMP 0x4180d3		
  0x4180ca		4c89df			MOVQ R11, DI		
  0x4180cd		4989d3			MOVQ DX, R11		
  0x4180d0		4c89f2			MOVQ R14, DX		
  0x4180d3		4d85db			TESTQ R11, R11		
  0x4180d6		0f8446010000		JE 0x418222		
		objIndex := uintptr(special.offset) / size
  0x4180dc		410fb74308		MOVZX 0x8(R11), AX	
  0x4180e1		4d85d2			TESTQ R10, R10		
  0x4180e4		0f8474070000		JE 0x41885e		
  0x4180ea		4889d1			MOVQ DX, CX		
  0x4180ed		31d2			XORL DX, DX		
  0x4180ef		49f7f2			DIVQ R10		
	bytep, mask := s.gcmarkBits.bitp(objIndex)
  0x4180f2		488b5650		MOVQ 0x50(SI), DX	
  0x4180f6		4989c4			MOVQ AX, R12		
	return b.bytep(n / 8), 1 << (n % 8)
  0x4180f9		48c1e803		SHRQ $0x3, AX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x4180fd		4c8d2c10		LEAQ 0(AX)(DX*1), R13	
	return *m.bytep&m.mask != 0
  0x418101		41844500		TESTB AL, 0(R13)	
  0x418105		4d89e5			MOVQ R12, R13		
		p := s.base() + objIndex*size
  0x418108		4d0fafe2		IMULQ R10, R12		
	return b.bytep(n / 8), 1 << (n % 8)
  0x41810c		4983e507		ANDQ $0x7, R13		
  0x418110		4989ce			MOVQ CX, R14		
  0x418113		4c89e9			MOVQ R13, CX		
  0x418116		41bf01000000		MOVL $0x1, R15		
  0x41811c		41d3e7			SHLL CL, R15		
	return *m.bytep&m.mask != 0
  0x41811f		440fb62c10		MOVZX 0(AX)(DX*1), R13	
  0x418124		4584fd			TESTL R15, R13		
		if !mbits.isMarked() {
  0x418127		7405			JE 0x41812e		
			special = *specialp
  0x418129		498b13			MOVQ 0(R11), DX		
  0x41812c		eb9c			JMP 0x4180ca		
			endOffset := p - s.base() + size
  0x41812e		4d01d4			ADDQ R10, R12		
  0x418131		4c89d9			MOVQ R11, CX		
			for tmp := special; tmp != nil && uintptr(tmp.offset) < endOffset; tmp = tmp.next {
  0x418134		eb0b			JMP 0x418141		
  0x418136		4d8b1b			MOVQ 0(R11), R11	
  0x418139		4c8bb42480000000	MOVQ 0x80(SP), R14	
  0x418141		4d85db			TESTQ R11, R11		
  0x418144		0f84d1000000		JE 0x41821b		
  0x41814a		450fb77308		MOVZX 0x8(R11), R14	
  0x41814f		4d39e6			CMPQ R12, R14		
  0x418152		0f83bc000000		JAE 0x418214		
				if tmp.kind == _KindSpecialFinalizer {
  0x418158		450fb6730a		MOVZX 0xa(R11), R14	
  0x41815d		4180fe01		CMPL $0x1, R14		
  0x418161		75d3			JNE 0x418136		
	*m.bytep |= m.mask
  0x418163		4509fd			ORL R15, R13		
  0x418166		44882c10		MOVB R13, 0(AX)(DX*1)	
  0x41816a		b801000000		MOVL $0x1, AX		
					break
  0x41816f		4c89642448		MOVQ R12, 0x48(SP)	
  0x418174		88442428		MOVB AL, 0x28(SP)	
			for special != nil && uintptr(special.offset) < endOffset {
  0x418178		eb06			JMP 0x418180		
  0x41817a		4889cf			MOVQ CX, DI		
  0x41817d		4889d1			MOVQ DX, CX		
  0x418180		4885c9			TESTQ CX, CX		
  0x418183		747c			JE 0x418201		
  0x418185		0fb75108		MOVZX 0x8(CX), DX	
  0x418189		4c39e2			CMPQ R12, DX		
  0x41818c		7373			JAE 0x418201		
	return s.startAddr
  0x41818e		4c8b5e18		MOVQ 0x18(SI), R11	
				p := s.base() + uintptr(special.offset)
  0x418192		4c01da			ADDQ R11, DX		
				if special.kind == _KindSpecialFinalizer || !hasFin {
  0x418195		440fb6590a		MOVZX 0xa(CX), R11	
  0x41819a		4180fb01		CMPL $0x1, R11		
  0x41819e		7409			JE 0x4181a9		
  0x4181a0		84c0			TESTL AL, AL		
  0x4181a2		7405			JE 0x4181a9		
					special = *specialp
  0x4181a4		488b11			MOVQ 0(CX), DX		
  0x4181a7		ebd1			JMP 0x41817a		
  0x4181a9		48897c2470		MOVQ DI, 0x70(SP)	
					special = special.next
  0x4181ae		488b01			MOVQ 0(CX), AX		
  0x4181b1		4889442478		MOVQ AX, 0x78(SP)	
					*specialp = special
  0x4181b6		488907			MOVQ AX, 0(DI)		
					freespecial(y, unsafe.Pointer(p), size)
  0x4181b9		48890c24		MOVQ CX, 0(SP)			
  0x4181bd		4889542408		MOVQ DX, 0x8(SP)		
  0x4181c2		4c89542410		MOVQ R10, 0x10(SP)		
  0x4181c7		e814460000		CALL runtime.freespecial(SB)	
  0x4181cc		0fb6442428		MOVZX 0x28(SP), AX		
  0x4181d1		8b5c2430		MOVL 0x30(SP), BX		
  0x4181d5		488bb424d0000000	MOVQ 0xd0(SP), SI		
  0x4181dd		440fb6442426		MOVZX 0x26(SP), R8		
  0x4181e3		448b4c2434		MOVL 0x34(SP), R9		
  0x4181e8		4c8b542438		MOVQ 0x38(SP), R10		
  0x4181ed		4c8b642448		MOVQ 0x48(SP), R12		
  0x4181f2		488b542478		MOVQ 0x78(SP), DX		
  0x4181f7		488b4c2470		MOVQ 0x70(SP), CX		
  0x4181fc		e979ffffff		JMP 0x41817a			
  0x418201		4c8bb42480000000	MOVQ 0x80(SP), R14		
  0x418209		4889ca			MOVQ CX, DX			
  0x41820c		4989fb			MOVQ DI, R11			
	for special != nil {
  0x41820f		e9b6feffff		JMP 0x4180ca		
  0x418214		31c0			XORL AX, AX		
			for tmp := special; tmp != nil && uintptr(tmp.offset) < endOffset; tmp = tmp.next {
  0x418216		e954ffffff		JMP 0x41816f		
  0x41821b		31c0			XORL AX, AX		
  0x41821d		e94dffffff		JMP 0x41816f		
	if debug.allocfreetrace != 0 || raceenabled || msanenabled {
  0x418222		8b0598b80a00		MOVL runtime.debug(SB), AX	
  0x418228		85c0			TESTL AX, AX			
  0x41822a		0f845a010000		JE 0x41838a			
	return markBits{(*uint8)(s.gcmarkBits), uint8(1), 0}
  0x418230		488b4650		MOVQ 0x50(SI), AX	
		mbits := s.markBitsForBase()
  0x418234		4889842490000000		MOVQ AX, 0x90(SP)	
  0x41823c		c684249800000001		MOVB $0x1, 0x98(SP)	
  0x418244		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)	
	bytep, mask := s.allocBits.bitp(allocBitIndex)
  0x418250		488b4648		MOVQ 0x48(SI), AX	
		abits := s.allocBitsForIndex(0)
  0x418254		48898424a8000000		MOVQ AX, 0xa8(SP)	
  0x41825c		c68424b000000001		MOVB $0x1, 0xb0(SP)	
  0x418264		48c78424b800000000000000	MOVQ $0x0, 0xb8(SP)	
  0x418270		31c0				XORL AX, AX		
		for i := uintptr(0); i < s.nelems; i++ {
  0x418272		eb0b			JMP 0x41827f		
	m.index++
  0x418274		48ff8424b8000000	INCQ 0xb8(SP)		
		for i := uintptr(0); i < s.nelems; i++ {
  0x41827c		48ffc0			INCQ AX			
  0x41827f		488b4e38		MOVQ 0x38(SI), CX	
  0x418283		4839c8			CMPQ CX, AX		
  0x418286		0f83fe000000		JAE 0x41838a		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x41828c		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x418294		0fb6bc2498000000	MOVZX 0x98(SP), DI	
	return *m.bytep&m.mask != 0
  0x41829c		0fb609			MOVZX 0(CX), CX		
  0x41829f		4084f9			TESTL DI, CL		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x4182a2		745a			JE 0x4182fe		
	if m.mask == 1<<7 {
  0x4182a4		0fb68c2498000000	MOVZX 0x98(SP), CX	
  0x4182ac		80f980			CMPL $0x80, CL		
  0x4182af		7542			JNE 0x4182f3		
		m.bytep = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.bytep)) + 1))
  0x4182b1		48ff842490000000	INCQ 0x90(SP)		
		m.mask = 1
  0x4182b9		c684249800000001	MOVB $0x1, 0x98(SP)	
	m.index++
  0x4182c1		48ff8424a0000000	INCQ 0xa0(SP)		
	if m.mask == 1<<7 {
  0x4182c9		0fb68c24b0000000	MOVZX 0xb0(SP), CX	
  0x4182d1		80f980			CMPL $0x80, CL		
  0x4182d4		7512			JNE 0x4182e8		
		m.bytep = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.bytep)) + 1))
  0x4182d6		48ff8424a8000000	INCQ 0xa8(SP)		
		m.mask = 1
  0x4182de		c68424b000000001	MOVB $0x1, 0xb0(SP)	
  0x4182e6		eb8c			JMP 0x418274		
		m.mask = m.mask << 1
  0x4182e8		d1e1			SHLL $0x1, CX		
  0x4182ea		888c24b0000000		MOVB CL, 0xb0(SP)	
  0x4182f1		eb81			JMP 0x418274		
  0x4182f3		d1e1			SHLL $0x1, CX		
  0x4182f5		888c2498000000		MOVB CL, 0x98(SP)	
  0x4182fc		ebc3			JMP 0x4182c1		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x4182fe		488b8c24b8000000	MOVQ 0xb8(SP), CX	
  0x418306		488b7e30		MOVQ 0x30(SI), DI	
  0x41830a		4839f9			CMPQ DI, CX		
  0x41830d		735e			JAE 0x41836d		
				x := s.base() + i*s.elemsize
  0x41830f		488b4e68		MOVQ 0x68(SI), CX	
  0x418313		480fafc8		IMULQ AX, CX		
	return s.startAddr
  0x418317		488d7e18		LEAQ 0x18(SI), DI	
				x := s.base() + i*s.elemsize
  0x41831b		48030f			ADDQ 0(DI), CX		
				if debug.allocfreetrace != 0 {
  0x41831e		8b3d9cb70a00		MOVL runtime.debug(SB), DI	
  0x418324		85ff			TESTL DI, DI			
  0x418326		0f8478ffffff		JE 0x4182a4			
  0x41832c		4889442440		MOVQ AX, 0x40(SP)		
					tracefree(unsafe.Pointer(x), size)
  0x418331		48890c24		MOVQ CX, 0(SP)			
  0x418335		4c89542408		MOVQ R10, 0x8(SP)		
  0x41833a		e8c15a0000		CALL runtime.tracefree(SB)	
  0x41833f		488b442440		MOVQ 0x40(SP), AX		
  0x418344		488b942480000000	MOVQ 0x80(SP), DX		
  0x41834c		8b5c2430		MOVL 0x30(SP), BX		
  0x418350		488bb424d0000000	MOVQ 0xd0(SP), SI		
  0x418358		440fb6442426		MOVZX 0x26(SP), R8		
  0x41835e		448b4c2434		MOVL 0x34(SP), R9		
  0x418363		4c8b542438		MOVQ 0x38(SP), R10		
  0x418368		e937ffffff		JMP 0x4182a4			
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x41836d		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x418375		0fb6bc24b0000000	MOVZX 0xb0(SP), DI	
	return *m.bytep&m.mask != 0
  0x41837d		0fb609			MOVZX 0(CX), CX		
  0x418380		4084f9			TESTL DI, CL		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x418383		758a			JNE 0x41830f		
  0x418385		e91affffff		JMP 0x4182a4		
	nalloc := uint16(s.countAlloc())
  0x41838a		48893424		MOVQ SI, 0(SP)				
  0x41838e		e8ad4dffff		CALL runtime.(*mspan).countAlloc(SB)	
  0x418393		488b442408		MOVQ 0x8(SP), AX			
  0x418398		0fb64c2426		MOVZX 0x26(SP), CX			
  0x41839d		89ca			MOVL CX, DX				
	return int8(sc >> 1)
  0x41839f		d0e9			SHRL $0x1, CL		
	if spc.sizeclass() == 0 && nalloc == 0 {
  0x4183a1		f6c1ff			TESTL $0xff, CL		
  0x4183a4		0f85d4020000		JNE 0x41867e		
  0x4183aa		6685c0			TESTW AX, AX		
  0x4183ad		0f85bc020000		JNE 0x41866f		
  0x4183b3		488b9c24d0000000	MOVQ 0xd0(SP), BX	
		s.needzero = 1
  0x4183bb		c6436501		MOVB $0x1, 0x65(BX)	
  0x4183bf		be01000000		MOVL $0x1, SI		
	nfreed := s.allocCount - nalloc
  0x4183c4		0fb77b60		MOVZX 0x60(BX), DI	
  0x4183c8		4189f8			MOVL DI, R8		
  0x4183cb		29c7			SUBL AX, DI		
  0x4183cd		66897c242c		MOVW DI, 0x2c(SP)	
	if nalloc > s.allocCount {
  0x4183d2		664439c0		CMPW R8, AX		
  0x4183d6		0f879f030000		JA 0x41877b		
  0x4183dc		884c242a		MOVB CL, 0x2a(SP)	
  0x4183e0		4088742429		MOVB SI, 0x29(SP)	
	s.allocCount = nalloc
  0x4183e5		66894360		MOVW AX, 0x60(BX)	
	wasempty := s.nextFreeIndex() == s.nelems
  0x4183e9		48891c24		MOVQ BX, 0(SP)				
  0x4183ed		e8de3affff		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x4183f2		488b442408		MOVQ 0x8(SP), AX			
  0x4183f7		4889442468		MOVQ AX, 0x68(SP)			
  0x4183fc		488b8c24d0000000	MOVQ 0xd0(SP), CX			
  0x418404		488b5138		MOVQ 0x38(CX), DX			
  0x418408		4889542460		MOVQ DX, 0x60(SP)			
	s.freeindex = 0 // reset allocation index to start of span.
  0x41840d		48c7413000000000	MOVQ $0x0, 0x30(CX)	
	if trace.enabled {
  0x418415		0fb61db4b30900		MOVZX runtime.trace+16(SB), BX	
  0x41841c		84db			TESTL BL, BL			
  0x41841e		7434			JE 0x418454			
		getg().m.p.ptr().traceReclaimed += uintptr(nfreed) * s.elemsize
  0x418420		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x418429		488b5b30		MOVQ 0x30(BX), BX	
  0x41842d		488b9bd0000000		MOVQ 0xd0(BX), BX	
  0x418434		8403			TESTB AL, 0(BX)		
  0x418436		0fb774242c		MOVZX 0x2c(SP), SI	
  0x41843b		0fb7fe			MOVZX SI, DI		
  0x41843e		4c8b4168		MOVQ 0x68(CX), R8	
  0x418442		4c0fafc7		IMULQ DI, R8		
  0x418446		4c038330120000		ADDQ 0x1230(BX), R8	
  0x41844d		4c898330120000		MOVQ R8, 0x1230(BX)	
	s.allocBits = s.gcmarkBits
  0x418454		488b4150		MOVQ 0x50(CX), AX	
  0x418458		48894148		MOVQ AX, 0x48(CX)	
	s.gcmarkBits = newMarkBits(s.nelems)
  0x41845c		488b4138		MOVQ 0x38(CX), AX		
  0x418460		48890424		MOVQ AX, 0(SP)			
  0x418464		e8d7440000		CALL runtime.newMarkBits(SB)	
  0x418469		488b442408		MOVQ 0x8(SP), AX		
  0x41846e		488b8c24d0000000	MOVQ 0xd0(SP), CX		
  0x418476		48894150		MOVQ AX, 0x50(CX)		
	s.refillAllocCache(0)
  0x41847a		48890c24		MOVQ CX, 0(SP)					
  0x41847e		48c744240800000000	MOVQ $0x0, 0x8(SP)				
  0x418487		e8243affff		CALL runtime.(*mspan).refillAllocCache(SB)	
  0x41848c		0fb6442429		MOVZX 0x29(SP), AX				
	if freeToHeap || nfreed == 0 {
  0x418491		84c0			TESTL AL, AL		
  0x418493		0f84b7010000		JE 0x418650		
  0x418499		488b8c24d0000000	MOVQ 0xd0(SP), CX	
		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x4184a1		0fb65164		MOVZX 0x64(CX), DX	
  0x4184a5		8854242b		MOVB DL, 0x2b(SP)	
  0x4184a9		80fa01			CMPL $0x1, DL		
  0x4184ac		0f8520020000		JNE 0x4186d2		
  0x4184b2		8b5958			MOVL 0x58(CX), BX	
  0x4184b5		8b742434		MOVL 0x34(SP), SI	
  0x4184b9		39de			CMPL BX, SI		
  0x4184bb		0f8511020000		JNE 0x4186d2		
  0x4184c1		8b542430		MOVL 0x30(SP), DX	
  0x4184c5		89d3			MOVL DX, BX		
		atomic.Store(&s.sweepgen, sweepgen)
  0x4184c7		875158			XCHGL DX, 0x58(CX)	
  0x4184ca		0fb754242c		MOVZX 0x2c(SP), DX	
	if nfreed > 0 && spc.sizeclass() != 0 {
  0x4184cf		6685d2			TESTW DX, DX		
  0x4184d2		0f8671010000		JBE 0x418649		
  0x4184d8		0fb674242a		MOVZX 0x2a(SP), SI	
	if spc.sizeclass() == 0 && nalloc == 0 {
  0x4184dd		40f6c6ff		TESTL $0xff, SI		
	if nfreed > 0 && spc.sizeclass() != 0 {
  0x4184e1		0f84dd000000		JE 0x4185c4		
  0x4184e7		488b842480000000	MOVQ 0x80(SP), AX	
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x4184ef		8400			TESTB AL, 0(AX)			
  0x4184f1		480fbef6		MOVSX SI, SI			
  0x4184f5		4883fe43		CMPQ $0x43, SI			
  0x4184f9		0f83cc010000		JAE 0x4186cb			
  0x4184ff		488bbcf0b0040000	MOVQ 0x4b0(AX)(SI*8), DI	
  0x418507		0fb7d2			MOVZX DX, DX			
  0x41850a		4801fa			ADDQ DI, DX			
  0x41850d		488994f0b0040000	MOVQ DX, 0x4b0(AX)(SI*8)	
  0x418515		0fb6442426		MOVZX 0x26(SP), AX		
		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
  0x41851a		0fb6c0			MOVZX AL, AX			
  0x41851d		483d86000000		CMPQ $0x86, AX			
  0x418523		0f839b010000		JAE 0x4186c4			
  0x418529		48c1e006		SHLQ $0x6, AX			
  0x41852d		488d156c3d0900		LEAQ runtime.mheap_(SB), DX	
  0x418534		488d840250130000	LEAQ 0x1350(DX)(AX*1), AX	
  0x41853c		48890424		MOVQ AX, 0(SP)			
  0x418540		48894c2408		MOVQ CX, 0x8(SP)		
  0x418545		0fb68424d8000000	MOVZX 0xd8(SP), AX		
  0x41854d		88442410		MOVB AL, 0x10(SP)		
  0x418551		488d442411		LEAQ 0x11(SP), AX		
  0x418556		488b542468		MOVQ 0x68(SP), DX		
  0x41855b		488b5c2460		MOVQ 0x60(SP), BX		
	wasempty := s.nextFreeIndex() == s.nelems
  0x418560		4839da			CMPQ BX, DX		
		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
  0x418563		0f9400			SETE 0(AX)				
  0x418566		e81566ffff		CALL runtime.(*mcentral).freeSpan(SB)	
  0x41856b		0fb6442418		MOVZX 0x18(SP), AX			
	if !res {
  0x418570		84c0			TESTL AL, AL		
  0x418572		7417			JE 0x41858b		
	return res
  0x418574		888424e0000000		MOVB AL, 0xe0(SP)	
  0x41857b		488bac24c0000000	MOVQ 0xc0(SP), BP	
  0x418583		4881c4c8000000		ADDQ $0xc8, SP		
  0x41858a		c3			RET			
  0x41858b		88442427		MOVB AL, 0x27(SP)	
  0x41858f		8b442430		MOVL 0x30(SP), AX	
		mheap_.sweepSpans[sweepgen/2%2].push(s)
  0x418593		d1e8			SHRL $0x1, AX				
  0x418595		83e001			ANDL $0x1, AX				
  0x418598		488d0480		LEAQ 0(AX)(AX*4), AX			
  0x41859c		488d0d5d4d0900		LEAQ runtime.mheap_+4192(SB), CX	
  0x4185a3		488d04c1		LEAQ 0(CX)(AX*8), AX			
  0x4185a7		48890424		MOVQ AX, 0(SP)				
  0x4185ab		488b8424d0000000	MOVQ 0xd0(SP), AX			
  0x4185b3		4889442408		MOVQ AX, 0x8(SP)			
  0x4185b8		e8d3040000		CALL runtime.(*gcSweepBuf).push(SB)	
  0x4185bd		0fb6442427		MOVZX 0x27(SP), AX			
  0x4185c2		ebb0			JMP 0x418574				
	if freeToHeap || nfreed == 0 {
  0x4185c4		84c0			TESTL AL, AL		
	} else if freeToHeap {
  0x4185c6		747a			JE 0x418642		
		if debug.efence > 0 {
  0x4185c8		8b05fab40a00		MOVL runtime.debug+8(SB), AX	
  0x4185ce		85c0			TESTL AX, AX			
  0x4185d0		7e51			JLE 0x418623			
			s.limit = 0 // prevent mlookup from finding this span
  0x4185d2		48c7818000000000000000	MOVQ $0x0, 0x80(CX)	
	return s.startAddr
  0x4185dd		488b4118		MOVQ 0x18(CX), AX	
			sysFault(unsafe.Pointer(s.base()), size)
  0x4185e1		48890424		MOVQ AX, 0(SP)			
  0x4185e5		488b442438		MOVQ 0x38(SP), AX		
  0x4185ea		4889442408		MOVQ AX, 0x8(SP)		
  0x4185ef		e89c6dffff		CALL runtime.sysFault(SB)	
  0x4185f4		488b842480000000	MOVQ 0x80(SP), AX		
		c.local_nlargefree++
  0x4185fc		48ff80a8040000		INCQ 0x4a8(AX)		
		c.local_largefree += size
  0x418603		488b88a0040000		MOVQ 0x4a0(AX), CX	
  0x41860a		488b542438		MOVQ 0x38(SP), DX	
  0x41860f		4801d1			ADDQ DX, CX		
  0x418612		488988a0040000		MOVQ CX, 0x4a0(AX)	
  0x418619		b801000000		MOVL $0x1, AX		
		res = true
  0x41861e		e94dffffff		JMP 0x418570		
			mheap_.freeSpan(s, 1)
  0x418623		488d05763c0900		LEAQ runtime.mheap_(SB), AX		
  0x41862a		48890424		MOVQ AX, 0(SP)				
  0x41862e		48894c2408		MOVQ CX, 0x8(SP)			
  0x418633		c744241001000000	MOVL $0x1, 0x10(SP)			
  0x41863b		e8502e0000		CALL runtime.(*mheap).freeSpan(SB)	
  0x418640		ebb2			JMP 0x4185f4				
  0x418642		31c0			XORL AX, AX				
	} else if freeToHeap {
  0x418644		e927ffffff		JMP 0x418570		
	if freeToHeap || nfreed == 0 {
  0x418649		84c0			TESTL AL, AL		
	if nfreed > 0 && spc.sizeclass() != 0 {
  0x41864b		e976ffffff		JMP 0x4185c6		
  0x418650		0fb74c242c		MOVZX 0x2c(SP), CX	
	if freeToHeap || nfreed == 0 {
  0x418655		6685c9			TESTW CX, CX		
  0x418658		0f843bfeffff		JE 0x418499		
  0x41865e		488b8c24d0000000	MOVQ 0xd0(SP), CX	
  0x418666		8b5c2430		MOVL 0x30(SP), BX	
  0x41866a		e95bfeffff		JMP 0x4184ca		
  0x41866f		488b9c24d0000000	MOVQ 0xd0(SP), BX	
  0x418677		31f6			XORL SI, SI		
	if spc.sizeclass() == 0 && nalloc == 0 {
  0x418679		e946fdffff		JMP 0x4183c4		
  0x41867e		488b9c24d0000000	MOVQ 0xd0(SP), BX	
  0x418686		31f6			XORL SI, SI		
  0x418688		e937fdffff		JMP 0x4183c4		
  0x41868d		4889942488000000	MOVQ DX, 0x88(SP)	
		traceGCSweepSpan(s.npages * _PageSize)
  0x418695		488b4620		MOVQ 0x20(SI), AX			
  0x418699		48c1e00d		SHLQ $0xd, AX				
  0x41869d		48890424		MOVQ AX, 0(SP)				
  0x4186a1		e85a1f0200		CALL runtime.traceGCSweepSpan(SB)	
  0x4186a6		488b942488000000	MOVQ 0x88(SP), DX			
  0x4186ae		8b5c2430		MOVL 0x30(SP), BX			
  0x4186b2		488bb424d0000000	MOVQ 0xd0(SP), SI			
  0x4186ba		448b4c2434		MOVL 0x34(SP), R9			
  0x4186bf		e9bef9ffff		JMP 0x418082				
		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
  0x4186c4		e877730000		CALL runtime.panicindex(SB)	
  0x4186c9		0f0b			UD2				
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x4186cb		e870730000		CALL runtime.panicindex(SB)	
  0x4186d0		0f0b			UD2				
			print("MSpan_Sweep: state=", s.state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
  0x4186d2		8b4158			MOVL 0x58(CX), AX		
  0x4186d5		4889442458		MOVQ AX, 0x58(SP)		
  0x4186da		e821940000		CALL runtime.printlock(SB)	
  0x4186df		488d0541270500		LEAQ 0x52741(IP), AX		
  0x4186e6		48890424		MOVQ AX, 0(SP)			
  0x4186ea		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4186f3		e8489d0000		CALL runtime.printstring(SB)	
  0x4186f8		0fb644242b		MOVZX 0x2b(SP), AX		
  0x4186fd		0fb6c0			MOVZX AL, AX			
  0x418700		48890424		MOVQ AX, 0(SP)			
  0x418704		e8679a0000		CALL runtime.printuint(SB)	
  0x418709		488d05d41b0500		LEAQ 0x51bd4(IP), AX		
  0x418710		48890424		MOVQ AX, 0(SP)			
  0x418714		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41871d		e81e9d0000		CALL runtime.printstring(SB)	
  0x418722		488b442458		MOVQ 0x58(SP), AX		
  0x418727		48890424		MOVQ AX, 0(SP)			
  0x41872b		e8409a0000		CALL runtime.printuint(SB)	
  0x418730		488d05cb220500		LEAQ 0x522cb(IP), AX		
  0x418737		48890424		MOVQ AX, 0(SP)			
  0x41873b		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x418744		e8f79c0000		CALL runtime.printstring(SB)	
  0x418749		8b442430		MOVL 0x30(SP), AX		
  0x41874d		48890424		MOVQ AX, 0(SP)			
  0x418751		e81a9a0000		CALL runtime.printuint(SB)	
  0x418756		e835960000		CALL runtime.printnl(SB)	
  0x41875b		e820940000		CALL runtime.printunlock(SB)	
			throw("MSpan_Sweep: bad span state after sweep")
  0x418760		488d059f490500		LEAQ 0x5499f(IP), AX	
  0x418767		48890424		MOVQ AX, 0(SP)		
  0x41876b		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x418774		e8578a0000		CALL runtime.throw(SB)	
  0x418779		0f0b			UD2			
  0x41877b		4889442450		MOVQ AX, 0x50(SP)	
  0x418780		66448944242e		MOVW R8, 0x2e(SP)	
		print("runtime: nelems=", s.nelems, " nalloc=", nalloc, " previous allocCount=", s.allocCount, " nfreed=", nfreed, "\n")
  0x418786		488b4338		MOVQ 0x38(BX), AX		
  0x41878a		4889442468		MOVQ AX, 0x68(SP)		
  0x41878f		e86c930000		CALL runtime.printlock(SB)	
  0x418794		488d05d7230500		LEAQ 0x523d7(IP), AX		
  0x41879b		48890424		MOVQ AX, 0(SP)			
  0x41879f		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4187a8		e8939c0000		CALL runtime.printstring(SB)	
  0x4187ad		488b442468		MOVQ 0x68(SP), AX		
  0x4187b2		48890424		MOVQ AX, 0(SP)			
  0x4187b6		e8b5990000		CALL runtime.printuint(SB)	
  0x4187bb		488d05f5170500		LEAQ 0x517f5(IP), AX		
  0x4187c2		48890424		MOVQ AX, 0(SP)			
  0x4187c6		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4187cf		e86c9c0000		CALL runtime.printstring(SB)	
  0x4187d4		488b442450		MOVQ 0x50(SP), AX		
  0x4187d9		0fb7c0			MOVZX AX, AX			
  0x4187dc		48890424		MOVQ AX, 0(SP)			
  0x4187e0		e88b990000		CALL runtime.printuint(SB)	
  0x4187e5		488d055e2a0500		LEAQ 0x52a5e(IP), AX		
  0x4187ec		48890424		MOVQ AX, 0(SP)			
  0x4187f0		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4187f9		e8429c0000		CALL runtime.printstring(SB)	
  0x4187fe		0fb744242e		MOVZX 0x2e(SP), AX		
  0x418803		0fb7c0			MOVZX AX, AX			
  0x418806		48890424		MOVQ AX, 0(SP)			
  0x41880a		e861990000		CALL runtime.printuint(SB)	
  0x41880f		488d05b1170500		LEAQ 0x517b1(IP), AX		
  0x418816		48890424		MOVQ AX, 0(SP)			
  0x41881a		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x418823		e8189c0000		CALL runtime.printstring(SB)	
  0x418828		0fb744242c		MOVZX 0x2c(SP), AX		
  0x41882d		0fb7c0			MOVZX AX, AX			
  0x418830		48890424		MOVQ AX, 0(SP)			
  0x418834		e837990000		CALL runtime.printuint(SB)	
  0x418839		e852950000		CALL runtime.printnl(SB)	
  0x41883e		e83d930000		CALL runtime.printunlock(SB)	
		throw("sweep increased allocation count")
  0x418843		488d05f9400500		LEAQ 0x540f9(IP), AX	
  0x41884a		48890424		MOVQ AX, 0(SP)		
  0x41884e		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x418857		e874890000		CALL runtime.throw(SB)	
  0x41885c		0f0b			UD2			
		objIndex := uintptr(special.offset) / size
  0x41885e		e8bd720000		CALL runtime.panicdivide(SB)	
  0x418863		0f0b			UD2				
		print("MSpan_Sweep: state=", s.state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
  0x418865		8b4658			MOVL 0x58(SI), AX		
  0x418868		4889442458		MOVQ AX, 0x58(SP)		
  0x41886d		e88e920000		CALL runtime.printlock(SB)	
  0x418872		488d05ae250500		LEAQ 0x525ae(IP), AX		
  0x418879		48890424		MOVQ AX, 0(SP)			
  0x41887d		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x418886		e8b59b0000		CALL runtime.printstring(SB)	
  0x41888b		0fb644242b		MOVZX 0x2b(SP), AX		
  0x418890		0fb6c0			MOVZX AL, AX			
  0x418893		48890424		MOVQ AX, 0(SP)			
  0x418897		e8d4980000		CALL runtime.printuint(SB)	
  0x41889c		488d05411a0500		LEAQ 0x51a41(IP), AX		
  0x4188a3		48890424		MOVQ AX, 0(SP)			
  0x4188a7		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x4188b0		e88b9b0000		CALL runtime.printstring(SB)	
  0x4188b5		488b442458		MOVQ 0x58(SP), AX		
  0x4188ba		48890424		MOVQ AX, 0(SP)			
  0x4188be		e8ad980000		CALL runtime.printuint(SB)	
  0x4188c3		488d0538210500		LEAQ 0x52138(IP), AX		
  0x4188ca		48890424		MOVQ AX, 0(SP)			
  0x4188ce		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4188d7		e8649b0000		CALL runtime.printstring(SB)	
  0x4188dc		8b442430		MOVL 0x30(SP), AX		
  0x4188e0		48890424		MOVQ AX, 0(SP)			
  0x4188e4		e887980000		CALL runtime.printuint(SB)	
  0x4188e9		e8a2940000		CALL runtime.printnl(SB)	
  0x4188ee		e88d920000		CALL runtime.printunlock(SB)	
		throw("MSpan_Sweep: bad span state")
  0x4188f3		488d05e5330500		LEAQ 0x533e5(IP), AX	
  0x4188fa		48890424		MOVQ AX, 0(SP)		
  0x4188fe		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x418907		e8c4880000		CALL runtime.throw(SB)	
  0x41890c		0f0b			UD2			
		throw("MSpan_Sweep: m is not locked")
  0x41890e		488d05c1360500		LEAQ 0x536c1(IP), AX	
  0x418915		48890424		MOVQ AX, 0(SP)		
  0x418919		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x418922		e8a9880000		CALL runtime.throw(SB)	
  0x418927		0f0b			UD2			
func (s *mspan) sweep(preserve bool) bool {
  0x418929		e842bc0200		CALL runtime.morestack_noctxt(SB)	
  0x41892e		e98df6ffff		JMP runtime.(*mspan).sweep(SB)		

TEXT runtime.deductSweepCredit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
func deductSweepCredit(spanBytes uintptr, callerSweepPages uintptr) {
  0x418940		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418949		483b6110		CMPQ 0x10(CX), SP	
  0x41894d		0f862f010000		JBE 0x418a82		
  0x418953		4883ec20		SUBQ $0x20, SP		
  0x418957		48896c2418		MOVQ BP, 0x18(SP)	
  0x41895c		488d6c2418		LEAQ 0x18(SP), BP	
	if mheap_.sweepPagesPerByte == 0 {
  0x418961		f20f10050f4a0900	MOVSD_XMM runtime.mheap_+4312(SB), X0	
  0x418969		0f57c9			XORPS X1, X1				
  0x41896c		660f2ec1		UCOMISD X1, X0				
  0x418970		7506			JNE 0x418978				
  0x418972		0f8b00010000		JNP 0x418a78				
	if trace.enabled {
  0x418978		0fb60551ae0900		MOVZX runtime.trace+16(SB), AX	
  0x41897f		84c0			TESTL AL, AL			
  0x418981		0f85e4000000		JNE 0x418a6b			
	sweptBasis := atomic.Load64(&mheap_.pagesSweptBasis)
  0x418987		eb4b			JMP 0x4189d4		
  0x418989		4889c8			MOVQ CX, AX		
  0x41898c		488b4c2410		MOVQ 0x10(SP), CX	
  0x418991		488b542428		MOVQ 0x28(SP), DX	
  0x418996		488b5c2430		MOVQ 0x30(SP), BX	
  0x41899b		0f57c9			XORPS X1, X1		
	for pagesTarget > int64(atomic.Load64(&mheap_.pagesSwept)-sweptBasis) {
  0x41899e		488b35bb490900		MOVQ runtime.mheap_+4288(SB), SI	
  0x4189a5		4829c6			SUBQ AX, SI				
  0x4189a8		4839f1			CMPQ SI, CX				
  0x4189ab		0f8e83000000		JLE 0x418a34				
		if gosweepone() == ^uintptr(0) {
  0x4189b1		e8baf4ffff		CALL runtime.gosweepone(SB)	
  0x4189b6		488b0424		MOVQ 0(SP), AX			
  0x4189ba		4883f8ff		CMPQ $-0x1, AX			
  0x4189be		7469			JE 0x418a29			
		if atomic.Load64(&mheap_.pagesSweptBasis) != sweptBasis {
  0x4189c0		488b05a1490900		MOVQ runtime.mheap_+4296(SB), AX	
  0x4189c7		488b4c2408		MOVQ 0x8(SP), CX			
  0x4189cc		4839c8			CMPQ CX, AX				
  0x4189cf		74b8			JE 0x418989				
  0x4189d1		0f57c9			XORPS X1, X1				
	sweptBasis := atomic.Load64(&mheap_.pagesSweptBasis)
  0x4189d4		488b058d490900		MOVQ runtime.mheap_+4296(SB), AX	
	newHeapLive := uintptr(atomic.Load64(&memstats.heap_live)-mheap_.sweepHeapLiveBasis) + spanBytes
  0x4189db		488b0d5ed40a00		MOVQ runtime.memstats+5952(SB), CX	
  0x4189e2		488b1587490900		MOVQ runtime.mheap_+4304(SB), DX	
  0x4189e9		4829d1			SUBQ DX, CX				
  0x4189ec		488b542428		MOVQ 0x28(SP), DX			
  0x4189f1		4801d1			ADDQ DX, CX				
	pagesTarget := int64(mheap_.sweepPagesPerByte*float64(newHeapLive)) - int64(callerSweepPages)
  0x4189f4		f20f10057c490900	MOVSD_XMM runtime.mheap_+4312(SB), X0	
  0x4189fc		4885c9			TESTQ CX, CX				
  0x4189ff		7c4f			JL 0x418a50				
  0x418a01		0f57d2			XORPS X2, X2				
  0x418a04		f2480f2ad1		CVTSI2SDQ CX, X2			
  0x418a09		4889442408		MOVQ AX, 0x8(SP)			
  0x418a0e		f20f59c2		MULSD X2, X0				
  0x418a12		f2480f2cc8		CVTTSD2SIQ X0, CX			
  0x418a17		488b5c2430		MOVQ 0x30(SP), BX			
  0x418a1c		4829d9			SUBQ BX, CX				
  0x418a1f		48894c2410		MOVQ CX, 0x10(SP)			
	for pagesTarget > int64(atomic.Load64(&mheap_.pagesSwept)-sweptBasis) {
  0x418a24		e975ffffff		JMP 0x41899e		
			mheap_.sweepPagesPerByte = 0
  0x418a29		0f57c0			XORPS X0, X0				
  0x418a2c		f20f110544490900	MOVSD_XMM X0, runtime.mheap_+4312(SB)	
	if trace.enabled {
  0x418a34		0fb60595ad0900		MOVZX runtime.trace+16(SB), AX	
  0x418a3b		84c0			TESTL AL, AL			
  0x418a3d		750a			JNE 0x418a49			
  0x418a3f		488b6c2418		MOVQ 0x18(SP), BP		
  0x418a44		4883c420		ADDQ $0x20, SP			
  0x418a48		c3			RET				
		traceGCSweepDone()
  0x418a49		e8621c0200		CALL runtime.traceGCSweepDone(SB)	
  0x418a4e		ebef			JMP 0x418a3f				
  0x418a50		4889cb			MOVQ CX, BX				
	pagesTarget := int64(mheap_.sweepPagesPerByte*float64(newHeapLive)) - int64(callerSweepPages)
  0x418a53		4883e101		ANDQ $0x1, CX		
  0x418a57		48d1eb			SHRQ $0x1, BX		
  0x418a5a		4809cb			ORQ CX, BX		
  0x418a5d		0f57d2			XORPS X2, X2		
  0x418a60		f2480f2ad3		CVTSI2SDQ BX, X2	
  0x418a65		f20f58d2		ADDSD X2, X2		
  0x418a69		eb9e			JMP 0x418a09		
		traceGCSweepStart()
  0x418a6b		e8101b0200		CALL runtime.traceGCSweepStart(SB)	
  0x418a70		0f57c9			XORPS X1, X1				
  0x418a73		e95cffffff		JMP 0x4189d4				
		return
  0x418a78		488b6c2418		MOVQ 0x18(SP), BP	
  0x418a7d		4883c420		ADDQ $0x20, SP		
  0x418a81		c3			RET			
func deductSweepCredit(spanBytes uintptr, callerSweepPages uintptr) {
  0x418a82		e8e9ba0200		CALL runtime.morestack_noctxt(SB)	
  0x418a87		e9b4feffff		JMP runtime.deductSweepCredit(SB)	

TEXT runtime.(*gcSweepBuf).push(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweepbuf.go
func (b *gcSweepBuf) push(s *mspan) {
  0x418a90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418a99		483b6110		CMPQ 0x10(CX), SP	
  0x418a9d		0f8697010000		JBE 0x418c3a		
  0x418aa3		4883ec58		SUBQ $0x58, SP		
  0x418aa7		48896c2450		MOVQ BP, 0x50(SP)	
  0x418aac		488d6c2450		LEAQ 0x50(SP), BP	
	cursor := uintptr(atomic.Xadd(&b.index, +1) - 1)
  0x418ab1		b801000000		MOVL $0x1, AX		
  0x418ab6		488b4c2460		MOVQ 0x60(SP), CX	
  0x418abb		f00fc14120		LOCK XADDL AX, 0x20(CX)	
  0x418ac0		89442424		MOVL AX, 0x24(SP)	
	spineLen := atomic.Loaduintptr(&b.spineLen)
  0x418ac4		488b5110		MOVQ 0x10(CX), DX	
func (b *gcSweepBuf) push(s *mspan) {
  0x418ac8		89c3			MOVL AX, BX		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x418aca		48c1e809		SHRQ $0x9, AX		
  0x418ace		4889442438		MOVQ AX, 0x38(SP)	
retry:
  0x418ad3		eb1c			JMP 0x418af1		
			unlock(&b.spineLock)
  0x418ad5		48890424		MOVQ AX, 0(SP)		
  0x418ad9		e8e20bffff		CALL runtime.unlock(SB)	
  0x418ade		488b442438		MOVQ 0x38(SP), AX	
  0x418ae3		488b4c2460		MOVQ 0x60(SP), CX	
  0x418ae8		8b5c2424		MOVL 0x24(SP), BX	
  0x418aec		488b542430		MOVQ 0x30(SP), DX	
	if top < spineLen {
  0x418af1		4839d0			CMPQ DX, AX		
  0x418af4		0f8230010000		JB 0x418c2a		
		lock(&b.spineLock)
  0x418afa		48890c24		MOVQ CX, 0(SP)		
  0x418afe		e81d0affff		CALL runtime.lock(SB)	
  0x418b03		488b442460		MOVQ 0x60(SP), AX	
		spineLen = atomic.Loaduintptr(&b.spineLen)
  0x418b08		488b4810		MOVQ 0x10(AX), CX	
  0x418b0c		48894c2430		MOVQ CX, 0x30(SP)	
  0x418b11		488b542438		MOVQ 0x38(SP), DX	
		if top < spineLen {
  0x418b16		4839ca			CMPQ CX, DX		
  0x418b19		72ba			JB 0x418ad5		
		if spineLen == b.spineCap {
  0x418b1b		488b5818		MOVQ 0x18(AX), BX	
  0x418b1f		4839d9			CMPQ BX, CX		
  0x418b22		755c			JNE 0x418b80		
			newCap := b.spineCap * 2
  0x418b24		48d1e3			SHLQ $0x1, BX		
			if newCap == 0 {
  0x418b27		48f7c3ffffffff		TESTQ $-0x1, BX		
  0x418b2e		7505			JNE 0x418b35		
  0x418b30		bb00010000		MOVL $0x100, BX		
			newSpine := persistentalloc(newCap*sys.PtrSize, sys.CacheLineSize, &memstats.gc_sys)
  0x418b35		48895c2428		MOVQ BX, 0x28(SP)			
  0x418b3a		48c1e303		SHLQ $0x3, BX				
  0x418b3e		48891c24		MOVQ BX, 0(SP)				
  0x418b42		48c744240840000000	MOVQ $0x40, 0x8(SP)			
  0x418b4b		488d0d46bc0a00		LEAQ runtime.memstats+152(SB), CX	
  0x418b52		48894c2410		MOVQ CX, 0x10(SP)			
  0x418b57		e84429ffff		CALL runtime.persistentalloc(SB)	
  0x418b5c		488b442418		MOVQ 0x18(SP), AX			
  0x418b61		488b4c2460		MOVQ 0x60(SP), CX			
			if b.spineCap != 0 {
  0x418b66		488b5118		MOVQ 0x18(CX), DX	
  0x418b6a		4885d2			TESTQ DX, DX		
  0x418b6d		0f8588000000		JNE 0x418bfb		
			atomic.StorepNoWB(unsafe.Pointer(&b.spine), newSpine)
  0x418b73		48874108		XCHGQ AX, 0x8(CX)	
  0x418b77		488b442428		MOVQ 0x28(SP), AX	
			b.spineCap = newCap
  0x418b7c		48894118		MOVQ AX, 0x18(CX)	
		block = (*gcSweepBlock)(persistentalloc(unsafe.Sizeof(gcSweepBlock{}), sys.CacheLineSize, &memstats.gc_sys))
  0x418b80		48c7042400100000	MOVQ $0x1000, 0(SP)			
  0x418b88		48c744240840000000	MOVQ $0x40, 0x8(SP)			
  0x418b91		488d0500bc0a00		LEAQ runtime.memstats+152(SB), AX	
  0x418b98		4889442410		MOVQ AX, 0x10(SP)			
  0x418b9d		e8fe28ffff		CALL runtime.persistentalloc(SB)	
  0x418ba2		488b442418		MOVQ 0x18(SP), AX			
  0x418ba7		4889442448		MOVQ AX, 0x48(SP)			
  0x418bac		488b4c2438		MOVQ 0x38(SP), CX			
		blockp := add(b.spine, sys.PtrSize*top)
  0x418bb1		48c1e103		SHLQ $0x3, CX		
  0x418bb5		488b542460		MOVQ 0x60(SP), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x418bba		48034a08		ADDQ 0x8(DX), CX	
		atomic.StorepNoWB(blockp, unsafe.Pointer(block))
  0x418bbe		488701			XCHGQ AX, 0(CX)		
  0x418bc1		488b442430		MOVQ 0x30(SP), AX	
		atomic.Storeuintptr(&b.spineLen, spineLen+1)
  0x418bc6		48ffc0			INCQ AX			
  0x418bc9		48874210		XCHGQ AX, 0x10(DX)	
		unlock(&b.spineLock)
  0x418bcd		48891424		MOVQ DX, 0(SP)		
  0x418bd1		e8ea0affff		CALL runtime.unlock(SB)	
  0x418bd6		488b442448		MOVQ 0x48(SP), AX	
	block.spans[bottom] = s
  0x418bdb		8400			TESTB AL, 0(AX)		
  0x418bdd		8b4c2424		MOVL 0x24(SP), CX	
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x418be1		4881e1ff010000		ANDQ $0x1ff, CX		
  0x418be8		488b542468		MOVQ 0x68(SP), DX	
	block.spans[bottom] = s
  0x418bed		488914c8		MOVQ DX, 0(AX)(CX*8)	
}
  0x418bf1		488b6c2450		MOVQ 0x50(SP), BP	
  0x418bf6		4883c458		ADDQ $0x58, SP		
  0x418bfa		c3			RET			
  0x418bfb		4889442440		MOVQ AX, 0x40(SP)	
				memmove(newSpine, b.spine, b.spineCap*sys.PtrSize)
  0x418c00		488b5908		MOVQ 0x8(CX), BX		
  0x418c04		48c1e203		SHLQ $0x3, DX			
  0x418c08		4889542410		MOVQ DX, 0x10(SP)		
  0x418c0d		48890424		MOVQ AX, 0(SP)			
  0x418c11		48895c2408		MOVQ BX, 0x8(SP)		
  0x418c16		e8e5e40200		CALL runtime.memmove(SB)	
  0x418c1b		488b442440		MOVQ 0x40(SP), AX		
  0x418c20		488b4c2460		MOVQ 0x60(SP), CX		
  0x418c25		e949ffffff		JMP 0x418b73			
		spine := atomic.Loadp(unsafe.Pointer(&b.spine))
  0x418c2a		488b4908		MOVQ 0x8(CX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x418c2e		488d0cc1		LEAQ 0(CX)(AX*8), CX	
		block = (*gcSweepBlock)(atomic.Loadp(blockp))
  0x418c32		488b09			MOVQ 0(CX), CX		
  0x418c35		4889c8			MOVQ CX, AX		
  0x418c38		eba1			JMP 0x418bdb		
func (b *gcSweepBuf) push(s *mspan) {
  0x418c3a		e831b90200		CALL runtime.morestack_noctxt(SB)	
  0x418c3f		e94cfeffff		JMP runtime.(*gcSweepBuf).push(SB)	

TEXT runtime.(*gcSweepBuf).block(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweepbuf.go
func (b *gcSweepBuf) block(i int) []*mspan {
  0x418c50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418c59		483b6110		CMPQ 0x10(CX), SP	
  0x418c5d		0f86b7000000		JBE 0x418d1a		
  0x418c63		4883ec18		SUBQ $0x18, SP		
  0x418c67		48896c2410		MOVQ BP, 0x10(SP)	
  0x418c6c		488d6c2410		LEAQ 0x10(SP), BP	
  0x418c71		488b442428		MOVQ 0x28(SP), AX	
	if i < 0 || uintptr(i) >= atomic.Loaduintptr(&b.spineLen) {
  0x418c76		4885c0			TESTQ AX, AX		
  0x418c79		0f8c80000000		JL 0x418cff		
  0x418c7f		488b4c2420		MOVQ 0x20(SP), CX	
  0x418c84		488b5110		MOVQ 0x10(CX), DX	
  0x418c88		4839d0			CMPQ DX, AX		
  0x418c8b		7372			JAE 0x418cff		
	spine := atomic.Loadp(unsafe.Pointer(&b.spine))
  0x418c8d		488b5108		MOVQ 0x8(CX), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x418c91		488d14c2		LEAQ 0(DX)(AX*8), DX	
	block := (*gcSweepBlock)(atomic.Loadp(blockp))
  0x418c95		488b12			MOVQ 0(DX), DX		
	cursor := uintptr(atomic.Load(&b.index))
  0x418c98		8b4920			MOVL 0x20(CX), CX	
  0x418c9b		89c9			MOVL CX, CX		
  0x418c9d		4889cb			MOVQ CX, BX		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x418ca0		48c1e909		SHRQ $0x9, CX		
	if uintptr(i) < top {
  0x418ca4		4839c8			CMPQ CX, AX		
  0x418ca7		7341			JAE 0x418cea		
		spans = block.spans[:]
  0x418ca9		8402			TESTB AL, 0(DX)		
  0x418cab		b800020000		MOVL $0x200, AX		
  0x418cb0		eb03			JMP 0x418cb5		
  0x418cb2		4889c8			MOVQ CX, AX		
	for len(spans) > 0 && spans[len(spans)-1] == nil {
  0x418cb5		4885c0			TESTQ AX, AX		
  0x418cb8		7e13			JLE 0x418ccd		
  0x418cba		488d48ff		LEAQ -0x1(AX), CX	
  0x418cbe		4839c1			CMPQ AX, CX		
  0x418cc1		7335			JAE 0x418cf8		
  0x418cc3		488b5cc2f8		MOVQ -0x8(DX)(AX*8), BX	
  0x418cc8		4885db			TESTQ BX, BX		
  0x418ccb		74e5			JE 0x418cb2		
	return spans
  0x418ccd		4889542430		MOVQ DX, 0x30(SP)	
  0x418cd2		4889442438		MOVQ AX, 0x38(SP)	
  0x418cd7		48c744244000020000	MOVQ $0x200, 0x40(SP)	
  0x418ce0		488b6c2410		MOVQ 0x10(SP), BP	
  0x418ce5		4883c418		ADDQ $0x18, SP		
  0x418ce9		c3			RET			
		spans = block.spans[:bottom]
  0x418cea		8402			TESTB AL, 0(DX)		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x418cec		4881e3ff010000		ANDQ $0x1ff, BX		
  0x418cf3		4889d8			MOVQ BX, AX		
		spans = block.spans[:bottom]
  0x418cf6		ebbd			JMP 0x418cb5		
	for len(spans) > 0 && spans[len(spans)-1] == nil {
  0x418cf8		e8436d0000		CALL runtime.panicindex(SB)	
  0x418cfd		0f0b			UD2				
		throw("block index out of range")
  0x418cff		488d05702b0500		LEAQ 0x52b70(IP), AX	
  0x418d06		48890424		MOVQ AX, 0(SP)		
  0x418d0a		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x418d13		e8b8840000		CALL runtime.throw(SB)	
  0x418d18		0f0b			UD2			
func (b *gcSweepBuf) block(i int) []*mspan {
  0x418d1a		e851b80200		CALL runtime.morestack_noctxt(SB)	
  0x418d1f		e92cffffff		JMP runtime.(*gcSweepBuf).block(SB)	

TEXT runtime.init.1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func init() {
  0x418d30		c3			RET			

TEXT runtime.(*gcWork).init(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (w *gcWork) init() {
  0x418d40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418d49		483b6110		CMPQ 0x10(CX), SP	
  0x418d4d		764b			JBE 0x418d9a		
  0x418d4f		4883ec10		SUBQ $0x10, SP		
  0x418d53		48896c2408		MOVQ BP, 0x8(SP)	
  0x418d58		488d6c2408		LEAQ 0x8(SP), BP	
	w.wbuf1 = getempty()
  0x418d5d		e87e070000		CALL runtime.getempty(SB)	
  0x418d62		488b0424		MOVQ 0(SP), AX			
  0x418d66		488b4c2418		MOVQ 0x18(SP), CX		
  0x418d6b		488901			MOVQ AX, 0(CX)			
	wbuf2 := trygetfull()
  0x418d6e		e83d0a0000		CALL runtime.trygetfull(SB)	
  0x418d73		488b0424		MOVQ 0(SP), AX			
	if wbuf2 == nil {
  0x418d77		4885c0			TESTQ AX, AX		
  0x418d7a		7413			JE 0x418d8f		
  0x418d7c		488b4c2418		MOVQ 0x18(SP), CX	
	w.wbuf2 = wbuf2
  0x418d81		48894108		MOVQ AX, 0x8(CX)	
}
  0x418d85		488b6c2408		MOVQ 0x8(SP), BP	
  0x418d8a		4883c410		ADDQ $0x10, SP		
  0x418d8e		c3			RET			
		wbuf2 = getempty()
  0x418d8f		e84c070000		CALL runtime.getempty(SB)	
  0x418d94		488b0424		MOVQ 0(SP), AX			
  0x418d98		ebe2			JMP 0x418d7c			
func (w *gcWork) init() {
  0x418d9a		e8d1b70200		CALL runtime.morestack_noctxt(SB)	
  0x418d9f		eb9f			JMP runtime.(*gcWork).init(SB)		

TEXT runtime.(*gcWork).put(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (w *gcWork) put(obj uintptr) {
  0x418db0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418db9		483b6110		CMPQ 0x10(CX), SP	
  0x418dbd		0f86db000000		JBE 0x418e9e		
  0x418dc3		4883ec18		SUBQ $0x18, SP		
  0x418dc7		48896c2410		MOVQ BP, 0x10(SP)	
  0x418dcc		488d6c2410		LEAQ 0x10(SP), BP	
  0x418dd1		488b442420		MOVQ 0x20(SP), AX	
	wbuf := w.wbuf1
  0x418dd6		488b08			MOVQ 0(AX), CX		
	if wbuf == nil {
  0x418dd9		4885c9			TESTQ CX, CX		
  0x418ddc		0f849d000000		JE 0x418e7f		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x418de2		488b5110		MOVQ 0x10(CX), DX	
  0x418de6		4881fafd000000		CMPQ $0xfd, DX		
  0x418ded		0f8588000000		JNE 0x418e7b		
		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
  0x418df3		488b5008		MOVQ 0x8(AX), DX	
  0x418df7		488910			MOVQ DX, 0(AX)		
  0x418dfa		48894808		MOVQ CX, 0x8(AX)	
		wbuf = w.wbuf1
  0x418dfe		488b08			MOVQ 0(AX), CX		
		if wbuf.nobj == len(wbuf.obj) {
  0x418e01		488b5110		MOVQ 0x10(CX), DX	
  0x418e05		4881fafd000000		CMPQ $0xfd, DX		
  0x418e0c		0f94c2			SETE DL			
  0x418e0f		7445			JE 0x418e56		
	wbuf.obj[wbuf.nobj] = obj
  0x418e11		488b4110		MOVQ 0x10(CX), AX	
  0x418e15		483dfd000000		CMPQ $0xfd, AX		
  0x418e1b		737a			JAE 0x418e97		
  0x418e1d		488b5c2428		MOVQ 0x28(SP), BX	
  0x418e22		48895cc118		MOVQ BX, 0x18(CX)(AX*8)	
	wbuf.nobj++
  0x418e27		48ff4110		INCQ 0x10(CX)		
	if flushed && gcphase == _GCmark {
  0x418e2b		84d2			TESTL DL, DL			
  0x418e2d		740b			JE 0x418e3a			
  0x418e2f		8b05a7aa0a00		MOVL runtime.gcphase(SB), AX	
  0x418e35		83f801			CMPL $0x1, AX			
  0x418e38		740a			JE 0x418e44			
  0x418e3a		488b6c2410		MOVQ 0x10(SP), BP		
  0x418e3f		4883c418		ADDQ $0x18, SP			
  0x418e43		c3			RET				
		gcController.enlistWorker()
  0x418e44		488d05d5ad0a00		LEAQ runtime.gcController(SB), AX			
  0x418e4b		48890424		MOVQ AX, 0(SP)						
  0x418e4f		e82c7affff		CALL runtime.(*gcControllerState).enlistWorker(SB)	
  0x418e54		ebe4			JMP 0x418e3a						
  0x418e56		8854240f		MOVB DL, 0xf(SP)					
			putfull(wbuf)
  0x418e5a		48890c24		MOVQ CX, 0(SP)			
  0x418e5e		e8ed080000		CALL runtime.putfull(SB)	
			wbuf = getempty()
  0x418e63		e878060000		CALL runtime.getempty(SB)	
  0x418e68		488b0c24		MOVQ 0(SP), CX			
  0x418e6c		488b442420		MOVQ 0x20(SP), AX		
			w.wbuf1 = wbuf
  0x418e71		488908			MOVQ CX, 0(AX)		
  0x418e74		0fb654240f		MOVZX 0xf(SP), DX	
			flushed = true
  0x418e79		eb96			JMP 0x418e11		
  0x418e7b		31d2			XORL DX, DX		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x418e7d		eb92			JMP 0x418e11		
		w.init()
  0x418e7f		48890424		MOVQ AX, 0(SP)			
  0x418e83		e8b8feffff		CALL runtime.(*gcWork).init(SB)	
  0x418e88		488b442420		MOVQ 0x20(SP), AX		
		wbuf = w.wbuf1
  0x418e8d		488b08			MOVQ 0(AX), CX		
  0x418e90		31d2			XORL DX, DX		
  0x418e92		e97affffff		JMP 0x418e11		
	wbuf.obj[wbuf.nobj] = obj
  0x418e97		e8a46b0000		CALL runtime.panicindex(SB)	
  0x418e9c		0f0b			UD2				
func (w *gcWork) put(obj uintptr) {
  0x418e9e		e8cdb60200		CALL runtime.morestack_noctxt(SB)	
  0x418ea3		e908ffffff		JMP runtime.(*gcWork).put(SB)		

TEXT runtime.(*gcWork).putBatch(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (w *gcWork) putBatch(obj []uintptr) {
  0x418eb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418eb9		483b6110		CMPQ 0x10(CX), SP	
  0x418ebd		0f86c4010000		JBE 0x419087		
  0x418ec3		4883ec40		SUBQ $0x40, SP		
  0x418ec7		48896c2438		MOVQ BP, 0x38(SP)	
  0x418ecc		488d6c2438		LEAQ 0x38(SP), BP	
  0x418ed1		488b442458		MOVQ 0x58(SP), AX	
	if len(obj) == 0 {
  0x418ed6		4885c0			TESTQ AX, AX		
  0x418ed9		0f8490010000		JE 0x41906f		
  0x418edf		488b4c2448		MOVQ 0x48(SP), CX	
	wbuf := w.wbuf1
  0x418ee4		488b11			MOVQ 0(CX), DX		
	if wbuf == nil {
  0x418ee7		4885d2			TESTQ DX, DX		
  0x418eea		0f8464010000		JE 0x419054		
  0x418ef0		488b5c2460		MOVQ 0x60(SP), BX	
  0x418ef5		488b742450		MOVQ 0x50(SP), SI	
  0x418efa		31ff			XORL DI, DI		
	for len(obj) > 0 {
  0x418efc		e906010000		JMP 0x419007		
			putfull(wbuf)
  0x418f01		48891424		MOVQ DX, 0(SP)			
  0x418f05		e846080000		CALL runtime.putfull(SB)	
			w.wbuf1, w.wbuf2 = w.wbuf2, getempty()
  0x418f0a		e8d1050000		CALL runtime.getempty(SB)	
  0x418f0f		488b4c2448		MOVQ 0x48(SP), CX		
  0x418f14		488b4108		MOVQ 0x8(CX), AX		
  0x418f18		488b1424		MOVQ 0(SP), DX			
  0x418f1c		488901			MOVQ AX, 0(CX)			
  0x418f1f		48895108		MOVQ DX, 0x8(CX)		
			wbuf = w.wbuf1
  0x418f23		488b11			MOVQ 0(CX), DX		
  0x418f26		488b442458		MOVQ 0x58(SP), AX	
  0x418f2b		488b5c2460		MOVQ 0x60(SP), BX	
  0x418f30		488b742430		MOVQ 0x30(SP), SI	
  0x418f35		bf01000000		MOVL $0x1, DI		
		for wbuf.nobj == len(wbuf.obj) {
  0x418f3a		4c8b4210		MOVQ 0x10(DX), R8	
  0x418f3e		4981f8fd000000		CMPQ $0xfd, R8		
  0x418f45		74ba			JE 0x418f01		
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x418f47		4c8d4a18		LEAQ 0x18(DX), R9	
  0x418f4b		418401			TESTB AL, 0(R9)		
		for wbuf.nobj == len(wbuf.obj) {
  0x418f4e		4981f8fd000000		CMPQ $0xfd, R8		
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x418f55		0f8725010000		JA 0x419080			
  0x418f5b		4889542428		MOVQ DX, 0x28(SP)		
  0x418f60		40887c241f		MOVB DI, 0x1f(SP)		
  0x418f65		4d8d8803ffffff		LEAQ 0xffffff03(R8), R9		
  0x418f6c		49c1e003		SHLQ $0x3, R8			
  0x418f70		49f7d9			NEGQ R9				
  0x418f73		4d89ca			MOVQ R9, R10			
  0x418f76		49f7d9			NEGQ R9				
  0x418f79		49c1f93f		SARQ $0x3f, R9			
  0x418f7d		4d21c8			ANDQ R9, R8			
  0x418f80		4e8d440218		LEAQ 0x18(DX)(R8*1), R8		
  0x418f85		4939c2			CMPQ AX, R10			
  0x418f88		0f8e92000000		JLE 0x419020			
  0x418f8e		4889442420		MOVQ AX, 0x20(SP)		
  0x418f93		4c890424		MOVQ R8, 0(SP)			
  0x418f97		4889742408		MOVQ SI, 0x8(SP)		
  0x418f9c		48c1e003		SHLQ $0x3, AX			
  0x418fa0		4889442410		MOVQ AX, 0x10(SP)		
  0x418fa5		e856e10200		CALL runtime.memmove(SB)	
  0x418faa		488b442428		MOVQ 0x28(SP), AX		
		wbuf.nobj += n
  0x418faf		488b4810		MOVQ 0x10(AX), CX	
  0x418fb3		488b542420		MOVQ 0x20(SP), DX	
  0x418fb8		4801d1			ADDQ DX, CX		
  0x418fbb		48894810		MOVQ CX, 0x10(AX)	
  0x418fbf		488b4c2458		MOVQ 0x58(SP), CX	
		obj = obj[n:]
  0x418fc4		4839ca			CMPQ CX, DX		
  0x418fc7		0f87ac000000		JA 0x419079		
  0x418fcd		4829d1			SUBQ DX, CX		
  0x418fd0		488b5c2460		MOVQ 0x60(SP), BX	
  0x418fd5		4829d3			SUBQ DX, BX		
  0x418fd8		48c1e203		SHLQ $0x3, DX		
  0x418fdc		4989d8			MOVQ BX, R8		
  0x418fdf		48f7db			NEGQ BX			
  0x418fe2		48c1fb3f		SARQ $0x3f, BX		
  0x418fe6		4821da			ANDQ BX, DX		
  0x418fe9		4c8b4c2430		MOVQ 0x30(SP), R9	
  0x418fee		498d3411		LEAQ 0(R9)(DX*1), SI	
  0x418ff2		4c89c3			MOVQ R8, BX		
  0x418ff5		4889c8			MOVQ CX, AX		
  0x418ff8		488b542428		MOVQ 0x28(SP), DX	
  0x418ffd		0fb67c241f		MOVZX 0x1f(SP), DI	
  0x419002		488b4c2448		MOVQ 0x48(SP), CX	
	for len(obj) > 0 {
  0x419007		4885c0			TESTQ AX, AX		
  0x41900a		7e1c			JLE 0x419028		
  0x41900c		48895c2460		MOVQ BX, 0x60(SP)	
  0x419011		4889442458		MOVQ AX, 0x58(SP)	
  0x419016		4889742430		MOVQ SI, 0x30(SP)	
		for wbuf.nobj == len(wbuf.obj) {
  0x41901b		e91affffff		JMP 0x418f3a		
  0x419020		4c89d0			MOVQ R10, AX		
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x419023		e966ffffff		JMP 0x418f8e		
	if flushed && gcphase == _GCmark {
  0x419028		4084ff			TESTL DI, DI			
  0x41902b		740b			JE 0x419038			
  0x41902d		8b05a9a80a00		MOVL runtime.gcphase(SB), AX	
  0x419033		83f801			CMPL $0x1, AX			
  0x419036		740a			JE 0x419042			
  0x419038		488b6c2438		MOVQ 0x38(SP), BP		
  0x41903d		4883c440		ADDQ $0x40, SP			
  0x419041		c3			RET				
		gcController.enlistWorker()
  0x419042		488d05d7ab0a00		LEAQ runtime.gcController(SB), AX			
  0x419049		48890424		MOVQ AX, 0(SP)						
  0x41904d		e82e78ffff		CALL runtime.(*gcControllerState).enlistWorker(SB)	
  0x419052		ebe4			JMP 0x419038						
		w.init()
  0x419054		48890c24		MOVQ CX, 0(SP)			
  0x419058		e8e3fcffff		CALL runtime.(*gcWork).init(SB)	
  0x41905d		488b4c2448		MOVQ 0x48(SP), CX		
		wbuf = w.wbuf1
  0x419062		488b11			MOVQ 0(CX), DX		
  0x419065		488b442458		MOVQ 0x58(SP), AX	
  0x41906a		e981feffff		JMP 0x418ef0		
		return
  0x41906f		488b6c2438		MOVQ 0x38(SP), BP	
  0x419074		4883c440		ADDQ $0x40, SP		
  0x419078		c3			RET			
		obj = obj[n:]
  0x419079		e8326a0000		CALL runtime.panicslice(SB)	
  0x41907e		0f0b			UD2				
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x419080		e82b6a0000		CALL runtime.panicslice(SB)	
  0x419085		0f0b			UD2				
func (w *gcWork) putBatch(obj []uintptr) {
  0x419087		e8e4b40200		CALL runtime.morestack_noctxt(SB)	
  0x41908c		e91ffeffff		JMP runtime.(*gcWork).putBatch(SB)	

TEXT runtime.(*gcWork).tryGet(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (w *gcWork) tryGet() uintptr {
  0x4190a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4190a9		483b6110		CMPQ 0x10(CX), SP	
  0x4190ad		0f86d0000000		JBE 0x419183		
  0x4190b3		4883ec20		SUBQ $0x20, SP		
  0x4190b7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4190bc		488d6c2418		LEAQ 0x18(SP), BP	
  0x4190c1		488b442428		MOVQ 0x28(SP), AX	
	wbuf := w.wbuf1
  0x4190c6		488b08			MOVQ 0(AX), CX		
	if wbuf == nil {
  0x4190c9		4885c9			TESTQ CX, CX		
  0x4190cc		0f8494000000		JE 0x419166		
	if wbuf.nobj == 0 {
  0x4190d2		488b5110		MOVQ 0x10(CX), DX	
  0x4190d6		4885d2			TESTQ DX, DX		
  0x4190d9		751a			JNE 0x4190f5		
		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
  0x4190db		488b4808		MOVQ 0x8(AX), CX	
  0x4190df		488b10			MOVQ 0(AX), DX		
  0x4190e2		488908			MOVQ CX, 0(AX)		
  0x4190e5		48895008		MOVQ DX, 0x8(AX)	
		wbuf = w.wbuf1
  0x4190e9		488b08			MOVQ 0(AX), CX		
		if wbuf.nobj == 0 {
  0x4190ec		488b5110		MOVQ 0x10(CX), DX	
  0x4190f0		4885d2			TESTQ DX, DX		
  0x4190f3		7429			JE 0x41911e		
	wbuf.nobj--
  0x4190f5		488b4110		MOVQ 0x10(CX), AX	
  0x4190f9		488d50ff		LEAQ -0x1(AX), DX	
  0x4190fd		48895110		MOVQ DX, 0x10(CX)	
	return wbuf.obj[wbuf.nobj]
  0x419101		4881fafd000000		CMPQ $0xfd, DX		
  0x419108		7372			JAE 0x41917c		
  0x41910a		488b44c110		MOVQ 0x10(CX)(AX*8), AX	
  0x41910f		4889442430		MOVQ AX, 0x30(SP)	
  0x419114		488b6c2418		MOVQ 0x18(SP), BP	
  0x419119		4883c420		ADDQ $0x20, SP		
  0x41911d		c3			RET			
  0x41911e		48894c2410		MOVQ CX, 0x10(SP)	
			wbuf = trygetfull()
  0x419123		e888060000		CALL runtime.trygetfull(SB)	
  0x419128		488b0424		MOVQ 0(SP), AX			
			if wbuf == nil {
  0x41912c		4885c0			TESTQ AX, AX		
  0x41912f		7422			JE 0x419153		
  0x419131		4889442408		MOVQ AX, 0x8(SP)	
  0x419136		488b442410		MOVQ 0x10(SP), AX	
			putempty(owbuf)
  0x41913b		48890424		MOVQ AX, 0(SP)			
  0x41913f		e8ac050000		CALL runtime.putempty(SB)	
  0x419144		488b4c2408		MOVQ 0x8(SP), CX		
  0x419149		488b442428		MOVQ 0x28(SP), AX		
			w.wbuf1 = wbuf
  0x41914e		488908			MOVQ CX, 0(AX)		
  0x419151		eba2			JMP 0x4190f5		
				return 0
  0x419153		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x41915c		488b6c2418		MOVQ 0x18(SP), BP	
  0x419161		4883c420		ADDQ $0x20, SP		
  0x419165		c3			RET			
		w.init()
  0x419166		48890424		MOVQ AX, 0(SP)			
  0x41916a		e8d1fbffff		CALL runtime.(*gcWork).init(SB)	
  0x41916f		488b442428		MOVQ 0x28(SP), AX		
		wbuf = w.wbuf1
  0x419174		488b08			MOVQ 0(AX), CX		
  0x419177		e956ffffff		JMP 0x4190d2		
	return wbuf.obj[wbuf.nobj]
  0x41917c		e8bf680000		CALL runtime.panicindex(SB)	
  0x419181		0f0b			UD2				
func (w *gcWork) tryGet() uintptr {
  0x419183		e8e8b30200		CALL runtime.morestack_noctxt(SB)	
  0x419188		e913ffffff		JMP runtime.(*gcWork).tryGet(SB)	

TEXT runtime.(*gcWork).get(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (w *gcWork) get() uintptr {
  0x419190		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419199		483b6110		CMPQ 0x10(CX), SP	
  0x41919d		0f86d0000000		JBE 0x419273		
  0x4191a3		4883ec20		SUBQ $0x20, SP		
  0x4191a7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4191ac		488d6c2418		LEAQ 0x18(SP), BP	
  0x4191b1		488b442428		MOVQ 0x28(SP), AX	
	wbuf := w.wbuf1
  0x4191b6		488b08			MOVQ 0(AX), CX		
	if wbuf == nil {
  0x4191b9		4885c9			TESTQ CX, CX		
  0x4191bc		0f8494000000		JE 0x419256		
	if wbuf.nobj == 0 {
  0x4191c2		488b5110		MOVQ 0x10(CX), DX	
  0x4191c6		4885d2			TESTQ DX, DX		
  0x4191c9		751a			JNE 0x4191e5		
		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
  0x4191cb		488b4808		MOVQ 0x8(AX), CX	
  0x4191cf		488b10			MOVQ 0(AX), DX		
  0x4191d2		488908			MOVQ CX, 0(AX)		
  0x4191d5		48895008		MOVQ DX, 0x8(AX)	
		wbuf = w.wbuf1
  0x4191d9		488b08			MOVQ 0(AX), CX		
		if wbuf.nobj == 0 {
  0x4191dc		488b5110		MOVQ 0x10(CX), DX	
  0x4191e0		4885d2			TESTQ DX, DX		
  0x4191e3		7429			JE 0x41920e		
	wbuf.nobj--
  0x4191e5		488b4110		MOVQ 0x10(CX), AX	
  0x4191e9		488d50ff		LEAQ -0x1(AX), DX	
  0x4191ed		48895110		MOVQ DX, 0x10(CX)	
	return wbuf.obj[wbuf.nobj]
  0x4191f1		4881fafd000000		CMPQ $0xfd, DX		
  0x4191f8		7372			JAE 0x41926c		
  0x4191fa		488b44c110		MOVQ 0x10(CX)(AX*8), AX	
  0x4191ff		4889442430		MOVQ AX, 0x30(SP)	
  0x419204		488b6c2418		MOVQ 0x18(SP), BP	
  0x419209		4883c420		ADDQ $0x20, SP		
  0x41920d		c3			RET			
  0x41920e		48894c2410		MOVQ CX, 0x10(SP)	
			wbuf = getfull()
  0x419213		e808060000		CALL runtime.getfull(SB)	
  0x419218		488b0424		MOVQ 0(SP), AX			
			if wbuf == nil {
  0x41921c		4885c0			TESTQ AX, AX		
  0x41921f		7422			JE 0x419243		
  0x419221		4889442408		MOVQ AX, 0x8(SP)	
  0x419226		488b442410		MOVQ 0x10(SP), AX	
			putempty(owbuf)
  0x41922b		48890424		MOVQ AX, 0(SP)			
  0x41922f		e8bc040000		CALL runtime.putempty(SB)	
  0x419234		488b4c2408		MOVQ 0x8(SP), CX		
  0x419239		488b442428		MOVQ 0x28(SP), AX		
			w.wbuf1 = wbuf
  0x41923e		488908			MOVQ CX, 0(AX)		
  0x419241		eba2			JMP 0x4191e5		
				return 0
  0x419243		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x41924c		488b6c2418		MOVQ 0x18(SP), BP	
  0x419251		4883c420		ADDQ $0x20, SP		
  0x419255		c3			RET			
		w.init()
  0x419256		48890424		MOVQ AX, 0(SP)			
  0x41925a		e8e1faffff		CALL runtime.(*gcWork).init(SB)	
  0x41925f		488b442428		MOVQ 0x28(SP), AX		
		wbuf = w.wbuf1
  0x419264		488b08			MOVQ 0(AX), CX		
  0x419267		e956ffffff		JMP 0x4191c2		
	return wbuf.obj[wbuf.nobj]
  0x41926c		e8cf670000		CALL runtime.panicindex(SB)	
  0x419271		0f0b			UD2				
func (w *gcWork) get() uintptr {
  0x419273		e8f8b20200		CALL runtime.morestack_noctxt(SB)	
  0x419278		e913ffffff		JMP runtime.(*gcWork).get(SB)		

TEXT runtime.(*gcWork).dispose(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (w *gcWork) dispose() {
  0x419280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419289		483b6110		CMPQ 0x10(CX), SP	
  0x41928d		0f86bd000000		JBE 0x419350		
  0x419293		4883ec10		SUBQ $0x10, SP		
  0x419297		48896c2408		MOVQ BP, 0x8(SP)	
  0x41929c		488d6c2408		LEAQ 0x8(SP), BP	
  0x4192a1		488b442418		MOVQ 0x18(SP), AX	
	if wbuf := w.wbuf1; wbuf != nil {
  0x4192a6		488b08			MOVQ 0(AX), CX		
  0x4192a9		4885c9			TESTQ CX, CX		
  0x4192ac		7445			JE 0x4192f3		
		if wbuf.nobj == 0 {
  0x4192ae		488b5110		MOVQ 0x10(CX), DX	
  0x4192b2		4885d2			TESTQ DX, DX		
  0x4192b5		0f8587000000		JNE 0x419342		
			putempty(wbuf)
  0x4192bb		48890c24		MOVQ CX, 0(SP)			
  0x4192bf		e82c040000		CALL runtime.putempty(SB)	
  0x4192c4		488b442418		MOVQ 0x18(SP), AX		
		w.wbuf1 = nil
  0x4192c9		48c70000000000		MOVQ $0x0, 0(AX)	
		wbuf = w.wbuf2
  0x4192d0		488b4808		MOVQ 0x8(AX), CX	
		if wbuf.nobj == 0 {
  0x4192d4		488b5110		MOVQ 0x10(CX), DX	
  0x4192d8		4885d2			TESTQ DX, DX		
  0x4192db		755a			JNE 0x419337		
			putempty(wbuf)
  0x4192dd		48890c24		MOVQ CX, 0(SP)			
  0x4192e1		e80a040000		CALL runtime.putempty(SB)	
  0x4192e6		488b442418		MOVQ 0x18(SP), AX		
		w.wbuf2 = nil
  0x4192eb		48c7400800000000	MOVQ $0x0, 0x8(AX)	
	if w.bytesMarked != 0 {
  0x4192f3		488b4810		MOVQ 0x10(AX), CX	
  0x4192f7		4885c9			TESTQ CX, CX		
  0x4192fa		7414			JE 0x419310		
		atomic.Xadd64(&work.bytesMarked, int64(w.bytesMarked))
  0x4192fc		488d151deb0800		LEAQ runtime.work+128(SB), DX	
  0x419303		f0480fc10a		LOCK XADDQ CX, 0(DX)		
		w.bytesMarked = 0
  0x419308		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	if w.scanWork != 0 {
  0x419310		488b4818		MOVQ 0x18(AX), CX	
  0x419314		4885c9			TESTQ CX, CX		
  0x419317		7414			JE 0x41932d		
		atomic.Xaddint64(&gcController.scanWork, w.scanWork)
  0x419319		488d1500a90a00		LEAQ runtime.gcController(SB), DX	
  0x419320		f0480fc10a		LOCK XADDQ CX, 0(DX)			
		w.scanWork = 0
  0x419325		48c7401800000000	MOVQ $0x0, 0x18(AX)	
  0x41932d		488b6c2408		MOVQ 0x8(SP), BP	
  0x419332		4883c410		ADDQ $0x10, SP		
  0x419336		c3			RET			
			putfull(wbuf)
  0x419337		48890c24		MOVQ CX, 0(SP)			
  0x41933b		e810040000		CALL runtime.putfull(SB)	
  0x419340		eba4			JMP 0x4192e6			
			putfull(wbuf)
  0x419342		48890c24		MOVQ CX, 0(SP)			
  0x419346		e805040000		CALL runtime.putfull(SB)	
  0x41934b		e974ffffff		JMP 0x4192c4			
func (w *gcWork) dispose() {
  0x419350		e81bb20200		CALL runtime.morestack_noctxt(SB)	
  0x419355		e926ffffff		JMP runtime.(*gcWork).dispose(SB)	

TEXT runtime.(*gcWork).balance(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (w *gcWork) balance() {
  0x419360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419369		483b6110		CMPQ 0x10(CX), SP	
  0x41936d		0f86a0000000		JBE 0x419413		
  0x419373		4883ec18		SUBQ $0x18, SP		
  0x419377		48896c2410		MOVQ BP, 0x10(SP)	
  0x41937c		488d6c2410		LEAQ 0x10(SP), BP	
  0x419381		488b442420		MOVQ 0x20(SP), AX	
	if w.wbuf1 == nil {
  0x419386		488b08			MOVQ 0(AX), CX		
  0x419389		4885c9			TESTQ CX, CX		
  0x41938c		747b			JE 0x419409		
	if wbuf := w.wbuf2; wbuf.nobj != 0 {
  0x41938e		488b5008		MOVQ 0x8(AX), DX	
  0x419392		488b5a10		MOVQ 0x10(DX), BX	
  0x419396		4885db			TESTQ BX, BX		
  0x419399		7551			JNE 0x4193ec		
	} else if wbuf := w.wbuf1; wbuf.nobj > 4 {
  0x41939b		488b5110		MOVQ 0x10(CX), DX	
  0x41939f		4883fa04		CMPQ $0x4, DX		
  0x4193a3		7e3d			JLE 0x4193e2		
		w.wbuf1 = handoff(wbuf)
  0x4193a5		48890c24		MOVQ CX, 0(SP)			
  0x4193a9		e882070000		CALL runtime.handoff(SB)	
  0x4193ae		488b442408		MOVQ 0x8(SP), AX		
  0x4193b3		488b4c2420		MOVQ 0x20(SP), CX		
  0x4193b8		488901			MOVQ AX, 0(CX)			
	if gcphase == _GCmark {
  0x4193bb		8b051ba50a00		MOVL runtime.gcphase(SB), AX	
  0x4193c1		83f801			CMPL $0x1, AX			
  0x4193c4		740a			JE 0x4193d0			
  0x4193c6		488b6c2410		MOVQ 0x10(SP), BP		
  0x4193cb		4883c418		ADDQ $0x18, SP			
  0x4193cf		c3			RET				
		gcController.enlistWorker()
  0x4193d0		488d0549a80a00		LEAQ runtime.gcController(SB), AX			
  0x4193d7		48890424		MOVQ AX, 0(SP)						
  0x4193db		e8a074ffff		CALL runtime.(*gcControllerState).enlistWorker(SB)	
  0x4193e0		ebe4			JMP 0x4193c6						
		return
  0x4193e2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4193e7		4883c418		ADDQ $0x18, SP		
  0x4193eb		c3			RET			
		putfull(wbuf)
  0x4193ec		48891424		MOVQ DX, 0(SP)			
  0x4193f0		e85b030000		CALL runtime.putfull(SB)	
		w.wbuf2 = getempty()
  0x4193f5		e8e6000000		CALL runtime.getempty(SB)	
  0x4193fa		488b0424		MOVQ 0(SP), AX			
  0x4193fe		488b4c2420		MOVQ 0x20(SP), CX		
  0x419403		48894108		MOVQ AX, 0x8(CX)		
  0x419407		ebb2			JMP 0x4193bb			
		return
  0x419409		488b6c2410		MOVQ 0x10(SP), BP	
  0x41940e		4883c418		ADDQ $0x18, SP		
  0x419412		c3			RET			
func (w *gcWork) balance() {
  0x419413		e858b10200		CALL runtime.morestack_noctxt(SB)	
  0x419418		e943ffffff		JMP runtime.(*gcWork).balance(SB)	

TEXT runtime.(*workbuf).checknonempty(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (b *workbuf) checknonempty() {
  0x419420		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419429		483b6110		CMPQ 0x10(CX), SP	
  0x41942d		7641			JBE 0x419470		
  0x41942f		4883ec18		SUBQ $0x18, SP		
  0x419433		48896c2410		MOVQ BP, 0x10(SP)	
  0x419438		488d6c2410		LEAQ 0x10(SP), BP	
  0x41943d		488b442420		MOVQ 0x20(SP), AX	
	if b.nobj == 0 {
  0x419442		488b4010		MOVQ 0x10(AX), AX	
  0x419446		4885c0			TESTQ AX, AX		
  0x419449		740a			JE 0x419455		
  0x41944b		488b6c2410		MOVQ 0x10(SP), BP	
  0x419450		4883c418		ADDQ $0x18, SP		
  0x419454		c3			RET			
		throw("workbuf is empty")
  0x419455		488d0536170500		LEAQ 0x51736(IP), AX	
  0x41945c		48890424		MOVQ AX, 0(SP)		
  0x419460		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x419469		e8627d0000		CALL runtime.throw(SB)	
  0x41946e		0f0b			UD2			
func (b *workbuf) checknonempty() {
  0x419470		e8fbb00200		CALL runtime.morestack_noctxt(SB)		
  0x419475		eba9			JMP runtime.(*workbuf).checknonempty(SB)	

TEXT runtime.(*workbuf).checkempty(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func (b *workbuf) checkempty() {
  0x419480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419489		483b6110		CMPQ 0x10(CX), SP	
  0x41948d		7641			JBE 0x4194d0		
  0x41948f		4883ec18		SUBQ $0x18, SP		
  0x419493		48896c2410		MOVQ BP, 0x10(SP)	
  0x419498		488d6c2410		LEAQ 0x10(SP), BP	
  0x41949d		488b442420		MOVQ 0x20(SP), AX	
	if b.nobj != 0 {
  0x4194a2		488b4010		MOVQ 0x10(AX), AX	
  0x4194a6		4885c0			TESTQ AX, AX		
  0x4194a9		750a			JNE 0x4194b5		
  0x4194ab		488b6c2410		MOVQ 0x10(SP), BP	
  0x4194b0		4883c418		ADDQ $0x18, SP		
  0x4194b4		c3			RET			
		throw("workbuf is not empty")
  0x4194b5		488d05511d0500		LEAQ 0x51d51(IP), AX	
  0x4194bc		48890424		MOVQ AX, 0(SP)		
  0x4194c0		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x4194c9		e8027d0000		CALL runtime.throw(SB)	
  0x4194ce		0f0b			UD2			
func (b *workbuf) checkempty() {
  0x4194d0		e89bb00200		CALL runtime.morestack_noctxt(SB)	
  0x4194d5		eba9			JMP runtime.(*workbuf).checkempty(SB)	

TEXT runtime.getempty(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func getempty() *workbuf {
  0x4194e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4194e9		483b6110		CMPQ 0x10(CX), SP	
  0x4194ed		0f86e8010000		JBE 0x4196db		
  0x4194f3		4883ec50		SUBQ $0x50, SP		
  0x4194f7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4194fc		488d6c2448		LEAQ 0x48(SP), BP	
	if work.empty != 0 {
  0x419501		488b05a0e80800		MOVQ runtime.work+8(SB), AX	
  0x419508		4885c0			TESTQ AX, AX			
  0x41950b		0f8579010000		JNE 0x41968a			
  0x419511		31c0			XORL AX, AX			
	if b == nil {
  0x419513		4885c0			TESTQ AX, AX		
  0x419516		757c			JNE 0x419594		
  0x419518		4889442420		MOVQ AX, 0x20(SP)	
		var s *mspan
  0x41951d		48c744241800000000	MOVQ $0x0, 0x18(SP)	
		if work.wbufSpans.free.first != nil {
  0x419526		488b0dcbe80800		MOVQ runtime.work+88(SB), CX	
  0x41952d		4885c9			TESTQ CX, CX			
  0x419530		0f85e3000000		JNE 0x419619			
		if s == nil {
  0x419536		488b4c2418		MOVQ 0x18(SP), CX	
  0x41953b		4885c9			TESTQ CX, CX		
  0x41953e		7463			JE 0x4195a3		
  0x419540		31c9			XORL CX, CX		
		for i := uintptr(0); i+_WorkbufSize <= workbufAlloc; i += _WorkbufSize {
  0x419542		eb06			JMP 0x41954a		
  0x419544		4889d1			MOVQ DX, CX		
  0x419547		4889f0			MOVQ SI, AX		
  0x41954a		488d9100080000		LEAQ 0x800(CX), DX	
  0x419551		4881fa00800000		CMPQ $0x8000, DX	
  0x419558		773a			JA 0x419594		
			newb := (*workbuf)(unsafe.Pointer(s.base() + i))
  0x41955a		488b5c2418		MOVQ 0x18(SP), BX	
	return s.startAddr
  0x41955f		488b7318		MOVQ 0x18(BX), SI	
			newb := (*workbuf)(unsafe.Pointer(s.base() + i))
  0x419563		4801ce			ADDQ CX, SI		
	return s.startAddr
  0x419566		8403			TESTB AL, 0(BX)		
			newb.nobj = 0
  0x419568		48c7461000000000	MOVQ $0x0, 0x10(SI)	
			if i == 0 {
  0x419570		4885c9			TESTQ CX, CX		
  0x419573		74cf			JE 0x419544		
  0x419575		4889542410		MOVQ DX, 0x10(SP)	
  0x41957a		4889442430		MOVQ AX, 0x30(SP)	
				putempty(newb)
  0x41957f		48893424		MOVQ SI, 0(SP)			
  0x419583		e868010000		CALL runtime.putempty(SB)	
  0x419588		488b542410		MOVQ 0x10(SP), DX		
  0x41958d		488b742430		MOVQ 0x30(SP), SI		
  0x419592		ebb0			JMP 0x419544			
	return b
  0x419594		4889442458		MOVQ AX, 0x58(SP)	
  0x419599		488b6c2448		MOVQ 0x48(SP), BP	
  0x41959e		4883c450		ADDQ $0x50, SP		
  0x4195a2		c3			RET			
			systemstack(func() {
  0x4195a3		488d0566910200		LEAQ runtime.getempty.func1(SB), AX	
  0x4195aa		4889442438		MOVQ AX, 0x38(SP)			
  0x4195af		488d442418		LEAQ 0x18(SP), AX			
  0x4195b4		4889442440		MOVQ AX, 0x40(SP)			
  0x4195b9		488d442438		LEAQ 0x38(SP), AX			
  0x4195be		48890424		MOVQ AX, 0(SP)				
  0x4195c2		e859ae0200		CALL runtime.systemstack(SB)		
			if s == nil {
  0x4195c7		488b442418		MOVQ 0x18(SP), AX	
  0x4195cc		4885c0			TESTQ AX, AX		
  0x4195cf		0f84eb000000		JE 0x4196c0		
			lock(&work.wbufSpans.lock)
  0x4195d5		488d0514e80800		LEAQ runtime.work+80(SB), AX	
  0x4195dc		48890424		MOVQ AX, 0(SP)			
  0x4195e0		e83bfffeff		CALL runtime.lock(SB)		
			work.wbufSpans.busy.insert(s)
  0x4195e5		488d051ce80800		LEAQ runtime.work+104(SB), AX		
  0x4195ec		48890424		MOVQ AX, 0(SP)				
  0x4195f0		488b442418		MOVQ 0x18(SP), AX			
  0x4195f5		4889442408		MOVQ AX, 0x8(SP)			
  0x4195fa		e8512c0000		CALL runtime.(*mSpanList).insert(SB)	
			unlock(&work.wbufSpans.lock)
  0x4195ff		488d05eae70800		LEAQ runtime.work+80(SB), AX	
  0x419606		48890424		MOVQ AX, 0(SP)			
  0x41960a		e8b100ffff		CALL runtime.unlock(SB)		
  0x41960f		488b442420		MOVQ 0x20(SP), AX		
  0x419614		e927ffffff		JMP 0x419540			
			lock(&work.wbufSpans.lock)
  0x419619		488d05d0e70800		LEAQ runtime.work+80(SB), AX	
  0x419620		48890424		MOVQ AX, 0(SP)			
  0x419624		e8f7fefeff		CALL runtime.lock(SB)		
			s = work.wbufSpans.free.first
  0x419629		488b05c8e70800		MOVQ runtime.work+88(SB), AX	
  0x419630		4889442418		MOVQ AX, 0x18(SP)		
			if s != nil {
  0x419635		4885c0			TESTQ AX, AX		
  0x419638		751a			JNE 0x419654		
			unlock(&work.wbufSpans.lock)
  0x41963a		488d05afe70800		LEAQ runtime.work+80(SB), AX	
  0x419641		48890424		MOVQ AX, 0(SP)			
  0x419645		e87600ffff		CALL runtime.unlock(SB)		
  0x41964a		488b442420		MOVQ 0x20(SP), AX		
  0x41964f		e9e2feffff		JMP 0x419536			
				work.wbufSpans.free.remove(s)
  0x419654		488d059de70800		LEAQ runtime.work+88(SB), AX		
  0x41965b		48890424		MOVQ AX, 0(SP)				
  0x41965f		488b442418		MOVQ 0x18(SP), AX			
  0x419664		4889442408		MOVQ AX, 0x8(SP)			
  0x419669		e8422a0000		CALL runtime.(*mSpanList).remove(SB)	
				work.wbufSpans.busy.insert(s)
  0x41966e		488d0593e70800		LEAQ runtime.work+104(SB), AX		
  0x419675		48890424		MOVQ AX, 0(SP)				
  0x419679		488b442418		MOVQ 0x18(SP), AX			
  0x41967e		4889442408		MOVQ AX, 0x8(SP)			
  0x419683		e8c82b0000		CALL runtime.(*mSpanList).insert(SB)	
  0x419688		ebb0			JMP 0x41963a				
		b = (*workbuf)(work.empty.pop())
  0x41968a		488d0517e70800		LEAQ runtime.work+8(SB), AX	
  0x419691		48890424		MOVQ AX, 0(SP)			
  0x419695		e846fefeff		CALL runtime.(*lfstack).pop(SB)	
  0x41969a		488b442408		MOVQ 0x8(SP), AX		
		if b != nil {
  0x41969f		4885c0			TESTQ AX, AX		
  0x4196a2		0f846bfeffff		JE 0x419513		
  0x4196a8		4889442428		MOVQ AX, 0x28(SP)	
			b.checkempty()
  0x4196ad		48890424		MOVQ AX, 0(SP)				
  0x4196b1		e8cafdffff		CALL runtime.(*workbuf).checkempty(SB)	
  0x4196b6		488b442428		MOVQ 0x28(SP), AX			
  0x4196bb		e953feffff		JMP 0x419513				
				throw("out of memory")
  0x4196c0		488d05ae100500		LEAQ 0x510ae(IP), AX	
  0x4196c7		48890424		MOVQ AX, 0(SP)		
  0x4196cb		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x4196d4		e8f77a0000		CALL runtime.throw(SB)	
  0x4196d9		0f0b			UD2			
func getempty() *workbuf {
  0x4196db		e890ae0200		CALL runtime.morestack_noctxt(SB)	
  0x4196e0		e9fbfdffff		JMP runtime.getempty(SB)		

TEXT runtime.putempty(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func putempty(b *workbuf) {
  0x4196f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4196f9		483b6110		CMPQ 0x10(CX), SP	
  0x4196fd		7642			JBE 0x419741		
  0x4196ff		4883ec18		SUBQ $0x18, SP		
  0x419703		48896c2410		MOVQ BP, 0x10(SP)	
  0x419708		488d6c2410		LEAQ 0x10(SP), BP	
  0x41970d		488b442420		MOVQ 0x20(SP), AX	
	b.checkempty()
  0x419712		48890424		MOVQ AX, 0(SP)				
  0x419716		e865fdffff		CALL runtime.(*workbuf).checkempty(SB)	
  0x41971b		488b442420		MOVQ 0x20(SP), AX			
	work.empty.push(&b.node)
  0x419720		8400			TESTB AL, 0(AX)				
  0x419722		4889442408		MOVQ AX, 0x8(SP)			
  0x419727		488d057ae60800		LEAQ runtime.work+8(SB), AX		
  0x41972e		48890424		MOVQ AX, 0(SP)				
  0x419732		e849fcfeff		CALL runtime.(*lfstack).push(SB)	
}
  0x419737		488b6c2410		MOVQ 0x10(SP), BP	
  0x41973c		4883c418		ADDQ $0x18, SP		
  0x419740		c3			RET			
func putempty(b *workbuf) {
  0x419741		e82aae0200		CALL runtime.morestack_noctxt(SB)	
  0x419746		eba8			JMP runtime.putempty(SB)		

TEXT runtime.putfull(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func putfull(b *workbuf) {
  0x419750		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419759		483b6110		CMPQ 0x10(CX), SP	
  0x41975d		7642			JBE 0x4197a1		
  0x41975f		4883ec18		SUBQ $0x18, SP		
  0x419763		48896c2410		MOVQ BP, 0x10(SP)	
  0x419768		488d6c2410		LEAQ 0x10(SP), BP	
  0x41976d		488b442420		MOVQ 0x20(SP), AX	
	b.checknonempty()
  0x419772		48890424		MOVQ AX, 0(SP)					
  0x419776		e8a5fcffff		CALL runtime.(*workbuf).checknonempty(SB)	
  0x41977b		488b442420		MOVQ 0x20(SP), AX				
	work.full.push(&b.node)
  0x419780		8400			TESTB AL, 0(AX)				
  0x419782		4889442408		MOVQ AX, 0x8(SP)			
  0x419787		488d0512e60800		LEAQ runtime.work(SB), AX		
  0x41978e		48890424		MOVQ AX, 0(SP)				
  0x419792		e8e9fbfeff		CALL runtime.(*lfstack).push(SB)	
}
  0x419797		488b6c2410		MOVQ 0x10(SP), BP	
  0x41979c		4883c418		ADDQ $0x18, SP		
  0x4197a0		c3			RET			
func putfull(b *workbuf) {
  0x4197a1		e8caad0200		CALL runtime.morestack_noctxt(SB)	
  0x4197a6		eba8			JMP runtime.putfull(SB)			

TEXT runtime.trygetfull(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func trygetfull() *workbuf {
  0x4197b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4197b9		483b6110		CMPQ 0x10(CX), SP	
  0x4197bd		7659			JBE 0x419818		
  0x4197bf		4883ec20		SUBQ $0x20, SP		
  0x4197c3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4197c8		488d6c2418		LEAQ 0x18(SP), BP	
	b := (*workbuf)(work.full.pop())
  0x4197cd		488d05cce50800		LEAQ runtime.work(SB), AX	
  0x4197d4		48890424		MOVQ AX, 0(SP)			
  0x4197d8		e803fdfeff		CALL runtime.(*lfstack).pop(SB)	
  0x4197dd		488b442408		MOVQ 0x8(SP), AX		
	if b != nil {
  0x4197e2		4885c0			TESTQ AX, AX		
  0x4197e5		7422			JE 0x419809		
  0x4197e7		4889442410		MOVQ AX, 0x10(SP)	
		b.checknonempty()
  0x4197ec		48890424		MOVQ AX, 0(SP)					
  0x4197f0		e82bfcffff		CALL runtime.(*workbuf).checknonempty(SB)	
		return b
  0x4197f5		488b442410		MOVQ 0x10(SP), AX	
  0x4197fa		4889442428		MOVQ AX, 0x28(SP)	
  0x4197ff		488b6c2418		MOVQ 0x18(SP), BP	
  0x419804		4883c420		ADDQ $0x20, SP		
  0x419808		c3			RET			
	return b
  0x419809		4889442428		MOVQ AX, 0x28(SP)	
  0x41980e		488b6c2418		MOVQ 0x18(SP), BP	
  0x419813		4883c420		ADDQ $0x20, SP		
  0x419817		c3			RET			
func trygetfull() *workbuf {
  0x419818		e853ad0200		CALL runtime.morestack_noctxt(SB)	
  0x41981d		eb91			JMP runtime.trygetfull(SB)		

TEXT runtime.getfull(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func getfull() *workbuf {
  0x419820		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419829		483b6110		CMPQ 0x10(CX), SP	
  0x41982d		0f86ea020000		JBE 0x419b1d		
  0x419833		4883ec38		SUBQ $0x38, SP		
  0x419837		48896c2430		MOVQ BP, 0x30(SP)	
  0x41983c		488d6c2430		LEAQ 0x30(SP), BP	
	b := (*workbuf)(work.full.pop())
  0x419841		488d0558e50800		LEAQ runtime.work(SB), AX	
  0x419848		48890424		MOVQ AX, 0(SP)			
  0x41984c		e88ffcfeff		CALL runtime.(*lfstack).pop(SB)	
  0x419851		488b442408		MOVQ 0x8(SP), AX		
	if b != nil {
  0x419856		4885c0			TESTQ AX, AX		
  0x419859		0f8522010000		JNE 0x419981		
	incnwait := atomic.Xadd(&work.nwait, +1)
  0x41985f		b801000000		MOVL $0x1, AX			
  0x419864		488d0dd5e50800		LEAQ runtime.work+160(SB), CX	
  0x41986b		f00fc101		LOCK XADDL AX, 0(CX)		
  0x41986f		ffc0			INCL AX				
	if incnwait > work.nproc {
  0x419871		8b15b9e50800		MOVL runtime.work+144(SB), DX	
  0x419877		39d0			CMPL DX, AX			
  0x419879		0f8720020000		JA 0x419a9f			
  0x41987f		31c0			XORL AX, AX			
		if work.full != 0 {
  0x419881		eb10			JMP 0x419893		
  0x419883		488b542420		MOVQ 0x20(SP), DX	
	for i := 0; ; i++ {
  0x419888		488d4201		LEAQ 0x1(DX), AX		
  0x41988c		488d0dade50800		LEAQ runtime.work+160(SB), CX	
  0x419893		4889442420		MOVQ AX, 0x20(SP)		
		if work.full != 0 {
  0x419898		488b1501e50800		MOVQ runtime.work(SB), DX	
  0x41989f		4885d2			TESTQ DX, DX			
  0x4198a2		7562			JNE 0x419906			
		if work.nwait == work.nproc && work.markrootNext >= work.markrootJobs {
  0x4198a4		8b1596e50800		MOVL runtime.work+160(SB), DX	
  0x4198aa		8b1d80e50800		MOVL runtime.work+144(SB), BX	
  0x4198b0		39da			CMPL BX, DX			
  0x4198b2		7510			JNE 0x4198c4			
  0x4198b4		8b156ee50800		MOVL runtime.work+136(SB), DX	
  0x4198ba		8b1d6ce50800		MOVL runtime.work+140(SB), BX	
  0x4198c0		39da			CMPL BX, DX			
  0x4198c2		732f			JAE 0x4198f3			
		if i < 10 {
  0x4198c4		4883f80a		CMPQ $0xa, AX		
  0x4198c8		7c1b			JL 0x4198e5		
		} else if i < 20 {
  0x4198ca		4883f814		CMPQ $0x14, AX		
  0x4198ce		7d07			JGE 0x4198d7		
			osyield()
  0x4198d0		e87be60200		CALL runtime.osyield(SB)	
  0x4198d5		ebac			JMP 0x419883			
			usleep(100)
  0x4198d7		c7042464000000		MOVL $0x64, 0(SP)	
  0x4198de		e8cddf0200		CALL runtime.usleep(SB)	
  0x4198e3		eb9e			JMP 0x419883		
			procyield(20)
  0x4198e5		c7042414000000		MOVL $0x14, 0(SP)		
  0x4198ec		e87fc20200		CALL runtime.procyield(SB)	
  0x4198f1		eb90			JMP 0x419883			
			return nil
  0x4198f3		48c744244000000000	MOVQ $0x0, 0x40(SP)	
  0x4198fc		488b6c2430		MOVQ 0x30(SP), BP	
  0x419901		4883c438		ADDQ $0x38, SP		
  0x419905		c3			RET			
			decnwait := atomic.Xadd(&work.nwait, -1)
  0x419906		baffffffff		MOVL $-0x1, DX		
  0x41990b		f00fc111		LOCK XADDL DX, 0(CX)	
  0x41990f		ffca			DECL DX			
			if decnwait == work.nproc {
  0x419911		8b1d19e50800		MOVL runtime.work+144(SB), BX	
  0x419917		39d3			CMPL DX, BX			
  0x419919		0f8402010000		JE 0x419a21			
			b = (*workbuf)(work.full.pop())
  0x41991f		488d057ae40800		LEAQ runtime.work(SB), AX	
  0x419926		48890424		MOVQ AX, 0(SP)			
  0x41992a		e8b1fbfeff		CALL runtime.(*lfstack).pop(SB)	
  0x41992f		488b442408		MOVQ 0x8(SP), AX		
			if b != nil {
  0x419934		4885c0			TESTQ AX, AX		
  0x419937		7526			JNE 0x41995f		
			incnwait := atomic.Xadd(&work.nwait, +1)
  0x419939		b801000000		MOVL $0x1, AX			
  0x41993e		488d0dfbe40800		LEAQ runtime.work+160(SB), CX	
  0x419945		f00fc101		LOCK XADDL AX, 0(CX)		
  0x419949		ffc0			INCL AX				
			if incnwait > work.nproc {
  0x41994b		8b15dfe40800		MOVL runtime.work+144(SB), DX	
  0x419951		39d0			CMPL DX, AX			
  0x419953		774e			JA 0x4199a3			
  0x419955		488b442420		MOVQ 0x20(SP), AX		
		if work.nwait == work.nproc && work.markrootNext >= work.markrootJobs {
  0x41995a		e945ffffff		JMP 0x4198a4		
  0x41995f		4889442428		MOVQ AX, 0x28(SP)	
				b.checknonempty()
  0x419964		48890424		MOVQ AX, 0(SP)					
  0x419968		e8b3faffff		CALL runtime.(*workbuf).checknonempty(SB)	
				return b
  0x41996d		488b442428		MOVQ 0x28(SP), AX	
  0x419972		4889442440		MOVQ AX, 0x40(SP)	
  0x419977		488b6c2430		MOVQ 0x30(SP), BP	
  0x41997c		4883c438		ADDQ $0x38, SP		
  0x419980		c3			RET			
  0x419981		4889442428		MOVQ AX, 0x28(SP)	
		b.checknonempty()
  0x419986		48890424		MOVQ AX, 0(SP)					
  0x41998a		e891faffff		CALL runtime.(*workbuf).checknonempty(SB)	
		return b
  0x41998f		488b442428		MOVQ 0x28(SP), AX	
  0x419994		4889442440		MOVQ AX, 0x40(SP)	
  0x419999		488b6c2430		MOVQ 0x30(SP), BP	
  0x41999e		4883c438		ADDQ $0x38, SP		
  0x4199a2		c3			RET			
  0x4199a3		89442414		MOVL AX, 0x14(SP)	
  0x4199a7		8954241c		MOVL DX, 0x1c(SP)	
				println("runtime: work.nwait=", incnwait, "work.nproc=", work.nproc)
  0x4199ab		e850810000		CALL runtime.printlock(SB)	
  0x4199b0		488d058f190500		LEAQ 0x5198f(IP), AX		
  0x4199b7		48890424		MOVQ AX, 0(SP)			
  0x4199bb		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4199c4		e8778a0000		CALL runtime.printstring(SB)	
  0x4199c9		8b442414		MOVL 0x14(SP), AX		
  0x4199cd		48890424		MOVQ AX, 0(SP)			
  0x4199d1		e89a870000		CALL runtime.printuint(SB)	
  0x4199d6		488d05fc0c0500		LEAQ 0x50cfc(IP), AX		
  0x4199dd		48890424		MOVQ AX, 0(SP)			
  0x4199e1		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4199ea		e8518a0000		CALL runtime.printstring(SB)	
  0x4199ef		8b44241c		MOVL 0x1c(SP), AX		
  0x4199f3		48890424		MOVQ AX, 0(SP)			
  0x4199f7		e874870000		CALL runtime.printuint(SB)	
  0x4199fc		e88f830000		CALL runtime.printnl(SB)	
  0x419a01		e87a810000		CALL runtime.printunlock(SB)	
				throw("work.nwait > work.nproc")
  0x419a06		488d05221e0500		LEAQ 0x51e22(IP), AX	
  0x419a0d		48890424		MOVQ AX, 0(SP)		
  0x419a11		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x419a1a		e8b1770000		CALL runtime.throw(SB)	
  0x419a1f		0f0b			UD2			
  0x419a21		89542418		MOVL DX, 0x18(SP)	
  0x419a25		895c241c		MOVL BX, 0x1c(SP)	
				println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)
  0x419a29		e8d2800000		CALL runtime.printlock(SB)	
  0x419a2e		488d0511190500		LEAQ 0x51911(IP), AX		
  0x419a35		48890424		MOVQ AX, 0(SP)			
  0x419a39		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x419a42		e8f9890000		CALL runtime.printstring(SB)	
  0x419a47		8b442418		MOVL 0x18(SP), AX		
  0x419a4b		48890424		MOVQ AX, 0(SP)			
  0x419a4f		e81c870000		CALL runtime.printuint(SB)	
  0x419a54		488d057e0c0500		LEAQ 0x50c7e(IP), AX		
  0x419a5b		48890424		MOVQ AX, 0(SP)			
  0x419a5f		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x419a68		e8d3890000		CALL runtime.printstring(SB)	
  0x419a6d		8b44241c		MOVL 0x1c(SP), AX		
  0x419a71		48890424		MOVQ AX, 0(SP)			
  0x419a75		e8f6860000		CALL runtime.printuint(SB)	
  0x419a7a		e811830000		CALL runtime.printnl(SB)	
  0x419a7f		e8fc800000		CALL runtime.printunlock(SB)	
				throw("work.nwait > work.nproc")
  0x419a84		488d05a41d0500		LEAQ 0x51da4(IP), AX	
  0x419a8b		48890424		MOVQ AX, 0(SP)		
  0x419a8f		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x419a98		e833770000		CALL runtime.throw(SB)	
  0x419a9d		0f0b			UD2			
  0x419a9f		89442410		MOVL AX, 0x10(SP)	
  0x419aa3		8954241c		MOVL DX, 0x1c(SP)	
		println("runtime: work.nwait=", incnwait, "work.nproc=", work.nproc)
  0x419aa7		e854800000		CALL runtime.printlock(SB)	
  0x419aac		488d0593180500		LEAQ 0x51893(IP), AX		
  0x419ab3		48890424		MOVQ AX, 0(SP)			
  0x419ab7		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x419ac0		e87b890000		CALL runtime.printstring(SB)	
  0x419ac5		8b442410		MOVL 0x10(SP), AX		
  0x419ac9		48890424		MOVQ AX, 0(SP)			
  0x419acd		e89e860000		CALL runtime.printuint(SB)	
  0x419ad2		488d05000c0500		LEAQ 0x50c00(IP), AX		
  0x419ad9		48890424		MOVQ AX, 0(SP)			
  0x419add		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x419ae6		e855890000		CALL runtime.printstring(SB)	
  0x419aeb		8b44241c		MOVL 0x1c(SP), AX		
  0x419aef		48890424		MOVQ AX, 0(SP)			
  0x419af3		e878860000		CALL runtime.printuint(SB)	
  0x419af8		e893820000		CALL runtime.printnl(SB)	
  0x419afd		e87e800000		CALL runtime.printunlock(SB)	
		throw("work.nwait > work.nproc")
  0x419b02		488d05261d0500		LEAQ 0x51d26(IP), AX	
  0x419b09		48890424		MOVQ AX, 0(SP)		
  0x419b0d		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x419b16		e8b5760000		CALL runtime.throw(SB)	
  0x419b1b		0f0b			UD2			
func getfull() *workbuf {
  0x419b1d		e84eaa0200		CALL runtime.morestack_noctxt(SB)	
  0x419b22		e9f9fcffff		JMP runtime.getfull(SB)			

TEXT runtime.handoff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func handoff(b *workbuf) *workbuf {
  0x419b30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419b39		483b6110		CMPQ 0x10(CX), SP	
  0x419b3d		0f8697000000		JBE 0x419bda		
  0x419b43		4883ec28		SUBQ $0x28, SP		
  0x419b47		48896c2420		MOVQ BP, 0x20(SP)	
  0x419b4c		488d6c2420		LEAQ 0x20(SP), BP	
	b1 := getempty()
  0x419b51		e88af9ffff		CALL runtime.getempty(SB)	
  0x419b56		488b0424		MOVQ 0(SP), AX			
  0x419b5a		488b4c2430		MOVQ 0x30(SP), CX		
	n := b.nobj / 2
  0x419b5f		488b5110		MOVQ 0x10(CX), DX	
  0x419b63		4889d3			MOVQ DX, BX		
  0x419b66		48c1fa3f		SARQ $0x3f, DX		
  0x419b6a		48c1ea3f		SHRQ $0x3f, DX		
  0x419b6e		4801da			ADDQ BX, DX		
  0x419b71		48d1fa			SARQ $0x1, DX		
	b.nobj -= n
  0x419b74		4829d3			SUBQ DX, BX		
  0x419b77		48895910		MOVQ BX, 0x10(CX)	
	b1.nobj = n
  0x419b7b		48895010		MOVQ DX, 0x10(AX)	
	memmove(unsafe.Pointer(&b1.obj[0]), unsafe.Pointer(&b.obj[b.nobj]), uintptr(n)*unsafe.Sizeof(b1.obj[0]))
  0x419b7f		488b5910		MOVQ 0x10(CX), BX		
  0x419b83		4881fbfd000000		CMPQ $0xfd, BX			
  0x419b8a		7347			JAE 0x419bd3			
  0x419b8c		4889442418		MOVQ AX, 0x18(SP)		
  0x419b91		488d5cd918		LEAQ 0x18(CX)(BX*8), BX		
  0x419b96		48895c2408		MOVQ BX, 0x8(SP)		
  0x419b9b		488d5818		LEAQ 0x18(AX), BX		
  0x419b9f		48891c24		MOVQ BX, 0(SP)			
  0x419ba3		48c1e203		SHLQ $0x3, DX			
  0x419ba7		4889542410		MOVQ DX, 0x10(SP)		
  0x419bac		e84fd50200		CALL runtime.memmove(SB)	
  0x419bb1		488b442430		MOVQ 0x30(SP), AX		
	putfull(b)
  0x419bb6		48890424		MOVQ AX, 0(SP)			
  0x419bba		e891fbffff		CALL runtime.putfull(SB)	
	return b1
  0x419bbf		488b442418		MOVQ 0x18(SP), AX	
  0x419bc4		4889442438		MOVQ AX, 0x38(SP)	
  0x419bc9		488b6c2420		MOVQ 0x20(SP), BP	
  0x419bce		4883c428		ADDQ $0x28, SP		
  0x419bd2		c3			RET			
	memmove(unsafe.Pointer(&b1.obj[0]), unsafe.Pointer(&b.obj[b.nobj]), uintptr(n)*unsafe.Sizeof(b1.obj[0]))
  0x419bd3		e8685e0000		CALL runtime.panicindex(SB)	
  0x419bd8		0f0b			UD2				
func handoff(b *workbuf) *workbuf {
  0x419bda		e891a90200		CALL runtime.morestack_noctxt(SB)	
  0x419bdf		e94cffffff		JMP runtime.handoff(SB)			

TEXT runtime.prepareFreeWorkbufs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func prepareFreeWorkbufs() {
  0x419bf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419bf9		483b6110		CMPQ 0x10(CX), SP	
  0x419bfd		0f8686000000		JBE 0x419c89		
  0x419c03		4883ec18		SUBQ $0x18, SP		
  0x419c07		48896c2410		MOVQ BP, 0x10(SP)	
  0x419c0c		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&work.wbufSpans.lock)
  0x419c11		488d05d8e10800		LEAQ runtime.work+80(SB), AX	
  0x419c18		48890424		MOVQ AX, 0(SP)			
  0x419c1c		e8fff8feff		CALL runtime.lock(SB)		
	if work.full != 0 {
  0x419c21		488b0578e10800		MOVQ runtime.work(SB), AX	
  0x419c28		4885c0			TESTQ AX, AX			
  0x419c2b		7541			JNE 0x419c6e			
	work.empty = 0
  0x419c2d		48c70570e1080000000000	MOVQ $0x0, runtime.work+8(SB)	
	work.wbufSpans.free.takeAll(&work.wbufSpans.busy)
  0x419c38		488d05b9e10800		LEAQ runtime.work+88(SB), AX		
  0x419c3f		48890424		MOVQ AX, 0(SP)				
  0x419c43		488d05bee10800		LEAQ runtime.work+104(SB), AX		
  0x419c4a		4889442408		MOVQ AX, 0x8(SP)			
  0x419c4f		e83c280000		CALL runtime.(*mSpanList).takeAll(SB)	
	unlock(&work.wbufSpans.lock)
  0x419c54		488d0595e10800		LEAQ runtime.work+80(SB), AX	
  0x419c5b		48890424		MOVQ AX, 0(SP)			
  0x419c5f		e85cfafeff		CALL runtime.unlock(SB)		
}
  0x419c64		488b6c2410		MOVQ 0x10(SP), BP	
  0x419c69		4883c418		ADDQ $0x18, SP		
  0x419c6d		c3			RET			
		throw("cannot free workbufs when work.full != 0")
  0x419c6e		488d05f1350500		LEAQ 0x535f1(IP), AX	
  0x419c75		48890424		MOVQ AX, 0(SP)		
  0x419c79		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x419c82		e849750000		CALL runtime.throw(SB)	
  0x419c87		0f0b			UD2			
func prepareFreeWorkbufs() {
  0x419c89		e8e2a80200		CALL runtime.morestack_noctxt(SB)	
  0x419c8e		e95dffffff		JMP runtime.prepareFreeWorkbufs(SB)	

TEXT runtime.freeSomeWbufs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
func freeSomeWbufs(preemptible bool) bool {
  0x419ca0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419ca9		483b6110		CMPQ 0x10(CX), SP	
  0x419cad		0f86b5000000		JBE 0x419d68		
  0x419cb3		4883ec28		SUBQ $0x28, SP		
  0x419cb7		48896c2420		MOVQ BP, 0x20(SP)	
  0x419cbc		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&work.wbufSpans.lock)
  0x419cc1		488d0528e10800		LEAQ runtime.work+80(SB), AX	
  0x419cc8		48890424		MOVQ AX, 0(SP)			
  0x419ccc		e84ff8feff		CALL runtime.lock(SB)		
	if gcphase != _GCoff || work.wbufSpans.free.isEmpty() {
  0x419cd1		8b05059c0a00		MOVL runtime.gcphase(SB), AX	
  0x419cd7		85c0			TESTL AX, AX			
  0x419cd9		741f			JE 0x419cfa			
		unlock(&work.wbufSpans.lock)
  0x419cdb		488d050ee10800		LEAQ runtime.work+80(SB), AX	
  0x419ce2		48890424		MOVQ AX, 0(SP)			
  0x419ce6		e8d5f9feff		CALL runtime.unlock(SB)		
		return false
  0x419ceb		c644243800		MOVB $0x0, 0x38(SP)	
  0x419cf0		488b6c2420		MOVQ 0x20(SP), BP	
  0x419cf5		4883c428		ADDQ $0x28, SP		
  0x419cf9		c3			RET			
	return list.first == nil
  0x419cfa		488d05f7e00800		LEAQ runtime.work+88(SB), AX	
  0x419d01		8400			TESTB AL, 0(AX)			
  0x419d03		488b05eee00800		MOVQ runtime.work+88(SB), AX	
  0x419d0a		4885c0			TESTQ AX, AX			
	if gcphase != _GCoff || work.wbufSpans.free.isEmpty() {
  0x419d0d		74cc			JE 0x419cdb		
	systemstack(func() {
  0x419d0f		488d056a8a0200		LEAQ runtime.freeSomeWbufs.func1(SB), AX	
  0x419d16		4889442408		MOVQ AX, 0x8(SP)				
  0x419d1b		0fb6442430		MOVZX 0x30(SP), AX				
  0x419d20		88442410		MOVB AL, 0x10(SP)				
  0x419d24		488d442408		LEAQ 0x8(SP), AX				
  0x419d29		48890424		MOVQ AX, 0(SP)					
  0x419d2d		e8eea60200		CALL runtime.systemstack(SB)			
	return list.first == nil
  0x419d32		488b05bfe00800		MOVQ runtime.work+88(SB), AX	
  0x419d39		4889442418		MOVQ AX, 0x18(SP)		
	unlock(&work.wbufSpans.lock)
  0x419d3e		488d0dabe00800		LEAQ runtime.work+80(SB), CX	
  0x419d45		48890c24		MOVQ CX, 0(SP)			
  0x419d49		e872f9feff		CALL runtime.unlock(SB)		
	return more
  0x419d4e		488b442418		MOVQ 0x18(SP), AX	
	return list.first == nil
  0x419d53		4885c0			TESTQ AX, AX		
	return more
  0x419d56		488d442438		LEAQ 0x38(SP), AX	
  0x419d5b		0f9500			SETNE 0(AX)		
  0x419d5e		488b6c2420		MOVQ 0x20(SP), BP	
  0x419d63		4883c428		ADDQ $0x28, SP		
  0x419d67		c3			RET			
func freeSomeWbufs(preemptible bool) bool {
  0x419d68		e803a80200		CALL runtime.morestack_noctxt(SB)	
  0x419d6d		e92effffff		JMP runtime.freeSomeWbufs(SB)		

TEXT runtime.recordspan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func recordspan(vh unsafe.Pointer, p unsafe.Pointer) {
  0x419d80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419d89		483b6110		CMPQ 0x10(CX), SP	
  0x419d8d		0f86e8010000		JBE 0x419f7b		
  0x419d93		4883ec48		SUBQ $0x48, SP		
  0x419d97		48896c2440		MOVQ BP, 0x40(SP)	
  0x419d9c		488d6c2440		LEAQ 0x40(SP), BP	
  0x419da1		0f57c0			XORPS X0, X0		
  0x419da4		0f11442428		MOVUPS X0, 0x28(SP)	
  0x419da9		0f11442430		MOVUPS X0, 0x30(SP)	
  0x419dae		488b442450		MOVQ 0x50(SP), AX	
	if len(h.allspans) >= cap(h.allspans) {
  0x419db3		8400			TESTB AL, 0(AX)		
  0x419db5		488d8830100000		LEAQ 0x1030(AX), CX	
  0x419dbc		488b9040100000		MOVQ 0x1040(AX), DX	
  0x419dc3		488b9838100000		MOVQ 0x1038(AX), BX	
  0x419dca		4839d3			CMPQ DX, BX		
  0x419dcd		0f8c0b010000		JL 0x419ede		
  0x419dd3		48894c2420		MOVQ CX, 0x20(SP)	
		if n < cap(h.allspans)*3/2 {
  0x419dd8		488d1452		LEAQ 0(DX)(DX*2), DX	
  0x419ddc		4889d3			MOVQ DX, BX		
  0x419ddf		48c1fa3f		SARQ $0x3f, DX		
  0x419de3		48c1ea3f		SHRQ $0x3f, DX		
  0x419de7		4801da			ADDQ BX, DX		
  0x419dea		48d1fa			SARQ $0x1, DX		
  0x419ded		4881fa00200000		CMPQ $0x2000, DX	
  0x419df4		0f8e4e010000		JLE 0x419f48		
  0x419dfa		4889542418		MOVQ DX, 0x18(SP)	
		var new []*mspan
  0x419dff		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x419e08		0f57c0			XORPS X0, X0		
  0x419e0b		0f11442430		MOVUPS X0, 0x30(SP)	
		sp.array = sysAlloc(uintptr(n)*sys.PtrSize, &memstats.other_sys)
  0x419e10		48c1e203		SHLQ $0x3, DX				
  0x419e14		48891424		MOVQ DX, 0(SP)				
  0x419e18		488d0d81a90a00		LEAQ runtime.memstats+160(SB), CX	
  0x419e1f		48894c2408		MOVQ CX, 0x8(SP)			
  0x419e24		e8f751ffff		CALL runtime.sysAlloc(SB)		
  0x419e29		488b442410		MOVQ 0x10(SP), AX			
  0x419e2e		4889442428		MOVQ AX, 0x28(SP)			
		if sp.array == nil {
  0x419e33		4885c0			TESTQ AX, AX		
  0x419e36		0f8424010000		JE 0x419f60		
  0x419e3c		488b442450		MOVQ 0x50(SP), AX	
		sp.len = len(h.allspans)
  0x419e41		488b8838100000		MOVQ 0x1038(AX), CX	
  0x419e48		48894c2430		MOVQ CX, 0x30(SP)	
  0x419e4d		488b4c2418		MOVQ 0x18(SP), CX	
		sp.cap = n
  0x419e52		48894c2438		MOVQ CX, 0x38(SP)	
		if len(h.allspans) > 0 {
  0x419e57		488b8838100000		MOVQ 0x1038(AX), CX	
  0x419e5e		488b9030100000		MOVQ 0x1030(AX), DX	
  0x419e65		4885c9			TESTQ CX, CX		
  0x419e68		7e2a			JLE 0x419e94		
			copy(new, h.allspans)
  0x419e6a		488b5c2430		MOVQ 0x30(SP), BX		
  0x419e6f		488b742428		MOVQ 0x28(SP), SI		
  0x419e74		4839cb			CMPQ CX, BX			
  0x419e77		0f8ec3000000		JLE 0x419f40			
  0x419e7d		48893424		MOVQ SI, 0(SP)			
  0x419e81		4889542408		MOVQ DX, 0x8(SP)		
  0x419e86		48c1e103		SHLQ $0x3, CX			
  0x419e8a		48894c2410		MOVQ CX, 0x10(SP)		
  0x419e8f		e86cd20200		CALL runtime.memmove(SB)	
  0x419e94		488b442420		MOVQ 0x20(SP), AX		
		*(*notInHeapSlice)(unsafe.Pointer(&h.allspans)) = *(*notInHeapSlice)(unsafe.Pointer(&new))
  0x419e99		8400			TESTB AL, 0(AX)		
  0x419e9b		488b442450		MOVQ 0x50(SP), AX	
		oldAllspans := h.allspans
  0x419ea0		488b8840100000		MOVQ 0x1040(AX), CX	
  0x419ea7		488b9038100000		MOVQ 0x1038(AX), DX	
  0x419eae		488b9830100000		MOVQ 0x1030(AX), BX	
		*(*notInHeapSlice)(unsafe.Pointer(&h.allspans)) = *(*notInHeapSlice)(unsafe.Pointer(&new))
  0x419eb5		488b742428		MOVQ 0x28(SP), SI	
  0x419eba		488b7c2438		MOVQ 0x38(SP), DI	
  0x419ebf		4c8b442430		MOVQ 0x30(SP), R8	
  0x419ec4		4c898038100000		MOVQ R8, 0x1038(AX)	
  0x419ecb		4889b840100000		MOVQ DI, 0x1040(AX)	
  0x419ed2		4889b030100000		MOVQ SI, 0x1030(AX)	
		if len(oldAllspans) != 0 {
  0x419ed9		4885d2			TESTQ DX, DX		
  0x419edc		753d			JNE 0x419f1b		
	h.allspans = h.allspans[:len(h.allspans)+1]
  0x419ede		488b8838100000		MOVQ 0x1038(AX), CX	
  0x419ee5		488b9040100000		MOVQ 0x1040(AX), DX	
  0x419eec		488d5901		LEAQ 0x1(CX), BX	
  0x419ef0		4839d3			CMPQ DX, BX		
  0x419ef3		7764			JA 0x419f59		
  0x419ef5		48899838100000		MOVQ BX, 0x1038(AX)	
	h.allspans[len(h.allspans)-1] = s
  0x419efc		488b8030100000		MOVQ 0x1030(AX), AX	
  0x419f03		4839d9			CMPQ BX, CX		
  0x419f06		734a			JAE 0x419f52		
  0x419f08		488b542458		MOVQ 0x58(SP), DX	
  0x419f0d		488914c8		MOVQ DX, 0(AX)(CX*8)	
}
  0x419f11		488b6c2440		MOVQ 0x40(SP), BP	
  0x419f16		4883c448		ADDQ $0x48, SP		
  0x419f1a		c3			RET			
			sysFree(unsafe.Pointer(&oldAllspans[0]), uintptr(cap(oldAllspans))*unsafe.Sizeof(oldAllspans[0]), &memstats.other_sys)
  0x419f1b		48891c24		MOVQ BX, 0(SP)				
  0x419f1f		48c1e103		SHLQ $0x3, CX				
  0x419f23		48894c2408		MOVQ CX, 0x8(SP)			
  0x419f28		488d0571a80a00		LEAQ runtime.memstats+160(SB), AX	
  0x419f2f		4889442410		MOVQ AX, 0x10(SP)			
  0x419f34		e80754ffff		CALL runtime.sysFree(SB)		
  0x419f39		488b442450		MOVQ 0x50(SP), AX			
  0x419f3e		eb9e			JMP 0x419ede				
  0x419f40		4889d9			MOVQ BX, CX				
			copy(new, h.allspans)
  0x419f43		e935ffffff		JMP 0x419e7d		
  0x419f48		ba00200000		MOVL $0x2000, DX	
		var new []*mspan
  0x419f4d		e9a8feffff		JMP 0x419dfa		
	h.allspans[len(h.allspans)-1] = s
  0x419f52		e8e95a0000		CALL runtime.panicindex(SB)	
  0x419f57		0f0b			UD2				
	h.allspans = h.allspans[:len(h.allspans)+1]
  0x419f59		e8525b0000		CALL runtime.panicslice(SB)	
  0x419f5e		0f0b			UD2				
			throw("runtime: cannot allocate memory")
  0x419f60		488d05fe270500		LEAQ 0x527fe(IP), AX	
  0x419f67		48890424		MOVQ AX, 0(SP)		
  0x419f6b		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x419f74		e857720000		CALL runtime.throw(SB)	
  0x419f79		0f0b			UD2			
func recordspan(vh unsafe.Pointer, p unsafe.Pointer) {
  0x419f7b		e8f0a50200		CALL runtime.morestack_noctxt(SB)	
  0x419f80		e9fbfdffff		JMP runtime.recordspan(SB)		

TEXT runtime.(*mheap).init(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) init(spansStart, spansBytes uintptr) {
  0x419f90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419f99		483b6110		CMPQ 0x10(CX), SP	
  0x419f9d		0f86bc040000		JBE 0x41a45f		
  0x419fa3		4883ec20		SUBQ $0x20, SP		
  0x419fa7		48896c2418		MOVQ BP, 0x18(SP)	
  0x419fac		488d6c2418		LEAQ 0x18(SP), BP	
  0x419fb1		488b4c2428		MOVQ 0x28(SP), CX	
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x419fb6		8401			TESTB AL, 0(CX)		
  0x419fb8		488d9160350000		LEAQ 0x3560(CX), DX	
	f.size = size
  0x419fbf		8402			TESTB AL, 0(DX)		
  0x419fc1		48c7816035000030000000	MOVQ $0x30, 0x3560(CX)	
	f.first = first
  0x419fcc		8b153e9a0a00		MOVL runtime.writeBarrier(SB), DX	
  0x419fd2		488db968350000		LEAQ 0x3568(CX), DI			
	f.arg = arg
  0x419fd9		488d9970350000		LEAQ 0x3570(CX), BX	
	f.first = first
  0x419fe0		85d2			TESTL DX, DX		
  0x419fe2		0f8561040000		JNE 0x41a449		
	f.arg = arg
  0x419fe8		0f57c0			XORPS X0, X0		
  0x419feb		0f118168350000		MOVUPS X0, 0x3568(CX)	
	f.chunk = 0
  0x419ff2		0f57c0			XORPS X0, X0		
  0x419ff5		0f118178350000		MOVUPS X0, 0x3578(CX)	
	f.nchunk = 0
  0x419ffc		c7818835000000000000	MOVL $0x0, 0x3588(CX)	
	f.inuse = 0
  0x41a006		48c7819035000000000000	MOVQ $0x0, 0x3590(CX)	
	f.stat = stat
  0x41a011		8b15f9990a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a017		488db998350000		LEAQ 0x3598(CX), DI			
  0x41a01e		85d2			TESTL DX, DX				
  0x41a020		0f850f040000		JNE 0x41a435				
  0x41a026		488d0573a70a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a02d		48898198350000		MOVQ AX, 0x3598(CX)			
	f.zero = true
  0x41a034		c681a035000001		MOVB $0x1, 0x35a0(CX)	
	h.spanalloc.init(unsafe.Sizeof(mspan{}), recordspan, unsafe.Pointer(h), &memstats.mspan_sys)
  0x41a03b		488d91d0340000		LEAQ 0x34d0(CX), DX	
	f.size = size
  0x41a042		8402			TESTB AL, 0(DX)		
  0x41a044		48c781d034000098000000	MOVQ $0x98, 0x34d0(CX)	
	f.first = first
  0x41a04f		8b15bb990a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a055		488db9d8340000		LEAQ 0x34d8(CX), DI			
	f.arg = arg
  0x41a05c		488d99e0340000		LEAQ 0x34e0(CX), BX	
	f.first = first
  0x41a063		85d2			TESTL DX, DX		
  0x41a065		0f85a4030000		JNE 0x41a40f		
  0x41a06b		488d154e410500		LEAQ 0x5414e(IP), DX	
  0x41a072		488991d8340000		MOVQ DX, 0x34d8(CX)	
	f.arg = arg
  0x41a079		488989e0340000		MOVQ CX, 0x34e0(CX)	
	f.chunk = 0
  0x41a080		0f1181e8340000		MOVUPS X0, 0x34e8(CX)	
	f.nchunk = 0
  0x41a087		c781f834000000000000	MOVL $0x0, 0x34f8(CX)	
	f.inuse = 0
  0x41a091		48c7810035000000000000	MOVQ $0x0, 0x3500(CX)	
	f.stat = stat
  0x41a09c		8b156e990a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a0a2		488db908350000		LEAQ 0x3508(CX), DI			
  0x41a0a9		85d2			TESTL DX, DX				
  0x41a0ab		0f8543030000		JNE 0x41a3f4				
  0x41a0b1		488d15c0a60a00		LEAQ runtime.memstats+120(SB), DX	
  0x41a0b8		48899108350000		MOVQ DX, 0x3508(CX)			
	f.zero = true
  0x41a0bf		c6811035000001		MOVB $0x1, 0x3510(CX)	
	h.cachealloc.init(unsafe.Sizeof(mcache{}), nil, nil, &memstats.mcache_sys)
  0x41a0c6		488d9118350000		LEAQ 0x3518(CX), DX	
	f.size = size
  0x41a0cd		8402			TESTB AL, 0(DX)		
  0x41a0cf		48c78118350000c8060000	MOVQ $0x6c8, 0x3518(CX)	
	f.first = first
  0x41a0da		8b1530990a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a0e0		488db920350000		LEAQ 0x3520(CX), DI			
	f.arg = arg
  0x41a0e7		488d9928350000		LEAQ 0x3528(CX), BX	
	f.first = first
  0x41a0ee		85d2			TESTL DX, DX		
  0x41a0f0		0f85de020000		JNE 0x41a3d4		
	f.arg = arg
  0x41a0f6		0f118120350000		MOVUPS X0, 0x3520(CX)	
	f.chunk = 0
  0x41a0fd		0f118130350000		MOVUPS X0, 0x3530(CX)	
	f.nchunk = 0
  0x41a104		c7814035000000000000	MOVL $0x0, 0x3540(CX)	
	f.inuse = 0
  0x41a10e		48c7814835000000000000	MOVQ $0x0, 0x3548(CX)	
	f.stat = stat
  0x41a119		8b15f1980a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a11f		488db950350000		LEAQ 0x3550(CX), DI			
  0x41a126		85d2			TESTL DX, DX				
  0x41a128		0f858b020000		JNE 0x41a3b9				
  0x41a12e		488d1553a60a00		LEAQ runtime.memstats+136(SB), DX	
  0x41a135		48899150350000		MOVQ DX, 0x3550(CX)			
	f.zero = true
  0x41a13c		c6815835000001		MOVB $0x1, 0x3558(CX)	
	h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer{}), nil, nil, &memstats.other_sys)
  0x41a143		488d91a8350000		LEAQ 0x35a8(CX), DX	
	f.size = size
  0x41a14a		8402			TESTB AL, 0(DX)		
  0x41a14c		48c781a835000030000000	MOVQ $0x30, 0x35a8(CX)	
	f.first = first
  0x41a157		8b15b3980a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a15d		488db9b0350000		LEAQ 0x35b0(CX), DI			
	f.arg = arg
  0x41a164		488d99b8350000		LEAQ 0x35b8(CX), BX	
	f.first = first
  0x41a16b		85d2			TESTL DX, DX		
  0x41a16d		0f8526020000		JNE 0x41a399		
	f.arg = arg
  0x41a173		0f1181b0350000		MOVUPS X0, 0x35b0(CX)	
	f.chunk = 0
  0x41a17a		0f1181c0350000		MOVUPS X0, 0x35c0(CX)	
	f.nchunk = 0
  0x41a181		c781d035000000000000	MOVL $0x0, 0x35d0(CX)	
	f.inuse = 0
  0x41a18b		48c781d835000000000000	MOVQ $0x0, 0x35d8(CX)	
	f.stat = stat
  0x41a196		8b1574980a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a19c		488db9e0350000		LEAQ 0x35e0(CX), DI			
  0x41a1a3		85d2			TESTL DX, DX				
  0x41a1a5		0f85e1010000		JNE 0x41a38c				
  0x41a1ab		488981e0350000		MOVQ AX, 0x35e0(CX)			
	f.zero = true
  0x41a1b2		c681e835000001		MOVB $0x1, 0x35e8(CX)	
	h.specialprofilealloc.init(unsafe.Sizeof(specialprofile{}), nil, nil, &memstats.other_sys)
  0x41a1b9		488d91f0350000		LEAQ 0x35f0(CX), DX	
	f.size = size
  0x41a1c0		8402			TESTB AL, 0(DX)		
  0x41a1c2		48c781f035000018000000	MOVQ $0x18, 0x35f0(CX)	
	f.first = first
  0x41a1cd		8b153d980a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a1d3		488db9f8350000		LEAQ 0x35f8(CX), DI			
	f.arg = arg
  0x41a1da		488d9900360000		LEAQ 0x3600(CX), BX	
	f.first = first
  0x41a1e1		85d2			TESTL DX, DX		
  0x41a1e3		0f8583010000		JNE 0x41a36c		
	f.arg = arg
  0x41a1e9		0f1181f8350000		MOVUPS X0, 0x35f8(CX)	
	f.chunk = 0
  0x41a1f0		0f118108360000		MOVUPS X0, 0x3608(CX)	
	f.nchunk = 0
  0x41a1f7		c7811836000000000000	MOVL $0x0, 0x3618(CX)	
	f.inuse = 0
  0x41a201		48c7812036000000000000	MOVQ $0x0, 0x3620(CX)	
	f.stat = stat
  0x41a20c		8b15fe970a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a212		488db928360000		LEAQ 0x3628(CX), DI			
  0x41a219		85d2			TESTL DX, DX				
  0x41a21b		0f853e010000		JNE 0x41a35f				
  0x41a221		48898128360000		MOVQ AX, 0x3628(CX)			
	f.zero = true
  0x41a228		c6813036000001		MOVB $0x1, 0x3630(CX)	
	h.spanalloc.zero = false
  0x41a22f		c6811035000000		MOVB $0x0, 0x3510(CX)	
  0x41a236		31c0			XORL AX, AX		
	for i := range h.free {
  0x41a238		eb35			JMP 0x41a26f		
  0x41a23a		4889c2			MOVQ AX, DX		
		h.free[i].init()
  0x41a23d		48c1e004		SHLQ $0x4, AX		
	list.first = nil
  0x41a241		48c744010800000000	MOVQ $0x0, 0x8(CX)(AX*1)	
	list.last = nil
  0x41a24a		48c744011000000000	MOVQ $0x0, 0x10(CX)(AX*1)	
	list.first = nil
  0x41a253		48c784011008000000000000	MOVQ $0x0, 0x810(CX)(AX*1)	
	list.last = nil
  0x41a25f		48c784011808000000000000	MOVQ $0x0, 0x818(CX)(AX*1)	
	for i := range h.free {
  0x41a26b		488d4201		LEAQ 0x1(DX), AX	
  0x41a26f		483d80000000		CMPQ $0x80, AX		
  0x41a275		7cc3			JL 0x41a23a		
	h.busylarge.init()
  0x41a277		488d9110100000		LEAQ 0x1010(CX), DX	
	list.first = nil
  0x41a27e		8402			TESTB AL, 0(DX)		
	list.last = nil
  0x41a280		0f118110100000		MOVUPS X0, 0x1010(CX)	
  0x41a287		31c0			XORL AX, AX		
	for i := range h.central {
  0x41a289		eb60			JMP 0x41a2eb		
  0x41a28b		4889c2			MOVQ AX, DX		
		h.central[i].mcentral.init(spanClass(i))
  0x41a28e		48c1e006		SHLQ $0x6, AX			
  0x41a292		488d9c0150130000	LEAQ 0x1350(CX)(AX*1), BX	
	c.spanclass = spc
  0x41a29a		8403			TESTB AL, 0(BX)			
  0x41a29c		88940158130000		MOVB DL, 0x1358(CX)(AX*1)	
	c.nonempty.init()
  0x41a2a3		488d9c0160130000	LEAQ 0x1360(CX)(AX*1), BX	
	list.first = nil
  0x41a2ab		8403				TESTB AL, 0(BX)			
  0x41a2ad		48c784016013000000000000	MOVQ $0x0, 0x1360(CX)(AX*1)	
	list.last = nil
  0x41a2b9		48c784016813000000000000	MOVQ $0x0, 0x1368(CX)(AX*1)	
	c.empty.init()
  0x41a2c5		488d9c0170130000	LEAQ 0x1370(CX)(AX*1), BX	
	list.first = nil
  0x41a2cd		8403				TESTB AL, 0(BX)			
  0x41a2cf		48c784017013000000000000	MOVQ $0x0, 0x1370(CX)(AX*1)	
	list.last = nil
  0x41a2db		48c784017813000000000000	MOVQ $0x0, 0x1378(CX)(AX*1)	
	for i := range h.central {
  0x41a2e7		488d4201		LEAQ 0x1(DX), AX	
  0x41a2eb		483d86000000		CMPQ $0x86, AX		
  0x41a2f1		7c98			JL 0x41a28b		
	sp := (*slice)(unsafe.Pointer(&h.spans))
  0x41a2f3		488d9148100000		LEAQ 0x1048(CX), DX	
	sp.array = unsafe.Pointer(spansStart)
  0x41a2fa		8402			TESTB AL, 0(DX)				
  0x41a2fc		8b150e970a00		MOVL runtime.writeBarrier(SB), DX	
  0x41a302		488db948100000		LEAQ 0x1048(CX), DI			
  0x41a309		488b442430		MOVQ 0x30(SP), AX			
  0x41a30e		85d2			TESTL DX, DX				
  0x41a310		7546			JNE 0x41a358				
  0x41a312		48898148100000		MOVQ AX, 0x1048(CX)			
	sp.len = 0
  0x41a319		48c7815010000000000000	MOVQ $0x0, 0x1050(CX)	
  0x41a324		488b442438		MOVQ 0x38(SP), AX	
	sp.cap = int(spansBytes / sys.PtrSize)
  0x41a329		48c1e803		SHRQ $0x3, AX		
  0x41a32d		48898158100000		MOVQ AX, 0x1058(CX)	
	h.setArenaUsed(h.arena_used, false)
  0x41a334		488b8130130000		MOVQ 0x1330(CX), AX			
  0x41a33b		4889442408		MOVQ AX, 0x8(SP)			
  0x41a340		48890c24		MOVQ CX, 0(SP)				
  0x41a344		c644241000		MOVB $0x0, 0x10(SP)			
  0x41a349		e822010000		CALL runtime.(*mheap).setArenaUsed(SB)	
}
  0x41a34e		488b6c2418		MOVQ 0x18(SP), BP	
  0x41a353		4883c420		ADDQ $0x20, SP		
  0x41a357		c3			RET			
	sp.array = unsafe.Pointer(spansStart)
  0x41a358		e843c50200		CALL runtime.gcWriteBarrier(SB)	
  0x41a35d		ebba			JMP 0x41a319			
	f.stat = stat
  0x41a35f		e83cc50200		CALL runtime.gcWriteBarrier(SB)	
  0x41a364		0f57c0			XORPS X0, X0			
  0x41a367		e9bcfeffff		JMP 0x41a228			
	f.first = first
  0x41a36c		31c0			XORL AX, AX			
  0x41a36e		e82dc50200		CALL runtime.gcWriteBarrier(SB)	
  0x41a373		4889df			MOVQ BX, DI			
	f.arg = arg
  0x41a376		31c0			XORL AX, AX				
  0x41a378		e823c50200		CALL runtime.gcWriteBarrier(SB)		
  0x41a37d		488d051ca40a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a384		0f57c0			XORPS X0, X0				
	f.first = first
  0x41a387		e964feffff		JMP 0x41a1f0		
	f.stat = stat
  0x41a38c		e80fc50200		CALL runtime.gcWriteBarrier(SB)	
  0x41a391		0f57c0			XORPS X0, X0			
  0x41a394		e919feffff		JMP 0x41a1b2			
	f.first = first
  0x41a399		31c0			XORL AX, AX			
  0x41a39b		e800c50200		CALL runtime.gcWriteBarrier(SB)	
  0x41a3a0		4889df			MOVQ BX, DI			
	f.arg = arg
  0x41a3a3		31c0			XORL AX, AX				
  0x41a3a5		e8f6c40200		CALL runtime.gcWriteBarrier(SB)		
  0x41a3aa		488d05efa30a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a3b1		0f57c0			XORPS X0, X0				
	f.first = first
  0x41a3b4		e9c1fdffff		JMP 0x41a17a		
	f.stat = stat
  0x41a3b9		488d05c8a30a00		LEAQ runtime.memstats+136(SB), AX	
  0x41a3c0		e8dbc40200		CALL runtime.gcWriteBarrier(SB)		
  0x41a3c5		488d05d4a30a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a3cc		0f57c0			XORPS X0, X0				
  0x41a3cf		e968fdffff		JMP 0x41a13c				
	f.first = first
  0x41a3d4		31c0			XORL AX, AX			
  0x41a3d6		e8c5c40200		CALL runtime.gcWriteBarrier(SB)	
  0x41a3db		4889df			MOVQ BX, DI			
	f.arg = arg
  0x41a3de		31c0			XORL AX, AX				
  0x41a3e0		e8bbc40200		CALL runtime.gcWriteBarrier(SB)		
  0x41a3e5		488d05b4a30a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a3ec		0f57c0			XORPS X0, X0				
	f.first = first
  0x41a3ef		e909fdffff		JMP 0x41a0fd		
	f.stat = stat
  0x41a3f4		488d057da30a00		LEAQ runtime.memstats+120(SB), AX	
  0x41a3fb		e8a0c40200		CALL runtime.gcWriteBarrier(SB)		
  0x41a400		488d0599a30a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a407		0f57c0			XORPS X0, X0				
  0x41a40a		e9b0fcffff		JMP 0x41a0bf				
	f.first = first
  0x41a40f		488d05aa3d0500		LEAQ 0x53daa(IP), AX		
  0x41a416		e885c40200		CALL runtime.gcWriteBarrier(SB)	
  0x41a41b		4889df			MOVQ BX, DI			
  0x41a41e		4889c8			MOVQ CX, AX			
	f.arg = arg
  0x41a421		e87ac40200		CALL runtime.gcWriteBarrier(SB)		
  0x41a426		488d0573a30a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a42d		0f57c0			XORPS X0, X0				
	f.first = first
  0x41a430		e94bfcffff		JMP 0x41a080		
	f.stat = stat
  0x41a435		488d0564a30a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a43c		e85fc40200		CALL runtime.gcWriteBarrier(SB)		
  0x41a441		0f57c0			XORPS X0, X0				
  0x41a444		e9ebfbffff		JMP 0x41a034				
	f.first = first
  0x41a449		31c0			XORL AX, AX			
  0x41a44b		e850c40200		CALL runtime.gcWriteBarrier(SB)	
  0x41a450		4889df			MOVQ BX, DI			
	f.arg = arg
  0x41a453		31c0			XORL AX, AX			
  0x41a455		e846c40200		CALL runtime.gcWriteBarrier(SB)	
	f.first = first
  0x41a45a		e993fbffff		JMP 0x419ff2		
func (h *mheap) init(spansStart, spansBytes uintptr) {
  0x41a45f		e80ca10200		CALL runtime.morestack_noctxt(SB)	
  0x41a464		e927fbffff		JMP runtime.(*mheap).init(SB)		

TEXT runtime.(*mheap).setArenaUsed(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) setArenaUsed(arena_used uintptr, racemap bool) {
  0x41a470		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a479		483b6110		CMPQ 0x10(CX), SP	
  0x41a47d		765b			JBE 0x41a4da		
  0x41a47f		4883ec18		SUBQ $0x18, SP		
  0x41a483		48896c2410		MOVQ BP, 0x10(SP)	
  0x41a488		488d6c2410		LEAQ 0x10(SP), BP	
  0x41a48d		488b442420		MOVQ 0x20(SP), AX	
	h.mapBits(arena_used)
  0x41a492		48890424		MOVQ AX, 0(SP)		
func (h *mheap) setArenaUsed(arena_used uintptr, racemap bool) {
  0x41a496		488b4c2428		MOVQ 0x28(SP), CX	
	h.mapBits(arena_used)
  0x41a49b		48894c2408		MOVQ CX, 0x8(SP)			
  0x41a4a0		e83b19ffff		CALL runtime.(*mheap).mapBits(SB)	
  0x41a4a5		488b442420		MOVQ 0x20(SP), AX			
	h.mapSpans(arena_used)
  0x41a4aa		48890424		MOVQ AX, 0(SP)				
  0x41a4ae		488b4c2428		MOVQ 0x28(SP), CX			
  0x41a4b3		48894c2408		MOVQ CX, 0x8(SP)			
  0x41a4b8		e833000000		CALL runtime.(*mheap).mapSpans(SB)	
  0x41a4bd		488b442420		MOVQ 0x20(SP), AX			
	h.arena_used = arena_used
  0x41a4c2		8400			TESTB AL, 0(AX)		
  0x41a4c4		488b4c2428		MOVQ 0x28(SP), CX	
  0x41a4c9		48898830130000		MOVQ CX, 0x1330(AX)	
}
  0x41a4d0		488b6c2410		MOVQ 0x10(SP), BP	
  0x41a4d5		4883c418		ADDQ $0x18, SP		
  0x41a4d9		c3			RET			
func (h *mheap) setArenaUsed(arena_used uintptr, racemap bool) {
  0x41a4da		e891a00200		CALL runtime.morestack_noctxt(SB)	
  0x41a4df		eb8f			JMP runtime.(*mheap).setArenaUsed(SB)	

TEXT runtime.(*mheap).mapSpans(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) mapSpans(arena_used uintptr) {
  0x41a4f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a4f9		483b6110		CMPQ 0x10(CX), SP	
  0x41a4fd		0f86bb000000		JBE 0x41a5be		
  0x41a503		4883ec28		SUBQ $0x28, SP		
  0x41a507		48896c2420		MOVQ BP, 0x20(SP)	
  0x41a50c		488d6c2420		LEAQ 0x20(SP), BP	
  0x41a511		488b442430		MOVQ 0x30(SP), AX	
	n -= h.arena_start
  0x41a516		8400			TESTB AL, 0(AX)		
func (h *mheap) mapSpans(arena_used uintptr) {
  0x41a518		488b4c2438		MOVQ 0x38(SP), CX	
	n -= h.arena_start
  0x41a51d		482b8828130000		SUBQ 0x1328(AX), CX	
	n = n / _PageSize * sys.PtrSize
  0x41a524		48c1e90d		SHRQ $0xd, CX		
	n = round(n, physPageSize)
  0x41a528		488b1571940a00		MOVQ runtime.physPageSize(SB), DX	
	return (n + a - 1) &^ (a - 1)
  0x41a52f		488d4ccaff		LEAQ -0x1(DX)(CX*8), CX	
  0x41a534		48ffca			DECQ DX			
  0x41a537		48f7d2			NOTQ DX			
  0x41a53a		4821d1			ANDQ DX, CX		
	need := n / unsafe.Sizeof(h.spans[0])
  0x41a53d		48c1e903		SHRQ $0x3, CX		
	have := uintptr(len(h.spans))
  0x41a541		488b9058100000		MOVQ 0x1058(AX), DX	
  0x41a548		488b9850100000		MOVQ 0x1050(AX), BX	
	if have >= need {
  0x41a54f		4839cb			CMPQ CX, BX		
  0x41a552		7352			JAE 0x41a5a6		
	h.spans = h.spans[:need]
  0x41a554		4839d1			CMPQ DX, CX		
  0x41a557		775e			JA 0x41a5b7		
  0x41a559		48898850100000		MOVQ CX, 0x1050(AX)	
	sysMap(unsafe.Pointer(&h.spans[have]), (need-have)*unsafe.Sizeof(h.spans[0]), h.arena_reserved, &memstats.other_sys)
  0x41a560		488b9048100000		MOVQ 0x1048(AX), DX	
	if have >= need {
  0x41a567		4839cb			CMPQ CX, BX		
	sysMap(unsafe.Pointer(&h.spans[have]), (need-have)*unsafe.Sizeof(h.spans[0]), h.arena_reserved, &memstats.other_sys)
  0x41a56a		7344			JAE 0x41a5b0				
  0x41a56c		0fb68048130000		MOVZX 0x1348(AX), AX			
  0x41a573		88442410		MOVB AL, 0x10(SP)			
  0x41a577		488d04da		LEAQ 0(DX)(BX*8), AX			
  0x41a57b		48890424		MOVQ AX, 0(SP)				
  0x41a57f		4829d9			SUBQ BX, CX				
  0x41a582		48c1e103		SHLQ $0x3, CX				
  0x41a586		48894c2408		MOVQ CX, 0x8(SP)			
  0x41a58b		488d050ea20a00		LEAQ runtime.memstats+160(SB), AX	
  0x41a592		4889442418		MOVQ AX, 0x18(SP)			
  0x41a597		e8a44fffff		CALL runtime.sysMap(SB)			
}
  0x41a59c		488b6c2420		MOVQ 0x20(SP), BP	
  0x41a5a1		4883c428		ADDQ $0x28, SP		
  0x41a5a5		c3			RET			
		return
  0x41a5a6		488b6c2420		MOVQ 0x20(SP), BP	
  0x41a5ab		4883c428		ADDQ $0x28, SP		
  0x41a5af		c3			RET			
	sysMap(unsafe.Pointer(&h.spans[have]), (need-have)*unsafe.Sizeof(h.spans[0]), h.arena_reserved, &memstats.other_sys)
  0x41a5b0		e88b540000		CALL runtime.panicindex(SB)	
  0x41a5b5		0f0b			UD2				
	h.spans = h.spans[:need]
  0x41a5b7		e8f4540000		CALL runtime.panicslice(SB)	
  0x41a5bc		0f0b			UD2				
func (h *mheap) mapSpans(arena_used uintptr) {
  0x41a5be		e8ad9f0200		CALL runtime.morestack_noctxt(SB)	
  0x41a5c3		e928ffffff		JMP runtime.(*mheap).mapSpans(SB)	

TEXT runtime.(*mheap).reclaimList(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) reclaimList(list *mSpanList, npages uintptr) uintptr {
  0x41a5d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a5d9		483b6110		CMPQ 0x10(CX), SP	
  0x41a5dd		0f8636010000		JBE 0x41a719		
  0x41a5e3		4883ec48		SUBQ $0x48, SP		
  0x41a5e7		48896c2440		MOVQ BP, 0x40(SP)	
  0x41a5ec		488d6c2440		LEAQ 0x40(SP), BP	
	sg := mheap_.sweepgen
  0x41a5f1		8b0dc92c0900		MOVL runtime.mheap_+4128(SB), CX	
  0x41a5f7		894c241c		MOVL CX, 0x1c(SP)			
  0x41a5fb		31c0			XORL AX, AX				
retry:
  0x41a5fd		e9e4000000		JMP 0x41a6e6		
	for s := list.first; s != nil; s = s.next {
  0x41a602		488b1b			MOVQ 0(BX), BX		
  0x41a605		4c89c0			MOVQ R8, AX		
  0x41a608		4885db			TESTQ BX, BX		
  0x41a60b		0f8400010000		JE 0x41a711		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41a611		8b7358			MOVL 0x58(BX), SI		
  0x41a614		8d79fe			LEAL -0x2(CX), DI		
  0x41a617		39fe			CMPL DI, SI			
  0x41a619		0f85ea000000		JNE 0x41a709			
  0x41a61f		8d71ff			LEAL -0x1(CX), SI		
  0x41a622		4989c0			MOVQ AX, R8			
  0x41a625		89f8			MOVL DI, AX			
  0x41a627		f00fb17358		LOCK CMPXCHGL SI, 0x58(BX)	
  0x41a62c		400f94c6		SETE SI				
  0x41a630		4084f6			TESTL SI, SI			
  0x41a633		7519			JNE 0x41a64e			
		if s.sweepgen == sg-1 {
  0x41a635		8b7358			MOVL 0x58(BX), SI	
  0x41a638		8d79ff			LEAL -0x1(CX), DI	
  0x41a63b		39fe			CMPL DI, SI		
  0x41a63d		74c3			JE 0x41a602		
	return n
  0x41a63f		4c89442468		MOVQ R8, 0x68(SP)	
  0x41a644		488b6c2440		MOVQ 0x40(SP), BP	
  0x41a649		4883c448		ADDQ $0x48, SP		
  0x41a64d		c3			RET			
  0x41a64e		48895c2438		MOVQ BX, 0x38(SP)	
  0x41a653		4c89442430		MOVQ R8, 0x30(SP)	
			list.remove(s)
  0x41a658		48891424		MOVQ DX, 0(SP)				
  0x41a65c		48895c2408		MOVQ BX, 0x8(SP)			
  0x41a661		e84a1a0000		CALL runtime.(*mSpanList).remove(SB)	
  0x41a666		488b442458		MOVQ 0x58(SP), AX			
			list.insertBack(s) // Puts it back on a busy list. s is not in the treap at this point.
  0x41a66b		48890424		MOVQ AX, 0(SP)					
  0x41a66f		488b4c2438		MOVQ 0x38(SP), CX				
  0x41a674		48894c2408		MOVQ CX, 0x8(SP)				
  0x41a679		e8f21c0000		CALL runtime.(*mSpanList).insertBack(SB)	
  0x41a67e		488b442450		MOVQ 0x50(SP), AX				
			unlock(&h.lock)
  0x41a683		8400			TESTB AL, 0(AX)		
  0x41a685		48890424		MOVQ AX, 0(SP)		
  0x41a689		e832f0feff		CALL runtime.unlock(SB)	
  0x41a68e		488b442438		MOVQ 0x38(SP), AX	
			snpages := s.npages
  0x41a693		488b4820		MOVQ 0x20(AX), CX	
  0x41a697		48894c2420		MOVQ CX, 0x20(SP)	
			if s.sweep(false) {
  0x41a69c		48890424		MOVQ AX, 0(SP)			
  0x41a6a0		c644240800		MOVB $0x0, 0x8(SP)		
  0x41a6a5		e816d9ffff		CALL runtime.(*mspan).sweep(SB)	
  0x41a6aa		0fb6442410		MOVZX 0x10(SP), AX		
  0x41a6af		84c0			TESTL AL, AL			
  0x41a6b1		744f			JE 0x41a702			
  0x41a6b3		488b442420		MOVQ 0x20(SP), AX		
  0x41a6b8		488b4c2430		MOVQ 0x30(SP), CX		
				n += snpages
  0x41a6bd		4801c8			ADDQ CX, AX		
  0x41a6c0		4889442428		MOVQ AX, 0x28(SP)	
  0x41a6c5		488b4c2450		MOVQ 0x50(SP), CX	
			lock(&h.lock)
  0x41a6ca		48890c24		MOVQ CX, 0(SP)		
  0x41a6ce		e84deefeff		CALL runtime.lock(SB)	
  0x41a6d3		488b442428		MOVQ 0x28(SP), AX	
  0x41a6d8		488b4c2460		MOVQ 0x60(SP), CX	
			if n >= npages {
  0x41a6dd		4839c8			CMPQ CX, AX		
  0x41a6e0		7311			JAE 0x41a6f3		
  0x41a6e2		8b4c241c		MOVL 0x1c(SP), CX	
			goto retry
  0x41a6e6		488b542458		MOVQ 0x58(SP), DX	
	for s := list.first; s != nil; s = s.next {
  0x41a6eb		488b1a			MOVQ 0(DX), BX		
  0x41a6ee		e915ffffff		JMP 0x41a608		
				return n
  0x41a6f3		4889442468		MOVQ AX, 0x68(SP)	
  0x41a6f8		488b6c2440		MOVQ 0x40(SP), BP	
  0x41a6fd		4883c448		ADDQ $0x48, SP		
  0x41a701		c3			RET			
  0x41a702		488b442430		MOVQ 0x30(SP), AX	
			lock(&h.lock)
  0x41a707		ebb7			JMP 0x41a6c0		
  0x41a709		4989c0			MOVQ AX, R8		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41a70c		e924ffffff		JMP 0x41a635		
  0x41a711		4989c0			MOVQ AX, R8		
	for s := list.first; s != nil; s = s.next {
  0x41a714		e926ffffff		JMP 0x41a63f		
func (h *mheap) reclaimList(list *mSpanList, npages uintptr) uintptr {
  0x41a719		e8529e0200		CALL runtime.morestack_noctxt(SB)	
  0x41a71e		e9adfeffff		JMP runtime.(*mheap).reclaimList(SB)	

TEXT runtime.(*mheap).reclaim(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) reclaim(npage uintptr) {
  0x41a730		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a739		483b6110		CMPQ 0x10(CX), SP	
  0x41a73d		0f8691010000		JBE 0x41a8d4		
  0x41a743		4883ec40		SUBQ $0x40, SP		
  0x41a747		48896c2438		MOVQ BP, 0x38(SP)	
  0x41a74c		488d6c2438		LEAQ 0x38(SP), BP	
  0x41a751		488b442450		MOVQ 0x50(SP), AX	
	for i := int(npage); i < len(h.busy); i++ {
  0x41a756		eb09			JMP 0x41a761		
  0x41a758		488b4c2430		MOVQ 0x30(SP), CX	
  0x41a75d		488d4101		LEAQ 0x1(CX), AX	
  0x41a761		483d80000000		CMPQ $0x80, AX		
  0x41a767		7d50			JGE 0x41a7b9		
  0x41a769		488b4c2448		MOVQ 0x48(SP), CX	
		if h.reclaimList(&h.busy[i], npage) != 0 {
  0x41a76e		8401			TESTB AL, 0(CX)		
	for i := int(npage); i < len(h.busy); i++ {
  0x41a770		483d80000000		CMPQ $0x80, AX		
		if h.reclaimList(&h.busy[i], npage) != 0 {
  0x41a776		0f8351010000		JAE 0x41a8cd				
  0x41a77c		4889442430		MOVQ AX, 0x30(SP)			
  0x41a781		48c1e004		SHLQ $0x4, AX				
  0x41a785		488d840810080000	LEAQ 0x810(AX)(CX*1), AX		
  0x41a78d		4889442408		MOVQ AX, 0x8(SP)			
  0x41a792		48890c24		MOVQ CX, 0(SP)				
  0x41a796		488b442450		MOVQ 0x50(SP), AX			
  0x41a79b		4889442410		MOVQ AX, 0x10(SP)			
  0x41a7a0		e82bfeffff		CALL runtime.(*mheap).reclaimList(SB)	
  0x41a7a5		488b442418		MOVQ 0x18(SP), AX			
  0x41a7aa		4885c0			TESTQ AX, AX				
  0x41a7ad		74a9			JE 0x41a758				
			return // Bingo!
  0x41a7af		488b6c2438		MOVQ 0x38(SP), BP	
  0x41a7b4		4883c440		ADDQ $0x40, SP		
  0x41a7b8		c3			RET			
  0x41a7b9		488b442448		MOVQ 0x48(SP), AX	
	if h.reclaimList(&h.busylarge, npage) != 0 {
  0x41a7be		8400			TESTB AL, 0(AX)				
  0x41a7c0		488d8810100000		LEAQ 0x1010(AX), CX			
  0x41a7c7		48894c2408		MOVQ CX, 0x8(SP)			
  0x41a7cc		48890424		MOVQ AX, 0(SP)				
  0x41a7d0		488b4c2450		MOVQ 0x50(SP), CX			
  0x41a7d5		48894c2410		MOVQ CX, 0x10(SP)			
  0x41a7da		e8f1fdffff		CALL runtime.(*mheap).reclaimList(SB)	
  0x41a7df		488b442418		MOVQ 0x18(SP), AX			
  0x41a7e4		4885c0			TESTQ AX, AX				
  0x41a7e7		0f85cf000000		JNE 0x41a8bc				
  0x41a7ed		31c0			XORL AX, AX				
  0x41a7ef		31c9			XORL CX, CX				
	for i := 0; i < int(npage) && i < len(h.busy); i++ {
  0x41a7f1		eb0e			JMP 0x41a801		
  0x41a7f3		488b542428		MOVQ 0x28(SP), DX	
  0x41a7f8		48ffc2			INCQ DX			
  0x41a7fb		4889c1			MOVQ AX, CX		
  0x41a7fe		4889d0			MOVQ DX, AX		
  0x41a801		48894c2420		MOVQ CX, 0x20(SP)	
  0x41a806		488b542450		MOVQ 0x50(SP), DX	
  0x41a80b		4839d0			CMPQ DX, AX		
  0x41a80e		7d5b			JGE 0x41a86b		
  0x41a810		483d80000000		CMPQ $0x80, AX		
  0x41a816		7d53			JGE 0x41a86b		
		reclaimed += h.reclaimList(&h.busy[i], npage-reclaimed)
  0x41a818		0f83a8000000		JAE 0x41a8c6				
  0x41a81e		4889442428		MOVQ AX, 0x28(SP)			
  0x41a823		48c1e004		SHLQ $0x4, AX				
  0x41a827		488b742448		MOVQ 0x48(SP), SI			
  0x41a82c		488d843010080000	LEAQ 0x810(AX)(SI*1), AX		
  0x41a834		4889442408		MOVQ AX, 0x8(SP)			
  0x41a839		48893424		MOVQ SI, 0(SP)				
  0x41a83d		4829ca			SUBQ CX, DX				
  0x41a840		4889542410		MOVQ DX, 0x10(SP)			
  0x41a845		e886fdffff		CALL runtime.(*mheap).reclaimList(SB)	
  0x41a84a		488b442418		MOVQ 0x18(SP), AX			
  0x41a84f		488b4c2420		MOVQ 0x20(SP), CX			
  0x41a854		4801c8			ADDQ CX, AX				
  0x41a857		488b4c2450		MOVQ 0x50(SP), CX			
		if reclaimed >= npage {
  0x41a85c		4839c8			CMPQ CX, AX		
  0x41a85f		7292			JB 0x41a7f3		
			return
  0x41a861		488b6c2438		MOVQ 0x38(SP), BP	
  0x41a866		4883c440		ADDQ $0x40, SP		
  0x41a86a		c3			RET			
  0x41a86b		488b442448		MOVQ 0x48(SP), AX	
	unlock(&h.lock)
  0x41a870		48890424		MOVQ AX, 0(SP)		
  0x41a874		e847eefeff		CALL runtime.unlock(SB)	
  0x41a879		488b442420		MOVQ 0x20(SP), AX	
	for {
  0x41a87e		4889442420		MOVQ AX, 0x20(SP)	
		n := sweepone()
  0x41a883		e838d2ffff		CALL runtime.sweepone(SB)	
  0x41a888		488b0424		MOVQ 0(SP), AX			
		if n == ^uintptr(0) { // all spans are swept
  0x41a88c		4883f8ff		CMPQ $-0x1, AX		
  0x41a890		7412			JE 0x41a8a4		
  0x41a892		488b4c2420		MOVQ 0x20(SP), CX	
		reclaimed += n
  0x41a897		4801c8			ADDQ CX, AX		
  0x41a89a		488b4c2450		MOVQ 0x50(SP), CX	
		if reclaimed >= npage {
  0x41a89f		4839c8			CMPQ CX, AX		
  0x41a8a2		72da			JB 0x41a87e		
  0x41a8a4		488b442448		MOVQ 0x48(SP), AX	
	lock(&h.lock)
  0x41a8a9		48890424		MOVQ AX, 0(SP)		
  0x41a8ad		e86eecfeff		CALL runtime.lock(SB)	
}
  0x41a8b2		488b6c2438		MOVQ 0x38(SP), BP	
  0x41a8b7		4883c440		ADDQ $0x40, SP		
  0x41a8bb		c3			RET			
		return // Bingo!
  0x41a8bc		488b6c2438		MOVQ 0x38(SP), BP	
  0x41a8c1		4883c440		ADDQ $0x40, SP		
  0x41a8c5		c3			RET			
		reclaimed += h.reclaimList(&h.busy[i], npage-reclaimed)
  0x41a8c6		e875510000		CALL runtime.panicindex(SB)	
  0x41a8cb		0f0b			UD2				
		if h.reclaimList(&h.busy[i], npage) != 0 {
  0x41a8cd		e86e510000		CALL runtime.panicindex(SB)	
  0x41a8d2		0f0b			UD2				
func (h *mheap) reclaim(npage uintptr) {
  0x41a8d4		e8979c0200		CALL runtime.morestack_noctxt(SB)	
  0x41a8d9		e952feffff		JMP runtime.(*mheap).reclaim(SB)	

TEXT runtime.(*mheap).alloc_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {
  0x41a8e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a8e9		483b6110		CMPQ 0x10(CX), SP	
  0x41a8ed		0f8606030000		JBE 0x41abf9		
  0x41a8f3		4883ec38		SUBQ $0x38, SP		
  0x41a8f7		48896c2430		MOVQ BP, 0x30(SP)	
  0x41a8fc		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x41a901		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_ != _g_.m.g0 {
  0x41a90a		488b4830		MOVQ 0x30(AX), CX	
  0x41a90e		488b09			MOVQ 0(CX), CX		
  0x41a911		4839c8			CMPQ CX, AX		
  0x41a914		0f85c4020000		JNE 0x41abde		
  0x41a91a		4889442428		MOVQ AX, 0x28(SP)	
  0x41a91f		488b442440		MOVQ 0x40(SP), AX	
	lock(&h.lock)
  0x41a924		8400			TESTB AL, 0(AX)		
  0x41a926		48890424		MOVQ AX, 0(SP)		
  0x41a92a		e8f1ebfeff		CALL runtime.lock(SB)	
  0x41a92f		488b442440		MOVQ 0x40(SP), AX	
	if h.sweepdone == 0 {
  0x41a934		8b8824100000		MOVL 0x1024(AX), CX	
  0x41a93a		85c9			TESTL CX, CX		
  0x41a93c		7531			JNE 0x41a96f		
		if trace.enabled {
  0x41a93e		0fb60d8b8e0900		MOVZX runtime.trace+16(SB), CX	
  0x41a945		84c9			TESTL CL, CL			
  0x41a947		0f857b020000		JNE 0x41abc8			
		h.reclaim(npage)
  0x41a94d		48890424		MOVQ AX, 0(SP)				
  0x41a951		488b4c2448		MOVQ 0x48(SP), CX			
  0x41a956		48894c2408		MOVQ CX, 0x8(SP)			
  0x41a95b		e8d0fdffff		CALL runtime.(*mheap).reclaim(SB)	
		if trace.enabled {
  0x41a960		0fb605698e0900		MOVZX runtime.trace+16(SB), AX	
  0x41a967		84c0			TESTL AL, AL			
  0x41a969		0f854f020000		JNE 0x41abbe			
  0x41a96f		488b442428		MOVQ 0x28(SP), AX		
	memstats.heap_scan += uint64(_g_.m.mcache.local_scan)
  0x41a974		488b4830		MOVQ 0x30(AX), CX			
  0x41a978		488b8960010000		MOVQ 0x160(CX), CX			
  0x41a97f		488b4908		MOVQ 0x8(CX), CX			
  0x41a983		48030dbeb40a00		ADDQ runtime.memstats+5960(SB), CX	
  0x41a98a		48890db7b40a00		MOVQ CX, runtime.memstats+5960(SB)	
	_g_.m.mcache.local_scan = 0
  0x41a991		488b4830		MOVQ 0x30(AX), CX	
  0x41a995		488b8960010000		MOVQ 0x160(CX), CX	
  0x41a99c		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	memstats.tinyallocs += uint64(_g_.m.mcache.local_tinyallocs)
  0x41a9a4		488b4830		MOVQ 0x30(AX), CX			
  0x41a9a8		488b8960010000		MOVQ 0x160(CX), CX			
  0x41a9af		488b4920		MOVQ 0x20(CX), CX			
  0x41a9b3		48030d6eb40a00		ADDQ runtime.memstats+5928(SB), CX	
  0x41a9ba		48890d67b40a00		MOVQ CX, runtime.memstats+5928(SB)	
	_g_.m.mcache.local_tinyallocs = 0
  0x41a9c1		488b4030		MOVQ 0x30(AX), AX	
  0x41a9c5		488b8060010000		MOVQ 0x160(AX), AX	
  0x41a9cc		48c7402000000000	MOVQ $0x0, 0x20(AX)	
  0x41a9d4		488b442440		MOVQ 0x40(SP), AX	
	s := h.allocSpanLocked(npage, &memstats.heap_inuse)
  0x41a9d9		48890424		MOVQ AX, 0(SP)					
  0x41a9dd		488b4c2448		MOVQ 0x48(SP), CX				
  0x41a9e2		48894c2408		MOVQ CX, 0x8(SP)				
  0x41a9e7		488d155a9d0a00		LEAQ runtime.memstats+72(SB), DX		
  0x41a9ee		4889542410		MOVQ DX, 0x10(SP)				
  0x41a9f3		e8e8030000		CALL runtime.(*mheap).allocSpanLocked(SB)	
  0x41a9f8		488b442418		MOVQ 0x18(SP), AX				
  0x41a9fd		4889442420		MOVQ AX, 0x20(SP)				
	if s != nil {
  0x41aa02		4885c0			TESTQ AX, AX		
  0x41aa05		7555			JNE 0x41aa5c		
	if gcBlackenEnabled != 0 {
  0x41aa07		8b0dc78e0a00		MOVL runtime.gcBlackenEnabled(SB), CX	
  0x41aa0d		85c9			TESTL CX, CX				
  0x41aa0f		7534			JNE 0x41aa45				
	if trace.enabled {
  0x41aa11		0fb60db88d0900		MOVZX runtime.trace+16(SB), CX	
  0x41aa18		84c9			TESTL CL, CL			
  0x41aa1a		7522			JNE 0x41aa3e			
  0x41aa1c		488b442440		MOVQ 0x40(SP), AX		
	unlock(&h.lock)
  0x41aa21		48890424		MOVQ AX, 0(SP)		
  0x41aa25		e896ecfeff		CALL runtime.unlock(SB)	
	return s
  0x41aa2a		488b442420		MOVQ 0x20(SP), AX	
  0x41aa2f		4889442458		MOVQ AX, 0x58(SP)	
  0x41aa34		488b6c2430		MOVQ 0x30(SP), BP	
  0x41aa39		4883c438		ADDQ $0x38, SP		
  0x41aa3d		c3			RET			
		traceHeapAlloc()
  0x41aa3e		e89d050200		CALL runtime.traceHeapAlloc(SB)	
  0x41aa43		ebd7			JMP 0x41aa1c			
		gcController.revise()
  0x41aa45		488d05d4910a00		LEAQ runtime.gcController(SB), AX		
  0x41aa4c		48890424		MOVQ AX, 0(SP)					
  0x41aa50		e86b58ffff		CALL runtime.(*gcControllerState).revise(SB)	
  0x41aa55		488b442420		MOVQ 0x20(SP), AX				
  0x41aa5a		ebb5			JMP 0x41aa11					
  0x41aa5c		488b4c2440		MOVQ 0x40(SP), CX				
		atomic.Store(&s.sweepgen, h.sweepgen)
  0x41aa61		8b9120100000		MOVL 0x1020(CX), DX	
  0x41aa67		875058			XCHGL DX, 0x58(AX)	
		h.sweepSpans[h.sweepgen/2%2].push(s) // Add to swept in-use list.
  0x41aa6a		8b9120100000		MOVL 0x1020(CX), DX			
  0x41aa70		d1ea			SHRL $0x1, DX				
  0x41aa72		83e201			ANDL $0x1, DX				
  0x41aa75		488d1492		LEAQ 0(DX)(DX*4), DX			
  0x41aa79		488d94d160100000	LEAQ 0x1060(CX)(DX*8), DX		
  0x41aa81		48891424		MOVQ DX, 0(SP)				
  0x41aa85		4889442408		MOVQ AX, 0x8(SP)			
  0x41aa8a		e801e0ffff		CALL runtime.(*gcSweepBuf).push(SB)	
  0x41aa8f		488b442420		MOVQ 0x20(SP), AX			
		s.state = _MSpanInUse
  0x41aa94		c6406401		MOVB $0x1, 0x64(AX)	
		s.allocCount = 0
  0x41aa98		66c740600000		MOVW $0x0, 0x60(AX)	
  0x41aa9e		0fb64c2450		MOVZX 0x50(SP), CX	
		s.spanclass = spanclass
  0x41aaa3		884862			MOVB CL, 0x62(AX)	
	return int8(sc >> 1)
  0x41aaa6		d0e9			SHRL $0x1, CL		
		if sizeclass := spanclass.sizeclass(); sizeclass == 0 {
  0x41aaa8		f6c1ff			TESTL $0xff, CL		
  0x41aaab		0f85bc000000		JNE 0x41ab6d		
			s.elemsize = s.npages << _PageShift
  0x41aab1		488b4820		MOVQ 0x20(AX), CX	
  0x41aab5		48c1e10d		SHLQ $0xd, CX		
  0x41aab9		48894868		MOVQ CX, 0x68(AX)	
			s.divShift = 0
  0x41aabd		c6406600		MOVB $0x0, 0x66(AX)	
			s.divMul = 0
  0x41aac1		66c7405c0000		MOVW $0x0, 0x5c(AX)	
			s.divShift2 = 0
  0x41aac7		c6406700		MOVB $0x0, 0x67(AX)	
			s.baseMask = 0
  0x41aacb		66c7405e0000		MOVW $0x0, 0x5e(AX)	
  0x41aad1		488b4c2440		MOVQ 0x40(SP), CX	
		h.pagesInUse += uint64(npage)
  0x41aad6		488b91b8100000		MOVQ 0x10b8(CX), DX	
  0x41aadd		488b5c2448		MOVQ 0x48(SP), BX	
  0x41aae2		4801da			ADDQ BX, DX		
  0x41aae5		488991b8100000		MOVQ DX, 0x10b8(CX)	
  0x41aaec		0fb6542451		MOVZX 0x51(SP), DX	
func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {
  0x41aaf1		84d2			TESTL DL, DL		
		if large {
  0x41aaf3		7457			JE 0x41ab4c		
			memstats.heap_objects++
  0x41aaf5		48ff055c9c0a00		INCQ runtime.memstats+88(SB)	
			mheap_.largealloc += uint64(s.elemsize)
  0x41aafc		488b5068		MOVQ 0x68(AX), DX			
  0x41ab00		48031579280900		ADDQ runtime.mheap_+4320(SB), DX	
  0x41ab07		48891572280900		MOVQ DX, runtime.mheap_+4320(SB)	
			mheap_.nlargealloc++
  0x41ab0e		48ff0573280900		INCQ runtime.mheap_+4328(SB)	
			atomic.Xadd64(&memstats.heap_live, int64(npage<<_PageShift))
  0x41ab15		48c1e30d		SHLQ $0xd, BX				
  0x41ab19		488d1520b30a00		LEAQ runtime.memstats+5952(SB), DX	
  0x41ab20		f0480fc11a		LOCK XADDQ BX, 0(DX)			
			if s.npages < uintptr(len(h.busy)) {
  0x41ab25		488b5020		MOVQ 0x20(AX), DX	
  0x41ab29		4881fa80000000		CMPQ $0x80, DX		
  0x41ab30		7324			JAE 0x41ab56		
				h.busy[s.npages].insertBack(s)
  0x41ab32		48c1e204		SHLQ $0x4, DX					
  0x41ab36		488d941110080000	LEAQ 0x810(CX)(DX*1), DX			
  0x41ab3e		48891424		MOVQ DX, 0(SP)					
  0x41ab42		4889442408		MOVQ AX, 0x8(SP)				
  0x41ab47		e824180000		CALL runtime.(*mSpanList).insertBack(SB)	
  0x41ab4c		488b442420		MOVQ 0x20(SP), AX				
	if gcBlackenEnabled != 0 {
  0x41ab51		e9b1feffff		JMP 0x41aa07		
				h.busylarge.insertBack(s)
  0x41ab56		488d9110100000		LEAQ 0x1010(CX), DX				
  0x41ab5d		48891424		MOVQ DX, 0(SP)					
  0x41ab61		4889442408		MOVQ AX, 0x8(SP)				
  0x41ab66		e805180000		CALL runtime.(*mSpanList).insertBack(SB)	
  0x41ab6b		ebdf			JMP 0x41ab4c					
			s.elemsize = uintptr(class_to_size[sizeclass])
  0x41ab6d		480fbec9		MOVSX CL, CX				
  0x41ab71		4883f943		CMPQ $0x43, CX				
  0x41ab75		7360			JAE 0x41abd7				
  0x41ab77		488d1542a60800		LEAQ runtime.class_to_size(SB), DX	
  0x41ab7e		0fb7144a		MOVZX 0(DX)(CX*2), DX			
  0x41ab82		48895068		MOVQ DX, 0x68(AX)			
			m := &class_to_divmagic[sizeclass]
  0x41ab86		488d0c49		LEAQ 0(CX)(CX*2), CX	
  0x41ab8a		4889ca			MOVQ CX, DX		
  0x41ab8d		48d1e1			SHLQ $0x1, CX		
			s.divShift = m.shift
  0x41ab90		488d1d09ab0800		LEAQ runtime.class_to_divmagic(SB), BX	
  0x41ab97		0fb6340b		MOVZX 0(BX)(CX*1), SI			
  0x41ab9b		40887066		MOVB SI, 0x66(AX)			
			s.divMul = m.mul
  0x41ab9f		0fb7745302		MOVZX 0x2(BX)(DX*2), SI	
  0x41aba4		6689705c		MOVW SI, 0x5c(AX)	
			s.divShift2 = m.shift2
  0x41aba8		0fb64c0b01		MOVZX 0x1(BX)(CX*1), CX	
  0x41abad		884867			MOVB CL, 0x67(AX)	
			s.baseMask = m.baseMask
  0x41abb0		0fb74c5304		MOVZX 0x4(BX)(DX*2), CX	
  0x41abb5		6689485e		MOVW CX, 0x5e(AX)	
  0x41abb9		e913ffffff		JMP 0x41aad1		
			traceGCSweepDone()
  0x41abbe		e8edfa0100		CALL runtime.traceGCSweepDone(SB)	
  0x41abc3		e9a7fdffff		JMP 0x41a96f				
			traceGCSweepStart()
  0x41abc8		e8b3f90100		CALL runtime.traceGCSweepStart(SB)	
  0x41abcd		488b442440		MOVQ 0x40(SP), AX			
  0x41abd2		e976fdffff		JMP 0x41a94d				
			s.elemsize = uintptr(class_to_size[sizeclass])
  0x41abd7		e8644e0000		CALL runtime.panicindex(SB)	
  0x41abdc		0f0b			UD2				
		throw("_mheap_alloc not on g0 stack")
  0x41abde		488d0545140500		LEAQ 0x51445(IP), AX	
  0x41abe5		48890424		MOVQ AX, 0(SP)		
  0x41abe9		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x41abf2		e8d9650000		CALL runtime.throw(SB)	
  0x41abf7		0f0b			UD2			
func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {
  0x41abf9		e872990200		CALL runtime.morestack_noctxt(SB)	
  0x41abfe		e9ddfcffff		JMP runtime.(*mheap).alloc_m(SB)	

TEXT runtime.(*mheap).alloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41ac10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ac19		483b6110		CMPQ 0x10(CX), SP	
  0x41ac1d		0f86cb000000		JBE 0x41acee		
  0x41ac23		4883ec48		SUBQ $0x48, SP		
  0x41ac27		48896c2440		MOVQ BP, 0x40(SP)	
  0x41ac2c		488d6c2440		LEAQ 0x40(SP), BP	
	var s *mspan
  0x41ac31		48c744241000000000	MOVQ $0x0, 0x10(SP)	
	systemstack(func() {
  0x41ac3a		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x41ac43		0f57c0			XORPS X0, X0					
  0x41ac46		0f11442420		MOVUPS X0, 0x20(SP)				
  0x41ac4b		0f11442430		MOVUPS X0, 0x30(SP)				
  0x41ac50		488d05097c0200		LEAQ runtime.(*mheap).alloc.func1(SB), AX	
  0x41ac57		4889442418		MOVQ AX, 0x18(SP)				
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41ac5c		488b442450		MOVQ 0x50(SP), AX	
	systemstack(func() {
  0x41ac61		4889442420		MOVQ AX, 0x20(SP)	
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41ac66		488b442458		MOVQ 0x58(SP), AX	
	systemstack(func() {
  0x41ac6b		4889442428		MOVQ AX, 0x28(SP)	
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41ac70		0fb6442460		MOVZX 0x60(SP), AX	
	systemstack(func() {
  0x41ac75		88442430		MOVB AL, 0x30(SP)	
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41ac79		0fb6442461		MOVZX 0x61(SP), AX	
	systemstack(func() {
  0x41ac7e		88442431		MOVB AL, 0x31(SP)		
  0x41ac82		488d442410		LEAQ 0x10(SP), AX		
  0x41ac87		4889442438		MOVQ AX, 0x38(SP)		
  0x41ac8c		488d442418		LEAQ 0x18(SP), AX		
  0x41ac91		48890424		MOVQ AX, 0(SP)			
  0x41ac95		e886970200		CALL runtime.systemstack(SB)	
	if s != nil {
  0x41ac9a		488b442410		MOVQ 0x10(SP), AX	
  0x41ac9f		4885c0			TESTQ AX, AX		
  0x41aca2		741a			JE 0x41acbe		
  0x41aca4		0fb64c2462		MOVZX 0x62(SP), CX	
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41aca9		84c9			TESTL CL, CL		
		if needzero && s.needzero != 0 {
  0x41acab		7408			JE 0x41acb5		
  0x41acad		0fb64865		MOVZX 0x65(AX), CX	
  0x41acb1		84c9			TESTL CL, CL		
  0x41acb3		751d			JNE 0x41acd2		
		s.needzero = 0
  0x41acb5		488b442410		MOVQ 0x10(SP), AX	
  0x41acba		c6406500		MOVB $0x0, 0x65(AX)	
	return s
  0x41acbe		488b442410		MOVQ 0x10(SP), AX	
  0x41acc3		4889442468		MOVQ AX, 0x68(SP)	
  0x41acc8		488b6c2440		MOVQ 0x40(SP), BP	
  0x41accd		4883c448		ADDQ $0x48, SP		
  0x41acd1		c3			RET			
			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages<<_PageShift)
  0x41acd2		488b4820		MOVQ 0x20(AX), CX	
  0x41acd6		48c1e10d		SHLQ $0xd, CX		
	return s.startAddr
  0x41acda		488b4018		MOVQ 0x18(AX), AX	
			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages<<_PageShift)
  0x41acde		48894c2408		MOVQ CX, 0x8(SP)			
  0x41ace3		48890424		MOVQ AX, 0(SP)				
  0x41ace7		e884c10200		CALL runtime.memclrNoHeapPointers(SB)	
  0x41acec		ebc7			JMP 0x41acb5				
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41acee		e87d980200		CALL runtime.morestack_noctxt(SB)	
  0x41acf3		e918ffffff		JMP runtime.(*mheap).alloc(SB)		

TEXT runtime.(*mheap).allocManual(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) allocManual(npage uintptr, stat *uint64) *mspan {
  0x41ad00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ad09		483b6118		CMPQ 0x18(CX), SP	
  0x41ad0d		0f86c3000000		JBE 0x41add6		
  0x41ad13		4883ec30		SUBQ $0x30, SP		
  0x41ad17		48896c2428		MOVQ BP, 0x28(SP)	
  0x41ad1c		488d6c2428		LEAQ 0x28(SP), BP	
  0x41ad21		488b442438		MOVQ 0x38(SP), AX	
	lock(&h.lock)
  0x41ad26		8400			TESTB AL, 0(AX)		
  0x41ad28		48890424		MOVQ AX, 0(SP)		
  0x41ad2c		e8efe7feff		CALL runtime.lock(SB)	
  0x41ad31		488b442438		MOVQ 0x38(SP), AX	
	s := h.allocSpanLocked(npage, stat)
  0x41ad36		48890424		MOVQ AX, 0(SP)		
func (h *mheap) allocManual(npage uintptr, stat *uint64) *mspan {
  0x41ad3a		488b4c2440		MOVQ 0x40(SP), CX	
	s := h.allocSpanLocked(npage, stat)
  0x41ad3f		48894c2408		MOVQ CX, 0x8(SP)	
func (h *mheap) allocManual(npage uintptr, stat *uint64) *mspan {
  0x41ad44		488b4c2448		MOVQ 0x48(SP), CX	
	s := h.allocSpanLocked(npage, stat)
  0x41ad49		48894c2410		MOVQ CX, 0x10(SP)				
  0x41ad4e		e88d000000		CALL runtime.(*mheap).allocSpanLocked(SB)	
  0x41ad53		488b442418		MOVQ 0x18(SP), AX				
  0x41ad58		4889442420		MOVQ AX, 0x20(SP)				
	if s != nil {
  0x41ad5d		4885c0			TESTQ AX, AX		
  0x41ad60		7452			JE 0x41adb4		
		s.state = _MSpanManual
  0x41ad62		c6406402		MOVB $0x2, 0x64(AX)	
		s.manualFreeList = 0
  0x41ad66		48c7402800000000	MOVQ $0x0, 0x28(AX)	
		s.allocCount = 0
  0x41ad6e		66c740600000		MOVW $0x0, 0x60(AX)	
		s.spanclass = 0
  0x41ad74		c6406200		MOVB $0x0, 0x62(AX)	
		s.nelems = 0
  0x41ad78		48c7403800000000	MOVQ $0x0, 0x38(AX)	
		s.elemsize = 0
  0x41ad80		48c7406800000000	MOVQ $0x0, 0x68(AX)	
		s.limit = s.base() + s.npages<<_PageShift
  0x41ad88		488b4820		MOVQ 0x20(AX), CX	
  0x41ad8c		48c1e10d		SHLQ $0xd, CX		
  0x41ad90		48034818		ADDQ 0x18(AX), CX	
  0x41ad94		48898880000000		MOVQ CX, 0x80(AX)	
		memstats.heap_sys -= uint64(s.npages << _PageShift)
  0x41ad9b		488b0d96990a00		MOVQ runtime.memstats+56(SB), CX	
  0x41ada2		488b5020		MOVQ 0x20(AX), DX			
  0x41ada6		48c1e20d		SHLQ $0xd, DX				
  0x41adaa		4829d1			SUBQ DX, CX				
  0x41adad		48890d84990a00		MOVQ CX, runtime.memstats+56(SB)	
  0x41adb4		488b442438		MOVQ 0x38(SP), AX			
	unlock(&h.lock)
  0x41adb9		48890424		MOVQ AX, 0(SP)		
  0x41adbd		e8fee8feff		CALL runtime.unlock(SB)	
	return s
  0x41adc2		488b442420		MOVQ 0x20(SP), AX	
  0x41adc7		4889442450		MOVQ AX, 0x50(SP)	
  0x41adcc		488b6c2428		MOVQ 0x28(SP), BP	
  0x41add1		4883c430		ADDQ $0x30, SP		
  0x41add5		c3			RET			
func (h *mheap) allocManual(npage uintptr, stat *uint64) *mspan {
  0x41add6		e825bf0100		CALL runtime.morestackc(SB)		
  0x41addb		e920ffffff		JMP runtime.(*mheap).allocManual(SB)	

TEXT runtime.(*mheap).allocSpanLocked(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) allocSpanLocked(npage uintptr, stat *uint64) *mspan {
  0x41ade0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ade9		483b6110		CMPQ 0x10(CX), SP	
  0x41aded		0f86b7030000		JBE 0x41b1aa		
  0x41adf3		4883ec38		SUBQ $0x38, SP		
  0x41adf7		48896c2430		MOVQ BP, 0x30(SP)	
  0x41adfc		488d6c2430		LEAQ 0x30(SP), BP	
  0x41ae01		488b442440		MOVQ 0x40(SP), AX	
  0x41ae06		488b4c2448		MOVQ 0x48(SP), CX	
  0x41ae0b		4889ca			MOVQ CX, DX		
	for i := int(npage); i < len(h.free); i++ {
  0x41ae0e		eb04			JMP 0x41ae14		
  0x41ae10		488d4b01		LEAQ 0x1(BX), CX	
  0x41ae14		4881f980000000		CMPQ $0x80, CX		
  0x41ae1b		0f8d8c020000		JGE 0x41b0ad		
		list = &h.free[i]
  0x41ae21		8400			TESTB AL, 0(AX)		
	for i := int(npage); i < len(h.free); i++ {
  0x41ae23		4881f980000000		CMPQ $0x80, CX		
		list = &h.free[i]
  0x41ae2a		0f8373030000		JAE 0x41b1a3		
  0x41ae30		4889cb			MOVQ CX, BX		
  0x41ae33		48c1e104		SHLQ $0x4, CX		
  0x41ae37		488d740808		LEAQ 0x8(AX)(CX*1), SI	
	return list.first == nil
  0x41ae3c		488b4c0808		MOVQ 0x8(AX)(CX*1), CX	
  0x41ae41		4885c9			TESTQ CX, CX		
		if !list.isEmpty() {
  0x41ae44		74ca			JE 0x41ae10		
  0x41ae46		48894c2428		MOVQ CX, 0x28(SP)	
			list.remove(s)
  0x41ae4b		48893424		MOVQ SI, 0(SP)				
  0x41ae4f		48894c2408		MOVQ CX, 0x8(SP)			
  0x41ae54		e857120000		CALL runtime.(*mSpanList).remove(SB)	
  0x41ae59		488b442428		MOVQ 0x28(SP), AX			
	if s.state != _MSpanFree {
  0x41ae5e		0fb64864		MOVZX 0x64(AX), CX	
  0x41ae62		80f903			CMPL $0x3, CL		
  0x41ae65		0f851d030000		JNE 0x41b188		
	if s.npages < npage {
  0x41ae6b		488b4820		MOVQ 0x20(AX), CX	
  0x41ae6f		488b542448		MOVQ 0x48(SP), DX	
  0x41ae74		4839d1			CMPQ DX, CX		
  0x41ae77		0f82f0020000		JB 0x41b16d		
  0x41ae7d		4889442420		MOVQ AX, 0x20(SP)	
	if s.npreleased > 0 {
  0x41ae82		488b5878		MOVQ 0x78(AX), BX	
  0x41ae86		4885db			TESTQ BX, BX		
  0x41ae89		0f87d5010000		JA 0x41b064		
	if s.npages > npage {
  0x41ae8f		488b4820		MOVQ 0x20(AX), CX	
  0x41ae93		4839d1			CMPQ DX, CX		
  0x41ae96		0f8789000000		JA 0x41af25		
	s.unusedsince = 0
  0x41ae9c		48c7407000000000	MOVQ $0x0, 0x70(AX)	
  0x41aea4		488b4c2440		MOVQ 0x40(SP), CX	
	p := (s.base() - h.arena_start) >> _PageShift
  0x41aea9		8401			TESTB AL, 0(CX)		
	return s.startAddr
  0x41aeab		488b5818		MOVQ 0x18(AX), BX	
	p := (s.base() - h.arena_start) >> _PageShift
  0x41aeaf		482b9928130000		SUBQ 0x1328(CX), BX	
  0x41aeb6		48c1eb0d		SHRQ $0xd, BX		
  0x41aeba		31f6			XORL SI, SI		
	for n := uintptr(0); n < npage; n++ {
  0x41aebc		eb07			JMP 0x41aec5		
		h.spans[p+n] = s
  0x41aebe		4b8904c8		MOVQ AX, 0(R8)(R9*8)	
	for n := uintptr(0); n < npage; n++ {
  0x41aec2		48ffc6			INCQ SI			
  0x41aec5		4839d6			CMPQ DX, SI		
  0x41aec8		731c			JAE 0x41aee6		
		h.spans[p+n] = s
  0x41aeca		488bb950100000		MOVQ 0x1050(CX), DI	
  0x41aed1		4c8b8148100000		MOVQ 0x1048(CX), R8	
  0x41aed8		4c8d0c1e		LEAQ 0(SI)(BX*1), R9	
  0x41aedc		4939f9			CMPQ DI, R9		
  0x41aedf		72dd			JB 0x41aebe		
  0x41aee1		e96b020000		JMP 0x41b151		
  0x41aee6		488b4c2450		MOVQ 0x50(SP), CX	
	*stat += uint64(npage << _PageShift)
  0x41aeeb		488b19			MOVQ 0(CX), BX		
  0x41aeee		48c1e20d		SHLQ $0xd, DX		
  0x41aef2		4801d3			ADDQ DX, BX		
  0x41aef5		488919			MOVQ BX, 0(CX)		
	memstats.heap_idle -= uint64(npage << _PageShift)
  0x41aef8		488b0d41980a00		MOVQ runtime.memstats+64(SB), CX	
  0x41aeff		4829d1			SUBQ DX, CX				
  0x41af02		48890d37980a00		MOVQ CX, runtime.memstats+64(SB)	
	return span.list != nil
  0x41af09		488b4810		MOVQ 0x10(AX), CX	
  0x41af0d		4885c9			TESTQ CX, CX		
	if s.inList() {
  0x41af10		0f8520020000		JNE 0x41b136		
	return s
  0x41af16		4889442458		MOVQ AX, 0x58(SP)	
  0x41af1b		488b6c2430		MOVQ 0x30(SP), BP	
  0x41af20		4883c438		ADDQ $0x38, SP		
  0x41af24		c3			RET			
  0x41af25		488b442440		MOVQ 0x40(SP), AX	
		t := (*mspan)(h.spanalloc.alloc())
  0x41af2a		8400			TESTB AL, 0(AX)				
  0x41af2c		488d88d0340000		LEAQ 0x34d0(AX), CX			
  0x41af33		48890c24		MOVQ CX, 0(SP)				
  0x41af37		e8044bffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x41af3c		488b442408		MOVQ 0x8(SP), AX			
  0x41af41		488b4c2448		MOVQ 0x48(SP), CX			
  0x41af46		4889ca			MOVQ CX, DX				
		t.init(s.base()+npage<<_PageShift, s.npages-npage)
  0x41af49		48c1e10d		SHLQ $0xd, CX		
  0x41af4d		488b5c2420		MOVQ 0x20(SP), BX	
	return s.startAddr
  0x41af52		488d7318		LEAQ 0x18(BX), SI	
		t.init(s.base()+npage<<_PageShift, s.npages-npage)
  0x41af56		48030e			ADDQ 0(SI), CX		
  0x41af59		488b7320		MOVQ 0x20(BX), SI	
	span.prev = nil
  0x41af5d		0f57c0			XORPS X0, X0		
  0x41af60		0f1100			MOVUPS X0, 0(AX)	
	span.list = nil
  0x41af63		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	span.startAddr = base
  0x41af6b		48894818		MOVQ CX, 0x18(AX)	
		t.init(s.base()+npage<<_PageShift, s.npages-npage)
  0x41af6f		4829d6			SUBQ DX, SI		
	span.npages = npages
  0x41af72		48897020		MOVQ SI, 0x20(AX)	
	span.incache = false
  0x41af76		c7406000000000		MOVL $0x0, 0x60(AX)	
	span.elemsize = 0
  0x41af7d		48c7406800000000	MOVQ $0x0, 0x68(AX)	
	span.state = _MSpanDead
  0x41af85		c6406400		MOVB $0x0, 0x64(AX)	
	span.npreleased = 0
  0x41af89		0f114070		MOVUPS X0, 0x70(AX)	
	span.specials = nil
  0x41af8d		0f118088000000		MOVUPS X0, 0x88(AX)	
	span.needzero = 0
  0x41af94		c6406500		MOVB $0x0, 0x65(AX)	
	span.freeindex = 0
  0x41af98		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	span.gcmarkBits = nil
  0x41afa0		0f114048		MOVUPS X0, 0x48(AX)	
		s.npages = npage
  0x41afa4		48895320		MOVQ DX, 0x20(BX)	
	return s.startAddr
  0x41afa8		488b4818		MOVQ 0x18(AX), CX	
  0x41afac		488b742440		MOVQ 0x40(SP), SI	
		p := (t.base() - h.arena_start) >> _PageShift
  0x41afb1		482b8e28130000		SUBQ 0x1328(SI), CX	
  0x41afb8		48c1e90d		SHRQ $0xd, CX		
		if p > 0 {
  0x41afbc		48f7c1ffffffff		TESTQ $-0x1, CX		
  0x41afc3		7620			JBE 0x41afe5		
			h.spans[p-1] = s
  0x41afc5		488bbe50100000		MOVQ 0x1050(SI), DI	
  0x41afcc		4c8b8648100000		MOVQ 0x1048(SI), R8	
  0x41afd3		4c8d49ff		LEAQ -0x1(CX), R9	
  0x41afd7		4939f9			CMPQ DI, R9		
  0x41afda		0f8386010000		JAE 0x41b166		
  0x41afe0		49895cc8f8		MOVQ BX, -0x8(R8)(CX*8)	
		h.spans[p] = t
  0x41afe5		488bbe50100000		MOVQ 0x1050(SI), DI	
  0x41afec		4c8b8648100000		MOVQ 0x1048(SI), R8	
  0x41aff3		4839f9			CMPQ DI, CX		
  0x41aff6		0f8363010000		JAE 0x41b15f		
  0x41affc		498904c8		MOVQ AX, 0(R8)(CX*8)	
		h.spans[p+t.npages-1] = t
  0x41b000		488bbe50100000		MOVQ 0x1050(SI), DI	
  0x41b007		4c8b8648100000		MOVQ 0x1048(SI), R8	
  0x41b00e		4c8b4820		MOVQ 0x20(AX), R9	
  0x41b012		4a8d4c09ff		LEAQ -0x1(CX)(R9*1), CX	
  0x41b017		4839f9			CMPQ DI, CX		
  0x41b01a		0f8338010000		JAE 0x41b158		
  0x41b020		498904c8		MOVQ AX, 0(R8)(CX*8)	
		t.needzero = s.needzero
  0x41b024		0fb64b65		MOVZX 0x65(BX), CX	
  0x41b028		884865			MOVB CL, 0x65(AX)	
		s.state = _MSpanManual // prevent coalescing with s
  0x41b02b		c6436402		MOVB $0x2, 0x64(BX)	
		t.state = _MSpanManual
  0x41b02f		c6406402		MOVB $0x2, 0x64(AX)	
		h.freeSpanLocked(t, false, false, s.unusedsince)
  0x41b033		488b4b70		MOVQ 0x70(BX), CX				
  0x41b037		48894c2418		MOVQ CX, 0x18(SP)				
  0x41b03c		48893424		MOVQ SI, 0(SP)					
  0x41b040		4889442408		MOVQ AX, 0x8(SP)				
  0x41b045		66c74424100000		MOVW $0x0, 0x10(SP)				
  0x41b04c		e85f050000		CALL runtime.(*mheap).freeSpanLocked(SB)	
  0x41b051		488b442420		MOVQ 0x20(SP), AX				
		s.state = _MSpanFree
  0x41b056		c6406403		MOVB $0x3, 0x64(AX)	
  0x41b05a		488b542448		MOVQ 0x48(SP), DX	
  0x41b05f		e938feffff		JMP 0x41ae9c		
		sysUsed(unsafe.Pointer(s.base()), s.npages<<_PageShift)
  0x41b064		48c1e10d		SHLQ $0xd, CX		
	return s.startAddr
  0x41b068		488b5018		MOVQ 0x18(AX), DX	
		sysUsed(unsafe.Pointer(s.base()), s.npages<<_PageShift)
  0x41b06c		48894c2408		MOVQ CX, 0x8(SP)		
  0x41b071		48891424		MOVQ DX, 0(SP)			
  0x41b075		e84642ffff		CALL runtime.sysUsed(SB)	
		memstats.heap_released -= uint64(s.npreleased << _PageShift)
  0x41b07a		488b05cf960a00		MOVQ runtime.memstats+80(SB), AX	
  0x41b081		488b4c2420		MOVQ 0x20(SP), CX			
  0x41b086		488b5178		MOVQ 0x78(CX), DX			
  0x41b08a		48c1e20d		SHLQ $0xd, DX				
  0x41b08e		4829d0			SUBQ DX, AX				
  0x41b091		488905b8960a00		MOVQ AX, runtime.memstats+80(SB)	
		s.npreleased = 0
  0x41b098		48c7417800000000	MOVQ $0x0, 0x78(CX)	
  0x41b0a0		4889c8			MOVQ CX, AX		
  0x41b0a3		488b542448		MOVQ 0x48(SP), DX	
  0x41b0a8		e9e2fdffff		JMP 0x41ae8f		
	s = h.allocLarge(npage) // allocLarge removed s from h.freelarge for us
  0x41b0ad		48890424		MOVQ AX, 0(SP)				
  0x41b0b1		4889542408		MOVQ DX, 0x8(SP)			
  0x41b0b6		e805010000		CALL runtime.(*mheap).allocLarge(SB)	
  0x41b0bb		488b442410		MOVQ 0x10(SP), AX			
	if s == nil {
  0x41b0c0		4885c0			TESTQ AX, AX		
  0x41b0c3		0f8595fdffff		JNE 0x41ae5e		
  0x41b0c9		488b442440		MOVQ 0x40(SP), AX	
		if !h.grow(npage) {
  0x41b0ce		48890424		MOVQ AX, 0(SP)			
  0x41b0d2		488b4c2448		MOVQ 0x48(SP), CX		
  0x41b0d7		48894c2408		MOVQ CX, 0x8(SP)		
  0x41b0dc		e83f010000		CALL runtime.(*mheap).grow(SB)	
  0x41b0e1		0fb6442410		MOVZX 0x10(SP), AX		
  0x41b0e6		84c0			TESTL AL, AL			
  0x41b0e8		7439			JE 0x41b123			
  0x41b0ea		488b442440		MOVQ 0x40(SP), AX		
		s = h.allocLarge(npage)
  0x41b0ef		48890424		MOVQ AX, 0(SP)				
  0x41b0f3		488b4c2448		MOVQ 0x48(SP), CX			
  0x41b0f8		48894c2408		MOVQ CX, 0x8(SP)			
  0x41b0fd		e8be000000		CALL runtime.(*mheap).allocLarge(SB)	
  0x41b102		488b442410		MOVQ 0x10(SP), AX			
		if s == nil {
  0x41b107		4885c0			TESTQ AX, AX		
  0x41b10a		0f854efdffff		JNE 0x41ae5e		
			return nil
  0x41b110		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x41b119		488b6c2430		MOVQ 0x30(SP), BP	
  0x41b11e		4883c438		ADDQ $0x38, SP		
  0x41b122		c3			RET			
			return nil
  0x41b123		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x41b12c		488b6c2430		MOVQ 0x30(SP), BP	
  0x41b131		4883c438		ADDQ $0x38, SP		
  0x41b135		c3			RET			
		throw("still in list")
  0x41b136		488d0545f60400		LEAQ 0x4f645(IP), AX	
  0x41b13d		48890424		MOVQ AX, 0(SP)		
  0x41b141		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x41b14a		e881600000		CALL runtime.throw(SB)	
  0x41b14f		0f0b			UD2			
		h.spans[p+n] = s
  0x41b151		e8ea480000		CALL runtime.panicindex(SB)	
  0x41b156		0f0b			UD2				
		h.spans[p+t.npages-1] = t
  0x41b158		e8e3480000		CALL runtime.panicindex(SB)	
  0x41b15d		0f0b			UD2				
		h.spans[p] = t
  0x41b15f		e8dc480000		CALL runtime.panicindex(SB)	
  0x41b164		0f0b			UD2				
			h.spans[p-1] = s
  0x41b166		e8d5480000		CALL runtime.panicindex(SB)	
  0x41b16b		0f0b			UD2				
		throw("MHeap_AllocLocked - bad npages")
  0x41b16d		488d059d120500		LEAQ 0x5129d(IP), AX	
  0x41b174		48890424		MOVQ AX, 0(SP)		
  0x41b178		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x41b181		e84a600000		CALL runtime.throw(SB)	
  0x41b186		0f0b			UD2			
		throw("MHeap_AllocLocked - MSpan not free")
  0x41b188		488d05051a0500		LEAQ 0x51a05(IP), AX	
  0x41b18f		48890424		MOVQ AX, 0(SP)		
  0x41b193		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x41b19c		e82f600000		CALL runtime.throw(SB)	
  0x41b1a1		0f0b			UD2			
		list = &h.free[i]
  0x41b1a3		e898480000		CALL runtime.panicindex(SB)	
  0x41b1a8		0f0b			UD2				
func (h *mheap) allocSpanLocked(npage uintptr, stat *uint64) *mspan {
  0x41b1aa		e8c1930200		CALL runtime.morestack_noctxt(SB)		
  0x41b1af		e92cfcffff		JMP runtime.(*mheap).allocSpanLocked(SB)	

TEXT runtime.(*mheap).allocLarge(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) allocLarge(npage uintptr) *mspan {
  0x41b1c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b1c9		483b6110		CMPQ 0x10(CX), SP	
  0x41b1cd		7642			JBE 0x41b211		
  0x41b1cf		4883ec20		SUBQ $0x20, SP		
  0x41b1d3		48896c2418		MOVQ BP, 0x18(SP)	
  0x41b1d8		488d6c2418		LEAQ 0x18(SP), BP	
  0x41b1dd		488b442428		MOVQ 0x28(SP), AX	
	return h.freelarge.remove(npage)
  0x41b1e2		8400			TESTB AL, 0(AX)		
  0x41b1e4		480508080000		ADDQ $0x808, AX		
  0x41b1ea		48890424		MOVQ AX, 0(SP)		
func (h *mheap) allocLarge(npage uintptr) *mspan {
  0x41b1ee		488b442430		MOVQ 0x30(SP), AX	
	return h.freelarge.remove(npage)
  0x41b1f3		4889442408		MOVQ AX, 0x8(SP)			
  0x41b1f8		e8f387ffff		CALL runtime.(*mTreap).remove(SB)	
  0x41b1fd		488b442410		MOVQ 0x10(SP), AX			
  0x41b202		4889442438		MOVQ AX, 0x38(SP)			
  0x41b207		488b6c2418		MOVQ 0x18(SP), BP			
  0x41b20c		4883c420		ADDQ $0x20, SP				
  0x41b210		c3			RET					
func (h *mheap) allocLarge(npage uintptr) *mspan {
  0x41b211		e85a930200		CALL runtime.morestack_noctxt(SB)	
  0x41b216		eba8			JMP runtime.(*mheap).allocLarge(SB)	

TEXT runtime.(*mheap).grow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) grow(npage uintptr) bool {
  0x41b220		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b229		483b6110		CMPQ 0x10(CX), SP	
  0x41b22d		0f8646020000		JBE 0x41b479		
  0x41b233		4883ec50		SUBQ $0x50, SP		
  0x41b237		48896c2448		MOVQ BP, 0x48(SP)	
  0x41b23c		488d6c2448		LEAQ 0x48(SP), BP	
  0x41b241		488b442460		MOVQ 0x60(SP), AX	
	return (n + a - 1) &^ (a - 1)
  0x41b246		4883c007		ADDQ $0x7, AX		
  0x41b24a		4883e0f8		ANDQ $-0x8, AX		
	ask := npage << _PageShift
  0x41b24e		48c1e00d		SHLQ $0xd, AX		
  0x41b252		4889442438		MOVQ AX, 0x38(SP)	
	if ask < _HeapAllocChunk {
  0x41b257		483d00001000		CMPQ $0x100000, AX	
  0x41b25d		0f8307020000		JAE 0x41b46a		
  0x41b263		b900001000		MOVL $0x100000, CX	
	v := h.sysAlloc(ask)
  0x41b268		48894c2420		MOVQ CX, 0x20(SP)			
  0x41b26d		488b442458		MOVQ 0x58(SP), AX			
  0x41b272		48890424		MOVQ AX, 0(SP)				
  0x41b276		48894c2408		MOVQ CX, 0x8(SP)			
  0x41b27b		e8d0eefeff		CALL runtime.(*mheap).sysAlloc(SB)	
  0x41b280		488b442410		MOVQ 0x10(SP), AX			
	if v == nil {
  0x41b285		4885c0			TESTQ AX, AX		
  0x41b288		0f840d010000		JE 0x41b39b		
  0x41b28e		488b4c2420		MOVQ 0x20(SP), CX	
  0x41b293		4889442440		MOVQ AX, 0x40(SP)	
  0x41b298		48894c2420		MOVQ CX, 0x20(SP)	
  0x41b29d		488b542458		MOVQ 0x58(SP), DX	
	s := (*mspan)(h.spanalloc.alloc())
  0x41b2a2		8402			TESTB AL, 0(DX)				
  0x41b2a4		488d9ad0340000		LEAQ 0x34d0(DX), BX			
  0x41b2ab		48891c24		MOVQ BX, 0(SP)				
  0x41b2af		e88c47ffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x41b2b4		488b442408		MOVQ 0x8(SP), AX			
  0x41b2b9		488b4c2440		MOVQ 0x40(SP), CX			
	span.prev = nil
  0x41b2be		0f57c0			XORPS X0, X0		
  0x41b2c1		0f1100			MOVUPS X0, 0(AX)	
	span.list = nil
  0x41b2c4		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	span.startAddr = base
  0x41b2cc		48894818		MOVQ CX, 0x18(AX)	
  0x41b2d0		488b4c2420		MOVQ 0x20(SP), CX	
	s.init(uintptr(v), ask>>_PageShift)
  0x41b2d5		48c1e90d		SHRQ $0xd, CX		
	span.npages = npages
  0x41b2d9		48894820		MOVQ CX, 0x20(AX)	
	span.incache = false
  0x41b2dd		c7406000000000		MOVL $0x0, 0x60(AX)	
	span.elemsize = 0
  0x41b2e4		48c7406800000000	MOVQ $0x0, 0x68(AX)	
	span.state = _MSpanDead
  0x41b2ec		c6406400		MOVB $0x0, 0x64(AX)	
	span.npreleased = 0
  0x41b2f0		0f114070		MOVUPS X0, 0x70(AX)	
	span.specials = nil
  0x41b2f4		0f118088000000		MOVUPS X0, 0x88(AX)	
	span.needzero = 0
  0x41b2fb		c6406500		MOVB $0x0, 0x65(AX)	
	span.freeindex = 0
  0x41b2ff		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	span.gcmarkBits = nil
  0x41b307		0f114048		MOVUPS X0, 0x48(AX)	
	return s.startAddr
  0x41b30b		488b4818		MOVQ 0x18(AX), CX	
  0x41b30f		488b542458		MOVQ 0x58(SP), DX	
	p := (s.base() - h.arena_start) >> _PageShift
  0x41b314		482b8a28130000		SUBQ 0x1328(DX), CX	
  0x41b31b		48c1e90d		SHRQ $0xd, CX		
  0x41b31f		4889cb			MOVQ CX, BX		
	for i := p; i < p+s.npages; i++ {
  0x41b322		eb07			JMP 0x41b32b		
		h.spans[i] = s
  0x41b324		488904cf		MOVQ AX, 0(DI)(CX*8)	
	for i := p; i < p+s.npages; i++ {
  0x41b328		48ffc1			INCQ CX			
  0x41b32b		488b7020		MOVQ 0x20(AX), SI	
  0x41b32f		4801de			ADDQ BX, SI		
  0x41b332		4839f1			CMPQ SI, CX		
  0x41b335		7318			JAE 0x41b34f		
		h.spans[i] = s
  0x41b337		488bb250100000		MOVQ 0x1050(DX), SI	
  0x41b33e		488bba48100000		MOVQ 0x1048(DX), DI	
  0x41b345		4839f1			CMPQ SI, CX		
  0x41b348		72da			JB 0x41b324		
  0x41b34a		e923010000		JMP 0x41b472		
	atomic.Store(&s.sweepgen, h.sweepgen)
  0x41b34f		8b8a20100000		MOVL 0x1020(DX), CX	
  0x41b355		874858			XCHGL CX, 0x58(AX)	
	s.state = _MSpanInUse
  0x41b358		c6406401		MOVB $0x1, 0x64(AX)	
	h.pagesInUse += uint64(s.npages)
  0x41b35c		488b8ab8100000		MOVQ 0x10b8(DX), CX	
  0x41b363		48034820		ADDQ 0x20(AX), CX	
  0x41b367		48898ab8100000		MOVQ CX, 0x10b8(DX)	
	h.freeSpanLocked(s, false, true, 0)
  0x41b36e		48891424		MOVQ DX, 0(SP)					
  0x41b372		4889442408		MOVQ AX, 0x8(SP)				
  0x41b377		66c74424100001		MOVW $0x100, 0x10(SP)				
  0x41b37e		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x41b387		e824020000		CALL runtime.(*mheap).freeSpanLocked(SB)	
	return true
  0x41b38c		c644246801		MOVB $0x1, 0x68(SP)	
  0x41b391		488b6c2448		MOVQ 0x48(SP), BP	
  0x41b396		4883c450		ADDQ $0x50, SP		
  0x41b39a		c3			RET			
  0x41b39b		488b4c2420		MOVQ 0x20(SP), CX	
  0x41b3a0		488b542438		MOVQ 0x38(SP), DX	
		if ask > npage<<_PageShift {
  0x41b3a5		4839d1			CMPQ DX, CX		
  0x41b3a8		0f879a000000		JA 0x41b448		
		if v == nil {
  0x41b3ae		4885c0			TESTQ AX, AX		
  0x41b3b1		0f85dcfeffff		JNE 0x41b293		
  0x41b3b7		48894c2430		MOVQ CX, 0x30(SP)	
			print("runtime: out of memory: cannot allocate ", ask, "-byte block (", memstats.heap_sys, " in use)\n")
  0x41b3bc		488b0575930a00		MOVQ runtime.memstats+56(SB), AX	
  0x41b3c3		4889442428		MOVQ AX, 0x28(SP)			
  0x41b3c8		e833670000		CALL runtime.printlock(SB)		
  0x41b3cd		488d050a1f0500		LEAQ 0x51f0a(IP), AX			
  0x41b3d4		48890424		MOVQ AX, 0(SP)				
  0x41b3d8		48c744240828000000	MOVQ $0x28, 0x8(SP)			
  0x41b3e1		e85a700000		CALL runtime.printstring(SB)		
  0x41b3e6		488b442430		MOVQ 0x30(SP), AX			
  0x41b3eb		48890424		MOVQ AX, 0(SP)				
  0x41b3ef		e87c6d0000		CALL runtime.printuint(SB)		
  0x41b3f4		488d0505f30400		LEAQ 0x4f305(IP), AX			
  0x41b3fb		48890424		MOVQ AX, 0(SP)				
  0x41b3ff		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x41b408		e833700000		CALL runtime.printstring(SB)		
  0x41b40d		488b442428		MOVQ 0x28(SP), AX			
  0x41b412		48890424		MOVQ AX, 0(SP)				
  0x41b416		e8556d0000		CALL runtime.printuint(SB)		
  0x41b41b		488d0541ec0400		LEAQ 0x4ec41(IP), AX			
  0x41b422		48890424		MOVQ AX, 0(SP)				
  0x41b426		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x41b42f		e80c700000		CALL runtime.printstring(SB)		
  0x41b434		e847670000		CALL runtime.printunlock(SB)		
			return false
  0x41b439		c644246800		MOVB $0x0, 0x68(SP)	
  0x41b43e		488b6c2448		MOVQ 0x48(SP), BP	
  0x41b443		4883c450		ADDQ $0x50, SP		
  0x41b447		c3			RET			
  0x41b448		488b442458		MOVQ 0x58(SP), AX	
			v = h.sysAlloc(ask)
  0x41b44d		48890424		MOVQ AX, 0(SP)				
  0x41b451		4889542408		MOVQ DX, 0x8(SP)			
  0x41b456		e8f5ecfeff		CALL runtime.(*mheap).sysAlloc(SB)	
  0x41b45b		488b442410		MOVQ 0x10(SP), AX			
  0x41b460		488b4c2438		MOVQ 0x38(SP), CX			
  0x41b465		e944ffffff		JMP 0x41b3ae				
  0x41b46a		4889c1			MOVQ AX, CX				
	if ask < _HeapAllocChunk {
  0x41b46d		e9f6fdffff		JMP 0x41b268		
		h.spans[i] = s
  0x41b472		e8c9450000		CALL runtime.panicindex(SB)	
  0x41b477		0f0b			UD2				
func (h *mheap) grow(npage uintptr) bool {
  0x41b479		e8f2900200		CALL runtime.morestack_noctxt(SB)	
  0x41b47e		e99dfdffff		JMP runtime.(*mheap).grow(SB)		

TEXT runtime.(*mheap).freeSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) freeSpan(s *mspan, acct int32) {
  0x41b490		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b499		483b6110		CMPQ 0x10(CX), SP	
  0x41b49d		764e			JBE 0x41b4ed		
  0x41b49f		4883ec30		SUBQ $0x30, SP		
  0x41b4a3		48896c2428		MOVQ BP, 0x28(SP)	
  0x41b4a8		488d6c2428		LEAQ 0x28(SP), BP	
	systemstack(func() {
  0x41b4ad		488d051c740200		LEAQ runtime.(*mheap).freeSpan.func1(SB), AX	
  0x41b4b4		4889442408		MOVQ AX, 0x8(SP)				
func (h *mheap) freeSpan(s *mspan, acct int32) {
  0x41b4b9		488b442438		MOVQ 0x38(SP), AX	
	systemstack(func() {
  0x41b4be		4889442410		MOVQ AX, 0x10(SP)	
func (h *mheap) freeSpan(s *mspan, acct int32) {
  0x41b4c3		488b442440		MOVQ 0x40(SP), AX	
	systemstack(func() {
  0x41b4c8		4889442418		MOVQ AX, 0x18(SP)	
func (h *mheap) freeSpan(s *mspan, acct int32) {
  0x41b4cd		8b442448		MOVL 0x48(SP), AX	
	systemstack(func() {
  0x41b4d1		89442420		MOVL AX, 0x20(SP)		
  0x41b4d5		488d442408		LEAQ 0x8(SP), AX		
  0x41b4da		48890424		MOVQ AX, 0(SP)			
  0x41b4de		e83d8f0200		CALL runtime.systemstack(SB)	
}
  0x41b4e3		488b6c2428		MOVQ 0x28(SP), BP	
  0x41b4e8		4883c430		ADDQ $0x30, SP		
  0x41b4ec		c3			RET			
func (h *mheap) freeSpan(s *mspan, acct int32) {
  0x41b4ed		e87e900200		CALL runtime.morestack_noctxt(SB)	
  0x41b4f2		eb9c			JMP runtime.(*mheap).freeSpan(SB)	

TEXT runtime.(*mheap).freeManual(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) freeManual(s *mspan, stat *uint64) {
  0x41b500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b509		483b6118		CMPQ 0x18(CX), SP	
  0x41b50d		0f8693000000		JBE 0x41b5a6		
  0x41b513		4883ec28		SUBQ $0x28, SP		
  0x41b517		48896c2420		MOVQ BP, 0x20(SP)	
  0x41b51c		488d6c2420		LEAQ 0x20(SP), BP	
  0x41b521		488b442438		MOVQ 0x38(SP), AX	
	s.needzero = 1
  0x41b526		c6406501		MOVB $0x1, 0x65(AX)	
func (h *mheap) freeManual(s *mspan, stat *uint64) {
  0x41b52a		488b4c2430		MOVQ 0x30(SP), CX	
	lock(&h.lock)
  0x41b52f		8401			TESTB AL, 0(CX)		
  0x41b531		48890c24		MOVQ CX, 0(SP)		
  0x41b535		e8e6dffeff		CALL runtime.lock(SB)	
func (h *mheap) freeManual(s *mspan, stat *uint64) {
  0x41b53a		488b442440		MOVQ 0x40(SP), AX	
	*stat -= uint64(s.npages << _PageShift)
  0x41b53f		488b08			MOVQ 0(AX), CX		
  0x41b542		488b542438		MOVQ 0x38(SP), DX	
  0x41b547		488b5a20		MOVQ 0x20(DX), BX	
  0x41b54b		48c1e30d		SHLQ $0xd, BX		
  0x41b54f		4829d9			SUBQ BX, CX		
  0x41b552		488908			MOVQ CX, 0(AX)		
	memstats.heap_sys += uint64(s.npages << _PageShift)
  0x41b555		488b4220		MOVQ 0x20(DX), AX			
  0x41b559		48c1e00d		SHLQ $0xd, AX				
  0x41b55d		480305d4910a00		ADDQ runtime.memstats+56(SB), AX	
  0x41b564		488905cd910a00		MOVQ AX, runtime.memstats+56(SB)	
  0x41b56b		488b442430		MOVQ 0x30(SP), AX			
	h.freeSpanLocked(s, false, true, 0)
  0x41b570		48890424		MOVQ AX, 0(SP)					
  0x41b574		4889542408		MOVQ DX, 0x8(SP)				
  0x41b579		66c74424100001		MOVW $0x100, 0x10(SP)				
  0x41b580		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x41b589		e822000000		CALL runtime.(*mheap).freeSpanLocked(SB)	
  0x41b58e		488b442430		MOVQ 0x30(SP), AX				
	unlock(&h.lock)
  0x41b593		48890424		MOVQ AX, 0(SP)		
  0x41b597		e824e1feff		CALL runtime.unlock(SB)	
}
  0x41b59c		488b6c2420		MOVQ 0x20(SP), BP	
  0x41b5a1		4883c428		ADDQ $0x28, SP		
  0x41b5a5		c3			RET			
func (h *mheap) freeManual(s *mspan, stat *uint64) {
  0x41b5a6		e855b70100		CALL runtime.morestackc(SB)		
  0x41b5ab		e950ffffff		JMP runtime.(*mheap).freeManual(SB)	

TEXT runtime.(*mheap).freeSpanLocked(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41b5b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b5b9		483b6110		CMPQ 0x10(CX), SP	
  0x41b5bd		0f8643050000		JBE 0x41bb06		
  0x41b5c3		4883ec48		SUBQ $0x48, SP		
  0x41b5c7		48896c2440		MOVQ BP, 0x40(SP)	
  0x41b5cc		488d6c2440		LEAQ 0x40(SP), BP	
  0x41b5d1		488b442458		MOVQ 0x58(SP), AX	
	switch s.state {
  0x41b5d6		0fb64864		MOVZX 0x64(AX), CX	
	case _MSpanInUse:
  0x41b5da		80f901			CMPL $0x1, CL		
  0x41b5dd		0f85a5030000		JNE 0x41b988		
		if s.allocCount != 0 || s.sweepgen != h.sweepgen {
  0x41b5e3		0fb74860		MOVZX 0x60(AX), CX	
  0x41b5e7		66894c2416		MOVW CX, 0x16(SP)	
  0x41b5ec		6685c9			TESTW CX, CX		
  0x41b5ef		0f85c8030000		JNE 0x41b9bd		
  0x41b5f5		488b542450		MOVQ 0x50(SP), DX	
  0x41b5fa		8402			TESTB AL, 0(DX)		
  0x41b5fc		8b5858			MOVL 0x58(AX), BX	
  0x41b5ff		8bb220100000		MOVL 0x1020(DX), SI	
  0x41b605		39f3			CMPL SI, BX		
  0x41b607		0f85b0030000		JNE 0x41b9bd		
		h.pagesInUse -= uint64(s.npages)
  0x41b60d		488b8ab8100000		MOVQ 0x10b8(DX), CX	
  0x41b614		482b4820		SUBQ 0x20(AX), CX	
  0x41b618		48898ab8100000		MOVQ CX, 0x10b8(DX)	
	switch s.state {
  0x41b61f		0fb64c2460		MOVZX 0x60(SP), CX	
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41b624		84c9			TESTL CL, CL		
	if acctinuse {
  0x41b626		7419			JE 0x41b641		
		memstats.heap_inuse -= uint64(s.npages << _PageShift)
  0x41b628		488b0d19910a00		MOVQ runtime.memstats+72(SB), CX	
  0x41b62f		488b5820		MOVQ 0x20(AX), BX			
  0x41b633		48c1e30d		SHLQ $0xd, BX				
  0x41b637		4829d9			SUBQ BX, CX				
  0x41b63a		48890d07910a00		MOVQ CX, runtime.memstats+72(SB)	
  0x41b641		0fb64c2461		MOVZX 0x61(SP), CX			
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41b646		84c9			TESTL CL, CL		
	if acctidle {
  0x41b648		7416			JE 0x41b660		
		memstats.heap_idle += uint64(s.npages << _PageShift)
  0x41b64a		488b4820		MOVQ 0x20(AX), CX			
  0x41b64e		48c1e10d		SHLQ $0xd, CX				
  0x41b652		48030de7900a00		ADDQ runtime.memstats+64(SB), CX	
  0x41b659		48890de0900a00		MOVQ CX, runtime.memstats+64(SB)	
	s.state = _MSpanFree
  0x41b660		c6406403		MOVB $0x3, 0x64(AX)	
	return span.list != nil
  0x41b664		488b4810		MOVQ 0x10(AX), CX	
  0x41b668		4885c9			TESTQ CX, CX		
	if s.inList() {
  0x41b66b		742d			JE 0x41b69a		
		h.busyList(s.npages).remove(s)
  0x41b66d		488b4820		MOVQ 0x20(AX), CX	
	if npages < uintptr(len(h.busy)) {
  0x41b671		4881f980000000		CMPQ $0x80, CX		
  0x41b678		0f83fc020000		JAE 0x41b97a		
		return &h.busy[npages]
  0x41b67e		8402			TESTB AL, 0(DX)			
  0x41b680		48c1e104		SHLQ $0x4, CX			
  0x41b684		488d8c0a10080000	LEAQ 0x810(DX)(CX*1), CX	
		h.busyList(s.npages).remove(s)
  0x41b68c		48890c24		MOVQ CX, 0(SP)				
  0x41b690		4889442408		MOVQ AX, 0x8(SP)			
  0x41b695		e8160a0000		CALL runtime.(*mSpanList).remove(SB)	
  0x41b69a		488b442468		MOVQ 0x68(SP), AX			
  0x41b69f		488b4c2458		MOVQ 0x58(SP), CX			
	s.unusedsince = unusedsince
  0x41b6a4		48894170		MOVQ AX, 0x70(CX)	
	if unusedsince == 0 {
  0x41b6a8		4885c0			TESTQ AX, AX		
  0x41b6ab		0f84b2020000		JE 0x41b963		
	s.npreleased = 0
  0x41b6b1		48c7417800000000	MOVQ $0x0, 0x78(CX)	
  0x41b6b9		488b442450		MOVQ 0x50(SP), AX	
	p := (s.base() - h.arena_start) >> _PageShift
  0x41b6be		8400			TESTB AL, 0(AX)		
	return s.startAddr
  0x41b6c0		488b5118		MOVQ 0x18(CX), DX	
	p := (s.base() - h.arena_start) >> _PageShift
  0x41b6c4		482b9028130000		SUBQ 0x1328(AX), DX	
  0x41b6cb		48c1ea0d		SHRQ $0xd, DX		
	if p > 0 {
  0x41b6cf		48f7c2ffffffff		TESTQ $-0x1, DX		
  0x41b6d6		0f867c020000		JBE 0x41b958		
		before := h.spans[p-1]
  0x41b6dc		488b9850100000		MOVQ 0x1050(AX), BX	
  0x41b6e3		488bb048100000		MOVQ 0x1048(AX), SI	
  0x41b6ea		488d7aff		LEAQ -0x1(DX), DI	
  0x41b6ee		4839df			CMPQ BX, DI		
  0x41b6f1		0f83bf020000		JAE 0x41b9b6		
  0x41b6f7		488b5cd6f8		MOVQ -0x8(SI)(DX*8), BX	
		if before != nil && before.state == _MSpanFree {
  0x41b6fc		4885db			TESTQ BX, BX		
  0x41b6ff		0f8448020000		JE 0x41b94d		
  0x41b705		0fb67364		MOVZX 0x64(BX), SI	
  0x41b709		4080fe03		CMPL $0x3, SI		
  0x41b70d		0f852f020000		JNE 0x41b942		
			s.startAddr = before.startAddr
  0x41b713		488b7318		MOVQ 0x18(BX), SI	
  0x41b717		48897118		MOVQ SI, 0x18(CX)	
			s.npages += before.npages
  0x41b71b		488b7120		MOVQ 0x20(CX), SI	
  0x41b71f		48037320		ADDQ 0x20(BX), SI	
  0x41b723		48897120		MOVQ SI, 0x20(CX)	
			s.npreleased = before.npreleased // absorb released pages
  0x41b727		488b7378		MOVQ 0x78(BX), SI	
  0x41b72b		48897178		MOVQ SI, 0x78(CX)	
			s.needzero |= before.needzero
  0x41b72f		0fb67165		MOVZX 0x65(CX), SI	
  0x41b733		0fb67b65		MOVZX 0x65(BX), DI	
  0x41b737		09f7			ORL SI, DI		
  0x41b739		40887965		MOVB DI, 0x65(CX)	
			p -= before.npages
  0x41b73d		488b7320		MOVQ 0x20(BX), SI	
  0x41b741		4829f2			SUBQ SI, DX		
			h.spans[p] = s
  0x41b744		488bb050100000		MOVQ 0x1050(AX), SI	
  0x41b74b		488bb848100000		MOVQ 0x1048(AX), DI	
  0x41b752		4839f2			CMPQ SI, DX		
  0x41b755		0f8354020000		JAE 0x41b9af		
  0x41b75b		48895c2438		MOVQ BX, 0x38(SP)	
  0x41b760		4889542420		MOVQ DX, 0x20(SP)	
  0x41b765		48890cd7		MOVQ CX, 0(DI)(DX*8)	
			if h.isLargeSpan(before.npages) {
  0x41b769		488b7320		MOVQ 0x20(BX), SI	
	return npages >= uintptr(len(h.free))
  0x41b76d		4881fe80000000		CMPQ $0x80, SI		
			if h.isLargeSpan(before.npages) {
  0x41b774		0f82ac010000		JB 0x41b926		
				h.freelarge.removeSpan(before)
  0x41b77a		488d8808080000		LEAQ 0x808(AX), CX			
  0x41b781		48890c24		MOVQ CX, 0(SP)				
  0x41b785		48895c2408		MOVQ BX, 0x8(SP)			
  0x41b78a		e82183ffff		CALL runtime.(*mTreap).removeSpan(SB)	
  0x41b78f		488b442438		MOVQ 0x38(SP), AX			
			before.state = _MSpanDead
  0x41b794		c6406400		MOVB $0x0, 0x64(AX)	
  0x41b798		488b4c2450		MOVQ 0x50(SP), CX	
			h.spanalloc.free(unsafe.Pointer(before))
  0x41b79d		488d91d0340000		LEAQ 0x34d0(CX), DX	
	f.inuse -= f.size
  0x41b7a4		8402			TESTB AL, 0(DX)		
  0x41b7a6		488b9100350000		MOVQ 0x3500(CX), DX	
  0x41b7ad		482b91d0340000		SUBQ 0x34d0(CX), DX	
  0x41b7b4		48899100350000		MOVQ DX, 0x3500(CX)	
	v.next = f.list
  0x41b7bb		488b91e8340000		MOVQ 0x34e8(CX), DX	
  0x41b7c2		488910			MOVQ DX, 0(AX)		
	f.list = v
  0x41b7c5		488981e8340000		MOVQ AX, 0x34e8(CX)	
  0x41b7cc		488b442420		MOVQ 0x20(SP), AX	
	if (p + s.npages) < uintptr(len(h.spans)) {
  0x41b7d1		488b542458		MOVQ 0x58(SP), DX	
  0x41b7d6		488b5a20		MOVQ 0x20(DX), BX	
  0x41b7da		488d3403		LEAQ 0(BX)(AX*1), SI	
  0x41b7de		488bb950100000		MOVQ 0x1050(CX), DI	
  0x41b7e5		4c8b8148100000		MOVQ 0x1048(CX), R8	
  0x41b7ec		4839fe			CMPQ DI, SI		
  0x41b7ef		0f83cb000000		JAE 0x41b8c0		
		after := h.spans[p+s.npages]
  0x41b7f5		498b34f0		MOVQ 0(R8)(SI*8), SI	
		if after != nil && after.state == _MSpanFree {
  0x41b7f9		4885f6			TESTQ SI, SI		
  0x41b7fc		0f84be000000		JE 0x41b8c0		
  0x41b802		0fb67e64		MOVZX 0x64(SI), DI	
  0x41b806		4080ff03		CMPL $0x3, DI		
  0x41b80a		0f85b0000000		JNE 0x41b8c0		
			s.npages += after.npages
  0x41b810		488b7e20		MOVQ 0x20(SI), DI	
  0x41b814		4801fb			ADDQ DI, BX		
  0x41b817		48895a20		MOVQ BX, 0x20(DX)	
			s.npreleased += after.npreleased
  0x41b81b		488b5a78		MOVQ 0x78(DX), BX	
  0x41b81f		48035e78		ADDQ 0x78(SI), BX	
  0x41b823		48895a78		MOVQ BX, 0x78(DX)	
			s.needzero |= after.needzero
  0x41b827		0fb65a65		MOVZX 0x65(DX), BX	
  0x41b82b		0fb67e65		MOVZX 0x65(SI), DI	
  0x41b82f		09df			ORL BX, DI		
  0x41b831		40887a65		MOVB DI, 0x65(DX)	
			h.spans[p+s.npages-1] = s
  0x41b835		488b9950100000		MOVQ 0x1050(CX), BX	
  0x41b83c		488bb948100000		MOVQ 0x1048(CX), DI	
  0x41b843		4c8b4220		MOVQ 0x20(DX), R8	
  0x41b847		498d4400ff		LEAQ -0x1(R8)(AX*1), AX	
  0x41b84c		4839d8			CMPQ BX, AX		
  0x41b84f		0f8353010000		JAE 0x41b9a8		
  0x41b855		4889742438		MOVQ SI, 0x38(SP)	
  0x41b85a		488914c7		MOVQ DX, 0(DI)(AX*8)	
			if h.isLargeSpan(after.npages) {
  0x41b85e		488b4620		MOVQ 0x20(SI), AX	
	return npages >= uintptr(len(h.free))
  0x41b862		483d80000000		CMPQ $0x80, AX		
			if h.isLargeSpan(after.npages) {
  0x41b868		0f829c000000		JB 0x41b90a		
				h.freelarge.removeSpan(after)
  0x41b86e		488d8108080000		LEAQ 0x808(CX), AX			
  0x41b875		48890424		MOVQ AX, 0(SP)				
  0x41b879		4889742408		MOVQ SI, 0x8(SP)			
  0x41b87e		e82d82ffff		CALL runtime.(*mTreap).removeSpan(SB)	
  0x41b883		488b442438		MOVQ 0x38(SP), AX			
			after.state = _MSpanDead
  0x41b888		c6406400		MOVB $0x0, 0x64(AX)	
  0x41b88c		488b4c2450		MOVQ 0x50(SP), CX	
			h.spanalloc.free(unsafe.Pointer(after))
  0x41b891		488d91d0340000		LEAQ 0x34d0(CX), DX	
	f.inuse -= f.size
  0x41b898		8402			TESTB AL, 0(DX)		
  0x41b89a		488b9100350000		MOVQ 0x3500(CX), DX	
  0x41b8a1		482b91d0340000		SUBQ 0x34d0(CX), DX	
  0x41b8a8		48899100350000		MOVQ DX, 0x3500(CX)	
	v.next = f.list
  0x41b8af		488b91e8340000		MOVQ 0x34e8(CX), DX	
  0x41b8b6		488910			MOVQ DX, 0(AX)		
	f.list = v
  0x41b8b9		488981e8340000		MOVQ AX, 0x34e8(CX)	
	if h.isLargeSpan(s.npages) {
  0x41b8c0		488b442458		MOVQ 0x58(SP), AX	
  0x41b8c5		488b5020		MOVQ 0x20(AX), DX	
	return npages >= uintptr(len(h.free))
  0x41b8c9		4881fa80000000		CMPQ $0x80, DX		
	if h.isLargeSpan(s.npages) {
  0x41b8d0		721f			JB 0x41b8f1		
		h.freelarge.insert(s)
  0x41b8d2		4881c108080000		ADDQ $0x808, CX				
  0x41b8d9		48890c24		MOVQ CX, 0(SP)				
  0x41b8dd		4889442408		MOVQ AX, 0x8(SP)			
  0x41b8e2		e8d97cffff		CALL runtime.(*mTreap).insert(SB)	
  0x41b8e7		488b6c2440		MOVQ 0x40(SP), BP			
  0x41b8ec		4883c448		ADDQ $0x48, SP				
  0x41b8f0		c3			RET					
	return &h.free[npages]
  0x41b8f1		48c1e204		SHLQ $0x4, DX		
  0x41b8f5		488d4c0a08		LEAQ 0x8(DX)(CX*1), CX	
		h.freeList(s.npages).insert(s)
  0x41b8fa		48890c24		MOVQ CX, 0(SP)				
  0x41b8fe		4889442408		MOVQ AX, 0x8(SP)			
  0x41b903		e848090000		CALL runtime.(*mSpanList).insert(SB)	
  0x41b908		ebdd			JMP 0x41b8e7				
	return &h.free[npages]
  0x41b90a		48c1e004		SHLQ $0x4, AX		
  0x41b90e		488d440808		LEAQ 0x8(AX)(CX*1), AX	
				h.freeList(after.npages).remove(after)
  0x41b913		48890424		MOVQ AX, 0(SP)				
  0x41b917		4889742408		MOVQ SI, 0x8(SP)			
  0x41b91c		e88f070000		CALL runtime.(*mSpanList).remove(SB)	
  0x41b921		e95dffffff		JMP 0x41b883				
	return &h.free[npages]
  0x41b926		48c1e604		SHLQ $0x4, SI		
  0x41b92a		488d4c0608		LEAQ 0x8(SI)(AX*1), CX	
				h.freeList(before.npages).remove(before)
  0x41b92f		48890c24		MOVQ CX, 0(SP)				
  0x41b933		48895c2408		MOVQ BX, 0x8(SP)			
  0x41b938		e873070000		CALL runtime.(*mSpanList).remove(SB)	
  0x41b93d		e94dfeffff		JMP 0x41b78f				
  0x41b942		4889c1			MOVQ AX, CX				
  0x41b945		4889d0			MOVQ DX, AX				
		if before != nil && before.state == _MSpanFree {
  0x41b948		e984feffff		JMP 0x41b7d1		
  0x41b94d		4889c1			MOVQ AX, CX		
  0x41b950		4889d0			MOVQ DX, AX		
  0x41b953		e979feffff		JMP 0x41b7d1		
  0x41b958		4889c1			MOVQ AX, CX		
  0x41b95b		4889d0			MOVQ DX, AX		
	if p > 0 {
  0x41b95e		e96efeffff		JMP 0x41b7d1		
		s.unusedsince = nanotime()
  0x41b963		e8c8c00200		CALL runtime.nanotime(SB)	
  0x41b968		488b0424		MOVQ 0(SP), AX			
  0x41b96c		488b4c2458		MOVQ 0x58(SP), CX		
  0x41b971		48894170		MOVQ AX, 0x70(CX)		
  0x41b975		e937fdffff		JMP 0x41b6b1			
	return &h.busylarge
  0x41b97a		8402			TESTB AL, 0(DX)		
  0x41b97c		488d8a10100000		LEAQ 0x1010(DX), CX	
		h.busyList(s.npages).remove(s)
  0x41b983		e904fdffff		JMP 0x41b68c		
	case _MSpanManual:
  0x41b988		80f902			CMPL $0x2, CL		
  0x41b98b		0f855a010000		JNE 0x41baeb		
		if s.allocCount != 0 {
  0x41b991		0fb74860		MOVZX 0x60(AX), CX	
  0x41b995		6685c9			TESTW CX, CX		
  0x41b998		0f8532010000		JNE 0x41bad0		
  0x41b99e		488b542450		MOVQ 0x50(SP), DX	
	switch s.state {
  0x41b9a3		e977fcffff		JMP 0x41b61f		
			h.spans[p+s.npages-1] = s
  0x41b9a8		e893400000		CALL runtime.panicindex(SB)	
  0x41b9ad		0f0b			UD2				
			h.spans[p] = s
  0x41b9af		e88c400000		CALL runtime.panicindex(SB)	
  0x41b9b4		0f0b			UD2				
		before := h.spans[p-1]
  0x41b9b6		e885400000		CALL runtime.panicindex(SB)	
  0x41b9bb		0f0b			UD2				
  0x41b9bd		488b4c2450		MOVQ 0x50(SP), CX		
			print("MHeap_FreeSpanLocked - span ", s, " ptr ", hex(s.base()), " allocCount ", s.allocCount, " sweepgen ", s.sweepgen, "/", h.sweepgen, "\n")
  0x41b9c2		8401			TESTB AL, 0(CX)		
  0x41b9c4		8b8920100000		MOVL 0x1020(CX), CX	
  0x41b9ca		48894c2430		MOVQ CX, 0x30(SP)	
  0x41b9cf		8b5058			MOVL 0x58(AX), DX	
  0x41b9d2		4889542428		MOVQ DX, 0x28(SP)	
	return s.startAddr
  0x41b9d7		488b5818		MOVQ 0x18(AX), BX	
  0x41b9db		48895c2418		MOVQ BX, 0x18(SP)	
			print("MHeap_FreeSpanLocked - span ", s, " ptr ", hex(s.base()), " allocCount ", s.allocCount, " sweepgen ", s.sweepgen, "/", h.sweepgen, "\n")
  0x41b9e0		e81b610000		CALL runtime.printlock(SB)	
  0x41b9e5		488d05ce050500		LEAQ 0x505ce(IP), AX		
  0x41b9ec		48890424		MOVQ AX, 0(SP)			
  0x41b9f0		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x41b9f9		e8426a0000		CALL runtime.printstring(SB)	
  0x41b9fe		488b442458		MOVQ 0x58(SP), AX		
  0x41ba03		48890424		MOVQ AX, 0(SP)			
  0x41ba07		e8f4690000		CALL runtime.printpointer(SB)	
  0x41ba0c		488d0564e30400		LEAQ 0x4e364(IP), AX		
  0x41ba13		48890424		MOVQ AX, 0(SP)			
  0x41ba17		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x41ba20		e81b6a0000		CALL runtime.printstring(SB)	
  0x41ba25		488b442418		MOVQ 0x18(SP), AX		
  0x41ba2a		48890424		MOVQ AX, 0(SP)			
  0x41ba2e		e8bd680000		CALL runtime.printhex(SB)	
  0x41ba33		488d05b4ea0400		LEAQ 0x4eab4(IP), AX		
  0x41ba3a		48890424		MOVQ AX, 0(SP)			
  0x41ba3e		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x41ba47		e8f4690000		CALL runtime.printstring(SB)	
  0x41ba4c		0fb7442416		MOVZX 0x16(SP), AX		
  0x41ba51		0fb7c0			MOVZX AX, AX			
  0x41ba54		48890424		MOVQ AX, 0(SP)			
  0x41ba58		e813670000		CALL runtime.printuint(SB)	
  0x41ba5d		488d0576e80400		LEAQ 0x4e876(IP), AX		
  0x41ba64		48890424		MOVQ AX, 0(SP)			
  0x41ba68		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41ba71		e8ca690000		CALL runtime.printstring(SB)	
  0x41ba76		488b442428		MOVQ 0x28(SP), AX		
  0x41ba7b		48890424		MOVQ AX, 0(SP)			
  0x41ba7f		e8ec660000		CALL runtime.printuint(SB)	
  0x41ba84		488d05cce10400		LEAQ 0x4e1cc(IP), AX		
  0x41ba8b		48890424		MOVQ AX, 0(SP)			
  0x41ba8f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x41ba98		e8a3690000		CALL runtime.printstring(SB)	
  0x41ba9d		488b442430		MOVQ 0x30(SP), AX		
  0x41baa2		48890424		MOVQ AX, 0(SP)			
  0x41baa6		e8c5660000		CALL runtime.printuint(SB)	
  0x41baab		e8e0620000		CALL runtime.printnl(SB)	
  0x41bab0		e8cb600000		CALL runtime.printunlock(SB)	
			throw("MHeap_FreeSpanLocked - invalid free")
  0x41bab5		488d050a120500		LEAQ 0x5120a(IP), AX	
  0x41babc		48890424		MOVQ AX, 0(SP)		
  0x41bac0		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x41bac9		e802570000		CALL runtime.throw(SB)	
  0x41bace		0f0b			UD2			
			throw("MHeap_FreeSpanLocked - invalid stack free")
  0x41bad0		488d05a9180500		LEAQ 0x518a9(IP), AX	
  0x41bad7		48890424		MOVQ AX, 0(SP)		
  0x41badb		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x41bae4		e8e7560000		CALL runtime.throw(SB)	
  0x41bae9		0f0b			UD2			
		throw("MHeap_FreeSpanLocked - invalid span state")
  0x41baeb		488d0565180500		LEAQ 0x51865(IP), AX	
  0x41baf2		48890424		MOVQ AX, 0(SP)		
  0x41baf6		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x41baff		e8cc560000		CALL runtime.throw(SB)	
  0x41bb04		0f0b			UD2			
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41bb06		e8658a0200		CALL runtime.morestack_noctxt(SB)	
  0x41bb0b		e9a0faffff		JMP runtime.(*mheap).freeSpanLocked(SB)	

TEXT runtime.scavengeTreapNode(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func scavengeTreapNode(t *treapNode, now, limit uint64) uintptr {
  0x41bb10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bb19		483b6110		CMPQ 0x10(CX), SP	
  0x41bb1d		0f860e010000		JBE 0x41bc31		
  0x41bb23		4883ec20		SUBQ $0x20, SP		
  0x41bb27		48896c2418		MOVQ BP, 0x18(SP)	
  0x41bb2c		488d6c2418		LEAQ 0x18(SP), BP	
  0x41bb31		488b442428		MOVQ 0x28(SP), AX	
	s := t.spanKey
  0x41bb36		488b4020		MOVQ 0x20(AX), AX	
	if (now-uint64(s.unusedsince)) > limit && s.npreleased != s.npages {
  0x41bb3a		8400			TESTB AL, 0(AX)		
  0x41bb3c		488d4870		LEAQ 0x70(AX), CX	
  0x41bb40		488b542430		MOVQ 0x30(SP), DX	
  0x41bb45		482b11			SUBQ 0(CX), DX		
  0x41bb48		488b4c2438		MOVQ 0x38(SP), CX	
  0x41bb4d		4839ca			CMPQ CX, DX		
  0x41bb50		0f86d7000000		JBE 0x41bc2d		
  0x41bb56		488b4878		MOVQ 0x78(AX), CX	
  0x41bb5a		488b5020		MOVQ 0x20(AX), DX	
  0x41bb5e		4839d1			CMPQ DX, CX		
  0x41bb61		0f84c2000000		JE 0x41bc29		
		end := start + s.npages<<_PageShift
  0x41bb67		48c1e20d		SHLQ $0xd, DX		
	return s.startAddr
  0x41bb6b		488b5818		MOVQ 0x18(AX), BX	
		end := start + s.npages<<_PageShift
  0x41bb6f		4801da			ADDQ BX, DX		
		if physPageSize > _PageSize {
  0x41bb72		488b35277e0a00		MOVQ runtime.physPageSize(SB), SI	
  0x41bb79		4881fe00200000		CMPQ $0x2000, SI			
  0x41bb80		0f869b000000		JBE 0x41bc21				
			start = (start + physPageSize - 1) &^ (physPageSize - 1)
  0x41bb86		488d5c33ff		LEAQ -0x1(BX)(SI*1), BX	
  0x41bb8b		488d7eff		LEAQ -0x1(SI), DI	
  0x41bb8f		48f7d7			NOTQ DI			
  0x41bb92		4821fb			ANDQ DI, BX		
			end &^= physPageSize - 1
  0x41bb95		4821d7			ANDQ DX, DI		
			if end <= start {
  0x41bb98		4839df			CMPQ BX, DI		
  0x41bb9b		7671			JBE 0x41bc0e		
		len := end - start
  0x41bb9d		4829df			SUBQ BX, DI		
		released := len - (s.npreleased << _PageShift)
  0x41bba0		48c1e10d		SHLQ $0xd, CX		
  0x41bba4		4889fa			MOVQ DI, DX		
  0x41bba7		4829cf			SUBQ CX, DI		
		if physPageSize > _PageSize {
  0x41bbaa		4881fe00200000		CMPQ $0x2000, SI	
		if physPageSize > _PageSize && released == 0 {
  0x41bbb1		7605			JBE 0x41bbb8		
  0x41bbb3		4885ff			TESTQ DI, DI		
  0x41bbb6		7443			JE 0x41bbfb		
  0x41bbb8		48897c2410		MOVQ DI, 0x10(SP)	
		memstats.heap_released += uint64(released)
  0x41bbbd		488b0d8c8b0a00		MOVQ runtime.memstats+80(SB), CX	
  0x41bbc4		4801f9			ADDQ DI, CX				
  0x41bbc7		48890d828b0a00		MOVQ CX, runtime.memstats+80(SB)	
  0x41bbce		4889d1			MOVQ DX, CX				
		s.npreleased = len >> _PageShift
  0x41bbd1		48c1ea0d		SHRQ $0xd, DX		
  0x41bbd5		48895078		MOVQ DX, 0x78(AX)	
		sysUnused(unsafe.Pointer(start), len)
  0x41bbd9		48891c24		MOVQ BX, 0(SP)			
  0x41bbdd		48894c2408		MOVQ CX, 0x8(SP)		
  0x41bbe2		e84935ffff		CALL runtime.sysUnused(SB)	
  0x41bbe7		488b442410		MOVQ 0x10(SP), AX		
	return sumreleased
  0x41bbec		4889442440		MOVQ AX, 0x40(SP)	
  0x41bbf1		488b6c2418		MOVQ 0x18(SP), BP	
  0x41bbf6		4883c420		ADDQ $0x20, SP		
  0x41bbfa		c3			RET			
			return sumreleased
  0x41bbfb		48c744244000000000	MOVQ $0x0, 0x40(SP)	
  0x41bc04		488b6c2418		MOVQ 0x18(SP), BP	
  0x41bc09		4883c420		ADDQ $0x20, SP		
  0x41bc0d		c3			RET			
				return sumreleased
  0x41bc0e		48c744244000000000	MOVQ $0x0, 0x40(SP)	
  0x41bc17		488b6c2418		MOVQ 0x18(SP), BP	
  0x41bc1c		4883c420		ADDQ $0x20, SP		
  0x41bc20		c3			RET			
  0x41bc21		4889d7			MOVQ DX, DI		
		if physPageSize > _PageSize {
  0x41bc24		e974ffffff		JMP 0x41bb9d		
  0x41bc29		31c0			XORL AX, AX		
	if (now-uint64(s.unusedsince)) > limit && s.npreleased != s.npages {
  0x41bc2b		ebbf			JMP 0x41bbec		
  0x41bc2d		31c0			XORL AX, AX		
  0x41bc2f		ebbb			JMP 0x41bbec		
func scavengeTreapNode(t *treapNode, now, limit uint64) uintptr {
  0x41bc31		e83a890200		CALL runtime.morestack_noctxt(SB)	
  0x41bc36		e9d5feffff		JMP runtime.scavengeTreapNode(SB)	

TEXT runtime.scavengelist(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func scavengelist(list *mSpanList, now, limit uint64) uintptr {
  0x41bc40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bc49		483b6110		CMPQ 0x10(CX), SP	
  0x41bc4d		0f862b010000		JBE 0x41bd7e		
  0x41bc53		4883ec30		SUBQ $0x30, SP		
  0x41bc57		48896c2428		MOVQ BP, 0x28(SP)	
  0x41bc5c		488d6c2428		LEAQ 0x28(SP), BP	
  0x41bc61		488b442438		MOVQ 0x38(SP), AX	
	return list.first == nil
  0x41bc66		488b00			MOVQ 0(AX), AX		
  0x41bc69		4885c0			TESTQ AX, AX		
	if list.isEmpty() {
  0x41bc6c		0f84f9000000		JE 0x41bd6b		
  0x41bc72		31c9			XORL CX, CX		
	for s := list.first; s != nil; s = s.next {
  0x41bc74		eb03			JMP 0x41bc79		
  0x41bc76		488b00			MOVQ 0(AX), AX		
  0x41bc79		4885c0			TESTQ AX, AX		
  0x41bc7c		0f84da000000		JE 0x41bd5c		
		if (now-uint64(s.unusedsince)) <= limit || s.npreleased == s.npages {
  0x41bc82		488b5070		MOVQ 0x70(AX), DX	
  0x41bc86		488b5c2440		MOVQ 0x40(SP), BX	
  0x41bc8b		4889de			MOVQ BX, SI		
  0x41bc8e		4829d3			SUBQ DX, BX		
  0x41bc91		488b542448		MOVQ 0x48(SP), DX	
  0x41bc96		4839d3			CMPQ DX, BX		
  0x41bc99		76db			JBE 0x41bc76		
  0x41bc9b		488b5878		MOVQ 0x78(AX), BX	
  0x41bc9f		488b7820		MOVQ 0x20(AX), DI	
  0x41bca3		4839fb			CMPQ DI, BX		
  0x41bca6		74ce			JE 0x41bc76		
		end := start + s.npages<<_PageShift
  0x41bca8		48c1e70d		SHLQ $0xd, DI		
	return s.startAddr
  0x41bcac		4c8b4018		MOVQ 0x18(AX), R8	
		end := start + s.npages<<_PageShift
  0x41bcb0		4c01c7			ADDQ R8, DI		
		if physPageSize > _PageSize {
  0x41bcb3		4c8b0de67c0a00		MOVQ runtime.physPageSize(SB), R9	
  0x41bcba		4981f900200000		CMPQ $0x2000, R9			
  0x41bcc1		0f8690000000		JBE 0x41bd57				
			start = (start + physPageSize - 1) &^ (physPageSize - 1)
  0x41bcc7		4f8d4408ff		LEAQ -0x1(R8)(R9*1), R8	
  0x41bccc		4d8d51ff		LEAQ -0x1(R9), R10	
  0x41bcd0		49f7d2			NOTQ R10		
  0x41bcd3		4d21d0			ANDQ R10, R8		
			end &^= physPageSize - 1
  0x41bcd6		4921fa			ANDQ DI, R10		
			if end <= start {
  0x41bcd9		4d39c2			CMPQ R8, R10		
  0x41bcdc		7698			JBE 0x41bc76		
  0x41bcde		48894c2410		MOVQ CX, 0x10(SP)	
		len := end - start
  0x41bce3		4d29c2			SUBQ R8, R10		
		released := len - (s.npreleased << _PageShift)
  0x41bce6		48c1e30d		SHLQ $0xd, BX		
  0x41bcea		4c89d7			MOVQ R10, DI		
  0x41bced		4929da			SUBQ BX, R10		
		if physPageSize > _PageSize {
  0x41bcf0		4981f900200000		CMPQ $0x2000, R9	
		if physPageSize > _PageSize && released == 0 {
  0x41bcf7		7609			JBE 0x41bd02		
  0x41bcf9		4d85d2			TESTQ R10, R10		
  0x41bcfc		0f8474ffffff		JE 0x41bc76		
  0x41bd02		4889442420		MOVQ AX, 0x20(SP)	
  0x41bd07		4c89542418		MOVQ R10, 0x18(SP)	
		memstats.heap_released += uint64(released)
  0x41bd0c		488b0d3d8a0a00		MOVQ runtime.memstats+80(SB), CX	
  0x41bd13		4c01d1			ADDQ R10, CX				
  0x41bd16		48890d338a0a00		MOVQ CX, runtime.memstats+80(SB)	
  0x41bd1d		4889f9			MOVQ DI, CX				
		s.npreleased = len >> _PageShift
  0x41bd20		48c1ef0d		SHRQ $0xd, DI		
  0x41bd24		48897878		MOVQ DI, 0x78(AX)	
		sysUnused(unsafe.Pointer(start), len)
  0x41bd28		4c890424		MOVQ R8, 0(SP)			
  0x41bd2c		48894c2408		MOVQ CX, 0x8(SP)		
  0x41bd31		e8fa33ffff		CALL runtime.sysUnused(SB)	
  0x41bd36		488b442418		MOVQ 0x18(SP), AX		
  0x41bd3b		488b4c2410		MOVQ 0x10(SP), CX		
		sumreleased += released
  0x41bd40		4801c1			ADDQ AX, CX		
  0x41bd43		488b442420		MOVQ 0x20(SP), AX	
  0x41bd48		488b542448		MOVQ 0x48(SP), DX	
  0x41bd4d		488b742440		MOVQ 0x40(SP), SI	
		sysUnused(unsafe.Pointer(start), len)
  0x41bd52		e91fffffff		JMP 0x41bc76		
  0x41bd57		4989fa			MOVQ DI, R10		
		if physPageSize > _PageSize {
  0x41bd5a		eb82			JMP 0x41bcde		
	return sumreleased
  0x41bd5c		48894c2450		MOVQ CX, 0x50(SP)	
  0x41bd61		488b6c2428		MOVQ 0x28(SP), BP	
  0x41bd66		4883c430		ADDQ $0x30, SP		
  0x41bd6a		c3			RET			
		return 0
  0x41bd6b		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x41bd74		488b6c2428		MOVQ 0x28(SP), BP	
  0x41bd79		4883c430		ADDQ $0x30, SP		
  0x41bd7d		c3			RET			
func scavengelist(list *mSpanList, now, limit uint64) uintptr {
  0x41bd7e		e8ed870200		CALL runtime.morestack_noctxt(SB)	
  0x41bd83		e9b8feffff		JMP runtime.scavengelist(SB)		

TEXT runtime.(*mheap).scavenge(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (h *mheap) scavenge(k int32, now, limit uint64) {
  0x41bd90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bd99		483b6110		CMPQ 0x10(CX), SP	
  0x41bd9d		0f86f5020000		JBE 0x41c098		
  0x41bda3		4883ec68		SUBQ $0x68, SP		
  0x41bda7		48896c2460		MOVQ BP, 0x60(SP)	
  0x41bdac		488d6c2460		LEAQ 0x60(SP), BP	
	gp := getg()
  0x41bdb1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41bdba		4889442458		MOVQ AX, 0x58(SP)	
	gp.m.mallocing++
  0x41bdbf		488b4830		MOVQ 0x30(AX), CX	
  0x41bdc3		ff81e8000000		INCL 0xe8(CX)		
func (h *mheap) scavenge(k int32, now, limit uint64) {
  0x41bdc9		488b4c2470		MOVQ 0x70(SP), CX	
	lock(&h.lock)
  0x41bdce		8401			TESTB AL, 0(CX)		
  0x41bdd0		48890c24		MOVQ CX, 0(SP)		
  0x41bdd4		e847d7feff		CALL runtime.lock(SB)	
func (h *mheap) scavenge(k int32, now, limit uint64) {
  0x41bdd9		31c0			XORL AX, AX		
  0x41bddb		31c9			XORL CX, CX		
	for i := 0; i < len(h.free); i++ {
  0x41bddd		eb4b			JMP 0x41be2a		
  0x41bddf		4889442428		MOVQ AX, 0x28(SP)	
		sumreleased += scavengelist(&h.free[i], now, limit)
  0x41bde4		48c1e004		SHLQ $0x4, AX			
  0x41bde8		488b542470		MOVQ 0x70(SP), DX		
  0x41bded		488d440208		LEAQ 0x8(DX)(AX*1), AX		
  0x41bdf2		48890424		MOVQ AX, 0(SP)			
  0x41bdf6		488b842480000000	MOVQ 0x80(SP), AX		
  0x41bdfe		4889442408		MOVQ AX, 0x8(SP)		
  0x41be03		488b9c2488000000	MOVQ 0x88(SP), BX		
  0x41be0b		48895c2410		MOVQ BX, 0x10(SP)		
  0x41be10		e82bfeffff		CALL runtime.scavengelist(SB)	
  0x41be15		488b442428		MOVQ 0x28(SP), AX		
	for i := 0; i < len(h.free); i++ {
  0x41be1a		48ffc0			INCQ AX			
		sumreleased += scavengelist(&h.free[i], now, limit)
  0x41be1d		488b4c2418		MOVQ 0x18(SP), CX	
  0x41be22		488b542420		MOVQ 0x20(SP), DX	
  0x41be27		4801d1			ADDQ DX, CX		
	for i := 0; i < len(h.free); i++ {
  0x41be2a		48894c2420		MOVQ CX, 0x20(SP)	
  0x41be2f		483d80000000		CMPQ $0x80, AX		
  0x41be35		7ca8			JL 0x41bddf		
  0x41be37		488b442470		MOVQ 0x70(SP), AX	
	sumreleased += scavengetreap(h.freelarge.treap, now, limit)
  0x41be3c		488b8808080000		MOVQ 0x808(AX), CX		
  0x41be43		48890c24		MOVQ CX, 0(SP)			
  0x41be47		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x41be4f		48894c2408		MOVQ CX, 0x8(SP)		
  0x41be54		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x41be5c		48894c2410		MOVQ CX, 0x10(SP)		
  0x41be61		e8da7cffff		CALL runtime.scavengetreap(SB)	
  0x41be66		488b442418		MOVQ 0x18(SP), AX		
  0x41be6b		4889442450		MOVQ AX, 0x50(SP)		
  0x41be70		488b4c2470		MOVQ 0x70(SP), CX		
	unlock(&h.lock)
  0x41be75		48890c24		MOVQ CX, 0(SP)		
  0x41be79		e842d8feff		CALL runtime.unlock(SB)	
  0x41be7e		488b442458		MOVQ 0x58(SP), AX	
	gp.m.mallocing--
  0x41be83		488b4030		MOVQ 0x30(AX), AX	
  0x41be87		8380e8000000ff		ADDL $-0x1, 0xe8(AX)	
  0x41be8e		488b442450		MOVQ 0x50(SP), AX	
  0x41be93		488b4c2420		MOVQ 0x20(SP), CX	
	sumreleased += scavengetreap(h.freelarge.treap, now, limit)
  0x41be98		4801c8			ADDQ CX, AX		
	if debug.gctrace > 0 {
  0x41be9b		8b0d3f7c0a00		MOVL runtime.debug+32(SB), CX	
  0x41bea1		85c9			TESTL CX, CX			
  0x41bea3		0f8e64010000		JLE 0x41c00d			
		if sumreleased > 0 {
  0x41bea9		4885c0			TESTQ AX, AX		
  0x41beac		0f8765010000		JA 0x41c017		
		print("scvg", k, ": inuse: ", memstats.heap_inuse>>20, ", idle: ", memstats.heap_idle>>20, ", sys: ", memstats.heap_sys>>20, ", released: ", memstats.heap_released>>20, ", consumed: ", (memstats.heap_sys-memstats.heap_released)>>20, " (MB)\n")
  0x41beb2		488b058f880a00		MOVQ runtime.memstats+72(SB), AX	
  0x41beb9		4889442448		MOVQ AX, 0x48(SP)			
  0x41bebe		488b0d7b880a00		MOVQ runtime.memstats+64(SB), CX	
  0x41bec5		48894c2440		MOVQ CX, 0x40(SP)			
  0x41beca		488b1567880a00		MOVQ runtime.memstats+56(SB), DX	
  0x41bed1		4889542438		MOVQ DX, 0x38(SP)			
  0x41bed6		488b1d73880a00		MOVQ runtime.memstats+80(SB), BX	
  0x41bedd		48895c2430		MOVQ BX, 0x30(SP)			
  0x41bee2		e8195c0000		CALL runtime.printlock(SB)		
  0x41bee7		488d0540de0400		LEAQ 0x4de40(IP), AX			
  0x41beee		48890424		MOVQ AX, 0(SP)				
  0x41bef2		48c744240804000000	MOVQ $0x4, 0x8(SP)			
  0x41befb		e840650000		CALL runtime.printstring(SB)		
  0x41bf00		8b442478		MOVL 0x78(SP), AX			
  0x41bf04		4863c0			MOVSXD AX, AX				
  0x41bf07		48890424		MOVQ AX, 0(SP)				
  0x41bf0b		e870630000		CALL runtime.printint(SB)		
  0x41bf10		488d05cae10400		LEAQ 0x4e1ca(IP), AX			
  0x41bf17		48890424		MOVQ AX, 0(SP)				
  0x41bf1b		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x41bf24		e817650000		CALL runtime.printstring(SB)		
  0x41bf29		488b442448		MOVQ 0x48(SP), AX			
  0x41bf2e		48c1e814		SHRQ $0x14, AX				
  0x41bf32		48890424		MOVQ AX, 0(SP)				
  0x41bf36		e835620000		CALL runtime.printuint(SB)		
  0x41bf3b		488d05ade00400		LEAQ 0x4e0ad(IP), AX			
  0x41bf42		48890424		MOVQ AX, 0(SP)				
  0x41bf46		48c744240808000000	MOVQ $0x8, 0x8(SP)			
  0x41bf4f		e8ec640000		CALL runtime.printstring(SB)		
  0x41bf54		488b442440		MOVQ 0x40(SP), AX			
  0x41bf59		48c1e814		SHRQ $0x14, AX				
  0x41bf5d		48890424		MOVQ AX, 0(SP)				
  0x41bf61		e80a620000		CALL runtime.printuint(SB)		
  0x41bf66		488d052cdf0400		LEAQ 0x4df2c(IP), AX			
  0x41bf6d		48890424		MOVQ AX, 0(SP)				
  0x41bf71		48c744240807000000	MOVQ $0x7, 0x8(SP)			
  0x41bf7a		e8c1640000		CALL runtime.printstring(SB)		
  0x41bf7f		488b442438		MOVQ 0x38(SP), AX			
  0x41bf84		48c1e814		SHRQ $0x14, AX				
  0x41bf88		48890424		MOVQ AX, 0(SP)				
  0x41bf8c		e8df610000		CALL runtime.printuint(SB)		
  0x41bf91		488d05fee50400		LEAQ 0x4e5fe(IP), AX			
  0x41bf98		48890424		MOVQ AX, 0(SP)				
  0x41bf9c		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x41bfa5		e896640000		CALL runtime.printstring(SB)		
  0x41bfaa		488b442430		MOVQ 0x30(SP), AX			
  0x41bfaf		48c1e814		SHRQ $0x14, AX				
  0x41bfb3		48890424		MOVQ AX, 0(SP)				
  0x41bfb7		e8b4610000		CALL runtime.printuint(SB)		
  0x41bfbc		488d05c7e50400		LEAQ 0x4e5c7(IP), AX			
  0x41bfc3		48890424		MOVQ AX, 0(SP)				
  0x41bfc7		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x41bfd0		e86b640000		CALL runtime.printstring(SB)		
  0x41bfd5		488b442438		MOVQ 0x38(SP), AX			
  0x41bfda		488b4c2430		MOVQ 0x30(SP), CX			
  0x41bfdf		4829c8			SUBQ CX, AX				
  0x41bfe2		48c1e814		SHRQ $0x14, AX				
  0x41bfe6		48890424		MOVQ AX, 0(SP)				
  0x41bfea		e881610000		CALL runtime.printuint(SB)		
  0x41bfef		488d05e5dd0400		LEAQ 0x4dde5(IP), AX			
  0x41bff6		48890424		MOVQ AX, 0(SP)				
  0x41bffa		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x41c003		e838640000		CALL runtime.printstring(SB)		
  0x41c008		e8735b0000		CALL runtime.printunlock(SB)		
  0x41c00d		488b6c2460		MOVQ 0x60(SP), BP			
  0x41c012		4883c468		ADDQ $0x68, SP				
  0x41c016		c3			RET					
  0x41c017		4889442420		MOVQ AX, 0x20(SP)			
			print("scvg", k, ": ", sumreleased>>20, " MB released\n")
  0x41c01c		e8df5a0000		CALL runtime.printlock(SB)	
  0x41c021		488d0506dd0400		LEAQ 0x4dd06(IP), AX		
  0x41c028		48890424		MOVQ AX, 0(SP)			
  0x41c02c		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x41c035		e806640000		CALL runtime.printstring(SB)	
  0x41c03a		8b442478		MOVL 0x78(SP), AX		
  0x41c03e		4863c8			MOVSXD AX, CX			
  0x41c041		48890c24		MOVQ CX, 0(SP)			
  0x41c045		e836620000		CALL runtime.printint(SB)	
  0x41c04a		488d051fdc0400		LEAQ 0x4dc1f(IP), AX		
  0x41c051		48890424		MOVQ AX, 0(SP)			
  0x41c055		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41c05e		e8dd630000		CALL runtime.printstring(SB)	
  0x41c063		488b442420		MOVQ 0x20(SP), AX		
  0x41c068		48c1e814		SHRQ $0x14, AX			
  0x41c06c		48890424		MOVQ AX, 0(SP)			
  0x41c070		e8fb600000		CALL runtime.printuint(SB)	
  0x41c075		488d05cee50400		LEAQ 0x4e5ce(IP), AX		
  0x41c07c		48890424		MOVQ AX, 0(SP)			
  0x41c080		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x41c089		e8b2630000		CALL runtime.printstring(SB)	
  0x41c08e		e8ed5a0000		CALL runtime.printunlock(SB)	
  0x41c093		e91afeffff		JMP 0x41beb2			
func (h *mheap) scavenge(k int32, now, limit uint64) {
  0x41c098		e8d3840200		CALL runtime.morestack_noctxt(SB)	
  0x41c09d		e9eefcffff		JMP runtime.(*mheap).scavenge(SB)	

TEXT runtime.(*mSpanList).remove(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (list *mSpanList) remove(span *mspan) {
  0x41c0b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c0b9		483b6110		CMPQ 0x10(CX), SP	
  0x41c0bd		0f8675010000		JBE 0x41c238		
  0x41c0c3		4883ec30		SUBQ $0x30, SP		
  0x41c0c7		48896c2428		MOVQ BP, 0x28(SP)	
  0x41c0cc		488d6c2428		LEAQ 0x28(SP), BP	
  0x41c0d1		488b442440		MOVQ 0x40(SP), AX	
	if span.list != list {
  0x41c0d6		488b4810		MOVQ 0x10(AX), CX	
  0x41c0da		488b542438		MOVQ 0x38(SP), DX	
  0x41c0df		4839d1			CMPQ DX, CX		
  0x41c0e2		7550			JNE 0x41c134		
	if list.first == span {
  0x41c0e4		488b0a			MOVQ 0(DX), CX		
  0x41c0e7		4839c1			CMPQ AX, CX		
  0x41c0ea		753c			JNE 0x41c128		
		list.first = span.next
  0x41c0ec		488b08			MOVQ 0(AX), CX		
  0x41c0ef		48890a			MOVQ CX, 0(DX)		
	if list.last == span {
  0x41c0f2		488b4a08		MOVQ 0x8(DX), CX	
  0x41c0f6		4839c8			CMPQ CX, AX		
  0x41c0f9		7520			JNE 0x41c11b		
		list.last = span.prev
  0x41c0fb		488b4808		MOVQ 0x8(AX), CX	
  0x41c0ff		48894a08		MOVQ CX, 0x8(DX)	
	span.prev = nil
  0x41c103		0f57c0			XORPS X0, X0		
  0x41c106		0f1100			MOVUPS X0, 0(AX)	
	span.list = nil
  0x41c109		48c7401000000000	MOVQ $0x0, 0x10(AX)	
}
  0x41c111		488b6c2428		MOVQ 0x28(SP), BP	
  0x41c116		4883c430		ADDQ $0x30, SP		
  0x41c11a		c3			RET			
		span.next.prev = span.prev
  0x41c11b		488b08			MOVQ 0(AX), CX		
  0x41c11e		488b5008		MOVQ 0x8(AX), DX	
  0x41c122		48895108		MOVQ DX, 0x8(CX)	
  0x41c126		ebdb			JMP 0x41c103		
		span.prev.next = span.next
  0x41c128		488b4808		MOVQ 0x8(AX), CX	
  0x41c12c		488b18			MOVQ 0(AX), BX		
  0x41c12f		488919			MOVQ BX, 0(CX)		
  0x41c132		ebbe			JMP 0x41c0f2		
  0x41c134		48894c2420		MOVQ CX, 0x20(SP)	
		print("runtime: failed MSpanList_Remove span.npages=", span.npages,
  0x41c139		488b4820		MOVQ 0x20(AX), CX	
  0x41c13d		48894c2410		MOVQ CX, 0x10(SP)	
			" span=", span, " prev=", span.prev, " span.list=", span.list, " list=", list, "\n")
  0x41c142		488b5008		MOVQ 0x8(AX), DX	
  0x41c146		4889542418		MOVQ DX, 0x18(SP)	
		print("runtime: failed MSpanList_Remove span.npages=", span.npages,
  0x41c14b		e8b0590000		CALL runtime.printlock(SB)	
  0x41c150		488d05a8150500		LEAQ 0x515a8(IP), AX		
  0x41c157		48890424		MOVQ AX, 0(SP)			
  0x41c15b		48c74424082d000000	MOVQ $0x2d, 0x8(SP)		
  0x41c164		e8d7620000		CALL runtime.printstring(SB)	
  0x41c169		488b442410		MOVQ 0x10(SP), AX		
  0x41c16e		48890424		MOVQ AX, 0(SP)			
  0x41c172		e8f95f0000		CALL runtime.printuint(SB)	
  0x41c177		488d05a5dc0400		LEAQ 0x4dca5(IP), AX		
  0x41c17e		48890424		MOVQ AX, 0(SP)			
  0x41c182		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x41c18b		e8b0620000		CALL runtime.printstring(SB)	
  0x41c190		488b442440		MOVQ 0x40(SP), AX		
  0x41c195		48890424		MOVQ AX, 0(SP)			
  0x41c199		e862620000		CALL runtime.printpointer(SB)	
  0x41c19e		488d0578dc0400		LEAQ 0x4dc78(IP), AX		
  0x41c1a5		48890424		MOVQ AX, 0(SP)			
  0x41c1a9		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x41c1b2		e889620000		CALL runtime.printstring(SB)	
  0x41c1b7		488b442418		MOVQ 0x18(SP), AX		
  0x41c1bc		48890424		MOVQ AX, 0(SP)			
  0x41c1c0		e83b620000		CALL runtime.printpointer(SB)	
  0x41c1c5		488d0566e20400		LEAQ 0x4e266(IP), AX		
  0x41c1cc		48890424		MOVQ AX, 0(SP)			
  0x41c1d0		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x41c1d9		e862620000		CALL runtime.printstring(SB)	
  0x41c1de		488b442420		MOVQ 0x20(SP), AX		
  0x41c1e3		48890424		MOVQ AX, 0(SP)			
  0x41c1e7		e814620000		CALL runtime.printpointer(SB)	
  0x41c1ec		488d0518dc0400		LEAQ 0x4dc18(IP), AX		
  0x41c1f3		48890424		MOVQ AX, 0(SP)			
  0x41c1f7		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x41c200		e83b620000		CALL runtime.printstring(SB)	
  0x41c205		488b442438		MOVQ 0x38(SP), AX		
  0x41c20a		48890424		MOVQ AX, 0(SP)			
  0x41c20e		e8ed610000		CALL runtime.printpointer(SB)	
  0x41c213		e8785b0000		CALL runtime.printnl(SB)	
  0x41c218		e863590000		CALL runtime.printunlock(SB)	
		throw("MSpanList_Remove")
  0x41c21d		488d053ee80400		LEAQ 0x4e83e(IP), AX	
  0x41c224		48890424		MOVQ AX, 0(SP)		
  0x41c228		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x41c231		e89a4f0000		CALL runtime.throw(SB)	
  0x41c236		0f0b			UD2			
func (list *mSpanList) remove(span *mspan) {
  0x41c238		e833830200		CALL runtime.morestack_noctxt(SB)	
  0x41c23d		e96efeffff		JMP runtime.(*mSpanList).remove(SB)	

TEXT runtime.(*mSpanList).insert(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (list *mSpanList) insert(span *mspan) {
  0x41c250		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c259		483b6110		CMPQ 0x10(CX), SP	
  0x41c25d		0f86fc000000		JBE 0x41c35f		
  0x41c263		4883ec30		SUBQ $0x30, SP		
  0x41c267		48896c2428		MOVQ BP, 0x28(SP)	
  0x41c26c		488d6c2428		LEAQ 0x28(SP), BP	
  0x41c271		488b442440		MOVQ 0x40(SP), AX	
	if span.next != nil || span.prev != nil || span.list != nil {
  0x41c276		488b08			MOVQ 0(AX), CX		
  0x41c279		48894c2420		MOVQ CX, 0x20(SP)	
  0x41c27e		4885c9			TESTQ CX, CX		
  0x41c281		7540			JNE 0x41c2c3		
  0x41c283		488b5008		MOVQ 0x8(AX), DX	
  0x41c287		4885d2			TESTQ DX, DX		
  0x41c28a		7537			JNE 0x41c2c3		
  0x41c28c		488b5010		MOVQ 0x10(AX), DX	
  0x41c290		4885d2			TESTQ DX, DX		
  0x41c293		752e			JNE 0x41c2c3		
  0x41c295		488b4c2438		MOVQ 0x38(SP), CX	
	span.next = list.first
  0x41c29a		488b11			MOVQ 0(CX), DX		
  0x41c29d		488910			MOVQ DX, 0(AX)		
	if list.first != nil {
  0x41c2a0		488b11			MOVQ 0(CX), DX		
  0x41c2a3		4885d2			TESTQ DX, DX		
  0x41c2a6		7415			JE 0x41c2bd		
		list.first.prev = span
  0x41c2a8		48894208		MOVQ AX, 0x8(DX)	
	list.first = span
  0x41c2ac		488901			MOVQ AX, 0(CX)		
	span.list = list
  0x41c2af		48894810		MOVQ CX, 0x10(AX)	
}
  0x41c2b3		488b6c2428		MOVQ 0x28(SP), BP	
  0x41c2b8		4883c430		ADDQ $0x30, SP		
  0x41c2bc		c3			RET			
		list.last = span
  0x41c2bd		48894108		MOVQ AX, 0x8(CX)	
  0x41c2c1		ebe9			JMP 0x41c2ac		
		println("runtime: failed MSpanList_Insert", span, span.next, span.prev, span.list)
  0x41c2c3		488b4808		MOVQ 0x8(AX), CX		
  0x41c2c7		48894c2418		MOVQ CX, 0x18(SP)		
  0x41c2cc		488b5010		MOVQ 0x10(AX), DX		
  0x41c2d0		4889542410		MOVQ DX, 0x10(SP)		
  0x41c2d5		e826580000		CALL runtime.printlock(SB)	
  0x41c2da		488d058a070500		LEAQ 0x5078a(IP), AX		
  0x41c2e1		48890424		MOVQ AX, 0(SP)			
  0x41c2e5		48c744240821000000	MOVQ $0x21, 0x8(SP)		
  0x41c2ee		e84d610000		CALL runtime.printstring(SB)	
  0x41c2f3		488b442440		MOVQ 0x40(SP), AX		
  0x41c2f8		48890424		MOVQ AX, 0(SP)			
  0x41c2fc		e8ff600000		CALL runtime.printpointer(SB)	
  0x41c301		e83a5a0000		CALL runtime.printsp(SB)	
  0x41c306		488b442420		MOVQ 0x20(SP), AX		
  0x41c30b		48890424		MOVQ AX, 0(SP)			
  0x41c30f		e8ec600000		CALL runtime.printpointer(SB)	
  0x41c314		e8275a0000		CALL runtime.printsp(SB)	
  0x41c319		488b442418		MOVQ 0x18(SP), AX		
  0x41c31e		48890424		MOVQ AX, 0(SP)			
  0x41c322		e8d9600000		CALL runtime.printpointer(SB)	
  0x41c327		e8145a0000		CALL runtime.printsp(SB)	
  0x41c32c		488b442410		MOVQ 0x10(SP), AX		
  0x41c331		48890424		MOVQ AX, 0(SP)			
  0x41c335		e8c6600000		CALL runtime.printpointer(SB)	
  0x41c33a		e8515a0000		CALL runtime.printnl(SB)	
  0x41c33f		e83c580000		CALL runtime.printunlock(SB)	
		throw("MSpanList_Insert")
  0x41c344		488d0507e70400		LEAQ 0x4e707(IP), AX	
  0x41c34b		48890424		MOVQ AX, 0(SP)		
  0x41c34f		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x41c358		e8734e0000		CALL runtime.throw(SB)	
  0x41c35d		0f0b			UD2			
func (list *mSpanList) insert(span *mspan) {
  0x41c35f		e80c820200		CALL runtime.morestack_noctxt(SB)	
  0x41c364		e9e7feffff		JMP runtime.(*mSpanList).insert(SB)	

TEXT runtime.(*mSpanList).insertBack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (list *mSpanList) insertBack(span *mspan) {
  0x41c370		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c379		483b6110		CMPQ 0x10(CX), SP	
  0x41c37d		0f86fe000000		JBE 0x41c481		
  0x41c383		4883ec30		SUBQ $0x30, SP		
  0x41c387		48896c2428		MOVQ BP, 0x28(SP)	
  0x41c38c		488d6c2428		LEAQ 0x28(SP), BP	
  0x41c391		488b442440		MOVQ 0x40(SP), AX	
	if span.next != nil || span.prev != nil || span.list != nil {
  0x41c396		488b08			MOVQ 0(AX), CX		
  0x41c399		48894c2420		MOVQ CX, 0x20(SP)	
  0x41c39e		4885c9			TESTQ CX, CX		
  0x41c3a1		7542			JNE 0x41c3e5		
  0x41c3a3		488b5008		MOVQ 0x8(AX), DX	
  0x41c3a7		4885d2			TESTQ DX, DX		
  0x41c3aa		7539			JNE 0x41c3e5		
  0x41c3ac		488b5010		MOVQ 0x10(AX), DX	
  0x41c3b0		4885d2			TESTQ DX, DX		
  0x41c3b3		7530			JNE 0x41c3e5		
  0x41c3b5		488b4c2438		MOVQ 0x38(SP), CX	
	span.prev = list.last
  0x41c3ba		488b5108		MOVQ 0x8(CX), DX	
  0x41c3be		48895008		MOVQ DX, 0x8(AX)	
	if list.last != nil {
  0x41c3c2		488b5108		MOVQ 0x8(CX), DX	
  0x41c3c6		4885d2			TESTQ DX, DX		
  0x41c3c9		7415			JE 0x41c3e0		
		list.last.next = span
  0x41c3cb		488902			MOVQ AX, 0(DX)		
	list.last = span
  0x41c3ce		48894108		MOVQ AX, 0x8(CX)	
	span.list = list
  0x41c3d2		48894810		MOVQ CX, 0x10(AX)	
}
  0x41c3d6		488b6c2428		MOVQ 0x28(SP), BP	
  0x41c3db		4883c430		ADDQ $0x30, SP		
  0x41c3df		c3			RET			
		list.first = span
  0x41c3e0		488901			MOVQ AX, 0(CX)		
  0x41c3e3		ebe9			JMP 0x41c3ce		
		println("runtime: failed MSpanList_InsertBack", span, span.next, span.prev, span.list)
  0x41c3e5		488b4808		MOVQ 0x8(AX), CX		
  0x41c3e9		48894c2418		MOVQ CX, 0x18(SP)		
  0x41c3ee		488b5010		MOVQ 0x10(AX), DX		
  0x41c3f2		4889542410		MOVQ DX, 0x10(SP)		
  0x41c3f7		e804570000		CALL runtime.printlock(SB)	
  0x41c3fc		488d05fc0b0500		LEAQ 0x50bfc(IP), AX		
  0x41c403		48890424		MOVQ AX, 0(SP)			
  0x41c407		48c744240825000000	MOVQ $0x25, 0x8(SP)		
  0x41c410		e82b600000		CALL runtime.printstring(SB)	
  0x41c415		488b442440		MOVQ 0x40(SP), AX		
  0x41c41a		48890424		MOVQ AX, 0(SP)			
  0x41c41e		e8dd5f0000		CALL runtime.printpointer(SB)	
  0x41c423		e818590000		CALL runtime.printsp(SB)	
  0x41c428		488b442420		MOVQ 0x20(SP), AX		
  0x41c42d		48890424		MOVQ AX, 0(SP)			
  0x41c431		e8ca5f0000		CALL runtime.printpointer(SB)	
  0x41c436		e805590000		CALL runtime.printsp(SB)	
  0x41c43b		488b442418		MOVQ 0x18(SP), AX		
  0x41c440		48890424		MOVQ AX, 0(SP)			
  0x41c444		e8b75f0000		CALL runtime.printpointer(SB)	
  0x41c449		e8f2580000		CALL runtime.printsp(SB)	
  0x41c44e		488b442410		MOVQ 0x10(SP), AX		
  0x41c453		48890424		MOVQ AX, 0(SP)			
  0x41c457		e8a45f0000		CALL runtime.printpointer(SB)	
  0x41c45c		e82f590000		CALL runtime.printnl(SB)	
  0x41c461		e81a570000		CALL runtime.printunlock(SB)	
		throw("MSpanList_InsertBack")
  0x41c466		488d05aceb0400		LEAQ 0x4ebac(IP), AX	
  0x41c46d		48890424		MOVQ AX, 0(SP)		
  0x41c471		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41c47a		e8514d0000		CALL runtime.throw(SB)	
  0x41c47f		0f0b			UD2			
func (list *mSpanList) insertBack(span *mspan) {
  0x41c481		e8ea800200		CALL runtime.morestack_noctxt(SB)	
  0x41c486		e9e5feffff		JMP runtime.(*mSpanList).insertBack(SB)	

TEXT runtime.(*mSpanList).takeAll(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func (list *mSpanList) takeAll(other *mSpanList) {
  0x41c490		488b442410		MOVQ 0x10(SP), AX	
	return list.first == nil
  0x41c495		488b08			MOVQ 0(AX), CX		
  0x41c498		4885c9			TESTQ CX, CX		
	if other.isEmpty() {
  0x41c49b		744a			JE 0x41c4e7		
  0x41c49d		488b542408		MOVQ 0x8(SP), DX	
	for s := other.first; s != nil; s = s.next {
  0x41c4a2		eb07			JMP 0x41c4ab		
		s.list = list
  0x41c4a4		48895110		MOVQ DX, 0x10(CX)	
	for s := other.first; s != nil; s = s.next {
  0x41c4a8		488b09			MOVQ 0(CX), CX		
  0x41c4ab		4885c9			TESTQ CX, CX		
  0x41c4ae		75f4			JNE 0x41c4a4		
	return list.first == nil
  0x41c4b0		488b0a			MOVQ 0(DX), CX		
  0x41c4b3		4885c9			TESTQ CX, CX		
	if list.isEmpty() {
  0x41c4b6		741f			JE 0x41c4d7		
		other.last.next = list.first
  0x41c4b8		488b5808		MOVQ 0x8(AX), BX	
  0x41c4bc		48890b			MOVQ CX, 0(BX)		
		list.first.prev = other.last
  0x41c4bf		488b0a			MOVQ 0(DX), CX		
  0x41c4c2		488b5808		MOVQ 0x8(AX), BX	
  0x41c4c6		48895908		MOVQ BX, 0x8(CX)	
		list.first = other.first
  0x41c4ca		488b08			MOVQ 0(AX), CX		
  0x41c4cd		48890a			MOVQ CX, 0(DX)		
	other.first, other.last = nil, nil
  0x41c4d0		0f57c0			XORPS X0, X0		
  0x41c4d3		0f1100			MOVUPS X0, 0(AX)	
}
  0x41c4d6		c3			RET			
		*list = *other
  0x41c4d7		488b4808		MOVQ 0x8(AX), CX	
  0x41c4db		488b18			MOVQ 0(AX), BX		
  0x41c4de		48891a			MOVQ BX, 0(DX)		
  0x41c4e1		48894a08		MOVQ CX, 0x8(DX)	
  0x41c4e5		ebe9			JMP 0x41c4d0		
		return
  0x41c4e7		c3			RET			

TEXT runtime.addspecial(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func addspecial(p unsafe.Pointer, s *special) bool {
  0x41c4f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c4f9		483b6110		CMPQ 0x10(CX), SP	
  0x41c4fd		0f860f020000		JBE 0x41c712		
  0x41c503		4883ec40		SUBQ $0x40, SP		
  0x41c507		48896c2438		MOVQ BP, 0x38(SP)	
  0x41c50c		488d6c2438		LEAQ 0x38(SP), BP	
  0x41c511		488b442448		MOVQ 0x48(SP), AX	
  0x41c516		4889c1			MOVQ AX, CX		
	if uintptr(v) < h.arena_start || uintptr(v) >= h.arena_used {
  0x41c519		488b15a8100900		MOVQ runtime.mheap_+4904(SB), DX	
  0x41c520		4839d0			CMPQ DX, AX				
  0x41c523		0f8367010000		JAE 0x41c690				
  0x41c529		31c0			XORL AX, AX				
	if span == nil {
  0x41c52b		4885c0			TESTQ AX, AX		
  0x41c52e		0f84bc010000		JE 0x41c6f0		
  0x41c534		4889442420		MOVQ AX, 0x20(SP)	
	_g_ := getg()
  0x41c539		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x41c542		488b5130		MOVQ 0x30(CX), DX	
  0x41c546		ff8200010000		INCL 0x100(DX)		
	return _g_.m
  0x41c54c		488b4930		MOVQ 0x30(CX), CX	
  0x41c550		48894c2428		MOVQ CX, 0x28(SP)	
	span.ensureSwept()
  0x41c555		48890424		MOVQ AX, 0(SP)				
  0x41c559		e882b9ffff		CALL runtime.(*mspan).ensureSwept(SB)	
  0x41c55e		488b442448		MOVQ 0x48(SP), AX			
	offset := uintptr(p) - span.base()
  0x41c563		488b4c2420		MOVQ 0x20(SP), CX	
	return s.startAddr
  0x41c568		488d5118		LEAQ 0x18(CX), DX	
	offset := uintptr(p) - span.base()
  0x41c56c		482b02			SUBQ 0(DX), AX		
  0x41c56f		4889442418		MOVQ AX, 0x18(SP)	
  0x41c574		488b542450		MOVQ 0x50(SP), DX	
	kind := s.kind
  0x41c579		0fb65a0a		MOVZX 0xa(DX), BX	
  0x41c57d		885c2417		MOVB BL, 0x17(SP)	
	lock(&span.speciallock)
  0x41c581		488db188000000		LEAQ 0x88(CX), SI	
  0x41c588		4889742430		MOVQ SI, 0x30(SP)	
  0x41c58d		48893424		MOVQ SI, 0(SP)		
  0x41c591		e88acffeff		CALL runtime.lock(SB)	
  0x41c596		488b442420		MOVQ 0x20(SP), AX	
	t := &span.specials
  0x41c59b		480590000000		ADDQ $0x90, AX		
  0x41c5a1		0fb64c2417		MOVZX 0x17(SP), CX	
  0x41c5a6		488b542418		MOVQ 0x18(SP), DX	
	for {
  0x41c5ab		eb03			JMP 0x41c5b0		
  0x41c5ad		4889d8			MOVQ BX, AX		
		x := *t
  0x41c5b0		488b18			MOVQ 0(AX), BX		
		if x == nil {
  0x41c5b3		4885db			TESTQ BX, BX		
  0x41c5b6		7422			JE 0x41c5da		
		if offset == uintptr(x.offset) && kind == x.kind {
  0x41c5b8		0fb77308		MOVZX 0x8(BX), SI	
  0x41c5bc		4839f2			CMPQ SI, DX		
  0x41c5bf		750c			JNE 0x41c5cd		
  0x41c5c1		0fb67b0a		MOVZX 0xa(BX), DI	
  0x41c5c5		4038f9			CMPL DI, CL		
  0x41c5c8		7474			JE 0x41c63e		
  0x41c5ca		4839f2			CMPQ SI, DX		
		if offset < uintptr(x.offset) || (offset == uintptr(x.offset) && kind < x.kind) {
  0x41c5cd		720b			JB 0x41c5da		
  0x41c5cf		75dc			JNE 0x41c5ad		
  0x41c5d1		0fb6730a		MOVZX 0xa(BX), SI	
  0x41c5d5		4038f1			CMPL SI, CL		
  0x41c5d8		73d3			JAE 0x41c5ad		
  0x41c5da		488b4c2450		MOVQ 0x50(SP), CX	
	s.offset = uint16(offset)
  0x41c5df		66895108		MOVW DX, 0x8(CX)	
	s.next = *t
  0x41c5e3		488b10			MOVQ 0(AX), DX		
  0x41c5e6		488911			MOVQ DX, 0(CX)		
	*t = s
  0x41c5e9		488908			MOVQ CX, 0(AX)		
  0x41c5ec		488b442430		MOVQ 0x30(SP), AX	
	unlock(&span.speciallock)
  0x41c5f1		48890424		MOVQ AX, 0(SP)		
  0x41c5f5		e8c6d0feff		CALL runtime.unlock(SB)	
	_g_ := getg()
  0x41c5fa		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41c603		488b4c2428		MOVQ 0x28(SP), CX	
	mp.locks--
  0x41c608		8b9100010000		MOVL 0x100(CX), DX	
  0x41c60e		8d5aff			LEAL -0x1(DX), BX	
  0x41c611		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x41c617		83fa01			CMPL $0x1, DX		
  0x41c61a		7513			JNE 0x41c62f		
  0x41c61c		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x41c623		84c9			TESTL CL, CL		
  0x41c625		7408			JE 0x41c62f		
		_g_.stackguard0 = stackPreempt
  0x41c627		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	return true
  0x41c62f		c644245801		MOVB $0x1, 0x58(SP)	
  0x41c634		488b6c2438		MOVQ 0x38(SP), BP	
  0x41c639		4883c440		ADDQ $0x40, SP		
  0x41c63d		c3			RET			
  0x41c63e		488b442430		MOVQ 0x30(SP), AX	
			unlock(&span.speciallock)
  0x41c643		48890424		MOVQ AX, 0(SP)		
  0x41c647		e874d0feff		CALL runtime.unlock(SB)	
	_g_ := getg()
  0x41c64c		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41c655		488b4c2428		MOVQ 0x28(SP), CX	
	mp.locks--
  0x41c65a		8b9100010000		MOVL 0x100(CX), DX	
  0x41c660		8d5aff			LEAL -0x1(DX), BX	
  0x41c663		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x41c669		83fa01			CMPL $0x1, DX		
  0x41c66c		7513			JNE 0x41c681		
  0x41c66e		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x41c675		84c9			TESTL CL, CL		
  0x41c677		7408			JE 0x41c681		
		_g_.stackguard0 = stackPreempt
  0x41c679		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
			return false // already exists
  0x41c681		c644245800		MOVB $0x0, 0x58(SP)	
  0x41c686		488b6c2438		MOVQ 0x38(SP), BP	
  0x41c68b		4883c440		ADDQ $0x40, SP		
  0x41c68f		c3			RET			
	if uintptr(v) < h.arena_start || uintptr(v) >= h.arena_used {
  0x41c690		488b1d390f0900		MOVQ runtime.mheap_+4912(SB), BX	
  0x41c697		4839d8			CMPQ BX, AX				
  0x41c69a		0f8389feffff		JAE 0x41c529				
	s := h.spans[(uintptr(v)-h.arena_start)>>_PageShift]
  0x41c6a0		488b1d490c0900		MOVQ runtime.mheap_+4176(SB), BX	
  0x41c6a7		488b353a0c0900		MOVQ runtime.mheap_+4168(SB), SI	
  0x41c6ae		4889c7			MOVQ AX, DI				
  0x41c6b1		4829d0			SUBQ DX, AX				
  0x41c6b4		48c1e80d		SHRQ $0xd, AX				
  0x41c6b8		4839d8			CMPQ BX, AX				
  0x41c6bb		734e			JAE 0x41c70b				
  0x41c6bd		488b04c6		MOVQ 0(SI)(AX*8), AX			
	if s == nil || uintptr(v) < s.base() || uintptr(v) >= uintptr(unsafe.Pointer(s.limit)) || s.state != _MSpanInUse {
  0x41c6c1		4885c0			TESTQ AX, AX		
  0x41c6c4		7409			JE 0x41c6cf		
	return s.startAddr
  0x41c6c6		488b5018		MOVQ 0x18(AX), DX	
	if s == nil || uintptr(v) < s.base() || uintptr(v) >= uintptr(unsafe.Pointer(s.limit)) || s.state != _MSpanInUse {
  0x41c6ca		4839d7			CMPQ DX, DI		
  0x41c6cd		7307			JAE 0x41c6d6		
  0x41c6cf		31c0			XORL AX, AX		
	span := mheap_.lookupMaybe(p)
  0x41c6d1		e955feffff		JMP 0x41c52b		
	if s == nil || uintptr(v) < s.base() || uintptr(v) >= uintptr(unsafe.Pointer(s.limit)) || s.state != _MSpanInUse {
  0x41c6d6		488b9080000000		MOVQ 0x80(AX), DX	
  0x41c6dd		4839d7			CMPQ DX, DI		
  0x41c6e0		73ed			JAE 0x41c6cf		
  0x41c6e2		0fb65064		MOVZX 0x64(AX), DX	
  0x41c6e6		80fa01			CMPL $0x1, DL		
  0x41c6e9		75e4			JNE 0x41c6cf		
  0x41c6eb		e93bfeffff		JMP 0x41c52b		
		throw("addspecial on invalid pointer")
  0x41c6f0		488d0549fb0400		LEAQ 0x4fb49(IP), AX	
  0x41c6f7		48890424		MOVQ AX, 0(SP)		
  0x41c6fb		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x41c704		e8c74a0000		CALL runtime.throw(SB)	
  0x41c709		0f0b			UD2			
	s := h.spans[(uintptr(v)-h.arena_start)>>_PageShift]
  0x41c70b		e830330000		CALL runtime.panicindex(SB)	
  0x41c710		0f0b			UD2				
func addspecial(p unsafe.Pointer, s *special) bool {
  0x41c712		e8597e0200		CALL runtime.morestack_noctxt(SB)	
  0x41c717		e9d4fdffff		JMP runtime.addspecial(SB)		

TEXT runtime.setprofilebucket(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func setprofilebucket(p unsafe.Pointer, b *bucket) {
  0x41c720		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c729		483b6110		CMPQ 0x10(CX), SP	
  0x41c72d		0f869b000000		JBE 0x41c7ce		
  0x41c733		4883ec28		SUBQ $0x28, SP		
  0x41c737		48896c2420		MOVQ BP, 0x20(SP)	
  0x41c73c		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&mheap_.speciallock)
  0x41c741		488d0590310900		LEAQ runtime.mheap_+13880(SB), AX	
  0x41c748		48890424		MOVQ AX, 0(SP)				
  0x41c74c		e8cfcdfeff		CALL runtime.lock(SB)			
	s := (*specialprofile)(mheap_.specialprofilealloc.alloc())
  0x41c751		488d0538310900		LEAQ runtime.mheap_+13808(SB), AX	
  0x41c758		48890424		MOVQ AX, 0(SP)				
  0x41c75c		e8df32ffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x41c761		488b442408		MOVQ 0x8(SP), AX			
  0x41c766		4889442418		MOVQ AX, 0x18(SP)			
	unlock(&mheap_.speciallock)
  0x41c76b		488d0d66310900		LEAQ runtime.mheap_+13880(SB), CX	
  0x41c772		48890c24		MOVQ CX, 0(SP)				
  0x41c776		e845cffeff		CALL runtime.unlock(SB)			
  0x41c77b		488b442418		MOVQ 0x18(SP), AX			
	s.special.kind = _KindSpecialProfile
  0x41c780		c6400a02		MOVB $0x2, 0xa(AX)	
func setprofilebucket(p unsafe.Pointer, b *bucket) {
  0x41c784		488b4c2438		MOVQ 0x38(SP), CX	
	s.b = b
  0x41c789		48894810		MOVQ CX, 0x10(AX)	
	if !addspecial(p, &s.special) {
  0x41c78d		4889442408		MOVQ AX, 0x8(SP)	
func setprofilebucket(p unsafe.Pointer, b *bucket) {
  0x41c792		488b442430		MOVQ 0x30(SP), AX	
	if !addspecial(p, &s.special) {
  0x41c797		48890424		MOVQ AX, 0(SP)			
  0x41c79b		e850fdffff		CALL runtime.addspecial(SB)	
  0x41c7a0		0fb6442410		MOVZX 0x10(SP), AX		
  0x41c7a5		84c0			TESTL AL, AL			
  0x41c7a7		740a			JE 0x41c7b3			
  0x41c7a9		488b6c2420		MOVQ 0x20(SP), BP		
  0x41c7ae		4883c428		ADDQ $0x28, SP			
  0x41c7b2		c3			RET				
		throw("setprofilebucket: profile already set")
  0x41c7b3		488d056a080500		LEAQ 0x5086a(IP), AX	
  0x41c7ba		48890424		MOVQ AX, 0(SP)		
  0x41c7be		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x41c7c7		e8044a0000		CALL runtime.throw(SB)	
  0x41c7cc		0f0b			UD2			
func setprofilebucket(p unsafe.Pointer, b *bucket) {
  0x41c7ce		e89d7d0200		CALL runtime.morestack_noctxt(SB)	
  0x41c7d3		e948ffffff		JMP runtime.setprofilebucket(SB)	

TEXT runtime.freespecial(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func freespecial(s *special, p unsafe.Pointer, size uintptr) {
  0x41c7e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c7e9		483b6110		CMPQ 0x10(CX), SP	
  0x41c7ed		0f8640010000		JBE 0x41c933		
  0x41c7f3		4883ec30		SUBQ $0x30, SP		
  0x41c7f7		48896c2428		MOVQ BP, 0x28(SP)	
  0x41c7fc		488d6c2428		LEAQ 0x28(SP), BP	
  0x41c801		488b442438		MOVQ 0x38(SP), AX	
	switch s.kind {
  0x41c806		0fb6480a		MOVZX 0xa(AX), CX	
	case _KindSpecialFinalizer:
  0x41c80a		80f901			CMPL $0x1, CL		
  0x41c80d		747e			JE 0x41c88d		
	case _KindSpecialProfile:
  0x41c80f		80f902			CMPL $0x2, CL		
  0x41c812		0f8500010000		JNE 0x41c918		
		mProf_Free(sp.b, size)
  0x41c818		488b4810		MOVQ 0x10(AX), CX		
  0x41c81c		48890c24		MOVQ CX, 0(SP)			
  0x41c820		488b4c2448		MOVQ 0x48(SP), CX		
  0x41c825		48894c2408		MOVQ CX, 0x8(SP)		
  0x41c82a		e8110f0000		CALL runtime.mProf_Free(SB)	
		lock(&mheap_.speciallock)
  0x41c82f		488d05a2300900		LEAQ runtime.mheap_+13880(SB), AX	
  0x41c836		48890424		MOVQ AX, 0(SP)				
  0x41c83a		e8e1ccfeff		CALL runtime.lock(SB)			
	f.inuse -= f.size
  0x41c83f		488d054a300900		LEAQ runtime.mheap_+13808(SB), AX	
  0x41c846		8400			TESTB AL, 0(AX)				
  0x41c848		488b0571300900		MOVQ runtime.mheap_+13856(SB), AX	
  0x41c84f		482b053a300900		SUBQ runtime.mheap_+13808(SB), AX	
  0x41c856		48890563300900		MOVQ AX, runtime.mheap_+13856(SB)	
	v.next = f.list
  0x41c85d		488b0544300900		MOVQ runtime.mheap_+13832(SB), AX	
  0x41c864		488b4c2438		MOVQ 0x38(SP), CX			
  0x41c869		488901			MOVQ AX, 0(CX)				
	f.list = v
  0x41c86c		48890d35300900		MOVQ CX, runtime.mheap_+13832(SB)	
		unlock(&mheap_.speciallock)
  0x41c873		488d055e300900		LEAQ runtime.mheap_+13880(SB), AX	
  0x41c87a		48890424		MOVQ AX, 0(SP)				
  0x41c87e		e83dcefeff		CALL runtime.unlock(SB)			
  0x41c883		488b6c2428		MOVQ 0x28(SP), BP			
  0x41c888		4883c430		ADDQ $0x30, SP				
  0x41c88c		c3			RET					
		queuefinalizer(p, sf.fn, sf.nret, sf.fint, sf.ot)
  0x41c88d		488b4810		MOVQ 0x10(AX), CX		
  0x41c891		488b5018		MOVQ 0x18(AX), DX		
  0x41c895		488b5820		MOVQ 0x20(AX), BX		
  0x41c899		488b7028		MOVQ 0x28(AX), SI		
  0x41c89d		4889742420		MOVQ SI, 0x20(SP)		
  0x41c8a2		488b742440		MOVQ 0x40(SP), SI		
  0x41c8a7		48893424		MOVQ SI, 0(SP)			
  0x41c8ab		48894c2408		MOVQ CX, 0x8(SP)		
  0x41c8b0		4889542410		MOVQ DX, 0x10(SP)		
  0x41c8b5		48895c2418		MOVQ BX, 0x18(SP)		
  0x41c8ba		e8a12effff		CALL runtime.queuefinalizer(SB)	
		lock(&mheap_.speciallock)
  0x41c8bf		488d0512300900		LEAQ runtime.mheap_+13880(SB), AX	
  0x41c8c6		48890424		MOVQ AX, 0(SP)				
  0x41c8ca		e851ccfeff		CALL runtime.lock(SB)			
	f.inuse -= f.size
  0x41c8cf		488d05722f0900		LEAQ runtime.mheap_+13736(SB), AX	
  0x41c8d6		8400			TESTB AL, 0(AX)				
  0x41c8d8		488b05992f0900		MOVQ runtime.mheap_+13784(SB), AX	
  0x41c8df		482b05622f0900		SUBQ runtime.mheap_+13736(SB), AX	
  0x41c8e6		4889058b2f0900		MOVQ AX, runtime.mheap_+13784(SB)	
	v.next = f.list
  0x41c8ed		488b056c2f0900		MOVQ runtime.mheap_+13760(SB), AX	
  0x41c8f4		488b4c2438		MOVQ 0x38(SP), CX			
  0x41c8f9		488901			MOVQ AX, 0(CX)				
	f.list = v
  0x41c8fc		48890d5d2f0900		MOVQ CX, runtime.mheap_+13760(SB)	
		unlock(&mheap_.speciallock)
  0x41c903		488d05ce2f0900		LEAQ runtime.mheap_+13880(SB), AX	
  0x41c90a		48890424		MOVQ AX, 0(SP)				
  0x41c90e		e8adcdfeff		CALL runtime.unlock(SB)			
	switch s.kind {
  0x41c913		e96bffffff		JMP 0x41c883		
		throw("bad special kind")
  0x41c918		488d0583e10400		LEAQ 0x4e183(IP), AX	
  0x41c91f		48890424		MOVQ AX, 0(SP)		
  0x41c923		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x41c92c		e89f480000		CALL runtime.throw(SB)	
  0x41c931		0f0b			UD2			
func freespecial(s *special, p unsafe.Pointer, size uintptr) {
  0x41c933		e8387c0200		CALL runtime.morestack_noctxt(SB)	
  0x41c938		e9a3feffff		JMP runtime.freespecial(SB)		

TEXT runtime.newMarkBits(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func newMarkBits(nelems uintptr) *gcBits {
  0x41c940		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c949		483b6110		CMPQ 0x10(CX), SP	
  0x41c94d		0f86d7020000		JBE 0x41cc2a		
  0x41c953		4883ec40		SUBQ $0x40, SP		
  0x41c957		48896c2438		MOVQ BP, 0x38(SP)	
  0x41c95c		488d6c2438		LEAQ 0x38(SP), BP	
	head := (*gcBitsArena)(atomic.Loadp(unsafe.Pointer(&gcBitsArenas.next)))
  0x41c961		488b05a8ae0800		MOVQ runtime.gcBitsArenas+16(SB), AX	
func newMarkBits(nelems uintptr) *gcBits {
  0x41c968		488b4c2448		MOVQ 0x48(SP), CX	
	blocksNeeded := uintptr((nelems + 63) / 64)
  0x41c96d		4883c13f		ADDQ $0x3f, CX		
  0x41c971		48c1e906		SHRQ $0x6, CX		
  0x41c975		4889ca			MOVQ CX, DX		
	bytesNeeded := blocksNeeded * 8
  0x41c978		48c1e103		SHLQ $0x3, CX		
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41c97c		4885c0			TESTQ AX, AX		
  0x41c97f		7414			JE 0x41c995		
  0x41c981		488b18			MOVQ 0(AX), BX		
  0x41c984		488d1cd3		LEAQ 0(BX)(DX*8), BX	
  0x41c988		4881fbf0ff0000		CMPQ $0xfff0, BX	
  0x41c98f		0f8626020000		JBE 0x41cbbb		
  0x41c995		31c0			XORL AX, AX		
	if p := head.tryAlloc(bytesNeeded); p != nil {
  0x41c997		4885c0			TESTQ AX, AX		
  0x41c99a		0f850c020000		JNE 0x41cbac		
  0x41c9a0		48894c2418		MOVQ CX, 0x18(SP)	
  0x41c9a5		4889542410		MOVQ DX, 0x10(SP)	
	lock(&gcBitsArenas.lock)
  0x41c9aa		488d054fae0800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41c9b1		48890424		MOVQ AX, 0(SP)				
  0x41c9b5		e866cbfeff		CALL runtime.lock(SB)			
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41c9ba		488b054fae0800		MOVQ runtime.gcBitsArenas+16(SB), AX	
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41c9c1		4885c0			TESTQ AX, AX		
  0x41c9c4		0f84d8010000		JE 0x41cba2		
  0x41c9ca		488b08			MOVQ 0(AX), CX		
  0x41c9cd		488b542410		MOVQ 0x10(SP), DX	
  0x41c9d2		488d0cd1		LEAQ 0(CX)(DX*8), CX	
  0x41c9d6		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41c9dd		0f8684010000		JBE 0x41cb67		
  0x41c9e3		31c0			XORL AX, AX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41c9e5		4885c0			TESTQ AX, AX		
  0x41c9e8		0f8550010000		JNE 0x41cb3e		
	fresh := newArenaMayUnlock()
  0x41c9ee		e85d030000		CALL runtime.newArenaMayUnlock(SB)	
  0x41c9f3		488b0424		MOVQ 0(SP), AX				
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41c9f7		488b0d12ae0800		MOVQ runtime.gcBitsArenas+16(SB), CX	
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41c9fe		4885c9			TESTQ CX, CX		
  0x41ca01		0f842d010000		JE 0x41cb34		
  0x41ca07		488b11			MOVQ 0(CX), DX		
  0x41ca0a		488b5c2410		MOVQ 0x10(SP), BX	
  0x41ca0f		488d14da		LEAQ 0(DX)(BX*8), DX	
  0x41ca13		4881faf0ff0000		CMPQ $0xfff0, DX	
  0x41ca1a		0f86d9000000		JBE 0x41caf9		
  0x41ca20		31c9			XORL CX, CX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41ca22		4885c9			TESTQ CX, CX		
  0x41ca25		0f8593000000		JNE 0x41cabe		
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41ca2b		4885c0			TESTQ AX, AX		
  0x41ca2e		7410			JE 0x41ca40		
  0x41ca30		488b08			MOVQ 0(AX), CX		
  0x41ca33		488d0cd9		LEAQ 0(CX)(BX*8), CX	
  0x41ca37		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41ca3e		7649			JBE 0x41ca89		
  0x41ca40		31c9			XORL CX, CX		
	if p == nil {
  0x41ca42		4885c9			TESTQ CX, CX		
  0x41ca45		0f84a8010000		JE 0x41cbf3		
  0x41ca4b		48894c2430		MOVQ CX, 0x30(SP)	
	fresh.next = gcBitsArenas.next
  0x41ca50		488b0db9ad0800		MOVQ runtime.gcBitsArenas+16(SB), CX	
  0x41ca57		48894808		MOVQ CX, 0x8(AX)			
	atomic.StorepNoWB(unsafe.Pointer(&gcBitsArenas.next), unsafe.Pointer(fresh))
  0x41ca5b		488d0daead0800		LEAQ runtime.gcBitsArenas+16(SB), CX	
  0x41ca62		488701			XCHGQ AX, 0(CX)				
	unlock(&gcBitsArenas.lock)
  0x41ca65		488d0594ad0800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41ca6c		48890424		MOVQ AX, 0(SP)				
  0x41ca70		e84bccfeff		CALL runtime.unlock(SB)			
	return p
  0x41ca75		488b442430		MOVQ 0x30(SP), AX	
  0x41ca7a		4889442450		MOVQ AX, 0x50(SP)	
  0x41ca7f		488b6c2438		MOVQ 0x38(SP), BP	
  0x41ca84		4883c440		ADDQ $0x40, SP		
  0x41ca88		c3			RET			
  0x41ca89		488b4c2418		MOVQ 0x18(SP), CX	
  0x41ca8e		4889ca			MOVQ CX, DX		
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41ca91		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x41ca96		488d0cd9		LEAQ 0(CX)(BX*8), CX	
	if end > uintptr(len(b.bits)) {
  0x41ca9a		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41caa1		7604			JBE 0x41caa7		
  0x41caa3		31c9			XORL CX, CX		
	p := fresh.tryAlloc(bytesNeeded)
  0x41caa5		eb9b			JMP 0x41ca42		
	start := end - bytes
  0x41caa7		4829d1			SUBQ DX, CX		
	return &b.bits[start]
  0x41caaa		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41cab1		0f8357010000		JAE 0x41cc0e		
  0x41cab7		488d4c0810		LEAQ 0x10(AX)(CX*1), CX	
	p := fresh.tryAlloc(bytesNeeded)
  0x41cabc		eb84			JMP 0x41ca42		
  0x41cabe		48894c2428		MOVQ CX, 0x28(SP)	
		fresh.next = gcBitsArenas.free
  0x41cac3		488b0d3ead0800		MOVQ runtime.gcBitsArenas+8(SB), CX	
  0x41caca		48894808		MOVQ CX, 0x8(AX)			
		gcBitsArenas.free = fresh
  0x41cace		48890533ad0800		MOVQ AX, runtime.gcBitsArenas+8(SB)	
		unlock(&gcBitsArenas.lock)
  0x41cad5		488d0524ad0800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41cadc		48890424		MOVQ AX, 0(SP)				
  0x41cae0		e8dbcbfeff		CALL runtime.unlock(SB)			
		return p
  0x41cae5		488b442428		MOVQ 0x28(SP), AX	
  0x41caea		4889442450		MOVQ AX, 0x50(SP)	
  0x41caef		488b6c2438		MOVQ 0x38(SP), BP	
  0x41caf4		4883c440		ADDQ $0x40, SP		
  0x41caf8		c3			RET			
  0x41caf9		488b542418		MOVQ 0x18(SP), DX	
  0x41cafe		4889d6			MOVQ DX, SI		
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41cb01		f0480fc111		LOCK XADDQ DX, 0(CX)	
  0x41cb06		488d14da		LEAQ 0(DX)(BX*8), DX	
	if end > uintptr(len(b.bits)) {
  0x41cb0a		4881faf0ff0000		CMPQ $0xfff0, DX	
  0x41cb11		7607			JBE 0x41cb1a		
  0x41cb13		31c9			XORL CX, CX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41cb15		e908ffffff		JMP 0x41ca22		
	start := end - bytes
  0x41cb1a		4829f2			SUBQ SI, DX		
	return &b.bits[start]
  0x41cb1d		4881faf0ff0000		CMPQ $0xfff0, DX	
  0x41cb24		0f83eb000000		JAE 0x41cc15		
  0x41cb2a		488d4c0a10		LEAQ 0x10(DX)(CX*1), CX	
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41cb2f		e9eefeffff		JMP 0x41ca22		
  0x41cb34		488b5c2410		MOVQ 0x10(SP), BX	
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41cb39		e9e2feffff		JMP 0x41ca20		
  0x41cb3e		4889442420		MOVQ AX, 0x20(SP)	
		unlock(&gcBitsArenas.lock)
  0x41cb43		488d05b6ac0800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41cb4a		48890424		MOVQ AX, 0(SP)				
  0x41cb4e		e86dcbfeff		CALL runtime.unlock(SB)			
		return p
  0x41cb53		488b442420		MOVQ 0x20(SP), AX	
  0x41cb58		4889442450		MOVQ AX, 0x50(SP)	
  0x41cb5d		488b6c2438		MOVQ 0x38(SP), BP	
  0x41cb62		4883c440		ADDQ $0x40, SP		
  0x41cb66		c3			RET			
  0x41cb67		488b4c2418		MOVQ 0x18(SP), CX	
  0x41cb6c		4889cb			MOVQ CX, BX		
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41cb6f		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x41cb74		488d0cd1		LEAQ 0(CX)(DX*8), CX	
	if end > uintptr(len(b.bits)) {
  0x41cb78		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41cb7f		7607			JBE 0x41cb88		
  0x41cb81		31c0			XORL AX, AX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41cb83		e95dfeffff		JMP 0x41c9e5		
	start := end - bytes
  0x41cb88		4829d9			SUBQ BX, CX		
	return &b.bits[start]
  0x41cb8b		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41cb92		0f8384000000		JAE 0x41cc1c		
  0x41cb98		488d440110		LEAQ 0x10(CX)(AX*1), AX	
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41cb9d		e943feffff		JMP 0x41c9e5		
  0x41cba2		488b542410		MOVQ 0x10(SP), DX	
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41cba7		e937feffff		JMP 0x41c9e3		
		return p
  0x41cbac		4889442450		MOVQ AX, 0x50(SP)	
  0x41cbb1		488b6c2438		MOVQ 0x38(SP), BP	
  0x41cbb6		4883c440		ADDQ $0x40, SP		
  0x41cbba		c3			RET			
  0x41cbbb		4889cb			MOVQ CX, BX		
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41cbbe		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x41cbc3		488d0cd1		LEAQ 0(CX)(DX*8), CX	
	if end > uintptr(len(b.bits)) {
  0x41cbc7		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41cbce		760a			JBE 0x41cbda		
  0x41cbd0		4889d9			MOVQ BX, CX		
  0x41cbd3		31c0			XORL AX, AX		
	if p := head.tryAlloc(bytesNeeded); p != nil {
  0x41cbd5		e9bdfdffff		JMP 0x41c997		
	start := end - bytes
  0x41cbda		4829d9			SUBQ BX, CX		
	return &b.bits[start]
  0x41cbdd		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41cbe4		733d			JAE 0x41cc23		
  0x41cbe6		488d440810		LEAQ 0x10(AX)(CX*1), AX	
  0x41cbeb		4889d9			MOVQ BX, CX		
	if p := head.tryAlloc(bytesNeeded); p != nil {
  0x41cbee		e9a4fdffff		JMP 0x41c997		
		throw("markBits overflow")
  0x41cbf3		488d0574e00400		LEAQ 0x4e074(IP), AX	
  0x41cbfa		48890424		MOVQ AX, 0(SP)		
  0x41cbfe		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x41cc07		e8c4450000		CALL runtime.throw(SB)	
  0x41cc0c		0f0b			UD2			
	return &b.bits[start]
  0x41cc0e		e82d2e0000		CALL runtime.panicindex(SB)	
  0x41cc13		0f0b			UD2				
  0x41cc15		e8262e0000		CALL runtime.panicindex(SB)	
  0x41cc1a		0f0b			UD2				
  0x41cc1c		e81f2e0000		CALL runtime.panicindex(SB)	
  0x41cc21		0f0b			UD2				
  0x41cc23		e8182e0000		CALL runtime.panicindex(SB)	
  0x41cc28		0f0b			UD2				
func newMarkBits(nelems uintptr) *gcBits {
  0x41cc2a		e841790200		CALL runtime.morestack_noctxt(SB)	
  0x41cc2f		e90cfdffff		JMP runtime.newMarkBits(SB)		

TEXT runtime.newAllocBits(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func newAllocBits(nelems uintptr) *gcBits {
  0x41cc40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41cc49		483b6110		CMPQ 0x10(CX), SP	
  0x41cc4d		7630			JBE 0x41cc7f		
  0x41cc4f		4883ec18		SUBQ $0x18, SP		
  0x41cc53		48896c2410		MOVQ BP, 0x10(SP)	
  0x41cc58		488d6c2410		LEAQ 0x10(SP), BP	
  0x41cc5d		488b442420		MOVQ 0x20(SP), AX	
	return newMarkBits(nelems)
  0x41cc62		48890424		MOVQ AX, 0(SP)			
  0x41cc66		e8d5fcffff		CALL runtime.newMarkBits(SB)	
  0x41cc6b		488b442408		MOVQ 0x8(SP), AX		
  0x41cc70		4889442428		MOVQ AX, 0x28(SP)		
  0x41cc75		488b6c2410		MOVQ 0x10(SP), BP		
  0x41cc7a		4883c418		ADDQ $0x18, SP			
  0x41cc7e		c3			RET				
func newAllocBits(nelems uintptr) *gcBits {
  0x41cc7f		e8ec780200		CALL runtime.morestack_noctxt(SB)	
  0x41cc84		ebba			JMP runtime.newAllocBits(SB)		

TEXT runtime.nextMarkBitArenaEpoch(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func nextMarkBitArenaEpoch() {
  0x41cc90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41cc99		483b6110		CMPQ 0x10(CX), SP	
  0x41cc9d		0f86a1000000		JBE 0x41cd44		
  0x41cca3		4883ec10		SUBQ $0x10, SP		
  0x41cca7		48896c2408		MOVQ BP, 0x8(SP)	
  0x41ccac		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&gcBitsArenas.lock)
  0x41ccb1		488d0548ab0800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41ccb8		48890424		MOVQ AX, 0(SP)				
  0x41ccbc		e85fc8feff		CALL runtime.lock(SB)			
	if gcBitsArenas.previous != nil {
  0x41ccc1		488b0558ab0800		MOVQ runtime.gcBitsArenas+32(SB), AX	
  0x41ccc8		4885c0			TESTQ AX, AX				
  0x41cccb		742c			JE 0x41ccf9				
		if gcBitsArenas.free == nil {
  0x41cccd		488b0d34ab0800		MOVQ runtime.gcBitsArenas+8(SB), CX	
  0x41ccd4		4885c9			TESTQ CX, CX				
  0x41ccd7		7505			JNE 0x41ccde				
  0x41ccd9		eb60			JMP 0x41cd3b				
  0x41ccdb		4889d0			MOVQ DX, AX				
			for last = gcBitsArenas.previous; last.next != nil; last = last.next {
  0x41ccde		488b5008		MOVQ 0x8(AX), DX	
  0x41cce2		4885d2			TESTQ DX, DX		
  0x41cce5		75f4			JNE 0x41ccdb		
			last.next = gcBitsArenas.free
  0x41cce7		48894808		MOVQ CX, 0x8(AX)	
			gcBitsArenas.free = gcBitsArenas.previous
  0x41cceb		488b052eab0800		MOVQ runtime.gcBitsArenas+32(SB), AX	
  0x41ccf2		4889050fab0800		MOVQ AX, runtime.gcBitsArenas+8(SB)	
	gcBitsArenas.previous = gcBitsArenas.current
  0x41ccf9		488b0518ab0800		MOVQ runtime.gcBitsArenas+24(SB), AX	
  0x41cd00		48890519ab0800		MOVQ AX, runtime.gcBitsArenas+32(SB)	
	gcBitsArenas.current = gcBitsArenas.next
  0x41cd07		488b0502ab0800		MOVQ runtime.gcBitsArenas+16(SB), AX	
  0x41cd0e		48890503ab0800		MOVQ AX, runtime.gcBitsArenas+24(SB)	
	atomic.StorepNoWB(unsafe.Pointer(&gcBitsArenas.next), nil) // newMarkBits calls newArena when needed
  0x41cd15		31c0			XORL AX, AX				
  0x41cd17		488d0df2aa0800		LEAQ runtime.gcBitsArenas+16(SB), CX	
  0x41cd1e		488701			XCHGQ AX, 0(CX)				
	unlock(&gcBitsArenas.lock)
  0x41cd21		488d05d8aa0800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41cd28		48890424		MOVQ AX, 0(SP)				
  0x41cd2c		e88fc9feff		CALL runtime.unlock(SB)			
}
  0x41cd31		488b6c2408		MOVQ 0x8(SP), BP	
  0x41cd36		4883c410		ADDQ $0x10, SP		
  0x41cd3a		c3			RET			
			gcBitsArenas.free = gcBitsArenas.previous
  0x41cd3b		488905c6aa0800		MOVQ AX, runtime.gcBitsArenas+8(SB)	
  0x41cd42		ebb5			JMP 0x41ccf9				
func nextMarkBitArenaEpoch() {
  0x41cd44		e827780200		CALL runtime.morestack_noctxt(SB)	
  0x41cd49		e942ffffff		JMP runtime.nextMarkBitArenaEpoch(SB)	

TEXT runtime.newArenaMayUnlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
func newArenaMayUnlock() *gcBitsArena {
  0x41cd50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41cd59		483b6110		CMPQ 0x10(CX), SP	
  0x41cd5d		0f86c9000000		JBE 0x41ce2c		
  0x41cd63		4883ec30		SUBQ $0x30, SP		
  0x41cd67		48896c2428		MOVQ BP, 0x28(SP)	
  0x41cd6c		488d6c2428		LEAQ 0x28(SP), BP	
	if gcBitsArenas.free == nil {
  0x41cd71		488b0590aa0800		MOVQ runtime.gcBitsArenas+8(SB), AX	
  0x41cd78		4885c0			TESTQ AX, AX				
  0x41cd7b		7445			JE 0x41cdc2				
  0x41cd7d		4889442420		MOVQ AX, 0x20(SP)			
		gcBitsArenas.free = gcBitsArenas.free.next
  0x41cd82		488b4808		MOVQ 0x8(AX), CX			
  0x41cd86		48890d7baa0800		MOVQ CX, runtime.gcBitsArenas+8(SB)	
		memclrNoHeapPointers(unsafe.Pointer(result), gcBitsChunkBytes)
  0x41cd8d		48890424		MOVQ AX, 0(SP)				
  0x41cd91		48c744240800000100	MOVQ $0x10000, 0x8(SP)			
  0x41cd9a		e8d1a00200		CALL runtime.memclrNoHeapPointers(SB)	
  0x41cd9f		488b442420		MOVQ 0x20(SP), AX			
	result.next = nil
  0x41cda4		48c7400800000000	MOVQ $0x0, 0x8(AX)	
		result.free = 0
  0x41cdac		48c70000000000		MOVQ $0x0, 0(AX)	
	return result
  0x41cdb3		4889442438		MOVQ AX, 0x38(SP)	
  0x41cdb8		488b6c2428		MOVQ 0x28(SP), BP	
  0x41cdbd		4883c430		ADDQ $0x30, SP		
  0x41cdc1		c3			RET			
		unlock(&gcBitsArenas.lock)
  0x41cdc2		488d0537aa0800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41cdc9		48890424		MOVQ AX, 0(SP)				
  0x41cdcd		e8eec8feff		CALL runtime.unlock(SB)			
		result = (*gcBitsArena)(sysAlloc(gcBitsChunkBytes, &memstats.gc_sys))
  0x41cdd2		48c7042400000100	MOVQ $0x10000, 0(SP)			
  0x41cdda		488d05b7790a00		LEAQ runtime.memstats+152(SB), AX	
  0x41cde1		4889442408		MOVQ AX, 0x8(SP)			
  0x41cde6		e83522ffff		CALL runtime.sysAlloc(SB)		
  0x41cdeb		488b442410		MOVQ 0x10(SP), AX			
		if result == nil {
  0x41cdf0		4885c0			TESTQ AX, AX		
  0x41cdf3		741c			JE 0x41ce11		
  0x41cdf5		4889442418		MOVQ AX, 0x18(SP)	
		lock(&gcBitsArenas.lock)
  0x41cdfa		488d05ffa90800		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41ce01		48890424		MOVQ AX, 0(SP)				
  0x41ce05		e816c7feff		CALL runtime.lock(SB)			
  0x41ce0a		488b442418		MOVQ 0x18(SP), AX			
  0x41ce0f		eb93			JMP 0x41cda4				
			throw("runtime: cannot allocate memory")
  0x41ce11		488d054df90400		LEAQ 0x4f94d(IP), AX	
  0x41ce18		48890424		MOVQ AX, 0(SP)		
  0x41ce1c		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x41ce25		e8a6430000		CALL runtime.throw(SB)	
  0x41ce2a		0f0b			UD2			
func newArenaMayUnlock() *gcBitsArena {
  0x41ce2c		e83f770200		CALL runtime.morestack_noctxt(SB)	
  0x41ce31		e91affffff		JMP runtime.newArenaMayUnlock(SB)	

TEXT runtime.newBucket(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func newBucket(typ bucketType, nstk int) *bucket {
  0x41ce40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ce49		483b6110		CMPQ 0x10(CX), SP	
  0x41ce4d		0f86b2000000		JBE 0x41cf05		
  0x41ce53		4883ec30		SUBQ $0x30, SP		
  0x41ce57		48896c2428		MOVQ BP, 0x28(SP)	
  0x41ce5c		488d6c2428		LEAQ 0x28(SP), BP	
  0x41ce61		488b442440		MOVQ 0x40(SP), AX	
	size := unsafe.Sizeof(bucket{}) + uintptr(nstk)*unsafe.Sizeof(uintptr(0))
  0x41ce66		48c1e003		SHLQ $0x3, AX		
  0x41ce6a		488b542438		MOVQ 0x38(SP), DX	
	case memProfile:
  0x41ce6f		4883fa01		CMPQ $0x1, DX		
  0x41ce73		7565			JNE 0x41ceda		
		size += unsafe.Sizeof(memRecord{})
  0x41ce75		4805b0000000		ADDQ $0xb0, AX		
	switch typ {
  0x41ce7b		4889442420		MOVQ AX, 0x20(SP)	
	b := (*bucket)(persistentalloc(size, 0, &memstats.buckhash_sys))
  0x41ce80		48890424		MOVQ AX, 0(SP)				
  0x41ce84		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x41ce8d		488d0dfc780a00		LEAQ runtime.memstats+144(SB), CX	
  0x41ce94		48894c2410		MOVQ CX, 0x10(SP)			
  0x41ce99		e802e6feff		CALL runtime.persistentalloc(SB)	
  0x41ce9e		488b442418		MOVQ 0x18(SP), AX			
	bucketmem += size
  0x41cea3		488b0d866a0a00		MOVQ runtime.bucketmem(SB), CX	
  0x41ceaa		488b542420		MOVQ 0x20(SP), DX		
  0x41ceaf		4801d1			ADDQ DX, CX			
  0x41ceb2		48890d776a0a00		MOVQ CX, runtime.bucketmem(SB)	
  0x41ceb9		488b4c2438		MOVQ 0x38(SP), CX		
	b.typ = typ
  0x41cebe		48894810		MOVQ CX, 0x10(AX)	
  0x41cec2		488b4c2440		MOVQ 0x40(SP), CX	
	b.nstk = uintptr(nstk)
  0x41cec7		48894828		MOVQ CX, 0x28(AX)	
	return b
  0x41cecb		4889442448		MOVQ AX, 0x48(SP)	
  0x41ced0		488b6c2428		MOVQ 0x28(SP), BP	
  0x41ced5		4883c430		ADDQ $0x30, SP		
  0x41ced9		c3			RET			
	case blockProfile, mutexProfile:
  0x41ceda		488d5afe		LEAQ -0x2(DX), BX	
  0x41cede		4883fb01		CMPQ $0x1, BX		
  0x41cee2		7706			JA 0x41ceea		
		size += unsafe.Sizeof(blockRecord{})
  0x41cee4		4883c040		ADDQ $0x40, AX		
	switch typ {
  0x41cee8		eb91			JMP 0x41ce7b		
		throw("invalid profile bucket type")
  0x41ceea		488d0590ee0400		LEAQ 0x4ee90(IP), AX	
  0x41cef1		48890424		MOVQ AX, 0(SP)		
  0x41cef5		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x41cefe		e8cd420000		CALL runtime.throw(SB)	
  0x41cf03		0f0b			UD2			
func newBucket(typ bucketType, nstk int) *bucket {
  0x41cf05		e866760200		CALL runtime.morestack_noctxt(SB)	
  0x41cf0a		e931ffffff		JMP runtime.newBucket(SB)		

TEXT runtime.(*bucket).mp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func (b *bucket) mp() *memRecord {
  0x41cf10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41cf19		483b6110		CMPQ 0x10(CX), SP	
  0x41cf1d		7650			JBE 0x41cf6f		
  0x41cf1f		4883ec18		SUBQ $0x18, SP		
  0x41cf23		48896c2410		MOVQ BP, 0x10(SP)	
  0x41cf28		488d6c2410		LEAQ 0x10(SP), BP	
  0x41cf2d		488b442420		MOVQ 0x20(SP), AX	
	if b.typ != memProfile {
  0x41cf32		488b4810		MOVQ 0x10(AX), CX	
  0x41cf36		4883f901		CMPQ $0x1, CX		
  0x41cf3a		7518			JNE 0x41cf54		
	data := add(unsafe.Pointer(b), unsafe.Sizeof(*b)+b.nstk*unsafe.Sizeof(uintptr(0)))
  0x41cf3c		488b4828		MOVQ 0x28(AX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x41cf40		488d44c830		LEAQ 0x30(AX)(CX*8), AX	
	return (*memRecord)(data)
  0x41cf45		4889442428		MOVQ AX, 0x28(SP)	
  0x41cf4a		488b6c2410		MOVQ 0x10(SP), BP	
  0x41cf4f		4883c418		ADDQ $0x18, SP		
  0x41cf53		c3			RET			
		throw("bad use of bucket.mp")
  0x41cf54		488d054ae10400		LEAQ 0x4e14a(IP), AX	
  0x41cf5b		48890424		MOVQ AX, 0(SP)		
  0x41cf5f		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41cf68		e863420000		CALL runtime.throw(SB)	
  0x41cf6d		0f0b			UD2			
func (b *bucket) mp() *memRecord {
  0x41cf6f		e8fc750200		CALL runtime.morestack_noctxt(SB)	
  0x41cf74		eb9a			JMP runtime.(*bucket).mp(SB)		

TEXT runtime.(*bucket).bp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func (b *bucket) bp() *blockRecord {
  0x41cf80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41cf89		483b6110		CMPQ 0x10(CX), SP	
  0x41cf8d		7656			JBE 0x41cfe5		
  0x41cf8f		4883ec18		SUBQ $0x18, SP		
  0x41cf93		48896c2410		MOVQ BP, 0x10(SP)	
  0x41cf98		488d6c2410		LEAQ 0x10(SP), BP	
  0x41cf9d		488b442420		MOVQ 0x20(SP), AX	
	if b.typ != blockProfile && b.typ != mutexProfile {
  0x41cfa2		488b4810		MOVQ 0x10(AX), CX	
  0x41cfa6		4883f902		CMPQ $0x2, CX		
  0x41cfaa		7406			JE 0x41cfb2		
  0x41cfac		4883f903		CMPQ $0x3, CX		
  0x41cfb0		7518			JNE 0x41cfca		
	data := add(unsafe.Pointer(b), unsafe.Sizeof(*b)+b.nstk*unsafe.Sizeof(uintptr(0)))
  0x41cfb2		488b4828		MOVQ 0x28(AX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x41cfb6		488d44c830		LEAQ 0x30(AX)(CX*8), AX	
	return (*blockRecord)(data)
  0x41cfbb		4889442428		MOVQ AX, 0x28(SP)	
  0x41cfc0		488b6c2410		MOVQ 0x10(SP), BP	
  0x41cfc5		4883c418		ADDQ $0x18, SP		
  0x41cfc9		c3			RET			
		throw("bad use of bucket.bp")
  0x41cfca		488d05c0e00400		LEAQ 0x4e0c0(IP), AX	
  0x41cfd1		48890424		MOVQ AX, 0(SP)		
  0x41cfd5		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41cfde		e8ed410000		CALL runtime.throw(SB)	
  0x41cfe3		0f0b			UD2			
func (b *bucket) bp() *blockRecord {
  0x41cfe5		e886750200		CALL runtime.morestack_noctxt(SB)	
  0x41cfea		eb94			JMP runtime.(*bucket).bp(SB)		

TEXT runtime.stkbucket(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket {
  0x41cff0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41cff9		483b6110		CMPQ 0x10(CX), SP	
  0x41cffd		0f861b030000		JBE 0x41d31e		
  0x41d003		4883ec58		SUBQ $0x58, SP		
  0x41d007		48896c2450		MOVQ BP, 0x50(SP)	
  0x41d00c		488d6c2450		LEAQ 0x50(SP), BP	
	if buckhash == nil {
  0x41d011		488b0d18a60800		MOVQ runtime.buckhash(SB), CX	
  0x41d018		4885c9			TESTQ CX, CX			
  0x41d01b		0f847b020000		JE 0x41d29c			
  0x41d021		488b4c2470		MOVQ 0x70(SP), CX		
  0x41d026		488b542478		MOVQ 0x78(SP), DX		
  0x41d02b		31c0			XORL AX, AX			
  0x41d02d		31db			XORL BX, BX			
	for _, pc := range stk {
  0x41d02f		eb1f			JMP 0x41d050		
  0x41d031		488b34c1		MOVQ 0(CX)(AX*8), SI	
  0x41d035		48ffc0			INCQ AX			
		h += pc
  0x41d038		4801de			ADDQ BX, SI		
  0x41d03b		4889f7			MOVQ SI, DI		
		h += h << 10
  0x41d03e		48c1e60a		SHLQ $0xa, SI		
  0x41d042		488d1c37		LEAQ 0(DI)(SI*1), BX	
  0x41d046		4889de			MOVQ BX, SI		
		h ^= h >> 6
  0x41d049		48c1eb06		SHRQ $0x6, BX		
  0x41d04d		4831f3			XORQ SI, BX		
	for _, pc := range stk {
  0x41d050		4839d0			CMPQ DX, AX		
  0x41d053		7cdc			JL 0x41d031		
	for b := buckhash[i]; b != nil; b = b.next {
  0x41d055		488b35d4a50800		MOVQ runtime.buckhash(SB), SI	
  0x41d05c		8406			TESTB AL, 0(SI)			
  0x41d05e		488b7c2468		MOVQ 0x68(SP), DI		
	h += size
  0x41d063		4801fb			ADDQ DI, BX		
  0x41d066		4989d8			MOVQ BX, R8		
	h += h << 10
  0x41d069		48c1e30a		SHLQ $0xa, BX		
  0x41d06d		4c01c3			ADDQ R8, BX		
  0x41d070		4989d8			MOVQ BX, R8		
	h ^= h >> 6
  0x41d073		48c1eb06		SHRQ $0x6, BX		
  0x41d077		4931d8			XORQ BX, R8		
	h += h << 3
  0x41d07a		4b8d1cc0		LEAQ 0(R8)(R8*8), BX	
  0x41d07e		4989d8			MOVQ BX, R8		
	h ^= h >> 11
  0x41d081		48c1eb0b		SHRQ $0xb, BX		
  0x41d085		4931d8			XORQ BX, R8		
	i := int(h % buckHashSize)
  0x41d088		48b8921a1953bc1f6aba	MOVQ $0xba6a1fbc53191a92, AX	
  0x41d092		4889d3			MOVQ DX, BX			
  0x41d095		49f7e0			MULQ R8				
  0x41d098		48c1ea11		SHRQ $0x11, DX			
  0x41d09c		4869d21fbf0200		IMULQ $0x2bf1f, DX, DX		
  0x41d0a3		4d89c1			MOVQ R8, R9			
  0x41d0a6		4929d0			SUBQ DX, R8			
	for b := buckhash[i]; b != nil; b = b.next {
  0x41d0a9		4981f81fbf0200		CMPQ $0x2bf1f, R8	
  0x41d0b0		0f8346020000		JAE 0x41d2fc		
  0x41d0b6		4c894c2440		MOVQ R9, 0x40(SP)	
  0x41d0bb		4c89442438		MOVQ R8, 0x38(SP)	
  0x41d0c0		4a8b04c6		MOVQ 0(SI)(R8*8), AX	
  0x41d0c4		eb03			JMP 0x41d0c9		
  0x41d0c6		488b00			MOVQ 0(AX), AX		
  0x41d0c9		4885c0			TESTQ AX, AX		
  0x41d0cc		0f84ab000000		JE 0x41d17d		
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41d0d2		488b5010		MOVQ 0x10(AX), DX	
  0x41d0d6		488b742460		MOVQ 0x60(SP), SI	
  0x41d0db		4839f2			CMPQ SI, DX		
  0x41d0de		75e6			JNE 0x41d0c6		
  0x41d0e0		488b5018		MOVQ 0x18(AX), DX	
  0x41d0e4		4939d1			CMPQ DX, R9		
  0x41d0e7		75dd			JNE 0x41d0c6		
  0x41d0e9		488b5020		MOVQ 0x20(AX), DX	
  0x41d0ed		4839d7			CMPQ DX, DI		
  0x41d0f0		75d4			JNE 0x41d0c6		
	return unsafe.Pointer(uintptr(p) + x)
  0x41d0f2		488d5030		LEAQ 0x30(AX), DX	
	return stk[:b.nstk:b.nstk]
  0x41d0f6		8402			TESTB AL, 0(DX)		
  0x41d0f8		4c8b5028		MOVQ 0x28(AX), R10	
  0x41d0fc		4983fa20		CMPQ $0x20, R10		
  0x41d100		0f87ef010000		JA 0x41d2f5		
  0x41d106		4889442448		MOVQ AX, 0x48(SP)	
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41d10b		48891424		MOVQ DX, 0(SP)			
  0x41d10f		4c89542408		MOVQ R10, 0x8(SP)		
  0x41d114		4c89542410		MOVQ R10, 0x10(SP)		
  0x41d119		48894c2418		MOVQ CX, 0x18(SP)		
  0x41d11e		48895c2420		MOVQ BX, 0x20(SP)		
  0x41d123		488b842480000000	MOVQ 0x80(SP), AX		
  0x41d12b		4889442428		MOVQ AX, 0x28(SP)		
  0x41d130		e8fb010000		CALL runtime.eqslice(SB)	
  0x41d135		0fb6442430		MOVZX 0x30(SP), AX		
  0x41d13a		84c0			TESTL AL, AL			
  0x41d13c		7528			JNE 0x41d166			
  0x41d13e		488b442448		MOVQ 0x48(SP), AX		
  0x41d143		488b4c2470		MOVQ 0x70(SP), CX		
  0x41d148		488b5c2478		MOVQ 0x78(SP), BX		
  0x41d14d		488b742460		MOVQ 0x60(SP), SI		
  0x41d152		488b7c2468		MOVQ 0x68(SP), DI		
  0x41d157		4c8b442438		MOVQ 0x38(SP), R8		
  0x41d15c		4c8b4c2440		MOVQ 0x40(SP), R9		
  0x41d161		e960ffffff		JMP 0x41d0c6			
			return b
  0x41d166		488b442448		MOVQ 0x48(SP), AX	
  0x41d16b		4889842490000000	MOVQ AX, 0x90(SP)	
  0x41d173		488b6c2450		MOVQ 0x50(SP), BP	
  0x41d178		4883c458		ADDQ $0x58, SP		
  0x41d17c		c3			RET			
  0x41d17d		0fb6842488000000	MOVZX 0x88(SP), AX	
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket {
  0x41d185		84c0			TESTL AL, AL		
	if !alloc {
  0x41d187		0f84f9000000		JE 0x41d286		
  0x41d18d		488b442460		MOVQ 0x60(SP), AX	
	b := newBucket(typ, len(stk))
  0x41d192		48890424		MOVQ AX, 0(SP)			
  0x41d196		48895c2408		MOVQ BX, 0x8(SP)		
  0x41d19b		e8a0fcffff		CALL runtime.newBucket(SB)	
  0x41d1a0		488b442410		MOVQ 0x10(SP), AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x41d1a5		488d4830		LEAQ 0x30(AX), CX	
	return stk[:b.nstk:b.nstk]
  0x41d1a9		8401			TESTB AL, 0(CX)		
  0x41d1ab		488b5028		MOVQ 0x28(AX), DX	
  0x41d1af		4883fa20		CMPQ $0x20, DX		
  0x41d1b3		0f8735010000		JA 0x41d2ee		
  0x41d1b9		4889442448		MOVQ AX, 0x48(SP)	
  0x41d1be		488b5c2478		MOVQ 0x78(SP), BX	
	copy(b.stk(), stk)
  0x41d1c3		4839da			CMPQ BX, DX			
  0x41d1c6		0f8eb2000000		JLE 0x41d27e			
  0x41d1cc		48890c24		MOVQ CX, 0(SP)			
  0x41d1d0		488b442470		MOVQ 0x70(SP), AX		
  0x41d1d5		4889442408		MOVQ AX, 0x8(SP)		
  0x41d1da		48c1e303		SHLQ $0x3, BX			
  0x41d1de		48895c2410		MOVQ BX, 0x10(SP)		
  0x41d1e3		e8189f0200		CALL runtime.memmove(SB)	
  0x41d1e8		488b442440		MOVQ 0x40(SP), AX		
  0x41d1ed		488b4c2448		MOVQ 0x48(SP), CX		
	b.hash = h
  0x41d1f2		48894118		MOVQ AX, 0x18(CX)	
  0x41d1f6		488b442468		MOVQ 0x68(SP), AX	
	b.size = size
  0x41d1fb		48894120		MOVQ AX, 0x20(CX)	
	b.next = buckhash[i]
  0x41d1ff		488b052aa40800		MOVQ runtime.buckhash(SB), AX	
  0x41d206		8400			TESTB AL, 0(AX)			
  0x41d208		488b542438		MOVQ 0x38(SP), DX		
  0x41d20d		488b04d0		MOVQ 0(AX)(DX*8), AX		
  0x41d211		488901			MOVQ AX, 0(CX)			
	buckhash[i] = b
  0x41d214		488b0515a40800		MOVQ runtime.buckhash(SB), AX	
  0x41d21b		8400			TESTB AL, 0(AX)			
  0x41d21d		48890cd0		MOVQ CX, 0(AX)(DX*8)		
  0x41d221		488b442460		MOVQ 0x60(SP), AX		
	if typ == memProfile {
  0x41d226		4883f801		CMPQ $0x1, AX		
  0x41d22a		7524			JNE 0x41d250		
		b.allnext = mbuckets
  0x41d22c		488b053da40800		MOVQ runtime.mbuckets(SB), AX	
  0x41d233		48894108		MOVQ AX, 0x8(CX)		
		mbuckets = b
  0x41d237		48890d32a40800		MOVQ CX, runtime.mbuckets(SB)	
	return b
  0x41d23e		48898c2490000000	MOVQ CX, 0x90(SP)	
  0x41d246		488b6c2450		MOVQ 0x50(SP), BP	
  0x41d24b		4883c458		ADDQ $0x58, SP		
  0x41d24f		c3			RET			
	} else if typ == mutexProfile {
  0x41d250		4883f803		CMPQ $0x3, AX		
  0x41d254		7514			JNE 0x41d26a		
		b.allnext = xbuckets
  0x41d256		488b052ba40800		MOVQ runtime.xbuckets(SB), AX	
  0x41d25d		48894108		MOVQ AX, 0x8(CX)		
		xbuckets = b
  0x41d261		48890d20a40800		MOVQ CX, runtime.xbuckets(SB)	
  0x41d268		ebd4			JMP 0x41d23e			
		b.allnext = bbuckets
  0x41d26a		488b05b7a30800		MOVQ runtime.bbuckets(SB), AX	
  0x41d271		48894108		MOVQ AX, 0x8(CX)		
		bbuckets = b
  0x41d275		48890daca30800		MOVQ CX, runtime.bbuckets(SB)	
  0x41d27c		ebc0			JMP 0x41d23e			
  0x41d27e		4889d3			MOVQ DX, BX			
	copy(b.stk(), stk)
  0x41d281		e946ffffff		JMP 0x41d1cc		
		return nil
  0x41d286		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x41d292		488b6c2450			MOVQ 0x50(SP), BP	
  0x41d297		4883c458			ADDQ $0x58, SP		
  0x41d29b		c3				RET			
		buckhash = (*[buckHashSize]*bucket)(sysAlloc(unsafe.Sizeof(*buckhash), &memstats.buckhash_sys))
  0x41d29c		48c70424f8f81500	MOVQ $0x15f8f8, 0(SP)			
  0x41d2a4		488d05e5740a00		LEAQ runtime.memstats+144(SB), AX	
  0x41d2ab		4889442408		MOVQ AX, 0x8(SP)			
  0x41d2b0		e86b1dffff		CALL runtime.sysAlloc(SB)		
  0x41d2b5		8b0555670a00		MOVL runtime.writeBarrier(SB), AX	
  0x41d2bb		488b4c2410		MOVQ 0x10(SP), CX			
  0x41d2c0		85c0			TESTL AX, AX				
  0x41d2c2		7519			JNE 0x41d2dd				
  0x41d2c4		48890d65a30800		MOVQ CX, runtime.buckhash(SB)		
		if buckhash == nil {
  0x41d2cb		488b0d5ea30800		MOVQ runtime.buckhash(SB), CX	
  0x41d2d2		4885c9			TESTQ CX, CX			
  0x41d2d5		0f8546fdffff		JNE 0x41d021			
  0x41d2db		eb26			JMP 0x41d303			
		buckhash = (*[buckHashSize]*bucket)(sysAlloc(unsafe.Sizeof(*buckhash), &memstats.buckhash_sys))
  0x41d2dd		488d3d4ca30800		LEAQ runtime.buckhash(SB), DI	
  0x41d2e4		4889c8			MOVQ CX, AX			
  0x41d2e7		e8b4950200		CALL runtime.gcWriteBarrier(SB)	
  0x41d2ec		ebdd			JMP 0x41d2cb			
	return stk[:b.nstk:b.nstk]
  0x41d2ee		e8bd270000		CALL runtime.panicslice(SB)	
  0x41d2f3		0f0b			UD2				
  0x41d2f5		e8b6270000		CALL runtime.panicslice(SB)	
  0x41d2fa		0f0b			UD2				
	for b := buckhash[i]; b != nil; b = b.next {
  0x41d2fc		e83f270000		CALL runtime.panicindex(SB)	
  0x41d301		0f0b			UD2				
			throw("runtime: cannot allocate memory")
  0x41d303		488d055bf40400		LEAQ 0x4f45b(IP), AX	
  0x41d30a		48890424		MOVQ AX, 0(SP)		
  0x41d30e		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x41d317		e8b43e0000		CALL runtime.throw(SB)	
  0x41d31c		0f0b			UD2			
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket {
  0x41d31e		e84d720200		CALL runtime.morestack_noctxt(SB)	
  0x41d323		e9c8fcffff		JMP runtime.stkbucket(SB)		

TEXT runtime.eqslice(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func eqslice(x, y []uintptr) bool {
  0x41d330		4883ec08		SUBQ $0x8, SP		
  0x41d334		48892c24		MOVQ BP, 0(SP)		
  0x41d338		488d2c24		LEAQ 0(SP), BP		
  0x41d33c		488b442418		MOVQ 0x18(SP), AX	
  0x41d341		488b4c2430		MOVQ 0x30(SP), CX	
	if len(x) != len(y) {
  0x41d346		4839c8			CMPQ CX, AX		
  0x41d349		7544			JNE 0x41d38f		
  0x41d34b		488b542428		MOVQ 0x28(SP), DX	
  0x41d350		488b5c2410		MOVQ 0x10(SP), BX	
  0x41d355		31f6			XORL SI, SI		
	for i, xi := range x {
  0x41d357		eb03			JMP 0x41d35c		
  0x41d359		48ffc6			INCQ SI			
  0x41d35c		4839c6			CMPQ AX, SI		
  0x41d35f		7d20			JGE 0x41d381		
  0x41d361		488b3cf3		MOVQ 0(BX)(SI*8), DI	
		if xi != y[i] {
  0x41d365		4839ce			CMPQ CX, SI		
  0x41d368		7333			JAE 0x41d39d		
  0x41d36a		4c8b04f2		MOVQ 0(DX)(SI*8), R8	
  0x41d36e		4c39c7			CMPQ R8, DI		
  0x41d371		74e6			JE 0x41d359		
			return false
  0x41d373		c644244000		MOVB $0x0, 0x40(SP)	
  0x41d378		488b2c24		MOVQ 0(SP), BP		
  0x41d37c		4883c408		ADDQ $0x8, SP		
  0x41d380		c3			RET			
	return true
  0x41d381		c644244001		MOVB $0x1, 0x40(SP)	
  0x41d386		488b2c24		MOVQ 0(SP), BP		
  0x41d38a		4883c408		ADDQ $0x8, SP		
  0x41d38e		c3			RET			
		return false
  0x41d38f		c644244000		MOVB $0x0, 0x40(SP)	
  0x41d394		488b2c24		MOVQ 0(SP), BP		
  0x41d398		4883c408		ADDQ $0x8, SP		
  0x41d39c		c3			RET			
		if xi != y[i] {
  0x41d39d		e89e260000		CALL runtime.panicindex(SB)	
  0x41d3a2		0f0b			UD2				

TEXT runtime.mProf_NextCycle(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func mProf_NextCycle() {
  0x41d3b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d3b9		483b6110		CMPQ 0x10(CX), SP	
  0x41d3bd		7662			JBE 0x41d421		
  0x41d3bf		4883ec10		SUBQ $0x10, SP		
  0x41d3c3		48896c2408		MOVQ BP, 0x8(SP)	
  0x41d3c8		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&proflock)
  0x41d3cd		488d05e4650a00		LEAQ runtime.proflock(SB), AX	
  0x41d3d4		48890424		MOVQ AX, 0(SP)			
  0x41d3d8		e843c1feff		CALL runtime.lock(SB)		
	mProf.cycle = (mProf.cycle + 1) % mProfCycleWrap
  0x41d3dd		8b05a5650a00		MOVL runtime.mProf(SB), AX	
  0x41d3e3		ffc0			INCL AX				
  0x41d3e5		b9abaaaaaa		MOVL $-0x55555555, CX		
  0x41d3ea		480fafc8		IMULQ AX, CX			
  0x41d3ee		48c1e93a		SHRQ $0x3a, CX			
  0x41d3f2		69c900000006		IMULL $0x6000000, CX, CX	
  0x41d3f8		29c8			SUBL CX, AX			
  0x41d3fa		890588650a00		MOVL AX, runtime.mProf(SB)	
	mProf.flushed = false
  0x41d400		c60585650a0000		MOVB $0x0, runtime.mProf+4(SB)	
	unlock(&proflock)
  0x41d407		488d05aa650a00		LEAQ runtime.proflock(SB), AX	
  0x41d40e		48890424		MOVQ AX, 0(SP)			
  0x41d412		e8a9c2feff		CALL runtime.unlock(SB)		
}
  0x41d417		488b6c2408		MOVQ 0x8(SP), BP	
  0x41d41c		4883c410		ADDQ $0x10, SP		
  0x41d420		c3			RET			
func mProf_NextCycle() {
  0x41d421		e84a710200		CALL runtime.morestack_noctxt(SB)	
  0x41d426		eb88			JMP runtime.mProf_NextCycle(SB)		

TEXT runtime.mProf_Flush(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func mProf_Flush() {
  0x41d430		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d439		483b6110		CMPQ 0x10(CX), SP	
  0x41d43d		7651			JBE 0x41d490		
  0x41d43f		4883ec10		SUBQ $0x10, SP		
  0x41d443		48896c2408		MOVQ BP, 0x8(SP)	
  0x41d448		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&proflock)
  0x41d44d		488d0564650a00		LEAQ runtime.proflock(SB), AX	
  0x41d454		48890424		MOVQ AX, 0(SP)			
  0x41d458		e8c3c0feff		CALL runtime.lock(SB)		
	if !mProf.flushed {
  0x41d45d		0fb60528650a00		MOVZX runtime.mProf+4(SB), AX	
  0x41d464		84c0			TESTL AL, AL			
  0x41d466		741a			JE 0x41d482			
	unlock(&proflock)
  0x41d468		488d0549650a00		LEAQ runtime.proflock(SB), AX	
  0x41d46f		48890424		MOVQ AX, 0(SP)			
  0x41d473		e848c2feff		CALL runtime.unlock(SB)		
}
  0x41d478		488b6c2408		MOVQ 0x8(SP), BP	
  0x41d47d		4883c410		ADDQ $0x10, SP		
  0x41d481		c3			RET			
		mProf_FlushLocked()
  0x41d482		e819000000		CALL runtime.mProf_FlushLocked(SB)	
		mProf.flushed = true
  0x41d487		c605fe640a0001		MOVB $0x1, runtime.mProf+4(SB)	
  0x41d48e		ebd8			JMP 0x41d468			
func mProf_Flush() {
  0x41d490		e8db700200		CALL runtime.morestack_noctxt(SB)	
  0x41d495		eb99			JMP runtime.mProf_Flush(SB)		

TEXT runtime.mProf_FlushLocked(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func mProf_FlushLocked() {
  0x41d4a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d4a9		483b6110		CMPQ 0x10(CX), SP	
  0x41d4ad		0f86c7000000		JBE 0x41d57a		
  0x41d4b3		4883ec28		SUBQ $0x28, SP		
  0x41d4b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x41d4bc		488d6c2420		LEAQ 0x20(SP), BP	
	c := mProf.cycle
  0x41d4c1		8b05c1640a00		MOVL runtime.mProf(SB), AX	
  0x41d4c7		89442414		MOVL AX, 0x14(SP)		
	for b := mbuckets; b != nil; b = b.allnext {
  0x41d4cb		488b0d9ea10800		MOVQ runtime.mbuckets(SB), CX	
  0x41d4d2		e990000000		JMP 0x41d567			
  0x41d4d7		48894c2418		MOVQ CX, 0x18(SP)		
		mp := b.mp()
  0x41d4dc		48890c24		MOVQ CX, 0(SP)			
  0x41d4e0		e82bfaffff		CALL runtime.(*bucket).mp(SB)	
  0x41d4e5		488b442408		MOVQ 0x8(SP), AX		
		mpc := &mp.future[c%uint32(len(mp.future))]
  0x41d4ea		b9abaaaaaa		MOVL $-0x55555555, CX	
  0x41d4ef		8b542414		MOVL 0x14(SP), DX	
  0x41d4f3		480fafca		IMULQ DX, CX		
  0x41d4f7		48c1e921		SHRQ $0x21, CX		
  0x41d4fb		6bc903			IMULL $0x3, CX, CX	
  0x41d4fe		89d3			MOVL DX, BX		
  0x41d500		29ca			SUBL CX, DX		
  0x41d502		48c1e205		SHLQ $0x5, DX		
	a.allocs += b.allocs
  0x41d506		488b4c1020		MOVQ 0x20(AX)(DX*1), CX	
  0x41d50b		480308			ADDQ 0(AX), CX		
  0x41d50e		488908			MOVQ CX, 0(AX)		
	a.frees += b.frees
  0x41d511		488b4c1028		MOVQ 0x28(AX)(DX*1), CX	
  0x41d516		48034808		ADDQ 0x8(AX), CX	
  0x41d51a		48894808		MOVQ CX, 0x8(AX)	
	a.alloc_bytes += b.alloc_bytes
  0x41d51e		488b4c1030		MOVQ 0x30(AX)(DX*1), CX	
  0x41d523		48034810		ADDQ 0x10(AX), CX	
  0x41d527		48894810		MOVQ CX, 0x10(AX)	
	a.free_bytes += b.free_bytes
  0x41d52b		488b4c1038		MOVQ 0x38(AX)(DX*1), CX	
  0x41d530		48034818		ADDQ 0x18(AX), CX	
  0x41d534		48894818		MOVQ CX, 0x18(AX)	
		*mpc = memRecordCycle{}
  0x41d538		48c744102000000000	MOVQ $0x0, 0x20(AX)(DX*1)	
  0x41d541		48c744102800000000	MOVQ $0x0, 0x28(AX)(DX*1)	
  0x41d54a		48c744103000000000	MOVQ $0x0, 0x30(AX)(DX*1)	
  0x41d553		48c744103800000000	MOVQ $0x0, 0x38(AX)(DX*1)	
  0x41d55c		488b442418		MOVQ 0x18(SP), AX		
	for b := mbuckets; b != nil; b = b.allnext {
  0x41d561		488b4808		MOVQ 0x8(AX), CX	
  0x41d565		89d8			MOVL BX, AX		
  0x41d567		4885c9			TESTQ CX, CX		
  0x41d56a		0f8567ffffff		JNE 0x41d4d7		
  0x41d570		488b6c2420		MOVQ 0x20(SP), BP	
  0x41d575		4883c428		ADDQ $0x28, SP		
  0x41d579		c3			RET			
func mProf_FlushLocked() {
  0x41d57a		e8f16f0200		CALL runtime.morestack_noctxt(SB)	
  0x41d57f		e91cffffff		JMP runtime.mProf_FlushLocked(SB)	

TEXT runtime.mProf_Malloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func mProf_Malloc(p unsafe.Pointer, size uintptr) {
  0x41d590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d599		488d842410ffffff	LEAQ 0xffffff10(SP), AX	
  0x41d5a1		483b4110		CMPQ 0x10(CX), AX	
  0x41d5a5		0f8688010000		JBE 0x41d733		
  0x41d5ab		4881ec70010000		SUBQ $0x170, SP		
  0x41d5b2		4889ac2468010000	MOVQ BP, 0x168(SP)	
  0x41d5ba		488dac2468010000	LEAQ 0x168(SP), BP	
	var stk [maxStack]uintptr
  0x41d5c2		488d7c2448		LEAQ 0x48(SP), DI	
  0x41d5c7		0f57c0			XORPS X0, X0		
  0x41d5ca		48896c24f0		MOVQ BP, -0x10(SP)	
  0x41d5cf		488d6c24f0		LEAQ -0x10(SP), BP	
  0x41d5d4		e8ab940200		CALL 0x446a84		
  0x41d5d9		488b6d00		MOVQ 0(BP), BP		
	nstk := callers(4, stk[:])
  0x41d5dd		48c7042404000000	MOVQ $0x4, 0(SP)		
  0x41d5e5		488d442448		LEAQ 0x48(SP), AX		
  0x41d5ea		4889442408		MOVQ AX, 0x8(SP)		
  0x41d5ef		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x41d5f8		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x41d601		e8fa020200		CALL runtime.callers(SB)	
  0x41d606		488b442420		MOVQ 0x20(SP), AX		
  0x41d60b		4889442440		MOVQ AX, 0x40(SP)		
	lock(&proflock)
  0x41d610		488d0da1630a00		LEAQ runtime.proflock(SB), CX	
  0x41d617		48890c24		MOVQ CX, 0(SP)			
  0x41d61b		e800bffeff		CALL runtime.lock(SB)		
func mProf_Malloc(p unsafe.Pointer, size uintptr) {
  0x41d620		488b442440		MOVQ 0x40(SP), AX	
	b := stkbucket(memProfile, size, stk[:nstk], true)
  0x41d625		4883f820		CMPQ $0x20, AX			
  0x41d629		0f87fd000000		JA 0x41d72c			
  0x41d62f		48c7042401000000	MOVQ $0x1, 0(SP)		
  0x41d637		488b8c2480010000	MOVQ 0x180(SP), CX		
  0x41d63f		48894c2408		MOVQ CX, 0x8(SP)		
  0x41d644		488d542448		LEAQ 0x48(SP), DX		
  0x41d649		4889542410		MOVQ DX, 0x10(SP)		
  0x41d64e		4889442418		MOVQ AX, 0x18(SP)		
  0x41d653		48c744242020000000	MOVQ $0x20, 0x20(SP)		
  0x41d65c		c644242801		MOVB $0x1, 0x28(SP)		
  0x41d661		e88af9ffff		CALL runtime.stkbucket(SB)	
  0x41d666		488b442430		MOVQ 0x30(SP), AX		
  0x41d66b		4889842448010000	MOVQ AX, 0x148(SP)		
	c := mProf.cycle
  0x41d673		8b0d0f630a00		MOVL runtime.mProf(SB), CX	
  0x41d679		894c243c		MOVL CX, 0x3c(SP)		
	mp := b.mp()
  0x41d67d		48890424		MOVQ AX, 0(SP)			
  0x41d681		e88af8ffff		CALL runtime.(*bucket).mp(SB)	
  0x41d686		488b442408		MOVQ 0x8(SP), AX		
	mpc := &mp.future[(c+2)%uint32(len(mp.future))]
  0x41d68b		8400			TESTB AL, 0(AX)		
  0x41d68d		8b4c243c		MOVL 0x3c(SP), CX	
  0x41d691		83c102			ADDL $0x2, CX		
  0x41d694		baabaaaaaa		MOVL $-0x55555555, DX	
  0x41d699		480fafd1		IMULQ CX, DX		
  0x41d69d		48c1ea21		SHRQ $0x21, DX		
  0x41d6a1		6bd203			IMULL $0x3, DX, DX	
  0x41d6a4		29d1			SUBL DX, CX		
  0x41d6a6		48c1e105		SHLQ $0x5, CX		
	mpc.allocs++
  0x41d6aa		488b540820		MOVQ 0x20(AX)(CX*1), DX	
  0x41d6af		48ffc2			INCQ DX			
  0x41d6b2		4889540820		MOVQ DX, 0x20(AX)(CX*1)	
	mpc.alloc_bytes += size
  0x41d6b7		488b540830		MOVQ 0x30(AX)(CX*1), DX	
  0x41d6bc		488b9c2480010000	MOVQ 0x180(SP), BX	
  0x41d6c4		4801da			ADDQ BX, DX		
  0x41d6c7		4889540830		MOVQ DX, 0x30(AX)(CX*1)	
	unlock(&proflock)
  0x41d6cc		488d05e5620a00		LEAQ runtime.proflock(SB), AX	
  0x41d6d3		48890424		MOVQ AX, 0(SP)			
  0x41d6d7		e8e4bffeff		CALL runtime.unlock(SB)		
	systemstack(func() {
  0x41d6dc		488d051d530200		LEAQ runtime.mProf_Malloc.func1(SB), AX	
  0x41d6e3		4889842450010000	MOVQ AX, 0x150(SP)			
  0x41d6eb		488b842478010000	MOVQ 0x178(SP), AX			
  0x41d6f3		4889842458010000	MOVQ AX, 0x158(SP)			
  0x41d6fb		488b842448010000	MOVQ 0x148(SP), AX			
  0x41d703		4889842460010000	MOVQ AX, 0x160(SP)			
  0x41d70b		488d842450010000	LEAQ 0x150(SP), AX			
  0x41d713		48890424		MOVQ AX, 0(SP)				
  0x41d717		e8046d0200		CALL runtime.systemstack(SB)		
}
  0x41d71c		488bac2468010000	MOVQ 0x168(SP), BP	
  0x41d724		4881c470010000		ADDQ $0x170, SP		
  0x41d72b		c3			RET			
	b := stkbucket(memProfile, size, stk[:nstk], true)
  0x41d72c		e87f230000		CALL runtime.panicslice(SB)	
  0x41d731		0f0b			UD2				
func mProf_Malloc(p unsafe.Pointer, size uintptr) {
  0x41d733		e8386e0200		CALL runtime.morestack_noctxt(SB)	
  0x41d738		e953feffff		JMP runtime.mProf_Malloc(SB)		

TEXT runtime.mProf_Free(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func mProf_Free(b *bucket, size uintptr) {
  0x41d740		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d749		483b6110		CMPQ 0x10(CX), SP	
  0x41d74d		0f8692000000		JBE 0x41d7e5		
  0x41d753		4883ec20		SUBQ $0x20, SP		
  0x41d757		48896c2418		MOVQ BP, 0x18(SP)	
  0x41d75c		488d6c2418		LEAQ 0x18(SP), BP	
	lock(&proflock)
  0x41d761		488d0550620a00		LEAQ runtime.proflock(SB), AX	
  0x41d768		48890424		MOVQ AX, 0(SP)			
  0x41d76c		e8afbdfeff		CALL runtime.lock(SB)		
	c := mProf.cycle
  0x41d771		8b0511620a00		MOVL runtime.mProf(SB), AX	
  0x41d777		89442414		MOVL AX, 0x14(SP)		
  0x41d77b		488b4c2428		MOVQ 0x28(SP), CX		
	mp := b.mp()
  0x41d780		48890c24		MOVQ CX, 0(SP)			
  0x41d784		e887f7ffff		CALL runtime.(*bucket).mp(SB)	
  0x41d789		488b442408		MOVQ 0x8(SP), AX		
	mpc := &mp.future[(c+1)%uint32(len(mp.future))]
  0x41d78e		8400			TESTB AL, 0(AX)		
  0x41d790		8b4c2414		MOVL 0x14(SP), CX	
  0x41d794		ffc1			INCL CX			
  0x41d796		baabaaaaaa		MOVL $-0x55555555, DX	
  0x41d79b		480fafd1		IMULQ CX, DX		
  0x41d79f		48c1ea21		SHRQ $0x21, DX		
  0x41d7a3		6bd203			IMULL $0x3, DX, DX	
  0x41d7a6		29d1			SUBL DX, CX		
  0x41d7a8		48c1e105		SHLQ $0x5, CX		
	mpc.frees++
  0x41d7ac		488b540828		MOVQ 0x28(AX)(CX*1), DX	
  0x41d7b1		48ffc2			INCQ DX			
  0x41d7b4		4889540828		MOVQ DX, 0x28(AX)(CX*1)	
	mpc.free_bytes += size
  0x41d7b9		488b540838		MOVQ 0x38(AX)(CX*1), DX	
  0x41d7be		488b5c2430		MOVQ 0x30(SP), BX	
  0x41d7c3		4801da			ADDQ BX, DX		
  0x41d7c6		4889540838		MOVQ DX, 0x38(AX)(CX*1)	
	unlock(&proflock)
  0x41d7cb		488d05e6610a00		LEAQ runtime.proflock(SB), AX	
  0x41d7d2		48890424		MOVQ AX, 0(SP)			
  0x41d7d6		e8e5befeff		CALL runtime.unlock(SB)		
}
  0x41d7db		488b6c2418		MOVQ 0x18(SP), BP	
  0x41d7e0		4883c420		ADDQ $0x20, SP		
  0x41d7e4		c3			RET			
func mProf_Free(b *bucket, size uintptr) {
  0x41d7e5		e8866d0200		CALL runtime.morestack_noctxt(SB)	
  0x41d7ea		e951ffffff		JMP runtime.mProf_Free(SB)		

TEXT runtime.blockevent(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func blockevent(cycles int64, skip int) {
  0x41d7f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d7f9		483b6110		CMPQ 0x10(CX), SP	
  0x41d7fd		7664			JBE 0x41d863		
  0x41d7ff		4883ec20		SUBQ $0x20, SP		
  0x41d803		48896c2418		MOVQ BP, 0x18(SP)	
  0x41d808		488d6c2418		LEAQ 0x18(SP), BP	
  0x41d80d		488b442428		MOVQ 0x28(SP), AX	
	if cycles <= 0 {
  0x41d812		4885c0			TESTQ AX, AX		
  0x41d815		7f05			JG 0x41d81c		
  0x41d817		b801000000		MOVL $0x1, AX		
	if blocksampled(cycles) {
  0x41d81c		4889442428		MOVQ AX, 0x28(SP)		
  0x41d821		48890424		MOVQ AX, 0(SP)			
  0x41d825		e846000000		CALL runtime.blocksampled(SB)	
  0x41d82a		0fb6442408		MOVZX 0x8(SP), AX		
  0x41d82f		84c0			TESTL AL, AL			
  0x41d831		750a			JNE 0x41d83d			
  0x41d833		488b6c2418		MOVQ 0x18(SP), BP		
  0x41d838		4883c420		ADDQ $0x20, SP			
  0x41d83c		c3			RET				
  0x41d83d		488b442428		MOVQ 0x28(SP), AX		
		saveblockevent(cycles, skip+1, blockProfile)
  0x41d842		48890424		MOVQ AX, 0(SP)			
  0x41d846		488b442430		MOVQ 0x30(SP), AX		
  0x41d84b		48ffc0			INCQ AX				
  0x41d84e		4889442408		MOVQ AX, 0x8(SP)		
  0x41d853		48c744241002000000	MOVQ $0x2, 0x10(SP)		
  0x41d85c		e89f000000		CALL runtime.saveblockevent(SB)	
  0x41d861		ebd0			JMP 0x41d833			
func blockevent(cycles int64, skip int) {
  0x41d863		e8086d0200		CALL runtime.morestack_noctxt(SB)	
  0x41d868		eb86			JMP runtime.blockevent(SB)		

TEXT runtime.blocksampled(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
	rate := int64(atomic.Load64(&blockprofilerate))
  0x41d870		488b0db1600a00		MOVQ runtime.blockprofilerate(SB), CX	
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x41d877		4885c9			TESTQ CX, CX		
  0x41d87a		7f06			JG 0x41d882		
		return false
  0x41d87c		c644241000		MOVB $0x0, 0x10(SP)	
  0x41d881		c3			RET			
  0x41d882		488b542408		MOVQ 0x8(SP), DX	
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x41d887		4839d1			CMPQ DX, CX		
  0x41d88a		7e61			JLE 0x41d8ed		
	mp := getg().m
  0x41d88c		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x41d895		488b5b30		MOVQ 0x30(BX), BX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x41d899		8bb320010000		MOVL 0x120(BX), SI	
  0x41d89f		8bbb24010000		MOVL 0x124(BX), DI	
  0x41d8a5		4189f0			MOVL SI, R8		
	s1 ^= s1 << 17
  0x41d8a8		c1e611			SHLL $0x11, SI		
  0x41d8ab		4431c6			XORL R8, SI		
  0x41d8ae		4189f8			MOVL DI, R8		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x41d8b1		31f7			XORL SI, DI		
  0x41d8b3		c1ee07			SHRL $0x7, SI		
  0x41d8b6		31fe			XORL DI, SI		
  0x41d8b8		4489c7			MOVL R8, DI		
  0x41d8bb		41c1e810		SHRL $0x10, R8		
  0x41d8bf		4131f0			XORL SI, R8		
	return s0 + s1
  0x41d8c2		428d0407		LEAL 0(DI)(R8*1), AX	
  0x41d8c6		4889d6			MOVQ DX, SI		
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x41d8c9		4883f9ff		CMPQ $-0x1, CX		
  0x41d8cd		7407			JE 0x41d8d6		
  0x41d8cf		4899			CQO			
  0x41d8d1		48f7f9			IDIVQ CX		
  0x41d8d4		eb05			JMP 0x41d8db		
  0x41d8d6		48f7d8			NEGQ AX			
  0x41d8d9		31d2			XORL DX, DX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x41d8db		89bb20010000		MOVL DI, 0x120(BX)	
  0x41d8e1		44898324010000		MOVL R8, 0x124(BX)	
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x41d8e8		4839f2			CMPQ SI, DX		
  0x41d8eb		7f8f			JG 0x41d87c		
	return true
  0x41d8ed		c644241001		MOVB $0x1, 0x10(SP)	
  0x41d8f2		c3			RET			

TEXT runtime.saveblockevent(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func saveblockevent(cycles int64, skip int, which bucketType) {
  0x41d900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d909		488d842430ffffff	LEAQ 0xffffff30(SP), AX	
  0x41d911		483b4110		CMPQ 0x10(CX), AX	
  0x41d915		0f8688010000		JBE 0x41daa3		
  0x41d91b		4881ec50010000		SUBQ $0x150, SP		
  0x41d922		4889ac2448010000	MOVQ BP, 0x148(SP)	
  0x41d92a		488dac2448010000	LEAQ 0x148(SP), BP	
	gp := getg()
  0x41d932		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	var stk [maxStack]uintptr
  0x41d93b		488d7c2440		LEAQ 0x40(SP), DI	
  0x41d940		0f57c0			XORPS X0, X0		
  0x41d943		48896c24f0		MOVQ BP, -0x10(SP)	
  0x41d948		488d6c24f0		LEAQ -0x10(SP), BP	
  0x41d94d		e832910200		CALL 0x446a84		
  0x41d952		488b6d00		MOVQ 0(BP), BP		
	if gp.m.curg == nil || gp.m.curg == gp {
  0x41d956		488b4830		MOVQ 0x30(AX), CX	
  0x41d95a		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x41d961		4885c9			TESTQ CX, CX		
  0x41d964		7409			JE 0x41d96f		
  0x41d966		4839c1			CMPQ AX, CX		
  0x41d969		0f85f1000000		JNE 0x41da60		
  0x41d96f		488b842460010000	MOVQ 0x160(SP), AX	
		nstk = callers(skip, stk[:])
  0x41d977		48890424		MOVQ AX, 0(SP)			
  0x41d97b		488d442440		LEAQ 0x40(SP), AX		
  0x41d980		4889442408		MOVQ AX, 0x8(SP)		
  0x41d985		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x41d98e		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x41d997		e864ff0100		CALL runtime.callers(SB)	
  0x41d99c		488b442420		MOVQ 0x20(SP), AX		
  0x41d9a1		4889442438		MOVQ AX, 0x38(SP)		
	lock(&proflock)
  0x41d9a6		488d0d0b600a00		LEAQ runtime.proflock(SB), CX	
  0x41d9ad		48890c24		MOVQ CX, 0(SP)			
  0x41d9b1		e86abbfeff		CALL runtime.lock(SB)		
  0x41d9b6		488b442438		MOVQ 0x38(SP), AX		
	b := stkbucket(which, 0, stk[:nstk], true)
  0x41d9bb		4883f820		CMPQ $0x20, AX			
  0x41d9bf		0f87d7000000		JA 0x41da9c			
  0x41d9c5		488b8c2468010000	MOVQ 0x168(SP), CX		
  0x41d9cd		48890c24		MOVQ CX, 0(SP)			
  0x41d9d1		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x41d9da		488d4c2440		LEAQ 0x40(SP), CX		
  0x41d9df		48894c2410		MOVQ CX, 0x10(SP)		
  0x41d9e4		4889442418		MOVQ AX, 0x18(SP)		
  0x41d9e9		48c744242020000000	MOVQ $0x20, 0x20(SP)		
  0x41d9f2		c644242801		MOVB $0x1, 0x28(SP)		
  0x41d9f7		e8f4f5ffff		CALL runtime.stkbucket(SB)	
  0x41d9fc		488b442430		MOVQ 0x30(SP), AX		
  0x41da01		4889842440010000	MOVQ AX, 0x140(SP)		
	b.bp().count++
  0x41da09		48890424		MOVQ AX, 0(SP)			
  0x41da0d		e86ef5ffff		CALL runtime.(*bucket).bp(SB)	
  0x41da12		488b442408		MOVQ 0x8(SP), AX		
  0x41da17		48ff00			INCQ 0(AX)			
  0x41da1a		488b842440010000	MOVQ 0x140(SP), AX		
	b.bp().cycles += cycles
  0x41da22		48890424		MOVQ AX, 0(SP)			
  0x41da26		e855f5ffff		CALL runtime.(*bucket).bp(SB)	
  0x41da2b		488b442408		MOVQ 0x8(SP), AX		
  0x41da30		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x41da38		48034808		ADDQ 0x8(AX), CX		
  0x41da3c		48894808		MOVQ CX, 0x8(AX)		
	unlock(&proflock)
  0x41da40		488d05715f0a00		LEAQ runtime.proflock(SB), AX	
  0x41da47		48890424		MOVQ AX, 0(SP)			
  0x41da4b		e870bcfeff		CALL runtime.unlock(SB)		
}
  0x41da50		488bac2448010000	MOVQ 0x148(SP), BP	
  0x41da58		4881c450010000		ADDQ $0x150, SP		
  0x41da5f		c3			RET			
		nstk = gcallers(gp.m.curg, skip, stk[:])
  0x41da60		48890c24		MOVQ CX, 0(SP)			
  0x41da64		488b842460010000	MOVQ 0x160(SP), AX		
  0x41da6c		4889442408		MOVQ AX, 0x8(SP)		
  0x41da71		488d442440		LEAQ 0x40(SP), AX		
  0x41da76		4889442410		MOVQ AX, 0x10(SP)		
  0x41da7b		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x41da84		48c744242020000000	MOVQ $0x20, 0x20(SP)		
  0x41da8d		e84eff0100		CALL runtime.gcallers(SB)	
  0x41da92		488b442428		MOVQ 0x28(SP), AX		
  0x41da97		e905ffffff		JMP 0x41d9a1			
	b := stkbucket(which, 0, stk[:nstk], true)
  0x41da9c		e80f200000		CALL runtime.panicslice(SB)	
  0x41daa1		0f0b			UD2				
func saveblockevent(cycles int64, skip int, which bucketType) {
  0x41daa3		e8c86a0200		CALL runtime.morestack_noctxt(SB)	
  0x41daa8		e953feffff		JMP runtime.saveblockevent(SB)		

TEXT sync.event(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func mutexevent(cycles int64, skip int) {
  0x41dab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41dab9		483b6110		CMPQ 0x10(CX), SP	
  0x41dabd		0f86bb000000		JBE 0x41db7e		
  0x41dac3		4883ec20		SUBQ $0x20, SP		
  0x41dac7		48896c2418		MOVQ BP, 0x18(SP)	
  0x41dacc		488d6c2418		LEAQ 0x18(SP), BP	
  0x41dad1		488b4c2428		MOVQ 0x28(SP), CX	
	if cycles < 0 {
  0x41dad6		4885c9			TESTQ CX, CX		
  0x41dad9		0f8d97000000		JGE 0x41db76		
  0x41dadf		31c0			XORL AX, AX		
	rate := int64(atomic.Load64(&mutexprofilerate))
  0x41dae1		488b0da85e0a00		MOVQ runtime.mutexprofilerate(SB), CX	
	if rate > 0 && int64(fastrand())%rate == 0 {
  0x41dae8		4885c9			TESTQ CX, CX		
  0x41daeb		7e5e			JLE 0x41db4b		
	mp := getg().m
  0x41daed		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x41daf6		488b5230		MOVQ 0x30(DX), DX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x41dafa		8b9a20010000		MOVL 0x120(DX), BX	
  0x41db00		8bb224010000		MOVL 0x124(DX), SI	
  0x41db06		89df			MOVL BX, DI		
	s1 ^= s1 << 17
  0x41db08		c1e311			SHLL $0x11, BX		
  0x41db0b		31fb			XORL DI, BX		
  0x41db0d		89f7			MOVL SI, DI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x41db0f		31de			XORL BX, SI		
  0x41db11		c1eb07			SHRL $0x7, BX		
  0x41db14		31f3			XORL SI, BX		
  0x41db16		89fe			MOVL DI, SI		
  0x41db18		c1ef10			SHRL $0x10, DI		
  0x41db1b		31df			XORL BX, DI		
	return s0 + s1
  0x41db1d		8d1c3e			LEAL 0(SI)(DI*1), BX	
  0x41db20		4989c0			MOVQ AX, R8		
  0x41db23		89d8			MOVL BX, AX		
  0x41db25		4889d3			MOVQ DX, BX		
	if rate > 0 && int64(fastrand())%rate == 0 {
  0x41db28		4883f9ff		CMPQ $-0x1, CX		
  0x41db2c		7407			JE 0x41db35		
  0x41db2e		4899			CQO			
  0x41db30		48f7f9			IDIVQ CX		
  0x41db33		eb05			JMP 0x41db3a		
  0x41db35		48f7d8			NEGQ AX			
  0x41db38		31d2			XORL DX, DX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x41db3a		89b320010000		MOVL SI, 0x120(BX)	
  0x41db40		89bb24010000		MOVL DI, 0x124(BX)	
	if rate > 0 && int64(fastrand())%rate == 0 {
  0x41db46		4885d2			TESTQ DX, DX		
  0x41db49		740a			JE 0x41db55		
  0x41db4b		488b6c2418		MOVQ 0x18(SP), BP	
  0x41db50		4883c420		ADDQ $0x20, SP		
  0x41db54		c3			RET			
		saveblockevent(cycles, skip+1, mutexProfile)
  0x41db55		4c890424		MOVQ R8, 0(SP)			
  0x41db59		488b442430		MOVQ 0x30(SP), AX		
  0x41db5e		48ffc0			INCQ AX				
  0x41db61		4889442408		MOVQ AX, 0x8(SP)		
  0x41db66		48c744241003000000	MOVQ $0x3, 0x10(SP)		
  0x41db6f		e88cfdffff		CALL runtime.saveblockevent(SB)	
  0x41db74		ebd5			JMP 0x41db4b			
  0x41db76		4889c8			MOVQ CX, AX			
	if cycles < 0 {
  0x41db79		e963ffffff		JMP 0x41dae1		
func mutexevent(cycles int64, skip int) {
  0x41db7e		e8ed690200		CALL runtime.morestack_noctxt(SB)	
  0x41db83		e928ffffff		JMP sync.event(SB)			

TEXT runtime.tracealloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func tracealloc(p unsafe.Pointer, size uintptr, typ *_type) {
  0x41db90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41db99		483b6110		CMPQ 0x10(CX), SP	
  0x41db9d		0f864d020000		JBE 0x41ddf0		
  0x41dba3		4883ec60		SUBQ $0x60, SP		
  0x41dba7		48896c2458		MOVQ BP, 0x58(SP)	
  0x41dbac		488d6c2458		LEAQ 0x58(SP), BP	
	lock(&tracelock)
  0x41dbb1		488d05405e0a00		LEAQ runtime.tracelock(SB), AX	
  0x41dbb8		48890424		MOVQ AX, 0(SP)			
  0x41dbbc		e85fb9feff		CALL runtime.lock(SB)		
	gp := getg()
  0x41dbc1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41dbca		4889442428		MOVQ AX, 0x28(SP)	
	gp.m.traceback = 2
  0x41dbcf		488b4830		MOVQ 0x30(AX), CX	
  0x41dbd3		c6812901000002		MOVB $0x2, 0x129(CX)	
func tracealloc(p unsafe.Pointer, size uintptr, typ *_type) {
  0x41dbda		488b4c2478		MOVQ 0x78(SP), CX	
	if typ == nil {
  0x41dbdf		4885c9			TESTQ CX, CX		
  0x41dbe2		0f8492010000		JE 0x41dd7a		
		print("tracealloc(", p, ", ", hex(size), ", ", typ.string(), ")\n")
  0x41dbe8		48890c24		MOVQ CX, 0(SP)				
  0x41dbec		e87f0d0200		CALL runtime.(*_type).string(SB)	
  0x41dbf1		488b442410		MOVQ 0x10(SP), AX			
  0x41dbf6		4889442420		MOVQ AX, 0x20(SP)			
  0x41dbfb		488b4c2408		MOVQ 0x8(SP), CX			
  0x41dc00		48894c2430		MOVQ CX, 0x30(SP)			
  0x41dc05		e8f63e0000		CALL runtime.printlock(SB)		
  0x41dc0a		488d05bbc80400		LEAQ 0x4c8bb(IP), AX			
  0x41dc11		48890424		MOVQ AX, 0(SP)				
  0x41dc15		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x41dc1e		e81d480000		CALL runtime.printstring(SB)		
  0x41dc23		488b442468		MOVQ 0x68(SP), AX			
  0x41dc28		48890424		MOVQ AX, 0(SP)				
  0x41dc2c		e8cf470000		CALL runtime.printpointer(SB)		
  0x41dc31		488d0534c00400		LEAQ 0x4c034(IP), AX			
  0x41dc38		48890424		MOVQ AX, 0(SP)				
  0x41dc3c		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x41dc45		e8f6470000		CALL runtime.printstring(SB)		
  0x41dc4a		488b442470		MOVQ 0x70(SP), AX			
  0x41dc4f		48890424		MOVQ AX, 0(SP)				
  0x41dc53		e898460000		CALL runtime.printhex(SB)		
  0x41dc58		488d050dc00400		LEAQ 0x4c00d(IP), AX			
  0x41dc5f		48890424		MOVQ AX, 0(SP)				
  0x41dc63		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x41dc6c		e8cf470000		CALL runtime.printstring(SB)		
  0x41dc71		488b442430		MOVQ 0x30(SP), AX			
  0x41dc76		48890424		MOVQ AX, 0(SP)				
  0x41dc7a		488b442420		MOVQ 0x20(SP), AX			
  0x41dc7f		4889442408		MOVQ AX, 0x8(SP)			
  0x41dc84		e8b7470000		CALL runtime.printstring(SB)		
  0x41dc89		488d05dabf0400		LEAQ 0x4bfda(IP), AX			
  0x41dc90		48890424		MOVQ AX, 0(SP)				
  0x41dc94		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x41dc9d		e89e470000		CALL runtime.printstring(SB)		
  0x41dca2		e8d93e0000		CALL runtime.printunlock(SB)		
  0x41dca7		488b442428		MOVQ 0x28(SP), AX			
	if gp.m.curg == nil || gp == gp.m.curg {
  0x41dcac		488b4830		MOVQ 0x30(AX), CX	
  0x41dcb0		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x41dcb7		4885c9			TESTQ CX, CX		
  0x41dcba		7405			JE 0x41dcc1		
  0x41dcbc		4839c8			CMPQ CX, AX		
  0x41dcbf		757a			JNE 0x41dd3b		
		goroutineheader(gp)
  0x41dcc1		48890424		MOVQ AX, 0(SP)				
  0x41dcc5		e856000200		CALL runtime.goroutineheader(SB)	
		systemstack(func() {
  0x41dcca		488d057f4d0200		LEAQ runtime.tracealloc.func1(SB), AX	
  0x41dcd1		4889442438		MOVQ AX, 0x38(SP)			
  0x41dcd6		488b442460		MOVQ 0x60(SP), AX			
  0x41dcdb		4889442440		MOVQ AX, 0x40(SP)			
  0x41dce0		488d442468		LEAQ 0x68(SP), AX			
  0x41dce5		4889442448		MOVQ AX, 0x48(SP)			
  0x41dcea		488b442428		MOVQ 0x28(SP), AX			
  0x41dcef		4889442450		MOVQ AX, 0x50(SP)			
  0x41dcf4		488d4c2438		LEAQ 0x38(SP), CX			
  0x41dcf9		48890c24		MOVQ CX, 0(SP)				
  0x41dcfd		e81e670200		CALL runtime.systemstack(SB)		
	print("\n")
  0x41dd02		e8f93d0000		CALL runtime.printlock(SB)	
  0x41dd07		e884400000		CALL runtime.printnl(SB)	
  0x41dd0c		e86f3e0000		CALL runtime.printunlock(SB)	
  0x41dd11		488b442428		MOVQ 0x28(SP), AX		
	gp.m.traceback = 0
  0x41dd16		488b4030		MOVQ 0x30(AX), AX	
  0x41dd1a		c6802901000000		MOVB $0x0, 0x129(AX)	
	unlock(&tracelock)
  0x41dd21		488d05d05c0a00		LEAQ runtime.tracelock(SB), AX	
  0x41dd28		48890424		MOVQ AX, 0(SP)			
  0x41dd2c		e88fb9feff		CALL runtime.unlock(SB)		
}
  0x41dd31		488b6c2458		MOVQ 0x58(SP), BP	
  0x41dd36		4883c460		ADDQ $0x60, SP		
  0x41dd3a		c3			RET			
		goroutineheader(gp.m.curg)
  0x41dd3b		48890c24		MOVQ CX, 0(SP)				
  0x41dd3f		e8dcff0100		CALL runtime.goroutineheader(SB)	
  0x41dd44		488b442428		MOVQ 0x28(SP), AX			
		traceback(^uintptr(0), ^uintptr(0), 0, gp.m.curg)
  0x41dd49		488b4830		MOVQ 0x30(AX), CX		
  0x41dd4d		488b89c0000000		MOVQ 0xc0(CX), CX		
  0x41dd54		48894c2418		MOVQ CX, 0x18(SP)		
  0x41dd59		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x41dd61		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x41dd6a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x41dd73		e848f80100		CALL runtime.traceback(SB)	
  0x41dd78		eb88			JMP 0x41dd02			
		print("tracealloc(", p, ", ", hex(size), ")\n")
  0x41dd7a		e8813d0000		CALL runtime.printlock(SB)	
  0x41dd7f		488d0546c70400		LEAQ 0x4c746(IP), AX		
  0x41dd86		48890424		MOVQ AX, 0(SP)			
  0x41dd8a		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x41dd93		e8a8460000		CALL runtime.printstring(SB)	
  0x41dd98		488b442468		MOVQ 0x68(SP), AX		
  0x41dd9d		48890424		MOVQ AX, 0(SP)			
  0x41dda1		e85a460000		CALL runtime.printpointer(SB)	
  0x41dda6		488d05bfbe0400		LEAQ 0x4bebf(IP), AX		
  0x41ddad		48890424		MOVQ AX, 0(SP)			
  0x41ddb1		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41ddba		e881460000		CALL runtime.printstring(SB)	
  0x41ddbf		488b442470		MOVQ 0x70(SP), AX		
  0x41ddc4		48890424		MOVQ AX, 0(SP)			
  0x41ddc8		e823450000		CALL runtime.printhex(SB)	
  0x41ddcd		488d0596be0400		LEAQ 0x4be96(IP), AX		
  0x41ddd4		48890424		MOVQ AX, 0(SP)			
  0x41ddd8		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41dde1		e85a460000		CALL runtime.printstring(SB)	
  0x41dde6		e8953d0000		CALL runtime.printunlock(SB)	
  0x41ddeb		e9b7feffff		JMP 0x41dca7			
func tracealloc(p unsafe.Pointer, size uintptr, typ *_type) {
  0x41ddf0		e87b670200		CALL runtime.morestack_noctxt(SB)	
  0x41ddf5		e996fdffff		JMP runtime.tracealloc(SB)		

TEXT runtime.tracefree(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func tracefree(p unsafe.Pointer, size uintptr) {
  0x41de00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41de09		483b6110		CMPQ 0x10(CX), SP	
  0x41de0d		0f8627010000		JBE 0x41df3a		
  0x41de13		4883ec40		SUBQ $0x40, SP		
  0x41de17		48896c2438		MOVQ BP, 0x38(SP)	
  0x41de1c		488d6c2438		LEAQ 0x38(SP), BP	
	lock(&tracelock)
  0x41de21		488d05d05b0a00		LEAQ runtime.tracelock(SB), AX	
  0x41de28		48890424		MOVQ AX, 0(SP)			
  0x41de2c		e8efb6feff		CALL runtime.lock(SB)		
	gp := getg()
  0x41de31		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41de3a		4889442410		MOVQ AX, 0x10(SP)	
	gp.m.traceback = 2
  0x41de3f		488b4830		MOVQ 0x30(AX), CX	
  0x41de43		c6812901000002		MOVB $0x2, 0x129(CX)	
	print("tracefree(", p, ", ", hex(size), ")\n")
  0x41de4a		e8b13c0000		CALL runtime.printlock(SB)	
  0x41de4f		488d0524c50400		LEAQ 0x4c524(IP), AX		
  0x41de56		48890424		MOVQ AX, 0(SP)			
  0x41de5a		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41de63		e8d8450000		CALL runtime.printstring(SB)	
  0x41de68		488b442448		MOVQ 0x48(SP), AX		
  0x41de6d		48890424		MOVQ AX, 0(SP)			
  0x41de71		e88a450000		CALL runtime.printpointer(SB)	
  0x41de76		488d05efbd0400		LEAQ 0x4bdef(IP), AX		
  0x41de7d		48890424		MOVQ AX, 0(SP)			
  0x41de81		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41de8a		e8b1450000		CALL runtime.printstring(SB)	
func tracefree(p unsafe.Pointer, size uintptr) {
  0x41de8f		488b442450		MOVQ 0x50(SP), AX	
	print("tracefree(", p, ", ", hex(size), ")\n")
  0x41de94		48890424		MOVQ AX, 0(SP)			
  0x41de98		e853440000		CALL runtime.printhex(SB)	
  0x41de9d		488d05c6bd0400		LEAQ 0x4bdc6(IP), AX		
  0x41dea4		48890424		MOVQ AX, 0(SP)			
  0x41dea8		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41deb1		e88a450000		CALL runtime.printstring(SB)	
  0x41deb6		e8c53c0000		CALL runtime.printunlock(SB)	
  0x41debb		488b442410		MOVQ 0x10(SP), AX		
	goroutineheader(gp)
  0x41dec0		48890424		MOVQ AX, 0(SP)				
  0x41dec4		e857fe0100		CALL runtime.goroutineheader(SB)	
	systemstack(func() {
  0x41dec9		488d05e04b0200		LEAQ runtime.tracefree.func1(SB), AX	
  0x41ded0		4889442418		MOVQ AX, 0x18(SP)			
  0x41ded5		488b442440		MOVQ 0x40(SP), AX			
  0x41deda		4889442420		MOVQ AX, 0x20(SP)			
  0x41dedf		488d442448		LEAQ 0x48(SP), AX			
  0x41dee4		4889442428		MOVQ AX, 0x28(SP)			
  0x41dee9		488b442410		MOVQ 0x10(SP), AX			
  0x41deee		4889442430		MOVQ AX, 0x30(SP)			
  0x41def3		488d4c2418		LEAQ 0x18(SP), CX			
  0x41def8		48890c24		MOVQ CX, 0(SP)				
  0x41defc		e81f650200		CALL runtime.systemstack(SB)		
	print("\n")
  0x41df01		e8fa3b0000		CALL runtime.printlock(SB)	
  0x41df06		e8853e0000		CALL runtime.printnl(SB)	
  0x41df0b		e8703c0000		CALL runtime.printunlock(SB)	
  0x41df10		488b442410		MOVQ 0x10(SP), AX		
	gp.m.traceback = 0
  0x41df15		488b4030		MOVQ 0x30(AX), AX	
  0x41df19		c6802901000000		MOVB $0x0, 0x129(AX)	
	unlock(&tracelock)
  0x41df20		488d05d15a0a00		LEAQ runtime.tracelock(SB), AX	
  0x41df27		48890424		MOVQ AX, 0(SP)			
  0x41df2b		e890b7feff		CALL runtime.unlock(SB)		
}
  0x41df30		488b6c2438		MOVQ 0x38(SP), BP	
  0x41df35		4883c440		ADDQ $0x40, SP		
  0x41df39		c3			RET			
func tracefree(p unsafe.Pointer, size uintptr) {
  0x41df3a		e831660200		CALL runtime.morestack_noctxt(SB)	
  0x41df3f		e9bcfeffff		JMP runtime.tracefree(SB)		

TEXT runtime.tracegc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
func tracegc() {
  0x41df50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41df59		483b6110		CMPQ 0x10(CX), SP	
  0x41df5d		0f86c4000000		JBE 0x41e027		
  0x41df63		4883ec20		SUBQ $0x20, SP		
  0x41df67		48896c2418		MOVQ BP, 0x18(SP)	
  0x41df6c		488d6c2418		LEAQ 0x18(SP), BP	
	lock(&tracelock)
  0x41df71		488d05805a0a00		LEAQ runtime.tracelock(SB), AX	
  0x41df78		48890424		MOVQ AX, 0(SP)			
  0x41df7c		e89fb5feff		CALL runtime.lock(SB)		
	gp := getg()
  0x41df81		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41df8a		4889442410		MOVQ AX, 0x10(SP)	
	gp.m.traceback = 2
  0x41df8f		488b4830		MOVQ 0x30(AX), CX	
  0x41df93		c6812901000002		MOVB $0x2, 0x129(CX)	
	print("tracegc()\n")
  0x41df9a		e8613b0000		CALL runtime.printlock(SB)	
  0x41df9f		488d05dec30400		LEAQ 0x4c3de(IP), AX		
  0x41dfa6		48890424		MOVQ AX, 0(SP)			
  0x41dfaa		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41dfb3		e888440000		CALL runtime.printstring(SB)	
  0x41dfb8		e8c33b0000		CALL runtime.printunlock(SB)	
  0x41dfbd		488b442410		MOVQ 0x10(SP), AX		
	tracebackothers(gp)
  0x41dfc2		48890424		MOVQ AX, 0(SP)				
  0x41dfc6		e8f5ff0100		CALL runtime.tracebackothers(SB)	
	print("end tracegc\n")
  0x41dfcb		e8303b0000		CALL runtime.printlock(SB)	
  0x41dfd0		488d052bc60400		LEAQ 0x4c62b(IP), AX		
  0x41dfd7		48890424		MOVQ AX, 0(SP)			
  0x41dfdb		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x41dfe4		e857440000		CALL runtime.printstring(SB)	
  0x41dfe9		e8923b0000		CALL runtime.printunlock(SB)	
	print("\n")
  0x41dfee		e80d3b0000		CALL runtime.printlock(SB)	
  0x41dff3		e8983d0000		CALL runtime.printnl(SB)	
  0x41dff8		e8833b0000		CALL runtime.printunlock(SB)	
  0x41dffd		488b442410		MOVQ 0x10(SP), AX		
	gp.m.traceback = 0
  0x41e002		488b4030		MOVQ 0x30(AX), AX	
  0x41e006		c6802901000000		MOVB $0x0, 0x129(AX)	
	unlock(&tracelock)
  0x41e00d		488d05e4590a00		LEAQ runtime.tracelock(SB), AX	
  0x41e014		48890424		MOVQ AX, 0(SP)			
  0x41e018		e8a3b6feff		CALL runtime.unlock(SB)		
}
  0x41e01d		488b6c2418		MOVQ 0x18(SP), BP	
  0x41e022		4883c420		ADDQ $0x20, SP		
  0x41e026		c3			RET			
func tracegc() {
  0x41e027		e844650200		CALL runtime.morestack_noctxt(SB)	
  0x41e02c		e91fffffff		JMP runtime.tracegc(SB)			

TEXT runtime.init.2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mstats.go
func init() {
  0x41e040		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e049		488b7110		MOVQ 0x10(CX), SI	
  0x41e04d		4881fedefaffff		CMPQ $-0x522, SI	
  0x41e054		0f84a9000000		JE 0x41e103		
  0x41e05a		488d842470030000	LEAQ 0x370(SP), AX	
  0x41e062		4829f0			SUBQ SI, AX		
  0x41e065		483d98190000		CMPQ $0x1998, AX	
  0x41e06b		0f8692000000		JBE 0x41e103		
  0x41e071		4881eca8160000		SUBQ $0x16a8, SP	
  0x41e078		4889ac24a0160000	MOVQ BP, 0x16a0(SP)	
  0x41e080		488dac24a0160000	LEAQ 0x16a0(SP), BP	
	var memStats MemStats
  0x41e088		488d7c2410		LEAQ 0x10(SP), DI	
  0x41e08d		b9d2020000		MOVL $0x2d2, CX		
  0x41e092		31c0			XORL AX, AX		
  0x41e094		f348ab			REP; STOSQ AX, ES:0(DI)	
	if sizeof_C_MStats != unsafe.Sizeof(memStats) {
  0x41e097		488b15ba6f0800		MOVQ runtime.sizeof_C_MStats(SB), DX	
  0x41e09e		4881fa90160000		CMPQ $0x1690, DX			
  0x41e0a5		7510			JNE 0x41e0b7				
  0x41e0a7		488bac24a0160000	MOVQ 0x16a0(SP), BP			
  0x41e0af		4881c4a8160000		ADDQ $0x16a8, SP			
  0x41e0b6		c3			RET					
		println(sizeof_C_MStats, unsafe.Sizeof(memStats))
  0x41e0b7		e8443a0000		CALL runtime.printlock(SB)		
  0x41e0bc		488b05956f0800		MOVQ runtime.sizeof_C_MStats(SB), AX	
  0x41e0c3		48890424		MOVQ AX, 0(SP)				
  0x41e0c7		e8a4400000		CALL runtime.printuint(SB)		
  0x41e0cc		e86f3c0000		CALL runtime.printsp(SB)		
  0x41e0d1		48c7042490160000	MOVQ $0x1690, 0(SP)			
  0x41e0d9		e892400000		CALL runtime.printuint(SB)		
  0x41e0de		e8ad3c0000		CALL runtime.printnl(SB)		
  0x41e0e3		e8983a0000		CALL runtime.printunlock(SB)		
		throw("MStats vs MemStatsType size mismatch")
  0x41e0e8		488d0513ed0400		LEAQ 0x4ed13(IP), AX	
  0x41e0ef		48890424		MOVQ AX, 0(SP)		
  0x41e0f3		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x41e0fc		e8cf300000		CALL runtime.throw(SB)	
  0x41e101		0f0b			UD2			
func init() {
  0x41e103		e868640200		CALL runtime.morestack_noctxt(SB)	
  0x41e108		e933ffffff		JMP runtime.init.2(SB)			

TEXT runtime.cachestats(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mstats.go
func cachestats() {
  0x41e110		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e119		483b6110		CMPQ 0x10(CX), SP	
  0x41e11d		7668			JBE 0x41e187		
  0x41e11f		4883ec28		SUBQ $0x28, SP		
  0x41e123		48896c2420		MOVQ BP, 0x20(SP)	
  0x41e128		488d6c2420		LEAQ 0x20(SP), BP	
	for _, p := range allp {
  0x41e12d		488b057c950800		MOVQ runtime.allp(SB), AX	
  0x41e134		4889442418		MOVQ AX, 0x18(SP)		
  0x41e139		488b0d78950800		MOVQ runtime.allp+8(SB), CX	
  0x41e140		48894c2410		MOVQ CX, 0x10(SP)		
  0x41e145		31d2			XORL DX, DX			
  0x41e147		eb03			JMP 0x41e14c			
  0x41e149		48ffc2			INCQ DX				
  0x41e14c		4839ca			CMPQ CX, DX			
  0x41e14f		7d2c			JGE 0x41e17d			
  0x41e151		488b1cd0		MOVQ 0(AX)(DX*8), BX		
		c := p.mcache
  0x41e155		488b5b48		MOVQ 0x48(BX), BX	
		if c == nil {
  0x41e159		4885db			TESTQ BX, BX		
  0x41e15c		74eb			JE 0x41e149		
  0x41e15e		4889542408		MOVQ DX, 0x8(SP)	
		purgecachedstats(c)
  0x41e163		48891c24		MOVQ BX, 0(SP)				
  0x41e167		e8a4000000		CALL runtime.purgecachedstats(SB)	
  0x41e16c		488b442418		MOVQ 0x18(SP), AX			
  0x41e171		488b4c2410		MOVQ 0x10(SP), CX			
  0x41e176		488b542408		MOVQ 0x8(SP), DX			
  0x41e17b		ebcc			JMP 0x41e149				
  0x41e17d		488b6c2420		MOVQ 0x20(SP), BP			
  0x41e182		4883c428		ADDQ $0x28, SP				
  0x41e186		c3			RET					
func cachestats() {
  0x41e187		e8e4630200		CALL runtime.morestack_noctxt(SB)	
  0x41e18c		eb82			JMP runtime.cachestats(SB)		

TEXT runtime.flushmcache(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mstats.go
func flushmcache(i int) {
  0x41e190		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e199		483b6110		CMPQ 0x10(CX), SP	
  0x41e19d		766a			JBE 0x41e209		
  0x41e19f		4883ec18		SUBQ $0x18, SP		
  0x41e1a3		48896c2410		MOVQ BP, 0x10(SP)	
  0x41e1a8		488d6c2410		LEAQ 0x10(SP), BP	
	p := allp[i]
  0x41e1ad		488b05fc940800		MOVQ runtime.allp(SB), AX	
  0x41e1b4		488b0dfd940800		MOVQ runtime.allp+8(SB), CX	
  0x41e1bb		488b542420		MOVQ 0x20(SP), DX		
  0x41e1c0		4839ca			CMPQ CX, DX			
  0x41e1c3		733d			JAE 0x41e202			
  0x41e1c5		488b04d0		MOVQ 0(AX)(DX*8), AX		
	c := p.mcache
  0x41e1c9		488b4048		MOVQ 0x48(AX), AX	
	if c == nil {
  0x41e1cd		4885c0			TESTQ AX, AX		
  0x41e1d0		7426			JE 0x41e1f8		
  0x41e1d2		4889442408		MOVQ AX, 0x8(SP)	
	c.releaseAll()
  0x41e1d7		48890424		MOVQ AX, 0(SP)				
  0x41e1db		e89003ffff		CALL runtime.(*mcache).releaseAll(SB)	
  0x41e1e0		488b442408		MOVQ 0x8(SP), AX			
	stackcache_clear(c)
  0x41e1e5		48890424		MOVQ AX, 0(SP)				
  0x41e1e9		e842620100		CALL runtime.stackcache_clear(SB)	
}
  0x41e1ee		488b6c2410		MOVQ 0x10(SP), BP	
  0x41e1f3		4883c418		ADDQ $0x18, SP		
  0x41e1f7		c3			RET			
		return
  0x41e1f8		488b6c2410		MOVQ 0x10(SP), BP	
  0x41e1fd		4883c418		ADDQ $0x18, SP		
  0x41e201		c3			RET			
	p := allp[i]
  0x41e202		e839180000		CALL runtime.panicindex(SB)	
  0x41e207		0f0b			UD2				
func flushmcache(i int) {
  0x41e209		e862630200		CALL runtime.morestack_noctxt(SB)	
  0x41e20e		eb80			JMP runtime.flushmcache(SB)		

TEXT runtime.purgecachedstats(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mstats.go
func purgecachedstats(c *mcache) {
  0x41e210		488b442408		MOVQ 0x8(SP), AX	
	memstats.heap_scan += uint64(c.local_scan)
  0x41e215		488b4808		MOVQ 0x8(AX), CX			
  0x41e219		48030d287c0a00		ADDQ runtime.memstats+5960(SB), CX	
  0x41e220		48890d217c0a00		MOVQ CX, runtime.memstats+5960(SB)	
	c.local_scan = 0
  0x41e227		48c7400800000000	MOVQ $0x0, 0x8(AX)	
	memstats.tinyallocs += uint64(c.local_tinyallocs)
  0x41e22f		488b4820		MOVQ 0x20(AX), CX			
  0x41e233		48030dee7b0a00		ADDQ runtime.memstats+5928(SB), CX	
  0x41e23a		48890de77b0a00		MOVQ CX, runtime.memstats+5928(SB)	
	c.local_tinyallocs = 0
  0x41e241		48c7402000000000	MOVQ $0x0, 0x20(AX)	
	memstats.nlookup += uint64(c.local_nlookup)
  0x41e249		488b8898040000		MOVQ 0x498(AX), CX			
  0x41e250		48030dc1640a00		ADDQ runtime.memstats+24(SB), CX	
  0x41e257		48890dba640a00		MOVQ CX, runtime.memstats+24(SB)	
	c.local_nlookup = 0
  0x41e25e		48c7809804000000000000	MOVQ $0x0, 0x498(AX)	
	h.largefree += uint64(c.local_largefree)
  0x41e269		488b88a0040000		MOVQ 0x4a0(AX), CX			
  0x41e270		48030d19f10800		ADDQ runtime.mheap_+4336(SB), CX	
  0x41e277		48890d12f10800		MOVQ CX, runtime.mheap_+4336(SB)	
	c.local_largefree = 0
  0x41e27e		48c780a004000000000000	MOVQ $0x0, 0x4a0(AX)	
	h.nlargefree += uint64(c.local_nlargefree)
  0x41e289		488b88a8040000		MOVQ 0x4a8(AX), CX			
  0x41e290		48030d01f10800		ADDQ runtime.mheap_+4344(SB), CX	
  0x41e297		48890dfaf00800		MOVQ CX, runtime.mheap_+4344(SB)	
	c.local_nlargefree = 0
  0x41e29e		48c780a804000000000000	MOVQ $0x0, 0x4a8(AX)	
  0x41e2a9		31c9			XORL CX, CX		
	for i := 0; i < len(c.local_nsmallfree); i++ {
  0x41e2ab		eb34			JMP 0x41e2e1		
		h.nsmallfree[i] += uint64(c.local_nsmallfree[i])
  0x41e2ad		488d15ecdf0800		LEAQ runtime.mheap_(SB), DX		
  0x41e2b4		488d9cca00110000	LEAQ 0x1100(DX)(CX*8), BX		
  0x41e2bc		488bb4c8b0040000	MOVQ 0x4b0(AX)(CX*8), SI		
  0x41e2c4		480333			ADDQ 0(BX), SI				
  0x41e2c7		488d1dd2f00800		LEAQ runtime.mheap_+4352(SB), BX	
  0x41e2ce		488934cb		MOVQ SI, 0(BX)(CX*8)			
		c.local_nsmallfree[i] = 0
  0x41e2d2		48c784c8b004000000000000	MOVQ $0x0, 0x4b0(AX)(CX*8)	
	for i := 0; i < len(c.local_nsmallfree); i++ {
  0x41e2de		48ffc1			INCQ CX			
  0x41e2e1		4883f943		CMPQ $0x43, CX		
  0x41e2e5		7cc6			JL 0x41e2ad		
  0x41e2e7		c3			RET			

TEXT runtime.mSysStatInc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mstats.go
func mSysStatInc(sysStat *uint64, n uintptr) {
  0x41e2f0		4883ec20		SUBQ $0x20, SP		
  0x41e2f4		48896c2418		MOVQ BP, 0x18(SP)	
  0x41e2f9		488d6c2418		LEAQ 0x18(SP), BP	
  0x41e2fe		488b442430		MOVQ 0x30(SP), AX	
  0x41e303		488b4c2428		MOVQ 0x28(SP), CX	
  0x41e308		4889c2			MOVQ AX, DX		
	if val := atomic.Xadduintptr((*uintptr)(unsafe.Pointer(sysStat)), n); val < n {
  0x41e30b		f0480fc101		LOCK XADDQ AX, 0(CX)	
  0x41e310		4801d0			ADDQ DX, AX		
  0x41e313		4839d0			CMPQ DX, AX		
  0x41e316		720a			JB 0x41e322		
  0x41e318		488b6c2418		MOVQ 0x18(SP), BP	
  0x41e31d		4883c420		ADDQ $0x20, SP		
  0x41e321		c3			RET			
  0x41e322		4889442410		MOVQ AX, 0x10(SP)	
		print("runtime: stat overflow: val ", val, ", n ", n, "\n")
  0x41e327		e8d4370000		CALL runtime.printlock(SB)	
  0x41e32c		488d05b7de0400		LEAQ 0x4deb7(IP), AX		
  0x41e333		48890424		MOVQ AX, 0(SP)			
  0x41e337		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x41e340		e8fb400000		CALL runtime.printstring(SB)	
  0x41e345		488b442410		MOVQ 0x10(SP), AX		
  0x41e34a		48890424		MOVQ AX, 0(SP)			
  0x41e34e		e81d3e0000		CALL runtime.printuint(SB)	
  0x41e353		488d0590b90400		LEAQ 0x4b990(IP), AX		
  0x41e35a		48890424		MOVQ AX, 0(SP)			
  0x41e35e		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x41e367		e8d4400000		CALL runtime.printstring(SB)	
  0x41e36c		488b442430		MOVQ 0x30(SP), AX		
  0x41e371		48890424		MOVQ AX, 0(SP)			
  0x41e375		e8f63d0000		CALL runtime.printuint(SB)	
  0x41e37a		e8113a0000		CALL runtime.printnl(SB)	
  0x41e37f		e8fc370000		CALL runtime.printunlock(SB)	
		exit(2)
  0x41e384		c7042402000000		MOVL $0x2, 0(SP)	
  0x41e38b		e840940200		CALL runtime.exit(SB)	
  0x41e390		eb86			JMP 0x41e318		

TEXT runtime.mSysStatDec(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mstats.go
func mSysStatDec(sysStat *uint64, n uintptr) {
  0x41e3a0		4883ec20		SUBQ $0x20, SP		
  0x41e3a4		48896c2418		MOVQ BP, 0x18(SP)	
  0x41e3a9		488d6c2418		LEAQ 0x18(SP), BP	
  0x41e3ae		488b442430		MOVQ 0x30(SP), AX	
  0x41e3b3		4889c1			MOVQ AX, CX		
	if val := atomic.Xadduintptr((*uintptr)(unsafe.Pointer(sysStat)), uintptr(-int64(n))); val+n < n {
  0x41e3b6		48f7d8			NEGQ AX			
  0x41e3b9		488b542428		MOVQ 0x28(SP), DX	
  0x41e3be		f0480fc102		LOCK XADDQ AX, 0(DX)	
  0x41e3c3		4829c8			SUBQ CX, AX		
  0x41e3c6		488d1408		LEAQ 0(AX)(CX*1), DX	
  0x41e3ca		4839ca			CMPQ CX, DX		
  0x41e3cd		720a			JB 0x41e3d9		
  0x41e3cf		488b6c2418		MOVQ 0x18(SP), BP	
  0x41e3d4		4883c420		ADDQ $0x20, SP		
  0x41e3d8		c3			RET			
  0x41e3d9		4889442410		MOVQ AX, 0x10(SP)	
		print("runtime: stat underflow: val ", val, ", n ", n, "\n")
  0x41e3de		e81d370000		CALL runtime.printlock(SB)	
  0x41e3e3		488d055bdf0400		LEAQ 0x4df5b(IP), AX		
  0x41e3ea		48890424		MOVQ AX, 0(SP)			
  0x41e3ee		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x41e3f7		e844400000		CALL runtime.printstring(SB)	
  0x41e3fc		488b442410		MOVQ 0x10(SP), AX		
  0x41e401		48890424		MOVQ AX, 0(SP)			
  0x41e405		e8663d0000		CALL runtime.printuint(SB)	
  0x41e40a		488d05d9b80400		LEAQ 0x4b8d9(IP), AX		
  0x41e411		48890424		MOVQ AX, 0(SP)			
  0x41e415		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x41e41e		e81d400000		CALL runtime.printstring(SB)	
  0x41e423		488b442430		MOVQ 0x30(SP), AX		
  0x41e428		48890424		MOVQ AX, 0(SP)			
  0x41e42c		e83f3d0000		CALL runtime.printuint(SB)	
  0x41e431		e85a390000		CALL runtime.printnl(SB)	
  0x41e436		e845370000		CALL runtime.printunlock(SB)	
		exit(2)
  0x41e43b		c7042402000000		MOVL $0x2, 0(SP)	
  0x41e442		e889930200		CALL runtime.exit(SB)	
  0x41e447		eb86			JMP 0x41e3cf		

TEXT runtime.(*wbBuf).reset(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mwbbuf.go
func (b *wbBuf) reset() {
  0x41e450		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e459		483b6110		CMPQ 0x10(CX), SP	
  0x41e45d		767a			JBE 0x41e4d9		
  0x41e45f		4883ec18		SUBQ $0x18, SP		
  0x41e463		48896c2410		MOVQ BP, 0x10(SP)	
  0x41e468		488d6c2410		LEAQ 0x10(SP), BP	
  0x41e46d		488b442420		MOVQ 0x20(SP), AX	
	start := uintptr(unsafe.Pointer(&b.buf[0]))
  0x41e472		488d4810		LEAQ 0x10(AX), CX	
	b.next = start
  0x41e476		488908			MOVQ CX, 0(AX)		
	if gcBlackenPromptly || writeBarrier.cgo {
  0x41e479		0fb61527540a00		MOVZX runtime.gcBlackenPromptly(SB), DX	
  0x41e480		84d2			TESTL DL, DL				
  0x41e482		7422			JE 0x41e4a6				
		b.end = uintptr(unsafe.Pointer(&b.buf[wbBufEntryPointers]))
  0x41e484		488d4820		LEAQ 0x20(AX), CX	
  0x41e488		48894808		MOVQ CX, 0x8(AX)	
	if (b.end-b.next)%(wbBufEntryPointers*unsafe.Sizeof(b.buf[0])) != 0 {
  0x41e48c		488b4808		MOVQ 0x8(AX), CX	
  0x41e490		482b08			SUBQ 0(AX), CX		
  0x41e493		48f7c10f000000		TESTQ $0xf, CX		
  0x41e49a		7522			JNE 0x41e4be		
  0x41e49c		488b6c2410		MOVQ 0x10(SP), BP	
  0x41e4a1		4883c418		ADDQ $0x18, SP		
  0x41e4a5		c3			RET			
	if gcBlackenPromptly || writeBarrier.cgo {
  0x41e4a6		0fb61568550a00		MOVZX runtime.writeBarrier+5(SB), DX	
  0x41e4ad		84d2			TESTL DL, DL				
  0x41e4af		75d3			JNE 0x41e484				
		b.end = start + uintptr(len(b.buf))*unsafe.Sizeof(b.buf[0])
  0x41e4b1		4881c100100000		ADDQ $0x1000, CX	
  0x41e4b8		48894808		MOVQ CX, 0x8(AX)	
	if (b.end-b.next)%(wbBufEntryPointers*unsafe.Sizeof(b.buf[0])) != 0 {
  0x41e4bc		ebce			JMP 0x41e48c		
		throw("bad write barrier buffer bounds")
  0x41e4be		488d056ae10400		LEAQ 0x4e16a(IP), AX	
  0x41e4c5		48890424		MOVQ AX, 0(SP)		
  0x41e4c9		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x41e4d2		e8f92c0000		CALL runtime.throw(SB)	
  0x41e4d7		0f0b			UD2			
func (b *wbBuf) reset() {
  0x41e4d9		e892600200		CALL runtime.morestack_noctxt(SB)	
  0x41e4de		e96dffffff		JMP runtime.(*wbBuf).reset(SB)		

TEXT runtime.wbBufFlush(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mwbbuf.go
func wbBufFlush(dst *uintptr, src uintptr) {
  0x41e4f0		4883ec18		SUBQ $0x18, SP		
  0x41e4f4		48896c2410		MOVQ BP, 0x10(SP)	
  0x41e4f9		488d6c2410		LEAQ 0x10(SP), BP	
	if getg().m.dying > 0 {
  0x41e4fe		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41e507		488b4030		MOVQ 0x30(AX), AX	
  0x41e50b		8b8808010000		MOVL 0x108(AX), CX	
  0x41e511		85c9			TESTL CX, CX		
  0x41e513		0f8f84000000		JG 0x41e59d		
	if writeBarrier.cgo && dst != nil {
  0x41e519		0fb605f5540a00		MOVZX runtime.writeBarrier+5(SB), AX	
  0x41e520		84c0			TESTL AL, AL				
  0x41e522		740a			JE 0x41e52e				
  0x41e524		488b442420		MOVQ 0x20(SP), AX			
  0x41e529		4885c0			TESTQ AX, AX				
  0x41e52c		751a			JNE 0x41e548				
	systemstack(func() {
  0x41e52e		488d050bfd0400		LEAQ 0x4fd0b(IP), AX		
  0x41e535		48890424		MOVQ AX, 0(SP)			
  0x41e539		e8e25e0200		CALL runtime.systemstack(SB)	
}
  0x41e53e		488b6c2410		MOVQ 0x10(SP), BP	
  0x41e543		4883c418		ADDQ $0x18, SP		
  0x41e547		c3			RET			
		cgoCheckWriteBarrier(dst, src)
  0x41e548		48890424		MOVQ AX, 0(SP)				
  0x41e54c		488b442428		MOVQ 0x28(SP), AX			
  0x41e551		4889442408		MOVQ AX, 0x8(SP)			
  0x41e556		e8e53ffeff		CALL runtime.cgoCheckWriteBarrier(SB)	
		if !writeBarrier.needed {
  0x41e55b		0fb605b2540a00		MOVZX runtime.writeBarrier+4(SB), AX	
  0x41e562		84c0			TESTL AL, AL				
  0x41e564		75c8			JNE 0x41e52e				
			getg().m.p.ptr().wbBuf.discard()
  0x41e566		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41e56f		488b4030		MOVQ 0x30(AX), AX	
  0x41e573		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x41e57a		8400			TESTB AL, 0(AX)		
  0x41e57c		488d8890120000		LEAQ 0x1290(AX), CX	
	b.next = uintptr(unsafe.Pointer(&b.buf[0]))
  0x41e583		8401			TESTB AL, 0(CX)		
  0x41e585		488d88a0120000		LEAQ 0x12a0(AX), CX	
  0x41e58c		48898890120000		MOVQ CX, 0x1290(AX)	
			return
  0x41e593		488b6c2410		MOVQ 0x10(SP), BP	
  0x41e598		4883c418		ADDQ $0x18, SP		
  0x41e59c		c3			RET			
		getg().m.p.ptr().wbBuf.discard()
  0x41e59d		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x41e5a4		8400			TESTB AL, 0(AX)		
  0x41e5a6		488d8890120000		LEAQ 0x1290(AX), CX	
	b.next = uintptr(unsafe.Pointer(&b.buf[0]))
  0x41e5ad		8401			TESTB AL, 0(CX)		
  0x41e5af		488d88a0120000		LEAQ 0x12a0(AX), CX	
  0x41e5b6		48898890120000		MOVQ CX, 0x1290(AX)	
		return
  0x41e5bd		488b6c2410		MOVQ 0x10(SP), BP	
  0x41e5c2		4883c418		ADDQ $0x18, SP		
  0x41e5c6		c3			RET			

TEXT runtime.wbBufFlush1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mwbbuf.go
func wbBufFlush1(_p_ *p) {
  0x41e5d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e5d9		483b6118		CMPQ 0x18(CX), SP	
  0x41e5dd		0f8691020000		JBE 0x41e874		
  0x41e5e3		4883ec78		SUBQ $0x78, SP		
  0x41e5e7		48896c2470		MOVQ BP, 0x70(SP)	
  0x41e5ec		488d6c2470		LEAQ 0x70(SP), BP	
  0x41e5f1		488b842480000000	MOVQ 0x80(SP), AX	
	start := uintptr(unsafe.Pointer(&_p_.wbBuf.buf[0]))
  0x41e5f9		8400			TESTB AL, 0(AX)		
	ptrs := _p_.wbBuf.buf[:n]
  0x41e5fb		488d88a0120000		LEAQ 0x12a0(AX), CX	
  0x41e602		8401			TESTB AL, 0(CX)		
	start := uintptr(unsafe.Pointer(&_p_.wbBuf.buf[0]))
  0x41e604		488d90a0120000		LEAQ 0x12a0(AX), DX	
	n := (_p_.wbBuf.next - start) / unsafe.Sizeof(_p_.wbBuf.buf[0])
  0x41e60b		488b9890120000		MOVQ 0x1290(AX), BX	
  0x41e612		4829d3			SUBQ DX, BX		
  0x41e615		48c1eb03		SHRQ $0x3, BX		
	ptrs := _p_.wbBuf.buf[:n]
  0x41e619		4881fb00020000		CMPQ $0x200, BX		
  0x41e620		0f8747020000		JA 0x41e86d		
  0x41e626		48894c2468		MOVQ CX, 0x68(SP)	
  0x41e62b		48895c2458		MOVQ BX, 0x58(SP)	
	_p_.wbBuf.reset()
  0x41e630		488d8890120000		LEAQ 0x1290(AX), CX		
  0x41e637		48890c24		MOVQ CX, 0(SP)			
  0x41e63b		e810feffff		CALL runtime.(*wbBuf).reset(SB)	
	if useCheckmark {
  0x41e640		0fb60578520a00		MOVZX runtime.useCheckmark(SB), AX	
  0x41e647		84c0			TESTL AL, AL				
  0x41e649		0f85d2010000		JNE 0x41e821				
  0x41e64f		488b842480000000	MOVQ 0x80(SP), AX			
	gcw := &_p_.gcw
  0x41e657		488d8870120000		LEAQ 0x1270(AX), CX	
  0x41e65e		48894c2460		MOVQ CX, 0x60(SP)	
	arenaStart := mheap_.arena_start
  0x41e663		488b155eef0800		MOVQ runtime.mheap_+4904(SB), DX	
  0x41e66a		4889542448		MOVQ DX, 0x48(SP)			
  0x41e66f		31db			XORL BX, BX				
  0x41e671		31f6			XORL SI, SI				
	for _, ptr := range ptrs {
  0x41e673		eb03			JMP 0x41e678			
  0x41e675		48ffc3			INCQ BX				
  0x41e678		488b7c2458		MOVQ 0x58(SP), DI		
  0x41e67d		4839fb			CMPQ DI, BX			
  0x41e680		0f8d3d010000		JGE 0x41e7c3			
  0x41e686		4c8b84d8a0120000	MOVQ 0x12a0(AX)(BX*8), R8	
		if ptr < arenaStart {
  0x41e68e		4939d0			CMPQ DX, R8		
  0x41e691		72e2			JB 0x41e675		
  0x41e693		48895c2450		MOVQ BX, 0x50(SP)	
  0x41e698		4889742440		MOVQ SI, 0x40(SP)	
		obj, _, span, objIndex := heapBitsForObject(ptr, 0, 0)
  0x41e69d		4c890424		MOVQ R8, 0(SP)				
  0x41e6a1		0f57c0			XORPS X0, X0				
  0x41e6a4		0f11442408		MOVUPS X0, 0x8(SP)			
  0x41e6a9		e8f2dbfeff		CALL runtime.heapBitsForObject(SB)	
  0x41e6ae		488b442418		MOVQ 0x18(SP), AX			
  0x41e6b3		488b4c2430		MOVQ 0x30(SP), CX			
  0x41e6b8		488b542438		MOVQ 0x38(SP), DX			
		if obj == 0 {
  0x41e6bd		4885c0			TESTQ AX, AX		
  0x41e6c0		7523			JNE 0x41e6e5		
  0x41e6c2		488b842480000000	MOVQ 0x80(SP), AX	
  0x41e6ca		488b4c2460		MOVQ 0x60(SP), CX	
  0x41e6cf		488b542448		MOVQ 0x48(SP), DX	
  0x41e6d4		488b5c2450		MOVQ 0x50(SP), BX	
  0x41e6d9		488b7c2458		MOVQ 0x58(SP), DI	
  0x41e6de		488b742440		MOVQ 0x40(SP), SI	
			continue
  0x41e6e3		eb90			JMP 0x41e675		
	bytep, mask := s.gcmarkBits.bitp(objIndex)
  0x41e6e5		488b5950		MOVQ 0x50(CX), BX	
  0x41e6e9		4889d6			MOVQ DX, SI		
	return b.bytep(n / 8), 1 << (n % 8)
  0x41e6ec		48c1ea03		SHRQ $0x3, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x41e6f0		488d3c13		LEAQ 0(BX)(DX*1), DI	
	return *m.bytep&m.mask != 0
  0x41e6f4		8407			TESTB AL, 0(DI)		
	return b.bytep(n / 8), 1 << (n % 8)
  0x41e6f6		4883e607		ANDQ $0x7, SI		
  0x41e6fa		4989c8			MOVQ CX, R8		
  0x41e6fd		4889f1			MOVQ SI, CX		
  0x41e700		41b901000000		MOVL $0x1, R9		
  0x41e706		41d3e1			SHLL CL, R9		
	return *m.bytep&m.mask != 0
  0x41e709		0fb61413		MOVZX 0(BX)(DX*1), DX	
  0x41e70d		4184d1			TESTL DL, R9		
		if mbits.isMarked() {
  0x41e710		7426			JE 0x41e738		
  0x41e712		488b842480000000	MOVQ 0x80(SP), AX	
  0x41e71a		488b4c2460		MOVQ 0x60(SP), CX	
  0x41e71f		488b542448		MOVQ 0x48(SP), DX	
  0x41e724		488b5c2450		MOVQ 0x50(SP), BX	
  0x41e729		488b7c2458		MOVQ 0x58(SP), DI	
  0x41e72e		488b742440		MOVQ 0x40(SP), SI	
			continue
  0x41e733		e93dffffff		JMP 0x41e675		
	atomic.Or8(m.bytep, m.mask)
  0x41e738		f044080f		LOCK ORB R9, 0(DI)	
		if span.spanclass.noscan() {
  0x41e73c		410fb64862		MOVZX 0x62(R8), CX	
	return sc&1 != 0
  0x41e741		f6c101			TESTL $0x1, CL		
		if span.spanclass.noscan() {
  0x41e744		743a			JE 0x41e780		
  0x41e746		488b4c2460		MOVQ 0x60(SP), CX	
			gcw.bytesMarked += uint64(span.elemsize)
  0x41e74b		8401			TESTB AL, 0(CX)		
  0x41e74d		488b842480000000	MOVQ 0x80(SP), AX	
  0x41e755		4c8b8880120000		MOVQ 0x1280(AX), R9	
  0x41e75c		4d034868		ADDQ 0x68(R8), R9	
  0x41e760		4c898880120000		MOVQ R9, 0x1280(AX)	
  0x41e767		488b542448		MOVQ 0x48(SP), DX	
  0x41e76c		488b5c2450		MOVQ 0x50(SP), BX	
  0x41e771		488b7c2458		MOVQ 0x58(SP), DI	
  0x41e776		488b742440		MOVQ 0x40(SP), SI	
			continue
  0x41e77b		e9f5feffff		JMP 0x41e675		
  0x41e780		488b4c2440		MOVQ 0x40(SP), CX	
  0x41e785		488b542458		MOVQ 0x58(SP), DX	
		ptrs[pos] = obj
  0x41e78a		4839d1			CMPQ DX, CX			
  0x41e78d		0f83d3000000		JAE 0x41e866			
  0x41e793		4c8b842480000000	MOVQ 0x80(SP), R8		
  0x41e79b		498984c8a0120000	MOVQ AX, 0x12a0(R8)(CX*8)	
		pos++
  0x41e7a3		488d7101		LEAQ 0x1(CX), SI	
  0x41e7a7		4c89c0			MOVQ R8, AX		
  0x41e7aa		488b4c2460		MOVQ 0x60(SP), CX	
  0x41e7af		488b542448		MOVQ 0x48(SP), DX	
  0x41e7b4		488b5c2450		MOVQ 0x50(SP), BX	
  0x41e7b9		488b7c2458		MOVQ 0x58(SP), DI	
  0x41e7be		e9b2feffff		JMP 0x41e675		
	gcw.putBatch(ptrs[:pos])
  0x41e7c3		4881fe00020000		CMPQ $0x200, SI				
  0x41e7ca		0f878f000000		JA 0x41e85f				
  0x41e7d0		48890c24		MOVQ CX, 0(SP)				
  0x41e7d4		488b442468		MOVQ 0x68(SP), AX			
  0x41e7d9		4889442408		MOVQ AX, 0x8(SP)			
  0x41e7de		4889742410		MOVQ SI, 0x10(SP)			
  0x41e7e3		48c744241800020000	MOVQ $0x200, 0x18(SP)			
  0x41e7ec		e8bfa6ffff		CALL runtime.(*gcWork).putBatch(SB)	
	if gcphase == _GCmarktermination || gcBlackenPromptly {
  0x41e7f1		8b05e5500a00		MOVL runtime.gcphase(SB), AX	
  0x41e7f7		83f802			CMPL $0x2, AX			
  0x41e7fa		7518			JNE 0x41e814			
  0x41e7fc		488b442460		MOVQ 0x60(SP), AX		
		gcw.dispose()
  0x41e801		48890424		MOVQ AX, 0(SP)				
  0x41e805		e876aaffff		CALL runtime.(*gcWork).dispose(SB)	
  0x41e80a		488b6c2470		MOVQ 0x70(SP), BP			
  0x41e80f		4883c478		ADDQ $0x78, SP				
  0x41e813		c3			RET					
	if gcphase == _GCmarktermination || gcBlackenPromptly {
  0x41e814		0fb6058c500a00		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x41e81b		84c0			TESTL AL, AL				
  0x41e81d		75dd			JNE 0x41e7fc				
  0x41e81f		ebe9			JMP 0x41e80a				
  0x41e821		31c0			XORL AX, AX				
		for _, ptr := range ptrs {
  0x41e823		eb26			JMP 0x41e84b			
  0x41e825		4889442450		MOVQ AX, 0x50(SP)		
  0x41e82a		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x41e832		488b94c1a0120000	MOVQ 0x12a0(CX)(AX*8), DX	
			shade(ptr)
  0x41e83a		48891424		MOVQ DX, 0(SP)		
  0x41e83e		e81d82ffff		CALL runtime.shade(SB)	
  0x41e843		488b442450		MOVQ 0x50(SP), AX	
		for _, ptr := range ptrs {
  0x41e848		48ffc0			INCQ AX			
  0x41e84b		488b4c2458		MOVQ 0x58(SP), CX	
  0x41e850		4839c8			CMPQ CX, AX		
  0x41e853		7cd0			JL 0x41e825		
		return
  0x41e855		488b6c2470		MOVQ 0x70(SP), BP	
  0x41e85a		4883c478		ADDQ $0x78, SP		
  0x41e85e		c3			RET			
	gcw.putBatch(ptrs[:pos])
  0x41e85f		e84c120000		CALL runtime.panicslice(SB)	
  0x41e864		0f0b			UD2				
		ptrs[pos] = obj
  0x41e866		e8d5110000		CALL runtime.panicindex(SB)	
  0x41e86b		0f0b			UD2				
	ptrs := _p_.wbBuf.buf[:n]
  0x41e86d		e83e120000		CALL runtime.panicslice(SB)	
  0x41e872		0f0b			UD2				
func wbBufFlush1(_p_ *p) {
  0x41e874		e887840100		CALL runtime.morestackc(SB)	
  0x41e879		e952fdffff		JMP runtime.wbBufFlush1(SB)	

TEXT runtime.netpollready(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/netpoll.go
func netpollready(gpp *guintptr, pd *pollDesc, mode int32) {
  0x41e880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e889		483b6110		CMPQ 0x10(CX), SP	
  0x41e88d		0f86e7000000		JBE 0x41e97a		
  0x41e893		4883ec30		SUBQ $0x30, SP		
  0x41e897		48896c2428		MOVQ BP, 0x28(SP)	
  0x41e89c		488d6c2428		LEAQ 0x28(SP), BP	
	var rg, wg guintptr
  0x41e8a1		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x41e8aa		48c744241800000000	MOVQ $0x0, 0x18(SP)	
func netpollready(gpp *guintptr, pd *pollDesc, mode int32) {
  0x41e8b3		8b442448		MOVL 0x48(SP), AX	
	if mode == 'r' || mode == 'r'+'w' {
  0x41e8b7		83f872			CMPL $0x72, AX		
  0x41e8ba		0f85aa000000		JNE 0x41e96a		
  0x41e8c0		488b442440		MOVQ 0x40(SP), AX	
		rg.set(netpollunblock(pd, 'r', true))
  0x41e8c5		48890424		MOVQ AX, 0(SP)			
  0x41e8c9		c744240872000000	MOVL $0x72, 0x8(SP)		
  0x41e8d1		c644240c01		MOVB $0x1, 0xc(SP)		
  0x41e8d6		e8b5000000		CALL runtime.netpollunblock(SB)	
  0x41e8db		488b442410		MOVQ 0x10(SP), AX		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41e8e0		4889442420		MOVQ AX, 0x20(SP)	
	if mode == 'w' || mode == 'r'+'w' {
  0x41e8e5		8b442448		MOVL 0x48(SP), AX	
  0x41e8e9		83f877			CMPL $0x77, AX		
  0x41e8ec		7573			JNE 0x41e961		
  0x41e8ee		488b442440		MOVQ 0x40(SP), AX	
		wg.set(netpollunblock(pd, 'w', true))
  0x41e8f3		48890424		MOVQ AX, 0(SP)			
  0x41e8f7		c744240877000000	MOVL $0x77, 0x8(SP)		
  0x41e8ff		c644240c01		MOVB $0x1, 0xc(SP)		
  0x41e904		e887000000		CALL runtime.netpollunblock(SB)	
  0x41e909		488b442410		MOVQ 0x10(SP), AX		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41e90e		4889442418		MOVQ AX, 0x18(SP)	
	if rg != 0 {
  0x41e913		488b442420		MOVQ 0x20(SP), AX	
  0x41e918		4885c0			TESTQ AX, AX		
  0x41e91b		743d			JE 0x41e95a		
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x41e91d		488b4c2438		MOVQ 0x38(SP), CX	
		rg.ptr().schedlink = *gpp
  0x41e922		488b11			MOVQ 0(CX), DX		
  0x41e925		488990b8000000		MOVQ DX, 0xb8(AX)	
		*gpp = rg
  0x41e92c		488b442420		MOVQ 0x20(SP), AX	
  0x41e931		488901			MOVQ AX, 0(CX)		
	if wg != 0 {
  0x41e934		488b442418		MOVQ 0x18(SP), AX	
  0x41e939		4885c0			TESTQ AX, AX		
  0x41e93c		7412			JE 0x41e950		
		wg.ptr().schedlink = *gpp
  0x41e93e		488b11			MOVQ 0(CX), DX		
  0x41e941		488990b8000000		MOVQ DX, 0xb8(AX)	
		*gpp = wg
  0x41e948		488b442418		MOVQ 0x18(SP), AX	
  0x41e94d		488901			MOVQ AX, 0(CX)		
  0x41e950		488b6c2428		MOVQ 0x28(SP), BP	
  0x41e955		4883c430		ADDQ $0x30, SP		
  0x41e959		c3			RET			
  0x41e95a		488b4c2438		MOVQ 0x38(SP), CX	
	if rg != 0 {
  0x41e95f		ebd3			JMP 0x41e934		
	if mode == 'w' || mode == 'r'+'w' {
  0x41e961		3de9000000		CMPL $0xe9, AX		
  0x41e966		7486			JE 0x41e8ee		
  0x41e968		eba9			JMP 0x41e913		
	if mode == 'r' || mode == 'r'+'w' {
  0x41e96a		3de9000000		CMPL $0xe9, AX		
  0x41e96f		0f844bffffff		JE 0x41e8c0		
  0x41e975		e96bffffff		JMP 0x41e8e5		
func netpollready(gpp *guintptr, pd *pollDesc, mode int32) {
  0x41e97a		e8f15b0200		CALL runtime.morestack_noctxt(SB)	
  0x41e97f		e9fcfeffff		JMP runtime.netpollready(SB)		

TEXT runtime.netpollunblock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/netpoll.go
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
  0x41e990		4883ec10		SUBQ $0x10, SP		
  0x41e994		48896c2408		MOVQ BP, 0x8(SP)	
  0x41e999		488d6c2408		LEAQ 0x8(SP), BP	
  0x41e99e		488b4c2418		MOVQ 0x18(SP), CX	
	gpp := &pd.rg
  0x41e9a3		8401			TESTB AL, 0(CX)		
  0x41e9a5		488d5128		LEAQ 0x28(CX), DX	
  0x41e9a9		8b5c2420		MOVL 0x20(SP), BX	
	if mode == 'w' {
  0x41e9ad		83fb77			CMPL $0x77, BX		
  0x41e9b0		756f			JNE 0x41ea21		
		gpp = &pd.wg
  0x41e9b2		4883c178		ADDQ $0x78, CX		
  0x41e9b6		0fb6542424		MOVZX 0x24(SP), DX	
		old := *gpp
  0x41e9bb		488b01			MOVQ 0(CX), AX		
		if old == pdReady {
  0x41e9be		4883f801		CMPQ $0x1, AX		
  0x41e9c2		744a			JE 0x41ea0e		
		if old == 0 && !ioready {
  0x41e9c4		4885c0			TESTQ AX, AX		
  0x41e9c7		7504			JNE 0x41e9cd		
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
  0x41e9c9		84d2			TESTL DL, DL		
		if old == 0 && !ioready {
  0x41e9cb		742e			JE 0x41e9fb		
  0x41e9cd		48890424		MOVQ AX, 0(SP)		
		if atomic.Casuintptr(gpp, old, new) {
  0x41e9d1		0fb6da			MOVZX DL, BX		
  0x41e9d4		f0480fb119		LOCK CMPXCHGQ BX, 0(CX)	
  0x41e9d9		0f94c3			SETE BL			
  0x41e9dc		84db			TESTL BL, BL		
  0x41e9de		74db			JE 0x41e9bb		
  0x41e9e0		488b0424		MOVQ 0(SP), AX		
			if old == pdReady || old == pdWait {
  0x41e9e4		4883f802		CMPQ $0x2, AX		
  0x41e9e8		7502			JNE 0x41e9ec		
  0x41e9ea		31c0			XORL AX, AX		
			return (*g)(unsafe.Pointer(old))
  0x41e9ec		4889442428		MOVQ AX, 0x28(SP)	
  0x41e9f1		488b6c2408		MOVQ 0x8(SP), BP	
  0x41e9f6		4883c410		ADDQ $0x10, SP		
  0x41e9fa		c3			RET			
			return nil
  0x41e9fb		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x41ea04		488b6c2408		MOVQ 0x8(SP), BP	
  0x41ea09		4883c410		ADDQ $0x10, SP		
  0x41ea0d		c3			RET			
			return nil
  0x41ea0e		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x41ea17		488b6c2408		MOVQ 0x8(SP), BP	
  0x41ea1c		4883c410		ADDQ $0x10, SP		
  0x41ea20		c3			RET			
  0x41ea21		4889d1			MOVQ DX, CX		
	if mode == 'w' {
  0x41ea24		eb90			JMP 0x41e9b6		

TEXT runtime.netpoll(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/netpoll_epoll.go
func netpoll(block bool) *g {
  0x41ea30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ea39		488d842440faffff	LEAQ 0xfffffa40(SP), AX	
  0x41ea41		483b4110		CMPQ 0x10(CX), AX	
  0x41ea45		0f86fd010000		JBE 0x41ec48		
  0x41ea4b		4881ec40060000		SUBQ $0x640, SP		
  0x41ea52		4889ac2438060000	MOVQ BP, 0x638(SP)	
  0x41ea5a		488dac2438060000	LEAQ 0x638(SP), BP	
	if epfd == -1 {
  0x41ea62		8b159c650800		MOVL runtime.epfd(SB), DX	
  0x41ea68		83faff			CMPL $-0x1, DX			
  0x41ea6b		0f8436010000		JE 0x41eba7			
  0x41ea71		0fb6942448060000	MOVZX 0x648(SP), DX		
func netpoll(block bool) *g {
  0x41ea79		84d2			TESTL DL, DL		
	if !block {
  0x41ea7b		0f841f010000		JE 0x41eba0		
  0x41ea81		b8ffffffff		MOVL $-0x1, AX		
  0x41ea86		89442424		MOVL AX, 0x24(SP)	
	var events [128]epollevent
  0x41ea8a		488d7c2438		LEAQ 0x38(SP), DI	
  0x41ea8f		b9c0000000		MOVL $0xc0, CX		
  0x41ea94		89c3			MOVL AX, BX		
  0x41ea96		31c0			XORL AX, AX		
  0x41ea98		f348ab			REP; STOSQ AX, ES:0(DI)	
retry:
  0x41ea9b		e998000000		JMP 0x41eb38		
	for i := int32(0); i < n; i++ {
  0x41eaa0		ffc1			INCL CX			
  0x41eaa2		39c1			CMPL AX, CX		
  0x41eaa4		7d78			JGE 0x41eb1e		
		ev := &events[i]
  0x41eaa6		4863d1			MOVSXD CX, DX		
  0x41eaa9		4881fa80000000		CMPQ $0x80, DX		
  0x41eab0		0f830d010000		JAE 0x41ebc3		
  0x41eab6		488d1452		LEAQ 0(DX)(DX*2), DX	
  0x41eaba		4889d3			MOVQ DX, BX		
  0x41eabd		48c1e202		SHLQ $0x2, DX		
		if ev.events == 0 {
  0x41eac1		8b749c38		MOVL 0x38(SP)(BX*4), SI	
  0x41eac5		85f6			TESTL SI, SI		
  0x41eac7		74d7			JE 0x41eaa0		
		if ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
  0x41eac9		f7c619200000		TESTL $0x2019, SI	
  0x41eacf		7449			JE 0x41eb1a		
  0x41ead1		bf72000000		MOVL $0x72, DI		
		if ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
  0x41ead6		f7c61c000000		TESTL $0x1c, SI		
  0x41eadc		7438			JE 0x41eb16		
			mode += 'w'
  0x41eade		8d7777			LEAL 0x77(DI), SI	
		if mode != 0 {
  0x41eae1		85f6			TESTL SI, SI		
  0x41eae3		74bb			JE 0x41eaa0		
  0x41eae5		894c242c		MOVL CX, 0x2c(SP)	
			pd := *(**pollDesc)(unsafe.Pointer(&ev.data))
  0x41eae9		488d449c3c		LEAQ 0x3c(SP)(BX*4), AX	
  0x41eaee		8400			TESTB AL, 0(AX)		
  0x41eaf0		488b44143c		MOVQ 0x3c(SP)(DX*1), AX	
			netpollready(&gp, pd, mode)
  0x41eaf5		488d4c2430		LEAQ 0x30(SP), CX		
  0x41eafa		48890c24		MOVQ CX, 0(SP)			
  0x41eafe		4889442408		MOVQ AX, 0x8(SP)		
  0x41eb03		89742410		MOVL SI, 0x10(SP)		
  0x41eb07		e874fdffff		CALL runtime.netpollready(SB)	
  0x41eb0c		8b442428		MOVL 0x28(SP), AX		
  0x41eb10		8b4c242c		MOVL 0x2c(SP), CX		
  0x41eb14		eb8a			JMP 0x41eaa0			
  0x41eb16		89fe			MOVL DI, SI			
		if ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
  0x41eb18		ebc7			JMP 0x41eae1		
  0x41eb1a		31ff			XORL DI, DI		
		if ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
  0x41eb1c		ebb8			JMP 0x41ead6		
  0x41eb1e		0fb6842448060000	MOVZX 0x648(SP), AX	
func netpoll(block bool) *g {
  0x41eb26		84c0			TESTL AL, AL		
	if block && gp == 0 {
  0x41eb28		7459			JE 0x41eb83		
  0x41eb2a		488b4c2430		MOVQ 0x30(SP), CX	
  0x41eb2f		4885c9			TESTQ CX, CX		
  0x41eb32		754f			JNE 0x41eb83		
  0x41eb34		8b5c2424		MOVL 0x24(SP), BX	
	n := epollwait(epfd, &events[0], int32(len(events)), waitms)
  0x41eb38		488d442438		LEAQ 0x38(SP), AX		
  0x41eb3d		4889442408		MOVQ AX, 0x8(SP)		
  0x41eb42		8b05bc640800		MOVL runtime.epfd(SB), AX	
  0x41eb48		890424			MOVL AX, 0(SP)			
  0x41eb4b		c744241080000000	MOVL $0x80, 0x10(SP)		
  0x41eb53		895c2414		MOVL BX, 0x14(SP)		
  0x41eb57		e824940200		CALL runtime.epollwait(SB)	
  0x41eb5c		8b442418		MOVL 0x18(SP), AX		
  0x41eb60		89442428		MOVL AX, 0x28(SP)		
	if n < 0 {
  0x41eb64		85c0			TESTL AX, AX		
  0x41eb66		7d0b			JGE 0x41eb73		
		if n != -_EINTR {
  0x41eb68		83f8fc			CMPL $-0x4, AX		
  0x41eb6b		755d			JNE 0x41ebca		
  0x41eb6d		8b5c2424		MOVL 0x24(SP), BX	
		goto retry
  0x41eb71		ebc5			JMP 0x41eb38		
	var gp guintptr
  0x41eb73		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x41eb7c		31c9			XORL CX, CX		
	for i := int32(0); i < n; i++ {
  0x41eb7e		e91fffffff		JMP 0x41eaa2		
	return gp.ptr()
  0x41eb83		488b442430		MOVQ 0x30(SP), AX	
  0x41eb88		4889842450060000	MOVQ AX, 0x650(SP)	
  0x41eb90		488bac2438060000	MOVQ 0x638(SP), BP	
  0x41eb98		4881c440060000		ADDQ $0x640, SP		
  0x41eb9f		c3			RET			
  0x41eba0		31c0			XORL AX, AX		
	var events [128]epollevent
  0x41eba2		e9dffeffff		JMP 0x41ea86		
		return nil
  0x41eba7		48c784245006000000000000	MOVQ $0x0, 0x650(SP)	
  0x41ebb3		488bac2438060000		MOVQ 0x638(SP), BP	
  0x41ebbb		4881c440060000			ADDQ $0x640, SP		
  0x41ebc2		c3				RET			
		ev := &events[i]
  0x41ebc3		e8780e0000		CALL runtime.panicindex(SB)	
  0x41ebc8		0f0b			UD2				
			println("runtime: epollwait on fd", epfd, "failed with", -n)
  0x41ebca		e8312f0000		CALL runtime.printlock(SB)	
  0x41ebcf		488d05eece0400		LEAQ 0x4ceee(IP), AX		
  0x41ebd6		48890424		MOVQ AX, 0(SP)			
  0x41ebda		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x41ebe3		e858380000		CALL runtime.printstring(SB)	
  0x41ebe8		48630515640800		MOVSXD runtime.epfd(SB), AX	
  0x41ebef		48890424		MOVQ AX, 0(SP)			
  0x41ebf3		e888360000		CALL runtime.printint(SB)	
  0x41ebf8		488d0572ba0400		LEAQ 0x4ba72(IP), AX		
  0x41ebff		48890424		MOVQ AX, 0(SP)			
  0x41ec03		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x41ec0c		e82f380000		CALL runtime.printstring(SB)	
  0x41ec11		8b442428		MOVL 0x28(SP), AX		
  0x41ec15		f7d8			NEGL AX				
  0x41ec17		4863c0			MOVSXD AX, AX			
  0x41ec1a		48890424		MOVQ AX, 0(SP)			
  0x41ec1e		e85d360000		CALL runtime.printint(SB)	
  0x41ec23		e868310000		CALL runtime.printnl(SB)	
  0x41ec28		e8532f0000		CALL runtime.printunlock(SB)	
			throw("runtime: netpoll failed")
  0x41ec2d		488d0543cb0400		LEAQ 0x4cb43(IP), AX	
  0x41ec34		48890424		MOVQ AX, 0(SP)		
  0x41ec38		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x41ec41		e88a250000		CALL runtime.throw(SB)	
  0x41ec46		0f0b			UD2			
func netpoll(block bool) *g {
  0x41ec48		e823590200		CALL runtime.morestack_noctxt(SB)	
  0x41ec4d		e9defdffff		JMP runtime.netpoll(SB)			

TEXT runtime.futexsleep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func futexsleep(addr *uint32, val uint32, ns int64) {
  0x41ec60		4883ec48		SUBQ $0x48, SP		
  0x41ec64		48896c2440		MOVQ BP, 0x40(SP)	
  0x41ec69		488d6c2440		LEAQ 0x40(SP), BP	
	var ts timespec
  0x41ec6e		0f57c0			XORPS X0, X0		
  0x41ec71		0f11442430		MOVUPS X0, 0x30(SP)	
func futexsleep(addr *uint32, val uint32, ns int64) {
  0x41ec76		488b4c2460		MOVQ 0x60(SP), CX	
	if ns < 0 {
  0x41ec7b		4885c9			TESTQ CX, CX		
  0x41ec7e		7d35			JGE 0x41ecb5		
  0x41ec80		488b442450		MOVQ 0x50(SP), AX	
		futex(unsafe.Pointer(addr), _FUTEX_WAIT, val, nil, nil, 0)
  0x41ec85		48890424		MOVQ AX, 0(SP)		
  0x41ec89		c744240800000000	MOVL $0x0, 0x8(SP)	
  0x41ec91		8b442458		MOVL 0x58(SP), AX	
  0x41ec95		8944240c		MOVL AX, 0xc(SP)	
  0x41ec99		0f11442410		MOVUPS X0, 0x10(SP)	
  0x41ec9e		c744242000000000	MOVL $0x0, 0x20(SP)	
  0x41eca6		e865910200		CALL runtime.futex(SB)	
		return
  0x41ecab		488b6c2440		MOVQ 0x40(SP), BP	
  0x41ecb0		4883c448		ADDQ $0x48, SP		
  0x41ecb4		c3			RET			
		ts.set_sec(ns / 1000000000)
  0x41ecb5		48b8cc525a9ba02fb844	MOVQ $0x44b82fa09b5a52cc, AX	
  0x41ecbf		48f7e9			IMULQ CX			
  0x41ecc2		4889cb			MOVQ CX, BX			
  0x41ecc5		48c1f93f		SARQ $0x3f, CX			
  0x41ecc9		48c1fa1c		SARQ $0x1c, DX			
  0x41eccd		4829ca			SUBQ CX, DX			
	ts.tv_sec = x
  0x41ecd0		4889542430		MOVQ DX, 0x30(SP)	
		ts.set_nsec(int32(ns % 1000000000))
  0x41ecd5		4869d200ca9a3b		IMULQ $0x3b9aca00, DX, DX	
  0x41ecdc		4829d3			SUBQ DX, BX			
	ts.tv_nsec = int64(x)
  0x41ecdf		4863cb			MOVSXD BX, CX		
  0x41ece2		48894c2438		MOVQ CX, 0x38(SP)	
  0x41ece7		488b4c2450		MOVQ 0x50(SP), CX	
	futex(unsafe.Pointer(addr), _FUTEX_WAIT, val, unsafe.Pointer(&ts), nil, 0)
  0x41ecec		48890c24		MOVQ CX, 0(SP)		
  0x41ecf0		c744240800000000	MOVL $0x0, 0x8(SP)	
  0x41ecf8		8b4c2458		MOVL 0x58(SP), CX	
  0x41ecfc		894c240c		MOVL CX, 0xc(SP)	
  0x41ed00		488d4c2430		LEAQ 0x30(SP), CX	
  0x41ed05		48894c2410		MOVQ CX, 0x10(SP)	
  0x41ed0a		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x41ed13		c744242000000000	MOVL $0x0, 0x20(SP)	
  0x41ed1b		e8f0900200		CALL runtime.futex(SB)	
}
  0x41ed20		488b6c2440		MOVQ 0x40(SP), BP	
  0x41ed25		4883c448		ADDQ $0x48, SP		
  0x41ed29		c3			RET			

TEXT runtime.futexwakeup(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func futexwakeup(addr *uint32, cnt uint32) {
  0x41ed30		4883ec50		SUBQ $0x50, SP		
  0x41ed34		48896c2448		MOVQ BP, 0x48(SP)	
  0x41ed39		488d6c2448		LEAQ 0x48(SP), BP	
  0x41ed3e		488b442458		MOVQ 0x58(SP), AX	
	ret := futex(unsafe.Pointer(addr), _FUTEX_WAKE, cnt, nil, nil, 0)
  0x41ed43		48890424		MOVQ AX, 0(SP)		
  0x41ed47		c744240801000000	MOVL $0x1, 0x8(SP)	
func futexwakeup(addr *uint32, cnt uint32) {
  0x41ed4f		8b4c2460		MOVL 0x60(SP), CX	
	ret := futex(unsafe.Pointer(addr), _FUTEX_WAKE, cnt, nil, nil, 0)
  0x41ed53		894c240c		MOVL CX, 0xc(SP)	
  0x41ed57		0f57c0			XORPS X0, X0		
  0x41ed5a		0f11442410		MOVUPS X0, 0x10(SP)	
  0x41ed5f		c744242000000000	MOVL $0x0, 0x20(SP)	
  0x41ed67		e8a4900200		CALL runtime.futex(SB)	
  0x41ed6c		8b442428		MOVL 0x28(SP), AX	
	if ret >= 0 {
  0x41ed70		85c0			TESTL AX, AX		
  0x41ed72		7c0a			JL 0x41ed7e		
		return
  0x41ed74		488b6c2448		MOVQ 0x48(SP), BP	
  0x41ed79		4883c450		ADDQ $0x50, SP		
  0x41ed7d		c3			RET			
	systemstack(func() {
  0x41ed7e		488d0ddb3d0200		LEAQ runtime.futexwakeup.func1(SB), CX	
  0x41ed85		48894c2430		MOVQ CX, 0x30(SP)			
  0x41ed8a		488b4c2458		MOVQ 0x58(SP), CX			
  0x41ed8f		48894c2438		MOVQ CX, 0x38(SP)			
  0x41ed94		89442440		MOVL AX, 0x40(SP)			
  0x41ed98		488d442430		LEAQ 0x30(SP), AX			
  0x41ed9d		48890424		MOVQ AX, 0(SP)				
  0x41eda1		e87a560200		CALL runtime.systemstack(SB)		
	*(*int32)(unsafe.Pointer(uintptr(0x1006))) = 0x1006
  0x41eda6		b806100000		MOVL $0x1006, AX	
  0x41edab		c70006100000		MOVL $0x1006, 0(AX)	
}
  0x41edb1		488b6c2448		MOVQ 0x48(SP), BP	
  0x41edb6		4883c450		ADDQ $0x50, SP		
  0x41edba		c3			RET			

TEXT runtime.getproccount(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func getproccount() int32 {
  0x41edc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41edc9		488b7110		MOVQ 0x10(CX), SI	
  0x41edcd		4881fedefaffff		CMPQ $-0x522, SI	
  0x41edd4		0f84db000000		JE 0x41eeb5		
  0x41edda		488d842470030000	LEAQ 0x370(SP), AX	
  0x41ede2		4829f0			SUBQ SI, AX		
  0x41ede5		483d18230000		CMPQ $0x2318, AX	
  0x41edeb		0f86c4000000		JBE 0x41eeb5		
  0x41edf1		4881ec28200000		SUBQ $0x2028, SP	
  0x41edf8		4889ac2420200000	MOVQ BP, 0x2020(SP)	
  0x41ee00		488dac2420200000	LEAQ 0x2020(SP), BP	
	var buf [maxCPUs / 8]byte
  0x41ee08		488d7c2420		LEAQ 0x20(SP), DI	
  0x41ee0d		b900040000		MOVL $0x400, CX		
  0x41ee12		31c0			XORL AX, AX		
  0x41ee14		f348ab			REP; STOSQ AX, ES:0(DI)	
	r := sched_getaffinity(0, unsafe.Sizeof(buf), &buf[0])
  0x41ee17		488d542420		LEAQ 0x20(SP), DX			
  0x41ee1c		4889542410		MOVQ DX, 0x10(SP)			
  0x41ee21		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x41ee29		48c744240800200000	MOVQ $0x2000, 0x8(SP)			
  0x41ee32		e829910200		CALL runtime.sched_getaffinity(SB)	
  0x41ee37		8b542418		MOVL 0x18(SP), DX			
	if r < 0 {
  0x41ee3b		85d2			TESTL DX, DX		
  0x41ee3d		7c54			JL 0x41ee93		
	for _, v := range buf[:r] {
  0x41ee3f		4863c2			MOVSXD DX, AX		
  0x41ee42		483d00200000		CMPQ $0x2000, AX	
  0x41ee48		7764			JA 0x41eeae		
  0x41ee4a		31c9			XORL CX, CX		
  0x41ee4c		31d2			XORL DX, DX		
  0x41ee4e		eb13			JMP 0x41ee63		
  0x41ee50		89de			MOVL BX, SI		
			n += int32(v & 1)
  0x41ee52		83e301			ANDL $0x1, BX		
  0x41ee55		01da			ADDL BX, DX		
			v >>= 1
  0x41ee57		40d0ee			SHRL $0x1, SI		
  0x41ee5a		89f3			MOVL SI, BX		
		for v != 0 {
  0x41ee5c		84db			TESTL BL, BL		
  0x41ee5e		75f0			JNE 0x41ee50		
	for _, v := range buf[:r] {
  0x41ee60		48ffc1			INCQ CX				
  0x41ee63		4839c1			CMPQ AX, CX			
  0x41ee66		7d07			JGE 0x41ee6f			
  0x41ee68		0fb65c0c20		MOVZX 0x20(SP)(CX*1), BX	
		for v != 0 {
  0x41ee6d		ebed			JMP 0x41ee5c		
	if n == 0 {
  0x41ee6f		85d2			TESTL DX, DX		
  0x41ee71		751c			JNE 0x41ee8f		
  0x41ee73		b801000000		MOVL $0x1, AX		
	return n
  0x41ee78		89842430200000		MOVL AX, 0x2030(SP)	
  0x41ee7f		488bac2420200000	MOVQ 0x2020(SP), BP	
  0x41ee87		4881c428200000		ADDQ $0x2028, SP	
  0x41ee8e		c3			RET			
  0x41ee8f		89d0			MOVL DX, AX		
	if n == 0 {
  0x41ee91		ebe5			JMP 0x41ee78		
		return 1
  0x41ee93		c784243020000001000000	MOVL $0x1, 0x2030(SP)	
  0x41ee9e		488bac2420200000	MOVQ 0x2020(SP), BP	
  0x41eea6		4881c428200000		ADDQ $0x2028, SP	
  0x41eead		c3			RET			
	for _, v := range buf[:r] {
  0x41eeae		e8fd0b0000		CALL runtime.panicslice(SB)	
  0x41eeb3		0f0b			UD2				
func getproccount() int32 {
  0x41eeb5		e8b6560200		CALL runtime.morestack_noctxt(SB)	
  0x41eeba		e901ffffff		JMP runtime.getproccount(SB)		

TEXT runtime.newosproc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func newosproc(mp *m, stk unsafe.Pointer) {
  0x41eec0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41eec9		483b6110		CMPQ 0x10(CX), SP	
  0x41eecd		0f869e010000		JBE 0x41f071		
  0x41eed3		4883ec60		SUBQ $0x60, SP		
  0x41eed7		48896c2458		MOVQ BP, 0x58(SP)	
  0x41eedc		488d6c2458		LEAQ 0x58(SP), BP	
	var oset sigset
  0x41eee1		48c744243800000000	MOVQ $0x0, 0x38(SP)	
	sigprocmask(_SIG_SETMASK, &sigset_all, &oset)
  0x41eeea		c7042402000000		MOVL $0x2, 0(SP)		
  0x41eef1		488d0558610800		LEAQ runtime.sigset_all(SB), AX	
  0x41eef8		4889442408		MOVQ AX, 0x8(SP)		
  0x41eefd		488d442438		LEAQ 0x38(SP), AX		
  0x41ef02		4889442410		MOVQ AX, 0x10(SP)		
  0x41ef07		e8b4070000		CALL runtime.sigprocmask(SB)	
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
  0x41ef0c		488d05cd770300		LEAQ 0x377cd(IP), AX	
  0x41ef13		4889442448		MOVQ AX, 0x48(SP)	
  0x41ef18		488d0559f20400		LEAQ 0x4f259(IP), AX	
  0x41ef1f		4889442450		MOVQ AX, 0x50(SP)	
  0x41ef24		488b4c2468		MOVQ 0x68(SP), CX	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x41ef29		8400			TESTB AL, 0(AX)		
  0x41ef2b		488d442450		LEAQ 0x50(SP), AX	
  0x41ef30		8400			TESTB AL, 0(AX)		
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
  0x41ef32		488b01			MOVQ 0(CX), AX		
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x41ef35		488b0d3cf20400		MOVQ 0x4f23c(IP), CX	
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
  0x41ef3c		4889442418		MOVQ AX, 0x18(SP)	
  0x41ef41		c70424000f0500		MOVL $0x50f00, 0(SP)	
func newosproc(mp *m, stk unsafe.Pointer) {
  0x41ef48		488b442470		MOVQ 0x70(SP), AX	
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
  0x41ef4d		4889442408		MOVQ AX, 0x8(SP)	
  0x41ef52		488b442468		MOVQ 0x68(SP), AX	
  0x41ef57		4889442410		MOVQ AX, 0x10(SP)	
  0x41ef5c		48894c2420		MOVQ CX, 0x20(SP)	
  0x41ef61		e8da8e0200		CALL runtime.clone(SB)	
  0x41ef66		8b442428		MOVL 0x28(SP), AX	
  0x41ef6a		89442434		MOVL AX, 0x34(SP)	
	sigprocmask(_SIG_SETMASK, &oset, nil)
  0x41ef6e		c7042402000000		MOVL $0x2, 0(SP)		
  0x41ef75		488d4c2438		LEAQ 0x38(SP), CX		
  0x41ef7a		48894c2408		MOVQ CX, 0x8(SP)		
  0x41ef7f		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x41ef88		e833070000		CALL runtime.sigprocmask(SB)	
  0x41ef8d		8b442434		MOVL 0x34(SP), AX		
	if ret < 0 {
  0x41ef91		85c0			TESTL AX, AX		
  0x41ef93		7c0a			JL 0x41ef9f		
  0x41ef95		488b6c2458		MOVQ 0x58(SP), BP	
  0x41ef9a		4883c460		ADDQ $0x60, SP		
  0x41ef9e		c3			RET			
	return int32(sched.mnext - sched.nmfreed)
  0x41ef9f		488b05a2890800		MOVQ runtime.sched+40(SB), AX	
  0x41efa6		482b05ab890800		SUBQ runtime.sched+56(SB), AX	
  0x41efad		4889442440		MOVQ AX, 0x40(SP)		
		print("runtime: failed to create new OS thread (have ", mcount(), " already; errno=", -ret, ")\n")
  0x41efb2		e8492b0000		CALL runtime.printlock(SB)	
  0x41efb7		488d059ce70400		LEAQ 0x4e79c(IP), AX		
  0x41efbe		48890424		MOVQ AX, 0(SP)			
  0x41efc2		48c74424082e000000	MOVQ $0x2e, 0x8(SP)		
  0x41efcb		e870340000		CALL runtime.printstring(SB)	
  0x41efd0		488b442440		MOVQ 0x40(SP), AX		
  0x41efd5		4863c0			MOVSXD AX, AX			
  0x41efd8		48890424		MOVQ AX, 0(SP)			
  0x41efdc		e89f320000		CALL runtime.printint(SB)	
  0x41efe1		488d050aba0400		LEAQ 0x4ba0a(IP), AX		
  0x41efe8		48890424		MOVQ AX, 0(SP)			
  0x41efec		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x41eff5		e846340000		CALL runtime.printstring(SB)	
  0x41effa		8b442434		MOVL 0x34(SP), AX		
  0x41effe		f7d8			NEGL AX				
  0x41f000		4863c0			MOVSXD AX, AX			
  0x41f003		48890424		MOVQ AX, 0(SP)			
  0x41f007		e874320000		CALL runtime.printint(SB)	
  0x41f00c		488d0557ac0400		LEAQ 0x4ac57(IP), AX		
  0x41f013		48890424		MOVQ AX, 0(SP)			
  0x41f017		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41f020		e81b340000		CALL runtime.printstring(SB)	
  0x41f025		e8562b0000		CALL runtime.printunlock(SB)	
  0x41f02a		8b442434		MOVL 0x34(SP), AX		
		if ret == -_EAGAIN {
  0x41f02e		83f8f5			CMPL $-0xb, AX		
  0x41f031		7523			JNE 0x41f056		
			println("runtime: may need to increase max user processes (ulimit -u)")
  0x41f033		e8c82a0000		CALL runtime.printlock(SB)	
  0x41f038		488d057eed0400		LEAQ 0x4ed7e(IP), AX		
  0x41f03f		48890424		MOVQ AX, 0(SP)			
  0x41f043		48c74424083d000000	MOVQ $0x3d, 0x8(SP)		
  0x41f04c		e8ef330000		CALL runtime.printstring(SB)	
  0x41f051		e82a2b0000		CALL runtime.printunlock(SB)	
		throw("newosproc")
  0x41f056		488d05ccb00400		LEAQ 0x4b0cc(IP), AX	
  0x41f05d		48890424		MOVQ AX, 0(SP)		
  0x41f061		48c744240809000000	MOVQ $0x9, 0x8(SP)	
  0x41f06a		e861210000		CALL runtime.throw(SB)	
  0x41f06f		0f0b			UD2			
func newosproc(mp *m, stk unsafe.Pointer) {
  0x41f071		e8fa540200		CALL runtime.morestack_noctxt(SB)	
  0x41f076		e945feffff		JMP runtime.newosproc(SB)		

TEXT runtime.sysargs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func sysargs(argc int32, argv **byte) {
  0x41f080		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f089		488d842430fcffff	LEAQ 0xfffffc30(SP), AX	
  0x41f091		483b4110		CMPQ 0x10(CX), AX	
  0x41f095		0f8655020000		JBE 0x41f2f0		
  0x41f09b		4881ec50040000		SUBQ $0x450, SP		
  0x41f0a2		4889ac2448040000	MOVQ BP, 0x448(SP)	
  0x41f0aa		488dac2448040000	LEAQ 0x448(SP), BP	
  0x41f0b2		8b842458040000		MOVL 0x458(SP), AX	
	n := argc + 1
  0x41f0b9		ffc0			INCL AX			
  0x41f0bb		488b8c2460040000	MOVQ 0x460(SP), CX	
	for argv_index(argv, n) != nil {
  0x41f0c3		eb02			JMP 0x41f0c7		
		n++
  0x41f0c5		ffc0			INCL AX			
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x41f0c7		4863d0			MOVSXD AX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x41f0ca		488d1cd1		LEAQ 0(CX)(DX*8), BX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x41f0ce		8403			TESTB AL, 0(BX)		
  0x41f0d0		488b14d1		MOVQ 0(CX)(DX*8), DX	
	for argv_index(argv, n) != nil {
  0x41f0d4		4885d2			TESTQ DX, DX		
  0x41f0d7		75ec			JNE 0x41f0c5		
	n++
  0x41f0d9		ffc0			INCL AX			
	auxv := (*[1 << 28]uintptr)(add(unsafe.Pointer(argv), uintptr(n)*sys.PtrSize))
  0x41f0db		4863c0			MOVSXD AX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x41f0de		488d04c1		LEAQ 0(CX)(AX*8), AX	
	if sysauxv(auxv[:]) != 0 {
  0x41f0e2		8400			TESTB AL, 0(AX)			
  0x41f0e4		48890424		MOVQ AX, 0(SP)			
  0x41f0e8		48c744240800000010	MOVQ $0x10000000, 0x8(SP)	
  0x41f0f1		48c744241000000010	MOVQ $0x10000000, 0x10(SP)	
  0x41f0fa		e801020000		CALL runtime.sysauxv(SB)	
  0x41f0ff		488b442418		MOVQ 0x18(SP), AX		
  0x41f104		4885c0			TESTQ AX, AX			
  0x41f107		0f85cc010000		JNE 0x41f2d9			
	fd := open(&procAuxv[0], 0 /* O_RDONLY */, 0)
  0x41f10d		488b05946a0800		MOVQ runtime.procAuxv+8(SB), AX	
  0x41f114		488b0d856a0800		MOVQ runtime.procAuxv(SB), CX	
  0x41f11b		4885c0			TESTQ AX, AX			
  0x41f11e		0f86c5010000		JBE 0x41f2e9			
  0x41f124		48890c24		MOVQ CX, 0(SP)			
  0x41f128		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x41f131		e8ca860200		CALL runtime.open(SB)		
  0x41f136		8b442410		MOVL 0x10(SP), AX		
	if fd < 0 {
  0x41f13a		85c0			TESTL AX, AX		
  0x41f13c		0f8df6000000		JGE 0x41f238		
		p, err := mmap(nil, size, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x41f142		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x41f14a		48c744240800000400	MOVQ $0x40000, 0x8(SP)	
  0x41f153		48b80300000022000000	MOVQ $0x2200000003, AX	
  0x41f15d		4889442410		MOVQ AX, 0x10(SP)	
  0x41f162		b8ffffffff		MOVL $-0x1, AX		
  0x41f167		4889442418		MOVQ AX, 0x18(SP)	
  0x41f16c		e8ff2dfeff		CALL runtime.mmap(SB)	
  0x41f171		488b442420		MOVQ 0x20(SP), AX	
  0x41f176		488b4c2428		MOVQ 0x28(SP), CX	
		if err != 0 {
  0x41f17b		4885c9			TESTQ CX, CX		
  0x41f17e		0f85a4000000		JNE 0x41f228		
  0x41f184		4889842440040000	MOVQ AX, 0x440(SP)	
  0x41f18c		b900100000		MOVL $0x1000, CX	
		for n = 4 << 10; n < size; n <<= 1 {
  0x41f191		eb10			JMP 0x41f1a3		
  0x41f193		488b4c2438		MOVQ 0x38(SP), CX	
  0x41f198		48d1e1			SHLQ $0x1, CX		
  0x41f19b		488b842440040000	MOVQ 0x440(SP), AX	
  0x41f1a3		4881f900000400		CMPQ $0x40000, CX	
  0x41f1aa		733b			JAE 0x41f1e7		
  0x41f1ac		48894c2438		MOVQ CX, 0x38(SP)	
			err := mincore(unsafe.Pointer(uintptr(p)+n), 1, &addrspace_vec[0])
  0x41f1b1		488d15e9460a00		LEAQ runtime.addrspace_vec(SB), DX	
  0x41f1b8		4889542410		MOVQ DX, 0x10(SP)			
  0x41f1bd		488d1401		LEAQ 0(CX)(AX*1), DX			
  0x41f1c1		48891424		MOVQ DX, 0(SP)				
  0x41f1c5		48c744240801000000	MOVQ $0x1, 0x8(SP)			
  0x41f1ce		e8ad870200		CALL runtime.mincore(SB)		
  0x41f1d3		8b442418		MOVL 0x18(SP), AX			
			if err == 0 {
  0x41f1d7		85c0			TESTL AX, AX		
  0x41f1d9		75b8			JNE 0x41f193		
  0x41f1db		488b442438		MOVQ 0x38(SP), AX	
				physPageSize = n
  0x41f1e0		488905b9470a00		MOVQ AX, runtime.physPageSize(SB)	
		if physPageSize == 0 {
  0x41f1e7		488b05b2470a00		MOVQ runtime.physPageSize(SB), AX	
  0x41f1ee		4885c0			TESTQ AX, AX				
  0x41f1f1		750b			JNE 0x41f1fe				
			physPageSize = size
  0x41f1f3		48c705a2470a0000000400	MOVQ $0x40000, runtime.physPageSize(SB)	
  0x41f1fe		488b842440040000	MOVQ 0x440(SP), AX			
		munmap(p, size)
  0x41f206		48890424		MOVQ AX, 0(SP)		
  0x41f20a		48c744240800000400	MOVQ $0x40000, 0x8(SP)	
  0x41f213		e8d82efeff		CALL runtime.munmap(SB)	
		return
  0x41f218		488bac2448040000	MOVQ 0x448(SP), BP	
  0x41f220		4881c450040000		ADDQ $0x450, SP		
  0x41f227		c3			RET			
			return
  0x41f228		488bac2448040000	MOVQ 0x448(SP), BP	
  0x41f230		4881c450040000		ADDQ $0x450, SP		
  0x41f237		c3			RET			
  0x41f238		89442434		MOVL AX, 0x34(SP)	
	var buf [128]uintptr
  0x41f23c		488d7c2440		LEAQ 0x40(SP), DI		
  0x41f241		0f57c0			XORPS X0, X0			
  0x41f244		48896c24f0		MOVQ BP, -0x10(SP)		
  0x41f249		488d6c24f0		LEAQ -0x10(SP), BP		
  0x41f24e		e84d770200		CALL runtime.duffzero(SB)	
  0x41f253		488b6d00		MOVQ 0(BP), BP			
	n = read(fd, noescape(unsafe.Pointer(&buf[0])), int32(unsafe.Sizeof(buf)))
  0x41f257		890424			MOVL AX, 0(SP)		
  0x41f25a		488d4c2440		LEAQ 0x40(SP), CX	
  0x41f25f		48894c2408		MOVQ CX, 0x8(SP)	
  0x41f264		c744241000040000	MOVL $0x400, 0x10(SP)	
  0x41f26c		e80f860200		CALL runtime.read(SB)	
  0x41f271		8b442418		MOVL 0x18(SP), AX	
  0x41f275		89442430		MOVL AX, 0x30(SP)	
  0x41f279		8b4c2434		MOVL 0x34(SP), CX	
	closefd(fd)
  0x41f27d		890c24			MOVL CX, 0(SP)			
  0x41f280		e8ab850200		CALL runtime.closefd(SB)	
  0x41f285		8b442430		MOVL 0x30(SP), AX		
	if n < 0 {
  0x41f289		85c0			TESTL AX, AX		
  0x41f28b		7d10			JGE 0x41f29d		
		return
  0x41f28d		488bac2448040000	MOVQ 0x448(SP), BP	
  0x41f295		4881c450040000		ADDQ $0x450, SP		
  0x41f29c		c3			RET			
	buf[len(buf)-2] = _AT_NULL
  0x41f29d		48c784243004000000000000	MOVQ $0x0, 0x430(SP)	
	sysauxv(buf[:])
  0x41f2a9		488d442440		LEAQ 0x40(SP), AX		
  0x41f2ae		48890424		MOVQ AX, 0(SP)			
  0x41f2b2		48c744240880000000	MOVQ $0x80, 0x8(SP)		
  0x41f2bb		48c744241080000000	MOVQ $0x80, 0x10(SP)		
  0x41f2c4		e837000000		CALL runtime.sysauxv(SB)	
}
  0x41f2c9		488bac2448040000	MOVQ 0x448(SP), BP	
  0x41f2d1		4881c450040000		ADDQ $0x450, SP		
  0x41f2d8		c3			RET			
		return
  0x41f2d9		488bac2448040000	MOVQ 0x448(SP), BP	
  0x41f2e1		4881c450040000		ADDQ $0x450, SP		
  0x41f2e8		c3			RET			
	fd := open(&procAuxv[0], 0 /* O_RDONLY */, 0)
  0x41f2e9		e852070000		CALL runtime.panicindex(SB)	
  0x41f2ee		0f0b			UD2				
func sysargs(argc int32, argv **byte) {
  0x41f2f0		e87b520200		CALL runtime.morestack_noctxt(SB)	
  0x41f2f5		e986fdffff		JMP runtime.sysargs(SB)			

TEXT runtime.sysauxv(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func sysauxv(auxv []uintptr) int {
  0x41f300		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f309		483b6110		CMPQ 0x10(CX), SP	
  0x41f30d		0f86ec000000		JBE 0x41f3ff		
  0x41f313		4883ec20		SUBQ $0x20, SP		
  0x41f317		48896c2418		MOVQ BP, 0x18(SP)	
  0x41f31c		488d6c2418		LEAQ 0x18(SP), BP	
  0x41f321		31c0			XORL AX, AX		
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x41f323		eb17			JMP 0x41f33c		
		archauxv(tag, val)
  0x41f325		48891c24		MOVQ BX, 0(SP)			
  0x41f329		4889742408		MOVQ SI, 0x8(SP)		
  0x41f32e		e8ed230200		CALL runtime.archauxv(SB)	
  0x41f333		488b442410		MOVQ 0x10(SP), AX		
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x41f338		4883c002		ADDQ $0x2, AX		
  0x41f33c		488b4c2430		MOVQ 0x30(SP), CX	
  0x41f341		4839c8			CMPQ CX, AX		
  0x41f344		0f83ae000000		JAE 0x41f3f8		
  0x41f34a		488b542428		MOVQ 0x28(SP), DX	
  0x41f34f		488b1cc2		MOVQ 0(DX)(AX*8), BX	
  0x41f353		4885db			TESTQ BX, BX		
  0x41f356		7479			JE 0x41f3d1		
		tag, val := auxv[i], auxv[i+1]
  0x41f358		488d7001		LEAQ 0x1(AX), SI	
  0x41f35c		4839ce			CMPQ CX, SI		
  0x41f35f		0f838c000000		JAE 0x41f3f1		
  0x41f365		4889442410		MOVQ AX, 0x10(SP)	
  0x41f36a		488b74c208		MOVQ 0x8(DX)(AX*8), SI	
		case _AT_PAGESZ:
  0x41f36f		4883fb06		CMPQ $0x6, BX		
  0x41f373		7509			JNE 0x41f37e		
			physPageSize = val
  0x41f375		48893524460a00		MOVQ SI, runtime.physPageSize(SB)	
		switch tag {
  0x41f37c		eba7			JMP 0x41f325		
		case _AT_RANDOM:
  0x41f37e		4883fb19		CMPQ $0x19, BX		
  0x41f382		75a1			JNE 0x41f325		
  0x41f384		4989f0			MOVQ SI, R8		
			startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:]
  0x41f387		8406			TESTB AL, 0(SI)					
  0x41f389		48c705e483080010000000	MOVQ $0x10, runtime.startupRandomData+8(SB)	
  0x41f394		48c705e183080010000000	MOVQ $0x10, runtime.startupRandomData+16(SB)	
  0x41f39f		448b0d6a460a00		MOVL runtime.writeBarrier(SB), R9		
  0x41f3a6		4585c9			TESTL R9, R9					
  0x41f3a9		750f			JNE 0x41f3ba					
  0x41f3ab		488935be830800		MOVQ SI, runtime.startupRandomData(SB)		
  0x41f3b2		4c89c6			MOVQ R8, SI					
		switch tag {
  0x41f3b5		e96bffffff		JMP 0x41f325		
			startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:]
  0x41f3ba		488d3daf830800		LEAQ runtime.startupRandomData(SB), DI	
  0x41f3c1		4989c1			MOVQ AX, R9				
  0x41f3c4		4889f0			MOVQ SI, AX				
  0x41f3c7		e8d4740200		CALL runtime.gcWriteBarrier(SB)		
  0x41f3cc		4c89c8			MOVQ R9, AX				
  0x41f3cf		ebe1			JMP 0x41f3b2				
	return i / 2
  0x41f3d1		4889c1			MOVQ AX, CX		
  0x41f3d4		48c1f83f		SARQ $0x3f, AX		
  0x41f3d8		48c1e83f		SHRQ $0x3f, AX		
  0x41f3dc		4801c8			ADDQ CX, AX		
  0x41f3df		48d1f8			SARQ $0x1, AX		
  0x41f3e2		4889442440		MOVQ AX, 0x40(SP)	
  0x41f3e7		488b6c2418		MOVQ 0x18(SP), BP	
  0x41f3ec		4883c420		ADDQ $0x20, SP		
  0x41f3f0		c3			RET			
		tag, val := auxv[i], auxv[i+1]
  0x41f3f1		e84a060000		CALL runtime.panicindex(SB)	
  0x41f3f6		0f0b			UD2				
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x41f3f8		e843060000		CALL runtime.panicindex(SB)	
  0x41f3fd		0f0b			UD2				
func sysauxv(auxv []uintptr) int {
  0x41f3ff		e86c510200		CALL runtime.morestack_noctxt(SB)	
  0x41f404		e9f7feffff		JMP runtime.sysauxv(SB)			

TEXT runtime.osinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func osinit() {
  0x41f410		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f419		483b6110		CMPQ 0x10(CX), SP	
  0x41f41d		7626			JBE 0x41f445		
  0x41f41f		4883ec10		SUBQ $0x10, SP		
  0x41f423		48896c2408		MOVQ BP, 0x8(SP)	
  0x41f428		488d6c2408		LEAQ 0x8(SP), BP	
	ncpu = getproccount()
  0x41f42d		e88ef9ffff		CALL runtime.getproccount(SB)	
  0x41f432		8b0424			MOVL 0(SP), AX			
  0x41f435		8905a9440a00		MOVL AX, runtime.ncpu(SB)	
}
  0x41f43b		488b6c2408		MOVQ 0x8(SP), BP	
  0x41f440		4883c410		ADDQ $0x10, SP		
  0x41f444		c3			RET			
func osinit() {
  0x41f445		e826510200		CALL runtime.morestack_noctxt(SB)	
  0x41f44a		ebc4			JMP runtime.osinit(SB)			

TEXT runtime.getRandomData(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func getRandomData(r []byte) {
  0x41f450		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f459		483b6110		CMPQ 0x10(CX), SP	
  0x41f45d		0f862e010000		JBE 0x41f591		
  0x41f463		4883ec40		SUBQ $0x40, SP		
  0x41f467		48896c2438		MOVQ BP, 0x38(SP)	
  0x41f46c		488d6c2438		LEAQ 0x38(SP), BP	
	if startupRandomData != nil {
  0x41f471		488b05f8820800		MOVQ runtime.startupRandomData(SB), AX		
  0x41f478		488b0df9820800		MOVQ runtime.startupRandomData+8(SB), CX	
  0x41f47f		4885c0			TESTQ AX, AX					
  0x41f482		7462			JE 0x41f4e6					
  0x41f484		488b542450		MOVQ 0x50(SP), DX				
		n := copy(r, startupRandomData)
  0x41f489		4839ca			CMPQ CX, DX			
  0x41f48c		7e53			JLE 0x41f4e1			
  0x41f48e		48894c2428		MOVQ CX, 0x28(SP)		
  0x41f493		488b542448		MOVQ 0x48(SP), DX		
  0x41f498		48891424		MOVQ DX, 0(SP)			
  0x41f49c		4889442408		MOVQ AX, 0x8(SP)		
  0x41f4a1		48894c2410		MOVQ CX, 0x10(SP)		
  0x41f4a6		e8557c0200		CALL runtime.memmove(SB)	
  0x41f4ab		488b442448		MOVQ 0x48(SP), AX		
		extendRandom(r, n)
  0x41f4b0		48890424		MOVQ AX, 0(SP)			
  0x41f4b4		488b442450		MOVQ 0x50(SP), AX		
  0x41f4b9		4889442408		MOVQ AX, 0x8(SP)		
  0x41f4be		488b442458		MOVQ 0x58(SP), AX		
  0x41f4c3		4889442410		MOVQ AX, 0x10(SP)		
  0x41f4c8		488b442428		MOVQ 0x28(SP), AX		
  0x41f4cd		4889442418		MOVQ AX, 0x18(SP)		
  0x41f4d2		e8a9070100		CALL runtime.extendRandom(SB)	
		return
  0x41f4d7		488b6c2438		MOVQ 0x38(SP), BP	
  0x41f4dc		4883c440		ADDQ $0x40, SP		
  0x41f4e0		c3			RET			
  0x41f4e1		4889d1			MOVQ DX, CX		
		n := copy(r, startupRandomData)
  0x41f4e4		eba8			JMP 0x41f48e		
	fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
  0x41f4e6		488b05fb660800		MOVQ runtime.urandom_dev+8(SB), AX	
  0x41f4ed		488b0dec660800		MOVQ runtime.urandom_dev(SB), CX	
  0x41f4f4		4885c0			TESTQ AX, AX				
  0x41f4f7		0f868d000000		JBE 0x41f58a				
  0x41f4fd		48890c24		MOVQ CX, 0(SP)				
  0x41f501		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x41f50a		e8f1820200		CALL runtime.open(SB)			
  0x41f50f		8b442410		MOVL 0x10(SP), AX			
  0x41f513		488b4c2450		MOVQ 0x50(SP), CX			
	n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
  0x41f518		4885c9			TESTQ CX, CX		
  0x41f51b		7666			JBE 0x41f583		
  0x41f51d		89442424		MOVL AX, 0x24(SP)	
  0x41f521		488b542448		MOVQ 0x48(SP), DX	
  0x41f526		4889542408		MOVQ DX, 0x8(SP)	
  0x41f52b		890424			MOVL AX, 0(SP)		
  0x41f52e		894c2410		MOVL CX, 0x10(SP)	
  0x41f532		e849830200		CALL runtime.read(SB)	
	extendRandom(r, int(n))
  0x41f537		4863442418		MOVSXD 0x18(SP), AX	
  0x41f53c		4889442430		MOVQ AX, 0x30(SP)	
  0x41f541		8b4c2424		MOVL 0x24(SP), CX	
	closefd(fd)
  0x41f545		890c24			MOVL CX, 0(SP)			
  0x41f548		e8e3820200		CALL runtime.closefd(SB)	
  0x41f54d		488b442448		MOVQ 0x48(SP), AX		
	extendRandom(r, int(n))
  0x41f552		48890424		MOVQ AX, 0(SP)			
  0x41f556		488b442450		MOVQ 0x50(SP), AX		
  0x41f55b		4889442408		MOVQ AX, 0x8(SP)		
  0x41f560		488b442458		MOVQ 0x58(SP), AX		
  0x41f565		4889442410		MOVQ AX, 0x10(SP)		
  0x41f56a		488b442430		MOVQ 0x30(SP), AX		
  0x41f56f		4889442418		MOVQ AX, 0x18(SP)		
  0x41f574		e807070100		CALL runtime.extendRandom(SB)	
}
  0x41f579		488b6c2438		MOVQ 0x38(SP), BP	
  0x41f57e		4883c440		ADDQ $0x40, SP		
  0x41f582		c3			RET			
	n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
  0x41f583		e8b8040000		CALL runtime.panicindex(SB)	
  0x41f588		0f0b			UD2				
	fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
  0x41f58a		e8b1040000		CALL runtime.panicindex(SB)	
  0x41f58f		0f0b			UD2				
func getRandomData(r []byte) {
  0x41f591		e8da4f0200		CALL runtime.morestack_noctxt(SB)	
  0x41f596		e9b5feffff		JMP runtime.getRandomData(SB)		

TEXT runtime.goenvs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func goenvs() {
  0x41f5a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f5a9		483b6110		CMPQ 0x10(CX), SP	
  0x41f5ad		761a			JBE 0x41f5c9		
  0x41f5af		4883ec08		SUBQ $0x8, SP		
  0x41f5b3		48892c24		MOVQ BP, 0(SP)		
  0x41f5b7		488d2c24		LEAQ 0(SP), BP		
	goenvs_unix()
  0x41f5bb		e8b0f80000		CALL runtime.goenvs_unix(SB)	
}
  0x41f5c0		488b2c24		MOVQ 0(SP), BP		
  0x41f5c4		4883c408		ADDQ $0x8, SP		
  0x41f5c8		c3			RET			
func goenvs() {
  0x41f5c9		e8a24f0200		CALL runtime.morestack_noctxt(SB)	
  0x41f5ce		ebd0			JMP runtime.goenvs(SB)			

TEXT runtime.mpreinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func mpreinit(mp *m) {
  0x41f5d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f5d9		483b6110		CMPQ 0x10(CX), SP	
  0x41f5dd		766d			JBE 0x41f64c		
  0x41f5df		4883ec18		SUBQ $0x18, SP		
  0x41f5e3		48896c2410		MOVQ BP, 0x10(SP)	
  0x41f5e8		488d6c2410		LEAQ 0x10(SP), BP	
	mp.gsignal = malg(32 * 1024) // Linux wants >= 2K
  0x41f5ed		c7042400800000		MOVL $0x8000, 0(SP)	
  0x41f5f4		e847ac0000		CALL runtime.malg(SB)	
func mpreinit(mp *m) {
  0x41f5f9		488b442420		MOVQ 0x20(SP), AX	
	mp.gsignal = malg(32 * 1024) // Linux wants >= 2K
  0x41f5fe		8400			TESTB AL, 0(AX)				
  0x41f600		8b0d0a440a00		MOVL runtime.writeBarrier(SB), CX	
  0x41f606		488d7850		LEAQ 0x50(AX), DI			
  0x41f60a		488b542408		MOVQ 0x8(SP), DX			
  0x41f60f		85c9			TESTL CX, CX				
  0x41f611		7529			JNE 0x41f63c				
  0x41f613		48895050		MOVQ DX, 0x50(AX)			
	mp.gsignal.m = mp
  0x41f617		8402			TESTB AL, 0(DX)				
  0x41f619		8b0df1430a00		MOVL runtime.writeBarrier(SB), CX	
  0x41f61f		488d7a30		LEAQ 0x30(DX), DI			
  0x41f623		85c9			TESTL CX, CX				
  0x41f625		750e			JNE 0x41f635				
  0x41f627		48894230		MOVQ AX, 0x30(DX)			
}
  0x41f62b		488b6c2410		MOVQ 0x10(SP), BP	
  0x41f630		4883c418		ADDQ $0x18, SP		
  0x41f634		c3			RET			
	mp.gsignal.m = mp
  0x41f635		e866720200		CALL runtime.gcWriteBarrier(SB)	
  0x41f63a		ebef			JMP 0x41f62b			
  0x41f63c		4889c1			MOVQ AX, CX			
  0x41f63f		4889d0			MOVQ DX, AX			
	mp.gsignal = malg(32 * 1024) // Linux wants >= 2K
  0x41f642		e859720200		CALL runtime.gcWriteBarrier(SB)	
  0x41f647		4889c8			MOVQ CX, AX			
  0x41f64a		ebcb			JMP 0x41f617			
func mpreinit(mp *m) {
  0x41f64c		e81f4f0200		CALL runtime.morestack_noctxt(SB)	
  0x41f651		e97affffff		JMP runtime.mpreinit(SB)		

TEXT runtime.minit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func minit() {
  0x41f660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f669		483b6110		CMPQ 0x10(CX), SP	
  0x41f66d		7636			JBE 0x41f6a5		
  0x41f66f		4883ec10		SUBQ $0x10, SP		
  0x41f673		48896c2408		MOVQ BP, 0x8(SP)	
  0x41f678		488d6c2408		LEAQ 0x8(SP), BP	
	minitSignals()
  0x41f67d		e87e3b0100		CALL runtime.minitSignals(SB)	
	getg().m.procid = uint64(gettid())
  0x41f682		e889820200		CALL runtime.gettid(SB)	
  0x41f687		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41f690		488b4030		MOVQ 0x30(AX), AX	
  0x41f694		8b0c24			MOVL 0(SP), CX		
  0x41f697		48894848		MOVQ CX, 0x48(AX)	
}
  0x41f69b		488b6c2408		MOVQ 0x8(SP), BP	
  0x41f6a0		4883c410		ADDQ $0x10, SP		
  0x41f6a4		c3			RET			
func minit() {
  0x41f6a5		e8c64e0200		CALL runtime.morestack_noctxt(SB)	
  0x41f6aa		ebb4			JMP runtime.minit(SB)			

TEXT runtime.unminit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
	unminitSignals()
  0x41f6b0		e80b3e0100		CALL runtime.unminitSignals(SB)	
}
  0x41f6b5		c3			RET			

TEXT runtime.sigprocmask(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func sigprocmask(how int32, new, old *sigset) {
  0x41f6c0		4883ec28		SUBQ $0x28, SP		
  0x41f6c4		48896c2420		MOVQ BP, 0x20(SP)	
  0x41f6c9		488d6c2420		LEAQ 0x20(SP), BP	
  0x41f6ce		8b442430		MOVL 0x30(SP), AX	
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x41f6d2		890424			MOVL AX, 0(SP)		
func sigprocmask(how int32, new, old *sigset) {
  0x41f6d5		488b442438		MOVQ 0x38(SP), AX	
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x41f6da		4889442408		MOVQ AX, 0x8(SP)	
func sigprocmask(how int32, new, old *sigset) {
  0x41f6df		488b442440		MOVQ 0x40(SP), AX	
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x41f6e4		4889442410		MOVQ AX, 0x10(SP)		
  0x41f6e9		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x41f6f1		e8da830200		CALL runtime.rtsigprocmask(SB)	
}
  0x41f6f6		488b6c2420		MOVQ 0x20(SP), BP	
  0x41f6fb		4883c428		ADDQ $0x28, SP		
  0x41f6ff		c3			RET			

TEXT runtime.setsig(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func setsig(i uint32, fn uintptr) {
  0x41f700		4881ec90000000		SUBQ $0x90, SP		
  0x41f707		4889ac2488000000	MOVQ BP, 0x88(SP)	
  0x41f70f		488dac2488000000	LEAQ 0x88(SP), BP	
  0x41f717		0f57c0			XORPS X0, X0		
  0x41f71a		0f11442468		MOVUPS X0, 0x68(SP)	
  0x41f71f		0f11442478		MOVUPS X0, 0x78(SP)	
	var sa sigactiont
  0x41f724		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x41f72d		0f57c0			XORPS X0, X0		
  0x41f730		0f11442438		MOVUPS X0, 0x38(SP)	
	sa.sa_flags = _SA_SIGINFO | _SA_ONSTACK | _SA_RESTORER | _SA_RESTART
  0x41f735		48c74424300400001c	MOVQ $0x1c000004, 0x30(SP)	
	*mask = ^uint64(0)
  0x41f73e		488d442440		LEAQ 0x40(SP), AX	
  0x41f743		8400			TESTB AL, 0(AX)		
  0x41f745		48c7442440ffffffff	MOVQ $-0x1, 0x40(SP)	
		sa.sa_restorer = funcPC(sigreturn)
  0x41f74e		488d058b6f0300		LEAQ 0x36f8b(IP), AX	
  0x41f755		4889442458		MOVQ AX, 0x58(SP)	
  0x41f75a		488d0d87ea0400		LEAQ 0x4ea87(IP), CX	
  0x41f761		48894c2460		MOVQ CX, 0x60(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x41f766		8401			TESTB AL, 0(CX)		
  0x41f768		488d4c2460		LEAQ 0x60(SP), CX	
  0x41f76d		8401			TESTB AL, 0(CX)		
  0x41f76f		488b0d72ea0400		MOVQ 0x4ea72(IP), CX	
		sa.sa_restorer = funcPC(sigreturn)
  0x41f776		48894c2438		MOVQ CX, 0x38(SP)	
	if fn == funcPC(sighandler) {
  0x41f77b		488d0d9eb10300		LEAQ 0x3b19e(IP), CX	
  0x41f782		48894c2448		MOVQ CX, 0x48(SP)	
  0x41f787		488d0d4aea0400		LEAQ 0x4ea4a(IP), CX	
  0x41f78e		48894c2450		MOVQ CX, 0x50(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x41f793		b908000000		MOVL $0x8, CX		
  0x41f798		488d542448		LEAQ 0x48(SP), DX	
  0x41f79d		488b140a		MOVQ 0(DX)(CX*1), DX	
  0x41f7a1		488d5c2450		LEAQ 0x50(SP), BX	
  0x41f7a6		8403			TESTB AL, 0(BX)		
  0x41f7a8		488b12			MOVQ 0(DX), DX		
  0x41f7ab		488b9c24a0000000	MOVQ 0xa0(SP), BX	
	if fn == funcPC(sighandler) {
  0x41f7b3		4839d3			CMPQ DX, BX		
  0x41f7b6		0f85a3000000		JNE 0x41f85f		
		if iscgo {
  0x41f7bc		0fb615e9400a00		MOVZX runtime.iscgo(SB), DX	
  0x41f7c3		84d2			TESTL DL, DL			
  0x41f7c5		7465			JE 0x41f82c			
			fn = funcPC(cgoSigtramp)
  0x41f7c7		4889442468		MOVQ AX, 0x68(SP)	
  0x41f7cc		488d051de80400		LEAQ 0x4e81d(IP), AX	
  0x41f7d3		4889442470		MOVQ AX, 0x70(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x41f7d8		488d442468		LEAQ 0x68(SP), AX	
  0x41f7dd		488b0408		MOVQ 0(AX)(CX*1), AX	
  0x41f7e1		488d4c2470		LEAQ 0x70(SP), CX	
  0x41f7e6		8401			TESTB AL, 0(CX)		
  0x41f7e8		488b00			MOVQ 0(AX), AX		
	sa.sa_handler = fn
  0x41f7eb		4889442428		MOVQ AX, 0x28(SP)	
  0x41f7f0		8b842498000000		MOVL 0x98(SP), AX	
	rt_sigaction(uintptr(i), &sa, nil, unsafe.Sizeof(sa.sa_mask))
  0x41f7f7		48890424		MOVQ AX, 0(SP)			
  0x41f7fb		488d442428		LEAQ 0x28(SP), AX		
  0x41f800		4889442408		MOVQ AX, 0x8(SP)		
  0x41f805		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x41f80e		48c744241808000000	MOVQ $0x8, 0x18(SP)		
  0x41f817		e86429feff		CALL runtime.rt_sigaction(SB)	
}
  0x41f81c		488bac2488000000	MOVQ 0x88(SP), BP	
  0x41f824		4881c490000000		ADDQ $0x90, SP		
  0x41f82b		c3			RET			
			fn = funcPC(sigtramp)
  0x41f82c		488d158da60300		LEAQ 0x3a68d(IP), DX	
  0x41f833		4889542478		MOVQ DX, 0x78(SP)	
  0x41f838		488d15b1e90400		LEAQ 0x4e9b1(IP), DX	
  0x41f83f		4889942480000000	MOVQ DX, 0x80(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x41f847		488d542478		LEAQ 0x78(SP), DX	
  0x41f84c		488b0c0a		MOVQ 0(DX)(CX*1), CX	
  0x41f850		488d942480000000	LEAQ 0x80(SP), DX	
  0x41f858		8402			TESTB AL, 0(DX)		
  0x41f85a		488b01			MOVQ 0(CX), AX		
			fn = funcPC(sigtramp)
  0x41f85d		eb8c			JMP 0x41f7eb		
  0x41f85f		4889d8			MOVQ BX, AX		
	if fn == funcPC(sighandler) {
  0x41f862		eb87			JMP 0x41f7eb		

TEXT runtime.setsigstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func setsigstack(i uint32) {
  0x41f870		4883ec50		SUBQ $0x50, SP		
  0x41f874		48896c2448		MOVQ BP, 0x48(SP)	
  0x41f879		488d6c2448		LEAQ 0x48(SP), BP	
	var sa sigactiont
  0x41f87e		0f57c0			XORPS X0, X0		
  0x41f881		0f11442428		MOVUPS X0, 0x28(SP)	
  0x41f886		0f11442438		MOVUPS X0, 0x38(SP)	
func setsigstack(i uint32) {
  0x41f88b		8b442458		MOVL 0x58(SP), AX	
	rt_sigaction(uintptr(i), nil, &sa, unsafe.Sizeof(sa.sa_mask))
  0x41f88f		48890424		MOVQ AX, 0(SP)			
  0x41f893		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x41f89c		488d4c2428		LEAQ 0x28(SP), CX		
  0x41f8a1		48894c2410		MOVQ CX, 0x10(SP)		
  0x41f8a6		48c744241808000000	MOVQ $0x8, 0x18(SP)		
  0x41f8af		e8cc28feff		CALL runtime.rt_sigaction(SB)	
	if sa.sa_flags&_SA_ONSTACK != 0 {
  0x41f8b4		488b442430		MOVQ 0x30(SP), AX	
  0x41f8b9		0fbae01b		BTL $0x1b, AX		
  0x41f8bd		730a			JAE 0x41f8c9		
		return
  0x41f8bf		488b6c2448		MOVQ 0x48(SP), BP	
  0x41f8c4		4883c450		ADDQ $0x50, SP		
  0x41f8c8		c3			RET			
	sa.sa_flags |= _SA_ONSTACK
  0x41f8c9		480d00000008		ORQ $0x8000000, AX	
  0x41f8cf		4889442430		MOVQ AX, 0x30(SP)	
  0x41f8d4		8b442458		MOVL 0x58(SP), AX	
	rt_sigaction(uintptr(i), &sa, nil, unsafe.Sizeof(sa.sa_mask))
  0x41f8d8		48890424		MOVQ AX, 0(SP)			
  0x41f8dc		488d442428		LEAQ 0x28(SP), AX		
  0x41f8e1		4889442408		MOVQ AX, 0x8(SP)		
  0x41f8e6		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x41f8ef		48c744241808000000	MOVQ $0x8, 0x18(SP)		
  0x41f8f8		e88328feff		CALL runtime.rt_sigaction(SB)	
}
  0x41f8fd		488b6c2448		MOVQ 0x48(SP), BP	
  0x41f902		4883c450		ADDQ $0x50, SP		
  0x41f906		c3			RET			

TEXT runtime.getsig(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
func getsig(i uint32) uintptr {
  0x41f910		4883ec50		SUBQ $0x50, SP		
  0x41f914		48896c2448		MOVQ BP, 0x48(SP)	
  0x41f919		488d6c2448		LEAQ 0x48(SP), BP	
	var sa sigactiont
  0x41f91e		0f57c0			XORPS X0, X0		
  0x41f921		0f11442428		MOVUPS X0, 0x28(SP)	
  0x41f926		0f11442438		MOVUPS X0, 0x38(SP)	
func getsig(i uint32) uintptr {
  0x41f92b		8b442458		MOVL 0x58(SP), AX	
	if rt_sigaction(uintptr(i), nil, &sa, unsafe.Sizeof(sa.sa_mask)) != 0 {
  0x41f92f		48890424		MOVQ AX, 0(SP)			
  0x41f933		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x41f93c		488d442428		LEAQ 0x28(SP), AX		
  0x41f941		4889442410		MOVQ AX, 0x10(SP)		
  0x41f946		48c744241808000000	MOVQ $0x8, 0x18(SP)		
  0x41f94f		e82c28feff		CALL runtime.rt_sigaction(SB)	
  0x41f954		8b442420		MOVL 0x20(SP), AX		
  0x41f958		85c0			TESTL AX, AX			
  0x41f95a		7514			JNE 0x41f970			
	return sa.sa_handler
  0x41f95c		488b442428		MOVQ 0x28(SP), AX	
  0x41f961		4889442460		MOVQ AX, 0x60(SP)	
  0x41f966		488b6c2448		MOVQ 0x48(SP), BP	
  0x41f96b		4883c450		ADDQ $0x50, SP		
  0x41f96f		c3			RET			
		throw("rt_sigaction read failure")
  0x41f970		488d051bc10400		LEAQ 0x4c11b(IP), AX	
  0x41f977		48890424		MOVQ AX, 0(SP)		
  0x41f97b		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x41f984		e847180000		CALL runtime.throw(SB)	
  0x41f989		0f0b			UD2			

TEXT runtime.panicCheckMalloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func panicCheckMalloc(err error) {
  0x41f990		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f999		483b6110		CMPQ 0x10(CX), SP	
  0x41f99d		0f8689000000		JBE 0x41fa2c		
  0x41f9a3		4883ec20		SUBQ $0x20, SP		
  0x41f9a7		48896c2418		MOVQ BP, 0x18(SP)	
  0x41f9ac		488d6c2418		LEAQ 0x18(SP), BP	
	gp := getg()
  0x41f9b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != nil && gp.m != nil && gp.m.mallocing != 0 {
  0x41f9ba		4885c0			TESTQ AX, AX		
  0x41f9bd		7413			JE 0x41f9d2		
  0x41f9bf		488b4030		MOVQ 0x30(AX), AX	
  0x41f9c3		4885c0			TESTQ AX, AX		
  0x41f9c6		740a			JE 0x41f9d2		
  0x41f9c8		8b80e8000000		MOVL 0xe8(AX), AX	
  0x41f9ce		85c0			TESTL AX, AX		
  0x41f9d0		750a			JNE 0x41f9dc		
  0x41f9d2		488b6c2418		MOVQ 0x18(SP), BP	
  0x41f9d7		4883c420		ADDQ $0x20, SP		
  0x41f9db		c3			RET			
  0x41f9dc		488b442428		MOVQ 0x28(SP), AX	
		throw(string(err.(errorString)))
  0x41f9e1		488d0d58540500		LEAQ go.itab.runtime.errorString,error(SB), CX	
  0x41f9e8		4839c8			CMPQ CX, AX					
  0x41f9eb		751c			JNE 0x41fa09					
  0x41f9ed		488b442430		MOVQ 0x30(SP), AX				
  0x41f9f2		488b4808		MOVQ 0x8(AX), CX				
  0x41f9f6		488b00			MOVQ 0(AX), AX					
  0x41f9f9		48890424		MOVQ AX, 0(SP)					
  0x41f9fd		48894c2408		MOVQ CX, 0x8(SP)				
  0x41fa02		e8c9170000		CALL runtime.throw(SB)				
  0x41fa07		0f0b			UD2						
  0x41fa09		48890424		MOVQ AX, 0(SP)					
  0x41fa0d		488d05acb40300		LEAQ 0x3b4ac(IP), AX				
  0x41fa14		4889442408		MOVQ AX, 0x8(SP)				
  0x41fa19		488d0520c00300		LEAQ 0x3c020(IP), AX				
  0x41fa20		4889442410		MOVQ AX, 0x10(SP)				
  0x41fa25		e81697feff		CALL runtime.panicdottypeI(SB)			
  0x41fa2a		0f0b			UD2						
func panicCheckMalloc(err error) {
  0x41fa2c		e83f4b0200		CALL runtime.morestack_noctxt(SB)	
  0x41fa31		e95affffff		JMP runtime.panicCheckMalloc(SB)	

TEXT runtime.panicindex(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func panicindex() {
  0x41fa40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fa49		483b6110		CMPQ 0x10(CX), SP	
  0x41fa4d		7651			JBE 0x41faa0		
  0x41fa4f		4883ec18		SUBQ $0x18, SP		
  0x41fa53		48896c2410		MOVQ BP, 0x10(SP)	
  0x41fa58		488d6c2410		LEAQ 0x10(SP), BP	
	panicCheckMalloc(indexError)
  0x41fa5d		488b0524600800		MOVQ runtime.indexError+8(SB), AX	
  0x41fa64		488b0d15600800		MOVQ runtime.indexError(SB), CX		
  0x41fa6b		48890c24		MOVQ CX, 0(SP)				
  0x41fa6f		4889442408		MOVQ AX, 0x8(SP)			
  0x41fa74		e817ffffff		CALL runtime.panicCheckMalloc(SB)	
	panic(indexError)
  0x41fa79		488b0500600800		MOVQ runtime.indexError(SB), AX		
  0x41fa80		488b0d01600800		MOVQ runtime.indexError+8(SB), CX	
  0x41fa87		4885c0			TESTQ AX, AX				
  0x41fa8a		7404			JE 0x41fa90				
  0x41fa8c		488b4008		MOVQ 0x8(AX), AX			
  0x41fa90		48890424		MOVQ AX, 0(SP)				
  0x41fa94		48894c2408		MOVQ CX, 0x8(SP)			
  0x41fa99		e8920f0000		CALL runtime.gopanic(SB)		
  0x41fa9e		0f0b			UD2					
func panicindex() {
  0x41faa0		e8cb4a0200		CALL runtime.morestack_noctxt(SB)	
  0x41faa5		eb99			JMP runtime.panicindex(SB)		

TEXT runtime.panicslice(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func panicslice() {
  0x41fab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fab9		483b6110		CMPQ 0x10(CX), SP	
  0x41fabd		7651			JBE 0x41fb10		
  0x41fabf		4883ec18		SUBQ $0x18, SP		
  0x41fac3		48896c2410		MOVQ BP, 0x10(SP)	
  0x41fac8		488d6c2410		LEAQ 0x10(SP), BP	
	panicCheckMalloc(sliceError)
  0x41facd		488b05e45f0800		MOVQ runtime.sliceError+8(SB), AX	
  0x41fad4		488b0dd55f0800		MOVQ runtime.sliceError(SB), CX		
  0x41fadb		48890c24		MOVQ CX, 0(SP)				
  0x41fadf		4889442408		MOVQ AX, 0x8(SP)			
  0x41fae4		e8a7feffff		CALL runtime.panicCheckMalloc(SB)	
	panic(sliceError)
  0x41fae9		488b05c05f0800		MOVQ runtime.sliceError(SB), AX		
  0x41faf0		488b0dc15f0800		MOVQ runtime.sliceError+8(SB), CX	
  0x41faf7		4885c0			TESTQ AX, AX				
  0x41fafa		7404			JE 0x41fb00				
  0x41fafc		488b4008		MOVQ 0x8(AX), AX			
  0x41fb00		48890424		MOVQ AX, 0(SP)				
  0x41fb04		48894c2408		MOVQ CX, 0x8(SP)			
  0x41fb09		e8220f0000		CALL runtime.gopanic(SB)		
  0x41fb0e		0f0b			UD2					
func panicslice() {
  0x41fb10		e85b4a0200		CALL runtime.morestack_noctxt(SB)	
  0x41fb15		eb99			JMP runtime.panicslice(SB)		

TEXT runtime.panicdivide(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func panicdivide() {
  0x41fb20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fb29		483b6110		CMPQ 0x10(CX), SP	
  0x41fb2d		7651			JBE 0x41fb80		
  0x41fb2f		4883ec18		SUBQ $0x18, SP		
  0x41fb33		48896c2410		MOVQ BP, 0x10(SP)	
  0x41fb38		488d6c2410		LEAQ 0x10(SP), BP	
	panicCheckMalloc(divideError)
  0x41fb3d		488b05245f0800		MOVQ runtime.divideError+8(SB), AX	
  0x41fb44		488b0d155f0800		MOVQ runtime.divideError(SB), CX	
  0x41fb4b		48890c24		MOVQ CX, 0(SP)				
  0x41fb4f		4889442408		MOVQ AX, 0x8(SP)			
  0x41fb54		e837feffff		CALL runtime.panicCheckMalloc(SB)	
	panic(divideError)
  0x41fb59		488b05005f0800		MOVQ runtime.divideError(SB), AX	
  0x41fb60		488b0d015f0800		MOVQ runtime.divideError+8(SB), CX	
  0x41fb67		4885c0			TESTQ AX, AX				
  0x41fb6a		7404			JE 0x41fb70				
  0x41fb6c		488b4008		MOVQ 0x8(AX), AX			
  0x41fb70		48890424		MOVQ AX, 0(SP)				
  0x41fb74		48894c2408		MOVQ CX, 0x8(SP)			
  0x41fb79		e8b20e0000		CALL runtime.gopanic(SB)		
  0x41fb7e		0f0b			UD2					
func panicdivide() {
  0x41fb80		e8eb490200		CALL runtime.morestack_noctxt(SB)	
  0x41fb85		eb99			JMP runtime.panicdivide(SB)		

TEXT runtime.panicoverflow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func panicoverflow() {
  0x41fb90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fb99		483b6110		CMPQ 0x10(CX), SP	
  0x41fb9d		7651			JBE 0x41fbf0		
  0x41fb9f		4883ec18		SUBQ $0x18, SP		
  0x41fba3		48896c2410		MOVQ BP, 0x10(SP)	
  0x41fba8		488d6c2410		LEAQ 0x10(SP), BP	
	panicCheckMalloc(overflowError)
  0x41fbad		488b05f45e0800		MOVQ runtime.overflowError+8(SB), AX	
  0x41fbb4		488b0de55e0800		MOVQ runtime.overflowError(SB), CX	
  0x41fbbb		48890c24		MOVQ CX, 0(SP)				
  0x41fbbf		4889442408		MOVQ AX, 0x8(SP)			
  0x41fbc4		e8c7fdffff		CALL runtime.panicCheckMalloc(SB)	
	panic(overflowError)
  0x41fbc9		488b05d05e0800		MOVQ runtime.overflowError(SB), AX	
  0x41fbd0		488b0dd15e0800		MOVQ runtime.overflowError+8(SB), CX	
  0x41fbd7		4885c0			TESTQ AX, AX				
  0x41fbda		7404			JE 0x41fbe0				
  0x41fbdc		488b4008		MOVQ 0x8(AX), AX			
  0x41fbe0		48890424		MOVQ AX, 0(SP)				
  0x41fbe4		48894c2408		MOVQ CX, 0x8(SP)			
  0x41fbe9		e8420e0000		CALL runtime.gopanic(SB)		
  0x41fbee		0f0b			UD2					
func panicoverflow() {
  0x41fbf0		e87b490200		CALL runtime.morestack_noctxt(SB)	
  0x41fbf5		eb99			JMP runtime.panicoverflow(SB)		

TEXT runtime.panicfloat(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func panicfloat() {
  0x41fc00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fc09		483b6110		CMPQ 0x10(CX), SP	
  0x41fc0d		7651			JBE 0x41fc60		
  0x41fc0f		4883ec18		SUBQ $0x18, SP		
  0x41fc13		48896c2410		MOVQ BP, 0x10(SP)	
  0x41fc18		488d6c2410		LEAQ 0x10(SP), BP	
	panicCheckMalloc(floatError)
  0x41fc1d		488b05545e0800		MOVQ runtime.floatError+8(SB), AX	
  0x41fc24		488b0d455e0800		MOVQ runtime.floatError(SB), CX		
  0x41fc2b		48890c24		MOVQ CX, 0(SP)				
  0x41fc2f		4889442408		MOVQ AX, 0x8(SP)			
  0x41fc34		e857fdffff		CALL runtime.panicCheckMalloc(SB)	
	panic(floatError)
  0x41fc39		488b05305e0800		MOVQ runtime.floatError(SB), AX		
  0x41fc40		488b0d315e0800		MOVQ runtime.floatError+8(SB), CX	
  0x41fc47		4885c0			TESTQ AX, AX				
  0x41fc4a		7404			JE 0x41fc50				
  0x41fc4c		488b4008		MOVQ 0x8(AX), AX			
  0x41fc50		48890424		MOVQ AX, 0(SP)				
  0x41fc54		48894c2408		MOVQ CX, 0x8(SP)			
  0x41fc59		e8d20d0000		CALL runtime.gopanic(SB)		
  0x41fc5e		0f0b			UD2					
func panicfloat() {
  0x41fc60		e80b490200		CALL runtime.morestack_noctxt(SB)	
  0x41fc65		eb99			JMP runtime.panicfloat(SB)		

TEXT runtime.panicmem(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func panicmem() {
  0x41fc70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fc79		483b6110		CMPQ 0x10(CX), SP	
  0x41fc7d		7651			JBE 0x41fcd0		
  0x41fc7f		4883ec18		SUBQ $0x18, SP		
  0x41fc83		48896c2410		MOVQ BP, 0x10(SP)	
  0x41fc88		488d6c2410		LEAQ 0x10(SP), BP	
	panicCheckMalloc(memoryError)
  0x41fc8d		488b05045e0800		MOVQ runtime.memoryError+8(SB), AX	
  0x41fc94		488b0df55d0800		MOVQ runtime.memoryError(SB), CX	
  0x41fc9b		48890c24		MOVQ CX, 0(SP)				
  0x41fc9f		4889442408		MOVQ AX, 0x8(SP)			
  0x41fca4		e8e7fcffff		CALL runtime.panicCheckMalloc(SB)	
	panic(memoryError)
  0x41fca9		488b05e05d0800		MOVQ runtime.memoryError(SB), AX	
  0x41fcb0		488b0de15d0800		MOVQ runtime.memoryError+8(SB), CX	
  0x41fcb7		4885c0			TESTQ AX, AX				
  0x41fcba		7404			JE 0x41fcc0				
  0x41fcbc		488b4008		MOVQ 0x8(AX), AX			
  0x41fcc0		48890424		MOVQ AX, 0(SP)				
  0x41fcc4		48894c2408		MOVQ CX, 0x8(SP)			
  0x41fcc9		e8620d0000		CALL runtime.gopanic(SB)		
  0x41fcce		0f0b			UD2					
func panicmem() {
  0x41fcd0		e89b480200		CALL runtime.morestack_noctxt(SB)	
  0x41fcd5		eb99			JMP runtime.panicmem(SB)		

TEXT runtime.throwinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func throwinit() {
  0x41fce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fce9		483b6110		CMPQ 0x10(CX), SP	
  0x41fced		7629			JBE 0x41fd18		
  0x41fcef		4883ec18		SUBQ $0x18, SP		
  0x41fcf3		48896c2410		MOVQ BP, 0x10(SP)	
  0x41fcf8		488d6c2410		LEAQ 0x10(SP), BP	
	throw("recursive call during initialization - linker skew")
  0x41fcfd		488d0552dd0400		LEAQ 0x4dd52(IP), AX	
  0x41fd04		48890424		MOVQ AX, 0(SP)		
  0x41fd08		48c744240832000000	MOVQ $0x32, 0x8(SP)	
  0x41fd11		e8ba140000		CALL runtime.throw(SB)	
  0x41fd16		0f0b			UD2			
func throwinit() {
  0x41fd18		e853480200		CALL runtime.morestack_noctxt(SB)	
  0x41fd1d		ebc1			JMP runtime.throwinit(SB)		

TEXT runtime.deferproc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn
  0x41fd20		4883ec28		SUBQ $0x28, SP		
  0x41fd24		48896c2420		MOVQ BP, 0x20(SP)	
  0x41fd29		488d6c2420		LEAQ 0x20(SP), BP	
	if getg().m.curg != getg() {
  0x41fd2e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41fd37		488b4830		MOVQ 0x30(AX), CX	
  0x41fd3b		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x41fd42		4839c1			CMPQ AX, CX		
  0x41fd45		0f85e2000000		JNE 0x41fe2d		
	argp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)
  0x41fd4b		488d442438		LEAQ 0x38(SP), AX	
  0x41fd50		4889442418		MOVQ AX, 0x18(SP)	
	d := newdefer(siz)
  0x41fd55		8b4c2430		MOVL 0x30(SP), CX		
  0x41fd59		890c24			MOVL CX, 0(SP)			
  0x41fd5c		e8bf030000		CALL runtime.newdefer(SB)	
  0x41fd61		488b442408		MOVQ 0x8(SP), AX		
	if d._panic != nil {
  0x41fd66		488b4820		MOVQ 0x20(AX), CX	
  0x41fd6a		4885c9			TESTQ CX, CX		
  0x41fd6d		0f859f000000		JNE 0x41fe12		
	d.fn = fn
  0x41fd73		8b0d973c0a00		MOVL runtime.writeBarrier(SB), CX	
  0x41fd79		488b542438		MOVQ 0x38(SP), DX			
  0x41fd7e		488d7818		LEAQ 0x18(AX), DI			
  0x41fd82		85c9			TESTL CX, CX				
  0x41fd84		7579			JNE 0x41fdff				
  0x41fd86		48895018		MOVQ DX, 0x18(AX)			
	d.pc = callerpc
  0x41fd8a		488b4c2428		MOVQ 0x28(SP), CX	
  0x41fd8f		48894810		MOVQ CX, 0x10(AX)	
	d.sp = sp
  0x41fd93		488d4c2430		LEAQ 0x30(SP), CX	
  0x41fd98		48894808		MOVQ CX, 0x8(AX)	
	switch siz {
  0x41fd9c		8b4c2430		MOVL 0x30(SP), CX	
	case 0:
  0x41fda0		85c9			TESTL CX, CX		
  0x41fda2		750f			JNE 0x41fdb3		
	return0()
  0x41fda4		e8d76a0200		CALL runtime.return0(SB)	
}
  0x41fda9		488b6c2420		MOVQ 0x20(SP), BP	
  0x41fdae		4883c428		ADDQ $0x28, SP		
  0x41fdb2		c3			RET			
  0x41fdb3		488b542418		MOVQ 0x18(SP), DX	
	argp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)
  0x41fdb8		4883c208		ADDQ $0x8, DX		
	case sys.PtrSize:
  0x41fdbc		83f908			CMPL $0x8, CX		
  0x41fdbf		7516			JNE 0x41fdd7		
	if d.siz == 0 {
  0x41fdc1		8b08			MOVL 0(AX), CX		
  0x41fdc3		85c9			TESTL CX, CX		
  0x41fdc5		750a			JNE 0x41fdd1		
  0x41fdc7		31c0			XORL AX, AX		
		*(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp))
  0x41fdc9		488b0a			MOVQ 0(DX), CX		
  0x41fdcc		488908			MOVQ CX, 0(AX)		
	switch siz {
  0x41fdcf		ebd3			JMP 0x41fda4		
	return unsafe.Pointer(uintptr(p) + x)
  0x41fdd1		4883c030		ADDQ $0x30, AX		
		*(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp))
  0x41fdd5		ebf2			JMP 0x41fdc9		
	if d.siz == 0 {
  0x41fdd7		8b08			MOVL 0(AX), CX		
  0x41fdd9		85c9			TESTL CX, CX		
  0x41fddb		751c			JNE 0x41fdf9		
  0x41fddd		31c0			XORL AX, AX		
		memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz))
  0x41fddf		48890424		MOVQ AX, 0(SP)			
  0x41fde3		4889542408		MOVQ DX, 0x8(SP)		
  0x41fde8		4863442430		MOVSXD 0x30(SP), AX		
  0x41fded		4889442410		MOVQ AX, 0x10(SP)		
  0x41fdf2		e809730200		CALL runtime.memmove(SB)	
	switch siz {
  0x41fdf7		ebab			JMP 0x41fda4		
	return unsafe.Pointer(uintptr(p) + x)
  0x41fdf9		4883c030		ADDQ $0x30, AX		
		memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz))
  0x41fdfd		ebe0			JMP 0x41fddf		
  0x41fdff		4889c1			MOVQ AX, CX		
  0x41fe02		4889d0			MOVQ DX, AX		
	d.fn = fn
  0x41fe05		e8966a0200		CALL runtime.gcWriteBarrier(SB)	
  0x41fe0a		4889c8			MOVQ CX, AX			
  0x41fe0d		e978ffffff		JMP 0x41fd8a			
		throw("deferproc: d.panic != nil after newdefer")
  0x41fe12		488d0575d40400		LEAQ 0x4d475(IP), AX	
  0x41fe19		48890424		MOVQ AX, 0(SP)		
  0x41fe1d		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x41fe26		e8a5130000		CALL runtime.throw(SB)	
  0x41fe2b		0f0b			UD2			
		throw("defer on system stack")
  0x41fe2d		488d056ab40400		LEAQ 0x4b46a(IP), AX	
  0x41fe34		48890424		MOVQ AX, 0(SP)		
  0x41fe38		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x41fe41		e88a130000		CALL runtime.throw(SB)	
  0x41fe46		0f0b			UD2			

TEXT runtime.testdefersizes(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func testdefersizes() {
  0x41fe50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fe59		483b6110		CMPQ 0x10(CX), SP	
  0x41fe5d		0f8633020000		JBE 0x420096		
  0x41fe63		4883ec48		SUBQ $0x48, SP		
  0x41fe67		48896c2440		MOVQ BP, 0x40(SP)	
  0x41fe6c		488d6c2440		LEAQ 0x40(SP), BP	
	var m [len(p{}.deferpool)]int32
  0x41fe71		48c744242c00000000	MOVQ $0x0, 0x2c(SP)	
  0x41fe7a		0f57c0			XORPS X0, X0		
  0x41fe7d		0f11442430		MOVUPS X0, 0x30(SP)	
  0x41fe82		31c0			XORL AX, AX		
	for i := range m {
  0x41fe84		eb13			JMP 0x41fe99		
  0x41fe86		4889c1			MOVQ AX, CX		
		m[i] = -1
  0x41fe89		48c1e002		SHLQ $0x2, AX			
  0x41fe8d		c744042cffffffff	MOVL $-0x1, 0x2c(SP)(AX*1)	
	for i := range m {
  0x41fe95		488d4101		LEAQ 0x1(CX), AX	
  0x41fe99		4883f805		CMPQ $0x5, AX		
  0x41fe9d		7ce7			JL 0x41fe86		
  0x41fe9f		31c0			XORL AX, AX		
		defersc := deferclass(i)
  0x41fea1		eb03			JMP 0x41fea6		
	for i := uintptr(0); ; i++ {
  0x41fea3		48ffc0			INCQ AX			
	if siz <= minDeferArgs {
  0x41fea6		4885c0			TESTQ AX, AX		
  0x41fea9		0f871e010000		JA 0x41ffcd		
  0x41feaf		31c9			XORL CX, CX		
		if defersc >= uintptr(len(m)) {
  0x41feb1		4883f905		CMPQ $0x5, CX		
  0x41feb5		0f8308010000		JAE 0x41ffc3		
	if siz <= minDeferArgs {
  0x41febb		4885c0			TESTQ AX, AX		
	if siz <= minDeferArgs {
  0x41febe		0f87f6000000		JA 0x41ffba		
  0x41fec4		ba30000000		MOVL $0x30, DX		
	if size < _MaxSmallSize {
  0x41fec9		4881fa00800000		CMPQ $0x8000, DX	
  0x41fed0		0f83a4000000		JAE 0x41ff7a		
		if size <= smallSizeMax-8 {
  0x41fed6		4881faf8030000		CMPQ $0x3f8, DX		
  0x41fedd		775a			JA 0x41ff39		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x41fedf		4883c207		ADDQ $0x7, DX				
  0x41fee3		48c1ea03		SHRQ $0x3, DX				
  0x41fee7		4881fa81000000		CMPQ $0x81, DX				
  0x41feee		0f839b010000		JAE 0x42008f				
  0x41fef4		488d1d25520800		LEAQ runtime.size_to_class8(SB), BX	
  0x41fefb		0fb6141a		MOVZX 0(DX)(BX*1), DX			
  0x41feff		4883fa43		CMPQ $0x43, DX				
  0x41ff03		0f8386010000		JAE 0x42008f				
  0x41ff09		488d35b0520800		LEAQ runtime.class_to_size(SB), SI	
  0x41ff10		0fb71456		MOVZX 0(SI)(DX*2), DX			
		if m[defersc] < 0 {
  0x41ff14		8b7c8c2c		MOVL 0x2c(SP)(CX*4), DI	
  0x41ff18		4989c8			MOVQ CX, R8		
  0x41ff1b		48c1e102		SHLQ $0x2, CX		
  0x41ff1f		85ff			TESTL DI, DI		
  0x41ff21		7d09			JGE 0x41ff2c		
			m[defersc] = int32(siz)
  0x41ff23		89540c2c		MOVL DX, 0x2c(SP)(CX*1)	
			continue
  0x41ff27		e977ffffff		JMP 0x41fea3		
		if m[defersc] != int32(siz) {
  0x41ff2c		39d7			CMPL DX, DI		
  0x41ff2e		0f85a6000000		JNE 0x41ffda		
  0x41ff34		e96affffff		JMP 0x41fea3		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x41ff39		4881c27ffcffff		ADDQ $-0x381, DX			
  0x41ff40		48c1ea07		SHRQ $0x7, DX				
  0x41ff44		4881faf9000000		CMPQ $0xf9, DX				
  0x41ff4b		0f8337010000		JAE 0x420088				
  0x41ff51		488d1d08530800		LEAQ runtime.size_to_class128(SB), BX	
  0x41ff58		0fb6141a		MOVZX 0(DX)(BX*1), DX			
  0x41ff5c		4883fa43		CMPQ $0x43, DX				
  0x41ff60		0f8322010000		JAE 0x420088				
  0x41ff66		488d3553520800		LEAQ runtime.class_to_size(SB), SI	
  0x41ff6d		0fb71456		MOVZX 0(SI)(DX*2), DX			
  0x41ff71		488d1da8510800		LEAQ runtime.size_to_class8(SB), BX	
		siz := roundupsize(totaldefersize(i))
  0x41ff78		eb9a			JMP 0x41ff14		
	if size+_PageSize < size {
  0x41ff7a		488d9a00200000		LEAQ 0x2000(DX), BX			
  0x41ff81		4839d3			CMPQ DX, BX				
  0x41ff84		7313			JAE 0x41ff99				
  0x41ff86		488d1d93510800		LEAQ runtime.size_to_class8(SB), BX	
  0x41ff8d		488d352c520800		LEAQ runtime.class_to_size(SB), SI	
		siz := roundupsize(totaldefersize(i))
  0x41ff94		e97bffffff		JMP 0x41ff14		
	return (n + a - 1) &^ (a - 1)
  0x41ff99		4881c2ff1f0000		ADDQ $0x1fff, DX			
  0x41ffa0		4881e200e0ffff		ANDQ $-0x2000, DX			
  0x41ffa7		488d1d72510800		LEAQ runtime.size_to_class8(SB), BX	
  0x41ffae		488d350b520800		LEAQ runtime.class_to_size(SB), SI	
		siz := roundupsize(totaldefersize(i))
  0x41ffb5		e95affffff		JMP 0x41ff14		
	return deferHeaderSize + siz
  0x41ffba		488d5030		LEAQ 0x30(AX), DX	
		siz := roundupsize(totaldefersize(i))
  0x41ffbe		e906ffffff		JMP 0x41fec9		
  0x41ffc3		488b6c2440		MOVQ 0x40(SP), BP	
  0x41ffc8		4883c448		ADDQ $0x48, SP		
  0x41ffcc		c3			RET			
	return (siz - minDeferArgs + 15) / 16
  0x41ffcd		488d480f		LEAQ 0xf(AX), CX	
  0x41ffd1		48c1e904		SHRQ $0x4, CX		
		defersc := deferclass(i)
  0x41ffd5		e9d7feffff		JMP 0x41feb1		
  0x41ffda		4c89442420		MOVQ R8, 0x20(SP)	
  0x41ffdf		4889542410		MOVQ DX, 0x10(SP)	
  0x41ffe4		4889442418		MOVQ AX, 0x18(SP)	
			print("bad defer size class: i=", i, " siz=", siz, " defersc=", defersc, "\n")
  0x41ffe9		e8121b0000		CALL runtime.printlock(SB)	
  0x41ffee		488d0569b80400		LEAQ 0x4b869(IP), AX		
  0x41fff5		48890424		MOVQ AX, 0(SP)			
  0x41fff9		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x420002		e839240000		CALL runtime.printstring(SB)	
  0x420007		488b442418		MOVQ 0x18(SP), AX		
  0x42000c		48890424		MOVQ AX, 0(SP)			
  0x420010		e85b210000		CALL runtime.printuint(SB)	
  0x420015		488d05609d0400		LEAQ 0x49d60(IP), AX		
  0x42001c		48890424		MOVQ AX, 0(SP)			
  0x420020		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x420029		e812240000		CALL runtime.printstring(SB)	
  0x42002e		488b442410		MOVQ 0x10(SP), AX		
  0x420033		48890424		MOVQ AX, 0(SP)			
  0x420037		e834210000		CALL runtime.printuint(SB)	
  0x42003c		488d0517a00400		LEAQ 0x4a017(IP), AX		
  0x420043		48890424		MOVQ AX, 0(SP)			
  0x420047		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x420050		e8eb230000		CALL runtime.printstring(SB)	
  0x420055		488b442420		MOVQ 0x20(SP), AX		
  0x42005a		48890424		MOVQ AX, 0(SP)			
  0x42005e		e80d210000		CALL runtime.printuint(SB)	
  0x420063		e8281d0000		CALL runtime.printnl(SB)	
  0x420068		e8131b0000		CALL runtime.printunlock(SB)	
			throw("bad defer size class")
  0x42006d		488d05f5af0400		LEAQ 0x4aff5(IP), AX	
  0x420074		48890424		MOVQ AX, 0(SP)		
  0x420078		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x420081		e84a110000		CALL runtime.throw(SB)	
  0x420086		0f0b			UD2			
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x420088		e8b3f9ffff		CALL runtime.panicindex(SB)	
  0x42008d		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x42008f		e8acf9ffff		CALL runtime.panicindex(SB)	
  0x420094		0f0b			UD2				
func testdefersizes() {
  0x420096		e8d5440200		CALL runtime.morestack_noctxt(SB)	
  0x42009b		e9b0fdffff		JMP runtime.testdefersizes(SB)		

TEXT runtime.init.3(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func init() {
  0x4200a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4200a9		483b6110		CMPQ 0x10(CX), SP	
  0x4200ad		765d			JBE 0x42010c		
  0x4200af		4883ec18		SUBQ $0x18, SP		
  0x4200b3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4200b8		488d6c2410		LEAQ 0x10(SP), BP	
	var x interface{}
  0x4200bd		0f57c0			XORPS X0, X0		
  0x4200c0		0f110424		MOVUPS X0, 0(SP)	
	x = (*_defer)(nil)
  0x4200c4		488b0d954a0500		MOVQ runtime.statictmp_20(SB), CX	
  0x4200cb		488d15ae3a0300		LEAQ 0x33aae(IP), DX			
  0x4200d2		48891424		MOVQ DX, 0(SP)				
  0x4200d6		48894c2408		MOVQ CX, 0x8(SP)			
	deferType = (*(**ptrtype)(unsafe.Pointer(&x))).elem
  0x4200db		488b0c24		MOVQ 0(SP), CX				
  0x4200df		8b152b390a00		MOVL runtime.writeBarrier(SB), DX	
  0x4200e5		488b4130		MOVQ 0x30(CX), AX			
  0x4200e9		85d2			TESTL DX, DX				
  0x4200eb		7511			JNE 0x4200fe				
  0x4200ed		48890554750800		MOVQ AX, runtime.deferType(SB)		
}
  0x4200f4		488b6c2410		MOVQ 0x10(SP), BP	
  0x4200f9		4883c418		ADDQ $0x18, SP		
  0x4200fd		c3			RET			
	deferType = (*(**ptrtype)(unsafe.Pointer(&x))).elem
  0x4200fe		488d3d43750800		LEAQ runtime.deferType(SB), DI	
  0x420105		e896670200		CALL runtime.gcWriteBarrier(SB)	
  0x42010a		ebe8			JMP 0x4200f4			
func init() {
  0x42010c		e85f440200		CALL runtime.morestack_noctxt(SB)	
  0x420111		eb8d			JMP runtime.init.3(SB)			

TEXT runtime.newdefer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func newdefer(siz int32) *_defer {
  0x420120		4883ec60		SUBQ $0x60, SP		
  0x420124		48896c2458		MOVQ BP, 0x58(SP)	
  0x420129		488d6c2458		LEAQ 0x58(SP), BP	
	var d *_defer
  0x42012e		48c744241800000000	MOVQ $0x0, 0x18(SP)	
func newdefer(siz int32) *_defer {
  0x420137		8b4c2468		MOVL 0x68(SP), CX	
	sc := deferclass(uintptr(siz))
  0x42013b		4863d1			MOVSXD CX, DX		
	if siz <= minDeferArgs {
  0x42013e		4885d2			TESTQ DX, DX		
  0x420141		0f87a9010000		JA 0x4202f0		
  0x420147		31c0			XORL AX, AX		
	gp := getg()
  0x420149		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x420152		4889542410		MOVQ DX, 0x10(SP)	
	if sc < uintptr(len(p{}.deferpool)) {
  0x420157		4883f805		CMPQ $0x5, AX		
  0x42015b		0f839d000000		JAE 0x4201fe		
		pp := gp.m.p.ptr()
  0x420161		488b5a30		MOVQ 0x30(DX), BX	
  0x420165		488b9bd0000000		MOVQ 0xd0(BX), BX	
		if len(pp.deferpool[sc]) == 0 && sched.deferpool[sc] != nil {
  0x42016c		8403			TESTB AL, 0(BX)			
  0x42016e		488d3440		LEAQ 0(AX)(AX*2), SI		
  0x420172		4c8b44f360		MOVQ 0x60(BX)(SI*8), R8		
  0x420177		4d85c0			TESTQ R8, R8			
  0x42017a		7518			JNE 0x420194			
  0x42017c		4c8d059d770800		LEAQ runtime.sched(SB), R8	
  0x420183		4d8b84c0a8000000	MOVQ 0xa8(R8)(AX*8), R8		
  0x42018b		4d85c0			TESTQ R8, R8			
  0x42018e		0f8516010000		JNE 0x4202aa			
		if n := len(pp.deferpool[sc]); n > 0 {
  0x420194		4c8b44f360		MOVQ 0x60(BX)(SI*8), R8	
  0x420199		4c8b4cf358		MOVQ 0x58(BX)(SI*8), R9	
  0x42019e		4d85c0			TESTQ R8, R8		
  0x4201a1		7e5b			JLE 0x4201fe		
			d = pp.deferpool[sc][n-1]
  0x4201a3		4d8d50ff		LEAQ -0x1(R8), R10	
  0x4201a7		4d39c2			CMPQ R8, R10		
  0x4201aa		0f835b010000		JAE 0x42030b		
  0x4201b0		4f8b4cc1f8		MOVQ -0x8(R9)(R8*8), R9	
  0x4201b5		4c894c2418		MOVQ R9, 0x18(SP)	
			pp.deferpool[sc][n-1] = nil
  0x4201ba		4c8b4cf358		MOVQ 0x58(BX)(SI*8), R9			
  0x4201bf		4c8b5cf360		MOVQ 0x60(BX)(SI*8), R11		
  0x4201c4		4d39da			CMPQ R11, R10				
  0x4201c7		0f8337010000		JAE 0x420304				
  0x4201cd		4b8d7cc1f8		LEAQ -0x8(R9)(R8*8), DI			
  0x4201d2		448b1d37380a00		MOVL runtime.writeBarrier(SB), R11	
  0x4201d9		4585db			TESTL R11, R11				
  0x4201dc		0f85bc000000		JNE 0x42029e				
  0x4201e2		4bc744c1f800000000	MOVQ $0x0, -0x8(R9)(R8*8)		
			pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x4201eb		4c8b44f368		MOVQ 0x68(BX)(SI*8), R8		
  0x4201f0		4d39c2			CMPQ R8, R10			
  0x4201f3		0f8704010000		JA 0x4202fd			
  0x4201f9		4c8954f360		MOVQ R10, 0x60(BX)(SI*8)	
	if d == nil {
  0x4201fe		488b5c2418		MOVQ 0x18(SP), BX	
  0x420203		4885db			TESTQ BX, BX		
  0x420206		7460			JE 0x420268		
	d.siz = siz
  0x420208		488b5c2418		MOVQ 0x18(SP), BX	
  0x42020d		890b			MOVL CX, 0(BX)		
	d.link = gp._defer
  0x42020f		488b4c2418		MOVQ 0x18(SP), CX			
  0x420214		8401			TESTB AL, 0(CX)				
  0x420216		8b1df4370a00		MOVL runtime.writeBarrier(SB), BX	
  0x42021c		488d7928		LEAQ 0x28(CX), DI			
  0x420220		488b4228		MOVQ 0x28(DX), AX			
  0x420224		488d7228		LEAQ 0x28(DX), SI			
  0x420228		85db			TESTL BX, BX				
  0x42022a		7535			JNE 0x420261				
  0x42022c		48894128		MOVQ AX, 0x28(CX)			
	gp._defer = d
  0x420230		8b0dda370a00		MOVL runtime.writeBarrier(SB), CX	
  0x420236		488b442418		MOVQ 0x18(SP), AX			
  0x42023b		85c9			TESTL CX, CX				
  0x42023d		7518			JNE 0x420257				
  0x42023f		48894228		MOVQ AX, 0x28(DX)			
	return d
  0x420243		488b442418		MOVQ 0x18(SP), AX	
  0x420248		4889442470		MOVQ AX, 0x70(SP)	
  0x42024d		488b6c2458		MOVQ 0x58(SP), BP	
  0x420252		4883c460		ADDQ $0x60, SP		
  0x420256		c3			RET			
  0x420257		4889f7			MOVQ SI, DI		
	gp._defer = d
  0x42025a		e841660200		CALL runtime.gcWriteBarrier(SB)	
  0x42025f		ebe2			JMP 0x420243			
	d.link = gp._defer
  0x420261		e83a660200		CALL runtime.gcWriteBarrier(SB)	
  0x420266		ebc8			JMP 0x420230			
		systemstack(func() {
  0x420268		488d05812b0200		LEAQ runtime.newdefer.func2(SB), AX	
  0x42026f		4889442428		MOVQ AX, 0x28(SP)			
  0x420274		894c2430		MOVL CX, 0x30(SP)			
  0x420278		488d442418		LEAQ 0x18(SP), AX			
  0x42027d		4889442438		MOVQ AX, 0x38(SP)			
  0x420282		488d442428		LEAQ 0x28(SP), AX			
  0x420287		48890424		MOVQ AX, 0(SP)				
  0x42028b		e890410200		CALL runtime.systemstack(SB)		
	if d == nil {
  0x420290		8b4c2468		MOVL 0x68(SP), CX	
  0x420294		488b542410		MOVQ 0x10(SP), DX	
		systemstack(func() {
  0x420299		e96affffff		JMP 0x420208		
			pp.deferpool[sc][n-1] = nil
  0x42029e		31c0			XORL AX, AX			
  0x4202a0		e8fb650200		CALL runtime.gcWriteBarrier(SB)	
  0x4202a5		e941ffffff		JMP 0x4201eb			
  0x4202aa		48895c2420		MOVQ BX, 0x20(SP)		
  0x4202af		4889742408		MOVQ SI, 0x8(SP)		
			systemstack(func() {
  0x4202b4		488d0d55290200		LEAQ runtime.newdefer.func1(SB), CX	
  0x4202bb		48894c2440		MOVQ CX, 0x40(SP)			
  0x4202c0		48895c2448		MOVQ BX, 0x48(SP)			
  0x4202c5		4889442450		MOVQ AX, 0x50(SP)			
  0x4202ca		488d442440		LEAQ 0x40(SP), AX			
  0x4202cf		48890424		MOVQ AX, 0(SP)				
  0x4202d3		e848410200		CALL runtime.systemstack(SB)		
		if len(pp.deferpool[sc]) == 0 && sched.deferpool[sc] != nil {
  0x4202d8		8b4c2468		MOVL 0x68(SP), CX	
  0x4202dc		488b542410		MOVQ 0x10(SP), DX	
  0x4202e1		488b5c2420		MOVQ 0x20(SP), BX	
  0x4202e6		488b742408		MOVQ 0x8(SP), SI	
			systemstack(func() {
  0x4202eb		e9a4feffff		JMP 0x420194		
	return (siz - minDeferArgs + 15) / 16
  0x4202f0		488d420f		LEAQ 0xf(DX), AX	
  0x4202f4		48c1e804		SHRQ $0x4, AX		
	sc := deferclass(uintptr(siz))
  0x4202f8		e94cfeffff		JMP 0x420149		
			pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x4202fd		e8aef7ffff		CALL runtime.panicslice(SB)	
  0x420302		0f0b			UD2				
			pp.deferpool[sc][n-1] = nil
  0x420304		e837f7ffff		CALL runtime.panicindex(SB)	
  0x420309		0f0b			UD2				
			d = pp.deferpool[sc][n-1]
  0x42030b		e830f7ffff		CALL runtime.panicindex(SB)	
  0x420310		0f0b			UD2				

TEXT runtime.freedefer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func freedefer(d *_defer) {
  0x420320		4881ec88000000		SUBQ $0x88, SP		
  0x420327		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x42032f		488dac2480000000	LEAQ 0x80(SP), BP	
  0x420337		488b842490000000	MOVQ 0x90(SP), AX	
	if d._panic != nil {
  0x42033f		488b4820		MOVQ 0x20(AX), CX	
  0x420343		488d5020		LEAQ 0x20(AX), DX	
  0x420347		4889542460		MOVQ DX, 0x60(SP)	
  0x42034c		4885c9			TESTQ CX, CX		
  0x42034f		0f850a020000		JNE 0x42055f		
	if d.fn != nil {
  0x420355		488b4818		MOVQ 0x18(AX), CX	
  0x420359		488d7818		LEAQ 0x18(AX), DI	
  0x42035d		48897c2458		MOVQ DI, 0x58(SP)	
  0x420362		4885c9			TESTQ CX, CX		
  0x420365		0f85d8010000		JNE 0x420543		
	sc := deferclass(uintptr(d.siz))
  0x42036b		486308			MOVSXD 0(AX), CX	
	if siz <= minDeferArgs {
  0x42036e		4885c9			TESTQ CX, CX		
  0x420371		0f87bf010000		JA 0x420536		
  0x420377		31c9			XORL CX, CX		
	if sc >= uintptr(len(p{}.deferpool)) {
  0x420379		4883f905		CMPQ $0x5, CX		
  0x42037d		0f83a3010000		JAE 0x420526		
	pp := getg().m.p.ptr()
  0x420383		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x42038c		488b5b30		MOVQ 0x30(BX), BX	
  0x420390		488b9bd0000000		MOVQ 0xd0(BX), BX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x420397		48895c2450		MOVQ BX, 0x50(SP)	
	if len(pp.deferpool[sc]) == cap(pp.deferpool[sc]) {
  0x42039c		8403			TESTB AL, 0(BX)			
  0x42039e		488d3449		LEAQ 0(CX)(CX*2), SI		
  0x4203a2		4889742440		MOVQ SI, 0x40(SP)		
  0x4203a7		4c8b44f368		MOVQ 0x68(BX)(SI*8), R8		
  0x4203ac		4c8b4cf360		MOVQ 0x60(BX)(SI*8), R9		
  0x4203b1		4c8d54f358		LEAQ 0x58(BX)(SI*8), R10	
  0x4203b6		4c89542448		MOVQ R10, 0x48(SP)		
  0x4203bb		4d39c1			CMPQ R8, R9			
  0x4203be		0f8418010000		JE 0x4204dc			
	d.siz = 0
  0x4203c4		c70000000000		MOVL $0x0, 0(AX)	
	d.started = false
  0x4203ca		c6400400		MOVB $0x0, 0x4(AX)	
	d.pc = 0
  0x4203ce		0f57c0			XORPS X0, X0		
  0x4203d1		0f114008		MOVUPS X0, 0x8(AX)	
	d.fn = nil
  0x4203d5		8b0d35360a00		MOVL runtime.writeBarrier(SB), CX	
	d.link = nil
  0x4203db		4c8d4028		LEAQ 0x28(AX), R8	
	d.fn = nil
  0x4203df		85c9			TESTL CX, CX		
  0x4203e1		0f85cf000000		JNE 0x4204b6		
	d._panic = nil
  0x4203e7		0f114018		MOVUPS X0, 0x18(AX)	
	d.link = nil
  0x4203eb		48c7402800000000	MOVQ $0x0, 0x28(AX)	
	pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x4203f3		488b4cf368		MOVQ 0x68(BX)(SI*8), CX			
  0x4203f8		488b54f360		MOVQ 0x60(BX)(SI*8), DX			
  0x4203fd		4c8b44f358		MOVQ 0x58(BX)(SI*8), R8			
  0x420402		4c8d4a01		LEAQ 0x1(DX), R9			
  0x420406		4939c9			CMPQ CX, R9				
  0x420409		7f32			JG 0x42043d				
  0x42040b		488d4a01		LEAQ 0x1(DX), CX			
  0x42040f		48894cf360		MOVQ CX, 0x60(BX)(SI*8)			
  0x420414		8b0df6350a00		MOVL runtime.writeBarrier(SB), CX	
  0x42041a		498d3cd0		LEAQ 0(R8)(DX*8), DI			
  0x42041e		85c9			TESTL CX, CX				
  0x420420		7514			JNE 0x420436				
  0x420422		498904d0		MOVQ AX, 0(R8)(DX*8)			
}
  0x420426		488bac2480000000	MOVQ 0x80(SP), BP	
  0x42042e		4881c488000000		ADDQ $0x88, SP		
  0x420435		c3			RET			
	pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x420436		e865640200		CALL runtime.gcWriteBarrier(SB)		
  0x42043b		ebe9			JMP 0x420426				
  0x42043d		488d053c370300		LEAQ 0x3373c(IP), AX			
  0x420444		48890424		MOVQ AX, 0(SP)				
  0x420448		4c89442408		MOVQ R8, 0x8(SP)			
  0x42044d		4889542410		MOVQ DX, 0x10(SP)			
  0x420452		48894c2418		MOVQ CX, 0x18(SP)			
  0x420457		4c894c2420		MOVQ R9, 0x20(SP)			
  0x42045c		e8ff330100		CALL runtime.growslice(SB)		
  0x420461		488b442428		MOVQ 0x28(SP), AX			
  0x420466		488b4c2430		MOVQ 0x30(SP), CX			
  0x42046b		488b542438		MOVQ 0x38(SP), DX			
  0x420470		488b5c2440		MOVQ 0x40(SP), BX			
  0x420475		488b742450		MOVQ 0x50(SP), SI			
  0x42047a		488954de68		MOVQ DX, 0x68(SI)(BX*8)			
  0x42047f		8b158b350a00		MOVL runtime.writeBarrier(SB), DX	
  0x420485		85d2			TESTL DX, DX				
  0x420487		7521			JNE 0x4204aa				
  0x420489		488944de58		MOVQ AX, 0x58(SI)(BX*8)			
  0x42048e		4889ca			MOVQ CX, DX				
  0x420491		4989c0			MOVQ AX, R8				
  0x420494		488b842490000000	MOVQ 0x90(SP), AX			
  0x42049c		4889df			MOVQ BX, DI				
  0x42049f		4889f3			MOVQ SI, BX				
  0x4204a2		4889fe			MOVQ DI, SI				
  0x4204a5		e961ffffff		JMP 0x42040b				
  0x4204aa		488b7c2448		MOVQ 0x48(SP), DI			
  0x4204af		e8ec630200		CALL runtime.gcWriteBarrier(SB)		
  0x4204b4		ebd8			JMP 0x42048e				
  0x4204b6		4889c1			MOVQ AX, CX				
	d.fn = nil
  0x4204b9		31c0			XORL AX, AX			
  0x4204bb		e8e0630200		CALL runtime.gcWriteBarrier(SB)	
  0x4204c0		4889d7			MOVQ DX, DI			
	d._panic = nil
  0x4204c3		31c0			XORL AX, AX			
  0x4204c5		e8d6630200		CALL runtime.gcWriteBarrier(SB)	
  0x4204ca		4c89c7			MOVQ R8, DI			
	d.link = nil
  0x4204cd		31c0			XORL AX, AX			
  0x4204cf		e8cc630200		CALL runtime.gcWriteBarrier(SB)	
  0x4204d4		4889c8			MOVQ CX, AX			
	d.fn = nil
  0x4204d7		e917ffffff		JMP 0x4203f3		
		systemstack(func() {
  0x4204dc		488d055d2a0200		LEAQ runtime.freedefer.func1(SB), AX	
  0x4204e3		4889442468		MOVQ AX, 0x68(SP)			
  0x4204e8		48895c2470		MOVQ BX, 0x70(SP)			
  0x4204ed		48894c2478		MOVQ CX, 0x78(SP)			
  0x4204f2		488d442468		LEAQ 0x68(SP), AX			
  0x4204f7		48890424		MOVQ AX, 0(SP)				
  0x4204fb		e8203f0200		CALL runtime.systemstack(SB)		
	if len(pp.deferpool[sc]) == cap(pp.deferpool[sc]) {
  0x420500		488b842490000000	MOVQ 0x90(SP), AX	
  0x420508		488b542460		MOVQ 0x60(SP), DX	
  0x42050d		488b5c2450		MOVQ 0x50(SP), BX	
  0x420512		488b742440		MOVQ 0x40(SP), SI	
  0x420517		488b7c2458		MOVQ 0x58(SP), DI	
  0x42051c		4c8b542448		MOVQ 0x48(SP), R10	
		systemstack(func() {
  0x420521		e99efeffff		JMP 0x4203c4		
		return
  0x420526		488bac2480000000	MOVQ 0x80(SP), BP	
  0x42052e		4881c488000000		ADDQ $0x88, SP		
  0x420535		c3			RET			
	return (siz - minDeferArgs + 15) / 16
  0x420536		4883c10f		ADDQ $0xf, CX		
  0x42053a		48c1e904		SHRQ $0x4, CX		
	sc := deferclass(uintptr(d.siz))
  0x42053e		e936feffff		JMP 0x420379		
		freedeferfn()
  0x420543		e878000000		CALL runtime.freedeferfn(SB)	
  0x420548		488b842490000000	MOVQ 0x90(SP), AX		
  0x420550		488b542460		MOVQ 0x60(SP), DX		
  0x420555		488b7c2458		MOVQ 0x58(SP), DI		
  0x42055a		e90cfeffff		JMP 0x42036b			
		freedeferpanic()
  0x42055f		e81c000000		CALL runtime.freedeferpanic(SB)	
  0x420564		488b842490000000	MOVQ 0x90(SP), AX		
  0x42056c		488b542460		MOVQ 0x60(SP), DX		
  0x420571		e9dffdffff		JMP 0x420355			

TEXT runtime.freedeferpanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func freedeferpanic() {
  0x420580		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420589		483b6110		CMPQ 0x10(CX), SP	
  0x42058d		7629			JBE 0x4205b8		
  0x42058f		4883ec18		SUBQ $0x18, SP		
  0x420593		48896c2410		MOVQ BP, 0x10(SP)	
  0x420598		488d6c2410		LEAQ 0x10(SP), BP	
	throw("freedefer with d._panic != nil")
  0x42059d		488d057bbf0400		LEAQ 0x4bf7b(IP), AX	
  0x4205a4		48890424		MOVQ AX, 0(SP)		
  0x4205a8		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x4205b1		e81a0c0000		CALL runtime.throw(SB)	
  0x4205b6		0f0b			UD2			
func freedeferpanic() {
  0x4205b8		e8b33f0200		CALL runtime.morestack_noctxt(SB)	
  0x4205bd		ebc1			JMP runtime.freedeferpanic(SB)		

TEXT runtime.freedeferfn(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func freedeferfn() {
  0x4205c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4205c9		483b6110		CMPQ 0x10(CX), SP	
  0x4205cd		7629			JBE 0x4205f8		
  0x4205cf		4883ec18		SUBQ $0x18, SP		
  0x4205d3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4205d8		488d6c2410		LEAQ 0x10(SP), BP	
	throw("freedefer with d.fn != nil")
  0x4205dd		488d052ab60400		LEAQ 0x4b62a(IP), AX	
  0x4205e4		48890424		MOVQ AX, 0(SP)		
  0x4205e8		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x4205f1		e8da0b0000		CALL runtime.throw(SB)	
  0x4205f6		0f0b			UD2			
func freedeferfn() {
  0x4205f8		e8733f0200		CALL runtime.morestack_noctxt(SB)	
  0x4205fd		ebc1			JMP runtime.freedeferfn(SB)		

TEXT runtime.deferreturn(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func deferreturn(arg0 uintptr) {
  0x420600		4883ec48		SUBQ $0x48, SP		
  0x420604		48896c2440		MOVQ BP, 0x40(SP)	
  0x420609		488d6c2440		LEAQ 0x40(SP), BP	
	gp := getg()
  0x42060e		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	d := gp._defer
  0x420617		488b5128		MOVQ 0x28(CX), DX	
  0x42061b		488d7928		LEAQ 0x28(CX), DI	
	if d == nil {
  0x42061f		4885d2			TESTQ DX, DX		
  0x420622		0f840c010000		JE 0x420734		
	if d.sp != sp {
  0x420628		488b5a08		MOVQ 0x8(DX), BX	
  0x42062c		488d742450		LEAQ 0x50(SP), SI	
  0x420631		4839f3			CMPQ SI, BX		
  0x420634		0f85f0000000		JNE 0x42072a		
	switch d.siz {
  0x42063a		8b1a			MOVL 0(DX), BX		
	case 0:
  0x42063c		85db			TESTL BX, BX		
  0x42063e		0f8586000000		JNE 0x4206ca		
	fn := d.fn
  0x420644		488b5a18		MOVQ 0x18(DX), BX	
  0x420648		488d7218		LEAQ 0x18(DX), SI	
	d.fn = nil
  0x42064c		448b05bd330a00		MOVL runtime.writeBarrier(SB), R8	
  0x420653		4585c0			TESTL R8, R8				
  0x420656		755d			JNE 0x4206b5				
  0x420658		48c7421800000000	MOVQ $0x0, 0x18(DX)			
  0x420660		48895c2420		MOVQ BX, 0x20(SP)			
	gp._defer = d.link
  0x420665		8401			TESTB AL, 0(CX)				
  0x420667		8b35a3330a00		MOVL runtime.writeBarrier(SB), SI	
  0x42066d		488b4228		MOVQ 0x28(DX), AX			
  0x420671		85f6			TESTL SI, SI				
  0x420673		7539			JNE 0x4206ae				
  0x420675		48894128		MOVQ AX, 0x28(CX)			
	freedefer(d)
  0x420679		48891424		MOVQ DX, 0(SP)			
  0x42067d		e89efcffff		CALL runtime.freedefer(SB)	
	jmpdefer(fn, uintptr(unsafe.Pointer(&arg0)))
  0x420682		488d442450		LEAQ 0x50(SP), AX		
  0x420687		4889442438		MOVQ AX, 0x38(SP)		
  0x42068c		488b442420		MOVQ 0x20(SP), AX		
  0x420691		48890424		MOVQ AX, 0(SP)			
  0x420695		488b442438		MOVQ 0x38(SP), AX		
  0x42069a		4889442408		MOVQ AX, 0x8(SP)		
  0x42069f		e8ec540200		CALL runtime.jmpdefer(SB)	
}
  0x4206a4		488b6c2440		MOVQ 0x40(SP), BP	
  0x4206a9		4883c448		ADDQ $0x48, SP		
  0x4206ad		c3			RET			
	gp._defer = d.link
  0x4206ae		e8ed610200		CALL runtime.gcWriteBarrier(SB)	
  0x4206b3		ebc4			JMP 0x420679			
  0x4206b5		4889f8			MOVQ DI, AX			
  0x4206b8		4889f7			MOVQ SI, DI			
  0x4206bb		4989c0			MOVQ AX, R8			
	d.fn = nil
  0x4206be		31c0			XORL AX, AX			
  0x4206c0		e8db610200		CALL runtime.gcWriteBarrier(SB)	
  0x4206c5		4c89c7			MOVQ R8, DI			
  0x4206c8		eb96			JMP 0x420660			
	case sys.PtrSize:
  0x4206ca		83fb08			CMPL $0x8, BX		
  0x4206cd		7519			JNE 0x4206e8		
	return unsafe.Pointer(uintptr(p) + x)
  0x4206cf		488d5a30		LEAQ 0x30(DX), BX	
		*(*uintptr)(unsafe.Pointer(&arg0)) = *(*uintptr)(deferArgs(d))
  0x4206d3		8403			TESTB AL, 0(BX)		
  0x4206d5		bb30000000		MOVL $0x30, BX		
  0x4206da		488b1c13		MOVQ 0(BX)(DX*1), BX	
  0x4206de		48895c2450		MOVQ BX, 0x50(SP)	
	switch d.siz {
  0x4206e3		e95cffffff		JMP 0x420644		
  0x4206e8		48894c2418		MOVQ CX, 0x18(SP)	
  0x4206ed		48897c2430		MOVQ DI, 0x30(SP)	
  0x4206f2		4889542428		MOVQ DX, 0x28(SP)	
		memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
  0x4206f7		4863c3			MOVSXD BX, AX		
  0x4206fa		4889442410		MOVQ AX, 0x10(SP)	
  0x4206ff		488d442450		LEAQ 0x50(SP), AX	
  0x420704		48890424		MOVQ AX, 0(SP)		
	return unsafe.Pointer(uintptr(p) + x)
  0x420708		488d4a30		LEAQ 0x30(DX), CX	
		memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
  0x42070c		48894c2408		MOVQ CX, 0x8(SP)		
  0x420711		e8ea690200		CALL runtime.memmove(SB)	
  0x420716		488b4c2418		MOVQ 0x18(SP), CX		
  0x42071b		488b542428		MOVQ 0x28(SP), DX		
  0x420720		488b7c2430		MOVQ 0x30(SP), DI		
	switch d.siz {
  0x420725		e91affffff		JMP 0x420644		
		return
  0x42072a		488b6c2440		MOVQ 0x40(SP), BP	
  0x42072f		4883c448		ADDQ $0x48, SP		
  0x420733		c3			RET			
		return
  0x420734		488b6c2440		MOVQ 0x40(SP), BP	
  0x420739		4883c448		ADDQ $0x48, SP		
  0x42073d		c3			RET			

TEXT runtime.preprintpanics(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func preprintpanics(p *_panic) {
  0x420740		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420749		483b6110		CMPQ 0x10(CX), SP	
  0x42074d		0f86cf010000		JBE 0x420922		
  0x420753		4883ec70		SUBQ $0x70, SP		
  0x420757		48896c2468		MOVQ BP, 0x68(SP)	
  0x42075c		488d6c2468		LEAQ 0x68(SP), BP	
	defer func() {
  0x420761		c7042400000000		MOVL $0x0, 0(SP)		
  0x420768		488d0549da0400		LEAQ 0x4da49(IP), AX		
  0x42076f		4889442408		MOVQ AX, 0x8(SP)		
  0x420774		e8a7f5ffff		CALL runtime.deferproc(SB)	
  0x420779		85c0			TESTL AX, AX			
  0x42077b		0f8591010000		JNE 0x420912			
  0x420781		488b442478		MOVQ 0x78(SP), AX		
	for p != nil {
  0x420786		eb04			JMP 0x42078c		
		p = p.link
  0x420788		488b4018		MOVQ 0x18(AX), AX	
	for p != nil {
  0x42078c		4885c0			TESTQ AX, AX		
  0x42078f		0f846d010000		JE 0x420902		
		switch v := p.arg.(type) {
  0x420795		488b4810		MOVQ 0x10(AX), CX		
  0x420799		488b5008		MOVQ 0x8(AX), DX		
  0x42079d		488d5810		LEAQ 0x10(AX), BX		
  0x4207a1		4885d2			TESTQ DX, DX			
  0x4207a4		74e2			JE 0x420788			
  0x4207a6		4889442478		MOVQ AX, 0x78(SP)		
  0x4207ab		48895c2440		MOVQ BX, 0x40(SP)		
  0x4207b0		48894c2438		MOVQ CX, 0x38(SP)		
  0x4207b5		4889542430		MOVQ DX, 0x30(SP)		
  0x4207ba		488d057fb20300		LEAQ 0x3b27f(IP), AX		
  0x4207c1		48890424		MOVQ AX, 0(SP)			
  0x4207c5		4889542408		MOVQ DX, 0x8(SP)		
  0x4207ca		48894c2410		MOVQ CX, 0x10(SP)		
  0x4207cf		e87c8afeff		CALL runtime.assertE2I2(SB)	
  0x4207d4		488b442420		MOVQ 0x20(SP), AX		
  0x4207d9		488b4c2418		MOVQ 0x18(SP), CX		
  0x4207de		0fb6542428		MOVZX 0x28(SP), DX		
  0x4207e3		84d2			TESTL DL, DL			
  0x4207e5		746d			JE 0x420854			
			p.arg = v.Error()
  0x4207e7		488b4918		MOVQ 0x18(CX), CX			
  0x4207eb		48890424		MOVQ AX, 0(SP)				
  0x4207ef		ffd1			CALL CX					
  0x4207f1		488b442410		MOVQ 0x10(SP), AX			
  0x4207f6		488b4c2408		MOVQ 0x8(SP), CX			
  0x4207fb		48894c2458		MOVQ CX, 0x58(SP)			
  0x420800		4889442460		MOVQ AX, 0x60(SP)			
  0x420805		488d05946b0300		LEAQ 0x36b94(IP), AX			
  0x42080c		48890424		MOVQ AX, 0(SP)				
  0x420810		488d4c2458		LEAQ 0x58(SP), CX			
  0x420815		48894c2408		MOVQ CX, 0x8(SP)			
  0x42081a		e88189feff		CALL runtime.convT2Estring(SB)		
  0x42081f		488b442418		MOVQ 0x18(SP), AX			
  0x420824		488b4c2410		MOVQ 0x10(SP), CX			
  0x420829		488b542478		MOVQ 0x78(SP), DX			
  0x42082e		48894a08		MOVQ CX, 0x8(DX)			
  0x420832		8b0dd8310a00		MOVL runtime.writeBarrier(SB), CX	
  0x420838		85c9			TESTL CX, CX				
  0x42083a		750c			JNE 0x420848				
  0x42083c		48894210		MOVQ AX, 0x10(DX)			
		switch v := p.arg.(type) {
  0x420840		4889d0			MOVQ DX, AX		
  0x420843		e940ffffff		JMP 0x420788		
  0x420848		488b7c2440		MOVQ 0x40(SP), DI	
			p.arg = v.Error()
  0x42084d		e84e600200		CALL runtime.gcWriteBarrier(SB)	
  0x420852		ebec			JMP 0x420840			
		switch v := p.arg.(type) {
  0x420854		488d0565b20300		LEAQ 0x3b265(IP), AX		
  0x42085b		48890424		MOVQ AX, 0(SP)			
  0x42085f		488b4c2430		MOVQ 0x30(SP), CX		
  0x420864		48894c2408		MOVQ CX, 0x8(SP)		
  0x420869		488b4c2438		MOVQ 0x38(SP), CX		
  0x42086e		48894c2410		MOVQ CX, 0x10(SP)		
  0x420873		e8d889feff		CALL runtime.assertE2I2(SB)	
  0x420878		0fb6442428		MOVZX 0x28(SP), AX		
  0x42087d		488b4c2420		MOVQ 0x20(SP), CX		
  0x420882		488b542418		MOVQ 0x18(SP), DX		
  0x420887		84c0			TESTL AL, AL			
  0x420889		750a			JNE 0x420895			
  0x42088b		488b442478		MOVQ 0x78(SP), AX		
  0x420890		e9f3feffff		JMP 0x420788			
			p.arg = v.String()
  0x420895		488b4218		MOVQ 0x18(DX), AX			
  0x420899		48890c24		MOVQ CX, 0(SP)				
  0x42089d		ffd0			CALL AX					
  0x42089f		488b442410		MOVQ 0x10(SP), AX			
  0x4208a4		488b4c2408		MOVQ 0x8(SP), CX			
  0x4208a9		48894c2448		MOVQ CX, 0x48(SP)			
  0x4208ae		4889442450		MOVQ AX, 0x50(SP)			
  0x4208b3		488d05e66a0300		LEAQ 0x36ae6(IP), AX			
  0x4208ba		48890424		MOVQ AX, 0(SP)				
  0x4208be		488d4c2448		LEAQ 0x48(SP), CX			
  0x4208c3		48894c2408		MOVQ CX, 0x8(SP)			
  0x4208c8		e8d388feff		CALL runtime.convT2Estring(SB)		
  0x4208cd		488b442418		MOVQ 0x18(SP), AX			
  0x4208d2		488b4c2410		MOVQ 0x10(SP), CX			
  0x4208d7		488b542478		MOVQ 0x78(SP), DX			
  0x4208dc		48894a08		MOVQ CX, 0x8(DX)			
  0x4208e0		8b0d2a310a00		MOVL runtime.writeBarrier(SB), CX	
  0x4208e6		85c9			TESTL CX, CX				
  0x4208e8		750c			JNE 0x4208f6				
  0x4208ea		48894210		MOVQ AX, 0x10(DX)			
		switch v := p.arg.(type) {
  0x4208ee		4889d0			MOVQ DX, AX		
  0x4208f1		e992feffff		JMP 0x420788		
  0x4208f6		488b7c2440		MOVQ 0x40(SP), DI	
			p.arg = v.String()
  0x4208fb		e8a05f0200		CALL runtime.gcWriteBarrier(SB)	
  0x420900		ebec			JMP 0x4208ee			
}
  0x420902		90			NOPL				
  0x420903		e8f8fcffff		CALL runtime.deferreturn(SB)	
  0x420908		488b6c2468		MOVQ 0x68(SP), BP		
  0x42090d		4883c470		ADDQ $0x70, SP			
  0x420911		c3			RET				
	defer func() {
  0x420912		90			NOPL				
  0x420913		e8e8fcffff		CALL runtime.deferreturn(SB)	
  0x420918		488b6c2468		MOVQ 0x68(SP), BP		
  0x42091d		4883c470		ADDQ $0x70, SP			
  0x420921		c3			RET				
func preprintpanics(p *_panic) {
  0x420922		e8493c0200		CALL runtime.morestack_noctxt(SB)	
  0x420927		e914feffff		JMP runtime.preprintpanics(SB)		

TEXT runtime.printpanics(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func printpanics(p *_panic) {
  0x420930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420939		483b6110		CMPQ 0x10(CX), SP	
  0x42093d		0f86da000000		JBE 0x420a1d		
  0x420943		4883ec18		SUBQ $0x18, SP		
  0x420947		48896c2410		MOVQ BP, 0x10(SP)	
  0x42094c		488d6c2410		LEAQ 0x10(SP), BP	
  0x420951		488b442420		MOVQ 0x20(SP), AX	
	if p.link != nil {
  0x420956		488b4818		MOVQ 0x18(AX), CX	
  0x42095a		4885c9			TESTQ CX, CX		
  0x42095d		0f8589000000		JNE 0x4209ec		
	print("panic: ")
  0x420963		e898110000		CALL runtime.printlock(SB)	
  0x420968		488d0570950400		LEAQ 0x49570(IP), AX		
  0x42096f		48890424		MOVQ AX, 0(SP)			
  0x420973		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42097c		e8bf1a0000		CALL runtime.printstring(SB)	
  0x420981		e8fa110000		CALL runtime.printunlock(SB)	
  0x420986		488b442420		MOVQ 0x20(SP), AX		
	printany(p.arg)
  0x42098b		488b4808		MOVQ 0x8(AX), CX		
  0x42098f		488b5010		MOVQ 0x10(AX), DX		
  0x420993		48890c24		MOVQ CX, 0(SP)			
  0x420997		4889542408		MOVQ DX, 0x8(SP)		
  0x42099c		e85f45feff		CALL runtime.printany(SB)	
  0x4209a1		488b442420		MOVQ 0x20(SP), AX		
	if p.recovered {
  0x4209a6		0fb64020		MOVZX 0x20(AX), AX	
  0x4209aa		84c0			TESTL AL, AL		
  0x4209ac		7519			JNE 0x4209c7		
	print("\n")
  0x4209ae		e84d110000		CALL runtime.printlock(SB)	
  0x4209b3		e8d8130000		CALL runtime.printnl(SB)	
  0x4209b8		e8c3110000		CALL runtime.printunlock(SB)	
}
  0x4209bd		488b6c2410		MOVQ 0x10(SP), BP	
  0x4209c2		4883c418		ADDQ $0x18, SP		
  0x4209c6		c3			RET			
		print(" [recovered]")
  0x4209c7		e834110000		CALL runtime.printlock(SB)	
  0x4209cc		488d050f9b0400		LEAQ 0x49b0f(IP), AX		
  0x4209d3		48890424		MOVQ AX, 0(SP)			
  0x4209d7		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x4209e0		e85b1a0000		CALL runtime.printstring(SB)	
  0x4209e5		e896110000		CALL runtime.printunlock(SB)	
  0x4209ea		ebc2			JMP 0x4209ae			
		printpanics(p.link)
  0x4209ec		48890c24		MOVQ CX, 0(SP)			
  0x4209f0		e83bffffff		CALL runtime.printpanics(SB)	
		print("\t")
  0x4209f5		e806110000		CALL runtime.printlock(SB)	
  0x4209fa		488d055d920400		LEAQ 0x4925d(IP), AX		
  0x420a01		48890424		MOVQ AX, 0(SP)			
  0x420a05		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x420a0e		e82d1a0000		CALL runtime.printstring(SB)	
  0x420a13		e868110000		CALL runtime.printunlock(SB)	
  0x420a18		e946ffffff		JMP 0x420963			
func printpanics(p *_panic) {
  0x420a1d		e84e3b0200		CALL runtime.morestack_noctxt(SB)	
  0x420a22		e909ffffff		JMP runtime.printpanics(SB)		

TEXT runtime.gopanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func gopanic(e interface{}) {
  0x420a30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420a39		488d4424e8		LEAQ -0x18(SP), AX	
  0x420a3e		483b4110		CMPQ 0x10(CX), AX	
  0x420a42		0f8680060000		JBE 0x4210c8		
  0x420a48		4881ec98000000		SUBQ $0x98, SP		
  0x420a4f		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x420a57		488dac2490000000	LEAQ 0x90(SP), BP	
	gp := getg()
  0x420a5f		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if gp.m.curg != gp {
  0x420a68		488b5130		MOVQ 0x30(CX), DX	
  0x420a6c		488b9ac0000000		MOVQ 0xc0(DX), BX	
  0x420a73		4839cb			CMPQ CX, BX		
  0x420a76		0f85e1050000		JNE 0x42105d		
	if gp.m.softfloat != 0 {
  0x420a7c		8b9a04010000		MOVL 0x104(DX), BX	
  0x420a82		85db			TESTL BX, BX		
  0x420a84		0f85a3050000		JNE 0x42102d		
	if gp.m.mallocing != 0 {
  0x420a8a		8b9ae8000000		MOVL 0xe8(DX), BX	
  0x420a90		85db			TESTL BX, BX		
  0x420a92		0f852a050000		JNE 0x420fc2		
  0x420a98		48894c2438		MOVQ CX, 0x38(SP)	
	if gp.m.preemptoff != "" {
  0x420a9d		488b9af8000000		MOVQ 0xf8(DX), BX	
  0x420aa4		4885db			TESTQ BX, BX		
  0x420aa7		0f8535040000		JNE 0x420ee2		
	if gp.m.locks != 0 {
  0x420aad		8b9200010000		MOVL 0x100(DX), DX	
  0x420ab3		85d2			TESTL DX, DX		
  0x420ab5		0f85bc030000		JNE 0x420e77		
	var p _panic
  0x420abb		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x420ac4		0f57c0			XORPS X0, X0		
  0x420ac7		0f11442470		MOVUPS X0, 0x70(SP)	
  0x420acc		0f11842480000000	MOVUPS X0, 0x80(SP)	
  0x420ad4		488b9424a0000000	MOVQ 0xa0(SP), DX	
	p.arg = e
  0x420adc		4889542470		MOVQ DX, 0x70(SP)	
  0x420ae1		488b9424a8000000	MOVQ 0xa8(SP), DX	
  0x420ae9		4889542478		MOVQ DX, 0x78(SP)	
	p.link = gp._panic
  0x420aee		488b5120		MOVQ 0x20(CX), DX	
  0x420af2		4889942480000000	MOVQ DX, 0x80(SP)	
  0x420afa		488d7920		LEAQ 0x20(CX), DI	
	gp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))
  0x420afe		8b150c2f0a00		MOVL runtime.writeBarrier(SB), DX	
  0x420b04		85d2			TESTL DX, DX				
  0x420b06		0f85fe020000		JNE 0x420e0a				
  0x420b0c		488d442468		LEAQ 0x68(SP), AX			
  0x420b11		48894120		MOVQ AX, 0x20(CX)			
  0x420b15		48897c2460		MOVQ DI, 0x60(SP)			
	atomic.Xadd(&runningPanicDefers, 1)
  0x420b1a		ba01000000		MOVL $0x1, DX				
  0x420b1f		488d1dd62d0a00		LEAQ runtime.runningPanicDefers(SB), BX	
  0x420b26		f00fc113		LOCK XADDL DX, 0(BX)			
	for {
  0x420b2a		eb16			JMP 0x420b42				
  0x420b2c		488d442468		LEAQ 0x68(SP), AX			
  0x420b31		488b4c2438		MOVQ 0x38(SP), CX			
  0x420b36		488d1dbf2d0a00		LEAQ runtime.runningPanicDefers(SB), BX	
  0x420b3d		488b7c2460		MOVQ 0x60(SP), DI			
		d := gp._defer
  0x420b42		488b5128		MOVQ 0x28(CX), DX	
  0x420b46		488d7128		LEAQ 0x28(CX), SI	
		if d == nil {
  0x420b4a		4885d2			TESTQ DX, DX		
  0x420b4d		0f845d020000		JE 0x420db0		
		if d.started {
  0x420b53		440fb64204		MOVZX 0x4(DX), R8	
  0x420b58		4584c0			TESTL R8, R8		
  0x420b5b		0f8482000000		JE 0x420be3		
			if d._panic != nil {
  0x420b61		4c8b4220		MOVQ 0x20(DX), R8	
  0x420b65		4c8d4a20		LEAQ 0x20(DX), R9	
  0x420b69		4d85c0			TESTQ R8, R8		
  0x420b6c		7405			JE 0x420b73		
				d._panic.aborted = true
  0x420b6e		41c6402101		MOVB $0x1, 0x21(R8)	
			d._panic = nil
  0x420b73		448b05962e0a00		MOVL runtime.writeBarrier(SB), R8	
			d.fn = nil
  0x420b7a		4c8d5218		LEAQ 0x18(DX), R10	
			d._panic = nil
  0x420b7e		4585c0			TESTL R8, R8		
  0x420b81		753f			JNE 0x420bc2		
  0x420b83		48c7422000000000	MOVQ $0x0, 0x20(DX)	
			d.fn = nil
  0x420b8b		48c7421800000000	MOVQ $0x0, 0x18(DX)	
			gp._defer = d.link
  0x420b93		448b05762e0a00		MOVL runtime.writeBarrier(SB), R8	
  0x420b9a		4c8b4a28		MOVQ 0x28(DX), R9			
  0x420b9e		4585c0			TESTL R8, R8				
  0x420ba1		7512			JNE 0x420bb5				
  0x420ba3		4c894928		MOVQ R9, 0x28(CX)			
			freedefer(d)
  0x420ba7		48891424		MOVQ DX, 0(SP)			
  0x420bab		e870f7ffff		CALL runtime.freedefer(SB)	
			continue
  0x420bb0		e977ffffff		JMP 0x420b2c		
  0x420bb5		4889f7			MOVQ SI, DI		
  0x420bb8		4c89c8			MOVQ R9, AX		
			gp._defer = d.link
  0x420bbb		e8e05c0200		CALL runtime.gcWriteBarrier(SB)	
  0x420bc0		ebe5			JMP 0x420ba7			
  0x420bc2		4989f8			MOVQ DI, R8			
  0x420bc5		4c89cf			MOVQ R9, DI			
			d._panic = nil
  0x420bc8		31c0			XORL AX, AX			
  0x420bca		e8d15c0200		CALL runtime.gcWriteBarrier(SB)	
  0x420bcf		4c89d7			MOVQ R10, DI			
			d.fn = nil
  0x420bd2		31c0			XORL AX, AX			
  0x420bd4		e8c75c0200		CALL runtime.gcWriteBarrier(SB)	
  0x420bd9		488d442468		LEAQ 0x68(SP), AX		
  0x420bde		4c89c7			MOVQ R8, DI			
			d._panic = nil
  0x420be1		ebb0			JMP 0x420b93		
  0x420be3		4889742458		MOVQ SI, 0x58(SP)	
  0x420be8		4889542450		MOVQ DX, 0x50(SP)	
		d.started = true
  0x420bed		c6420401		MOVB $0x1, 0x4(DX)	
		d._panic = (*_panic)(noescape(unsafe.Pointer(&p)))
  0x420bf1		448b05182e0a00		MOVL runtime.writeBarrier(SB), R8	
  0x420bf8		4c8d4a20		LEAQ 0x20(DX), R9			
  0x420bfc		4c894c2448		MOVQ R9, 0x48(SP)			
  0x420c01		4585c0			TESTL R8, R8				
  0x420c04		0f8599010000		JNE 0x420da3				
  0x420c0a		48894220		MOVQ AX, 0x20(DX)			
		p.argp = unsafe.Pointer(getargp(0))
  0x420c0e		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x420c16		e8c5040000		CALL runtime.getargp(SB)	
  0x420c1b		488b442408		MOVQ 0x8(SP), AX		
  0x420c20		4889442468		MOVQ AX, 0x68(SP)		
  0x420c25		488b442450		MOVQ 0x50(SP), AX		
	if d.siz == 0 {
  0x420c2a		8b08			MOVL 0(AX), CX		
  0x420c2c		85c9			TESTL CX, CX		
  0x420c2e		0f8566010000		JNE 0x420d9a		
  0x420c34		31d2			XORL DX, DX		
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
  0x420c36		488b5818		MOVQ 0x18(AX), BX		
  0x420c3a		894c241c		MOVL CX, 0x1c(SP)		
  0x420c3e		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x420c46		48895c2408		MOVQ BX, 0x8(SP)		
  0x420c4b		4889542410		MOVQ DX, 0x10(SP)		
  0x420c50		894c2418		MOVL CX, 0x18(SP)		
  0x420c54		e827390200		CALL runtime.reflectcall(SB)	
		p.argp = nil
  0x420c59		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x420c62		488b442450		MOVQ 0x50(SP), AX	
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
  0x420c67		488d4818		LEAQ 0x18(AX), CX	
  0x420c6b		488b542438		MOVQ 0x38(SP), DX	
		if gp._defer != d {
  0x420c70		488b5a28		MOVQ 0x28(DX), BX	
  0x420c74		4839c3			CMPQ AX, BX		
  0x420c77		0f85df010000		JNE 0x420e5c		
		d._panic = nil
  0x420c7d		8b1d8d2d0a00		MOVL runtime.writeBarrier(SB), BX	
  0x420c83		85db			TESTL BX, BX				
  0x420c85		0f85ee000000		JNE 0x420d79				
  0x420c8b		48c7402000000000	MOVQ $0x0, 0x20(AX)			
		d.fn = nil
  0x420c93		48c7401800000000	MOVQ $0x0, 0x18(AX)	
		gp._defer = d.link
  0x420c9b		8b0d6f2d0a00		MOVL runtime.writeBarrier(SB), CX	
  0x420ca1		488b5828		MOVQ 0x28(AX), BX			
  0x420ca5		85c9			TESTL CX, CX				
  0x420ca7		0f85b4000000		JNE 0x420d61				
  0x420cad		48895a28		MOVQ BX, 0x28(DX)			
		pc := d.pc
  0x420cb1		488b4810		MOVQ 0x10(AX), CX	
  0x420cb5		48894c2420		MOVQ CX, 0x20(SP)	
		sp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy
  0x420cba		488b5008		MOVQ 0x8(AX), DX	
  0x420cbe		4889542430		MOVQ DX, 0x30(SP)	
		freedefer(d)
  0x420cc3		48890424		MOVQ AX, 0(SP)			
  0x420cc7		e854f6ffff		CALL runtime.freedefer(SB)	
		if p.recovered {
  0x420ccc		0fb6842488000000	MOVZX 0x88(SP), AX	
  0x420cd4		84c0			TESTL AL, AL		
  0x420cd6		0f8450feffff		JE 0x420b2c		
			atomic.Xadd(&runningPanicDefers, -1)
  0x420cdc		b9ffffffff		MOVL $-0x1, CX				
  0x420ce1		488d15142c0a00		LEAQ runtime.runningPanicDefers(SB), DX	
  0x420ce8		f00fc10a		LOCK XADDL CX, 0(DX)			
			gp._panic = p.link
  0x420cec		8b0d1e2d0a00		MOVL runtime.writeBarrier(SB), CX	
  0x420cf2		488b842480000000	MOVQ 0x80(SP), AX			
  0x420cfa		85c9			TESTL CX, CX				
  0x420cfc		7552			JNE 0x420d50				
  0x420cfe		488b4c2438		MOVQ 0x38(SP), CX			
  0x420d03		48894120		MOVQ AX, 0x20(CX)			
			for gp._panic != nil && gp._panic.aborted {
  0x420d07		488b5120		MOVQ 0x20(CX), DX	
  0x420d0b		4885d2			TESTQ DX, DX		
  0x420d0e		742b			JE 0x420d3b		
  0x420d10		0fb65a21		MOVZX 0x21(DX), BX	
  0x420d14		84db			TESTL BL, BL		
  0x420d16		7420			JE 0x420d38		
				gp._panic = gp._panic.link
  0x420d18		8b1df22c0a00		MOVL runtime.writeBarrier(SB), BX	
  0x420d1e		488b4218		MOVQ 0x18(DX), AX			
  0x420d22		85db			TESTL BX, BX				
  0x420d24		7506			JNE 0x420d2c				
  0x420d26		48894120		MOVQ AX, 0x20(CX)			
  0x420d2a		ebdb			JMP 0x420d07				
  0x420d2c		488b7c2460		MOVQ 0x60(SP), DI			
  0x420d31		e86a5b0200		CALL runtime.gcWriteBarrier(SB)		
  0x420d36		ebcf			JMP 0x420d07				
			for gp._panic != nil && gp._panic.aborted {
  0x420d38		4885d2			TESTQ DX, DX		
			if gp._panic == nil { // must be done with signal
  0x420d3b		0f85d8000000		JNE 0x420e19		
				gp.sig = 0
  0x420d41		c781e800000000000000	MOVL $0x0, 0xe8(CX)	
  0x420d4b		e9c9000000		JMP 0x420e19		
  0x420d50		488b7c2460		MOVQ 0x60(SP), DI	
			gp._panic = p.link
  0x420d55		e8465b0200		CALL runtime.gcWriteBarrier(SB)	
  0x420d5a		488b4c2438		MOVQ 0x38(SP), CX		
  0x420d5f		eba6			JMP 0x420d07			
  0x420d61		488b7c2458		MOVQ 0x58(SP), DI		
  0x420d66		4889c1			MOVQ AX, CX			
  0x420d69		4889d8			MOVQ BX, AX			
		gp._defer = d.link
  0x420d6c		e82f5b0200		CALL runtime.gcWriteBarrier(SB)	
  0x420d71		4889c8			MOVQ CX, AX			
  0x420d74		e938ffffff		JMP 0x420cb1			
  0x420d79		488b7c2448		MOVQ 0x48(SP), DI		
  0x420d7e		4889c3			MOVQ AX, BX			
		d._panic = nil
  0x420d81		31c0			XORL AX, AX			
  0x420d83		e8185b0200		CALL runtime.gcWriteBarrier(SB)	
  0x420d88		4889cf			MOVQ CX, DI			
		d.fn = nil
  0x420d8b		31c0			XORL AX, AX			
  0x420d8d		e80e5b0200		CALL runtime.gcWriteBarrier(SB)	
  0x420d92		4889d8			MOVQ BX, AX			
		d._panic = nil
  0x420d95		e901ffffff		JMP 0x420c9b		
	return unsafe.Pointer(uintptr(p) + x)
  0x420d9a		488d5030		LEAQ 0x30(AX), DX	
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
  0x420d9e		e993feffff		JMP 0x420c36		
  0x420da3		4c89cf			MOVQ R9, DI		
		d._panic = (*_panic)(noescape(unsafe.Pointer(&p)))
  0x420da6		e8f55a0200		CALL runtime.gcWriteBarrier(SB)	
  0x420dab		e95efeffff		JMP 0x420c0e			
	preprintpanics(gp._panic)
  0x420db0		488b4120		MOVQ 0x20(CX), AX		
  0x420db4		48890424		MOVQ AX, 0(SP)			
  0x420db8		e883f9ffff		CALL runtime.preprintpanics(SB)	
	startpanic()
  0x420dbd		e87e030000		CALL runtime.startpanic(SB)	
	atomic.Xadd(&runningPanicDefers, -1)
  0x420dc2		b8ffffffff		MOVL $-0x1, AX				
  0x420dc7		488d0d2e2b0a00		LEAQ runtime.runningPanicDefers(SB), CX	
  0x420dce		f00fc101		LOCK XADDL AX, 0(CX)			
  0x420dd2		488b442438		MOVQ 0x38(SP), AX			
	printpanics(gp._panic)
  0x420dd7		488b4020		MOVQ 0x20(AX), AX		
  0x420ddb		48890424		MOVQ AX, 0(SP)			
  0x420ddf		e84cfbffff		CALL runtime.printpanics(SB)	
	dopanic(0)       // should not return
  0x420de4		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x420dec		e87f030000		CALL runtime.dopanic(SB)	
	*(*int)(nil) = 0 // not reached
  0x420df1		31c0			XORL AX, AX		
  0x420df3		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x420dfa		488bac2490000000	MOVQ 0x90(SP), BP	
  0x420e02		4881c498000000		ADDQ $0x98, SP		
  0x420e09		c3			RET			
	gp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))
  0x420e0a		488d442468		LEAQ 0x68(SP), AX		
  0x420e0f		e88c5a0200		CALL runtime.gcWriteBarrier(SB)	
  0x420e14		e9fcfcffff		JMP 0x420b15			
  0x420e19		488b442430		MOVQ 0x30(SP), AX		
			gp.sigcode0 = uintptr(sp)
  0x420e1e		48898108010000		MOVQ AX, 0x108(CX)	
  0x420e25		488b442420		MOVQ 0x20(SP), AX	
			gp.sigcode1 = pc
  0x420e2a		48898110010000		MOVQ AX, 0x110(CX)	
			mcall(recovery)
  0x420e31		488d0590d30400		LEAQ 0x4d390(IP), AX	
  0x420e38		48890424		MOVQ AX, 0(SP)		
  0x420e3c		e85f350200		CALL runtime.mcall(SB)	
			throw("recovery failed") // mcall should not return
  0x420e41		488d05509b0400		LEAQ 0x49b50(IP), AX	
  0x420e48		48890424		MOVQ AX, 0(SP)		
  0x420e4c		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x420e55		e876030000		CALL runtime.throw(SB)	
  0x420e5a		0f0b			UD2			
			throw("bad defer entry in panic")
  0x420e5c		488d05e3a90400		LEAQ 0x4a9e3(IP), AX	
  0x420e63		48890424		MOVQ AX, 0(SP)		
  0x420e67		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x420e70		e85b030000		CALL runtime.throw(SB)	
  0x420e75		0f0b			UD2			
		print("panic: ")
  0x420e77		e8840c0000		CALL runtime.printlock(SB)	
  0x420e7c		488d055c900400		LEAQ 0x4905c(IP), AX		
  0x420e83		48890424		MOVQ AX, 0(SP)			
  0x420e87		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x420e90		e8ab150000		CALL runtime.printstring(SB)	
  0x420e95		e8e60c0000		CALL runtime.printunlock(SB)	
  0x420e9a		488b8424a0000000	MOVQ 0xa0(SP), AX		
		printany(e)
  0x420ea2		48890424		MOVQ AX, 0(SP)			
  0x420ea6		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x420eae		4889442408		MOVQ AX, 0x8(SP)		
  0x420eb3		e84840feff		CALL runtime.printany(SB)	
		print("\n")
  0x420eb8		e8430c0000		CALL runtime.printlock(SB)	
  0x420ebd		e8ce0e0000		CALL runtime.printnl(SB)	
  0x420ec2		e8b90c0000		CALL runtime.printunlock(SB)	
		throw("panic holding locks")
  0x420ec7		488d0550a00400		LEAQ 0x4a050(IP), AX	
  0x420ece		48890424		MOVQ AX, 0(SP)		
  0x420ed2		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x420edb		e8f0020000		CALL runtime.throw(SB)	
  0x420ee0		0f0b			UD2			
		print("panic: ")
  0x420ee2		e8190c0000		CALL runtime.printlock(SB)	
  0x420ee7		488d05f18f0400		LEAQ 0x48ff1(IP), AX		
  0x420eee		48890424		MOVQ AX, 0(SP)			
  0x420ef2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x420efb		e840150000		CALL runtime.printstring(SB)	
  0x420f00		e87b0c0000		CALL runtime.printunlock(SB)	
  0x420f05		488b8424a0000000	MOVQ 0xa0(SP), AX		
		printany(e)
  0x420f0d		48890424		MOVQ AX, 0(SP)			
  0x420f11		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x420f19		4889442408		MOVQ AX, 0x8(SP)		
  0x420f1e		e8dd3ffeff		CALL runtime.printany(SB)	
		print("\n")
  0x420f23		e8d80b0000		CALL runtime.printlock(SB)	
  0x420f28		e8630e0000		CALL runtime.printnl(SB)	
  0x420f2d		e84e0c0000		CALL runtime.printunlock(SB)	
		print("preempt off reason: ")
  0x420f32		e8c90b0000		CALL runtime.printlock(SB)	
  0x420f37		488d0557a20400		LEAQ 0x4a257(IP), AX		
  0x420f3e		48890424		MOVQ AX, 0(SP)			
  0x420f42		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x420f4b		e8f0140000		CALL runtime.printstring(SB)	
  0x420f50		e82b0c0000		CALL runtime.printunlock(SB)	
  0x420f55		488b442438		MOVQ 0x38(SP), AX		
		print(gp.m.preemptoff)
  0x420f5a		488b4030		MOVQ 0x30(AX), AX		
  0x420f5e		488b88f8000000		MOVQ 0xf8(AX), CX		
  0x420f65		48894c2428		MOVQ CX, 0x28(SP)		
  0x420f6a		488b80f0000000		MOVQ 0xf0(AX), AX		
  0x420f71		4889442440		MOVQ AX, 0x40(SP)		
  0x420f76		e8850b0000		CALL runtime.printlock(SB)	
  0x420f7b		488b442440		MOVQ 0x40(SP), AX		
  0x420f80		48890424		MOVQ AX, 0(SP)			
  0x420f84		488b442428		MOVQ 0x28(SP), AX		
  0x420f89		4889442408		MOVQ AX, 0x8(SP)		
  0x420f8e		e8ad140000		CALL runtime.printstring(SB)	
  0x420f93		e8e80b0000		CALL runtime.printunlock(SB)	
		print("\n")
  0x420f98		e8630b0000		CALL runtime.printlock(SB)	
  0x420f9d		e8ee0d0000		CALL runtime.printnl(SB)	
  0x420fa2		e8d90b0000		CALL runtime.printunlock(SB)	
		throw("panic during preemptoff")
  0x420fa7		488d0556a70400		LEAQ 0x4a756(IP), AX	
  0x420fae		48890424		MOVQ AX, 0(SP)		
  0x420fb2		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x420fbb		e810020000		CALL runtime.throw(SB)	
  0x420fc0		0f0b			UD2			
		print("panic: ")
  0x420fc2		e8390b0000		CALL runtime.printlock(SB)	
  0x420fc7		488d05118f0400		LEAQ 0x48f11(IP), AX		
  0x420fce		48890424		MOVQ AX, 0(SP)			
  0x420fd2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x420fdb		e860140000		CALL runtime.printstring(SB)	
  0x420fe0		e89b0b0000		CALL runtime.printunlock(SB)	
  0x420fe5		488b8424a0000000	MOVQ 0xa0(SP), AX		
		printany(e)
  0x420fed		48890424		MOVQ AX, 0(SP)			
  0x420ff1		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x420ff9		4889442408		MOVQ AX, 0x8(SP)		
  0x420ffe		e8fd3efeff		CALL runtime.printany(SB)	
		print("\n")
  0x421003		e8f80a0000		CALL runtime.printlock(SB)	
  0x421008		e8830d0000		CALL runtime.printnl(SB)	
  0x42100d		e86e0b0000		CALL runtime.printunlock(SB)	
		throw("panic during malloc")
  0x421012		488d05df9e0400		LEAQ 0x49edf(IP), AX	
  0x421019		48890424		MOVQ AX, 0(SP)		
  0x42101d		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x421026		e8a5010000		CALL runtime.throw(SB)	
  0x42102b		0f0b			UD2			
		gp.m.locks--
  0x42102d		838200010000ff		ADDL $-0x1, 0x100(DX)	
		gp.m.softfloat = 0
  0x421034		488b4130		MOVQ 0x30(CX), AX	
  0x421038		c7800401000000000000	MOVL $0x0, 0x104(AX)	
		throw("panic during softfloat")
  0x421042		488d0559a40400		LEAQ 0x4a459(IP), AX	
  0x421049		48890424		MOVQ AX, 0(SP)		
  0x42104d		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x421056		e875010000		CALL runtime.throw(SB)	
  0x42105b		0f0b			UD2			
		print("panic: ")
  0x42105d		e89e0a0000		CALL runtime.printlock(SB)	
  0x421062		488d05768e0400		LEAQ 0x48e76(IP), AX		
  0x421069		48890424		MOVQ AX, 0(SP)			
  0x42106d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x421076		e8c5130000		CALL runtime.printstring(SB)	
  0x42107b		e8000b0000		CALL runtime.printunlock(SB)	
  0x421080		488b8424a0000000	MOVQ 0xa0(SP), AX		
		printany(e)
  0x421088		48890424		MOVQ AX, 0(SP)			
  0x42108c		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x421094		4889442408		MOVQ AX, 0x8(SP)		
  0x421099		e8623efeff		CALL runtime.printany(SB)	
		print("\n")
  0x42109e		e85d0a0000		CALL runtime.printlock(SB)	
  0x4210a3		e8e80c0000		CALL runtime.printnl(SB)	
  0x4210a8		e8d30a0000		CALL runtime.printunlock(SB)	
		throw("panic on system stack")
  0x4210ad		488d0529a20400		LEAQ 0x4a229(IP), AX	
  0x4210b4		48890424		MOVQ AX, 0(SP)		
  0x4210b8		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x4210c1		e80a010000		CALL runtime.throw(SB)	
  0x4210c6		0f0b			UD2			
func gopanic(e interface{}) {
  0x4210c8		e8a3340200		CALL runtime.morestack_noctxt(SB)	
  0x4210cd		e95ef9ffff		JMP runtime.gopanic(SB)			

TEXT runtime.getargp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
	return uintptr(noescape(unsafe.Pointer(&x)))
  0x4210e0		488d442408		LEAQ 0x8(SP), AX	
  0x4210e5		4889442410		MOVQ AX, 0x10(SP)	
  0x4210ea		c3			RET			

TEXT runtime.gorecover(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
	gp := getg()
  0x4210f0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	p := gp._panic
  0x4210f9		488b4020		MOVQ 0x20(AX), AX	
	if p != nil && !p.recovered && argp == uintptr(p.argp) {
  0x4210fd		4885c0			TESTQ AX, AX		
  0x421100		7408			JE 0x42110a		
  0x421102		0fb64820		MOVZX 0x20(AX), CX	
  0x421106		84c9			TESTL CL, CL		
  0x421108		7409			JE 0x421113		
	return nil
  0x42110a		0f57c0			XORPS X0, X0		
  0x42110d		0f11442410		MOVUPS X0, 0x10(SP)	
  0x421112		c3			RET			
	if p != nil && !p.recovered && argp == uintptr(p.argp) {
  0x421113		488b08			MOVQ 0(AX), CX		
  0x421116		488b542408		MOVQ 0x8(SP), DX	
  0x42111b		4839ca			CMPQ CX, DX		
  0x42111e		75ea			JNE 0x42110a		
		p.recovered = true
  0x421120		c6402001		MOVB $0x1, 0x20(AX)	
		return p.arg
  0x421124		488b4810		MOVQ 0x10(AX), CX	
  0x421128		488b4008		MOVQ 0x8(AX), AX	
  0x42112c		4889442410		MOVQ AX, 0x10(SP)	
  0x421131		48894c2418		MOVQ CX, 0x18(SP)	
  0x421136		c3			RET			

TEXT runtime.startpanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func startpanic() {
  0x421140		4883ec10		SUBQ $0x10, SP		
  0x421144		48896c2408		MOVQ BP, 0x8(SP)	
  0x421149		488d6c2408		LEAQ 0x8(SP), BP	
	systemstack(startpanic_m)
  0x42114e		488d05abd00400		LEAQ 0x4d0ab(IP), AX		
  0x421155		48890424		MOVQ AX, 0(SP)			
  0x421159		e8c2320200		CALL runtime.systemstack(SB)	
}
  0x42115e		488b6c2408		MOVQ 0x8(SP), BP	
  0x421163		4883c410		ADDQ $0x10, SP		
  0x421167		c3			RET			

TEXT runtime.dopanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func dopanic(unused int) {
  0x421170		4883ec30		SUBQ $0x30, SP		
  0x421174		48896c2428		MOVQ BP, 0x28(SP)	
  0x421179		488d6c2428		LEAQ 0x28(SP), BP	
	gp := getg()
  0x42117e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	systemstack(func() {
  0x421187		488d0db21f0200		LEAQ runtime.dopanic.func1(SB), CX	
  0x42118e		48894c2408		MOVQ CX, 0x8(SP)			
  0x421193		4889442410		MOVQ AX, 0x10(SP)			
  0x421198		488b442430		MOVQ 0x30(SP), AX			
  0x42119d		4889442418		MOVQ AX, 0x18(SP)			
  0x4211a2		488d442438		LEAQ 0x38(SP), AX			
  0x4211a7		4889442420		MOVQ AX, 0x20(SP)			
  0x4211ac		488d442408		LEAQ 0x8(SP), AX			
  0x4211b1		48890424		MOVQ AX, 0(SP)				
  0x4211b5		e866320200		CALL runtime.systemstack(SB)		
	*(*int)(nil) = 0
  0x4211ba		31c0			XORL AX, AX		
  0x4211bc		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x4211c3		488b6c2428		MOVQ 0x28(SP), BP	
  0x4211c8		4883c430		ADDQ $0x30, SP		
  0x4211cc		c3			RET			

TEXT runtime.throw(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func throw(s string) {
  0x4211d0		4883ec18		SUBQ $0x18, SP		
  0x4211d4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4211d9		488d6c2410		LEAQ 0x10(SP), BP	
	print("fatal error: ", s, "\n")
  0x4211de		e81d090000		CALL runtime.printlock(SB)	
  0x4211e3		488d0564950400		LEAQ 0x49564(IP), AX		
  0x4211ea		48890424		MOVQ AX, 0(SP)			
  0x4211ee		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4211f7		e844120000		CALL runtime.printstring(SB)	
func throw(s string) {
  0x4211fc		488b442420		MOVQ 0x20(SP), AX	
	print("fatal error: ", s, "\n")
  0x421201		48890424		MOVQ AX, 0(SP)		
func throw(s string) {
  0x421205		488b442428		MOVQ 0x28(SP), AX	
	print("fatal error: ", s, "\n")
  0x42120a		4889442408		MOVQ AX, 0x8(SP)		
  0x42120f		e82c120000		CALL runtime.printstring(SB)	
  0x421214		e8770b0000		CALL runtime.printnl(SB)	
  0x421219		e862090000		CALL runtime.printunlock(SB)	
	gp := getg()
  0x42121e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp.m.throwing == 0 {
  0x421227		488b4030		MOVQ 0x30(AX), AX	
  0x42122b		8b88ec000000		MOVL 0xec(AX), CX	
  0x421231		85c9			TESTL CX, CX		
  0x421233		750a			JNE 0x42123f		
		gp.m.throwing = 1
  0x421235		c780ec00000001000000	MOVL $0x1, 0xec(AX)	
	startpanic()
  0x42123f		e8fcfeffff		CALL runtime.startpanic(SB)	
	dopanic(0)
  0x421244		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x42124c		e81fffffff		CALL runtime.dopanic(SB)	
	*(*int)(nil) = 0 // not reached
  0x421251		31c0			XORL AX, AX		
  0x421253		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x42125a		488b6c2410		MOVQ 0x10(SP), BP	
  0x42125f		4883c418		ADDQ $0x18, SP		
  0x421263		c3			RET			

TEXT runtime.recovery(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func recovery(gp *g) {
  0x421270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421279		483b6110		CMPQ 0x10(CX), SP	
  0x42127d		0f862c010000		JBE 0x4213af		
  0x421283		4883ec30		SUBQ $0x30, SP		
  0x421287		48896c2428		MOVQ BP, 0x28(SP)	
  0x42128c		488d6c2428		LEAQ 0x28(SP), BP	
  0x421291		488b442438		MOVQ 0x38(SP), AX	
	sp := gp.sigcode0
  0x421296		488b8808010000		MOVQ 0x108(AX), CX	
	pc := gp.sigcode1
  0x42129d		488b9010010000		MOVQ 0x110(AX), DX	
	if sp != 0 && (sp < gp.stack.lo || gp.stack.hi < sp) {
  0x4212a4		4885c9			TESTQ CX, CX		
  0x4212a7		741b			JE 0x4212c4		
  0x4212a9		48894c2410		MOVQ CX, 0x10(SP)	
  0x4212ae		488b18			MOVQ 0(AX), BX		
  0x4212b1		48895c2420		MOVQ BX, 0x20(SP)	
  0x4212b6		4839d9			CMPQ BX, CX		
  0x4212b9		7238			JB 0x4212f3		
  0x4212bb		488b7008		MOVQ 0x8(AX), SI	
  0x4212bf		4839ce			CMPQ CX, SI		
  0x4212c2		722f			JB 0x4212f3		
	gp.sched.sp = sp
  0x4212c4		48894838		MOVQ CX, 0x38(AX)	
	gp.sched.pc = pc
  0x4212c8		48895040		MOVQ DX, 0x40(AX)	
	gp.sched.lr = 0
  0x4212cc		48c7406000000000	MOVQ $0x0, 0x60(AX)	
	gp.sched.ret = 1
  0x4212d4		48c7405801000000	MOVQ $0x1, 0x58(AX)	
	gogo(&gp.sched)
  0x4212dc		4883c038		ADDQ $0x38, AX		
  0x4212e0		48890424		MOVQ AX, 0(SP)		
  0x4212e4		e857300200		CALL runtime.gogo(SB)	
}
  0x4212e9		488b6c2428		MOVQ 0x28(SP), BP	
  0x4212ee		4883c430		ADDQ $0x30, SP		
  0x4212f2		c3			RET			
		print("recover: ", hex(sp), " not in [", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n")
  0x4212f3		488b4008		MOVQ 0x8(AX), AX		
  0x4212f7		4889442418		MOVQ AX, 0x18(SP)		
  0x4212fc		e8ff070000		CALL runtime.printlock(SB)	
  0x421301		488d05338e0400		LEAQ 0x48e33(IP), AX		
  0x421308		48890424		MOVQ AX, 0(SP)			
  0x42130c		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x421315		e826110000		CALL runtime.printstring(SB)	
  0x42131a		488b442410		MOVQ 0x10(SP), AX		
  0x42131f		48890424		MOVQ AX, 0(SP)			
  0x421323		e8c80f0000		CALL runtime.printhex(SB)	
  0x421328		488d05618d0400		LEAQ 0x48d61(IP), AX		
  0x42132f		48890424		MOVQ AX, 0(SP)			
  0x421333		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42133c		e8ff100000		CALL runtime.printstring(SB)	
  0x421341		488b442420		MOVQ 0x20(SP), AX		
  0x421346		48890424		MOVQ AX, 0(SP)			
  0x42134a		e8a10f0000		CALL runtime.printhex(SB)	
  0x42134f		488d0516890400		LEAQ 0x48916(IP), AX		
  0x421356		48890424		MOVQ AX, 0(SP)			
  0x42135a		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x421363		e8d8100000		CALL runtime.printstring(SB)	
  0x421368		488b442418		MOVQ 0x18(SP), AX		
  0x42136d		48890424		MOVQ AX, 0(SP)			
  0x421371		e87a0f0000		CALL runtime.printhex(SB)	
  0x421376		488d05f9880400		LEAQ 0x488f9(IP), AX		
  0x42137d		48890424		MOVQ AX, 0(SP)			
  0x421381		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42138a		e8b1100000		CALL runtime.printstring(SB)	
  0x42138f		e8ec070000		CALL runtime.printunlock(SB)	
		throw("bad recovery")
  0x421394		488d0537920400		LEAQ 0x49237(IP), AX	
  0x42139b		48890424		MOVQ AX, 0(SP)		
  0x42139f		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x4213a8		e823feffff		CALL runtime.throw(SB)	
  0x4213ad		0f0b			UD2			
func recovery(gp *g) {
  0x4213af		e8bc310200		CALL runtime.morestack_noctxt(SB)	
  0x4213b4		e9b7feffff		JMP runtime.recovery(SB)		

TEXT runtime.startpanic_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func startpanic_m() {
  0x4213c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4213c9		483b6110		CMPQ 0x10(CX), SP	
  0x4213cd		0f86a9010000		JBE 0x42157c		
  0x4213d3		4883ec20		SUBQ $0x20, SP		
  0x4213d7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4213dc		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x4213e1		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4213ea		48894c2410		MOVQ CX, 0x10(SP)	
	if mheap_.cachealloc.size == 0 { // very early
  0x4213ef		488b15c2e30800		MOVQ runtime.mheap_+13592(SB), DX	
  0x4213f6		4885d2			TESTQ DX, DX				
  0x4213f9		0f8450010000		JE 0x42154f				
	_g_.m.mallocing++
  0x4213ff		488b5130		MOVQ 0x30(CX), DX	
  0x421403		ff82e8000000		INCL 0xe8(DX)		
	switch _g_.m.dying {
  0x421409		488b5130		MOVQ 0x30(CX), DX	
  0x42140d		8b9a08010000		MOVL 0x108(DX), BX	
	case 0:
  0x421413		85db			TESTL BX, BX		
  0x421415		0f8587000000		JNE 0x4214a2		
		_g_.m.dying = 1
  0x42141b		c7820801000001000000	MOVL $0x1, 0x108(DX)	
		_g_.writebuf = nil
  0x421425		0f57c0			XORPS X0, X0				
  0x421428		0f1181f8000000		MOVUPS X0, 0xf8(CX)			
  0x42142f		8b15db250a00		MOVL runtime.writeBarrier(SB), DX	
  0x421435		488db9f0000000		LEAQ 0xf0(CX), DI			
  0x42143c		85d2			TESTL DX, DX				
  0x42143e		7559			JNE 0x421499				
  0x421440		48c781f000000000000000	MOVQ $0x0, 0xf0(CX)			
		atomic.Xadd(&panicking, 1)
  0x42144b		b801000000		MOVL $0x1, AX			
  0x421450		488d0d9d240a00		LEAQ runtime.panicking(SB), CX	
  0x421457		f00fc101		LOCK XADDL AX, 0(CX)		
		lock(&paniclk)
  0x42145b		488d0536250a00		LEAQ runtime.paniclk(SB), AX	
  0x421462		48890424		MOVQ AX, 0(SP)			
  0x421466		e8b580feff		CALL runtime.lock(SB)		
		if debug.schedtrace > 0 || debug.scheddetail > 0 {
  0x42146b		8b0583260a00		MOVL runtime.debug+52(SB), AX	
  0x421471		85c0			TESTL AX, AX			
  0x421473		7e18			JLE 0x42148d			
			schedtrace(true)
  0x421475		c6042401		MOVB $0x1, 0(SP)		
  0x421479		e872bc0000		CALL runtime.schedtrace(SB)	
		freezetheworld()
  0x42147e		e81d300000		CALL runtime.freezetheworld(SB)	
		return
  0x421483		488b6c2418		MOVQ 0x18(SP), BP	
  0x421488		4883c420		ADDQ $0x20, SP		
  0x42148c		c3			RET			
		if debug.schedtrace > 0 || debug.scheddetail > 0 {
  0x42148d		8b055d260a00		MOVL runtime.debug+48(SB), AX	
  0x421493		85c0			TESTL AX, AX			
  0x421495		7fde			JG 0x421475			
  0x421497		ebe5			JMP 0x42147e			
		_g_.writebuf = nil
  0x421499		31c0			XORL AX, AX			
  0x42149b		e800540200		CALL runtime.gcWriteBarrier(SB)	
  0x4214a0		eba9			JMP 0x42144b			
	case 1:
  0x4214a2		83fb01			CMPL $0x1, BX		
  0x4214a5		7458			JE 0x4214ff		
	case 2:
  0x4214a7		83fb02			CMPL $0x2, BX		
  0x4214aa		753d			JNE 0x4214e9		
		_g_.m.dying = 3
  0x4214ac		488b4130		MOVQ 0x30(CX), AX	
  0x4214b0		c7800801000003000000	MOVL $0x3, 0x108(AX)	
		print("stack trace unavailable\n")
  0x4214ba		e841060000		CALL runtime.printlock(SB)	
  0x4214bf		488d0588a40400		LEAQ 0x4a488(IP), AX		
  0x4214c6		48890424		MOVQ AX, 0(SP)			
  0x4214ca		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x4214d3		e8680f0000		CALL runtime.printstring(SB)	
  0x4214d8		e8a3060000		CALL runtime.printunlock(SB)	
		exit(4)
  0x4214dd		c7042404000000		MOVL $0x4, 0(SP)	
  0x4214e4		e8e7620200		CALL runtime.exit(SB)	
		exit(5)
  0x4214e9		c7042405000000		MOVL $0x5, 0(SP)	
  0x4214f0		e8db620200		CALL runtime.exit(SB)	
  0x4214f5		488b6c2418		MOVQ 0x18(SP), BP	
  0x4214fa		4883c420		ADDQ $0x20, SP		
  0x4214fe		c3			RET			
		_g_.m.dying = 2
  0x4214ff		c7820801000002000000	MOVL $0x2, 0x108(DX)	
		print("panic during panic\n")
  0x421509		e8f2050000		CALL runtime.printlock(SB)	
  0x42150e		488d05f6990400		LEAQ 0x499f6(IP), AX		
  0x421515		48890424		MOVQ AX, 0(SP)			
  0x421519		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x421522		e8190f0000		CALL runtime.printstring(SB)	
  0x421527		e854060000		CALL runtime.printunlock(SB)	
		dopanic(0)
  0x42152c		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x421534		e837fcffff		CALL runtime.dopanic(SB)	
		exit(3)
  0x421539		c7042403000000		MOVL $0x3, 0(SP)	
  0x421540		e88b620200		CALL runtime.exit(SB)	
  0x421545		488b4c2410		MOVQ 0x10(SP), CX	
	case 2:
  0x42154a		e95dffffff		JMP 0x4214ac		
		print("runtime: panic before malloc heap initialized\n")
  0x42154f		e8ac050000		CALL runtime.printlock(SB)	
  0x421554		488d055bc20400		LEAQ 0x4c25b(IP), AX		
  0x42155b		48890424		MOVQ AX, 0(SP)			
  0x42155f		48c74424082e000000	MOVQ $0x2e, 0x8(SP)		
  0x421568		e8d30e0000		CALL runtime.printstring(SB)	
  0x42156d		e80e060000		CALL runtime.printunlock(SB)	
  0x421572		488b4c2410		MOVQ 0x10(SP), CX		
  0x421577		e983feffff		JMP 0x4213ff			
func startpanic_m() {
  0x42157c		e8ef2f0200		CALL runtime.morestack_noctxt(SB)	
  0x421581		e93afeffff		JMP runtime.startpanic_m(SB)		

TEXT runtime.dopanic_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
func dopanic_m(gp *g, pc, sp uintptr) {
  0x421590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421599		483b6110		CMPQ 0x10(CX), SP	
  0x42159d		0f8694030000		JBE 0x421937		
  0x4215a3		4883ec68		SUBQ $0x68, SP		
  0x4215a7		48896c2460		MOVQ BP, 0x60(SP)	
  0x4215ac		488d6c2460		LEAQ 0x60(SP), BP	
  0x4215b1		488b442470		MOVQ 0x70(SP), AX	
	if gp.sig != 0 {
  0x4215b6		8b88e8000000		MOVL 0xe8(AX), CX	
  0x4215bc		85c9			TESTL CX, CX		
  0x4215be		0f841c010000		JE 0x4216e0		
	if sig >= uint32(len(sigtable)) {
  0x4215c4		83f941			CMPL $0x41, CX		
  0x4215c7		0f8243030000		JB 0x421910		
  0x4215cd		31d2			XORL DX, DX		
  0x4215cf		31db			XORL BX, BX		
		if signame != "" {
  0x4215d1		4885d2			TESTQ DX, DX		
  0x4215d4		0f84fd020000		JE 0x4218d7		
  0x4215da		4889542430		MOVQ DX, 0x30(SP)	
  0x4215df		48895c2450		MOVQ BX, 0x50(SP)	
			print("[signal ", signame)
  0x4215e4		e817050000		CALL runtime.printlock(SB)	
  0x4215e9		488d05078a0400		LEAQ 0x48a07(IP), AX		
  0x4215f0		48890424		MOVQ AX, 0(SP)			
  0x4215f4		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4215fd		e83e0e0000		CALL runtime.printstring(SB)	
  0x421602		488b442450		MOVQ 0x50(SP), AX		
  0x421607		48890424		MOVQ AX, 0(SP)			
  0x42160b		488b442430		MOVQ 0x30(SP), AX		
  0x421610		4889442408		MOVQ AX, 0x8(SP)		
  0x421615		e8260e0000		CALL runtime.printstring(SB)	
  0x42161a		e861050000		CALL runtime.printunlock(SB)	
  0x42161f		488b442470		MOVQ 0x70(SP), AX		
		print(" code=", hex(gp.sigcode0), " addr=", hex(gp.sigcode1), " pc=", hex(gp.sigpc), "]\n")
  0x421624		488b8808010000		MOVQ 0x108(AX), CX		
  0x42162b		48894c2448		MOVQ CX, 0x48(SP)		
  0x421630		488b9010010000		MOVQ 0x110(AX), DX		
  0x421637		4889542440		MOVQ DX, 0x40(SP)		
  0x42163c		488b9818010000		MOVQ 0x118(AX), BX		
  0x421643		48895c2438		MOVQ BX, 0x38(SP)		
  0x421648		e8b3040000		CALL runtime.printlock(SB)	
  0x42164d		488d059f870400		LEAQ 0x4879f(IP), AX		
  0x421654		48890424		MOVQ AX, 0(SP)			
  0x421658		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x421661		e8da0d0000		CALL runtime.printstring(SB)	
  0x421666		488b442448		MOVQ 0x48(SP), AX		
  0x42166b		48890424		MOVQ AX, 0(SP)			
  0x42166f		e87c0c0000		CALL runtime.printhex(SB)	
  0x421674		488d056c870400		LEAQ 0x4876c(IP), AX		
  0x42167b		48890424		MOVQ AX, 0(SP)			
  0x42167f		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x421688		e8b30d0000		CALL runtime.printstring(SB)	
  0x42168d		488b442440		MOVQ 0x40(SP), AX		
  0x421692		48890424		MOVQ AX, 0(SP)			
  0x421696		e8550c0000		CALL runtime.printhex(SB)	
  0x42169b		488d0530860400		LEAQ 0x48630(IP), AX		
  0x4216a2		48890424		MOVQ AX, 0(SP)			
  0x4216a6		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4216af		e88c0d0000		CALL runtime.printstring(SB)	
  0x4216b4		488b442438		MOVQ 0x38(SP), AX		
  0x4216b9		48890424		MOVQ AX, 0(SP)			
  0x4216bd		e82e0c0000		CALL runtime.printhex(SB)	
  0x4216c2		488d05ad850400		LEAQ 0x485ad(IP), AX		
  0x4216c9		48890424		MOVQ AX, 0(SP)			
  0x4216cd		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4216d6		e8650d0000		CALL runtime.printstring(SB)	
  0x4216db		e8a0040000		CALL runtime.printunlock(SB)	
	_g_ := getg()
  0x4216e0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	t := atomic.Load(&traceback_cache)
  0x4216e9		8b0d19390800		MOVL runtime.traceback_cache(SB), CX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x4216ef		488b4030		MOVQ 0x30(AX), AX	
  0x4216f3		8b90ec000000		MOVL 0xec(AX), DX	
  0x4216f9		85d2			TESTL DX, DX		
  0x4216fb		0f8eca010000		JLE 0x4218cb		
  0x421701		ba01000000		MOVL $0x1, DX		
	if _g_.m.traceback != 0 {
  0x421706		0fb68029010000		MOVZX 0x129(AX), AX	
  0x42170d		84c0			TESTL AL, AL		
  0x42170f		0f84ac010000		JE 0x4218c1		
		level = int32(_g_.m.traceback)
  0x421715		0fb6c0			MOVZX AL, AX		
  0x421718		894c2428		MOVL CX, 0x28(SP)	
	_g_ := getg()
  0x42171c		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
	if level > 0 {
  0x421725		85c0			TESTL AX, AX		
  0x421727		0f8e8a000000		JLE 0x4217b7		
  0x42172d		88542427		MOVB DL, 0x27(SP)	
  0x421731		488b742470		MOVQ 0x70(SP), SI	
		if gp != gp.m.curg {
  0x421736		488b7e30		MOVQ 0x30(SI), DI	
  0x42173a		4c8b87c0000000		MOVQ 0xc0(DI), R8	
  0x421741		4c89442458		MOVQ R8, 0x58(SP)	
		if gp != gp.m.g0 {
  0x421746		488b3f			MOVQ 0(DI), DI		
  0x421749		4839f7			CMPQ SI, DI		
  0x42174c		0f851f010000		JNE 0x421871		
		} else if level >= 2 || _g_.m.throwing > 0 {
  0x421752		83f802			CMPL $0x2, AX		
  0x421755		0f8cff000000		JL 0x42185a		
			print("\nruntime stack:\n")
  0x42175b		e8a0030000		CALL runtime.printlock(SB)	
  0x421760		488d051b930400		LEAQ 0x4931b(IP), AX		
  0x421767		48890424		MOVQ AX, 0(SP)			
  0x42176b		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x421774		e8c70c0000		CALL runtime.printstring(SB)	
  0x421779		e802040000		CALL runtime.printunlock(SB)	
  0x42177e		488b442478		MOVQ 0x78(SP), AX		
			traceback(pc, sp, 0, gp)
  0x421783		48890424		MOVQ AX, 0(SP)			
  0x421787		488b842480000000	MOVQ 0x80(SP), AX		
  0x42178f		4889442408		MOVQ AX, 0x8(SP)		
  0x421794		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42179d		488b442470		MOVQ 0x70(SP), AX		
  0x4217a2		4889442418		MOVQ AX, 0x18(SP)		
  0x4217a7		e814be0100		CALL runtime.traceback(SB)	
		if !didothers && all {
  0x4217ac		0fb605f0200a00		MOVZX runtime.didothers(SB), AX	
  0x4217b3		84c0			TESTL AL, AL			
  0x4217b5		746f			JE 0x421826			
	unlock(&paniclk)
  0x4217b7		488d05da210a00		LEAQ runtime.paniclk(SB), AX	
  0x4217be		48890424		MOVQ AX, 0(SP)			
  0x4217c2		e8f97efeff		CALL runtime.unlock(SB)		
	if atomic.Xadd(&panicking, -1) != 0 {
  0x4217c7		b8ffffffff		MOVL $-0x1, AX			
  0x4217cc		488d0d21210a00		LEAQ runtime.panicking(SB), CX	
  0x4217d3		f00fc101		LOCK XADDL AX, 0(CX)		
  0x4217d7		ffc8			DECL AX				
  0x4217d9		85c0			TESTL AX, AX			
  0x4217db		7527			JNE 0x421804			
  0x4217dd		8b442428		MOVL 0x28(SP), AX		
	crash = t&tracebackCrash != 0
  0x4217e1		0fbae000		BTL $0x0, AX		
	if docrash {
  0x4217e5		7216			JB 0x4217fd		
	exit(2)
  0x4217e7		c7042402000000		MOVL $0x2, 0(SP)	
  0x4217ee		e8dd5f0200		CALL runtime.exit(SB)	
}
  0x4217f3		488b6c2460		MOVQ 0x60(SP), BP	
  0x4217f8		4883c468		ADDQ $0x68, SP		
  0x4217fc		c3			RET			
		crash()
  0x4217fd		e89e140100		CALL runtime.crash(SB)	
  0x421802		ebe3			JMP 0x4217e7		
		lock(&deadlock)
  0x421804		488d053d210a00		LEAQ runtime.deadlock(SB), AX	
  0x42180b		48890424		MOVQ AX, 0(SP)			
  0x42180f		e80c7dfeff		CALL runtime.lock(SB)		
		lock(&deadlock)
  0x421814		488d052d210a00		LEAQ runtime.deadlock(SB), AX	
  0x42181b		48890424		MOVQ AX, 0(SP)			
  0x42181f		e8fc7cfeff		CALL runtime.lock(SB)		
  0x421824		ebb7			JMP 0x4217dd			
  0x421826		488b442458		MOVQ 0x58(SP), AX		
  0x42182b		488b4c2470		MOVQ 0x70(SP), CX		
		if gp != gp.m.curg {
  0x421830		4839c8			CMPQ CX, AX		
  0x421833		0f95c0			SETNE AL		
  0x421836		0fb6542427		MOVZX 0x27(SP), DX	
		if !didothers && all {
  0x42183b		09d0			ORL DX, AX		
  0x42183d		84c0			TESTL AL, AL		
  0x42183f		0f8472ffffff		JE 0x4217b7		
			didothers = true
  0x421845		c60557200a0001		MOVB $0x1, runtime.didothers(SB)	
			tracebackothers(gp)
  0x42184c		48890c24		MOVQ CX, 0(SP)				
  0x421850		e86bc70100		CALL runtime.tracebackothers(SB)	
  0x421855		e95dffffff		JMP 0x4217b7				
		} else if level >= 2 || _g_.m.throwing > 0 {
  0x42185a		488b4330		MOVQ 0x30(BX), AX	
  0x42185e		8b80ec000000		MOVL 0xec(AX), AX	
  0x421864		85c0			TESTL AX, AX		
  0x421866		0f8feffeffff		JG 0x42175b		
  0x42186c		e93bffffff		JMP 0x4217ac		
			print("\n")
  0x421871		e88a020000		CALL runtime.printlock(SB)	
  0x421876		e815050000		CALL runtime.printnl(SB)	
  0x42187b		e800030000		CALL runtime.printunlock(SB)	
  0x421880		488b442470		MOVQ 0x70(SP), AX		
			goroutineheader(gp)
  0x421885		48890424		MOVQ AX, 0(SP)				
  0x421889		e892c40100		CALL runtime.goroutineheader(SB)	
  0x42188e		488b442478		MOVQ 0x78(SP), AX			
			traceback(pc, sp, 0, gp)
  0x421893		48890424		MOVQ AX, 0(SP)			
  0x421897		488b842480000000	MOVQ 0x80(SP), AX		
  0x42189f		4889442408		MOVQ AX, 0x8(SP)		
  0x4218a4		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4218ad		488b442470		MOVQ 0x70(SP), AX		
  0x4218b2		4889442418		MOVQ AX, 0x18(SP)		
  0x4218b7		e804bd0100		CALL runtime.traceback(SB)	
  0x4218bc		e9ebfeffff		JMP 0x4217ac			
  0x4218c1		89c8			MOVL CX, AX			
		level = int32(t >> tracebackShift)
  0x4218c3		c1e802			SHRL $0x2, AX		
  0x4218c6		e94dfeffff		JMP 0x421718		
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x4218cb		0fbae101		BTL $0x1, CX		
  0x4218cf		0f92c2			SETB DL			
  0x4218d2		e92ffeffff		JMP 0x421706		
  0x4218d7		894c242c		MOVL CX, 0x2c(SP)	
			print("[signal ", hex(gp.sig))
  0x4218db		e820020000		CALL runtime.printlock(SB)	
  0x4218e0		488d0510870400		LEAQ 0x48710(IP), AX		
  0x4218e7		48890424		MOVQ AX, 0(SP)			
  0x4218eb		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4218f4		e8470b0000		CALL runtime.printstring(SB)	
  0x4218f9		8b44242c		MOVL 0x2c(SP), AX		
  0x4218fd		48890424		MOVQ AX, 0(SP)			
  0x421901		e8ea090000		CALL runtime.printhex(SB)	
  0x421906		e875020000		CALL runtime.printunlock(SB)	
  0x42190b		e90ffdffff		JMP 0x42161f			
	return sigtable[sig].name
  0x421910		4883f941		CMPQ $0x41, CX			
  0x421914		731a			JAE 0x421930			
  0x421916		488d3449		LEAQ 0(CX)(CX*2), SI		
  0x42191a		488d3d5f460800		LEAQ runtime.sigtable(SB), DI	
  0x421921		488b54f710		MOVQ 0x10(DI)(SI*8), DX		
  0x421926		488b5cf708		MOVQ 0x8(DI)(SI*8), BX		
		signame := signame(gp.sig)
  0x42192b		e9a1fcffff		JMP 0x4215d1		
	return sigtable[sig].name
  0x421930		e80be1ffff		CALL runtime.panicindex(SB)	
  0x421935		0f0b			UD2				
func dopanic_m(gp *g, pc, sp uintptr) {
  0x421937		e8342c0200		CALL runtime.morestack_noctxt(SB)	
  0x42193c		e94ffcffff		JMP runtime.dopanic_m(SB)		

TEXT runtime.canpanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
	_g_ := getg()
  0x421950		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_m_ := _g_.m
  0x421959		488b4030		MOVQ 0x30(AX), AX	
  0x42195d		488b4c2408		MOVQ 0x8(SP), CX	
	if gp == nil || gp != _m_.curg {
  0x421962		4885c9			TESTQ CX, CX		
  0x421965		740c			JE 0x421973		
  0x421967		488b90c0000000		MOVQ 0xc0(AX), DX	
  0x42196e		4839d1			CMPQ DX, CX		
  0x421971		7406			JE 0x421979		
		return false
  0x421973		c644241000		MOVB $0x0, 0x10(SP)	
  0x421978		c3			RET			
	if _m_.locks-_m_.softfloat != 0 || _m_.mallocing != 0 || _m_.throwing != 0 || _m_.preemptoff != "" || _m_.dying != 0 {
  0x421979		8b9000010000		MOVL 0x100(AX), DX	
  0x42197f		2b9004010000		SUBL 0x104(AX), DX	
  0x421985		85d2			TESTL DX, DX		
  0x421987		7406			JE 0x42198f		
		return false
  0x421989		c644241000		MOVB $0x0, 0x10(SP)	
  0x42198e		c3			RET			
	if _m_.locks-_m_.softfloat != 0 || _m_.mallocing != 0 || _m_.throwing != 0 || _m_.preemptoff != "" || _m_.dying != 0 {
  0x42198f		8b90e8000000		MOVL 0xe8(AX), DX	
  0x421995		85d2			TESTL DX, DX		
  0x421997		75f0			JNE 0x421989		
  0x421999		8b90ec000000		MOVL 0xec(AX), DX	
  0x42199f		85d2			TESTL DX, DX		
  0x4219a1		75e6			JNE 0x421989		
  0x4219a3		488b90f8000000		MOVQ 0xf8(AX), DX	
  0x4219aa		4885d2			TESTQ DX, DX		
  0x4219ad		75da			JNE 0x421989		
  0x4219af		8b8008010000		MOVL 0x108(AX), AX	
  0x4219b5		85c0			TESTL AX, AX		
  0x4219b7		75d0			JNE 0x421989		
	return atomic.Load(&gp.atomicstatus)
  0x4219b9		8b8190000000		MOVL 0x90(CX), AX	
	if status&^_Gscan != _Grunning || gp.syscallsp != 0 {
  0x4219bf		25ffefffff		ANDL $-0x1001, AX	
  0x4219c4		83f802			CMPL $0x2, AX		
  0x4219c7		7406			JE 0x4219cf		
		return false
  0x4219c9		c644241000		MOVB $0x0, 0x10(SP)	
  0x4219ce		c3			RET			
	if status&^_Gscan != _Grunning || gp.syscallsp != 0 {
  0x4219cf		488b4170		MOVQ 0x70(CX), AX	
  0x4219d3		4885c0			TESTQ AX, AX		
  0x4219d6		75f1			JNE 0x4219c9		
	return true
  0x4219d8		c644241001		MOVB $0x1, 0x10(SP)	
  0x4219dd		c3			RET			

TEXT runtime.recordForPanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func recordForPanic(b []byte) {
  0x4219e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4219e9		483b6110		CMPQ 0x10(CX), SP	
  0x4219ed		0f86fd000000		JBE 0x421af0		
  0x4219f3		4883ec30		SUBQ $0x30, SP		
  0x4219f7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4219fc		488d6c2428		LEAQ 0x28(SP), BP	
	printlock()
  0x421a01		e8fa000000		CALL runtime.printlock(SB)	
	if atomic.Load(&panicking) == 0 {
  0x421a06		8b05e81e0a00		MOVL runtime.panicking(SB), AX	
  0x421a0c		85c0			TESTL AX, AX			
  0x421a0e		0f85c6000000		JNE 0x421ada			
  0x421a14		31c0			XORL AX, AX			
		for i := 0; i < len(b); {
  0x421a16		eb59			JMP 0x421a71		
  0x421a18		48894c2418		MOVQ CX, 0x18(SP)	
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x421a1d		488d05bc240a00		LEAQ runtime.printBacklog(SB), AX	
  0x421a24		4801c2			ADDQ AX, DX				
  0x421a27		48891424		MOVQ DX, 0(SP)				
  0x421a2b		48897c2408		MOVQ DI, 0x8(SP)			
  0x421a30		48894c2410		MOVQ CX, 0x10(SP)			
  0x421a35		e8c6560200		CALL runtime.memmove(SB)		
			printBacklogIndex += n
  0x421a3a		488b05671f0a00		MOVQ runtime.printBacklogIndex(SB), AX	
  0x421a41		488b4c2418		MOVQ 0x18(SP), CX			
  0x421a46		4801c8			ADDQ CX, AX				
  0x421a49		4889c2			MOVQ AX, DX				
			printBacklogIndex %= len(printBacklog)
  0x421a4c		48c1f83f		SARQ $0x3f, AX				
  0x421a50		48c1e837		SHRQ $0x37, AX				
  0x421a54		4801d0			ADDQ DX, AX				
  0x421a57		48c1f809		SARQ $0x9, AX				
  0x421a5b		48c1e009		SHLQ $0x9, AX				
  0x421a5f		4829c2			SUBQ AX, DX				
  0x421a62		4889153f1f0a00		MOVQ DX, runtime.printBacklogIndex(SB)	
  0x421a69		488b442420		MOVQ 0x20(SP), AX			
			i += n
  0x421a6e		4801c8			ADDQ CX, AX		
		for i := 0; i < len(b); {
  0x421a71		488b4c2440		MOVQ 0x40(SP), CX	
  0x421a76		4839c8			CMPQ CX, AX		
  0x421a79		7d5f			JGE 0x421ada		
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x421a7b		488b15261f0a00		MOVQ runtime.printBacklogIndex(SB), DX	
  0x421a82		4881fa00020000		CMPQ $0x200, DX				
  0x421a89		775e			JA 0x421ae9				
  0x421a8b		488d9a00feffff		LEAQ 0xfffffe00(DX), BX			
  0x421a92		48f7db			NEGQ BX					
  0x421a95		4889de			MOVQ BX, SI				
  0x421a98		48f7db			NEGQ BX					
  0x421a9b		48c1fb3f		SARQ $0x3f, BX				
  0x421a9f		4821da			ANDQ BX, DX				
		for i := 0; i < len(b); {
  0x421aa2		4839c8			CMPQ CX, AX		
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x421aa5		7742			JA 0x421ae9		
  0x421aa7		4889442420		MOVQ AX, 0x20(SP)	
  0x421aac		4829c1			SUBQ AX, CX		
  0x421aaf		488b7c2448		MOVQ 0x48(SP), DI	
  0x421ab4		4829c7			SUBQ AX, DI		
  0x421ab7		48f7df			NEGQ DI			
  0x421aba		48c1ff3f		SARQ $0x3f, DI		
  0x421abe		4821c7			ANDQ AX, DI		
  0x421ac1		4c8b4c2438		MOVQ 0x38(SP), R9	
  0x421ac6		4c01cf			ADDQ R9, DI		
  0x421ac9		4839ce			CMPQ CX, SI		
  0x421acc		0f8f46ffffff		JG 0x421a18		
  0x421ad2		4889f1			MOVQ SI, CX		
  0x421ad5		e93effffff		JMP 0x421a18		
	printunlock()
  0x421ada		e8a1000000		CALL runtime.printunlock(SB)	
}
  0x421adf		488b6c2428		MOVQ 0x28(SP), BP	
  0x421ae4		4883c430		ADDQ $0x30, SP		
  0x421ae8		c3			RET			
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x421ae9		e8c2dfffff		CALL runtime.panicslice(SB)	
  0x421aee		0f0b			UD2				
func recordForPanic(b []byte) {
  0x421af0		e87b2a0200		CALL runtime.morestack_noctxt(SB)	
  0x421af5		e9e6feffff		JMP runtime.recordForPanic(SB)		

TEXT runtime.printlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printlock() {
  0x421b00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421b09		483b6110		CMPQ 0x10(CX), SP	
  0x421b0d		7662			JBE 0x421b71		
  0x421b0f		4883ec18		SUBQ $0x18, SP		
  0x421b13		48896c2410		MOVQ BP, 0x10(SP)	
  0x421b18		488d6c2410		LEAQ 0x10(SP), BP	
	mp := getg().m
  0x421b1d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x421b26		488b4030		MOVQ 0x30(AX), AX	
	mp.locks++ // do not reschedule between printlock++ and lock(&debuglock).
  0x421b2a		ff8000010000		INCL 0x100(AX)		
	mp.printlock++
  0x421b30		0fb68818010000		MOVZX 0x118(AX), CX	
  0x421b37		8d5101			LEAL 0x1(CX), DX	
  0x421b3a		889018010000		MOVB DL, 0x118(AX)	
	if mp.printlock == 1 {
  0x421b40		84c9			TESTL CL, CL		
  0x421b42		7411			JE 0x421b55		
	mp.locks-- // now we know debuglock is held and holding up mp.locks for us.
  0x421b44		838000010000ff		ADDL $-0x1, 0x100(AX)	
}
  0x421b4b		488b6c2410		MOVQ 0x10(SP), BP	
  0x421b50		4883c418		ADDQ $0x18, SP		
  0x421b54		c3			RET			
  0x421b55		4889442408		MOVQ AX, 0x8(SP)	
		lock(&debuglock)
  0x421b5a		488d05ef1d0a00		LEAQ runtime.debuglock(SB), AX	
  0x421b61		48890424		MOVQ AX, 0(SP)			
  0x421b65		e8b679feff		CALL runtime.lock(SB)		
  0x421b6a		488b442408		MOVQ 0x8(SP), AX		
  0x421b6f		ebd3			JMP 0x421b44			
func printlock() {
  0x421b71		e8fa290200		CALL runtime.morestack_noctxt(SB)	
  0x421b76		eb88			JMP runtime.printlock(SB)		

TEXT runtime.printunlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printunlock() {
  0x421b80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421b89		483b6110		CMPQ 0x10(CX), SP	
  0x421b8d		764c			JBE 0x421bdb		
  0x421b8f		4883ec10		SUBQ $0x10, SP		
  0x421b93		48896c2408		MOVQ BP, 0x8(SP)	
  0x421b98		488d6c2408		LEAQ 0x8(SP), BP	
	mp := getg().m
  0x421b9d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x421ba6		488b4030		MOVQ 0x30(AX), AX	
	mp.printlock--
  0x421baa		0fb68818010000		MOVZX 0x118(AX), CX	
  0x421bb1		8d51ff			LEAL -0x1(CX), DX	
  0x421bb4		889018010000		MOVB DL, 0x118(AX)	
	if mp.printlock == 0 {
  0x421bba		80f901			CMPL $0x1, CL		
  0x421bbd		740a			JE 0x421bc9		
  0x421bbf		488b6c2408		MOVQ 0x8(SP), BP	
  0x421bc4		4883c410		ADDQ $0x10, SP		
  0x421bc8		c3			RET			
		unlock(&debuglock)
  0x421bc9		488d05801d0a00		LEAQ runtime.debuglock(SB), AX	
  0x421bd0		48890424		MOVQ AX, 0(SP)			
  0x421bd4		e8e77afeff		CALL runtime.unlock(SB)		
  0x421bd9		ebe4			JMP 0x421bbf			
func printunlock() {
  0x421bdb		e890290200		CALL runtime.morestack_noctxt(SB)	
  0x421be0		eb9e			JMP runtime.printunlock(SB)		

TEXT runtime.gwrite(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func gwrite(b []byte) {
  0x421bf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421bf9		483b6110		CMPQ 0x10(CX), SP	
  0x421bfd		0f8627010000		JBE 0x421d2a		
  0x421c03		4883ec30		SUBQ $0x30, SP		
  0x421c07		48896c2428		MOVQ BP, 0x28(SP)	
  0x421c0c		488d6c2428		LEAQ 0x28(SP), BP	
  0x421c11		488b442440		MOVQ 0x40(SP), AX	
	if len(b) == 0 {
  0x421c16		4885c0			TESTQ AX, AX		
  0x421c19		0f84f3000000		JE 0x421d12		
  0x421c1f		488b4c2438		MOVQ 0x38(SP), CX	
	recordForPanic(b)
  0x421c24		48890c24		MOVQ CX, 0(SP)			
  0x421c28		4889442408		MOVQ AX, 0x8(SP)		
  0x421c2d		488b542448		MOVQ 0x48(SP), DX		
  0x421c32		4889542410		MOVQ DX, 0x10(SP)		
  0x421c37		e8a4fdffff		CALL runtime.recordForPanic(SB)	
	gp := getg()
  0x421c3c		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp == nil || gp.writebuf == nil {
  0x421c45		4885c0			TESTQ AX, AX		
  0x421c48		0f8498000000		JE 0x421ce6		
  0x421c4e		488b88f0000000		MOVQ 0xf0(AX), CX	
  0x421c55		488b9000010000		MOVQ 0x100(AX), DX	
  0x421c5c		488b98f8000000		MOVQ 0xf8(AX), BX	
  0x421c63		4885c9			TESTQ CX, CX		
  0x421c66		747e			JE 0x421ce6		
	n := copy(gp.writebuf[len(gp.writebuf):cap(gp.writebuf)], b)
  0x421c68		4839d3			CMPQ DX, BX			
  0x421c6b		0f87b2000000		JA 0x421d23			
  0x421c71		4889442420		MOVQ AX, 0x20(SP)		
  0x421c76		4829da			SUBQ BX, DX			
  0x421c79		4889d6			MOVQ DX, SI			
  0x421c7c		48f7da			NEGQ DX				
  0x421c7f		48c1fa3f		SARQ $0x3f, DX			
  0x421c83		4821d3			ANDQ DX, BX			
  0x421c86		4801d9			ADDQ BX, CX			
  0x421c89		488b542440		MOVQ 0x40(SP), DX		
  0x421c8e		4839d6			CMPQ DX, SI			
  0x421c91		7e4e			JLE 0x421ce1			
  0x421c93		4889542418		MOVQ DX, 0x18(SP)		
  0x421c98		48890c24		MOVQ CX, 0(SP)			
  0x421c9c		488b442438		MOVQ 0x38(SP), AX		
  0x421ca1		4889442408		MOVQ AX, 0x8(SP)		
  0x421ca6		4889542410		MOVQ DX, 0x10(SP)		
  0x421cab		e850540200		CALL runtime.memmove(SB)	
  0x421cb0		488b442420		MOVQ 0x20(SP), AX		
	gp.writebuf = gp.writebuf[:len(gp.writebuf)+n]
  0x421cb5		488b8800010000		MOVQ 0x100(AX), CX	
  0x421cbc		488b90f8000000		MOVQ 0xf8(AX), DX	
  0x421cc3		488b5c2418		MOVQ 0x18(SP), BX	
  0x421cc8		4801da			ADDQ BX, DX		
  0x421ccb		4839ca			CMPQ CX, DX		
  0x421cce		774c			JA 0x421d1c		
  0x421cd0		488990f8000000		MOVQ DX, 0xf8(AX)	
}
  0x421cd7		488b6c2428		MOVQ 0x28(SP), BP	
  0x421cdc		4883c430		ADDQ $0x30, SP		
  0x421ce0		c3			RET			
  0x421ce1		4889f2			MOVQ SI, DX		
	n := copy(gp.writebuf[len(gp.writebuf):cap(gp.writebuf)], b)
  0x421ce4		ebad			JMP 0x421c93		
  0x421ce6		488b442438		MOVQ 0x38(SP), AX	
		writeErr(b)
  0x421ceb		48890424		MOVQ AX, 0(SP)			
  0x421cef		488b442440		MOVQ 0x40(SP), AX		
  0x421cf4		4889442408		MOVQ AX, 0x8(SP)		
  0x421cf9		488b442448		MOVQ 0x48(SP), AX		
  0x421cfe		4889442410		MOVQ AX, 0x10(SP)		
  0x421d03		e8f8fa0100		CALL runtime.writeErr(SB)	
		return
  0x421d08		488b6c2428		MOVQ 0x28(SP), BP	
  0x421d0d		4883c430		ADDQ $0x30, SP		
  0x421d11		c3			RET			
		return
  0x421d12		488b6c2428		MOVQ 0x28(SP), BP	
  0x421d17		4883c430		ADDQ $0x30, SP		
  0x421d1b		c3			RET			
	gp.writebuf = gp.writebuf[:len(gp.writebuf)+n]
  0x421d1c		e88fddffff		CALL runtime.panicslice(SB)	
  0x421d21		0f0b			UD2				
	n := copy(gp.writebuf[len(gp.writebuf):cap(gp.writebuf)], b)
  0x421d23		e888ddffff		CALL runtime.panicslice(SB)	
  0x421d28		0f0b			UD2				
func gwrite(b []byte) {
  0x421d2a		e841280200		CALL runtime.morestack_noctxt(SB)	
  0x421d2f		e9bcfeffff		JMP runtime.gwrite(SB)			

TEXT runtime.printsp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printsp() {
  0x421d40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421d49		483b6110		CMPQ 0x10(CX), SP	
  0x421d4d		7631			JBE 0x421d80		
  0x421d4f		4883ec18		SUBQ $0x18, SP		
  0x421d53		48896c2410		MOVQ BP, 0x10(SP)	
  0x421d58		488d6c2410		LEAQ 0x10(SP), BP	
	printstring(" ")
  0x421d5d		488d05ec7e0400		LEAQ 0x47eec(IP), AX		
  0x421d64		48890424		MOVQ AX, 0(SP)			
  0x421d68		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x421d71		e8ca060000		CALL runtime.printstring(SB)	
}
  0x421d76		488b6c2410		MOVQ 0x10(SP), BP	
  0x421d7b		4883c418		ADDQ $0x18, SP		
  0x421d7f		c3			RET			
func printsp() {
  0x421d80		e8eb270200		CALL runtime.morestack_noctxt(SB)	
  0x421d85		ebb9			JMP runtime.printsp(SB)			

TEXT runtime.printnl(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printnl() {
  0x421d90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421d99		483b6110		CMPQ 0x10(CX), SP	
  0x421d9d		7631			JBE 0x421dd0		
  0x421d9f		4883ec18		SUBQ $0x18, SP		
  0x421da3		48896c2410		MOVQ BP, 0x10(SP)	
  0x421da8		488d6c2410		LEAQ 0x10(SP), BP	
	printstring("\n")
  0x421dad		488d05a97e0400		LEAQ 0x47ea9(IP), AX		
  0x421db4		48890424		MOVQ AX, 0(SP)			
  0x421db8		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x421dc1		e87a060000		CALL runtime.printstring(SB)	
}
  0x421dc6		488b6c2410		MOVQ 0x10(SP), BP	
  0x421dcb		4883c418		ADDQ $0x18, SP		
  0x421dcf		c3			RET			
func printnl() {
  0x421dd0		e89b270200		CALL runtime.morestack_noctxt(SB)	
  0x421dd5		ebb9			JMP runtime.printnl(SB)			

TEXT runtime.printbool(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printbool(v bool) {
  0x421de0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421de9		483b6110		CMPQ 0x10(CX), SP	
  0x421ded		7655			JBE 0x421e44		
  0x421def		4883ec18		SUBQ $0x18, SP		
  0x421df3		48896c2410		MOVQ BP, 0x10(SP)	
  0x421df8		488d6c2410		LEAQ 0x10(SP), BP	
  0x421dfd		0fb6442420		MOVZX 0x20(SP), AX	
  0x421e02		84c0			TESTL AL, AL		
	if v {
  0x421e04		7423			JE 0x421e29		
		printstring("true")
  0x421e06		488d05257f0400		LEAQ 0x47f25(IP), AX		
  0x421e0d		48890424		MOVQ AX, 0(SP)			
  0x421e11		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x421e1a		e821060000		CALL runtime.printstring(SB)	
  0x421e1f		488b6c2410		MOVQ 0x10(SP), BP		
  0x421e24		4883c418		ADDQ $0x18, SP			
  0x421e28		c3			RET				
		printstring("false")
  0x421e29		488d05977f0400		LEAQ 0x47f97(IP), AX		
  0x421e30		48890424		MOVQ AX, 0(SP)			
  0x421e34		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x421e3d		e8fe050000		CALL runtime.printstring(SB)	
  0x421e42		ebdb			JMP 0x421e1f			
func printbool(v bool) {
  0x421e44		e827270200		CALL runtime.morestack_noctxt(SB)	
  0x421e49		eb95			JMP runtime.printbool(SB)		

TEXT runtime.printfloat(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printfloat(v float64) {
  0x421e50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421e59		483b6110		CMPQ 0x10(CX), SP	
  0x421e5d		0f8672020000		JBE 0x4220d5		
  0x421e63		4883ec30		SUBQ $0x30, SP		
  0x421e67		48896c2428		MOVQ BP, 0x28(SP)	
  0x421e6c		488d6c2428		LEAQ 0x28(SP), BP	
  0x421e71		f20f10442438		MOVSD_XMM 0x38(SP), X0	
	case v != v:
  0x421e77		660f2ec0		UCOMISD X0, X0		
  0x421e7b		0f8531020000		JNE 0x4220b2		
  0x421e81		0f8a2b020000		JP 0x4220b2		
  0x421e87		0f10c8			MOVUPS X0, X1		
	case v+v == v && v > 0:
  0x421e8a		f20f58c0		ADDSD X0, X0		
  0x421e8e		660f2ec8		UCOMISD X0, X1		
  0x421e92		0f8512020000		JNE 0x4220aa		
  0x421e98		0f8a0c020000		JP 0x4220aa		
  0x421e9e		0f57d2			XORPS X2, X2		
  0x421ea1		660f2eca		UCOMISD X2, X1		
  0x421ea5		0f87dc010000		JA 0x422087		
  0x421eab		660f2ec8		UCOMISD X0, X1		
	case v+v == v && v < 0:
  0x421eaf		750c			JNE 0x421ebd		
  0x421eb1		7a0a			JP 0x421ebd		
  0x421eb3		660f2ed1		UCOMISD X1, X2		
  0x421eb7		0f87a7010000		JA 0x422064		
	var buf [n + 7]byte
  0x421ebd		48c744241a00000000	MOVQ $0x0, 0x1a(SP)	
  0x421ec6		48c744242000000000	MOVQ $0x0, 0x20(SP)	
	buf[0] = '+'
  0x421ecf		c644241a2b		MOVB $0x2b, 0x1a(SP)	
	if v == 0 {
  0x421ed4		660f2ed1		UCOMISD X1, X2		
  0x421ed8		0f8508010000		JNE 0x421fe6		
  0x421ede		0f8a02010000		JP 0x421fe6		
		if 1/v < 0 {
  0x421ee4		f20f1005e42b0500	MOVSD_XMM $f64.3ff0000000000000(SB), X0	
  0x421eec		f20f5ec1		DIVSD X1, X0				
  0x421ef0		660f2ed0		UCOMISD X0, X2				
  0x421ef4		7605			JBE 0x421efb				
			buf[0] = '-'
  0x421ef6		c644241a2d		MOVB $0x2d, 0x1a(SP)	
  0x421efb		31c0			XORL AX, AX		
	for i := 0; i < n; i++ {
  0x421efd		31c9			XORL CX, CX		
  0x421eff		eb28			JMP 0x421f29		
		s := int(v)
  0x421f01		f2480f2cd1		CVTTSD2SIQ X1, DX	
		buf[i+2] = byte(s + '0')
  0x421f06		488d5a30		LEAQ 0x30(DX), BX	
  0x421f0a		885c0c1c		MOVB BL, 0x1c(SP)(CX*1)	
	for i := 0; i < n; i++ {
  0x421f0e		48ffc1			INCQ CX			
		v -= float64(s)
  0x421f11		0f57c0			XORPS X0, X0		
  0x421f14		f2480f2ac2		CVTSI2SDQ DX, X0	
  0x421f19		f20f5cc8		SUBSD X0, X1		
		v *= 10
  0x421f1d		f20f1005d32b0500	MOVSD_XMM $f64.4024000000000000(SB), X0	
  0x421f25		f20f59c8		MULSD X0, X1				
	for i := 0; i < n; i++ {
  0x421f29		4883f907		CMPQ $0x7, CX		
  0x421f2d		7cd2			JL 0x421f01		
	buf[1] = buf[2]
  0x421f2f		0fb64c241c		MOVZX 0x1c(SP), CX	
  0x421f34		884c241b		MOVB CL, 0x1b(SP)	
	buf[2] = '.'
  0x421f38		c644241c2e		MOVB $0x2e, 0x1c(SP)	
	buf[n+3] = '+'
  0x421f3d		66c7442423652b		MOVW $0x2b65, 0x23(SP)	
	if e < 0 {
  0x421f44		4885c0			TESTQ AX, AX		
  0x421f47		7d08			JGE 0x421f51		
		buf[n+3] = '-'
  0x421f49		c64424242d		MOVB $0x2d, 0x24(SP)	
		e = -e
  0x421f4e		48f7d8			NEGQ AX			
		buf[n+3] = '-'
  0x421f51		4889c1			MOVQ AX, CX		
	buf[n+4] = byte(e/100) + '0'
  0x421f54		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX	
  0x421f5e		48f7e9			IMULQ CX			
  0x421f61		4801ca			ADDQ CX, DX			
  0x421f64		4889cb			MOVQ CX, BX			
  0x421f67		48c1f93f		SARQ $0x3f, CX			
  0x421f6b		48c1fa06		SARQ $0x6, DX			
  0x421f6f		4829ca			SUBQ CX, DX			
  0x421f72		83c230			ADDL $0x30, DX			
  0x421f75		88542425		MOVB DL, 0x25(SP)		
	buf[n+5] = byte(e/10)%10 + '0'
  0x421f79		48b8cdcccccccccccccc	MOVQ $0xcccccccccccccccd, AX	
  0x421f83		48f7eb			IMULQ BX			
	buf[n+6] = byte(e%10) + '0'
  0x421f86		4801da			ADDQ BX, DX		
	buf[n+5] = byte(e/10)%10 + '0'
  0x421f89		48c1fa03		SARQ $0x3, DX		
  0x421f8d		4829ca			SUBQ CX, DX		
  0x421f90		0fb6ca			MOVZX DL, CX		
  0x421f93		69c99a010000		IMULL $0x19a, CX, CX	
  0x421f99		c1e90c			SHRL $0xc, CX		
  0x421f9c		6bc90a			IMULL $0xa, CX, CX	
  0x421f9f		4889d6			MOVQ DX, SI		
  0x421fa2		29ca			SUBL CX, DX		
  0x421fa4		8d4a30			LEAL 0x30(DX), CX	
  0x421fa7		884c2426		MOVB CL, 0x26(SP)	
	buf[n+6] = byte(e%10) + '0'
  0x421fab		488d0cb6		LEAQ 0(SI)(SI*4), CX	
  0x421faf		48d1e1			SHLQ $0x1, CX		
  0x421fb2		4829cb			SUBQ CX, BX		
  0x421fb5		8d4b30			LEAL 0x30(BX), CX	
  0x421fb8		884c2427		MOVB CL, 0x27(SP)	
	gwrite(buf[:])
  0x421fbc		488d4c241a		LEAQ 0x1a(SP), CX	
  0x421fc1		48890c24		MOVQ CX, 0(SP)		
  0x421fc5		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x421fce		48c74424100e000000	MOVQ $0xe, 0x10(SP)	
  0x421fd7		e814fcffff		CALL runtime.gwrite(SB)	
}
  0x421fdc		488b6c2428		MOVQ 0x28(SP), BP	
  0x421fe1		4883c430		ADDQ $0x30, SP		
  0x421fe5		c3			RET			
		if v < 0 {
  0x421fe6		7611			JBE 0x421ff9		
			buf[0] = '-'
  0x421fe8		c644241a2d		MOVB $0x2d, 0x1a(SP)	
			v = -v
  0x421fed		f20f10052b2b0500	MOVSD_XMM $f64.8000000000000000(SB), X0	
  0x421ff5		660fefc8		PXOR X0, X1				
			buf[0] = '-'
  0x421ff9		31c0			XORL AX, AX		
		for v >= 10 {
  0x421ffb		eb07			JMP 0x422004		
			e++
  0x421ffd		48ffc0			INCQ AX			
			v /= 10
  0x422000		f20f5ec8		DIVSD X0, X1		
		for v >= 10 {
  0x422004		f20f1005ec2a0500	MOVSD_XMM $f64.4024000000000000(SB), X0	
  0x42200c		660f2ec8		UCOMISD X0, X1				
  0x422010		73eb			JAE 0x421ffd				
  0x422012		eb07			JMP 0x42201b				
			e--
  0x422014		48ffc8			DECQ AX			
			v *= 10
  0x422017		f20f59c8		MULSD X0, X1		
		for v < 1 {
  0x42201b		f20f1015ad2a0500	MOVSD_XMM $f64.3ff0000000000000(SB), X2	
  0x422023		660f2ed1		UCOMISD X1, X2				
  0x422027		77eb			JA 0x422014				
  0x422029		31c9			XORL CX, CX				
  0x42202b		f20f1015bd2a0500	MOVSD_XMM $f64.4014000000000000(SB), X2	
		for i := 0; i < n; i++ {
  0x422033		eb07			JMP 0x42203c		
  0x422035		48ffc1			INCQ CX			
			h /= 10
  0x422038		f20f5ed0		DIVSD X0, X2		
		for i := 0; i < n; i++ {
  0x42203c		4883f907		CMPQ $0x7, CX		
  0x422040		7cf3			JL 0x422035		
		v += h
  0x422042		f20f58d1		ADDSD X1, X2		
		if v >= 10 {
  0x422046		660f2ed0		UCOMISD X0, X2		
  0x42204a		7213			JB 0x42205f		
			e++
  0x42204c		488d4801		LEAQ 0x1(AX), CX	
			v /= 10
  0x422050		f20f5ed0		DIVSD X0, X2		
  0x422054		0f10ca			MOVUPS X2, X1		
  0x422057		4889c8			MOVQ CX, AX		
	for i := 0; i < n; i++ {
  0x42205a		e99efeffff		JMP 0x421efd		
  0x42205f		4889c1			MOVQ AX, CX		
		if v >= 10 {
  0x422062		ebf0			JMP 0x422054		
		printstring("-Inf")
  0x422064		488d05837c0400		LEAQ 0x47c83(IP), AX		
  0x42206b		48890424		MOVQ AX, 0(SP)			
  0x42206f		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x422078		e8c3030000		CALL runtime.printstring(SB)	
		return
  0x42207d		488b6c2428		MOVQ 0x28(SP), BP	
  0x422082		4883c430		ADDQ $0x30, SP		
  0x422086		c3			RET			
		printstring("+Inf")
  0x422087		488d05587c0400		LEAQ 0x47c58(IP), AX		
  0x42208e		48890424		MOVQ AX, 0(SP)			
  0x422092		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x42209b		e8a0030000		CALL runtime.printstring(SB)	
		return
  0x4220a0		488b6c2428		MOVQ 0x28(SP), BP	
  0x4220a5		4883c430		ADDQ $0x30, SP		
  0x4220a9		c3			RET			
  0x4220aa		0f57d2			XORPS X2, X2		
	case v+v == v && v > 0:
  0x4220ad		e9fdfdffff		JMP 0x421eaf		
		printstring("NaN")
  0x4220b2		488d05e67b0400		LEAQ 0x47be6(IP), AX		
  0x4220b9		48890424		MOVQ AX, 0(SP)			
  0x4220bd		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4220c6		e875030000		CALL runtime.printstring(SB)	
		return
  0x4220cb		488b6c2428		MOVQ 0x28(SP), BP	
  0x4220d0		4883c430		ADDQ $0x30, SP		
  0x4220d4		c3			RET			
func printfloat(v float64) {
  0x4220d5		e896240200		CALL runtime.morestack_noctxt(SB)	
  0x4220da		e971fdffff		JMP runtime.printfloat(SB)		

TEXT runtime.printcomplex(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printcomplex(c complex128) {
  0x4220e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4220e9		483b6110		CMPQ 0x10(CX), SP	
  0x4220ed		7674			JBE 0x422163		
  0x4220ef		4883ec18		SUBQ $0x18, SP		
  0x4220f3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4220f8		488d6c2410		LEAQ 0x10(SP), BP	
	print("(", real(c), imag(c), "i)")
  0x4220fd		e8fef9ffff		CALL runtime.printlock(SB)	
  0x422102		488d05487b0400		LEAQ 0x47b48(IP), AX		
  0x422109		48890424		MOVQ AX, 0(SP)			
  0x42210d		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x422116		e825030000		CALL runtime.printstring(SB)	
func printcomplex(c complex128) {
  0x42211b		f20f10442420		MOVSD_XMM 0x20(SP), X0	
	print("(", real(c), imag(c), "i)")
  0x422121		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x422126		e825fdffff		CALL runtime.printfloat(SB)	
func printcomplex(c complex128) {
  0x42212b		f20f10442428		MOVSD_XMM 0x28(SP), X0	
	print("(", real(c), imag(c), "i)")
  0x422131		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x422136		e815fdffff		CALL runtime.printfloat(SB)	
  0x42213b		488d05367b0400		LEAQ 0x47b36(IP), AX		
  0x422142		48890424		MOVQ AX, 0(SP)			
  0x422146		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42214f		e8ec020000		CALL runtime.printstring(SB)	
  0x422154		e827faffff		CALL runtime.printunlock(SB)	
}
  0x422159		488b6c2410		MOVQ 0x10(SP), BP	
  0x42215e		4883c418		ADDQ $0x18, SP		
  0x422162		c3			RET			
func printcomplex(c complex128) {
  0x422163		e808240200		CALL runtime.morestack_noctxt(SB)	
  0x422168		e973ffffff		JMP runtime.printcomplex(SB)		

TEXT runtime.printuint(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printuint(v uint64) {
  0x422170		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422179		488d4424f8		LEAQ -0x8(SP), AX	
  0x42217e		483b4110		CMPQ 0x10(CX), AX	
  0x422182		0f86ea000000		JBE 0x422272		
  0x422188		4881ec88000000		SUBQ $0x88, SP		
  0x42218f		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x422197		488dac2480000000	LEAQ 0x80(SP), BP	
	var buf [100]byte
  0x42219f		48c744241c00000000	MOVQ $0x0, 0x1c(SP)	
  0x4221a8		488d7c2420		LEAQ 0x20(SP), DI	
  0x4221ad		0f57c0			XORPS X0, X0		
  0x4221b0		488d7fe0		LEAQ -0x20(DI), DI	
  0x4221b4		48896c24f0		MOVQ BP, -0x10(SP)	
  0x4221b9		488d6c24f0		LEAQ -0x10(SP), BP	
  0x4221be		e8ee480200		CALL 0x446ab1		
  0x4221c3		488b6d00		MOVQ 0(BP), BP		
func printuint(v uint64) {
  0x4221c7		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x4221cf		b863000000		MOVL $0x63, AX		
	for i--; i > 0; i-- {
  0x4221d4		eb07			JMP 0x4221dd		
  0x4221d6		488d46ff		LEAQ -0x1(SI), AX	
  0x4221da		4889d1			MOVQ DX, CX		
  0x4221dd		4885c0			TESTQ AX, AX		
  0x4221e0		7e7d			JLE 0x42225f		
  0x4221e2		4889c2			MOVQ AX, DX		
  0x4221e5		4889c8			MOVQ CX, AX		
		buf[i] = byte(v%10 + '0')
  0x4221e8		48bbcdcccccccccccccc	MOVQ $0xcccccccccccccccd, BX	
  0x4221f2		4889d6			MOVQ DX, SI			
  0x4221f5		48f7e3			MULQ BX				
  0x4221f8		48c1ea03		SHRQ $0x3, DX			
  0x4221fc		488d3c92		LEAQ 0(DX)(DX*4), DI		
  0x422200		48d1e7			SHLQ $0x1, DI			
  0x422203		4989c8			MOVQ CX, R8			
  0x422206		4829f9			SUBQ DI, CX			
  0x422209		4883fe64		CMPQ $0x64, SI			
  0x42220d		735c			JAE 0x42226b			
  0x42220f		4883c130		ADDQ $0x30, CX			
  0x422213		884c341c		MOVB CL, 0x1c(SP)(SI*1)		
		if v < 10 {
  0x422217		4983f80a		CMPQ $0xa, R8		
  0x42221b		73b9			JAE 0x4221d6		
	gwrite(buf[i:])
  0x42221d		4883fe64		CMPQ $0x64, SI		
  0x422221		7741			JA 0x422264		
  0x422223		488d469c		LEAQ -0x64(SI), AX	
  0x422227		48f7d8			NEGQ AX			
  0x42222a		4889c1			MOVQ AX, CX		
  0x42222d		48f7d8			NEGQ AX			
  0x422230		48c1f83f		SARQ $0x3f, AX		
  0x422234		4821c6			ANDQ AX, SI		
  0x422237		488d44341c		LEAQ 0x1c(SP)(SI*1), AX	
  0x42223c		48890424		MOVQ AX, 0(SP)		
  0x422240		48894c2408		MOVQ CX, 0x8(SP)	
  0x422245		48894c2410		MOVQ CX, 0x10(SP)	
  0x42224a		e8a1f9ffff		CALL runtime.gwrite(SB)	
}
  0x42224f		488bac2480000000	MOVQ 0x80(SP), BP	
  0x422257		4881c488000000		ADDQ $0x88, SP		
  0x42225e		c3			RET			
  0x42225f		4889c6			MOVQ AX, SI		
	for i--; i > 0; i-- {
  0x422262		ebb9			JMP 0x42221d		
	gwrite(buf[i:])
  0x422264		e847d8ffff		CALL runtime.panicslice(SB)	
  0x422269		0f0b			UD2				
		buf[i] = byte(v%10 + '0')
  0x42226b		e8d0d7ffff		CALL runtime.panicindex(SB)	
  0x422270		0f0b			UD2				
func printuint(v uint64) {
  0x422272		e8f9220200		CALL runtime.morestack_noctxt(SB)	
  0x422277		e9f4feffff		JMP runtime.printuint(SB)		

TEXT runtime.printint(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printint(v int64) {
  0x422280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422289		483b6110		CMPQ 0x10(CX), SP	
  0x42228d		764e			JBE 0x4222dd		
  0x42228f		4883ec18		SUBQ $0x18, SP		
  0x422293		48896c2410		MOVQ BP, 0x10(SP)	
  0x422298		488d6c2410		LEAQ 0x10(SP), BP	
  0x42229d		488b442420		MOVQ 0x20(SP), AX	
	if v < 0 {
  0x4222a2		4885c0			TESTQ AX, AX		
  0x4222a5		7c13			JL 0x4222ba		
	printuint(uint64(v))
  0x4222a7		48890424		MOVQ AX, 0(SP)			
  0x4222ab		e8c0feffff		CALL runtime.printuint(SB)	
}
  0x4222b0		488b6c2410		MOVQ 0x10(SP), BP	
  0x4222b5		4883c418		ADDQ $0x18, SP		
  0x4222b9		c3			RET			
		printstring("-")
  0x4222ba		488d0594790400		LEAQ 0x47994(IP), AX		
  0x4222c1		48890424		MOVQ AX, 0(SP)			
  0x4222c5		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4222ce		e86d010000		CALL runtime.printstring(SB)	
  0x4222d3		488b442420		MOVQ 0x20(SP), AX		
		v = -v
  0x4222d8		48f7d8			NEGQ AX			
  0x4222db		ebca			JMP 0x4222a7		
func printint(v int64) {
  0x4222dd		e88e220200		CALL runtime.morestack_noctxt(SB)	
  0x4222e2		eb9c			JMP runtime.printint(SB)		

TEXT runtime.printhex(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printhex(v uint64) {
  0x4222f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4222f9		488d4424f8		LEAQ -0x8(SP), AX	
  0x4222fe		483b4110		CMPQ 0x10(CX), AX	
  0x422302		0f86ee000000		JBE 0x4223f6		
  0x422308		4881ec88000000		SUBQ $0x88, SP		
  0x42230f		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x422317		488dac2480000000	LEAQ 0x80(SP), BP	
	var buf [100]byte
  0x42231f		48c744241c00000000	MOVQ $0x0, 0x1c(SP)	
  0x422328		488d7c2420		LEAQ 0x20(SP), DI	
  0x42232d		0f57c0			XORPS X0, X0		
  0x422330		488d7fe0		LEAQ -0x20(DI), DI	
  0x422334		48896c24f0		MOVQ BP, -0x10(SP)	
  0x422339		488d6c24f0		LEAQ -0x10(SP), BP	
  0x42233e		e86e470200		CALL 0x446ab1		
  0x422343		488b6d00		MOVQ 0(BP), BP		
func printhex(v uint64) {
  0x422347		488b842490000000	MOVQ 0x90(SP), AX	
  0x42234f		b963000000		MOVL $0x63, CX		
	for i--; i > 0; i-- {
  0x422354		eb0a			JMP 0x422360		
  0x422356		48ffc9			DECQ CX			
		v /= 16
  0x422359		48c1ea04		SHRQ $0x4, DX		
  0x42235d		4889d0			MOVQ DX, AX		
	for i--; i > 0; i-- {
  0x422360		4885c9			TESTQ CX, CX		
  0x422363		7e22			JLE 0x422387		
  0x422365		4889c2			MOVQ AX, DX		
		buf[i] = dig[v%16]
  0x422368		4883e00f		ANDQ $0xf, AX		
  0x42236c		488d1dbf860400		LEAQ 0x486bf(IP), BX	
  0x422373		0fb60403		MOVZX 0(BX)(AX*1), AX	
  0x422377		4883f964		CMPQ $0x64, CX		
  0x42237b		7372			JAE 0x4223ef		
  0x42237d		88440c1c		MOVB AL, 0x1c(SP)(CX*1)	
		if v < 16 {
  0x422381		4883fa10		CMPQ $0x10, DX		
  0x422385		73cf			JAE 0x422356		
	i--
  0x422387		488d41ff		LEAQ -0x1(CX), AX	
	buf[i] = 'x'
  0x42238b		4883f864		CMPQ $0x64, AX			
  0x42238f		7357			JAE 0x4223e8			
  0x422391		c6440c1b78		MOVB $0x78, 0x1b(SP)(CX*1)	
	i--
  0x422396		488d41fe		LEAQ -0x2(CX), AX	
	buf[i] = '0'
  0x42239a		4883f864		CMPQ $0x64, AX			
  0x42239e		7341			JAE 0x4223e1			
  0x4223a0		c6440c1a30		MOVB $0x30, 0x1a(SP)(CX*1)	
	gwrite(buf[i:])
  0x4223a5		4883c19a		ADDQ $-0x66, CX		
  0x4223a9		48f7d9			NEGQ CX			
  0x4223ac		4889ca			MOVQ CX, DX		
  0x4223af		48f7d9			NEGQ CX			
  0x4223b2		48c1f93f		SARQ $0x3f, CX		
  0x4223b6		4821c8			ANDQ CX, AX		
  0x4223b9		488d44041c		LEAQ 0x1c(SP)(AX*1), AX	
  0x4223be		48890424		MOVQ AX, 0(SP)		
  0x4223c2		4889542408		MOVQ DX, 0x8(SP)	
  0x4223c7		4889542410		MOVQ DX, 0x10(SP)	
  0x4223cc		e81ff8ffff		CALL runtime.gwrite(SB)	
}
  0x4223d1		488bac2480000000	MOVQ 0x80(SP), BP	
  0x4223d9		4881c488000000		ADDQ $0x88, SP		
  0x4223e0		c3			RET			
	buf[i] = '0'
  0x4223e1		e85ad6ffff		CALL runtime.panicindex(SB)	
  0x4223e6		0f0b			UD2				
	buf[i] = 'x'
  0x4223e8		e853d6ffff		CALL runtime.panicindex(SB)	
  0x4223ed		0f0b			UD2				
		buf[i] = dig[v%16]
  0x4223ef		e84cd6ffff		CALL runtime.panicindex(SB)	
  0x4223f4		0f0b			UD2				
func printhex(v uint64) {
  0x4223f6		e875210200		CALL runtime.morestack_noctxt(SB)	
  0x4223fb		e9f0feffff		JMP runtime.printhex(SB)		

TEXT runtime.printpointer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printpointer(p unsafe.Pointer) {
  0x422400		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422409		483b6110		CMPQ 0x10(CX), SP	
  0x42240d		7626			JBE 0x422435		
  0x42240f		4883ec10		SUBQ $0x10, SP		
  0x422413		48896c2408		MOVQ BP, 0x8(SP)	
  0x422418		488d6c2408		LEAQ 0x8(SP), BP	
  0x42241d		488b442418		MOVQ 0x18(SP), AX	
	printhex(uint64(uintptr(p)))
  0x422422		48890424		MOVQ AX, 0(SP)			
  0x422426		e8c5feffff		CALL runtime.printhex(SB)	
}
  0x42242b		488b6c2408		MOVQ 0x8(SP), BP	
  0x422430		4883c410		ADDQ $0x10, SP		
  0x422434		c3			RET			
func printpointer(p unsafe.Pointer) {
  0x422435		e836210200		CALL runtime.morestack_noctxt(SB)	
  0x42243a		ebc4			JMP runtime.printpointer(SB)		

TEXT runtime.printstring(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printstring(s string) {
  0x422440		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422449		483b6110		CMPQ 0x10(CX), SP	
  0x42244d		7678			JBE 0x4224c7		
  0x42244f		4883ec48		SUBQ $0x48, SP		
  0x422453		48896c2440		MOVQ BP, 0x40(SP)	
  0x422458		488d6c2440		LEAQ 0x40(SP), BP	
  0x42245d		488b442450		MOVQ 0x50(SP), AX	
	gwrite(bytes(s))
  0x422462		4889442418		MOVQ AX, 0x18(SP)	
func printstring(s string) {
  0x422467		488b442458		MOVQ 0x58(SP), AX	
	gwrite(bytes(s))
  0x42246c		4889442420		MOVQ AX, 0x20(SP)	
  0x422471		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x42247a		0f57c0			XORPS X0, X0		
  0x42247d		0f11442430		MOVUPS X0, 0x30(SP)	
	rp.array = sp.str
  0x422482		488b442418		MOVQ 0x18(SP), AX	
  0x422487		4889442428		MOVQ AX, 0x28(SP)	
	rp.len = sp.len
  0x42248c		488b442420		MOVQ 0x20(SP), AX	
  0x422491		4889442430		MOVQ AX, 0x30(SP)	
	rp.cap = sp.len
  0x422496		488b442420		MOVQ 0x20(SP), AX	
  0x42249b		4889442438		MOVQ AX, 0x38(SP)	
	gwrite(bytes(s))
  0x4224a0		488b4c2430		MOVQ 0x30(SP), CX	
  0x4224a5		488b542428		MOVQ 0x28(SP), DX	
  0x4224aa		48891424		MOVQ DX, 0(SP)		
  0x4224ae		48894c2408		MOVQ CX, 0x8(SP)	
  0x4224b3		4889442410		MOVQ AX, 0x10(SP)	
  0x4224b8		e833f7ffff		CALL runtime.gwrite(SB)	
}
  0x4224bd		488b6c2440		MOVQ 0x40(SP), BP	
  0x4224c2		4883c448		ADDQ $0x48, SP		
  0x4224c6		c3			RET			
func printstring(s string) {
  0x4224c7		e8a4200200		CALL runtime.morestack_noctxt(SB)	
  0x4224cc		e96fffffff		JMP runtime.printstring(SB)		

TEXT runtime.printslice(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printslice(s []byte) {
  0x4224e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4224e9		483b6110		CMPQ 0x10(CX), SP	
  0x4224ed		0f86ab000000		JBE 0x42259e		
  0x4224f3		4883ec28		SUBQ $0x28, SP		
  0x4224f7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4224fc		488d6c2420		LEAQ 0x20(SP), BP	
	print("[", len(s), "/", cap(s), "]")
  0x422501		488b442440		MOVQ 0x40(SP), AX		
  0x422506		4889442418		MOVQ AX, 0x18(SP)		
  0x42250b		488b4c2438		MOVQ 0x38(SP), CX		
  0x422510		48894c2410		MOVQ CX, 0x10(SP)		
  0x422515		e8e6f5ffff		CALL runtime.printlock(SB)	
  0x42251a		488d053b770400		LEAQ 0x4773b(IP), AX		
  0x422521		48890424		MOVQ AX, 0(SP)			
  0x422525		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42252e		e80dffffff		CALL runtime.printstring(SB)	
  0x422533		488b442410		MOVQ 0x10(SP), AX		
  0x422538		48890424		MOVQ AX, 0(SP)			
  0x42253c		e83ffdffff		CALL runtime.printint(SB)	
  0x422541		488d050f770400		LEAQ 0x4770f(IP), AX		
  0x422548		48890424		MOVQ AX, 0(SP)			
  0x42254c		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x422555		e8e6feffff		CALL runtime.printstring(SB)	
  0x42255a		488b442418		MOVQ 0x18(SP), AX		
  0x42255f		48890424		MOVQ AX, 0(SP)			
  0x422563		e818fdffff		CALL runtime.printint(SB)	
  0x422568		488d05f0760400		LEAQ 0x476f0(IP), AX		
  0x42256f		48890424		MOVQ AX, 0(SP)			
  0x422573		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42257c		e8bffeffff		CALL runtime.printstring(SB)	
  0x422581		e8faf5ffff		CALL runtime.printunlock(SB)	
	printpointer(sp.array)
  0x422586		488b442430		MOVQ 0x30(SP), AX		
  0x42258b		48890424		MOVQ AX, 0(SP)			
  0x42258f		e86cfeffff		CALL runtime.printpointer(SB)	
}
  0x422594		488b6c2420		MOVQ 0x20(SP), BP	
  0x422599		4883c428		ADDQ $0x28, SP		
  0x42259d		c3			RET			
func printslice(s []byte) {
  0x42259e		e8cd1f0200		CALL runtime.morestack_noctxt(SB)	
  0x4225a3		e938ffffff		JMP runtime.printslice(SB)		

TEXT runtime.printeface(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func printeface(e eface) {
  0x4225b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4225b9		483b6110		CMPQ 0x10(CX), SP	
  0x4225bd		0f8689000000		JBE 0x42264c		
  0x4225c3		4883ec18		SUBQ $0x18, SP		
  0x4225c7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4225cc		488d6c2410		LEAQ 0x10(SP), BP	
	print("(", e._type, ",", e.data, ")")
  0x4225d1		e82af5ffff		CALL runtime.printlock(SB)	
  0x4225d6		488d0574760400		LEAQ 0x47674(IP), AX		
  0x4225dd		48890424		MOVQ AX, 0(SP)			
  0x4225e1		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4225ea		e851feffff		CALL runtime.printstring(SB)	
func printeface(e eface) {
  0x4225ef		488b442420		MOVQ 0x20(SP), AX	
	print("(", e._type, ",", e.data, ")")
  0x4225f4		48890424		MOVQ AX, 0(SP)			
  0x4225f8		e803feffff		CALL runtime.printpointer(SB)	
  0x4225fd		488d0550760400		LEAQ 0x47650(IP), AX		
  0x422604		48890424		MOVQ AX, 0(SP)			
  0x422608		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x422611		e82afeffff		CALL runtime.printstring(SB)	
func printeface(e eface) {
  0x422616		488b442428		MOVQ 0x28(SP), AX	
	print("(", e._type, ",", e.data, ")")
  0x42261b		48890424		MOVQ AX, 0(SP)			
  0x42261f		e8dcfdffff		CALL runtime.printpointer(SB)	
  0x422624		488d0527760400		LEAQ 0x47627(IP), AX		
  0x42262b		48890424		MOVQ AX, 0(SP)			
  0x42262f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x422638		e803feffff		CALL runtime.printstring(SB)	
  0x42263d		e83ef5ffff		CALL runtime.printunlock(SB)	
}
  0x422642		488b6c2410		MOVQ 0x10(SP), BP	
  0x422647		4883c418		ADDQ $0x18, SP		
  0x42264b		c3			RET			
func printeface(e eface) {
  0x42264c		e81f1f0200		CALL runtime.morestack_noctxt(SB)	
  0x422651		e95affffff		JMP runtime.printeface(SB)		

TEXT runtime.hexdumpWords(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
func hexdumpWords(p, end uintptr, mark func(uintptr) byte) {
  0x422660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422669		483b6110		CMPQ 0x10(CX), SP	
  0x42266d		0f8631020000		JBE 0x4228a4		
  0x422673		4883ec60		SUBQ $0x60, SP		
  0x422677		48896c2458		MOVQ BP, 0x58(SP)	
  0x42267c		488d6c2458		LEAQ 0x58(SP), BP	
	printlock()
  0x422681		e87af4ffff		CALL runtime.printlock(SB)	
	var markbuf [1]byte
  0x422686		c644242700		MOVB $0x0, 0x27(SP)	
	markbuf[0] = ' '
  0x42268b		c644242720		MOVB $0x20, 0x27(SP)	
func hexdumpWords(p, end uintptr, mark func(uintptr) byte) {
  0x422690		31c0			XORL AX, AX		
	for i := uintptr(0); p+i < end; i += sys.PtrSize {
  0x422692		eb09			JMP 0x42269d		
  0x422694		488b4c2430		MOVQ 0x30(SP), CX	
  0x422699		488d4108		LEAQ 0x8(CX), AX	
  0x42269d		488b4c2468		MOVQ 0x68(SP), CX	
  0x4226a2		488d1c08		LEAQ 0(AX)(CX*1), BX	
  0x4226a6		488b742470		MOVQ 0x70(SP), SI	
  0x4226ab		4839f3			CMPQ SI, BX		
  0x4226ae		0f83d2010000		JAE 0x422886		
  0x4226b4		4889442430		MOVQ AX, 0x30(SP)	
  0x4226b9		48895c2440		MOVQ BX, 0x40(SP)	
		if i%16 == 0 {
  0x4226be		48a90f000000		TESTQ $0xf, AX		
  0x4226c4		7540			JNE 0x422706		
			if i != 0 {
  0x4226c6		4885c0			TESTQ AX, AX		
  0x4226c9		0f859e010000		JNE 0x42286d		
			p1(p + i)
  0x4226cf		48891c24		MOVQ BX, 0(SP)		
  0x4226d3		488b05e6b90400		MOVQ 0x4b9e6(IP), AX	
  0x4226da		488d15dfb90400		LEAQ 0x4b9df(IP), DX	
  0x4226e1		ffd0			CALL AX			
			print(": ")
  0x4226e3		e818f4ffff		CALL runtime.printlock(SB)	
  0x4226e8		488d0581750400		LEAQ 0x47581(IP), AX		
  0x4226ef		48890424		MOVQ AX, 0(SP)			
  0x4226f3		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4226fc		e83ffdffff		CALL runtime.printstring(SB)	
  0x422701		e87af4ffff		CALL runtime.printunlock(SB)	
  0x422706		488b542478		MOVQ 0x78(SP), DX		
		if mark != nil {
  0x42270b		4885d2			TESTQ DX, DX		
  0x42270e		0f852d010000		JNE 0x422841		
		gwrite(markbuf[:])
  0x422714		488d442427		LEAQ 0x27(SP), AX	
  0x422719		48890424		MOVQ AX, 0(SP)		
  0x42271d		48c744240801000000	MOVQ $0x1, 0x8(SP)	
  0x422726		48c744241001000000	MOVQ $0x1, 0x10(SP)	
  0x42272f		e8bcf4ffff		CALL runtime.gwrite(SB)	
  0x422734		488b442440		MOVQ 0x40(SP), AX	
		val := *(*uintptr)(unsafe.Pointer(p + i))
  0x422739		488b00			MOVQ 0(AX), AX		
  0x42273c		4889442428		MOVQ AX, 0x28(SP)	
		p1(val)
  0x422741		48890424		MOVQ AX, 0(SP)		
  0x422745		488b0d74b90400		MOVQ 0x4b974(IP), CX	
  0x42274c		488d156db90400		LEAQ 0x4b96d(IP), DX	
  0x422753		ffd1			CALL CX			
		print(" ")
  0x422755		e8a6f3ffff		CALL runtime.printlock(SB)	
  0x42275a		e8e1f5ffff		CALL runtime.printsp(SB)	
  0x42275f		e81cf4ffff		CALL runtime.printunlock(SB)	
  0x422764		488b442428		MOVQ 0x28(SP), AX		
		fn := findfunc(val)
  0x422769		48890424		MOVQ AX, 0(SP)			
  0x42276d		e85e5a0100		CALL runtime.findfunc(SB)	
  0x422772		488b442410		MOVQ 0x10(SP), AX		
  0x422777		488b4c2408		MOVQ 0x8(SP), CX		
	return f._func != nil
  0x42277c		4885c9			TESTQ CX, CX		
		if fn.valid() {
  0x42277f		0f840fffffff		JE 0x422694		
  0x422785		48894c2450		MOVQ CX, 0x50(SP)	
			print("<", funcname(fn), "+", val-fn.entry, "> ")
  0x42278a		48890c24		MOVQ CX, 0(SP)			
  0x42278e		4889442408		MOVQ AX, 0x8(SP)		
  0x422793		e868610100		CALL runtime.funcname(SB)	
  0x422798		488b442418		MOVQ 0x18(SP), AX		
  0x42279d		4889442438		MOVQ AX, 0x38(SP)		
  0x4227a2		488b4c2410		MOVQ 0x10(SP), CX		
  0x4227a7		48894c2448		MOVQ CX, 0x48(SP)		
  0x4227ac		488b542450		MOVQ 0x50(SP), DX		
  0x4227b1		488b12			MOVQ 0(DX), DX			
  0x4227b4		4889542440		MOVQ DX, 0x40(SP)		
  0x4227b9		e842f3ffff		CALL runtime.printlock(SB)	
  0x4227be		488d0594740400		LEAQ 0x47494(IP), AX		
  0x4227c5		48890424		MOVQ AX, 0(SP)			
  0x4227c9		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4227d2		e869fcffff		CALL runtime.printstring(SB)	
  0x4227d7		488b442448		MOVQ 0x48(SP), AX		
  0x4227dc		48890424		MOVQ AX, 0(SP)			
  0x4227e0		488b442438		MOVQ 0x38(SP), AX		
  0x4227e5		4889442408		MOVQ AX, 0x8(SP)		
  0x4227ea		e851fcffff		CALL runtime.printstring(SB)	
  0x4227ef		488d055d740400		LEAQ 0x4745d(IP), AX		
  0x4227f6		48890424		MOVQ AX, 0(SP)			
  0x4227fa		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x422803		e838fcffff		CALL runtime.printstring(SB)	
  0x422808		488b442428		MOVQ 0x28(SP), AX		
  0x42280d		488b4c2440		MOVQ 0x40(SP), CX		
  0x422812		4829c8			SUBQ CX, AX			
  0x422815		48890424		MOVQ AX, 0(SP)			
  0x422819		e852f9ffff		CALL runtime.printuint(SB)	
  0x42281e		488d054d740400		LEAQ 0x4744d(IP), AX		
  0x422825		48890424		MOVQ AX, 0(SP)			
  0x422829		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x422832		e809fcffff		CALL runtime.printstring(SB)	
  0x422837		e844f3ffff		CALL runtime.printunlock(SB)	
  0x42283c		e953feffff		JMP 0x422694			
  0x422841		488b442440		MOVQ 0x40(SP), AX		
			markbuf[0] = mark(p + i)
  0x422846		48890424		MOVQ AX, 0(SP)		
  0x42284a		488b0a			MOVQ 0(DX), CX		
  0x42284d		ffd1			CALL CX			
  0x42284f		0fb6442408		MOVZX 0x8(SP), AX	
  0x422854		88442427		MOVB AL, 0x27(SP)	
			if markbuf[0] == 0 {
  0x422858		0fb6c0			MOVZX AL, AX		
  0x42285b		84c0			TESTL AL, AL		
  0x42285d		0f85b1feffff		JNE 0x422714		
				markbuf[0] = ' '
  0x422863		c644242720		MOVB $0x20, 0x27(SP)	
  0x422868		e9a7feffff		JMP 0x422714		
				println()
  0x42286d		e88ef2ffff		CALL runtime.printlock(SB)	
  0x422872		e819f5ffff		CALL runtime.printnl(SB)	
  0x422877		e804f3ffff		CALL runtime.printunlock(SB)	
  0x42287c		488b5c2440		MOVQ 0x40(SP), BX		
  0x422881		e949feffff		JMP 0x4226cf			
	println()
  0x422886		e875f2ffff		CALL runtime.printlock(SB)	
  0x42288b		e800f5ffff		CALL runtime.printnl(SB)	
  0x422890		e8ebf2ffff		CALL runtime.printunlock(SB)	
	printunlock()
  0x422895		e8e6f2ffff		CALL runtime.printunlock(SB)	
}
  0x42289a		488b6c2458		MOVQ 0x58(SP), BP	
  0x42289f		4883c460		ADDQ $0x60, SP		
  0x4228a3		c3			RET			
func hexdumpWords(p, end uintptr, mark func(uintptr) byte) {
  0x4228a4		e8c71c0200		CALL runtime.morestack_noctxt(SB)	
  0x4228a9		e9b2fdffff		JMP runtime.hexdumpWords(SB)		

TEXT runtime.main(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func main() {
  0x4228b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4228b9		483b6110		CMPQ 0x10(CX), SP	
  0x4228bd		0f8658030000		JBE 0x422c1b		
  0x4228c3		4883ec50		SUBQ $0x50, SP		
  0x4228c7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4228cc		488d6c2448		LEAQ 0x48(SP), BP	
	g := getg()
  0x4228d1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4228da		4889442440		MOVQ AX, 0x40(SP)	
	g.m.g0.racectx = 0
  0x4228df		488b4830		MOVQ 0x30(AX), CX	
  0x4228e3		488b09			MOVQ 0(CX), CX		
  0x4228e6		48c7813001000000000000	MOVQ $0x0, 0x130(CX)	
		maxstacksize = 1000000000
  0x4228f1		48c7054c27080000ca9a3b	MOVQ $0x3b9aca00, runtime.maxstacksize(SB)	
	mainStarted = true
  0x4228fc		c605ac0f0a0001		MOVB $0x1, runtime.mainStarted(SB)	
	systemstack(func() {
  0x422903		488d0dceb70400		LEAQ 0x4b7ce(IP), CX		
  0x42290a		48890c24		MOVQ CX, 0(SP)			
  0x42290e		e80d1b0200		CALL runtime.systemstack(SB)	
	getg().m.lockedInt++
  0x422913		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42291c		488b4030		MOVQ 0x30(AX), AX	
  0x422920		ff80f8020000		INCL 0x2f8(AX)		
	_g_ := getg()
  0x422926		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.lockedg.set(_g_)
  0x42292f		488b4830		MOVQ 0x30(AX), CX	
  0x422933		488d9168010000		LEAQ 0x168(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42293a		8402			TESTB AL, 0(DX)		
  0x42293c		4889c2			MOVQ AX, DX		
  0x42293f		48898168010000		MOVQ AX, 0x168(CX)	
	_g_.lockedm.set(_g_.m)
  0x422946		488d82e0000000		LEAQ 0xe0(DX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42294d		8400			TESTB AL, 0(AX)		
	_g_.lockedm.set(_g_.m)
  0x42294f		488b4230		MOVQ 0x30(DX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x422953		488982e0000000		MOVQ AX, 0xe0(DX)	
  0x42295a		488b442440		MOVQ 0x40(SP), AX	
	if g.m != &m0 {
  0x42295f		488b4030		MOVQ 0x30(AX), AX	
  0x422963		488d0df6550800		LEAQ runtime.m0(SB), CX	
  0x42296a		4839c8			CMPQ CX, AX		
  0x42296d		0f858d020000		JNE 0x422c00		
	runtime_init() // must be before defer
  0x422973		e878150200		CALL runtime.init(SB)	
	if nanotime() == 0 {
  0x422978		e8b3500200		CALL runtime.nanotime(SB)	
  0x42297d		488b0424		MOVQ 0(SP), AX			
  0x422981		4885c0			TESTQ AX, AX			
  0x422984		0f845b020000		JE 0x422be5			
	needUnlock := true
  0x42298a		c644243701		MOVB $0x1, 0x37(SP)	
	}()
  0x42298f		488d442437		LEAQ 0x37(SP), AX	
  0x422994		4889442410		MOVQ AX, 0x10(SP)	
	defer func() {
  0x422999		c7042408000000		MOVL $0x8, 0(SP)		
  0x4229a0		488d0539b70400		LEAQ 0x4b739(IP), AX		
  0x4229a7		4889442408		MOVQ AX, 0x8(SP)		
  0x4229ac		e86fd3ffff		CALL runtime.deferproc(SB)	
  0x4229b1		85c0			TESTL AX, AX			
  0x4229b3		0f85b0010000		JNE 0x422b69			
	runtimeInitTime = nanotime()
  0x4229b9		e872500200		CALL runtime.nanotime(SB)		
  0x4229be		488b0424		MOVQ 0(SP), AX				
  0x4229c2		488905f70f0a00		MOVQ AX, runtime.runtimeInitTime(SB)	
	gcenable()
  0x4229c9		e882d3feff		CALL runtime.gcenable(SB)	
	main_init_done = make(chan bool)
  0x4229ce		488d054b410300		LEAQ 0x3414b(IP), AX			
  0x4229d5		48890424		MOVQ AX, 0(SP)				
  0x4229d9		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x4229e2		e8e903feff		CALL runtime.makechan(SB)		
  0x4229e7		8b0523100a00		MOVL runtime.writeBarrier(SB), AX	
  0x4229ed		488b4c2410		MOVQ 0x10(SP), CX			
  0x4229f2		85c0			TESTL AX, AX				
  0x4229f4		0f855b010000		JNE 0x422b55				
  0x4229fa		48890d674c0800		MOVQ CX, runtime.main_init_done(SB)	
	if iscgo {
  0x422a01		0fb605a40e0a00		MOVZX runtime.iscgo(SB), AX	
  0x422a08		84c0			TESTL AL, AL			
  0x422a0a		745e			JE 0x422a6a			
		if _cgo_thread_start == nil {
  0x422a0c		488b05dd4b0800		MOVQ _cgo_thread_start(SB), AX	
  0x422a13		4885c0			TESTQ AX, AX			
  0x422a16		0f84ae010000		JE 0x422bca			
			if _cgo_setenv == nil {
  0x422a1c		488b05dd4b0800		MOVQ runtime._cgo_setenv(SB), AX	
  0x422a23		4885c0			TESTQ AX, AX				
  0x422a26		0f8483010000		JE 0x422baf				
			if _cgo_unsetenv == nil {
  0x422a2c		488b05d54b0800		MOVQ runtime._cgo_unsetenv(SB), AX	
  0x422a33		4885c0			TESTQ AX, AX				
  0x422a36		0f8458010000		JE 0x422b94				
		if _cgo_notify_runtime_init_done == nil {
  0x422a3c		488b059d4b0800		MOVQ _cgo_notify_runtime_init_done(SB), AX	
  0x422a43		4885c0			TESTQ AX, AX					
  0x422a46		0f842d010000		JE 0x422b79					
		startTemplateThread()
  0x422a4c		e89f400000		CALL runtime.startTemplateThread(SB)	
		cgocall(_cgo_notify_runtime_init_done, nil)
  0x422a51		488b05884b0800		MOVQ _cgo_notify_runtime_init_done(SB), AX	
  0x422a58		48890424		MOVQ AX, 0(SP)					
  0x422a5c		48c744240800000000	MOVQ $0x0, 0x8(SP)				
  0x422a65		e8b6f8fdff		CALL runtime.cgocall(SB)			
	fn()
  0x422a6a		488b0577b60400		MOVQ 0x4b677(IP), AX	
  0x422a71		488d1570b60400		LEAQ 0x4b670(IP), DX	
  0x422a78		ffd0			CALL AX			
	close(main_init_done)
  0x422a7a		488b05e74b0800		MOVQ runtime.main_init_done(SB), AX	
  0x422a81		48890424		MOVQ AX, 0(SP)				
  0x422a85		e8860efeff		CALL runtime.closechan(SB)		
	needUnlock = false
  0x422a8a		c644243700		MOVB $0x0, 0x37(SP)	
	unlockOSThread()
  0x422a8f		e80c830000		CALL runtime.unlockOSThread(SB)	
	if isarchive || islibrary {
  0x422a94		0fb605100e0a00		MOVZX runtime.isarchive(SB), AX	
  0x422a9b		84c0			TESTL AL, AL			
  0x422a9d		0f85a2000000		JNE 0x422b45			
  0x422aa3		0fb605030e0a00		MOVZX runtime.islibrary(SB), AX	
  0x422aaa		84c0			TESTL AL, AL			
  0x422aac		0f8593000000		JNE 0x422b45			
	fn()
  0x422ab2		488b0537b60400		MOVQ 0x4b637(IP), AX	
  0x422ab9		488d1530b60400		LEAQ 0x4b630(IP), DX	
  0x422ac0		ffd0			CALL AX			
	if atomic.Load(&runningPanicDefers) != 0 {
  0x422ac2		8b05340e0a00		MOVL runtime.runningPanicDefers(SB), AX	
  0x422ac8		85c0			TESTL AX, AX				
  0x422aca		7428			JE 0x422af4				
  0x422acc		31c0			XORL AX, AX				
		for c := 0; c < 1000; c++ {
  0x422ace		eb12			JMP 0x422ae2		
  0x422ad0		4889442438		MOVQ AX, 0x38(SP)	
			Gosched()
  0x422ad5		e8e6020000		CALL runtime.Gosched(SB)	
  0x422ada		488b442438		MOVQ 0x38(SP), AX		
		for c := 0; c < 1000; c++ {
  0x422adf		48ffc0			INCQ AX			
  0x422ae2		483de8030000		CMPQ $0x3e8, AX		
  0x422ae8		7d0a			JGE 0x422af4		
			if atomic.Load(&runningPanicDefers) == 0 {
  0x422aea		8b0d0c0e0a00		MOVL runtime.runningPanicDefers(SB), CX	
  0x422af0		85c9			TESTL CX, CX				
  0x422af2		75dc			JNE 0x422ad0				
	if atomic.Load(&panicking) != 0 {
  0x422af4		8b05fa0d0a00		MOVL runtime.panicking(SB), AX	
  0x422afa		85c0			TESTL AX, AX			
  0x422afc		7516			JNE 0x422b14			
	exit(0)
  0x422afe		c7042400000000		MOVL $0x0, 0(SP)	
  0x422b05		e8c64c0200		CALL runtime.exit(SB)	
		*x = 0
  0x422b0a		31c0			XORL AX, AX		
  0x422b0c		c70000000000		MOVL $0x0, 0(AX)	
  0x422b12		ebf6			JMP 0x422b0a		
		gopark(nil, nil, "panicwait", traceEvGoStop, 1)
  0x422b14		0f57c0			XORPS X0, X0		
  0x422b17		0f110424		MOVUPS X0, 0(SP)	
  0x422b1b		488d0510760400		LEAQ 0x47610(IP), AX	
  0x422b22		4889442410		MOVQ AX, 0x10(SP)	
  0x422b27		48c744241809000000	MOVQ $0x9, 0x18(SP)	
  0x422b30		c644242010		MOVB $0x10, 0x20(SP)	
  0x422b35		48c744242801000000	MOVQ $0x1, 0x28(SP)	
  0x422b3e		e8ad020000		CALL runtime.gopark(SB)	
  0x422b43		ebb9			JMP 0x422afe		
		return
  0x422b45		90			NOPL				
  0x422b46		e8b5daffff		CALL runtime.deferreturn(SB)	
  0x422b4b		488b6c2448		MOVQ 0x48(SP), BP		
  0x422b50		4883c450		ADDQ $0x50, SP			
  0x422b54		c3			RET				
	main_init_done = make(chan bool)
  0x422b55		488d3d0c4b0800		LEAQ runtime.main_init_done(SB), DI	
  0x422b5c		4889c8			MOVQ CX, AX				
  0x422b5f		e83c3d0200		CALL runtime.gcWriteBarrier(SB)		
  0x422b64		e998feffff		JMP 0x422a01				
	defer func() {
  0x422b69		90			NOPL				
  0x422b6a		e891daffff		CALL runtime.deferreturn(SB)	
  0x422b6f		488b6c2448		MOVQ 0x48(SP), BP		
  0x422b74		4883c450		ADDQ $0x50, SP			
  0x422b78		c3			RET				
			throw("_cgo_notify_runtime_init_done missing")
  0x422b79		488d05eba30400		LEAQ 0x4a3eb(IP), AX	
  0x422b80		48890424		MOVQ AX, 0(SP)		
  0x422b84		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x422b8d		e83ee6ffff		CALL runtime.throw(SB)	
  0x422b92		0f0b			UD2			
				throw("_cgo_unsetenv missing")
  0x422b94		488d05c4860400		LEAQ 0x486c4(IP), AX	
  0x422b9b		48890424		MOVQ AX, 0(SP)		
  0x422b9f		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x422ba8		e823e6ffff		CALL runtime.throw(SB)	
  0x422bad		0f0b			UD2			
				throw("_cgo_setenv missing")
  0x422baf		488d05aa820400		LEAQ 0x482aa(IP), AX	
  0x422bb6		48890424		MOVQ AX, 0(SP)		
  0x422bba		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x422bc3		e808e6ffff		CALL runtime.throw(SB)	
  0x422bc8		0f0b			UD2			
			throw("_cgo_thread_start missing")
  0x422bca		488d05ae8d0400		LEAQ 0x48dae(IP), AX	
  0x422bd1		48890424		MOVQ AX, 0(SP)		
  0x422bd5		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x422bde		e8ede5ffff		CALL runtime.throw(SB)	
  0x422be3		0f0b			UD2			
		throw("nanotime returning zero")
  0x422be5		488d05018b0400		LEAQ 0x48b01(IP), AX	
  0x422bec		48890424		MOVQ AX, 0(SP)		
  0x422bf0		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x422bf9		e8d2e5ffff		CALL runtime.throw(SB)	
  0x422bfe		0f0b			UD2			
		throw("runtime.main not on m0")
  0x422c00		488d05b1880400		LEAQ 0x488b1(IP), AX	
  0x422c07		48890424		MOVQ AX, 0(SP)		
  0x422c0b		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x422c14		e8b7e5ffff		CALL runtime.throw(SB)	
  0x422c19		0f0b			UD2			
func main() {
  0x422c1b		e850190200		CALL runtime.morestack_noctxt(SB)	
  0x422c20		e98bfcffff		JMP runtime.main(SB)			

TEXT runtime.init.4(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func init() {
  0x422c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422c39		483b6110		CMPQ 0x10(CX), SP	
  0x422c3d		7630			JBE 0x422c6f		
  0x422c3f		4883ec18		SUBQ $0x18, SP		
  0x422c43		48896c2410		MOVQ BP, 0x10(SP)	
  0x422c48		488d6c2410		LEAQ 0x10(SP), BP	
	go forcegchelper()
  0x422c4d		c7042400000000		MOVL $0x0, 0(SP)		
  0x422c54		488d050db40400		LEAQ 0x4b40d(IP), AX		
  0x422c5b		4889442408		MOVQ AX, 0x8(SP)		
  0x422c60		e88b760000		CALL runtime.newproc(SB)	
}
  0x422c65		488b6c2410		MOVQ 0x10(SP), BP	
  0x422c6a		4883c418		ADDQ $0x18, SP		
  0x422c6e		c3			RET			
func init() {
  0x422c6f		e8fc180200		CALL runtime.morestack_noctxt(SB)	
  0x422c74		ebba			JMP runtime.init.4(SB)			

TEXT runtime.forcegchelper(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func forcegchelper() {
  0x422c80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422c89		483b6110		CMPQ 0x10(CX), SP	
  0x422c8d		0f861b010000		JBE 0x422dae		
  0x422c93		4883ec30		SUBQ $0x30, SP		
  0x422c97		48896c2428		MOVQ BP, 0x28(SP)	
  0x422c9c		488d6c2428		LEAQ 0x28(SP), BP	
	forcegc.g = getg()
  0x422ca1		8b0d690d0a00		MOVL runtime.writeBarrier(SB), CX	
  0x422ca7		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x422cb0		85c9			TESTL CX, CX				
  0x422cb2		0f85ca000000		JNE 0x422d82				
  0x422cb8		488905594a0800		MOVQ AX, runtime.forcegc+8(SB)		
	for {
  0x422cbf		eb2c			JMP 0x422ced		
		gcStart(gcBackgroundMode, gcTrigger{kind: gcTriggerTime, now: nanotime()})
  0x422cc1		e86a4d0200		CALL runtime.nanotime(SB)	
  0x422cc6		488b0424		MOVQ 0(SP), AX			
  0x422cca		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x422cd2		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x422cdb		4889442410		MOVQ AX, 0x10(SP)		
  0x422ce0		c744241800000000	MOVL $0x0, 0x18(SP)		
  0x422ce8		e893e4feff		CALL runtime.gcStart(SB)	
		lock(&forcegc.lock)
  0x422ced		488d051c4a0800		LEAQ runtime.forcegc(SB), AX	
  0x422cf4		48890424		MOVQ AX, 0(SP)			
  0x422cf8		e82368feff		CALL runtime.lock(SB)		
		if forcegc.idle != 0 {
  0x422cfd		8b051d4a0800		MOVL runtime.forcegc+16(SB), AX	
  0x422d03		85c0			TESTL AX, AX			
  0x422d05		0f8588000000		JNE 0x422d93			
		atomic.Store(&forcegc.idle, 1)
  0x422d0b		b801000000		MOVL $0x1, AX			
  0x422d10		488d0d094a0800		LEAQ runtime.forcegc+16(SB), CX	
  0x422d17		8701			XCHGL AX, 0(CX)			
		goparkunlock(&forcegc.lock, "force gc (idle)", traceEvGoBlock, 1)
  0x422d19		488d05f0490800		LEAQ runtime.forcegc(SB), AX	
  0x422d20		48890424		MOVQ AX, 0(SP)			
  0x422d24		488d05317c0400		LEAQ 0x47c31(IP), AX		
  0x422d2b		4889442408		MOVQ AX, 0x8(SP)		
  0x422d30		48c74424100f000000	MOVQ $0xf, 0x10(SP)		
  0x422d39		c644241814		MOVB $0x14, 0x18(SP)		
  0x422d3e		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x422d47		e814020000		CALL runtime.goparkunlock(SB)	
		if debug.gctrace > 0 {
  0x422d4c		8b058e0d0a00		MOVL runtime.debug+32(SB), AX	
  0x422d52		85c0			TESTL AX, AX			
  0x422d54		0f8e67ffffff		JLE 0x422cc1			
			println("GC forced")
  0x422d5a		e8a1edffff		CALL runtime.printlock(SB)	
  0x422d5f		488d05a6750400		LEAQ 0x475a6(IP), AX		
  0x422d66		48890424		MOVQ AX, 0(SP)			
  0x422d6a		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x422d73		e8c8f6ffff		CALL runtime.printstring(SB)	
  0x422d78		e803eeffff		CALL runtime.printunlock(SB)	
  0x422d7d		e93fffffff		JMP 0x422cc1			
	forcegc.g = getg()
  0x422d82		488d3d8f490800		LEAQ runtime.forcegc+8(SB), DI	
  0x422d89		e8123b0200		CALL runtime.gcWriteBarrier(SB)	
  0x422d8e		e95affffff		JMP 0x422ced			
			throw("forcegc: phase error")
  0x422d93		488d055b830400		LEAQ 0x4835b(IP), AX	
  0x422d9a		48890424		MOVQ AX, 0(SP)		
  0x422d9e		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x422da7		e824e4ffff		CALL runtime.throw(SB)	
  0x422dac		0f0b			UD2			
func forcegchelper() {
  0x422dae		e8bd170200		CALL runtime.morestack_noctxt(SB)	
  0x422db3		e9c8feffff		JMP runtime.forcegchelper(SB)		

TEXT runtime.Gosched(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func Gosched() {
  0x422dc0		4883ec10		SUBQ $0x10, SP		
  0x422dc4		48896c2408		MOVQ BP, 0x8(SP)	
  0x422dc9		488d6c2408		LEAQ 0x8(SP), BP	
	mcall(gosched_m)
  0x422dce		488d05e3b20400		LEAQ 0x4b2e3(IP), AX	
  0x422dd5		48890424		MOVQ AX, 0(SP)		
  0x422dd9		e8c2150200		CALL runtime.mcall(SB)	
}
  0x422dde		488b6c2408		MOVQ 0x8(SP), BP	
  0x422de3		4883c410		ADDQ $0x10, SP		
  0x422de7		c3			RET			

TEXT runtime.gopark(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason string, traceEv byte, traceskip int) {
  0x422df0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422df9		483b6110		CMPQ 0x10(CX), SP	
  0x422dfd		0f8651010000		JBE 0x422f54		
  0x422e03		4883ec18		SUBQ $0x18, SP		
  0x422e07		48896c2410		MOVQ BP, 0x10(SP)	
  0x422e0c		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x422e11		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x422e1a		488b5130		MOVQ 0x30(CX), DX	
  0x422e1e		ff8200010000		INCL 0x100(DX)		
	return _g_.m
  0x422e24		488b5130		MOVQ 0x30(CX), DX	
  0x422e28		8401			TESTB AL, 0(CX)		
	gp := mp.curg
  0x422e2a		488b8ac0000000		MOVQ 0xc0(DX), CX	
	return atomic.Load(&gp.atomicstatus)
  0x422e31		8b9990000000		MOVL 0x90(CX), BX	
	if status != _Grunning && status != _Gscanrunning {
  0x422e37		83fb02			CMPL $0x2, BX		
  0x422e3a		740c			JE 0x422e48		
  0x422e3c		81fb02100000		CMPL $0x1002, BX	
  0x422e42		0f85f1000000		JNE 0x422f39		
	mp.waitlock = lock
  0x422e48		8b1dc20b0a00		MOVL runtime.writeBarrier(SB), BX	
  0x422e4e		488dba10030000		LEAQ 0x310(DX), DI			
  0x422e55		85db			TESTL BX, BX				
  0x422e57		0f85cd000000		JNE 0x422f2a				
  0x422e5d		488b5c2428		MOVQ 0x28(SP), BX			
  0x422e62		48899a10030000		MOVQ BX, 0x310(DX)			
	mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&unlockf))
  0x422e69		8b1da10b0a00		MOVL runtime.writeBarrier(SB), BX	
  0x422e6f		488dba08030000		LEAQ 0x308(DX), DI			
  0x422e76		488b442420		MOVQ 0x20(SP), AX			
  0x422e7b		85db			TESTL BX, BX				
  0x422e7d		0f859d000000		JNE 0x422f20				
  0x422e83		48898208030000		MOVQ AX, 0x308(DX)			
  0x422e8a		488b5c2438		MOVQ 0x38(SP), BX			
	gp.waitreason = reason
  0x422e8f		488999b0000000		MOVQ BX, 0xb0(CX)			
  0x422e96		8b1d740b0a00		MOVL runtime.writeBarrier(SB), BX	
  0x422e9c		488db9a8000000		LEAQ 0xa8(CX), DI			
  0x422ea3		85db			TESTL BX, BX				
  0x422ea5		756d			JNE 0x422f14				
  0x422ea7		488b442430		MOVQ 0x30(SP), AX			
  0x422eac		488981a8000000		MOVQ AX, 0xa8(CX)			
  0x422eb3		0fb6442440		MOVZX 0x40(SP), AX			
	mp.waittraceev = traceEv
  0x422eb8		888218030000		MOVB AL, 0x318(DX)	
  0x422ebe		488b442448		MOVQ 0x48(SP), AX	
	mp.waittraceskip = traceskip
  0x422ec3		48898220030000		MOVQ AX, 0x320(DX)	
	_g_ := getg()
  0x422eca		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x422ed3		8b8a00010000		MOVL 0x100(DX), CX	
  0x422ed9		8d59ff			LEAL -0x1(CX), BX	
  0x422edc		899a00010000		MOVL BX, 0x100(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x422ee2		83f901			CMPL $0x1, CX		
  0x422ee5		7513			JNE 0x422efa		
  0x422ee7		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x422eee		84c9			TESTL CL, CL		
  0x422ef0		7408			JE 0x422efa		
		_g_.stackguard0 = stackPreempt
  0x422ef2		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	mcall(park_m)
  0x422efa		488d0597b20400		LEAQ 0x4b297(IP), AX	
  0x422f01		48890424		MOVQ AX, 0(SP)		
  0x422f05		e896140200		CALL runtime.mcall(SB)	
}
  0x422f0a		488b6c2410		MOVQ 0x10(SP), BP	
  0x422f0f		4883c418		ADDQ $0x18, SP		
  0x422f13		c3			RET			
  0x422f14		488b442430		MOVQ 0x30(SP), AX	
	gp.waitreason = reason
  0x422f19		e882390200		CALL runtime.gcWriteBarrier(SB)	
  0x422f1e		eb93			JMP 0x422eb3			
	mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&unlockf))
  0x422f20		e87b390200		CALL runtime.gcWriteBarrier(SB)	
  0x422f25		e960ffffff		JMP 0x422e8a			
  0x422f2a		488b442428		MOVQ 0x28(SP), AX		
	mp.waitlock = lock
  0x422f2f		e86c390200		CALL runtime.gcWriteBarrier(SB)	
  0x422f34		e930ffffff		JMP 0x422e69			
		throw("gopark: bad g status")
  0x422f39		488d05f1810400		LEAQ 0x481f1(IP), AX	
  0x422f40		48890424		MOVQ AX, 0(SP)		
  0x422f44		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x422f4d		e87ee2ffff		CALL runtime.throw(SB)	
  0x422f52		0f0b			UD2			
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason string, traceEv byte, traceskip int) {
  0x422f54		e817160200		CALL runtime.morestack_noctxt(SB)	
  0x422f59		e992feffff		JMP runtime.gopark(SB)			

TEXT runtime.goparkunlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
  0x422f60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422f69		483b6110		CMPQ 0x10(CX), SP	
  0x422f6d		7659			JBE 0x422fc8		
  0x422f6f		4883ec38		SUBQ $0x38, SP		
  0x422f73		48896c2430		MOVQ BP, 0x30(SP)	
  0x422f78		488d6c2430		LEAQ 0x30(SP), BP	
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x422f7d		488d051cb20400		LEAQ 0x4b21c(IP), AX	
  0x422f84		48890424		MOVQ AX, 0(SP)		
func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
  0x422f88		488b442440		MOVQ 0x40(SP), AX	
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x422f8d		4889442408		MOVQ AX, 0x8(SP)	
func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
  0x422f92		488b442448		MOVQ 0x48(SP), AX	
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x422f97		4889442410		MOVQ AX, 0x10(SP)	
func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
  0x422f9c		488b442450		MOVQ 0x50(SP), AX	
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x422fa1		4889442418		MOVQ AX, 0x18(SP)	
func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
  0x422fa6		0fb6442458		MOVZX 0x58(SP), AX	
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x422fab		88442420		MOVB AL, 0x20(SP)	
func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
  0x422faf		488b442460		MOVQ 0x60(SP), AX	
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x422fb4		4889442428		MOVQ AX, 0x28(SP)	
  0x422fb9		e832feffff		CALL runtime.gopark(SB)	
}
  0x422fbe		488b6c2430		MOVQ 0x30(SP), BP	
  0x422fc3		4883c438		ADDQ $0x38, SP		
  0x422fc7		c3			RET			
func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
  0x422fc8		e8a3150200		CALL runtime.morestack_noctxt(SB)	
  0x422fcd		eb91			JMP runtime.goparkunlock(SB)		

TEXT runtime.goready(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func goready(gp *g, traceskip int) {
  0x422fd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422fd9		483b6110		CMPQ 0x10(CX), SP	
  0x422fdd		7646			JBE 0x423025		
  0x422fdf		4883ec28		SUBQ $0x28, SP		
  0x422fe3		48896c2420		MOVQ BP, 0x20(SP)	
  0x422fe8		488d6c2420		LEAQ 0x20(SP), BP	
	systemstack(func() {
  0x422fed		488d05ec020200		LEAQ runtime.goready.func1(SB), AX	
  0x422ff4		4889442408		MOVQ AX, 0x8(SP)			
func goready(gp *g, traceskip int) {
  0x422ff9		488b442430		MOVQ 0x30(SP), AX	
	systemstack(func() {
  0x422ffe		4889442410		MOVQ AX, 0x10(SP)	
func goready(gp *g, traceskip int) {
  0x423003		488b442438		MOVQ 0x38(SP), AX	
	systemstack(func() {
  0x423008		4889442418		MOVQ AX, 0x18(SP)		
  0x42300d		488d442408		LEAQ 0x8(SP), AX		
  0x423012		48890424		MOVQ AX, 0(SP)			
  0x423016		e805140200		CALL runtime.systemstack(SB)	
}
  0x42301b		488b6c2420		MOVQ 0x20(SP), BP	
  0x423020		4883c428		ADDQ $0x28, SP		
  0x423024		c3			RET			
func goready(gp *g, traceskip int) {
  0x423025		e846150200		CALL runtime.morestack_noctxt(SB)	
  0x42302a		eba4			JMP runtime.goready(SB)			

TEXT runtime.acquireSudog(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func acquireSudog() *sudog {
  0x423030		4883ec68		SUBQ $0x68, SP		
  0x423034		48896c2460		MOVQ BP, 0x60(SP)	
  0x423039		488d6c2460		LEAQ 0x60(SP), BP	
	_g_ := getg()
  0x42303e		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x423047		488b5130		MOVQ 0x30(CX), DX	
  0x42304b		ff8200010000		INCL 0x100(DX)		
	return _g_.m
  0x423051		488b5130		MOVQ 0x30(CX), DX	
  0x423055		4889542440		MOVQ DX, 0x40(SP)	
	pp := mp.p.ptr()
  0x42305a		488b9ad0000000		MOVQ 0xd0(DX), BX	
	return _g_.m
  0x423061		8401			TESTB AL, 0(CX)		
	if len(pp.sudogcache) == 0 {
  0x423063		488b8b080e0000		MOVQ 0xe08(BX), CX	
  0x42306a		488db3000e0000		LEAQ 0xe00(BX), SI	
  0x423071		4885c9			TESTQ CX, CX		
  0x423074		0f850f030000		JNE 0x423389		
  0x42307a		48895c2458		MOVQ BX, 0x58(SP)	
  0x42307f		4889742450		MOVQ SI, 0x50(SP)	
		lock(&sched.sudoglock)
  0x423084		488d0525490800		LEAQ runtime.sched+144(SB), AX	
  0x42308b		48890424		MOVQ AX, 0(SP)			
  0x42308f		e88c64feff		CALL runtime.lock(SB)		
		for len(pp.sudogcache) < cap(pp.sudogcache)/2 && sched.sudogcache != nil {
  0x423094		488b4c2458		MOVQ 0x58(SP), CX		
  0x423099		488b91080e0000		MOVQ 0xe08(CX), DX		
  0x4230a0		488b99100e0000		MOVQ 0xe10(CX), BX		
  0x4230a7		48d1eb			SHRQ $0x1, BX			
  0x4230aa		4839da			CMPQ BX, DX			
  0x4230ad		0f8d19010000		JGE 0x4231cc			
  0x4230b3		488b05fe480800		MOVQ runtime.sched+152(SB), AX	
  0x4230ba		4885c0			TESTQ AX, AX			
  0x4230bd		0f8409010000		JE 0x4231cc			
			sched.sudogcache = s.next
  0x4230c3		8b1547090a00		MOVL runtime.writeBarrier(SB), DX	
  0x4230c9		488b5810		MOVQ 0x10(AX), BX			
  0x4230cd		488d7010		LEAQ 0x10(AX), SI			
  0x4230d1		85d2			TESTL DX, DX				
  0x4230d3		0f85cf000000		JNE 0x4231a8				
  0x4230d9		48891dd8480800		MOVQ BX, runtime.sched+152(SB)		
			s.next = nil
  0x4230e0		48c7401000000000	MOVQ $0x0, 0x10(AX)	
			pp.sudogcache = append(pp.sudogcache, s)
  0x4230e8		488b91000e0000		MOVQ 0xe00(CX), DX			
  0x4230ef		488b99080e0000		MOVQ 0xe08(CX), BX			
  0x4230f6		488bb1100e0000		MOVQ 0xe10(CX), SI			
  0x4230fd		4c8d4301		LEAQ 0x1(BX), R8			
  0x423101		4939f0			CMPQ SI, R8				
  0x423104		7f2c			JG 0x423132				
  0x423106		488d7301		LEAQ 0x1(BX), SI			
  0x42310a		4889b1080e0000		MOVQ SI, 0xe08(CX)			
  0x423111		8b35f9080a00		MOVL runtime.writeBarrier(SB), SI	
  0x423117		488d3cda		LEAQ 0(DX)(BX*8), DI			
  0x42311b		85f6			TESTL SI, SI				
  0x42311d		7509			JNE 0x423128				
  0x42311f		488904da		MOVQ AX, 0(DX)(BX*8)			
  0x423123		e96cffffff		JMP 0x423094				
  0x423128		e873370200		CALL runtime.gcWriteBarrier(SB)		
  0x42312d		e962ffffff		JMP 0x423094				
  0x423132		4889442448		MOVQ AX, 0x48(SP)			
  0x423137		488d05421e0300		LEAQ 0x31e42(IP), AX			
  0x42313e		48890424		MOVQ AX, 0(SP)				
  0x423142		4889542408		MOVQ DX, 0x8(SP)			
  0x423147		48895c2410		MOVQ BX, 0x10(SP)			
  0x42314c		4889742418		MOVQ SI, 0x18(SP)			
  0x423151		4c89442420		MOVQ R8, 0x20(SP)			
  0x423156		e805070100		CALL runtime.growslice(SB)		
  0x42315b		488b442428		MOVQ 0x28(SP), AX			
  0x423160		488b4c2430		MOVQ 0x30(SP), CX			
  0x423165		488b542438		MOVQ 0x38(SP), DX			
  0x42316a		488b5c2458		MOVQ 0x58(SP), BX			
  0x42316f		488993100e0000		MOVQ DX, 0xe10(BX)			
  0x423176		8b1594080a00		MOVL runtime.writeBarrier(SB), DX	
  0x42317c		85d2			TESTL DX, DX				
  0x42317e		751c			JNE 0x42319c				
  0x423180		488983000e0000		MOVQ AX, 0xe00(BX)			
  0x423187		4889cb			MOVQ CX, BX				
  0x42318a		4889c2			MOVQ AX, DX				
  0x42318d		488b442448		MOVQ 0x48(SP), AX			
  0x423192		488b4c2458		MOVQ 0x58(SP), CX			
  0x423197		e96affffff		JMP 0x423106				
  0x42319c		488b7c2450		MOVQ 0x50(SP), DI			
  0x4231a1		e8fa360200		CALL runtime.gcWriteBarrier(SB)		
  0x4231a6		ebdf			JMP 0x423187				
			sched.sudogcache = s.next
  0x4231a8		488d3d09480800		LEAQ runtime.sched+152(SB), DI	
  0x4231af		4889c2			MOVQ AX, DX			
  0x4231b2		4889d8			MOVQ BX, AX			
  0x4231b5		e8e6360200		CALL runtime.gcWriteBarrier(SB)	
  0x4231ba		4889f7			MOVQ SI, DI			
			s.next = nil
  0x4231bd		31c0			XORL AX, AX			
  0x4231bf		e8dc360200		CALL runtime.gcWriteBarrier(SB)	
  0x4231c4		4889d0			MOVQ DX, AX			
			sched.sudogcache = s.next
  0x4231c7		e91cffffff		JMP 0x4230e8		
		unlock(&sched.sudoglock)
  0x4231cc		488d05dd470800		LEAQ runtime.sched+144(SB), AX	
  0x4231d3		48890424		MOVQ AX, 0(SP)			
  0x4231d7		e8e464feff		CALL runtime.unlock(SB)		
  0x4231dc		488b442458		MOVQ 0x58(SP), AX		
		if len(pp.sudogcache) == 0 {
  0x4231e1		488b88080e0000		MOVQ 0xe08(AX), CX	
  0x4231e8		4885c9			TESTQ CX, CX		
  0x4231eb		0f84b1000000		JE 0x4232a2		
	n := len(pp.sudogcache)
  0x4231f1		488b88080e0000		MOVQ 0xe08(AX), CX	
  0x4231f8		488b90000e0000		MOVQ 0xe00(AX), DX	
	s := pp.sudogcache[n-1]
  0x4231ff		488d59ff		LEAQ -0x1(CX), BX	
  0x423203		4839cb			CMPQ CX, BX		
  0x423206		0f83a7010000		JAE 0x4233b3		
  0x42320c		488b74caf8		MOVQ -0x8(DX)(CX*8), SI	
  0x423211		488d7ccaf8		LEAQ -0x8(DX)(CX*8), DI	
	pp.sudogcache[n-1] = nil
  0x423216		448b05f3070a00		MOVL runtime.writeBarrier(SB), R8	
  0x42321d		4585c0			TESTL R8, R8				
  0x423220		7571			JNE 0x423293				
  0x423222		48c744caf800000000	MOVQ $0x0, -0x8(DX)(CX*8)		
	pp.sudogcache = pp.sudogcache[:n-1]
  0x42322b		488b88100e0000		MOVQ 0xe10(AX), CX	
  0x423232		4839cb			CMPQ CX, BX		
  0x423235		0f8771010000		JA 0x4233ac		
  0x42323b		488998080e0000		MOVQ BX, 0xe08(AX)	
	if s.elem != nil {
  0x423242		488b4620		MOVQ 0x20(SI), AX	
  0x423246		4885c0			TESTQ AX, AX		
  0x423249		0f8542010000		JNE 0x423391		
	_g_ := getg()
  0x42324f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x423258		488b4c2440		MOVQ 0x40(SP), CX	
	mp.locks--
  0x42325d		8b9100010000		MOVL 0x100(CX), DX	
  0x423263		8d5aff			LEAL -0x1(DX), BX	
  0x423266		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x42326c		83fa01			CMPL $0x1, DX		
  0x42326f		7513			JNE 0x423284		
  0x423271		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x423278		84c9			TESTL CL, CL		
  0x42327a		7408			JE 0x423284		
		_g_.stackguard0 = stackPreempt
  0x42327c		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	return s
  0x423284		4889742470		MOVQ SI, 0x70(SP)	
  0x423289		488b6c2460		MOVQ 0x60(SP), BP	
  0x42328e		4883c468		ADDQ $0x68, SP		
  0x423292		c3			RET			
  0x423293		4889c1			MOVQ AX, CX		
	pp.sudogcache[n-1] = nil
  0x423296		31c0			XORL AX, AX			
  0x423298		e803360200		CALL runtime.gcWriteBarrier(SB)	
  0x42329d		4889c8			MOVQ CX, AX			
  0x4232a0		eb89			JMP 0x42322b			
			pp.sudogcache = append(pp.sudogcache, new(sudog))
  0x4232a2		488d05172f0400		LEAQ 0x42f17(IP), AX			
  0x4232a9		48890424		MOVQ AX, 0(SP)				
  0x4232ad		e86e7efeff		CALL runtime.newobject(SB)		
  0x4232b2		488b442458		MOVQ 0x58(SP), AX			
  0x4232b7		488b88100e0000		MOVQ 0xe10(AX), CX			
  0x4232be		488b90000e0000		MOVQ 0xe00(AX), DX			
  0x4232c5		488b98080e0000		MOVQ 0xe08(AX), BX			
  0x4232cc		488d7301		LEAQ 0x1(BX), SI			
  0x4232d0		488b7c2408		MOVQ 0x8(SP), DI			
  0x4232d5		4839ce			CMPQ CX, SI				
  0x4232d8		7f3b			JG 0x423315				
  0x4232da		488d4b01		LEAQ 0x1(BX), CX			
  0x4232de		488988080e0000		MOVQ CX, 0xe08(AX)			
  0x4232e5		488d0cda		LEAQ 0(DX)(BX*8), CX			
  0x4232e9		8b3521070a00		MOVL runtime.writeBarrier(SB), SI	
  0x4232ef		85f6			TESTL SI, SI				
  0x4232f1		7509			JNE 0x4232fc				
  0x4232f3		48893cda		MOVQ DI, 0(DX)(BX*8)			
  0x4232f7		e9f5feffff		JMP 0x4231f1				
  0x4232fc		4889fa			MOVQ DI, DX				
  0x4232ff		4889cf			MOVQ CX, DI				
  0x423302		4889c3			MOVQ AX, BX				
  0x423305		4889d0			MOVQ DX, AX				
  0x423308		e893350200		CALL runtime.gcWriteBarrier(SB)		
  0x42330d		4889d8			MOVQ BX, AX				
  0x423310		e9dcfeffff		JMP 0x4231f1				
  0x423315		48897c2448		MOVQ DI, 0x48(SP)			
  0x42331a		488d055f1c0300		LEAQ 0x31c5f(IP), AX			
  0x423321		48890424		MOVQ AX, 0(SP)				
  0x423325		4889542408		MOVQ DX, 0x8(SP)			
  0x42332a		48895c2410		MOVQ BX, 0x10(SP)			
  0x42332f		48894c2418		MOVQ CX, 0x18(SP)			
  0x423334		4889742420		MOVQ SI, 0x20(SP)			
  0x423339		e822050100		CALL runtime.growslice(SB)		
  0x42333e		488b442428		MOVQ 0x28(SP), AX			
  0x423343		488b4c2430		MOVQ 0x30(SP), CX			
  0x423348		488b542438		MOVQ 0x38(SP), DX			
  0x42334d		488b5c2458		MOVQ 0x58(SP), BX			
  0x423352		488993100e0000		MOVQ DX, 0xe10(BX)			
  0x423359		8b15b1060a00		MOVL runtime.writeBarrier(SB), DX	
  0x42335f		85d2			TESTL DX, DX				
  0x423361		751a			JNE 0x42337d				
  0x423363		488983000e0000		MOVQ AX, 0xe00(BX)			
  0x42336a		488b7c2448		MOVQ 0x48(SP), DI			
  0x42336f		4889c2			MOVQ AX, DX				
  0x423372		4889d8			MOVQ BX, AX				
  0x423375		4889cb			MOVQ CX, BX				
  0x423378		e95dffffff		JMP 0x4232da				
  0x42337d		488b7c2450		MOVQ 0x50(SP), DI			
  0x423382		e819350200		CALL runtime.gcWriteBarrier(SB)		
  0x423387		ebe1			JMP 0x42336a				
  0x423389		4889d8			MOVQ BX, AX				
	n := len(pp.sudogcache)
  0x42338c		e960feffff		JMP 0x4231f1		
		throw("acquireSudog: found s.elem != nil in cache")
  0x423391		488d05dfa00400		LEAQ 0x4a0df(IP), AX	
  0x423398		48890424		MOVQ AX, 0(SP)		
  0x42339c		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x4233a5		e826deffff		CALL runtime.throw(SB)	
  0x4233aa		0f0b			UD2			
	pp.sudogcache = pp.sudogcache[:n-1]
  0x4233ac		e8ffc6ffff		CALL runtime.panicslice(SB)	
  0x4233b1		0f0b			UD2				
	s := pp.sudogcache[n-1]
  0x4233b3		e888c6ffff		CALL runtime.panicindex(SB)	
  0x4233b8		0f0b			UD2				

TEXT runtime.releaseSudog(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func releaseSudog(s *sudog) {
  0x4233c0		4883ec70		SUBQ $0x70, SP		
  0x4233c4		48896c2468		MOVQ BP, 0x68(SP)	
  0x4233c9		488d6c2468		LEAQ 0x68(SP), BP	
  0x4233ce		488b442478		MOVQ 0x78(SP), AX	
	if s.elem != nil {
  0x4233d3		488b4820		MOVQ 0x20(AX), CX	
  0x4233d7		4885c9			TESTQ CX, CX		
  0x4233da		0f857a030000		JNE 0x42375a		
	if s.isSelect {
  0x4233e0		0fb64808		MOVZX 0x8(AX), CX	
  0x4233e4		84c9			TESTL CL, CL		
  0x4233e6		0f8553030000		JNE 0x42373f		
	if s.next != nil {
  0x4233ec		488b4810		MOVQ 0x10(AX), CX	
  0x4233f0		4885c9			TESTQ CX, CX		
  0x4233f3		0f852b030000		JNE 0x423724		
	if s.prev != nil {
  0x4233f9		488b4818		MOVQ 0x18(AX), CX	
  0x4233fd		4885c9			TESTQ CX, CX		
  0x423400		0f8503030000		JNE 0x423709		
	if s.waitlink != nil {
  0x423406		488b4848		MOVQ 0x48(AX), CX	
  0x42340a		4885c9			TESTQ CX, CX		
  0x42340d		0f85db020000		JNE 0x4236ee		
	if s.c != nil {
  0x423413		488b4858		MOVQ 0x58(AX), CX	
  0x423417		4885c9			TESTQ CX, CX		
  0x42341a		0f85b3020000		JNE 0x4236d3		
	gp := getg()
  0x423420		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if gp.param != nil {
  0x423429		488b9188000000		MOVQ 0x88(CX), DX	
  0x423430		4885d2			TESTQ DX, DX		
  0x423433		0f857f020000		JNE 0x4236b8		
	_g_.m.locks++
  0x423439		488b5130		MOVQ 0x30(CX), DX	
  0x42343d		ff8200010000		INCL 0x100(DX)		
	return _g_.m
  0x423443		488b5130		MOVQ 0x30(CX), DX	
  0x423447		4889542440		MOVQ DX, 0x40(SP)	
	pp := mp.p.ptr()
  0x42344c		488b9ad0000000		MOVQ 0xd0(DX), BX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x423453		48895c2460		MOVQ BX, 0x60(SP)	
	return _g_.m
  0x423458		8401			TESTB AL, 0(CX)		
	if len(pp.sudogcache) == cap(pp.sudogcache) {
  0x42345a		488b8b100e0000		MOVQ 0xe10(BX), CX	
  0x423461		488bb3080e0000		MOVQ 0xe08(BX), SI	
  0x423468		4c8d83000e0000		LEAQ 0xe00(BX), R8	
  0x42346f		4c89442458		MOVQ R8, 0x58(SP)	
  0x423474		4839ce			CMPQ CX, SI		
  0x423477		0f8512010000		JNE 0x42358f		
  0x42347d		31c9			XORL CX, CX		
  0x42347f		4889ce			MOVQ CX, SI		
		for len(pp.sudogcache) > cap(pp.sudogcache)/2 {
  0x423482		eb03			JMP 0x423487		
  0x423484		4c89e6			MOVQ R12, SI		
  0x423487		4c8b8b000e0000		MOVQ 0xe00(BX), R9	
  0x42348e		4c8b93080e0000		MOVQ 0xe08(BX), R10	
  0x423495		4c8b9b100e0000		MOVQ 0xe10(BX), R11	
  0x42349c		49d1eb			SHRQ $0x1, R11		
  0x42349f		4d39da			CMPQ R11, R10		
  0x4234a2		0f8e8d000000		JLE 0x423535		
			p := pp.sudogcache[n-1]
  0x4234a8		4d8d5aff		LEAQ -0x1(R10), R11		
  0x4234ac		4d39d3			CMPQ R10, R11			
  0x4234af		0f83fc010000		JAE 0x4236b1			
  0x4234b5		4f8b64d1f8		MOVQ -0x8(R9)(R10*8), R12	
  0x4234ba		4b8d7cd1f8		LEAQ -0x8(R9)(R10*8), DI	
			pp.sudogcache[n-1] = nil
  0x4234bf		448b2d4a050a00		MOVL runtime.writeBarrier(SB), R13	
  0x4234c6		4585ed			TESTL R13, R13				
  0x4234c9		755b			JNE 0x423526				
  0x4234cb		4bc744d1f800000000	MOVQ $0x0, -0x8(R9)(R10*8)		
			pp.sudogcache = pp.sudogcache[:n-1]
  0x4234d4		4c8b8b100e0000		MOVQ 0xe10(BX), R9	
  0x4234db		4d39cb			CMPQ R9, R11		
  0x4234de		0f87c6010000		JA 0x4236aa		
  0x4234e4		4c899b080e0000		MOVQ R11, 0xe08(BX)	
			if first == nil {
  0x4234eb		4885c9			TESTQ CX, CX		
  0x4234ee		742e			JE 0x42351e		
				last.next = p
  0x4234f0		8406			TESTB AL, 0(SI)				
  0x4234f2		448b0d17050a00		MOVL runtime.writeBarrier(SB), R9	
  0x4234f9		488d7e10		LEAQ 0x10(SI), DI			
  0x4234fd		4585c9			TESTL R9, R9				
  0x423500		7509			JNE 0x42350b				
  0x423502		4c896610		MOVQ R12, 0x10(SI)			
  0x423506		e979ffffff		JMP 0x423484				
  0x42350b		4889c6			MOVQ AX, SI				
  0x42350e		4c89e0			MOVQ R12, AX				
  0x423511		e88a330200		CALL runtime.gcWriteBarrier(SB)		
  0x423516		4889f0			MOVQ SI, AX				
  0x423519		e966ffffff		JMP 0x423484				
  0x42351e		4c89e1			MOVQ R12, CX				
				first = p
  0x423521		e95effffff		JMP 0x423484		
  0x423526		4989c1			MOVQ AX, R9		
			pp.sudogcache[n-1] = nil
  0x423529		31c0			XORL AX, AX			
  0x42352b		e870330200		CALL runtime.gcWriteBarrier(SB)	
  0x423530		4c89c8			MOVQ R9, AX			
  0x423533		eb9f			JMP 0x4234d4			
  0x423535		4889742448		MOVQ SI, 0x48(SP)		
  0x42353a		48894c2450		MOVQ CX, 0x50(SP)		
		lock(&sched.sudoglock)
  0x42353f		488d056a440800		LEAQ runtime.sched+144(SB), AX	
  0x423546		48890424		MOVQ AX, 0(SP)			
  0x42354a		e8d15ffeff		CALL runtime.lock(SB)		
  0x42354f		488b442448		MOVQ 0x48(SP), AX		
		last.next = sched.sudogcache
  0x423554		8400			TESTB AL, 0(AX)				
  0x423556		8b0db4040a00		MOVL runtime.writeBarrier(SB), CX	
  0x42355c		488d7810		LEAQ 0x10(AX), DI			
  0x423560		488b1551440800		MOVQ runtime.sched+152(SB), DX		
  0x423567		85c9			TESTL CX, CX				
  0x423569		0f851d010000		JNE 0x42368c				
  0x42356f		48895010		MOVQ DX, 0x10(AX)			
  0x423573		488b442450		MOVQ 0x50(SP), AX			
		sched.sudogcache = first
  0x423578		48890539440800		MOVQ AX, runtime.sched+152(SB)	
		unlock(&sched.sudoglock)
  0x42357f		488d052a440800		LEAQ runtime.sched+144(SB), AX	
  0x423586		48890424		MOVQ AX, 0(SP)			
  0x42358a		e83161feff		CALL runtime.unlock(SB)		
  0x42358f		488b4c2460		MOVQ 0x60(SP), CX		
	pp.sudogcache = append(pp.sudogcache, s)
  0x423594		488b91100e0000		MOVQ 0xe10(CX), DX			
  0x42359b		488b99080e0000		MOVQ 0xe08(CX), BX			
  0x4235a2		488bb1000e0000		MOVQ 0xe00(CX), SI			
  0x4235a9		4c8d4301		LEAQ 0x1(BX), R8			
  0x4235ad		4939d0			CMPQ DX, R8				
  0x4235b0		7f6d			JG 0x42361f				
  0x4235b2		488d5301		LEAQ 0x1(BX), DX			
  0x4235b6		488991080e0000		MOVQ DX, 0xe08(CX)			
  0x4235bd		8b0d4d040a00		MOVL runtime.writeBarrier(SB), CX	
  0x4235c3		488d3cde		LEAQ 0(SI)(BX*8), DI			
  0x4235c7		85c9			TESTL CX, CX				
  0x4235c9		7548			JNE 0x423613				
  0x4235cb		488b442478		MOVQ 0x78(SP), AX			
  0x4235d0		488904de		MOVQ AX, 0(SI)(BX*8)			
	_g_ := getg()
  0x4235d4		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4235dd		488b4c2440		MOVQ 0x40(SP), CX	
	mp.locks--
  0x4235e2		8b9100010000		MOVL 0x100(CX), DX	
  0x4235e8		8d5aff			LEAL -0x1(DX), BX	
  0x4235eb		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x4235f1		83fa01			CMPL $0x1, DX		
  0x4235f4		7513			JNE 0x423609		
  0x4235f6		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x4235fd		84c9			TESTL CL, CL		
  0x4235ff		7408			JE 0x423609		
		_g_.stackguard0 = stackPreempt
  0x423601		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x423609		488b6c2468		MOVQ 0x68(SP), BP	
  0x42360e		4883c470		ADDQ $0x70, SP		
  0x423612		c3			RET			
  0x423613		488b442478		MOVQ 0x78(SP), AX	
	pp.sudogcache = append(pp.sudogcache, s)
  0x423618		e883320200		CALL runtime.gcWriteBarrier(SB)		
  0x42361d		ebb5			JMP 0x4235d4				
  0x42361f		488d055a190300		LEAQ 0x3195a(IP), AX			
  0x423626		48890424		MOVQ AX, 0(SP)				
  0x42362a		4889742408		MOVQ SI, 0x8(SP)			
  0x42362f		48895c2410		MOVQ BX, 0x10(SP)			
  0x423634		4889542418		MOVQ DX, 0x18(SP)			
  0x423639		4c89442420		MOVQ R8, 0x20(SP)			
  0x42363e		e81d020100		CALL runtime.growslice(SB)		
  0x423643		488b442428		MOVQ 0x28(SP), AX			
  0x423648		488b4c2430		MOVQ 0x30(SP), CX			
  0x42364d		488b542438		MOVQ 0x38(SP), DX			
  0x423652		488b5c2460		MOVQ 0x60(SP), BX			
  0x423657		488993100e0000		MOVQ DX, 0xe10(BX)			
  0x42365e		8b15ac030a00		MOVL runtime.writeBarrier(SB), DX	
  0x423664		85d2			TESTL DX, DX				
  0x423666		7518			JNE 0x423680				
  0x423668		488983000e0000		MOVQ AX, 0xe00(BX)			
  0x42366f		4889c6			MOVQ AX, SI				
  0x423672		4889ca			MOVQ CX, DX				
  0x423675		4889d9			MOVQ BX, CX				
  0x423678		4889d3			MOVQ DX, BX				
  0x42367b		e932ffffff		JMP 0x4235b2				
  0x423680		488b7c2458		MOVQ 0x58(SP), DI			
  0x423685		e816320200		CALL runtime.gcWriteBarrier(SB)		
  0x42368a		ebe3			JMP 0x42366f				
  0x42368c		4889d0			MOVQ DX, AX				
		last.next = sched.sudogcache
  0x42368f		e80c320200		CALL runtime.gcWriteBarrier(SB)	
		sched.sudogcache = first
  0x423694		488d3d1d430800		LEAQ runtime.sched+152(SB), DI	
  0x42369b		488b442450		MOVQ 0x50(SP), AX		
  0x4236a0		e8fb310200		CALL runtime.gcWriteBarrier(SB)	
		last.next = sched.sudogcache
  0x4236a5		e9d5feffff		JMP 0x42357f		
			pp.sudogcache = pp.sudogcache[:n-1]
  0x4236aa		e801c4ffff		CALL runtime.panicslice(SB)	
  0x4236af		0f0b			UD2				
			p := pp.sudogcache[n-1]
  0x4236b1		e88ac3ffff		CALL runtime.panicindex(SB)	
  0x4236b6		0f0b			UD2				
		throw("runtime: releaseSudog with non-nil gp.param")
  0x4236b8		488d050c9f0400		LEAQ 0x49f0c(IP), AX	
  0x4236bf		48890424		MOVQ AX, 0(SP)		
  0x4236c3		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x4236cc		e8ffdaffff		CALL runtime.throw(SB)	
  0x4236d1		0f0b			UD2			
		throw("runtime: sudog with non-nil c")
  0x4236d3		488d05888c0400		LEAQ 0x48c88(IP), AX	
  0x4236da		48890424		MOVQ AX, 0(SP)		
  0x4236de		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x4236e7		e8e4daffff		CALL runtime.throw(SB)	
  0x4236ec		0f0b			UD2			
		throw("runtime: sudog with non-nil waitlink")
  0x4236ee		488d05c1970400		LEAQ 0x497c1(IP), AX	
  0x4236f5		48890424		MOVQ AX, 0(SP)		
  0x4236f9		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x423702		e8c9daffff		CALL runtime.throw(SB)	
  0x423707		0f0b			UD2			
		throw("runtime: sudog with non-nil prev")
  0x423709		488d05d3910400		LEAQ 0x491d3(IP), AX	
  0x423710		48890424		MOVQ AX, 0(SP)		
  0x423714		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x42371d		e8aedaffff		CALL runtime.throw(SB)	
  0x423722		0f0b			UD2			
		throw("runtime: sudog with non-nil next")
  0x423724		488d0598910400		LEAQ 0x49198(IP), AX	
  0x42372b		48890424		MOVQ AX, 0(SP)		
  0x42372f		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x423738		e893daffff		CALL runtime.throw(SB)	
  0x42373d		0f0b			UD2			
		throw("runtime: sudog with non-false isSelect")
  0x42373f		488d059a990400		LEAQ 0x4999a(IP), AX	
  0x423746		48890424		MOVQ AX, 0(SP)		
  0x42374a		48c744240826000000	MOVQ $0x26, 0x8(SP)	
  0x423753		e878daffff		CALL runtime.throw(SB)	
  0x423758		0f0b			UD2			
		throw("runtime: sudog with non-nil elem")
  0x42375a		488d0542910400		LEAQ 0x49142(IP), AX	
  0x423761		48890424		MOVQ AX, 0(SP)		
  0x423765		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x42376e		e85ddaffff		CALL runtime.throw(SB)	
  0x423773		0f0b			UD2			

TEXT runtime.funcPC(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x423780		b808000000		MOVL $0x8, AX		
  0x423785		488d4c2408		LEAQ 0x8(SP), CX	
  0x42378a		488b0401		MOVQ 0(CX)(AX*1), AX	
  0x42378e		488d4c2410		LEAQ 0x10(SP), CX	
  0x423793		8401			TESTB AL, 0(CX)		
  0x423795		488b00			MOVQ 0(AX), AX		
  0x423798		4889442418		MOVQ AX, 0x18(SP)	
  0x42379d		c3			RET			

TEXT runtime.badmcall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func badmcall(fn func(*g)) {
  0x4237a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4237a9		483b6110		CMPQ 0x10(CX), SP	
  0x4237ad		7629			JBE 0x4237d8		
  0x4237af		4883ec18		SUBQ $0x18, SP		
  0x4237b3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4237b8		488d6c2410		LEAQ 0x10(SP), BP	
	throw("runtime: mcall called on m->g0 stack")
  0x4237bd		488d05ce960400		LEAQ 0x496ce(IP), AX	
  0x4237c4		48890424		MOVQ AX, 0(SP)		
  0x4237c8		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x4237d1		e8fad9ffff		CALL runtime.throw(SB)	
  0x4237d6		0f0b			UD2			
func badmcall(fn func(*g)) {
  0x4237d8		e8930d0200		CALL runtime.morestack_noctxt(SB)	
  0x4237dd		ebc1			JMP runtime.badmcall(SB)		

TEXT runtime.badmcall2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func badmcall2(fn func(*g)) {
  0x4237e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4237e9		483b6110		CMPQ 0x10(CX), SP	
  0x4237ed		7629			JBE 0x423818		
  0x4237ef		4883ec18		SUBQ $0x18, SP		
  0x4237f3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4237f8		488d6c2410		LEAQ 0x10(SP), BP	
	throw("runtime: mcall function returned")
  0x4237fd		488d053f900400		LEAQ 0x4903f(IP), AX	
  0x423804		48890424		MOVQ AX, 0(SP)		
  0x423808		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x423811		e8bad9ffff		CALL runtime.throw(SB)	
  0x423816		0f0b			UD2			
func badmcall2(fn func(*g)) {
  0x423818		e8530d0200		CALL runtime.morestack_noctxt(SB)	
  0x42381d		ebc1			JMP runtime.badmcall2(SB)		

TEXT runtime.badreflectcall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func badreflectcall() {
  0x423820		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423829		483b6110		CMPQ 0x10(CX), SP	
  0x42382d		762c			JBE 0x42385b		
  0x42382f		4883ec18		SUBQ $0x18, SP		
  0x423833		48896c2410		MOVQ BP, 0x10(SP)	
  0x423838		488d6c2410		LEAQ 0x10(SP), BP	
	panic(plainError("arg size to reflect.call more than 1GB"))
  0x42383d		488d05fc770300		LEAQ 0x377fc(IP), AX			
  0x423844		48890424		MOVQ AX, 0(SP)				
  0x423848		488d0541150500		LEAQ runtime.statictmp_21(SB), AX	
  0x42384f		4889442408		MOVQ AX, 0x8(SP)			
  0x423854		e8d7d1ffff		CALL runtime.gopanic(SB)		
  0x423859		0f0b			UD2					
func badreflectcall() {
  0x42385b		e8100d0200		CALL runtime.morestack_noctxt(SB)	
  0x423860		ebbe			JMP runtime.badreflectcall(SB)		

TEXT runtime.badmorestackg0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func badmorestackg0() {
  0x423870		4883ec28		SUBQ $0x28, SP		
  0x423874		48896c2420		MOVQ BP, 0x20(SP)	
  0x423879		488d6c2420		LEAQ 0x20(SP), BP	
	write(2, sp.str, int32(sp.len))
  0x42387e		488b05ab210800		MOVQ runtime.badmorestackg0Msg(SB), AX		
  0x423885		488b0dac210800		MOVQ runtime.badmorestackg0Msg+8(SB), CX	
  0x42388c		894c2410		MOVL CX, 0x10(SP)				
  0x423890		48c7042402000000	MOVQ $0x2, 0(SP)				
  0x423898		4889442408		MOVQ AX, 0x8(SP)				
  0x42389d		e8ae3f0200		CALL runtime.write(SB)				
}
  0x4238a2		488b6c2420		MOVQ 0x20(SP), BP	
  0x4238a7		4883c428		ADDQ $0x28, SP		
  0x4238ab		c3			RET			

TEXT runtime.badmorestackgsignal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func badmorestackgsignal() {
  0x4238b0		4883ec28		SUBQ $0x28, SP		
  0x4238b4		48896c2420		MOVQ BP, 0x20(SP)	
  0x4238b9		488d6c2420		LEAQ 0x20(SP), BP	
	write(2, sp.str, int32(sp.len))
  0x4238be		488b057b210800		MOVQ runtime.badmorestackgsignalMsg(SB), AX	
  0x4238c5		488b0d7c210800		MOVQ runtime.badmorestackgsignalMsg+8(SB), CX	
  0x4238cc		894c2410		MOVL CX, 0x10(SP)				
  0x4238d0		48c7042402000000	MOVQ $0x2, 0(SP)				
  0x4238d8		4889442408		MOVQ AX, 0x8(SP)				
  0x4238dd		e86e3f0200		CALL runtime.write(SB)				
}
  0x4238e2		488b6c2420		MOVQ 0x20(SP), BP	
  0x4238e7		4883c428		ADDQ $0x28, SP		
  0x4238eb		c3			RET			

TEXT runtime.badctxt(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func badctxt() {
  0x4238f0		4883ec18		SUBQ $0x18, SP		
  0x4238f4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4238f9		488d6c2410		LEAQ 0x10(SP), BP	
	throw("ctxt != 0")
  0x4238fe		488d0512680400		LEAQ 0x46812(IP), AX	
  0x423905		48890424		MOVQ AX, 0(SP)		
  0x423909		48c744240809000000	MOVQ $0x9, 0x8(SP)	
  0x423912		e8b9d8ffff		CALL runtime.throw(SB)	
  0x423917		0f0b			UD2			

TEXT runtime.allgadd(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func allgadd(gp *g) {
  0x423920		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423929		483b6110		CMPQ 0x10(CX), SP	
  0x42392d		0f8621010000		JBE 0x423a54		
  0x423933		4883ec48		SUBQ $0x48, SP		
  0x423937		48896c2440		MOVQ BP, 0x40(SP)	
  0x42393c		488d6c2440		LEAQ 0x40(SP), BP	
  0x423941		488b442450		MOVQ 0x50(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x423946		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp) == _Gidle {
  0x42394c		85c9			TESTL CX, CX		
  0x42394e		0f84e5000000		JE 0x423a39		
	lock(&allglock)
  0x423954		488d05bdff0900		LEAQ runtime.allglock(SB), AX	
  0x42395b		48890424		MOVQ AX, 0(SP)			
  0x42395f		e8bc5bfeff		CALL runtime.lock(SB)		
	allgs = append(allgs, gp)
  0x423964		488b05253d0800		MOVQ runtime.allgs(SB), AX		
  0x42396b		488b0d263d0800		MOVQ runtime.allgs+8(SB), CX		
  0x423972		488b15273d0800		MOVQ runtime.allgs+16(SB), DX		
  0x423979		488d5901		LEAQ 0x1(CX), BX			
  0x42397d		4839d3			CMPQ DX, BX				
  0x423980		7f56			JG 0x4239d8				
  0x423982		488d5101		LEAQ 0x1(CX), DX			
  0x423986		4889150b3d0800		MOVQ DX, runtime.allgs+8(SB)		
  0x42398d		488d3cc8		LEAQ 0(AX)(CX*8), DI			
  0x423991		8b1579000a00		MOVL runtime.writeBarrier(SB), DX	
  0x423997		85d2			TESTL DX, DX				
  0x423999		7531			JNE 0x4239cc				
  0x42399b		488b542450		MOVQ 0x50(SP), DX			
  0x4239a0		488914c8		MOVQ DX, 0(AX)(CX*8)			
	allglen = uintptr(len(allgs))
  0x4239a4		488b05ed3c0800		MOVQ runtime.allgs+8(SB), AX	
  0x4239ab		4889055eff0900		MOVQ AX, runtime.allglen(SB)	
	unlock(&allglock)
  0x4239b2		488d055fff0900		LEAQ runtime.allglock(SB), AX	
  0x4239b9		48890424		MOVQ AX, 0(SP)			
  0x4239bd		e8fe5cfeff		CALL runtime.unlock(SB)		
}
  0x4239c2		488b6c2440		MOVQ 0x40(SP), BP	
  0x4239c7		4883c448		ADDQ $0x48, SP		
  0x4239cb		c3			RET			
  0x4239cc		488b442450		MOVQ 0x50(SP), AX	
	allgs = append(allgs, gp)
  0x4239d1		e8ca2e0200		CALL runtime.gcWriteBarrier(SB)		
  0x4239d6		ebcc			JMP 0x4239a4				
  0x4239d8		488d3561080300		LEAQ 0x30861(IP), SI			
  0x4239df		48893424		MOVQ SI, 0(SP)				
  0x4239e3		4889442408		MOVQ AX, 0x8(SP)			
  0x4239e8		48894c2410		MOVQ CX, 0x10(SP)			
  0x4239ed		4889542418		MOVQ DX, 0x18(SP)			
  0x4239f2		48895c2420		MOVQ BX, 0x20(SP)			
  0x4239f7		e864fe0000		CALL runtime.growslice(SB)		
  0x4239fc		488b442428		MOVQ 0x28(SP), AX			
  0x423a01		488b4c2430		MOVQ 0x30(SP), CX			
  0x423a06		488b542438		MOVQ 0x38(SP), DX			
  0x423a0b		4889158e3c0800		MOVQ DX, runtime.allgs+16(SB)		
  0x423a12		8b15f8ff0900		MOVL runtime.writeBarrier(SB), DX	
  0x423a18		85d2			TESTL DX, DX				
  0x423a1a		750c			JNE 0x423a28				
  0x423a1c		4889056d3c0800		MOVQ AX, runtime.allgs(SB)		
  0x423a23		e95affffff		JMP 0x423982				
  0x423a28		488d3d613c0800		LEAQ runtime.allgs(SB), DI		
  0x423a2f		e86c2e0200		CALL runtime.gcWriteBarrier(SB)		
  0x423a34		e949ffffff		JMP 0x423982				
		throw("allgadd: bad status Gidle")
  0x423a39		488d05717f0400		LEAQ 0x47f71(IP), AX	
  0x423a40		48890424		MOVQ AX, 0(SP)		
  0x423a44		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x423a4d		e87ed7ffff		CALL runtime.throw(SB)	
  0x423a52		0f0b			UD2			
func allgadd(gp *g) {
  0x423a54		e8170b0200		CALL runtime.morestack_noctxt(SB)	
  0x423a59		e9c2feffff		JMP runtime.allgadd(SB)			

TEXT runtime.schedinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func schedinit() {
  0x423a60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423a69		483b6110		CMPQ 0x10(CX), SP	
  0x423a6d		0f8622020000		JBE 0x423c95		
  0x423a73		4883ec60		SUBQ $0x60, SP		
  0x423a77		48896c2458		MOVQ BP, 0x58(SP)	
  0x423a7c		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x423a81		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x423a8a		4889442438		MOVQ AX, 0x38(SP)	
	sched.maxmcount = 10000
  0x423a8f		c705b73e080010270000	MOVL $0x2710, runtime.sched+48(SB)	
	skipPC = funcPC(skipPleaseUseCallersFrames)
  0x423a99		488d0d402c0300		LEAQ 0x32c40(IP), CX	
  0x423aa0		48894c2448		MOVQ CX, 0x48(SP)	
  0x423aa5		488d0d4ca70400		LEAQ 0x4a74c(IP), CX	
  0x423aac		48894c2450		MOVQ CX, 0x50(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x423ab1		b908000000		MOVL $0x8, CX		
  0x423ab6		488d542448		LEAQ 0x48(SP), DX	
  0x423abb		488b0c0a		MOVQ 0(DX)(CX*1), CX	
  0x423abf		488d542450		LEAQ 0x50(SP), DX	
  0x423ac4		8402			TESTB AL, 0(DX)		
  0x423ac6		488b09			MOVQ 0(CX), CX		
	skipPC = funcPC(skipPleaseUseCallersFrames)
  0x423ac9		48890df8fe0900		MOVQ CX, runtime.skipPC(SB)	
	moduledataverify()
  0x423ad0		e8ab3f0100		CALL runtime.moduledataverify(SB)	
	stackinit()
  0x423ad5		e866030100		CALL runtime.stackinit(SB)	
	mallocinit()
  0x423ada		e86161feff		CALL runtime.mallocinit(SB)	
  0x423adf		488b442438		MOVQ 0x38(SP), AX		
	mcommoninit(_g_.m)
  0x423ae4		488b4830		MOVQ 0x30(AX), CX		
  0x423ae8		48890c24		MOVQ CX, 0(SP)			
  0x423aec		e86f020000		CALL runtime.mcommoninit(SB)	
	alginit()       // maps must not be used before this call
  0x423af1		e87ae2fdff		CALL runtime.alginit(SB)	
	modulesinit()   // provides activeModules
  0x423af6		e8d53c0100		CALL runtime.modulesinit(SB)	
	typelinksinit() // uses maps, activeModules
  0x423afb		e8b0bc0100		CALL runtime.typelinksinit(SB)	
	itabsinit()     // uses activeModules
  0x423b00		e89b53feff		CALL runtime.itabsinit(SB)	
  0x423b05		488b442438		MOVQ 0x38(SP), AX		
	msigsave(_g_.m)
  0x423b0a		488b4830		MOVQ 0x30(AX), CX		
  0x423b0e		48890c24		MOVQ CX, 0(SP)			
  0x423b12		e8a9f50000		CALL runtime.msigsave(SB)	
  0x423b17		488b442438		MOVQ 0x38(SP), AX		
	initSigmask = _g_.m.sigmask
  0x423b1c		488b4030		MOVQ 0x30(AX), AX			
  0x423b20		488b8080000000		MOVQ 0x80(AX), AX			
  0x423b27		4889054afe0900		MOVQ AX, runtime.initSigmask(SB)	
	goargs()
  0x423b2e		e80db20000		CALL runtime.goargs(SB)	
	goenvs()
  0x423b33		e868baffff		CALL runtime.goenvs(SB)	
	parsedebugvars()
  0x423b38		e893bb0000		CALL runtime.parsedebugvars(SB)	
	gcinit()
  0x423b3d		e86ec0feff		CALL runtime.gcinit(SB)	
	sched.lastpoll = uint64(nanotime())
  0x423b42		e8e93e0200		CALL runtime.nanotime(SB)	
  0x423b47		488b0424		MOVQ 0(SP), AX			
  0x423b4b		488905d63d0800		MOVQ AX, runtime.sched+8(SB)	
	procs := ncpu
  0x423b52		8b058cfd0900		MOVL runtime.ncpu(SB), AX	
  0x423b58		89442424		MOVL AX, 0x24(SP)		
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
  0x423b5c		488d0db3670400		LEAQ 0x467b3(IP), CX		
  0x423b63		48890c24		MOVQ CX, 0(SP)			
  0x423b67		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x423b70		e8fb0efeff		CALL runtime.gogetenv(SB)	
  0x423b75		488b442410		MOVQ 0x10(SP), AX		
  0x423b7a		488b4c2418		MOVQ 0x18(SP), CX		
  0x423b7f		48890424		MOVQ AX, 0(SP)			
  0x423b83		48894c2408		MOVQ CX, 0x8(SP)		
  0x423b88		e8a33a0100		CALL runtime.atoi32(SB)		
  0x423b8d		8b442410		MOVL 0x10(SP), AX		
  0x423b91		0fb64c2414		MOVZX 0x14(SP), CX		
  0x423b96		84c9			TESTL CL, CL			
  0x423b98		0f84d3000000		JE 0x423c71			
  0x423b9e		85c0			TESTL AX, AX			
  0x423ba0		0f8ecb000000		JLE 0x423c71			
	if procresize(procs) != nil {
  0x423ba6		890424			MOVL AX, 0(SP)			
  0x423ba9		e8d2790000		CALL runtime.procresize(SB)	
  0x423bae		488b442408		MOVQ 0x8(SP), AX		
  0x423bb3		4885c0			TESTQ AX, AX			
  0x423bb6		0f85be000000		JNE 0x423c7a			
	if debug.cgocheck > 1 {
  0x423bbc		8b0d02ff0900		MOVL runtime.debug+4(SB), CX	
  0x423bc2		83f901			CMPL $0x1, CX			
  0x423bc5		7e5c			JLE 0x423c23			
		writeBarrier.cgo = true
  0x423bc7		c60547fe090001		MOVB $0x1, runtime.writeBarrier+5(SB)	
		writeBarrier.enabled = true
  0x423bce		c6053bfe090001		MOVB $0x1, runtime.writeBarrier(SB)	
		for _, p := range allp {
  0x423bd5		488b0ddc3a0800		MOVQ runtime.allp+8(SB), CX	
  0x423bdc		48894c2430		MOVQ CX, 0x30(SP)		
  0x423be1		488b15c83a0800		MOVQ runtime.allp(SB), DX	
  0x423be8		4889542440		MOVQ DX, 0x40(SP)		
  0x423bed		31c0			XORL AX, AX			
  0x423bef		eb2d			JMP 0x423c1e			
  0x423bf1		4889442428		MOVQ AX, 0x28(SP)		
  0x423bf6		488b0cc2		MOVQ 0(DX)(AX*8), CX		
			p.wbBuf.reset()
  0x423bfa		8401			TESTB AL, 0(CX)			
  0x423bfc		4881c190120000		ADDQ $0x1290, CX		
  0x423c03		48890c24		MOVQ CX, 0(SP)			
  0x423c07		e844a8ffff		CALL runtime.(*wbBuf).reset(SB)	
  0x423c0c		488b442428		MOVQ 0x28(SP), AX		
		for _, p := range allp {
  0x423c11		48ffc0			INCQ AX			
  0x423c14		488b4c2430		MOVQ 0x30(SP), CX	
  0x423c19		488b542440		MOVQ 0x40(SP), DX	
  0x423c1e		4839c8			CMPQ CX, AX		
  0x423c21		7cce			JL 0x423bf1		
	if buildVersion == "" {
  0x423c23		488b0d2e1e0800		MOVQ runtime.buildVersion+8(SB), CX	
  0x423c2a		4885c9			TESTQ CX, CX				
  0x423c2d		7523			JNE 0x423c52				
		buildVersion = "unknown"
  0x423c2f		48c7051e1e080007000000	MOVQ $0x7, runtime.buildVersion+8(SB)	
  0x423c3a		8b0dd0fd0900		MOVL runtime.writeBarrier(SB), CX	
  0x423c40		85c9			TESTL CX, CX				
  0x423c42		7518			JNE 0x423c5c				
  0x423c44		488d052e630400		LEAQ 0x4632e(IP), AX			
  0x423c4b		488905fe1d0800		MOVQ AX, runtime.buildVersion(SB)	
  0x423c52		488b6c2458		MOVQ 0x58(SP), BP			
  0x423c57		4883c460		ADDQ $0x60, SP				
  0x423c5b		c3			RET					
  0x423c5c		488d3ded1d0800		LEAQ runtime.buildVersion(SB), DI	
  0x423c63		488d050f630400		LEAQ 0x4630f(IP), AX			
  0x423c6a		e8312c0200		CALL runtime.gcWriteBarrier(SB)		
  0x423c6f		ebe1			JMP 0x423c52				
  0x423c71		8b442424		MOVL 0x24(SP), AX			
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
  0x423c75		e92cffffff		JMP 0x423ba6		
		throw("unknown runnable goroutine during bootstrap")
  0x423c7a		488d0575990400		LEAQ 0x49975(IP), AX	
  0x423c81		48890424		MOVQ AX, 0(SP)		
  0x423c85		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x423c8e		e83dd5ffff		CALL runtime.throw(SB)	
  0x423c93		0f0b			UD2			
func schedinit() {
  0x423c95		e8d6080200		CALL runtime.morestack_noctxt(SB)	
  0x423c9a		e9c1fdffff		JMP runtime.schedinit(SB)		

TEXT runtime.checkmcount(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func checkmcount() {
  0x423ca0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423ca9		483b6110		CMPQ 0x10(CX), SP	
  0x423cad		0f869b000000		JBE 0x423d4e		
  0x423cb3		4883ec20		SUBQ $0x20, SP		
  0x423cb7		48896c2418		MOVQ BP, 0x18(SP)	
  0x423cbc		488d6c2418		LEAQ 0x18(SP), BP	
	if mcount() > sched.maxmcount {
  0x423cc1		8b05893c0800		MOVL runtime.sched+48(SB), AX	
	return int32(sched.mnext - sched.nmfreed)
  0x423cc7		488b0d7a3c0800		MOVQ runtime.sched+40(SB), CX	
  0x423cce		482b0d833c0800		SUBQ runtime.sched+56(SB), CX	
	if mcount() > sched.maxmcount {
  0x423cd5		39c1			CMPL AX, CX		
  0x423cd7		7f0a			JG 0x423ce3		
  0x423cd9		488b6c2418		MOVQ 0x18(SP), BP	
  0x423cde		4883c420		ADDQ $0x20, SP		
  0x423ce2		c3			RET			
  0x423ce3		89442414		MOVL AX, 0x14(SP)	
		print("runtime: program exceeds ", sched.maxmcount, "-thread limit\n")
  0x423ce7		e814deffff		CALL runtime.printlock(SB)	
  0x423cec		488d05037e0400		LEAQ 0x47e03(IP), AX		
  0x423cf3		48890424		MOVQ AX, 0(SP)			
  0x423cf7		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x423d00		e83be7ffff		CALL runtime.printstring(SB)	
  0x423d05		8b442414		MOVL 0x14(SP), AX		
  0x423d09		4863c0			MOVSXD AX, AX			
  0x423d0c		48890424		MOVQ AX, 0(SP)			
  0x423d10		e86be5ffff		CALL runtime.printint(SB)	
  0x423d15		488d05fa6a0400		LEAQ 0x46afa(IP), AX		
  0x423d1c		48890424		MOVQ AX, 0(SP)			
  0x423d20		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x423d29		e812e7ffff		CALL runtime.printstring(SB)	
  0x423d2e		e84ddeffff		CALL runtime.printunlock(SB)	
		throw("thread exhaustion")
  0x423d33		488d05de6f0400		LEAQ 0x46fde(IP), AX	
  0x423d3a		48890424		MOVQ AX, 0(SP)		
  0x423d3e		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x423d47		e884d4ffff		CALL runtime.throw(SB)	
  0x423d4c		0f0b			UD2			
func checkmcount() {
  0x423d4e		e81d080200		CALL runtime.morestack_noctxt(SB)	
  0x423d53		e948ffffff		JMP runtime.checkmcount(SB)		

TEXT runtime.mcommoninit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func mcommoninit(mp *m) {
  0x423d60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423d69		483b6110		CMPQ 0x10(CX), SP	
  0x423d6d		0f86c8010000		JBE 0x423f3b		
  0x423d73		4883ec30		SUBQ $0x30, SP		
  0x423d77		48896c2428		MOVQ BP, 0x28(SP)	
  0x423d7c		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x423d81		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_ != _g_.m.g0 {
  0x423d8a		488b4830		MOVQ 0x30(AX), CX	
  0x423d8e		488b09			MOVQ 0(CX), CX		
  0x423d91		4839c8			CMPQ CX, AX		
  0x423d94		0f854d010000		JNE 0x423ee7		
	lock(&sched.lock)
  0x423d9a		488d058f3b0800		LEAQ runtime.sched+16(SB), AX	
  0x423da1		48890424		MOVQ AX, 0(SP)			
  0x423da5		e87657feff		CALL runtime.lock(SB)		
	if sched.mnext+1 < sched.mnext {
  0x423daa		488b05973b0800		MOVQ runtime.sched+40(SB), AX	
  0x423db1		488d4801		LEAQ 0x1(AX), CX		
  0x423db5		4839c1			CMPQ AX, CX			
  0x423db8		0f8c62010000		JL 0x423f20			
  0x423dbe		488b4c2438		MOVQ 0x38(SP), CX		
	mp.id = sched.mnext
  0x423dc3		488981e0000000		MOVQ AX, 0xe0(CX)	
	sched.mnext++
  0x423dca		48ff05773b0800		INCQ runtime.sched+40(SB)	
	checkmcount()
  0x423dd1		e8cafeffff		CALL runtime.checkmcount(SB)	
  0x423dd6		488b442438		MOVQ 0x38(SP), AX		
	mp.fastrand[0] = 1597334677 * uint32(mp.id)
  0x423ddb		488b88e0000000		MOVQ 0xe0(AX), CX		
  0x423de2		69c99564355f		IMULL $0x5f356495, CX, CX	
  0x423de8		898820010000		MOVL CX, 0x120(AX)		
	mp.fastrand[1] = uint32(cputicks())
  0x423dee		e8fd1e0200		CALL runtime.cputicks(SB)	
  0x423df3		488b0424		MOVQ 0(SP), AX			
  0x423df7		488b4c2438		MOVQ 0x38(SP), CX		
  0x423dfc		898124010000		MOVL AX, 0x124(CX)		
	if mp.fastrand[0]|mp.fastrand[1] == 0 {
  0x423e02		8b9120010000		MOVL 0x120(CX), DX	
  0x423e08		09c2			ORL AX, DX		
  0x423e0a		85d2			TESTL DX, DX		
  0x423e0c		750a			JNE 0x423e18		
		mp.fastrand[1] = 1
  0x423e0e		c7812401000001000000	MOVL $0x1, 0x124(CX)	
	mpreinit(mp)
  0x423e18		48890c24		MOVQ CX, 0(SP)			
  0x423e1c		e8afb7ffff		CALL runtime.mpreinit(SB)	
  0x423e21		488b442438		MOVQ 0x38(SP), AX		
	if mp.gsignal != nil {
  0x423e26		488b4850		MOVQ 0x50(AX), CX	
  0x423e2a		4885c9			TESTQ CX, CX		
  0x423e2d		740e			JE 0x423e3d		
		mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard
  0x423e2f		488b11			MOVQ 0(CX), DX		
  0x423e32		4881c270030000		ADDQ $0x370, DX		
  0x423e39		48895118		MOVQ DX, 0x18(CX)	
	mp.alllink = allm
  0x423e3d		8b0dcdfb0900		MOVL runtime.writeBarrier(SB), CX	
  0x423e43		488b15ce370800		MOVQ runtime.allm(SB), DX		
  0x423e4a		488db850010000		LEAQ 0x150(AX), DI			
  0x423e51		85c9			TESTL CX, CX				
  0x423e53		757f			JNE 0x423ed4				
  0x423e55		48899050010000		MOVQ DX, 0x150(AX)			
	atomicstorep(unsafe.Pointer(&allm), unsafe.Pointer(mp))
  0x423e5c		488d0db5370800		LEAQ runtime.allm(SB), CX	
  0x423e63		48890c24		MOVQ CX, 0(SP)			
  0x423e67		4889442408		MOVQ AX, 0x8(SP)		
  0x423e6c		e86fe0fdff		CALL runtime.atomicstorep(SB)	
	unlock(&sched.lock)
  0x423e71		488d05b83a0800		LEAQ runtime.sched+16(SB), AX	
  0x423e78		48890424		MOVQ AX, 0(SP)			
  0x423e7c		e83f58feff		CALL runtime.unlock(SB)		
	if iscgo || GOOS == "solaris" || GOOS == "windows" {
  0x423e81		0fb60524fa0900		MOVZX runtime.iscgo(SB), AX	
  0x423e88		84c0			TESTL AL, AL			
  0x423e8a		750a			JNE 0x423e96			
  0x423e8c		488b6c2428		MOVQ 0x28(SP), BP		
  0x423e91		4883c430		ADDQ $0x30, SP			
  0x423e95		c3			RET				
		mp.cgoCallers = new(cgoCallers)
  0x423e96		488d05236d0300		LEAQ 0x36d23(IP), AX			
  0x423e9d		48890424		MOVQ AX, 0(SP)				
  0x423ea1		e87a72feff		CALL runtime.newobject(SB)		
  0x423ea6		8b0564fb0900		MOVL runtime.writeBarrier(SB), AX	
  0x423eac		488b4c2438		MOVQ 0x38(SP), CX			
  0x423eb1		488db940010000		LEAQ 0x140(CX), DI			
  0x423eb8		488b542408		MOVQ 0x8(SP), DX			
  0x423ebd		85c0			TESTL AX, AX				
  0x423ebf		7509			JNE 0x423eca				
  0x423ec1		48899140010000		MOVQ DX, 0x140(CX)			
  0x423ec8		ebc2			JMP 0x423e8c				
  0x423eca		4889d0			MOVQ DX, AX				
  0x423ecd		e8ce290200		CALL runtime.gcWriteBarrier(SB)		
  0x423ed2		ebb8			JMP 0x423e8c				
  0x423ed4		4889c1			MOVQ AX, CX				
  0x423ed7		4889d0			MOVQ DX, AX				
	mp.alllink = allm
  0x423eda		e8c1290200		CALL runtime.gcWriteBarrier(SB)	
  0x423edf		4889c8			MOVQ CX, AX			
  0x423ee2		e975ffffff		JMP 0x423e5c			
  0x423ee7		488b442438		MOVQ 0x38(SP), AX		
		callers(1, mp.createstack[:])
  0x423eec		8400			TESTB AL, 0(AX)			
  0x423eee		488d8870010000		LEAQ 0x170(AX), CX		
  0x423ef5		8401			TESTB AL, 0(CX)			
  0x423ef7		48c7042401000000	MOVQ $0x1, 0(SP)		
  0x423eff		48894c2408		MOVQ CX, 0x8(SP)		
  0x423f04		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x423f0d		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x423f16		e8e5990100		CALL runtime.callers(SB)	
  0x423f1b		e97afeffff		JMP 0x423d9a			
		throw("runtime: thread ID overflow")
  0x423f20		488d05687f0400		LEAQ 0x47f68(IP), AX	
  0x423f27		48890424		MOVQ AX, 0(SP)		
  0x423f2b		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x423f34		e897d2ffff		CALL runtime.throw(SB)	
  0x423f39		0f0b			UD2			
func mcommoninit(mp *m) {
  0x423f3b		e830060200		CALL runtime.morestack_noctxt(SB)	
  0x423f40		e91bfeffff		JMP runtime.mcommoninit(SB)		

TEXT runtime.ready(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func ready(gp *g, traceskip int, next bool) {
  0x423f50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423f59		483b6110		CMPQ 0x10(CX), SP	
  0x423f5d		0f866a020000		JBE 0x4241cd		
  0x423f63		4883ec40		SUBQ $0x40, SP		
  0x423f67		48896c2438		MOVQ BP, 0x38(SP)	
  0x423f6c		488d6c2438		LEAQ 0x38(SP), BP	
	if trace.enabled {
  0x423f71		0fb60558f80800		MOVZX runtime.trace+16(SB), AX	
  0x423f78		84c0			TESTL AL, AL			
  0x423f7a		0f85cc000000		JNE 0x42404c			
  0x423f80		488b442448		MOVQ 0x48(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x423f85		8b8890000000		MOVL 0x90(AX), CX	
	_g_ := getg()
  0x423f8b		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	_g_.m.locks++ // disable preemption because it can be holding p in a local var
  0x423f94		488b5a30		MOVQ 0x30(DX), BX	
  0x423f98		ff8300010000		INCL 0x100(BX)		
	if status&^_Gscan != _Gwaiting {
  0x423f9e		81e1ffefffff		ANDL $-0x1001, CX	
  0x423fa4		83f904			CMPL $0x4, CX		
  0x423fa7		0f85bc000000		JNE 0x424069		
  0x423fad		4889542430		MOVQ DX, 0x30(SP)	
	casgstatus(gp, _Gwaiting, _Grunnable)
  0x423fb2		48890424		MOVQ AX, 0(SP)			
  0x423fb6		48b90400000001000000	MOVQ $0x100000004, CX		
  0x423fc0		48894c2408		MOVQ CX, 0x8(SP)		
  0x423fc5		e8b60a0000		CALL runtime.casgstatus(SB)	
  0x423fca		488b442430		MOVQ 0x30(SP), AX		
	runqput(_g_.m.p.ptr(), gp, next)
  0x423fcf		488b4830		MOVQ 0x30(AX), CX		
  0x423fd3		488b89d0000000		MOVQ 0xd0(CX), CX		
  0x423fda		48890c24		MOVQ CX, 0(SP)			
  0x423fde		488b4c2448		MOVQ 0x48(SP), CX		
  0x423fe3		48894c2408		MOVQ CX, 0x8(SP)		
  0x423fe8		0fb64c2458		MOVZX 0x58(SP), CX		
  0x423fed		884c2410		MOVB CL, 0x10(SP)		
  0x423ff1		e85a9e0000		CALL runtime.runqput(SB)	
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
  0x423ff6		8b0574390800		MOVL runtime.sched+80(SB), AX	
  0x423ffc		85c0			TESTL AX, AX			
  0x423ffe		740a			JE 0x42400a			
  0x424000		8b056e390800		MOVL runtime.sched+84(SB), AX	
  0x424006		85c0			TESTL AX, AX			
  0x424008		743b			JE 0x424045			
  0x42400a		488b442430		MOVQ 0x30(SP), AX		
	_g_.m.locks--
  0x42400f		488b4830		MOVQ 0x30(AX), CX	
  0x424013		838100010000ff		ADDL $-0x1, 0x100(CX)	
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in Case we've cleared it in newstack
  0x42401a		488b4830		MOVQ 0x30(AX), CX	
  0x42401e		8b8900010000		MOVL 0x100(CX), CX	
  0x424024		85c9			TESTL CX, CX		
  0x424026		7513			JNE 0x42403b		
  0x424028		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x42402f		84c9			TESTL CL, CL		
  0x424031		7408			JE 0x42403b		
		_g_.stackguard0 = stackPreempt
  0x424033		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x42403b		488b6c2438		MOVQ 0x38(SP), BP	
  0x424040		4883c440		ADDQ $0x40, SP		
  0x424044		c3			RET			
		wakep()
  0x424045		e826330000		CALL runtime.wakep(SB)	
  0x42404a		ebbe			JMP 0x42400a		
  0x42404c		488b442448		MOVQ 0x48(SP), AX	
		traceGoUnpark(gp, traceskip)
  0x424051		48890424		MOVQ AX, 0(SP)			
  0x424055		488b4c2450		MOVQ 0x50(SP), CX		
  0x42405a		48894c2408		MOVQ CX, 0x8(SP)		
  0x42405f		e85c6c0100		CALL runtime.traceGoUnpark(SB)	
  0x424064		e917ffffff		JMP 0x423f80			
	_g_ := getg()
  0x424069		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424072		48894c2428		MOVQ CX, 0x28(SP)	
	return atomic.Load(&gp.atomicstatus)
  0x424077		8b9090000000		MOVL 0x90(AX), DX	
  0x42407d		89542418		MOVL DX, 0x18(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x424081		488b9898000000		MOVQ 0x98(AX), BX		
  0x424088		48895c2420		MOVQ BX, 0x20(SP)		
  0x42408d		e86edaffff		CALL runtime.printlock(SB)	
  0x424092		488d05c96a0400		LEAQ 0x46ac9(IP), AX		
  0x424099		48890424		MOVQ AX, 0(SP)			
  0x42409d		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4240a6		e895e3ffff		CALL runtime.printstring(SB)	
  0x4240ab		488b442448		MOVQ 0x48(SP), AX		
  0x4240b0		48890424		MOVQ AX, 0(SP)			
  0x4240b4		e847e3ffff		CALL runtime.printpointer(SB)	
  0x4240b9		488d05d25d0400		LEAQ 0x45dd2(IP), AX		
  0x4240c0		48890424		MOVQ AX, 0(SP)			
  0x4240c4		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4240cd		e86ee3ffff		CALL runtime.printstring(SB)	
  0x4240d2		488b442420		MOVQ 0x20(SP), AX		
  0x4240d7		48890424		MOVQ AX, 0(SP)			
  0x4240db		e8a0e1ffff		CALL runtime.printint(SB)	
  0x4240e0		488d052d6d0400		LEAQ 0x46d2d(IP), AX		
  0x4240e7		48890424		MOVQ AX, 0(SP)			
  0x4240eb		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4240f4		e847e3ffff		CALL runtime.printstring(SB)	
  0x4240f9		8b442418		MOVL 0x18(SP), AX		
  0x4240fd		89c0			MOVL AX, AX			
  0x4240ff		48890424		MOVQ AX, 0(SP)			
  0x424103		e868e0ffff		CALL runtime.printuint(SB)	
  0x424108		e883dcffff		CALL runtime.printnl(SB)	
  0x42410d		e86edaffff		CALL runtime.printunlock(SB)	
  0x424112		488b442428		MOVQ 0x28(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x424117		8b8890000000		MOVL 0x90(AX), CX	
  0x42411d		894c241c		MOVL CX, 0x1c(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x424121		488b9098000000		MOVQ 0x98(AX), DX		
  0x424128		4889542420		MOVQ DX, 0x20(SP)		
  0x42412d		e8ced9ffff		CALL runtime.printlock(SB)	
  0x424132		488d05196a0400		LEAQ 0x46a19(IP), AX		
  0x424139		48890424		MOVQ AX, 0(SP)			
  0x42413d		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x424146		e8f5e2ffff		CALL runtime.printstring(SB)	
  0x42414b		488b442428		MOVQ 0x28(SP), AX		
  0x424150		48890424		MOVQ AX, 0(SP)			
  0x424154		e8a7e2ffff		CALL runtime.printpointer(SB)	
  0x424159		488d05325d0400		LEAQ 0x45d32(IP), AX		
  0x424160		48890424		MOVQ AX, 0(SP)			
  0x424164		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42416d		e8cee2ffff		CALL runtime.printstring(SB)	
  0x424172		488b442420		MOVQ 0x20(SP), AX		
  0x424177		48890424		MOVQ AX, 0(SP)			
  0x42417b		e800e1ffff		CALL runtime.printint(SB)	
  0x424180		488d057a6c0400		LEAQ 0x46c7a(IP), AX		
  0x424187		48890424		MOVQ AX, 0(SP)			
  0x42418b		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x424194		e8a7e2ffff		CALL runtime.printstring(SB)	
  0x424199		8b44241c		MOVL 0x1c(SP), AX		
  0x42419d		89c0			MOVL AX, AX			
  0x42419f		48890424		MOVQ AX, 0(SP)			
  0x4241a3		e8c8dfffff		CALL runtime.printuint(SB)	
  0x4241a8		e8e3dbffff		CALL runtime.printnl(SB)	
  0x4241ad		e8ced9ffff		CALL runtime.printunlock(SB)	
		throw("bad g->status in ready")
  0x4241b2		488d0539720400		LEAQ 0x47239(IP), AX	
  0x4241b9		48890424		MOVQ AX, 0(SP)		
  0x4241bd		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x4241c6		e805d0ffff		CALL runtime.throw(SB)	
  0x4241cb		0f0b			UD2			
func ready(gp *g, traceskip int, next bool) {
  0x4241cd		e89e030200		CALL runtime.morestack_noctxt(SB)	
  0x4241d2		e979fdffff		JMP runtime.ready(SB)			

TEXT runtime.gcprocs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gcprocs() int32 {
  0x4241e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4241e9		483b6110		CMPQ 0x10(CX), SP	
  0x4241ed		7676			JBE 0x424265		
  0x4241ef		4883ec18		SUBQ $0x18, SP		
  0x4241f3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4241f8		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&sched.lock)
  0x4241fd		488d052c370800		LEAQ runtime.sched+16(SB), AX	
  0x424204		48890424		MOVQ AX, 0(SP)			
  0x424208		e81353feff		CALL runtime.lock(SB)		
	n := gomaxprocs
  0x42420d		8b05cdf60900		MOVL runtime.gomaxprocs(SB), AX	
	if n > ncpu {
  0x424213		8b0dcbf60900		MOVL runtime.ncpu(SB), CX	
  0x424219		39c8			CMPL CX, AX			
  0x42421b		7e44			JLE 0x424261			
	if n > _MaxGcproc {
  0x42421d		83f920			CMPL $0x20, CX		
  0x424220		7e3b			JLE 0x42425d		
  0x424222		b820000000		MOVL $0x20, AX		
	if n > sched.nmidle+1 { // one M is currently running
  0x424227		8b0d13370800		MOVL runtime.sched+32(SB), CX	
  0x42422d		ffc1			INCL CX				
  0x42422f		39c8			CMPL CX, AX			
  0x424231		7e26			JLE 0x424259			
  0x424233		894c240c		MOVL CX, 0xc(SP)		
	unlock(&sched.lock)
  0x424237		488d05f2360800		LEAQ runtime.sched+16(SB), AX	
  0x42423e		48890424		MOVQ AX, 0(SP)			
  0x424242		e87954feff		CALL runtime.unlock(SB)		
	return n
  0x424247		8b44240c		MOVL 0xc(SP), AX	
  0x42424b		89442420		MOVL AX, 0x20(SP)	
  0x42424f		488b6c2410		MOVQ 0x10(SP), BP	
  0x424254		4883c418		ADDQ $0x18, SP		
  0x424258		c3			RET			
  0x424259		89c1			MOVL AX, CX		
	if n > sched.nmidle+1 { // one M is currently running
  0x42425b		ebd6			JMP 0x424233		
  0x42425d		89c8			MOVL CX, AX		
	if n > _MaxGcproc {
  0x42425f		ebc6			JMP 0x424227		
  0x424261		89c1			MOVL AX, CX		
	if n > ncpu {
  0x424263		ebb8			JMP 0x42421d		
func gcprocs() int32 {
  0x424265		e806030200		CALL runtime.morestack_noctxt(SB)	
  0x42426a		e971ffffff		JMP runtime.gcprocs(SB)			

TEXT runtime.needaddgcproc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func needaddgcproc() bool {
  0x424270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424279		483b6110		CMPQ 0x10(CX), SP	
  0x42427d		767e			JBE 0x4242fd		
  0x42427f		4883ec18		SUBQ $0x18, SP		
  0x424283		48896c2410		MOVQ BP, 0x10(SP)	
  0x424288		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&sched.lock)
  0x42428d		488d059c360800		LEAQ runtime.sched+16(SB), AX	
  0x424294		48890424		MOVQ AX, 0(SP)			
  0x424298		e88352feff		CALL runtime.lock(SB)		
	n := gomaxprocs
  0x42429d		8b053df60900		MOVL runtime.gomaxprocs(SB), AX	
	if n > ncpu {
  0x4242a3		8b0d3bf60900		MOVL runtime.ncpu(SB), CX	
  0x4242a9		39c8			CMPL CX, AX			
  0x4242ab		7e4c			JLE 0x4242f9			
	if n > _MaxGcproc {
  0x4242ad		83f920			CMPL $0x20, CX		
  0x4242b0		7e43			JLE 0x4242f5		
  0x4242b2		b820000000		MOVL $0x20, AX		
	n -= sched.nmidle + 1 // one M is currently running
  0x4242b7		89442408		MOVL AX, 0x8(SP)		
  0x4242bb		8b0d7f360800		MOVL runtime.sched+32(SB), CX	
  0x4242c1		894c240c		MOVL CX, 0xc(SP)		
	unlock(&sched.lock)
  0x4242c5		488d1564360800		LEAQ runtime.sched+16(SB), DX	
  0x4242cc		48891424		MOVQ DX, 0(SP)			
  0x4242d0		e8eb53feff		CALL runtime.unlock(SB)		
	return n > 0
  0x4242d5		8b44240c		MOVL 0xc(SP), AX	
	n -= sched.nmidle + 1 // one M is currently running
  0x4242d9		ffc0			INCL AX			
  0x4242db		8b4c2408		MOVL 0x8(SP), CX	
  0x4242df		29c1			SUBL AX, CX		
	return n > 0
  0x4242e1		85c9			TESTL CX, CX		
  0x4242e3		488d442420		LEAQ 0x20(SP), AX	
  0x4242e8		0f9f00			SETG 0(AX)		
  0x4242eb		488b6c2410		MOVQ 0x10(SP), BP	
  0x4242f0		4883c418		ADDQ $0x18, SP		
  0x4242f4		c3			RET			
  0x4242f5		89c8			MOVL CX, AX		
	if n > _MaxGcproc {
  0x4242f7		ebbe			JMP 0x4242b7		
  0x4242f9		89c1			MOVL AX, CX		
	if n > ncpu {
  0x4242fb		ebb0			JMP 0x4242ad		
func needaddgcproc() bool {
  0x4242fd		e86e020200		CALL runtime.morestack_noctxt(SB)	
  0x424302		e969ffffff		JMP runtime.needaddgcproc(SB)		

TEXT runtime.helpgc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func helpgc(nproc int32) {
  0x424310		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424319		483b6110		CMPQ 0x10(CX), SP	
  0x42431d		0f8665010000		JBE 0x424488		
  0x424323		4883ec30		SUBQ $0x30, SP		
  0x424327		48896c2428		MOVQ BP, 0x28(SP)	
  0x42432c		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x424331		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42433a		4889442420		MOVQ AX, 0x20(SP)	
	lock(&sched.lock)
  0x42433f		488d0dea350800		LEAQ runtime.sched+16(SB), CX	
  0x424346		48890c24		MOVQ CX, 0(SP)			
  0x42434a		e8d151feff		CALL runtime.lock(SB)		
func helpgc(nproc int32) {
  0x42434f		b801000000		MOVL $0x1, AX		
  0x424354		31c9			XORL CX, CX		
	for n := int32(1); n < nproc; n++ { // one M is currently running
  0x424356		eb36			JMP 0x42438e		
  0x424358		89442414		MOVL AX, 0x14(SP)	
  0x42435c		48894c2418		MOVQ CX, 0x18(SP)	
		mp.mcache = allp[pos].mcache
  0x424361		488b04cf		MOVQ 0(DI)(CX*8), AX	
  0x424365		488b4048		MOVQ 0x48(AX), AX	
  0x424369		48898360010000		MOVQ AX, 0x160(BX)	
		notewakeup(&mp.park)
  0x424370		488d8348010000		LEAQ 0x148(BX), AX		
  0x424377		48890424		MOVQ AX, 0(SP)			
  0x42437b		e81054feff		CALL runtime.notewakeup(SB)	
  0x424380		8b442414		MOVL 0x14(SP), AX		
	for n := int32(1); n < nproc; n++ { // one M is currently running
  0x424384		ffc0			INCL AX			
  0x424386		488b4c2418		MOVQ 0x18(SP), CX	
		pos++
  0x42438b		48ffc1			INCQ CX			
	for n := int32(1); n < nproc; n++ { // one M is currently running
  0x42438e		8b542438		MOVL 0x38(SP), DX	
  0x424392		39d0			CMPL DX, AX		
  0x424394		0f8da4000000		JGE 0x42443e		
		if allp[pos].mcache == _g_.m.mcache {
  0x42439a		488b1d17330800		MOVQ runtime.allp+8(SB), BX	
  0x4243a1		488b3508330800		MOVQ runtime.allp(SB), SI	
  0x4243a8		4839d9			CMPQ BX, CX			
  0x4243ab		0f83d0000000		JAE 0x424481			
  0x4243b1		488b1cce		MOVQ 0(SI)(CX*8), BX		
  0x4243b5		488b742420		MOVQ 0x20(SP), SI		
  0x4243ba		488b7e30		MOVQ 0x30(SI), DI		
  0x4243be		488b5b48		MOVQ 0x48(BX), BX		
  0x4243c2		488bbf60010000		MOVQ 0x160(DI), DI		
  0x4243c9		4839fb			CMPQ DI, BX			
  0x4243cc		7503			JNE 0x4243d1			
			pos++
  0x4243ce		48ffc1			INCQ CX			
	mp := sched.midle.ptr()
  0x4243d1		488b1d60350800		MOVQ runtime.sched+24(SB), BX	
	if mp != nil {
  0x4243d8		4885db			TESTQ BX, BX		
  0x4243db		7418			JE 0x4243f5		
		sched.midle = mp.schedlink
  0x4243dd		488bbb58010000		MOVQ 0x158(BX), DI		
  0x4243e4		48893d4d350800		MOVQ DI, runtime.sched+24(SB)	
		sched.nmidle--
  0x4243eb		83054e350800ff		ADDL $-0x1, runtime.sched+32(SB)	
	if mp != nil {
  0x4243f2		4885db			TESTQ BX, BX		
		if mp == nil {
  0x4243f5		746f			JE 0x424466		
		mp.helpgc = n
  0x4243f7		898310010000		MOVL AX, 0x110(BX)	
		mp.p.set(allp[pos])
  0x4243fd		488b3dac320800		MOVQ runtime.allp(SB), DI	
  0x424404		4c8b05ad320800		MOVQ runtime.allp+8(SB), R8	
  0x42440b		4c39c1			CMPQ R8, CX			
  0x42440e		734f			JAE 0x42445f			
  0x424410		4c8d83d0000000		LEAQ 0xd0(BX), R8		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x424417		418400			TESTB AL, 0(R8)		
		mp.p.set(allp[pos])
  0x42441a		488b3ccf		MOVQ 0(DI)(CX*8), DI	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42441e		4889bbd0000000		MOVQ DI, 0xd0(BX)	
		mp.mcache = allp[pos].mcache
  0x424425		488b3d84320800		MOVQ runtime.allp(SB), DI	
  0x42442c		4c8b0585320800		MOVQ runtime.allp+8(SB), R8	
  0x424433		4c39c1			CMPQ R8, CX			
  0x424436		0f821cffffff		JB 0x424358			
  0x42443c		eb1a			JMP 0x424458			
	unlock(&sched.lock)
  0x42443e		488d05eb340800		LEAQ runtime.sched+16(SB), AX	
  0x424445		48890424		MOVQ AX, 0(SP)			
  0x424449		e87252feff		CALL runtime.unlock(SB)		
}
  0x42444e		488b6c2428		MOVQ 0x28(SP), BP	
  0x424453		4883c430		ADDQ $0x30, SP		
  0x424457		c3			RET			
		mp.mcache = allp[pos].mcache
  0x424458		e8e3b5ffff		CALL runtime.panicindex(SB)	
  0x42445d		0f0b			UD2				
		mp.p.set(allp[pos])
  0x42445f		e8dcb5ffff		CALL runtime.panicindex(SB)	
  0x424464		0f0b			UD2				
			throw("gcprocs inconsistency")
  0x424466		488d055b6e0400		LEAQ 0x46e5b(IP), AX	
  0x42446d		48890424		MOVQ AX, 0(SP)		
  0x424471		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42447a		e851cdffff		CALL runtime.throw(SB)	
  0x42447f		0f0b			UD2			
		if allp[pos].mcache == _g_.m.mcache {
  0x424481		e8bab5ffff		CALL runtime.panicindex(SB)	
  0x424486		0f0b			UD2				
func helpgc(nproc int32) {
  0x424488		e8e3000200		CALL runtime.morestack_noctxt(SB)	
  0x42448d		e97efeffff		JMP runtime.helpgc(SB)			

TEXT runtime.freezetheworld(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func freezetheworld() {
  0x4244a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4244a9		483b6110		CMPQ 0x10(CX), SP	
  0x4244ad		0f868b000000		JBE 0x42453e		
  0x4244b3		4883ec18		SUBQ $0x18, SP		
  0x4244b7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4244bc		488d6c2410		LEAQ 0x10(SP), BP	
	atomic.Store(&freezing, 1)
  0x4244c1		b801000000		MOVL $0x1, AX			
  0x4244c6		488d0d03f40900		LEAQ runtime.freezing(SB), CX	
  0x4244cd		8701			XCHGL AX, 0(CX)			
  0x4244cf		31c0			XORL AX, AX			
	for i := 0; i < 5; i++ {
  0x4244d1		eb14			JMP 0x4244e7		
		usleep(1000)
  0x4244d3		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x4244da		e8d1330200		CALL runtime.usleep(SB)	
  0x4244df		488b442408		MOVQ 0x8(SP), AX	
	for i := 0; i < 5; i++ {
  0x4244e4		48ffc0			INCQ AX			
  0x4244e7		4883f805		CMPQ $0x5, AX		
  0x4244eb		7d2a			JGE 0x424517		
  0x4244ed		4889442408		MOVQ AX, 0x8(SP)	
		sched.stopwait = freezeStopWait
  0x4244f2		c70500350800ffffff7f	MOVL $0x7fffffff, runtime.sched+220(SB)	
		atomic.Store(&sched.gcwaiting, 1)
  0x4244fc		b801000000		MOVL $0x1, AX			
  0x424501		488d0df0340800		LEAQ runtime.sched+216(SB), CX	
  0x424508		8701			XCHGL AX, 0(CX)			
		if !preemptall() {
  0x42450a		e8618b0000		CALL runtime.preemptall(SB)	
  0x42450f		0fb60424		MOVZX 0(SP), AX			
  0x424513		84c0			TESTL AL, AL			
  0x424515		75bc			JNE 0x4244d3			
	usleep(1000)
  0x424517		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x42451e		e88d330200		CALL runtime.usleep(SB)	
	preemptall()
  0x424523		e8488b0000		CALL runtime.preemptall(SB)	
	usleep(1000)
  0x424528		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x42452f		e87c330200		CALL runtime.usleep(SB)	
}
  0x424534		488b6c2410		MOVQ 0x10(SP), BP	
  0x424539		4883c418		ADDQ $0x18, SP		
  0x42453d		c3			RET			
func freezetheworld() {
  0x42453e		e82d000200		CALL runtime.morestack_noctxt(SB)	
  0x424543		e958ffffff		JMP runtime.freezetheworld(SB)		

TEXT runtime.casfrom_Gscanstatus(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func casfrom_Gscanstatus(gp *g, oldval, newval uint32) {
  0x424550		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424559		483b6110		CMPQ 0x10(CX), SP	
  0x42455d		0f8631040000		JBE 0x424994		
  0x424563		4883ec40		SUBQ $0x40, SP		
  0x424567		48896c2438		MOVQ BP, 0x38(SP)	
  0x42456c		488d6c2438		LEAQ 0x38(SP), BP	
  0x424571		8b442450		MOVL 0x50(SP), AX	
	case _Gscanrunnable,
  0x424575		8d88ffefffff		LEAL 0xffffefff(AX), CX	
  0x42457b		83f903			CMPL $0x3, CX		
  0x42457e		0f8725020000		JA 0x4247a9		
  0x424584		89c1			MOVL AX, CX		
		if newval == oldval&^_Gscan {
  0x424586		25ffefffff		ANDL $-0x1001, AX	
  0x42458b		8b542454		MOVL 0x54(SP), DX	
  0x42458f		39c2			CMPL AX, DX		
  0x424591		7522			JNE 0x4245b5		
  0x424593		89c8			MOVL CX, AX		
  0x424595		488b5c2448		MOVQ 0x48(SP), BX	
			success = atomic.Cas(&gp.atomicstatus, oldval, newval)
  0x42459a		f00fb19390000000	LOCK CMPXCHGL DX, 0x90(BX)	
  0x4245a2		400f94c6		SETE SI				
	if !success {
  0x4245a6		4084f6			TESTL SI, SI		
  0x4245a9		7413			JE 0x4245be		
  0x4245ab		488b6c2438		MOVQ 0x38(SP), BP	
  0x4245b0		4883c440		ADDQ $0x40, SP		
  0x4245b4		c3			RET			
  0x4245b5		488b5c2448		MOVQ 0x48(SP), BX	
  0x4245ba		31f6			XORL SI, SI		
		if newval == oldval&^_Gscan {
  0x4245bc		ebe8			JMP 0x4245a6		
		print("runtime: casfrom_Gscanstatus failed gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")
  0x4245be		e83dd5ffff		CALL runtime.printlock(SB)	
  0x4245c3		488d05d88b0400		LEAQ 0x48bd8(IP), AX		
  0x4245ca		48890424		MOVQ AX, 0(SP)			
  0x4245ce		48c744240827000000	MOVQ $0x27, 0x8(SP)		
  0x4245d7		e864deffff		CALL runtime.printstring(SB)	
  0x4245dc		488b442448		MOVQ 0x48(SP), AX		
  0x4245e1		48890424		MOVQ AX, 0(SP)			
  0x4245e5		e816deffff		CALL runtime.printpointer(SB)	
  0x4245ea		488d05e75a0400		LEAQ 0x45ae7(IP), AX		
  0x4245f1		48890424		MOVQ AX, 0(SP)			
  0x4245f5		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4245fe		e83ddeffff		CALL runtime.printstring(SB)	
  0x424603		8b442450		MOVL 0x50(SP), AX		
  0x424607		48890424		MOVQ AX, 0(SP)			
  0x42460b		e8e0dcffff		CALL runtime.printhex(SB)	
  0x424610		488d05b85a0400		LEAQ 0x45ab8(IP), AX		
  0x424617		48890424		MOVQ AX, 0(SP)			
  0x42461b		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x424624		e817deffff		CALL runtime.printstring(SB)	
  0x424629		8b442454		MOVL 0x54(SP), AX		
  0x42462d		48890424		MOVQ AX, 0(SP)			
  0x424631		e8badcffff		CALL runtime.printhex(SB)	
  0x424636		e855d7ffff		CALL runtime.printnl(SB)	
  0x42463b		e840d5ffff		CALL runtime.printunlock(SB)	
	_g_ := getg()
  0x424640		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x424649		4889442428		MOVQ AX, 0x28(SP)	
  0x42464e		488b4c2448		MOVQ 0x48(SP), CX	
	return atomic.Load(&gp.atomicstatus)
  0x424653		8b9190000000		MOVL 0x90(CX), DX	
  0x424659		8954241c		MOVL DX, 0x1c(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x42465d		488b9998000000		MOVQ 0x98(CX), BX		
  0x424664		48895c2420		MOVQ BX, 0x20(SP)		
  0x424669		e892d4ffff		CALL runtime.printlock(SB)	
  0x42466e		488d05ed640400		LEAQ 0x464ed(IP), AX		
  0x424675		48890424		MOVQ AX, 0(SP)			
  0x424679		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x424682		e8b9ddffff		CALL runtime.printstring(SB)	
  0x424687		488b442448		MOVQ 0x48(SP), AX		
  0x42468c		48890424		MOVQ AX, 0(SP)			
  0x424690		e86bddffff		CALL runtime.printpointer(SB)	
  0x424695		488d05f6570400		LEAQ 0x457f6(IP), AX		
  0x42469c		48890424		MOVQ AX, 0(SP)			
  0x4246a0		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4246a9		e892ddffff		CALL runtime.printstring(SB)	
  0x4246ae		488b442420		MOVQ 0x20(SP), AX		
  0x4246b3		48890424		MOVQ AX, 0(SP)			
  0x4246b7		e8c4dbffff		CALL runtime.printint(SB)	
  0x4246bc		488d0551670400		LEAQ 0x46751(IP), AX		
  0x4246c3		48890424		MOVQ AX, 0(SP)			
  0x4246c7		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4246d0		e86bddffff		CALL runtime.printstring(SB)	
  0x4246d5		8b44241c		MOVL 0x1c(SP), AX		
  0x4246d9		89c0			MOVL AX, AX			
  0x4246db		48890424		MOVQ AX, 0(SP)			
  0x4246df		e88cdaffff		CALL runtime.printuint(SB)	
  0x4246e4		e8a7d6ffff		CALL runtime.printnl(SB)	
  0x4246e9		e892d4ffff		CALL runtime.printunlock(SB)	
  0x4246ee		488b442428		MOVQ 0x28(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x4246f3		8b8890000000		MOVL 0x90(AX), CX	
  0x4246f9		894c2410		MOVL CX, 0x10(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x4246fd		488b9098000000		MOVQ 0x98(AX), DX		
  0x424704		4889542420		MOVQ DX, 0x20(SP)		
  0x424709		e8f2d3ffff		CALL runtime.printlock(SB)	
  0x42470e		488d053d640400		LEAQ 0x4643d(IP), AX		
  0x424715		48890424		MOVQ AX, 0(SP)			
  0x424719		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x424722		e819ddffff		CALL runtime.printstring(SB)	
  0x424727		488b442428		MOVQ 0x28(SP), AX		
  0x42472c		48890424		MOVQ AX, 0(SP)			
  0x424730		e8cbdcffff		CALL runtime.printpointer(SB)	
  0x424735		488d0556570400		LEAQ 0x45756(IP), AX		
  0x42473c		48890424		MOVQ AX, 0(SP)			
  0x424740		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x424749		e8f2dcffff		CALL runtime.printstring(SB)	
  0x42474e		488b442420		MOVQ 0x20(SP), AX		
  0x424753		48890424		MOVQ AX, 0(SP)			
  0x424757		e824dbffff		CALL runtime.printint(SB)	
  0x42475c		488d059e660400		LEAQ 0x4669e(IP), AX		
  0x424763		48890424		MOVQ AX, 0(SP)			
  0x424767		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x424770		e8cbdcffff		CALL runtime.printstring(SB)	
  0x424775		8b442410		MOVL 0x10(SP), AX		
  0x424779		89c0			MOVL AX, AX			
  0x42477b		48890424		MOVQ AX, 0(SP)			
  0x42477f		e8ecd9ffff		CALL runtime.printuint(SB)	
  0x424784		e807d6ffff		CALL runtime.printnl(SB)	
  0x424789		e8f2d3ffff		CALL runtime.printunlock(SB)	
		throw("casfrom_Gscanstatus: gp->status is not in scan state")
  0x42478e		488d0526930400		LEAQ 0x49326(IP), AX	
  0x424795		48890424		MOVQ AX, 0(SP)		
  0x424799		48c744240834000000	MOVQ $0x34, 0x8(SP)	
  0x4247a2		e829caffff		CALL runtime.throw(SB)	
  0x4247a7		0f0b			UD2			
		print("runtime: casfrom_Gscanstatus bad oldval gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")
  0x4247a9		e852d3ffff		CALL runtime.printlock(SB)	
  0x4247ae		488d05c08d0400		LEAQ 0x48dc0(IP), AX		
  0x4247b5		48890424		MOVQ AX, 0(SP)			
  0x4247b9		48c74424082b000000	MOVQ $0x2b, 0x8(SP)		
  0x4247c2		e879dcffff		CALL runtime.printstring(SB)	
  0x4247c7		488b442448		MOVQ 0x48(SP), AX		
  0x4247cc		48890424		MOVQ AX, 0(SP)			
  0x4247d0		e82bdcffff		CALL runtime.printpointer(SB)	
  0x4247d5		488d05fc580400		LEAQ 0x458fc(IP), AX		
  0x4247dc		48890424		MOVQ AX, 0(SP)			
  0x4247e0		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4247e9		e852dcffff		CALL runtime.printstring(SB)	
  0x4247ee		8b442450		MOVL 0x50(SP), AX		
  0x4247f2		48890424		MOVQ AX, 0(SP)			
  0x4247f6		e8f5daffff		CALL runtime.printhex(SB)	
  0x4247fb		488d05cd580400		LEAQ 0x458cd(IP), AX		
  0x424802		48890424		MOVQ AX, 0(SP)			
  0x424806		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42480f		e82cdcffff		CALL runtime.printstring(SB)	
  0x424814		8b442454		MOVL 0x54(SP), AX		
  0x424818		48890424		MOVQ AX, 0(SP)			
  0x42481c		e8cfdaffff		CALL runtime.printhex(SB)	
  0x424821		e86ad5ffff		CALL runtime.printnl(SB)	
  0x424826		e855d3ffff		CALL runtime.printunlock(SB)	
	_g_ := getg()
  0x42482b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x424834		4889442430		MOVQ AX, 0x30(SP)	
  0x424839		488b4c2448		MOVQ 0x48(SP), CX	
	return atomic.Load(&gp.atomicstatus)
  0x42483e		8b9190000000		MOVL 0x90(CX), DX	
  0x424844		89542418		MOVL DX, 0x18(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x424848		488b9998000000		MOVQ 0x98(CX), BX		
  0x42484f		48895c2420		MOVQ BX, 0x20(SP)		
  0x424854		e8a7d2ffff		CALL runtime.printlock(SB)	
  0x424859		488d0502630400		LEAQ 0x46302(IP), AX		
  0x424860		48890424		MOVQ AX, 0(SP)			
  0x424864		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x42486d		e8cedbffff		CALL runtime.printstring(SB)	
  0x424872		488b442448		MOVQ 0x48(SP), AX		
  0x424877		48890424		MOVQ AX, 0(SP)			
  0x42487b		e880dbffff		CALL runtime.printpointer(SB)	
  0x424880		488d050b560400		LEAQ 0x4560b(IP), AX		
  0x424887		48890424		MOVQ AX, 0(SP)			
  0x42488b		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x424894		e8a7dbffff		CALL runtime.printstring(SB)	
  0x424899		488b442420		MOVQ 0x20(SP), AX		
  0x42489e		48890424		MOVQ AX, 0(SP)			
  0x4248a2		e8d9d9ffff		CALL runtime.printint(SB)	
  0x4248a7		488d0566650400		LEAQ 0x46566(IP), AX		
  0x4248ae		48890424		MOVQ AX, 0(SP)			
  0x4248b2		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4248bb		e880dbffff		CALL runtime.printstring(SB)	
  0x4248c0		8b442418		MOVL 0x18(SP), AX		
  0x4248c4		89c0			MOVL AX, AX			
  0x4248c6		48890424		MOVQ AX, 0(SP)			
  0x4248ca		e8a1d8ffff		CALL runtime.printuint(SB)	
  0x4248cf		e8bcd4ffff		CALL runtime.printnl(SB)	
  0x4248d4		e8a7d2ffff		CALL runtime.printunlock(SB)	
  0x4248d9		488b442430		MOVQ 0x30(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x4248de		8b8890000000		MOVL 0x90(AX), CX	
  0x4248e4		894c2414		MOVL CX, 0x14(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x4248e8		488b9098000000		MOVQ 0x98(AX), DX		
  0x4248ef		4889542420		MOVQ DX, 0x20(SP)		
  0x4248f4		e807d2ffff		CALL runtime.printlock(SB)	
  0x4248f9		488d0552620400		LEAQ 0x46252(IP), AX		
  0x424900		48890424		MOVQ AX, 0(SP)			
  0x424904		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x42490d		e82edbffff		CALL runtime.printstring(SB)	
  0x424912		488b442430		MOVQ 0x30(SP), AX		
  0x424917		48890424		MOVQ AX, 0(SP)			
  0x42491b		e8e0daffff		CALL runtime.printpointer(SB)	
  0x424920		488d056b550400		LEAQ 0x4556b(IP), AX		
  0x424927		48890424		MOVQ AX, 0(SP)			
  0x42492b		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x424934		e807dbffff		CALL runtime.printstring(SB)	
  0x424939		488b442420		MOVQ 0x20(SP), AX		
  0x42493e		48890424		MOVQ AX, 0(SP)			
  0x424942		e839d9ffff		CALL runtime.printint(SB)	
  0x424947		488d05b3640400		LEAQ 0x464b3(IP), AX		
  0x42494e		48890424		MOVQ AX, 0(SP)			
  0x424952		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x42495b		e8e0daffff		CALL runtime.printstring(SB)	
  0x424960		8b442414		MOVL 0x14(SP), AX		
  0x424964		89c0			MOVL AX, AX			
  0x424966		48890424		MOVQ AX, 0(SP)			
  0x42496a		e801d8ffff		CALL runtime.printuint(SB)	
  0x42496f		e81cd4ffff		CALL runtime.printnl(SB)	
  0x424974		e807d2ffff		CALL runtime.printunlock(SB)	
		throw("casfrom_Gscanstatus:top gp->status is not in scan state")
  0x424979		488d057a920400		LEAQ 0x4927a(IP), AX	
  0x424980		48890424		MOVQ AX, 0(SP)		
  0x424984		48c744240837000000	MOVQ $0x37, 0x8(SP)	
  0x42498d		e83ec8ffff		CALL runtime.throw(SB)	
  0x424992		0f0b			UD2			
func casfrom_Gscanstatus(gp *g, oldval, newval uint32) {
  0x424994		e8d7fb0100		CALL runtime.morestack_noctxt(SB)	
  0x424999		e9b2fbffff		JMP runtime.casfrom_Gscanstatus(SB)	

TEXT runtime.castogscanstatus(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func castogscanstatus(gp *g, oldval, newval uint32) bool {
  0x4249a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4249a9		483b6110		CMPQ 0x10(CX), SP	
  0x4249ad		0f86bf000000		JBE 0x424a72		
  0x4249b3		4883ec18		SUBQ $0x18, SP		
  0x4249b7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4249bc		488d6c2410		LEAQ 0x10(SP), BP	
  0x4249c1		8b442428		MOVL 0x28(SP), AX	
	case _Grunnable,
  0x4249c5		8d48ff			LEAL -0x1(AX), CX	
  0x4249c8		83f903			CMPL $0x3, CX		
  0x4249cb		772f			JA 0x4249fc		
  0x4249cd		89c1			MOVL AX, CX		
		if newval == oldval|_Gscan {
  0x4249cf		0d00100000		ORL $0x1000, AX		
  0x4249d4		8b54242c		MOVL 0x2c(SP), DX	
  0x4249d8		39c2			CMPL AX, DX		
  0x4249da		7520			JNE 0x4249fc		
  0x4249dc		89c8			MOVL CX, AX		
  0x4249de		488b5c2420		MOVQ 0x20(SP), BX	
			return atomic.Cas(&gp.atomicstatus, oldval, newval)
  0x4249e3		f00fb19390000000	LOCK CMPXCHGL DX, 0x90(BX)	
  0x4249eb		0f94c1			SETE CL				
  0x4249ee		884c2430		MOVB CL, 0x30(SP)		
  0x4249f2		488b6c2410		MOVQ 0x10(SP), BP		
  0x4249f7		4883c418		ADDQ $0x18, SP			
  0x4249fb		c3			RET				
	print("runtime: castogscanstatus oldval=", hex(oldval), " newval=", hex(newval), "\n")
  0x4249fc		e8ffd0ffff		CALL runtime.printlock(SB)	
  0x424a01		488d0542800400		LEAQ 0x48042(IP), AX		
  0x424a08		48890424		MOVQ AX, 0(SP)			
  0x424a0c		48c744240821000000	MOVQ $0x21, 0x8(SP)		
  0x424a15		e826daffff		CALL runtime.printstring(SB)	
  0x424a1a		8b442428		MOVL 0x28(SP), AX		
  0x424a1e		48890424		MOVQ AX, 0(SP)			
  0x424a22		e8c9d8ffff		CALL runtime.printhex(SB)	
  0x424a27		488d0591550400		LEAQ 0x45591(IP), AX		
  0x424a2e		48890424		MOVQ AX, 0(SP)			
  0x424a32		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x424a3b		e800daffff		CALL runtime.printstring(SB)	
  0x424a40		8b44242c		MOVL 0x2c(SP), AX		
  0x424a44		48890424		MOVQ AX, 0(SP)			
  0x424a48		e8a3d8ffff		CALL runtime.printhex(SB)	
  0x424a4d		e83ed3ffff		CALL runtime.printnl(SB)	
  0x424a52		e829d1ffff		CALL runtime.printunlock(SB)	
	throw("castogscanstatus")
  0x424a57		488d0564600400		LEAQ 0x46064(IP), AX	
  0x424a5e		48890424		MOVQ AX, 0(SP)		
  0x424a62		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x424a6b		e860c7ffff		CALL runtime.throw(SB)	
  0x424a70		0f0b			UD2			
func castogscanstatus(gp *g, oldval, newval uint32) bool {
  0x424a72		e8f9fa0100		CALL runtime.morestack_noctxt(SB)	
  0x424a77		e924ffffff		JMP runtime.castogscanstatus(SB)	

TEXT runtime.casgstatus(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func casgstatus(gp *g, oldval, newval uint32) {
  0x424a80		4883ec58		SUBQ $0x58, SP		
  0x424a84		48896c2450		MOVQ BP, 0x50(SP)	
  0x424a89		488d6c2450		LEAQ 0x50(SP), BP	
  0x424a8e		8b442468		MOVL 0x68(SP), AX	
	if (oldval&_Gscan != 0) || (newval&_Gscan != 0) || oldval == newval {
  0x424a92		0fbae00c		BTL $0xc, AX		
  0x424a96		0f83b9010000		JAE 0x424c55		
		systemstack(func() {
  0x424a9c		488d0d8de80100		LEAQ runtime.casgstatus.func1(SB), CX	
  0x424aa3		48894c2428		MOVQ CX, 0x28(SP)			
  0x424aa8		89442430		MOVL AX, 0x30(SP)			
  0x424aac		8b4c246c		MOVL 0x6c(SP), CX			
  0x424ab0		894c2434		MOVL CX, 0x34(SP)			
  0x424ab4		488d542428		LEAQ 0x28(SP), DX			
  0x424ab9		48891424		MOVQ DX, 0(SP)				
  0x424abd		e85ef90100		CALL runtime.systemstack(SB)		
  0x424ac2		8b442468		MOVL 0x68(SP), AX			
	if oldval == _Grunning && gp.gcscanvalid {
  0x424ac6		83f802			CMPL $0x2, AX		
  0x424ac9		0f857c010000		JNE 0x424c4b		
  0x424acf		488b4c2460		MOVQ 0x60(SP), CX	
  0x424ad4		0fb691c4000000		MOVZX 0xc4(CX), DX	
  0x424adb		84d2			TESTL DL, DL		
  0x424add		0f852f010000		JNE 0x424c12		
  0x424ae3		31d2			XORL DX, DX		
  0x424ae5		31db			XORL BX, BX		
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x424ae7		eb4c			JMP 0x424b35		
  0x424ae9		4889442408		MOVQ AX, 0x8(SP)	
				procyield(1)
  0x424aee		c7042401000000		MOVL $0x1, 0(SP)		
  0x424af5		e876100200		CALL runtime.procyield(SB)	
  0x424afa		488b442408		MOVQ 0x8(SP), AX		
			for x := 0; x < 10 && gp.atomicstatus != oldval; x++ {
  0x424aff		48ffc0			INCQ AX			
  0x424b02		488b4c2410		MOVQ 0x10(SP), CX	
  0x424b07		4883f80a		CMPQ $0xa, AX		
  0x424b0b		7d7e			JGE 0x424b8b		
  0x424b0d		488b542460		MOVQ 0x60(SP), DX	
  0x424b12		8b9a90000000		MOVL 0x90(DX), BX	
  0x424b18		8b742468		MOVL 0x68(SP), SI	
  0x424b1c		39de			CMPL BX, SI		
  0x424b1e		75c9			JNE 0x424ae9		
  0x424b20		488b7c2418		MOVQ 0x18(SP), DI	
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x424b25		48ffc7			INCQ DI				
  0x424b28		89f0			MOVL SI, AX			
  0x424b2a		4889fa			MOVQ DI, DX			
  0x424b2d		4889cb			MOVQ CX, BX			
  0x424b30		488b4c2460		MOVQ 0x60(SP), CX		
  0x424b35		8b74246c		MOVL 0x6c(SP), SI		
  0x424b39		f00fb1b190000000	LOCK CMPXCHGL SI, 0x90(CX)	
  0x424b41		400f94c7		SETE DI				
  0x424b45		4084ff			TESTL DI, DI			
  0x424b48		0f85ae000000		JNE 0x424bfc			
  0x424b4e		4889542418		MOVQ DX, 0x18(SP)		
  0x424b53		8b442468		MOVL 0x68(SP), AX		
		if oldval == _Gwaiting && gp.atomicstatus == _Grunnable {
  0x424b57		83f804			CMPL $0x4, AX		
  0x424b5a		750b			JNE 0x424b67		
  0x424b5c		8bb990000000		MOVL 0x90(CX), DI	
  0x424b62		83ff01			CMPL $0x1, DI		
  0x424b65		7464			JE 0x424bcb		
		if i == 0 {
  0x424b67		4885d2			TESTQ DX, DX		
  0x424b6a		744d			JE 0x424bb9		
  0x424b6c		48895c2410		MOVQ BX, 0x10(SP)	
		if nanotime() < nextYield {
  0x424b71		e8ba2e0200		CALL runtime.nanotime(SB)	
  0x424b76		488b0424		MOVQ 0(SP), AX			
  0x424b7a		488b4c2410		MOVQ 0x10(SP), CX		
  0x424b7f		4839c8			CMPQ CX, AX			
  0x424b82		7d12			JGE 0x424b96			
  0x424b84		31c0			XORL AX, AX			
			for x := 0; x < 10 && gp.atomicstatus != oldval; x++ {
  0x424b86		e97cffffff		JMP 0x424b07		
  0x424b8b		488b542460		MOVQ 0x60(SP), DX	
  0x424b90		8b742468		MOVL 0x68(SP), SI	
  0x424b94		eb8a			JMP 0x424b20		
			osyield()
  0x424b96		e8b5330200		CALL runtime.osyield(SB)	
			nextYield = nanotime() + yieldDelay/2
  0x424b9b		e8902e0200		CALL runtime.nanotime(SB)	
  0x424ba0		488b0424		MOVQ 0(SP), AX			
  0x424ba4		488d88c4090000		LEAQ 0x9c4(AX), CX		
  0x424bab		488b542460		MOVQ 0x60(SP), DX		
  0x424bb0		8b742468		MOVL 0x68(SP), SI		
  0x424bb4		e967ffffff		JMP 0x424b20			
			nextYield = nanotime() + yieldDelay
  0x424bb9		e8722e0200		CALL runtime.nanotime(SB)	
  0x424bbe		488b0424		MOVQ 0(SP), AX			
  0x424bc2		488d9888130000		LEAQ 0x1388(AX), BX		
  0x424bc9		eba1			JMP 0x424b6c			
  0x424bcb		48895c2420		MOVQ BX, 0x20(SP)		
			systemstack(func() {
  0x424bd0		488d0501940400		LEAQ 0x49401(IP), AX		
  0x424bd7		48890424		MOVQ AX, 0(SP)			
  0x424bdb		e840f80100		CALL runtime.systemstack(SB)	
  0x424be0		8b442468		MOVL 0x68(SP), AX		
  0x424be4		488b4c2460		MOVQ 0x60(SP), CX		
  0x424be9		488b542418		MOVQ 0x18(SP), DX		
  0x424bee		488b5c2420		MOVQ 0x20(SP), BX		
  0x424bf3		8b74246c		MOVL 0x6c(SP), SI		
  0x424bf7		e96bffffff		JMP 0x424b67			
	if newval == _Grunning {
  0x424bfc		83fe02			CMPL $0x2, SI		
  0x424bff		7507			JNE 0x424c08		
		gp.gcscanvalid = false
  0x424c01		c681c400000000		MOVB $0x0, 0xc4(CX)	
  0x424c08		488b6c2450		MOVQ 0x50(SP), BP	
  0x424c0d		4883c458		ADDQ $0x58, SP		
  0x424c11		c3			RET			
		systemstack(func() {
  0x424c12		488d15d7e70100		LEAQ runtime.casgstatus.func2(SB), DX	
  0x424c19		4889542438		MOVQ DX, 0x38(SP)			
  0x424c1e		89442440		MOVL AX, 0x40(SP)			
  0x424c22		8b54246c		MOVL 0x6c(SP), DX			
  0x424c26		89542444		MOVL DX, 0x44(SP)			
  0x424c2a		48894c2448		MOVQ CX, 0x48(SP)			
  0x424c2f		488d5c2438		LEAQ 0x38(SP), BX			
  0x424c34		48891c24		MOVQ BX, 0(SP)				
  0x424c38		e8e3f70100		CALL runtime.systemstack(SB)		
	if oldval == _Grunning && gp.gcscanvalid {
  0x424c3d		8b442468		MOVL 0x68(SP), AX	
  0x424c41		488b4c2460		MOVQ 0x60(SP), CX	
		systemstack(func() {
  0x424c46		e998feffff		JMP 0x424ae3		
  0x424c4b		488b4c2460		MOVQ 0x60(SP), CX	
	if oldval == _Grunning && gp.gcscanvalid {
  0x424c50		e98efeffff		JMP 0x424ae3		
  0x424c55		8b4c246c		MOVL 0x6c(SP), CX	
	if (oldval&_Gscan != 0) || (newval&_Gscan != 0) || oldval == newval {
  0x424c59		0fbae10c		BTL $0xc, CX		
  0x424c5d		0f8239feffff		JB 0x424a9c		
  0x424c63		39c1			CMPL AX, CX		
  0x424c65		0f8431feffff		JE 0x424a9c		
  0x424c6b		e952feffff		JMP 0x424ac2		

TEXT runtime.scang(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func scang(gp *g, gcw *gcWork) {
  0x424c70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424c79		483b6110		CMPQ 0x10(CX), SP	
  0x424c7d		0f867a030000		JBE 0x424ffd		
  0x424c83		4883ec48		SUBQ $0x48, SP		
  0x424c87		48896c2440		MOVQ BP, 0x40(SP)	
  0x424c8c		488d6c2440		LEAQ 0x40(SP), BP	
  0x424c91		488b442450		MOVQ 0x50(SP), AX	
	gp.gcscandone = false
  0x424c96		c680c300000000		MOVB $0x0, 0xc3(AX)	
func scang(gp *g, gcw *gcWork) {
  0x424c9d		31c9			XORL CX, CX		
  0x424c9f		31d2			XORL DX, DX		
	for i := 0; !gp.gcscandone; i++ {
  0x424ca1		eb11			JMP 0x424cb4		
  0x424ca3		488b5c2428		MOVQ 0x28(SP), BX	
  0x424ca8		488d4b01		LEAQ 0x1(BX), CX	
  0x424cac		4889c2			MOVQ AX, DX		
  0x424caf		488b442450		MOVQ 0x50(SP), AX	
  0x424cb4		0fb698c3000000		MOVZX 0xc3(AX), BX	
  0x424cbb		84db			TESTL BL, BL		
  0x424cbd		0f857a010000		JNE 0x424e3d		
  0x424cc3		48894c2428		MOVQ CX, 0x28(SP)	
	return atomic.Load(&gp.atomicstatus)
  0x424cc8		8b9890000000		MOVL 0x90(AX), BX	
		switch s := readgstatus(gp); s {
  0x424cce		83fb04			CMPL $0x4, BX		
  0x424cd1		0f879d010000		JA 0x424e74		
  0x424cd7		4889542420		MOVQ DX, 0x20(SP)	
		case _Grunnable, _Gsyscall, _Gwaiting:
  0x424cdc		83fb01			CMPL $0x1, BX		
  0x424cdf		0f840b010000		JE 0x424df0		
		case _Grunning:
  0x424ce5		83fb02			CMPL $0x2, BX		
  0x424ce8		0f85f6000000		JNE 0x424de4		
			if gp.preemptscan && gp.preempt && gp.stackguard0 == stackPreempt {
  0x424cee		0fb698c2000000		MOVZX 0xc2(AX), BX	
  0x424cf5		84db			TESTL BL, BL		
  0x424cf7		7476			JE 0x424d6f		
  0x424cf9		0fb698c0000000		MOVZX 0xc0(AX), BX	
  0x424d00		84db			TESTL BL, BL		
  0x424d02		746b			JE 0x424d6f		
  0x424d04		488b5810		MOVQ 0x10(AX), BX	
  0x424d08		4881fbdefaffff		CMPQ $-0x522, BX	
  0x424d0f		755e			JNE 0x424d6f		
		if i == 0 {
  0x424d11		4885c9			TESTQ CX, CX		
  0x424d14		7447			JE 0x424d5d		
  0x424d16		4889542430		MOVQ DX, 0x30(SP)	
		if nanotime() < nextYield {
  0x424d1b		e8102d0200		CALL runtime.nanotime(SB)	
  0x424d20		488b0424		MOVQ 0(SP), AX			
  0x424d24		488b4c2430		MOVQ 0x30(SP), CX		
  0x424d29		4839c8			CMPQ CX, AX			
  0x424d2c		7d16			JGE 0x424d44			
			procyield(10)
  0x424d2e		c704240a000000		MOVL $0xa, 0(SP)		
  0x424d35		e8360e0200		CALL runtime.procyield(SB)	
  0x424d3a		488b442430		MOVQ 0x30(SP), AX		
  0x424d3f		e95fffffff		JMP 0x424ca3			
			osyield()
  0x424d44		e807320200		CALL runtime.osyield(SB)	
			nextYield = nanotime() + yieldDelay/2
  0x424d49		e8e22c0200		CALL runtime.nanotime(SB)	
  0x424d4e		488b0424		MOVQ 0(SP), AX			
  0x424d52		480588130000		ADDQ $0x1388, AX		
  0x424d58		e946ffffff		JMP 0x424ca3			
			nextYield = nanotime() + yieldDelay
  0x424d5d		e8ce2c0200		CALL runtime.nanotime(SB)	
  0x424d62		488b0424		MOVQ 0(SP), AX			
  0x424d66		488d9010270000		LEAQ 0x2710(AX), DX		
  0x424d6d		eba7			JMP 0x424d16			
			if castogscanstatus(gp, _Grunning, _Gscanrunning) {
  0x424d6f		48890424		MOVQ AX, 0(SP)				
  0x424d73		48b90200000002100000	MOVQ $0x100200000002, CX		
  0x424d7d		48894c2408		MOVQ CX, 0x8(SP)			
  0x424d82		e819fcffff		CALL runtime.castogscanstatus(SB)	
  0x424d87		0fb6442410		MOVZX 0x10(SP), AX			
  0x424d8c		84c0			TESTL AL, AL				
  0x424d8e		7428			JE 0x424db8				
  0x424d90		488b442450		MOVQ 0x50(SP), AX			
				if !gp.gcscandone {
  0x424d95		0fb688c3000000		MOVZX 0xc3(AX), CX	
  0x424d9c		84c9			TESTL CL, CL		
  0x424d9e		742c			JE 0x424dcc		
				casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)
  0x424da0		48890424		MOVQ AX, 0(SP)				
  0x424da4		48b90210000002000000	MOVQ $0x200001002, CX			
  0x424dae		48894c2408		MOVQ CX, 0x8(SP)			
  0x424db3		e898f7ffff		CALL runtime.casfrom_Gscanstatus(SB)	
  0x424db8		488b442450		MOVQ 0x50(SP), AX			
  0x424dbd		488b4c2428		MOVQ 0x28(SP), CX			
  0x424dc2		488b542420		MOVQ 0x20(SP), DX			
		switch s := readgstatus(gp); s {
  0x424dc7		e945ffffff		JMP 0x424d11		
					gp.preemptscan = true
  0x424dcc		c680c200000001		MOVB $0x1, 0xc2(AX)	
					gp.preempt = true
  0x424dd3		c680c000000001		MOVB $0x1, 0xc0(AX)	
					gp.stackguard0 = stackPreempt
  0x424dda		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x424de2		ebbc			JMP 0x424da0		
		case _Grunnable, _Gsyscall, _Gwaiting:
  0x424de4		8d73fd			LEAL -0x3(BX), SI	
  0x424de7		83fe01			CMPL $0x1, SI		
  0x424dea		0f87a9000000		JA 0x424e99		
			if castogscanstatus(gp, s, s|_Gscan) {
  0x424df0		48890424		MOVQ AX, 0(SP)				
  0x424df4		895c2408		MOVL BX, 0x8(SP)			
  0x424df8		81cb00100000		ORL $0x1000, BX				
  0x424dfe		895c240c		MOVL BX, 0xc(SP)			
  0x424e02		e899fbffff		CALL runtime.castogscanstatus(SB)	
  0x424e07		0fb6442410		MOVZX 0x10(SP), AX			
  0x424e0c		84c0			TESTL AL, AL				
  0x424e0e		7514			JNE 0x424e24				
  0x424e10		488b442450		MOVQ 0x50(SP), AX			
  0x424e15		488b4c2428		MOVQ 0x28(SP), CX			
  0x424e1a		488b542420		MOVQ 0x20(SP), DX			
		switch s := readgstatus(gp); s {
  0x424e1f		e9edfeffff		JMP 0x424d11		
  0x424e24		488b442450		MOVQ 0x50(SP), AX	
				if !gp.gcscandone {
  0x424e29		0fb688c3000000		MOVZX 0xc3(AX), CX	
  0x424e30		84c9			TESTL CL, CL		
  0x424e32		741f			JE 0x424e53		
				restartg(gp)
  0x424e34		48890424		MOVQ AX, 0(SP)			
  0x424e38		e8d3010000		CALL runtime.restartg(SB)	
				break loop
  0x424e3d		488b442450		MOVQ 0x50(SP), AX	
	gp.preemptscan = false // cancel scan request if no longer needed
  0x424e42		c680c200000000		MOVB $0x0, 0xc2(AX)	
}
  0x424e49		488b6c2440		MOVQ 0x40(SP), BP	
  0x424e4e		4883c448		ADDQ $0x48, SP		
  0x424e52		c3			RET			
					scanstack(gp, gcw)
  0x424e53		48890424		MOVQ AX, 0(SP)			
  0x424e57		488b4c2458		MOVQ 0x58(SP), CX		
  0x424e5c		48894c2408		MOVQ CX, 0x8(SP)		
  0x424e61		e83a05ffff		CALL runtime.scanstack(SB)	
  0x424e66		488b442450		MOVQ 0x50(SP), AX		
					gp.gcscandone = true
  0x424e6b		c680c300000001		MOVB $0x1, 0xc3(AX)	
  0x424e72		ebc0			JMP 0x424e34		
		case _Gdead:
  0x424e74		83fb06			CMPL $0x6, BX		
  0x424e77		7417			JE 0x424e90		
		case _Gcopystack:
  0x424e79		83fb08			CMPL $0x8, BX		
  0x424e7c		0f848ffeffff		JE 0x424d11		
		case _Gscanwaiting:
  0x424e82		81fb04100000		CMPL $0x1004, BX	
  0x424e88		0f8483feffff		JE 0x424d11		
  0x424e8e		eb09			JMP 0x424e99		
			gp.gcscandone = true
  0x424e90		c680c300000001		MOVB $0x1, 0xc3(AX)	
			break loop
  0x424e97		eba4			JMP 0x424e3d		
	_g_ := getg()
  0x424e99		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424ea2		48894c2438		MOVQ CX, 0x38(SP)	
	return atomic.Load(&gp.atomicstatus)
  0x424ea7		8b9090000000		MOVL 0x90(AX), DX	
  0x424ead		89542418		MOVL DX, 0x18(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x424eb1		488b9898000000		MOVQ 0x98(AX), BX		
  0x424eb8		48895c2430		MOVQ BX, 0x30(SP)		
  0x424ebd		e83eccffff		CALL runtime.printlock(SB)	
  0x424ec2		488d05995c0400		LEAQ 0x45c99(IP), AX		
  0x424ec9		48890424		MOVQ AX, 0(SP)			
  0x424ecd		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x424ed6		e865d5ffff		CALL runtime.printstring(SB)	
  0x424edb		488b442450		MOVQ 0x50(SP), AX		
  0x424ee0		48890424		MOVQ AX, 0(SP)			
  0x424ee4		e817d5ffff		CALL runtime.printpointer(SB)	
  0x424ee9		488d05a24f0400		LEAQ 0x44fa2(IP), AX		
  0x424ef0		48890424		MOVQ AX, 0(SP)			
  0x424ef4		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x424efd		e83ed5ffff		CALL runtime.printstring(SB)	
  0x424f02		488b442430		MOVQ 0x30(SP), AX		
  0x424f07		48890424		MOVQ AX, 0(SP)			
  0x424f0b		e870d3ffff		CALL runtime.printint(SB)	
  0x424f10		488d05fd5e0400		LEAQ 0x45efd(IP), AX		
  0x424f17		48890424		MOVQ AX, 0(SP)			
  0x424f1b		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x424f24		e817d5ffff		CALL runtime.printstring(SB)	
  0x424f29		8b442418		MOVL 0x18(SP), AX		
  0x424f2d		89c0			MOVL AX, AX			
  0x424f2f		48890424		MOVQ AX, 0(SP)			
  0x424f33		e838d2ffff		CALL runtime.printuint(SB)	
  0x424f38		e853ceffff		CALL runtime.printnl(SB)	
  0x424f3d		e83eccffff		CALL runtime.printunlock(SB)	
  0x424f42		488b442438		MOVQ 0x38(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x424f47		8b8890000000		MOVL 0x90(AX), CX	
  0x424f4d		894c241c		MOVL CX, 0x1c(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x424f51		488b9098000000		MOVQ 0x98(AX), DX		
  0x424f58		4889542430		MOVQ DX, 0x30(SP)		
  0x424f5d		e89ecbffff		CALL runtime.printlock(SB)	
  0x424f62		488d05e95b0400		LEAQ 0x45be9(IP), AX		
  0x424f69		48890424		MOVQ AX, 0(SP)			
  0x424f6d		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x424f76		e8c5d4ffff		CALL runtime.printstring(SB)	
  0x424f7b		488b442438		MOVQ 0x38(SP), AX		
  0x424f80		48890424		MOVQ AX, 0(SP)			
  0x424f84		e877d4ffff		CALL runtime.printpointer(SB)	
  0x424f89		488d05024f0400		LEAQ 0x44f02(IP), AX		
  0x424f90		48890424		MOVQ AX, 0(SP)			
  0x424f94		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x424f9d		e89ed4ffff		CALL runtime.printstring(SB)	
  0x424fa2		488b442430		MOVQ 0x30(SP), AX		
  0x424fa7		48890424		MOVQ AX, 0(SP)			
  0x424fab		e8d0d2ffff		CALL runtime.printint(SB)	
  0x424fb0		488d054a5e0400		LEAQ 0x45e4a(IP), AX		
  0x424fb7		48890424		MOVQ AX, 0(SP)			
  0x424fbb		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x424fc4		e877d4ffff		CALL runtime.printstring(SB)	
  0x424fc9		8b44241c		MOVL 0x1c(SP), AX		
  0x424fcd		89c0			MOVL AX, AX			
  0x424fcf		48890424		MOVQ AX, 0(SP)			
  0x424fd3		e898d1ffff		CALL runtime.printuint(SB)	
  0x424fd8		e8b3cdffff		CALL runtime.printnl(SB)	
  0x424fdd		e89ecbffff		CALL runtime.printunlock(SB)	
			throw("stopg: invalid status")
  0x424fe2		488d059c630400		LEAQ 0x4639c(IP), AX	
  0x424fe9		48890424		MOVQ AX, 0(SP)		
  0x424fed		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x424ff6		e8d5c1ffff		CALL runtime.throw(SB)	
  0x424ffb		0f0b			UD2			
func scang(gp *g, gcw *gcWork) {
  0x424ffd		e86ef50100		CALL runtime.morestack_noctxt(SB)	
  0x425002		e969fcffff		JMP runtime.scang(SB)			

TEXT runtime.restartg(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func restartg(gp *g) {
  0x425010		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425019		483b6110		CMPQ 0x10(CX), SP	
  0x42501d		0f86b8010000		JBE 0x4251db		
  0x425023		4883ec30		SUBQ $0x30, SP		
  0x425027		48896c2428		MOVQ BP, 0x28(SP)	
  0x42502c		488d6c2428		LEAQ 0x28(SP), BP	
  0x425031		488b442438		MOVQ 0x38(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x425036		8b8890000000		MOVL 0x90(AX), CX	
	case _Gdead:
  0x42503c		83f906			CMPL $0x6, CX		
  0x42503f		750a			JNE 0x42504b		
  0x425041		488b6c2428		MOVQ 0x28(SP), BP	
  0x425046		4883c430		ADDQ $0x30, SP		
  0x42504a		c3			RET			
	case _Gscanrunnable,
  0x42504b		81f901100000		CMPL $0x1001, CX	
  0x425051		7519			JNE 0x42506c		
		casfrom_Gscanstatus(gp, s, s&^_Gscan)
  0x425053		48890424		MOVQ AX, 0(SP)				
  0x425057		894c2408		MOVL CX, 0x8(SP)			
  0x42505b		81e1ffefffff		ANDL $-0x1001, CX			
  0x425061		894c240c		MOVL CX, 0xc(SP)			
  0x425065		e8e6f4ffff		CALL runtime.casfrom_Gscanstatus(SB)	
	switch s {
  0x42506a		ebd5			JMP 0x425041		
	case _Gscanrunnable,
  0x42506c		8d91fdefffff		LEAL 0xffffeffd(CX), DX	
  0x425072		83fa01			CMPL $0x1, DX		
  0x425075		76dc			JBE 0x425053		
	_g_ := getg()
  0x425077		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425080		48894c2420		MOVQ CX, 0x20(SP)	
	return atomic.Load(&gp.atomicstatus)
  0x425085		8b9090000000		MOVL 0x90(AX), DX	
  0x42508b		89542410		MOVL DX, 0x10(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x42508f		488b9898000000		MOVQ 0x98(AX), BX		
  0x425096		48895c2418		MOVQ BX, 0x18(SP)		
  0x42509b		e860caffff		CALL runtime.printlock(SB)	
  0x4250a0		488d05bb5a0400		LEAQ 0x45abb(IP), AX		
  0x4250a7		48890424		MOVQ AX, 0(SP)			
  0x4250ab		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4250b4		e887d3ffff		CALL runtime.printstring(SB)	
  0x4250b9		488b442438		MOVQ 0x38(SP), AX		
  0x4250be		48890424		MOVQ AX, 0(SP)			
  0x4250c2		e839d3ffff		CALL runtime.printpointer(SB)	
  0x4250c7		488d05c44d0400		LEAQ 0x44dc4(IP), AX		
  0x4250ce		48890424		MOVQ AX, 0(SP)			
  0x4250d2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4250db		e860d3ffff		CALL runtime.printstring(SB)	
  0x4250e0		488b442418		MOVQ 0x18(SP), AX		
  0x4250e5		48890424		MOVQ AX, 0(SP)			
  0x4250e9		e892d1ffff		CALL runtime.printint(SB)	
  0x4250ee		488d051f5d0400		LEAQ 0x45d1f(IP), AX		
  0x4250f5		48890424		MOVQ AX, 0(SP)			
  0x4250f9		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x425102		e839d3ffff		CALL runtime.printstring(SB)	
  0x425107		8b442410		MOVL 0x10(SP), AX		
  0x42510b		89c0			MOVL AX, AX			
  0x42510d		48890424		MOVQ AX, 0(SP)			
  0x425111		e85ad0ffff		CALL runtime.printuint(SB)	
  0x425116		e875ccffff		CALL runtime.printnl(SB)	
  0x42511b		e860caffff		CALL runtime.printunlock(SB)	
  0x425120		488b442420		MOVQ 0x20(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x425125		8b8890000000		MOVL 0x90(AX), CX	
  0x42512b		894c2414		MOVL CX, 0x14(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x42512f		488b9098000000		MOVQ 0x98(AX), DX		
  0x425136		4889542418		MOVQ DX, 0x18(SP)		
  0x42513b		e8c0c9ffff		CALL runtime.printlock(SB)	
  0x425140		488d050b5a0400		LEAQ 0x45a0b(IP), AX		
  0x425147		48890424		MOVQ AX, 0(SP)			
  0x42514b		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x425154		e8e7d2ffff		CALL runtime.printstring(SB)	
  0x425159		488b442420		MOVQ 0x20(SP), AX		
  0x42515e		48890424		MOVQ AX, 0(SP)			
  0x425162		e899d2ffff		CALL runtime.printpointer(SB)	
  0x425167		488d05244d0400		LEAQ 0x44d24(IP), AX		
  0x42516e		48890424		MOVQ AX, 0(SP)			
  0x425172		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42517b		e8c0d2ffff		CALL runtime.printstring(SB)	
  0x425180		488b442418		MOVQ 0x18(SP), AX		
  0x425185		48890424		MOVQ AX, 0(SP)			
  0x425189		e8f2d0ffff		CALL runtime.printint(SB)	
  0x42518e		488d056c5c0400		LEAQ 0x45c6c(IP), AX		
  0x425195		48890424		MOVQ AX, 0(SP)			
  0x425199		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4251a2		e899d2ffff		CALL runtime.printstring(SB)	
  0x4251a7		8b442414		MOVL 0x14(SP), AX		
  0x4251ab		89c0			MOVL AX, AX			
  0x4251ad		48890424		MOVQ AX, 0(SP)			
  0x4251b1		e8bacfffff		CALL runtime.printuint(SB)	
  0x4251b6		e8d5cbffff		CALL runtime.printnl(SB)	
  0x4251bb		e8c0c9ffff		CALL runtime.printunlock(SB)	
		throw("restartg: unexpected status")
  0x4251c0		488d055c6c0400		LEAQ 0x46c5c(IP), AX	
  0x4251c7		48890424		MOVQ AX, 0(SP)		
  0x4251cb		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x4251d4		e8f7bfffff		CALL runtime.throw(SB)	
  0x4251d9		0f0b			UD2			
func restartg(gp *g) {
  0x4251db		e890f30100		CALL runtime.morestack_noctxt(SB)	
  0x4251e0		e92bfeffff		JMP runtime.restartg(SB)		

TEXT runtime.stopTheWorldWithSema(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func stopTheWorldWithSema() {
  0x4251f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4251f9		483b6110		CMPQ 0x10(CX), SP	
  0x4251fd		0f86b5020000		JBE 0x4254b8		
  0x425203		4883ec60		SUBQ $0x60, SP		
  0x425207		48896c2458		MOVQ BP, 0x58(SP)	
  0x42520c		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x425211		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.locks > 0 {
  0x42521a		488b4830		MOVQ 0x30(AX), CX	
  0x42521e		8b8900010000		MOVL 0x100(CX), CX	
  0x425224		85c9			TESTL CX, CX		
  0x425226		0f8f71020000		JG 0x42549d		
  0x42522c		4889442448		MOVQ AX, 0x48(SP)	
	lock(&sched.lock)
  0x425231		488d05f8260800		LEAQ runtime.sched+16(SB), AX	
  0x425238		48890424		MOVQ AX, 0(SP)			
  0x42523c		e8df42feff		CALL runtime.lock(SB)		
	sched.stopwait = gomaxprocs
  0x425241		8b0599e60900		MOVL runtime.gomaxprocs(SB), AX	
  0x425247		8905af270800		MOVL AX, runtime.sched+220(SB)	
	atomic.Store(&sched.gcwaiting, 1)
  0x42524d		b801000000		MOVL $0x1, AX			
  0x425252		488d0d9f270800		LEAQ runtime.sched+216(SB), CX	
  0x425259		8701			XCHGL AX, 0(CX)			
	preemptall()
  0x42525b		e8107e0000		CALL runtime.preemptall(SB)	
  0x425260		488b442448		MOVQ 0x48(SP), AX		
	_g_.m.p.ptr().status = _Pgcstop // Pgcstop is only diagnostic.
  0x425265		488b4030		MOVQ 0x30(AX), AX	
  0x425269		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x425270		c7400c03000000		MOVL $0x3, 0xc(AX)	
	sched.stopwait--
  0x425277		83057e270800ff		ADDL $-0x1, runtime.sched+220(SB)	
	for _, p := range allp {
  0x42527e		488b0533240800		MOVQ runtime.allp+8(SB), AX	
  0x425285		4889442430		MOVQ AX, 0x30(SP)		
  0x42528a		488b0d1f240800		MOVQ runtime.allp(SB), CX	
  0x425291		48894c2450		MOVQ CX, 0x50(SP)		
  0x425296		31d2			XORL DX, DX			
  0x425298		eb06			JMP 0x4252a0			
  0x42529a		48ffc2			INCQ DX				
  0x42529d		4889f8			MOVQ DI, AX			
  0x4252a0		4839c2			CMPQ AX, DX			
  0x4252a3		0f8d97000000		JGE 0x425340			
  0x4252a9		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		s := p.status
  0x4252ad		8b730c			MOVL 0xc(BX), SI	
		if s == _Psyscall && atomic.Cas(&p.status, s, _Pgcstop) {
  0x4252b0		83fe02			CMPL $0x2, SI			
  0x4252b3		756f			JNE 0x425324			
  0x4252b5		4889c7			MOVQ AX, DI			
  0x4252b8		89f0			MOVL SI, AX			
  0x4252ba		41b803000000		MOVL $0x3, R8			
  0x4252c0		f0440fb1430c		LOCK CMPXCHGL R8, 0xc(BX)	
  0x4252c6		400f94c6		SETE SI				
  0x4252ca		4084f6			TESTL SI, SI			
  0x4252cd		74cb			JE 0x42529a			
			if trace.enabled {
  0x4252cf		0fb635fae40800		MOVZX runtime.trace+16(SB), SI	
  0x4252d6		4084f6			TESTL SI, SI			
  0x4252d9		750c			JNE 0x4252e7			
			p.syscalltick++
  0x4252db		ff431c			INCL 0x1c(BX)		
			sched.stopwait--
  0x4252de		830517270800ff		ADDL $-0x1, runtime.sched+220(SB)	
  0x4252e5		ebb3			JMP 0x42529a				
  0x4252e7		4889542428		MOVQ DX, 0x28(SP)			
  0x4252ec		48895c2438		MOVQ BX, 0x38(SP)			
				traceGoSysBlock(p)
  0x4252f1		48891c24		MOVQ BX, 0(SP)				
  0x4252f5		e8065c0100		CALL runtime.traceGoSysBlock(SB)	
  0x4252fa		488b442438		MOVQ 0x38(SP), AX			
				traceProcStop(p)
  0x4252ff		48890424		MOVQ AX, 0(SP)			
  0x425303		e8e84f0100		CALL runtime.traceProcStop(SB)	
  0x425308		488b4c2450		MOVQ 0x50(SP), CX		
  0x42530d		488b542428		MOVQ 0x28(SP), DX		
  0x425312		488b5c2438		MOVQ 0x38(SP), BX		
  0x425317		488b7c2430		MOVQ 0x30(SP), DI		
  0x42531c		41b803000000		MOVL $0x3, R8			
  0x425322		ebb7			JMP 0x4252db			
  0x425324		4889c7			MOVQ AX, DI			
  0x425327		41b803000000		MOVL $0x3, R8			
		if s == _Psyscall && atomic.Cas(&p.status, s, _Pgcstop) {
  0x42532d		e968ffffff		JMP 0x42529a		
		p.status = _Pgcstop
  0x425332		c7400c03000000		MOVL $0x3, 0xc(AX)	
		sched.stopwait--
  0x425339		8305bc260800ff		ADDL $-0x1, runtime.sched+220(SB)	
	_p_ := sched.pidle.ptr()
  0x425340		488b0521260800		MOVQ runtime.sched+72(SB), AX	
	if _p_ != nil {
  0x425347		4885c0			TESTQ AX, AX		
  0x42534a		741e			JE 0x42536a		
		sched.pidle = _p_.link
  0x42534c		488b4810		MOVQ 0x10(AX), CX		
  0x425350		48890d11260800		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x425357		b9ffffffff		MOVL $-0x1, CX			
  0x42535c		488d150d260800		LEAQ runtime.sched+80(SB), DX	
  0x425363		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x425367		4885c0			TESTQ AX, AX		
		if p == nil {
  0x42536a		75c6			JNE 0x425332		
	wait := sched.stopwait > 0
  0x42536c		8b058a260800		MOVL runtime.sched+220(SB), AX	
  0x425372		8944241c		MOVL AX, 0x1c(SP)		
	unlock(&sched.lock)
  0x425376		488d0db3250800		LEAQ runtime.sched+16(SB), CX	
  0x42537d		48890c24		MOVQ CX, 0(SP)			
  0x425381		e83a43feff		CALL runtime.unlock(SB)		
  0x425386		8b44241c		MOVL 0x1c(SP), AX		
	wait := sched.stopwait > 0
  0x42538a		85c0			TESTL AX, AX		
	if wait {
  0x42538c		0f8fc0000000		JG 0x425452		
	if sched.stopwait != 0 {
  0x425392		8b0564260800		MOVL runtime.sched+220(SB), AX	
  0x425398		85c0			TESTL AX, AX			
  0x42539a		0f859f000000		JNE 0x42543f			
		for _, p := range allp {
  0x4253a0		488b0511230800		MOVQ runtime.allp+8(SB), AX	
  0x4253a7		488b0d02230800		MOVQ runtime.allp(SB), CX	
  0x4253ae		31d2			XORL DX, DX			
  0x4253b0		31db			XORL BX, BX			
  0x4253b2		31f6			XORL SI, SI			
  0x4253b4		eb0c			JMP 0x4253c2			
  0x4253b6		48ffc2			INCQ DX				
  0x4253b9		4889df			MOVQ BX, DI			
  0x4253bc		4889f3			MOVQ SI, BX			
  0x4253bf		4889fe			MOVQ DI, SI			
  0x4253c2		4839c2			CMPQ AX, DX			
  0x4253c5		7d25			JGE 0x4253ec			
  0x4253c7		488b3cd1		MOVQ 0(CX)(DX*8), DI		
			if p.status != _Pgcstop {
  0x4253cb		8b7f0c			MOVL 0xc(DI), DI	
  0x4253ce		83ff03			CMPL $0x3, DI		
  0x4253d1		740e			JE 0x4253e1		
  0x4253d3		488d1d66840400		LEAQ 0x48466(IP), BX	
  0x4253da		be2e000000		MOVL $0x2e, SI		
		for _, p := range allp {
  0x4253df		ebd5			JMP 0x4253b6		
  0x4253e1		4889df			MOVQ BX, DI		
  0x4253e4		4889f3			MOVQ SI, BX		
  0x4253e7		4889fe			MOVQ DI, SI		
			if p.status != _Pgcstop {
  0x4253ea		ebca			JMP 0x4253b6		
	if atomic.Load(&freezing) != 0 {
  0x4253ec		8b05dee40900		MOVL runtime.freezing(SB), AX	
  0x4253f2		85c0			TESTL AX, AX			
  0x4253f4		7513			JNE 0x425409			
	if bad != "" {
  0x4253f6		4885db			TESTQ BX, BX		
  0x4253f9		0f858e000000		JNE 0x42548d		
  0x4253ff		488b6c2458		MOVQ 0x58(SP), BP	
  0x425404		4883c460		ADDQ $0x60, SP		
  0x425408		c3			RET			
  0x425409		48895c2420		MOVQ BX, 0x20(SP)	
  0x42540e		4889742440		MOVQ SI, 0x40(SP)	
		lock(&deadlock)
  0x425413		488d052ee50900		LEAQ runtime.deadlock(SB), AX	
  0x42541a		48890424		MOVQ AX, 0(SP)			
  0x42541e		e8fd40feff		CALL runtime.lock(SB)		
		lock(&deadlock)
  0x425423		488d051ee50900		LEAQ runtime.deadlock(SB), AX	
  0x42542a		48890424		MOVQ AX, 0(SP)			
  0x42542e		e8ed40feff		CALL runtime.lock(SB)		
  0x425433		488b5c2420		MOVQ 0x20(SP), BX		
  0x425438		488b742440		MOVQ 0x40(SP), SI		
  0x42543d		ebb7			JMP 0x4253f6			
  0x42543f		bb29000000		MOVL $0x29, BX			
  0x425444		488d35d97f0400		LEAQ 0x47fd9(IP), SI		
	if atomic.Load(&freezing) != 0 {
  0x42544b		eb9f			JMP 0x4253ec		
			preemptall()
  0x42544d		e81e7c0000		CALL runtime.preemptall(SB)	
			if notetsleep(&sched.stopnote, 100*1000) {
  0x425452		488d05a7250800		LEAQ runtime.sched+224(SB), AX	
  0x425459		48890424		MOVQ AX, 0(SP)			
  0x42545d		48c7442408a0860100	MOVQ $0x186a0, 0x8(SP)		
  0x425466		e89546feff		CALL runtime.notetsleep(SB)	
  0x42546b		0fb6442410		MOVZX 0x10(SP), AX		
  0x425470		84c0			TESTL AL, AL			
  0x425472		74d9			JE 0x42544d			
	n.key = 0
  0x425474		488d0585250800		LEAQ runtime.sched+224(SB), AX		
  0x42547b		8400			TESTB AL, 0(AX)				
  0x42547d		48c7057825080000000000	MOVQ $0x0, runtime.sched+224(SB)	
	if sched.stopwait != 0 {
  0x425488		e905ffffff		JMP 0x425392		
		throw(bad)
  0x42548d		48893424		MOVQ SI, 0(SP)		
  0x425491		48895c2408		MOVQ BX, 0x8(SP)	
  0x425496		e835bdffff		CALL runtime.throw(SB)	
  0x42549b		0f0b			UD2			
		throw("stopTheWorld: holding locks")
  0x42549d		488d05a86a0400		LEAQ 0x46aa8(IP), AX	
  0x4254a4		48890424		MOVQ AX, 0(SP)		
  0x4254a8		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x4254b1		e81abdffff		CALL runtime.throw(SB)	
  0x4254b6		0f0b			UD2			
func stopTheWorldWithSema() {
  0x4254b8		e8b3f00100		CALL runtime.morestack_noctxt(SB)	
  0x4254bd		e92efdffff		JMP runtime.stopTheWorldWithSema(SB)	

TEXT runtime.mhelpgc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	_g_ := getg()
  0x4254d0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.helpgc = -1
  0x4254d9		488b4030		MOVQ 0x30(AX), AX	
  0x4254dd		c78010010000ffffffff	MOVL $-0x1, 0x110(AX)	
}
  0x4254e7		c3			RET			

TEXT runtime.startTheWorldWithSema(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func startTheWorldWithSema(emitTraceEvent bool) int64 {
  0x4254f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4254f9		483b6110		CMPQ 0x10(CX), SP	
  0x4254fd		0f863c020000		JBE 0x42573f		
  0x425503		4883ec40		SUBQ $0x40, SP		
  0x425507		48896c2438		MOVQ BP, 0x38(SP)	
  0x42550c		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x425511		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42551a		4889442428		MOVQ AX, 0x28(SP)	
	_g_.m.locks++ // disable preemption because it can be holding p in a local var
  0x42551f		488b4830		MOVQ 0x30(AX), CX	
  0x425523		ff8100010000		INCL 0x100(CX)		
	return atomic.Load(&netpollInited) != 0
  0x425529		8b0db9e30900		MOVL runtime.netpollInited(SB), CX	
  0x42552f		85c9			TESTL CX, CX				
	if netpollinited() {
  0x425531		0f85d1010000		JNE 0x425708		
	add := needaddgcproc()
  0x425537		e834edffff		CALL runtime.needaddgcproc(SB)	
  0x42553c		0fb60424		MOVZX 0(SP), AX			
  0x425540		88442417		MOVB AL, 0x17(SP)		
	lock(&sched.lock)
  0x425544		488d0de5230800		LEAQ runtime.sched+16(SB), CX	
  0x42554b		48890c24		MOVQ CX, 0(SP)			
  0x42554f		e8cc3ffeff		CALL runtime.lock(SB)		
	procs := gomaxprocs
  0x425554		8b0586e30900		MOVL runtime.gomaxprocs(SB), AX	
	if newprocs != 0 {
  0x42555a		8b0d90e30900		MOVL runtime.newprocs(SB), CX	
  0x425560		85c9			TESTL CX, CX			
  0x425562		0f8499010000		JE 0x425701			
		newprocs = 0
  0x425568		c7057ee3090000000000	MOVL $0x0, runtime.newprocs(SB)	
	p1 := procresize(procs)
  0x425572		890c24			MOVL CX, 0(SP)			
  0x425575		e806600000		CALL runtime.procresize(SB)	
  0x42557a		488b442408		MOVQ 0x8(SP), AX		
  0x42557f		4889442420		MOVQ AX, 0x20(SP)		
	sched.gcwaiting = 0
  0x425584		c7056a24080000000000	MOVL $0x0, runtime.sched+216(SB)	
	if sched.sysmonwait != 0 {
  0x42558e		8b0d74240800		MOVL runtime.sched+232(SB), CX	
  0x425594		85c9			TESTL CX, CX			
  0x425596		0f8546010000		JNE 0x4256e2			
	unlock(&sched.lock)
  0x42559c		488d058d230800		LEAQ runtime.sched+16(SB), AX	
  0x4255a3		48890424		MOVQ AX, 0(SP)			
  0x4255a7		e81441feff		CALL runtime.unlock(SB)		
  0x4255ac		488b442420		MOVQ 0x20(SP), AX		
  0x4255b1		0fb64c2417		MOVZX 0x17(SP), CX		
	for p1 != nil {
  0x4255b6		eb07			JMP 0x4255bf		
  0x4255b8		89c1			MOVL AX, CX		
  0x4255ba		488b442430		MOVQ 0x30(SP), AX	
  0x4255bf		884c2417		MOVB CL, 0x17(SP)	
  0x4255c3		4885c0			TESTQ AX, AX		
  0x4255c6		7467			JE 0x42562f		
		p1 = p1.link.ptr()
  0x4255c8		488b5010		MOVQ 0x10(AX), DX	
		if p.m != 0 {
  0x4255cc		488b5840		MOVQ 0x40(AX), BX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x4255d0		4889542430		MOVQ DX, 0x30(SP)	
		if p.m != 0 {
  0x4255d5		4885db			TESTQ BX, BX		
  0x4255d8		743f			JE 0x425619		
			p.m = 0
  0x4255da		48c7404000000000	MOVQ $0x0, 0x40(AX)	
			if mp.nextp != 0 {
  0x4255e2		488bb3d8000000		MOVQ 0xd8(BX), SI	
  0x4255e9		488dbbd8000000		LEAQ 0xd8(BX), DI	
  0x4255f0		4885f6			TESTQ SI, SI		
  0x4255f3		0f852b010000		JNE 0x425724		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4255f9		8407			TESTB AL, 0(DI)		
  0x4255fb		488983d8000000		MOVQ AX, 0xd8(BX)	
			notewakeup(&mp.park)
  0x425602		488d8348010000		LEAQ 0x148(BX), AX		
  0x425609		48890424		MOVQ AX, 0(SP)			
  0x42560d		e87e41feff		CALL runtime.notewakeup(SB)	
  0x425612		0fb6442417		MOVZX 0x17(SP), AX		
  0x425617		eb9f			JMP 0x4255b8			
			newm(nil, p)
  0x425619		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x425621		4889442408		MOVQ AX, 0x8(SP)	
  0x425626		e815120000		CALL runtime.newm(SB)	
  0x42562b		31c0			XORL AX, AX		
			add = false
  0x42562d		eb89			JMP 0x4255b8		
	startTime := nanotime()
  0x42562f		e8fc230200		CALL runtime.nanotime(SB)	
  0x425634		488b0424		MOVQ 0(SP), AX			
  0x425638		4889442418		MOVQ AX, 0x18(SP)		
  0x42563d		0fb64c2448		MOVZX 0x48(SP), CX		
func startTheWorldWithSema(emitTraceEvent bool) int64 {
  0x425642		84c9			TESTL CL, CL		
	if emitTraceEvent {
  0x425644		0f8589000000		JNE 0x4256d3		
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
  0x42564a		8b0d20230800		MOVL runtime.sched+80(SB), CX	
  0x425650		85c9			TESTL CX, CX			
  0x425652		740a			JE 0x42565e			
  0x425654		8b0d1a230800		MOVL runtime.sched+84(SB), CX	
  0x42565a		85c9			TESTL CX, CX			
  0x42565c		7469			JE 0x4256c7			
  0x42565e		0fb64c2417		MOVZX 0x17(SP), CX		
	if add {
  0x425663		84c9			TESTL CL, CL		
  0x425665		7540			JNE 0x4256a7		
  0x425667		488b4c2428		MOVQ 0x28(SP), CX	
	_g_.m.locks--
  0x42566c		488b5130		MOVQ 0x30(CX), DX	
  0x425670		838200010000ff		ADDL $-0x1, 0x100(DX)	
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
  0x425677		488b5130		MOVQ 0x30(CX), DX	
  0x42567b		8b9200010000		MOVL 0x100(DX), DX	
  0x425681		85d2			TESTL DX, DX		
  0x425683		7513			JNE 0x425698		
  0x425685		0fb691c0000000		MOVZX 0xc0(CX), DX	
  0x42568c		84d2			TESTL DL, DL		
  0x42568e		7408			JE 0x425698		
		_g_.stackguard0 = stackPreempt
  0x425690		48c74110defaffff	MOVQ $-0x522, 0x10(CX)	
	return startTime
  0x425698		4889442450		MOVQ AX, 0x50(SP)	
  0x42569d		488b6c2438		MOVQ 0x38(SP), BP	
  0x4256a2		4883c440		ADDQ $0x40, SP		
  0x4256a6		c3			RET			
		newm(mhelpgc, nil)
  0x4256a7		488d05b28a0400		LEAQ 0x48ab2(IP), AX	
  0x4256ae		48890424		MOVQ AX, 0(SP)		
  0x4256b2		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x4256bb		e880110000		CALL runtime.newm(SB)	
  0x4256c0		488b442418		MOVQ 0x18(SP), AX	
  0x4256c5		eba0			JMP 0x425667		
		wakep()
  0x4256c7		e8a41c0000		CALL runtime.wakep(SB)	
  0x4256cc		488b442418		MOVQ 0x18(SP), AX	
  0x4256d1		eb8b			JMP 0x42565e		
		traceGCSTWDone()
  0x4256d3		e8484e0100		CALL runtime.traceGCSTWDone(SB)	
  0x4256d8		488b442418		MOVQ 0x18(SP), AX		
  0x4256dd		e968ffffff		JMP 0x42564a			
		sched.sysmonwait = 0
  0x4256e2		c7051c23080000000000	MOVL $0x0, runtime.sched+232(SB)	
		notewakeup(&sched.sysmonnote)
  0x4256ec		488d051d230800		LEAQ runtime.sched+240(SB), AX	
  0x4256f3		48890424		MOVQ AX, 0(SP)			
  0x4256f7		e89440feff		CALL runtime.notewakeup(SB)	
  0x4256fc		e99bfeffff		JMP 0x42559c			
  0x425701		89c1			MOVL AX, CX			
	if newprocs != 0 {
  0x425703		e96afeffff		JMP 0x425572		
		gp := netpoll(false) // non-blocking
  0x425708		c6042400		MOVB $0x0, 0(SP)		
  0x42570c		e81f93ffff		CALL runtime.netpoll(SB)	
  0x425711		488b442408		MOVQ 0x8(SP), AX		
		injectglist(gp)
  0x425716		48890424		MOVQ AX, 0(SP)			
  0x42571a		e851300000		CALL runtime.injectglist(SB)	
  0x42571f		e913feffff		JMP 0x425537			
				throw("startTheWorld: inconsistent mp->nextp")
  0x425724		488d051e790400		LEAQ 0x4791e(IP), AX	
  0x42572b		48890424		MOVQ AX, 0(SP)		
  0x42572f		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x425738		e893baffff		CALL runtime.throw(SB)	
  0x42573d		0f0b			UD2			
func startTheWorldWithSema(emitTraceEvent bool) int64 {
  0x42573f		e82cee0100		CALL runtime.morestack_noctxt(SB)	
  0x425744		e9a7fdffff		JMP runtime.startTheWorldWithSema(SB)	

TEXT runtime.mstart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func mstart() {
  0x425750		4883ec20		SUBQ $0x20, SP		
  0x425754		48896c2418		MOVQ BP, 0x18(SP)	
  0x425759		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x42575e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	osStack := _g_.stack.lo == 0
  0x425767		488b08			MOVQ 0(AX), CX		
  0x42576a		4885c9			TESTQ CX, CX		
  0x42576d		0f94c1			SETE CL			
  0x425770		884c240f		MOVB CL, 0xf(SP)	
	if osStack {
  0x425774		7532			JNE 0x4257a8		
		size := _g_.stack.hi
  0x425776		488b5008		MOVQ 0x8(AX), DX	
  0x42577a		4889542410		MOVQ DX, 0x10(SP)	
		if size == 0 {
  0x42577f		4885d2			TESTQ DX, DX		
  0x425782		7509			JNE 0x42578d		
			size = 8192 * sys.StackGuardMultiplier
  0x425784		48c744241000200000	MOVQ $0x2000, 0x10(SP)	
		_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))
  0x42578d		488d542410		LEAQ 0x10(SP), DX	
  0x425792		48895008		MOVQ DX, 0x8(AX)	
		_g_.stack.lo = _g_.stack.hi - size + 1024
  0x425796		488b5c2410		MOVQ 0x10(SP), BX	
  0x42579b		4829da			SUBQ BX, DX		
  0x42579e		4881c200040000		ADDQ $0x400, DX		
  0x4257a5		488910			MOVQ DX, 0(AX)		
	_g_.stackguard0 = _g_.stack.lo + _StackGuard
  0x4257a8		488b08			MOVQ 0(AX), CX		
  0x4257ab		4881c170030000		ADDQ $0x370, CX		
  0x4257b2		48894810		MOVQ CX, 0x10(AX)	
	_g_.stackguard1 = _g_.stackguard0
  0x4257b6		48894818		MOVQ CX, 0x18(AX)	
	mstart1(0)
  0x4257ba		c7042400000000		MOVL $0x0, 0(SP)		
  0x4257c1		e81a000000		CALL runtime.mstart1(SB)	
  0x4257c6		0fb644240f		MOVZX 0xf(SP), AX		
	mexit(osStack)
  0x4257cb		880424			MOVB AL, 0(SP)		
  0x4257ce		e89d010000		CALL runtime.mexit(SB)	
}
  0x4257d3		488b6c2418		MOVQ 0x18(SP), BP	
  0x4257d8		4883c420		ADDQ $0x20, SP		
  0x4257dc		c3			RET			

TEXT runtime.mstart1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func mstart1(dummy int32) {
  0x4257e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4257e9		483b6110		CMPQ 0x10(CX), SP	
  0x4257ed		0f8613010000		JBE 0x425906		
  0x4257f3		4883ec20		SUBQ $0x20, SP		
  0x4257f7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4257fc		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x425801		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_ != _g_.m.g0 {
  0x42580a		488b4830		MOVQ 0x30(AX), CX	
  0x42580e		488b09			MOVQ 0(CX), CX		
  0x425811		4839c1			CMPQ AX, CX		
  0x425814		0f85d1000000		JNE 0x4258eb		
  0x42581a		4889442410		MOVQ AX, 0x10(SP)	
	save(getcallerpc(), getcallersp(unsafe.Pointer(&dummy)))
  0x42581f		488b442420		MOVQ 0x20(SP), AX	
  0x425824		48890424		MOVQ AX, 0(SP)		
  0x425828		488d442428		LEAQ 0x28(SP), AX	
  0x42582d		4889442408		MOVQ AX, 0x8(SP)	
  0x425832		e8e93c0000		CALL runtime.save(SB)	
	asminit()
  0x425837		e8f4ea0100		CALL runtime.asminit(SB)	
	minit()
  0x42583c		e81f9effff		CALL runtime.minit(SB)	
  0x425841		488b442410		MOVQ 0x10(SP), AX	
	if _g_.m == &m0 {
  0x425846		488b4830		MOVQ 0x30(AX), CX	
  0x42584a		488d150f270800		LEAQ runtime.m0(SB), DX	
  0x425851		4839d1			CMPQ DX, CX		
  0x425854		747f			JE 0x4258d5		
	if fn := _g_.m.mstartfn; fn != nil {
  0x425856		488b4830		MOVQ 0x30(AX), CX	
  0x42585a		488b89b8000000		MOVQ 0xb8(CX), CX	
  0x425861		4885c9			TESTQ CX, CX		
  0x425864		7559			JNE 0x4258bf		
	if _g_.m.helpgc != 0 {
  0x425866		488b4830		MOVQ 0x30(AX), CX	
  0x42586a		8b9910010000		MOVL 0x110(CX), BX	
  0x425870		85db			TESTL BX, BX		
  0x425872		753a			JNE 0x4258ae		
	} else if _g_.m != &m0 {
  0x425874		4839ca			CMPQ CX, DX		
  0x425877		750f			JNE 0x425888		
	schedule()
  0x425879		e882300000		CALL runtime.schedule(SB)	
}
  0x42587e		488b6c2418		MOVQ 0x18(SP), BP	
  0x425883		4883c420		ADDQ $0x20, SP		
  0x425887		c3			RET			
		acquirep(_g_.m.nextp.ptr())
  0x425888		488b81d8000000		MOVQ 0xd8(CX), AX		
  0x42588f		48890424		MOVQ AX, 0(SP)			
  0x425893		e848670000		CALL runtime.acquirep(SB)	
  0x425898		488b442410		MOVQ 0x10(SP), AX		
		_g_.m.nextp = 0
  0x42589d		488b4030		MOVQ 0x30(AX), AX	
  0x4258a1		48c780d800000000000000	MOVQ $0x0, 0xd8(AX)	
  0x4258ac		ebcb			JMP 0x425879		
		_g_.m.helpgc = 0
  0x4258ae		c7811001000000000000	MOVL $0x0, 0x110(CX)	
		stopm()
  0x4258b8		e8c3130000		CALL runtime.stopm(SB)	
  0x4258bd		ebba			JMP 0x425879		
		fn()
  0x4258bf		488b01			MOVQ 0(CX), AX		
  0x4258c2		4889ca			MOVQ CX, DX		
  0x4258c5		ffd0			CALL AX			
  0x4258c7		488b442410		MOVQ 0x10(SP), AX	
  0x4258cc		488d158d260800		LEAQ runtime.m0(SB), DX	
  0x4258d3		eb91			JMP 0x425866		
		mstartm0()
  0x4258d5		e836000000		CALL runtime.mstartm0(SB)	
  0x4258da		488b442410		MOVQ 0x10(SP), AX		
  0x4258df		488d157a260800		LEAQ runtime.m0(SB), DX		
  0x4258e6		e96bffffff		JMP 0x425856			
		throw("bad runtime·mstart")
  0x4258eb		488d0581550400		LEAQ 0x45581(IP), AX	
  0x4258f2		48890424		MOVQ AX, 0(SP)		
  0x4258f6		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x4258ff		e8ccb8ffff		CALL runtime.throw(SB)	
  0x425904		0f0b			UD2			
func mstart1(dummy int32) {
  0x425906		e865ec0100		CALL runtime.morestack_noctxt(SB)	
  0x42590b		e9d0feffff		JMP runtime.mstart1(SB)			

TEXT runtime.mstartm0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func mstartm0() {
  0x425910		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425919		483b6110		CMPQ 0x10(CX), SP	
  0x42591d		7645			JBE 0x425964		
  0x42591f		4883ec10		SUBQ $0x10, SP		
  0x425923		48896c2408		MOVQ BP, 0x8(SP)	
  0x425928		488d6c2408		LEAQ 0x8(SP), BP	
	if iscgo && !cgoHasExtraM {
  0x42592d		0fb60578df0900		MOVZX runtime.iscgo(SB), AX		
  0x425934		84c0			TESTL AL, AL				
  0x425936		740b			JE 0x425943				
  0x425938		0fb60563df0900		MOVZX runtime.cgoHasExtraM(SB), AX	
  0x42593f		84c0			TESTL AL, AL				
  0x425941		7413			JE 0x425956				
	initsig(false)
  0x425943		c6042400		MOVB $0x0, 0(SP)		
  0x425947		e864c70000		CALL runtime.initsig(SB)	
}
  0x42594c		488b6c2408		MOVQ 0x8(SP), BP	
  0x425951		4883c410		ADDQ $0x10, SP		
  0x425955		c3			RET			
		cgoHasExtraM = true
  0x425956		c60545df090001		MOVB $0x1, runtime.cgoHasExtraM(SB)	
		newextram()
  0x42595d		e8be0a0000		CALL runtime.newextram(SB)	
  0x425962		ebdf			JMP 0x425943			
func mstartm0() {
  0x425964		e807ec0100		CALL runtime.morestack_noctxt(SB)	
  0x425969		eba5			JMP runtime.mstartm0(SB)		

TEXT runtime.mexit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func mexit(osStack bool) {
  0x425970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425979		483b6110		CMPQ 0x10(CX), SP	
  0x42597d		0f8621020000		JBE 0x425ba4		
  0x425983		4883ec20		SUBQ $0x20, SP		
  0x425987		48896c2418		MOVQ BP, 0x18(SP)	
  0x42598c		488d6c2418		LEAQ 0x18(SP), BP	
	g := getg()
  0x425991		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	m := g.m
  0x42599a		488b4030		MOVQ 0x30(AX), AX	
  0x42599e		4889442410		MOVQ AX, 0x10(SP)	
	if m == &m0 {
  0x4259a3		488d0db6250800		LEAQ runtime.m0(SB), CX	
  0x4259aa		4839c1			CMPQ AX, CX		
  0x4259ad		0f848a010000		JE 0x425b3d		
	sigblock()
  0x4259b3		e888d70000		CALL runtime.sigblock(SB)	
	unminit()
  0x4259b8		e8f39cffff		CALL runtime.unminit(SB)	
  0x4259bd		488b442410		MOVQ 0x10(SP), AX		
	if m.gsignal != nil {
  0x4259c2		488b4850		MOVQ 0x50(AX), CX	
  0x4259c6		4885c9			TESTQ CX, CX		
  0x4259c9		0f8539010000		JNE 0x425b08		
	lock(&sched.lock)
  0x4259cf		488d055a1f0800		LEAQ runtime.sched+16(SB), AX	
  0x4259d6		48890424		MOVQ AX, 0(SP)			
  0x4259da		e8413bfeff		CALL runtime.lock(SB)		
  0x4259df		488b442410		MOVQ 0x10(SP), AX		
  0x4259e4		488d0d2d1c0800		LEAQ runtime.allm(SB), CX	
	for pprev := &allm; *pprev != nil; pprev = &(*pprev).alllink {
  0x4259eb		eb07			JMP 0x4259f4		
  0x4259ed		488d8a50010000		LEAQ 0x150(DX), CX	
  0x4259f4		488b11			MOVQ 0(CX), DX		
  0x4259f7		4885d2			TESTQ DX, DX		
  0x4259fa		0f8422010000		JE 0x425b22		
		if *pprev == m {
  0x425a00		4839c2			CMPQ AX, DX		
  0x425a03		75e8			JNE 0x4259ed		
			*pprev = m.alllink
  0x425a05		8b1505e00900		MOVL runtime.writeBarrier(SB), DX	
  0x425a0b		488b9850010000		MOVQ 0x150(AX), BX			
  0x425a12		85d2			TESTL DX, DX				
  0x425a14		0f85d8000000		JNE 0x425af2				
  0x425a1a		488919			MOVQ BX, 0(CX)				
  0x425a1d		0fb64c2428		MOVZX 0x28(SP), CX			
func mexit(osStack bool) {
  0x425a22		84c9			TESTL CL, CL		
	if !osStack {
  0x425a24		7477			JE 0x425a9d		
	unlock(&sched.lock)
  0x425a26		488d05031f0800		LEAQ runtime.sched+16(SB), AX	
  0x425a2d		48890424		MOVQ AX, 0(SP)			
  0x425a31		e88a3cfeff		CALL runtime.unlock(SB)		
	handoffp(releasep())
  0x425a36		e895670000		CALL runtime.releasep(SB)	
  0x425a3b		e830160000		CALL runtime.handoffp(SB)	
	lock(&sched.lock)
  0x425a40		488d05e91e0800		LEAQ runtime.sched+16(SB), AX	
  0x425a47		48890424		MOVQ AX, 0(SP)			
  0x425a4b		e8d03afeff		CALL runtime.lock(SB)		
	sched.nmfreed++
  0x425a50		48ff05011f0800		INCQ runtime.sched+56(SB)	
	checkdead()
  0x425a57		e8146a0000		CALL runtime.checkdead(SB)	
	unlock(&sched.lock)
  0x425a5c		488d05cd1e0800		LEAQ runtime.sched+16(SB), AX	
  0x425a63		48890424		MOVQ AX, 0(SP)			
  0x425a67		e8543cfeff		CALL runtime.unlock(SB)		
  0x425a6c		0fb6442428		MOVZX 0x28(SP), AX		
func mexit(osStack bool) {
  0x425a71		84c0			TESTL AL, AL		
	if osStack {
  0x425a73		740a			JE 0x425a7f		
		return
  0x425a75		488b6c2418		MOVQ 0x18(SP), BP	
  0x425a7a		4883c420		ADDQ $0x20, SP		
  0x425a7e		c3			RET			
  0x425a7f		488b442410		MOVQ 0x10(SP), AX	
	exitThread(&m.freeWait)
  0x425a84		48051c010000		ADDQ $0x11c, AX			
  0x425a8a		48890424		MOVQ AX, 0(SP)			
  0x425a8e		e84d1d0200		CALL runtime.exitThread(SB)	
}
  0x425a93		488b6c2418		MOVQ 0x18(SP), BP	
  0x425a98		4883c420		ADDQ $0x20, SP		
  0x425a9c		c3			RET			
		atomic.Store(&m.freeWait, 1)
  0x425a9d		ba01000000		MOVL $0x1, DX		
  0x425aa2		87901c010000		XCHGL DX, 0x11c(AX)	
		m.freelink = sched.freem
  0x425aa8		8b1562df0900		MOVL runtime.writeBarrier(SB), DX	
  0x425aae		488db838030000		LEAQ 0x338(AX), DI			
  0x425ab5		488b1d341f0800		MOVQ runtime.sched+208(SB), BX		
  0x425abc		85d2			TESTL DX, DX				
  0x425abe		7513			JNE 0x425ad3				
  0x425ac0		48899838030000		MOVQ BX, 0x338(AX)			
		sched.freem = m
  0x425ac7		488905221f0800		MOVQ AX, runtime.sched+208(SB)	
		m.freelink = sched.freem
  0x425ace		e953ffffff		JMP 0x425a26			
  0x425ad3		4889c2			MOVQ AX, DX			
  0x425ad6		4889d8			MOVQ BX, AX			
  0x425ad9		e8c20d0200		CALL runtime.gcWriteBarrier(SB)	
		sched.freem = m
  0x425ade		488d3d0b1f0800		LEAQ runtime.sched+208(SB), DI	
  0x425ae5		4889d0			MOVQ DX, AX			
  0x425ae8		e8b30d0200		CALL runtime.gcWriteBarrier(SB)	
		m.freelink = sched.freem
  0x425aed		e934ffffff		JMP 0x425a26		
  0x425af2		4889cf			MOVQ CX, DI		
  0x425af5		4889c2			MOVQ AX, DX		
  0x425af8		4889d8			MOVQ BX, AX		
			*pprev = m.alllink
  0x425afb		e8a00d0200		CALL runtime.gcWriteBarrier(SB)	
  0x425b00		4889d0			MOVQ DX, AX			
  0x425b03		e915ffffff		JMP 0x425a1d			
		stackfree(m.gsignal.stack)
  0x425b08		488b4108		MOVQ 0x8(CX), AX		
  0x425b0c		488b09			MOVQ 0(CX), CX			
  0x425b0f		48890c24		MOVQ CX, 0(SP)			
  0x425b13		4889442408		MOVQ AX, 0x8(SP)		
  0x425b18		e813ed0000		CALL runtime.stackfree(SB)	
  0x425b1d		e9adfeffff		JMP 0x4259cf			
	throw("m not found in allm")
  0x425b22		488d0570530400		LEAQ 0x45370(IP), AX	
  0x425b29		48890424		MOVQ AX, 0(SP)		
  0x425b2d		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x425b36		e895b6ffff		CALL runtime.throw(SB)	
  0x425b3b		0f0b			UD2			
		handoffp(releasep())
  0x425b3d		e88e660000		CALL runtime.releasep(SB)	
  0x425b42		e829150000		CALL runtime.handoffp(SB)	
		lock(&sched.lock)
  0x425b47		488d05e21d0800		LEAQ runtime.sched+16(SB), AX	
  0x425b4e		48890424		MOVQ AX, 0(SP)			
  0x425b52		e8c939feff		CALL runtime.lock(SB)		
		sched.nmfreed++
  0x425b57		48ff05fa1d0800		INCQ runtime.sched+56(SB)	
		checkdead()
  0x425b5e		e80d690000		CALL runtime.checkdead(SB)	
		unlock(&sched.lock)
  0x425b63		488d05c61d0800		LEAQ runtime.sched+16(SB), AX	
  0x425b6a		48890424		MOVQ AX, 0(SP)			
  0x425b6e		e84d3bfeff		CALL runtime.unlock(SB)		
  0x425b73		488b442410		MOVQ 0x10(SP), AX		
		notesleep(&m.park)
  0x425b78		8400			TESTB AL, 0(AX)			
  0x425b7a		480548010000		ADDQ $0x148, AX			
  0x425b80		48890424		MOVQ AX, 0(SP)			
  0x425b84		e8c73cfeff		CALL runtime.notesleep(SB)	
		throw("locked m0 woke up")
  0x425b89		488d05bc500400		LEAQ 0x450bc(IP), AX	
  0x425b90		48890424		MOVQ AX, 0(SP)		
  0x425b94		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x425b9d		e82eb6ffff		CALL runtime.throw(SB)	
  0x425ba2		0f0b			UD2			
func mexit(osStack bool) {
  0x425ba4		e8c7e90100		CALL runtime.morestack_noctxt(SB)	
  0x425ba9		e9c2fdffff		JMP runtime.mexit(SB)			

TEXT runtime.forEachP(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func forEachP(fn func(*p)) {
  0x425bb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425bb9		483b6118		CMPQ 0x18(CX), SP	
  0x425bbd		0f8670030000		JBE 0x425f33		
  0x425bc3		4883ec60		SUBQ $0x60, SP		
  0x425bc7		48896c2458		MOVQ BP, 0x58(SP)	
  0x425bcc		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x425bd1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x425bda		488b4830		MOVQ 0x30(AX), CX	
  0x425bde		ff8100010000		INCL 0x100(CX)		
	_p_ := getg().m.p.ptr()
  0x425be4		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425bed		488b4930		MOVQ 0x30(CX), CX	
  0x425bf1		488b89d0000000		MOVQ 0xd0(CX), CX	
	return _g_.m
  0x425bf8		488b4030		MOVQ 0x30(AX), AX	
  0x425bfc		4889442438		MOVQ AX, 0x38(SP)	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x425c01		48894c2450		MOVQ CX, 0x50(SP)	
	lock(&sched.lock)
  0x425c06		488d15231d0800		LEAQ runtime.sched+16(SB), DX	
  0x425c0d		48891424		MOVQ DX, 0(SP)			
  0x425c11		e80a39feff		CALL runtime.lock(SB)		
	if sched.safePointWait != 0 {
  0x425c16		8b05041e0800		MOVL runtime.sched+256(SB), AX	
  0x425c1c		85c0			TESTL AX, AX			
  0x425c1e		0f85f4020000		JNE 0x425f18			
	sched.safePointWait = gomaxprocs - 1
  0x425c24		8b0db6dc0900		MOVL runtime.gomaxprocs(SB), CX	
  0x425c2a		ffc9			DECL CX				
  0x425c2c		890dee1d0800		MOVL CX, runtime.sched+256(SB)	
	sched.safePointFn = fn
  0x425c32		8b0dd8dd0900		MOVL runtime.writeBarrier(SB), CX	
  0x425c38		85c9			TESTL CX, CX				
  0x425c3a		0f858c020000		JNE 0x425ecc				
  0x425c40		488b442468		MOVQ 0x68(SP), AX			
  0x425c45		488905cc1d0800		MOVQ AX, runtime.sched+248(SB)		
	for _, p := range allp {
  0x425c4c		488b0d651a0800		MOVQ runtime.allp+8(SB), CX	
  0x425c53		488b15561a0800		MOVQ runtime.allp(SB), DX	
  0x425c5a		488b5c2450		MOVQ 0x50(SP), BX		
  0x425c5f		31f6			XORL SI, SI			
  0x425c61		eb03			JMP 0x425c66			
  0x425c63		48ffc6			INCQ SI				
  0x425c66		4839ce			CMPQ CX, SI			
  0x425c69		7d1a			JGE 0x425c85			
  0x425c6b		488b3cf2		MOVQ 0(DX)(SI*8), DI		
		if p != _p_ {
  0x425c6f		4839df			CMPQ BX, DI		
  0x425c72		74ef			JE 0x425c63		
			atomic.Store(&p.runSafePointFn, 1)
  0x425c74		8407			TESTB AL, 0(DI)		
  0x425c76		41b801000000		MOVL $0x1, R8		
  0x425c7c		448787a0220000		XCHGL R8, 0x22a0(DI)	
  0x425c83		ebde			JMP 0x425c63		
	preemptall()
  0x425c85		e8e6730000		CALL runtime.preemptall(SB)	
	for p := sched.pidle.ptr(); p != nil; p = p.link.ptr() {
  0x425c8a		488b05d71c0800		MOVQ runtime.sched+72(SB), AX	
  0x425c91		eb04			JMP 0x425c97			
  0x425c93		488b4110		MOVQ 0x10(CX), AX		
  0x425c97		4885c0			TESTQ AX, AX			
  0x425c9a		743e			JE 0x425cda			
  0x425c9c		4889c1			MOVQ AX, CX			
		if atomic.Cas(&p.runSafePointFn, 1, 0) {
  0x425c9f		b801000000		MOVL $0x1, AX			
  0x425ca4		31db			XORL BX, BX			
  0x425ca6		f00fb199a0220000	LOCK CMPXCHGL BX, 0x22a0(CX)	
  0x425cae		400f94c6		SETE SI				
  0x425cb2		4084f6			TESTL SI, SI			
  0x425cb5		74dc			JE 0x425c93			
  0x425cb7		48894c2448		MOVQ CX, 0x48(SP)		
			fn(p)
  0x425cbc		48890c24		MOVQ CX, 0(SP)		
  0x425cc0		488b542468		MOVQ 0x68(SP), DX	
  0x425cc5		488b02			MOVQ 0(DX), AX		
  0x425cc8		ffd0			CALL AX			
			sched.safePointWait--
  0x425cca		83054f1d0800ff		ADDL $-0x1, runtime.sched+256(SB)	
  0x425cd1		488b4c2448		MOVQ 0x48(SP), CX			
  0x425cd6		31db			XORL BX, BX				
  0x425cd8		ebb9			JMP 0x425c93				
	wait := sched.safePointWait > 0
  0x425cda		8b05401d0800		MOVL runtime.sched+256(SB), AX	
  0x425ce0		8944241c		MOVL AX, 0x1c(SP)		
	unlock(&sched.lock)
  0x425ce4		488d0d451c0800		LEAQ runtime.sched+16(SB), CX	
  0x425ceb		48890c24		MOVQ CX, 0(SP)			
  0x425cef		e8cc39feff		CALL runtime.unlock(SB)		
  0x425cf4		488b442450		MOVQ 0x50(SP), AX		
	fn(_p_)
  0x425cf9		48890424		MOVQ AX, 0(SP)		
  0x425cfd		488b542468		MOVQ 0x68(SP), DX	
  0x425d02		488b02			MOVQ 0(DX), AX		
  0x425d05		ffd0			CALL AX			
	for _, p := range allp {
  0x425d07		488b05aa190800		MOVQ runtime.allp+8(SB), AX	
  0x425d0e		4889442428		MOVQ AX, 0x28(SP)		
  0x425d13		488b0d96190800		MOVQ runtime.allp(SB), CX	
  0x425d1a		48894c2440		MOVQ CX, 0x40(SP)		
  0x425d1f		31d2			XORL DX, DX			
  0x425d21		eb06			JMP 0x425d29			
  0x425d23		48ffc2			INCQ DX				
  0x425d26		4889f8			MOVQ DI, AX			
  0x425d29		4839c2			CMPQ AX, DX			
  0x425d2c		0f8d8c000000		JGE 0x425dbe			
  0x425d32		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		s := p.status
  0x425d36		8b730c			MOVL 0xc(BX), SI	
		if s == _Psyscall && p.runSafePointFn == 1 && atomic.Cas(&p.status, s, _Pidle) {
  0x425d39		83fe02			CMPL $0x2, SI			
  0x425d3c		7575			JNE 0x425db3			
  0x425d3e		8bbba0220000		MOVL 0x22a0(BX), DI		
  0x425d44		83ff01			CMPL $0x1, DI			
  0x425d47		756a			JNE 0x425db3			
  0x425d49		4889c7			MOVQ AX, DI			
  0x425d4c		89f0			MOVL SI, AX			
  0x425d4e		4531c0			XORL R8, R8			
  0x425d51		f0440fb1430c		LOCK CMPXCHGL R8, 0xc(BX)	
  0x425d57		400f94c6		SETE SI				
  0x425d5b		4084f6			TESTL SI, SI			
  0x425d5e		74c3			JE 0x425d23			
  0x425d60		4889542420		MOVQ DX, 0x20(SP)		
			if trace.enabled {
  0x425d65		0fb60564da0800		MOVZX runtime.trace+16(SB), AX	
  0x425d6c		84c0			TESTL AL, AL			
  0x425d6e		7520			JNE 0x425d90			
			p.syscalltick++
  0x425d70		ff431c			INCL 0x1c(BX)		
			handoffp(p)
  0x425d73		48891c24		MOVQ BX, 0(SP)			
  0x425d77		e8f4120000		CALL runtime.handoffp(SB)	
  0x425d7c		488b4c2440		MOVQ 0x40(SP), CX		
  0x425d81		488b542420		MOVQ 0x20(SP), DX		
  0x425d86		488b7c2428		MOVQ 0x28(SP), DI		
  0x425d8b		4531c0			XORL R8, R8			
  0x425d8e		eb93			JMP 0x425d23			
  0x425d90		48895c2430		MOVQ BX, 0x30(SP)		
				traceGoSysBlock(p)
  0x425d95		48891c24		MOVQ BX, 0(SP)				
  0x425d99		e862510100		CALL runtime.traceGoSysBlock(SB)	
  0x425d9e		488b442430		MOVQ 0x30(SP), AX			
				traceProcStop(p)
  0x425da3		48890424		MOVQ AX, 0(SP)			
  0x425da7		e844450100		CALL runtime.traceProcStop(SB)	
  0x425dac		488b5c2430		MOVQ 0x30(SP), BX		
  0x425db1		ebbd			JMP 0x425d70			
  0x425db3		4889c7			MOVQ AX, DI			
  0x425db6		4531c0			XORL R8, R8			
		if s == _Psyscall && p.runSafePointFn == 1 && atomic.Cas(&p.status, s, _Pidle) {
  0x425db9		e965ffffff		JMP 0x425d23		
  0x425dbe		8b44241c		MOVL 0x1c(SP), AX	
	wait := sched.safePointWait > 0
  0x425dc2		85c0			TESTL AX, AX		
	if wait {
  0x425dc4		0f8fc7000000		JG 0x425e91		
	if sched.safePointWait != 0 {
  0x425dca		8b05501c0800		MOVL runtime.sched+256(SB), AX	
  0x425dd0		85c0			TESTL AX, AX			
  0x425dd2		0f8525010000		JNE 0x425efd			
	for _, p := range allp {
  0x425dd8		488b05d9180800		MOVQ runtime.allp+8(SB), AX	
  0x425ddf		488b0dca180800		MOVQ runtime.allp(SB), CX	
  0x425de6		31d2			XORL DX, DX			
  0x425de8		eb03			JMP 0x425ded			
  0x425dea		48ffc2			INCQ DX				
  0x425ded		4839c2			CMPQ AX, DX			
  0x425df0		7d16			JGE 0x425e08			
  0x425df2		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		if p.runSafePointFn != 0 {
  0x425df6		8403			TESTB AL, 0(BX)		
  0x425df8		8b9ba0220000		MOVL 0x22a0(BX), BX	
  0x425dfe		85db			TESTL BX, BX		
  0x425e00		0f85dc000000		JNE 0x425ee2		
  0x425e06		ebe2			JMP 0x425dea		
	lock(&sched.lock)
  0x425e08		488d05211b0800		LEAQ runtime.sched+16(SB), AX	
  0x425e0f		48890424		MOVQ AX, 0(SP)			
  0x425e13		e80837feff		CALL runtime.lock(SB)		
	sched.safePointFn = nil
  0x425e18		8b05f2db0900		MOVL runtime.writeBarrier(SB), AX	
  0x425e1e		85c0			TESTL AX, AX				
  0x425e20		755a			JNE 0x425e7c				
  0x425e22		48c705eb1b080000000000	MOVQ $0x0, runtime.sched+248(SB)	
	unlock(&sched.lock)
  0x425e2d		488d05fc1a0800		LEAQ runtime.sched+16(SB), AX	
  0x425e34		48890424		MOVQ AX, 0(SP)			
  0x425e38		e88338feff		CALL runtime.unlock(SB)		
	_g_ := getg()
  0x425e3d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x425e46		488b4c2438		MOVQ 0x38(SP), CX	
	mp.locks--
  0x425e4b		8b9100010000		MOVL 0x100(CX), DX	
  0x425e51		8d5aff			LEAL -0x1(DX), BX	
  0x425e54		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x425e5a		83fa01			CMPL $0x1, DX		
  0x425e5d		7513			JNE 0x425e72		
  0x425e5f		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x425e66		84c9			TESTL CL, CL		
  0x425e68		7408			JE 0x425e72		
		_g_.stackguard0 = stackPreempt
  0x425e6a		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x425e72		488b6c2458		MOVQ 0x58(SP), BP	
  0x425e77		4883c460		ADDQ $0x60, SP		
  0x425e7b		c3			RET			
	sched.safePointFn = nil
  0x425e7c		488d3d951b0800		LEAQ runtime.sched+248(SB), DI	
  0x425e83		31c0			XORL AX, AX			
  0x425e85		e8160a0200		CALL runtime.gcWriteBarrier(SB)	
  0x425e8a		eba1			JMP 0x425e2d			
			preemptall()
  0x425e8c		e8df710000		CALL runtime.preemptall(SB)	
			if notetsleep(&sched.safePointNote, 100*1000) {
  0x425e91		488d05901b0800		LEAQ runtime.sched+264(SB), AX	
  0x425e98		48890424		MOVQ AX, 0(SP)			
  0x425e9c		48c7442408a0860100	MOVQ $0x186a0, 0x8(SP)		
  0x425ea5		e8563cfeff		CALL runtime.notetsleep(SB)	
  0x425eaa		0fb6442410		MOVZX 0x10(SP), AX		
  0x425eaf		84c0			TESTL AL, AL			
  0x425eb1		74d9			JE 0x425e8c			
	n.key = 0
  0x425eb3		488d056e1b0800		LEAQ runtime.sched+264(SB), AX		
  0x425eba		8400			TESTB AL, 0(AX)				
  0x425ebc		48c705611b080000000000	MOVQ $0x0, runtime.sched+264(SB)	
	if sched.safePointWait != 0 {
  0x425ec7		e9fefeffff		JMP 0x425dca		
	sched.safePointFn = fn
  0x425ecc		488d3d451b0800		LEAQ runtime.sched+248(SB), DI	
  0x425ed3		488b442468		MOVQ 0x68(SP), AX		
  0x425ed8		e8c3090200		CALL runtime.gcWriteBarrier(SB)	
  0x425edd		e96afdffff		JMP 0x425c4c			
			throw("forEachP: P did not run fn")
  0x425ee2		488d05f15c0400		LEAQ 0x45cf1(IP), AX	
  0x425ee9		48890424		MOVQ AX, 0(SP)		
  0x425eed		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x425ef6		e8d5b2ffff		CALL runtime.throw(SB)	
  0x425efb		0f0b			UD2			
		throw("forEachP: not done")
  0x425efd		488d058f4e0400		LEAQ 0x44e8f(IP), AX	
  0x425f04		48890424		MOVQ AX, 0(SP)		
  0x425f08		48c744240812000000	MOVQ $0x12, 0x8(SP)	
  0x425f11		e8bab2ffff		CALL runtime.throw(SB)	
  0x425f16		0f0b			UD2			
		throw("forEachP: sched.safePointWait != 0")
  0x425f18		488d05db6c0400		LEAQ 0x46cdb(IP), AX	
  0x425f1f		48890424		MOVQ AX, 0(SP)		
  0x425f23		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x425f2c		e89fb2ffff		CALL runtime.throw(SB)	
  0x425f31		0f0b			UD2			
func forEachP(fn func(*p)) {
  0x425f33		e8c80d0100		CALL runtime.morestackc(SB)	
  0x425f38		e973fcffff		JMP runtime.forEachP(SB)	

TEXT runtime.runSafePointFn(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func runSafePointFn() {
  0x425f40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425f49		483b6110		CMPQ 0x10(CX), SP	
  0x425f4d		0f86a4000000		JBE 0x425ff7		
  0x425f53		4883ec10		SUBQ $0x10, SP		
  0x425f57		48896c2408		MOVQ BP, 0x8(SP)	
  0x425f5c		488d6c2408		LEAQ 0x8(SP), BP	
	p := getg().m.p.ptr()
  0x425f61		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425f6a		488b4930		MOVQ 0x30(CX), CX	
  0x425f6e		488b89d0000000		MOVQ 0xd0(CX), CX	
	if !atomic.Cas(&p.runSafePointFn, 1, 0) {
  0x425f75		8401			TESTB AL, 0(CX)			
  0x425f77		b801000000		MOVL $0x1, AX			
  0x425f7c		31db			XORL BX, BX			
  0x425f7e		f00fb199a0220000	LOCK CMPXCHGL BX, 0x22a0(CX)	
  0x425f86		0f94c3			SETE BL				
  0x425f89		84db			TESTL BL, BL			
  0x425f8b		7460			JE 0x425fed			
	sched.safePointFn(p)
  0x425f8d		488b15841a0800		MOVQ runtime.sched+248(SB), DX	
  0x425f94		48890c24		MOVQ CX, 0(SP)			
  0x425f98		488b02			MOVQ 0(DX), AX			
  0x425f9b		ffd0			CALL AX				
	lock(&sched.lock)
  0x425f9d		488d058c190800		LEAQ runtime.sched+16(SB), AX	
  0x425fa4		48890424		MOVQ AX, 0(SP)			
  0x425fa8		e87335feff		CALL runtime.lock(SB)		
	sched.safePointWait--
  0x425fad		8b056d1a0800		MOVL runtime.sched+256(SB), AX	
  0x425fb3		8d48ff			LEAL -0x1(AX), CX		
  0x425fb6		890d641a0800		MOVL CX, runtime.sched+256(SB)	
	if sched.safePointWait == 0 {
  0x425fbc		83f801			CMPL $0x1, AX		
  0x425fbf		741a			JE 0x425fdb		
	unlock(&sched.lock)
  0x425fc1		488d0568190800		LEAQ runtime.sched+16(SB), AX	
  0x425fc8		48890424		MOVQ AX, 0(SP)			
  0x425fcc		e8ef36feff		CALL runtime.unlock(SB)		
}
  0x425fd1		488b6c2408		MOVQ 0x8(SP), BP	
  0x425fd6		4883c410		ADDQ $0x10, SP		
  0x425fda		c3			RET			
		notewakeup(&sched.safePointNote)
  0x425fdb		488d05461a0800		LEAQ runtime.sched+264(SB), AX	
  0x425fe2		48890424		MOVQ AX, 0(SP)			
  0x425fe6		e8a537feff		CALL runtime.notewakeup(SB)	
  0x425feb		ebd4			JMP 0x425fc1			
		return
  0x425fed		488b6c2408		MOVQ 0x8(SP), BP	
  0x425ff2		4883c410		ADDQ $0x10, SP		
  0x425ff6		c3			RET			
func runSafePointFn() {
  0x425ff7		e874e50100		CALL runtime.morestack_noctxt(SB)	
  0x425ffc		e93fffffff		JMP runtime.runSafePointFn(SB)		

TEXT runtime.allocm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func allocm(_p_ *p, fn func()) *m {
  0x426010		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426019		483b6110		CMPQ 0x10(CX), SP	
  0x42601d		0f8696020000		JBE 0x4262b9		
  0x426023		4883ec38		SUBQ $0x38, SP		
  0x426027		48896c2430		MOVQ BP, 0x30(SP)	
  0x42602c		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x426031		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42603a		4889442428		MOVQ AX, 0x28(SP)	
	_g_.m.locks++ // disable GC because it can be called from sysmon
  0x42603f		488b4830		MOVQ 0x30(AX), CX	
  0x426043		ff8100010000		INCL 0x100(CX)		
	if _g_.m.p == 0 {
  0x426049		488b4830		MOVQ 0x30(AX), CX	
  0x42604d		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x426054		4885c9			TESTQ CX, CX		
  0x426057		0f8444020000		JE 0x4262a1		
	if sched.freem != nil {
  0x42605d		488b0d8c190800		MOVQ runtime.sched+208(SB), CX	
  0x426064		4885c9			TESTQ CX, CX			
  0x426067		0f84bb000000		JE 0x426128			
		lock(&sched.lock)
  0x42606d		488d05bc180800		LEAQ runtime.sched+16(SB), AX	
  0x426074		48890424		MOVQ AX, 0(SP)			
  0x426078		e8a334feff		CALL runtime.lock(SB)		
		for freem := sched.freem; freem != nil; {
  0x42607d		488b056c190800		MOVQ runtime.sched+208(SB), AX	
  0x426084		31c9			XORL CX, CX			
  0x426086		eb06			JMP 0x42608e			
  0x426088		4889c1			MOVQ AX, CX			
  0x42608b		4889d0			MOVQ DX, AX			
  0x42608e		4885c0			TESTQ AX, AX			
  0x426091		7470			JE 0x426103			
			if freem.freeWait != 0 {
  0x426093		8b901c010000		MOVL 0x11c(AX), DX	
  0x426099		85d2			TESTL DX, DX		
  0x42609b		7431			JE 0x4260ce		
				next := freem.freelink
  0x42609d		488b9038030000		MOVQ 0x338(AX), DX	
  0x4260a4		488db838030000		LEAQ 0x338(AX), DI	
				freem.freelink = newList
  0x4260ab		8b1d5fd90900		MOVL runtime.writeBarrier(SB), BX	
  0x4260b1		85db			TESTL BX, BX				
  0x4260b3		7509			JNE 0x4260be				
  0x4260b5		48898838030000		MOVQ CX, 0x338(AX)			
  0x4260bc		ebca			JMP 0x426088				
  0x4260be		4889c3			MOVQ AX, BX				
  0x4260c1		4889c8			MOVQ CX, AX				
  0x4260c4		e8d7070200		CALL runtime.gcWriteBarrier(SB)		
  0x4260c9		4889d8			MOVQ BX, AX				
  0x4260cc		ebba			JMP 0x426088				
  0x4260ce		4889442420		MOVQ AX, 0x20(SP)			
  0x4260d3		48894c2410		MOVQ CX, 0x10(SP)			
			stackfree(freem.g0.stack)
  0x4260d8		488b08			MOVQ 0(AX), CX			
  0x4260db		488b11			MOVQ 0(CX), DX			
  0x4260de		488b4908		MOVQ 0x8(CX), CX		
  0x4260e2		48891424		MOVQ DX, 0(SP)			
  0x4260e6		48894c2408		MOVQ CX, 0x8(SP)		
  0x4260eb		e840e70000		CALL runtime.stackfree(SB)	
  0x4260f0		488b442420		MOVQ 0x20(SP), AX		
			freem = freem.freelink
  0x4260f5		488b9038030000		MOVQ 0x338(AX), DX	
  0x4260fc		488b442410		MOVQ 0x10(SP), AX	
  0x426101		eb85			JMP 0x426088		
		sched.freem = newList
  0x426103		8b1507d90900		MOVL runtime.writeBarrier(SB), DX	
  0x426109		85d2			TESTL DX, DX				
  0x42610b		0f857c010000		JNE 0x42628d				
  0x426111		48890dd8180800		MOVQ CX, runtime.sched+208(SB)		
		unlock(&sched.lock)
  0x426118		488d0511180800		LEAQ runtime.sched+16(SB), AX	
  0x42611f		48890424		MOVQ AX, 0(SP)			
  0x426123		e89835feff		CALL runtime.unlock(SB)		
	mp := new(m)
  0x426128		488d05f1340400		LEAQ 0x434f1(IP), AX		
  0x42612f		48890424		MOVQ AX, 0(SP)			
  0x426133		e8e84ffeff		CALL runtime.newobject(SB)	
  0x426138		488b442408		MOVQ 0x8(SP), AX		
	mp.mstartfn = fn
  0x42613d		8b0dcdd80900		MOVL runtime.writeBarrier(SB), CX	
  0x426143		488db8b8000000		LEAQ 0xb8(AX), DI			
  0x42614a		85c9			TESTL CX, CX				
  0x42614c		0f8526010000		JNE 0x426278				
  0x426152		488b4c2448		MOVQ 0x48(SP), CX			
  0x426157		488988b8000000		MOVQ CX, 0xb8(AX)			
  0x42615e		4889442418		MOVQ AX, 0x18(SP)			
	mcommoninit(mp)
  0x426163		48890424		MOVQ AX, 0(SP)			
  0x426167		e8f4dbffff		CALL runtime.mcommoninit(SB)	
	if iscgo || GOOS == "solaris" || GOOS == "windows" || GOOS == "plan9" {
  0x42616c		0fb60539d70900		MOVZX runtime.iscgo(SB), AX	
  0x426173		84c0			TESTL AL, AL			
  0x426175		0f84c0000000		JE 0x42623b			
		mp.g0 = malg(-1)
  0x42617b		c70424ffffffff		MOVL $-0x1, 0(SP)			
  0x426182		e8b9400000		CALL runtime.malg(SB)			
  0x426187		8b0583d80900		MOVL runtime.writeBarrier(SB), AX	
  0x42618d		488b4c2408		MOVQ 0x8(SP), CX			
  0x426192		85c0			TESTL AX, AX				
  0x426194		0f858c000000		JNE 0x426226				
  0x42619a		488b442418		MOVQ 0x18(SP), AX			
  0x42619f		488908			MOVQ CX, 0(AX)				
	mp.g0.m = mp
  0x4261a2		488b08			MOVQ 0(AX), CX				
  0x4261a5		8401			TESTB AL, 0(CX)				
  0x4261a7		8b1563d80900		MOVL runtime.writeBarrier(SB), DX	
  0x4261ad		488d7930		LEAQ 0x30(CX), DI			
  0x4261b1		85d2			TESTL DX, DX				
  0x4261b3		756a			JNE 0x42621f				
  0x4261b5		48894130		MOVQ AX, 0x30(CX)			
  0x4261b9		488b4c2428		MOVQ 0x28(SP), CX			
	if _p_ == _g_.m.p.ptr() {
  0x4261be		488b5130		MOVQ 0x30(CX), DX	
  0x4261c2		488b92d0000000		MOVQ 0xd0(DX), DX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x4261c9		488b5c2440		MOVQ 0x40(SP), BX	
	if _p_ == _g_.m.p.ptr() {
  0x4261ce		4839d3			CMPQ DX, BX		
  0x4261d1		743b			JE 0x42620e		
	_g_.m.locks--
  0x4261d3		488b5130		MOVQ 0x30(CX), DX	
  0x4261d7		838200010000ff		ADDL $-0x1, 0x100(DX)	
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
  0x4261de		488b5130		MOVQ 0x30(CX), DX	
  0x4261e2		8b9200010000		MOVL 0x100(DX), DX	
  0x4261e8		85d2			TESTL DX, DX		
  0x4261ea		7513			JNE 0x4261ff		
  0x4261ec		0fb691c0000000		MOVZX 0xc0(CX), DX	
  0x4261f3		84d2			TESTL DL, DL		
  0x4261f5		7408			JE 0x4261ff		
		_g_.stackguard0 = stackPreempt
  0x4261f7		48c74110defaffff	MOVQ $-0x522, 0x10(CX)	
	return mp
  0x4261ff		4889442450		MOVQ AX, 0x50(SP)	
  0x426204		488b6c2430		MOVQ 0x30(SP), BP	
  0x426209		4883c438		ADDQ $0x38, SP		
  0x42620d		c3			RET			
		releasep()
  0x42620e		e8bd5f0000		CALL runtime.releasep(SB)	
  0x426213		488b442418		MOVQ 0x18(SP), AX		
  0x426218		488b4c2428		MOVQ 0x28(SP), CX		
  0x42621d		ebb4			JMP 0x4261d3			
	mp.g0.m = mp
  0x42621f		e87c060200		CALL runtime.gcWriteBarrier(SB)	
  0x426224		eb93			JMP 0x4261b9			
  0x426226		488b7c2418		MOVQ 0x18(SP), DI		
  0x42622b		4889c8			MOVQ CX, AX			
		mp.g0 = malg(-1)
  0x42622e		e86d060200		CALL runtime.gcWriteBarrier(SB)	
  0x426233		4889f8			MOVQ DI, AX			
  0x426236		e967ffffff		JMP 0x4261a2			
		mp.g0 = malg(8192 * sys.StackGuardMultiplier)
  0x42623b		c7042400200000		MOVL $0x2000, 0(SP)			
  0x426242		e8f93f0000		CALL runtime.malg(SB)			
  0x426247		8b05c3d70900		MOVL runtime.writeBarrier(SB), AX	
  0x42624d		488b4c2408		MOVQ 0x8(SP), CX			
  0x426252		85c0			TESTL AX, AX				
  0x426254		750d			JNE 0x426263				
  0x426256		488b442418		MOVQ 0x18(SP), AX			
  0x42625b		488908			MOVQ CX, 0(AX)				
  0x42625e		e93fffffff		JMP 0x4261a2				
  0x426263		488b7c2418		MOVQ 0x18(SP), DI			
  0x426268		4889c8			MOVQ CX, AX				
  0x42626b		e830060200		CALL runtime.gcWriteBarrier(SB)		
  0x426270		4889f8			MOVQ DI, AX				
  0x426273		e92affffff		JMP 0x4261a2				
  0x426278		4889c1			MOVQ AX, CX				
  0x42627b		488b442448		MOVQ 0x48(SP), AX			
	mp.mstartfn = fn
  0x426280		e81b060200		CALL runtime.gcWriteBarrier(SB)	
  0x426285		4889c8			MOVQ CX, AX			
  0x426288		e9d1feffff		JMP 0x42615e			
		sched.freem = newList
  0x42628d		488d3d5c170800		LEAQ runtime.sched+208(SB), DI	
  0x426294		4889c8			MOVQ CX, AX			
  0x426297		e804060200		CALL runtime.gcWriteBarrier(SB)	
  0x42629c		e977feffff		JMP 0x426118			
  0x4262a1		488b442440		MOVQ 0x40(SP), AX		
		acquirep(_p_) // temporarily borrow p for mallocs in this function
  0x4262a6		48890424		MOVQ AX, 0(SP)			
  0x4262aa		e8315d0000		CALL runtime.acquirep(SB)	
  0x4262af		488b442428		MOVQ 0x28(SP), AX		
  0x4262b4		e9a4fdffff		JMP 0x42605d			
func allocm(_p_ *p, fn func()) *m {
  0x4262b9		e8b2e20100		CALL runtime.morestack_noctxt(SB)	
  0x4262be		e94dfdffff		JMP runtime.allocm(SB)			

TEXT runtime.needm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func needm(x byte) {
  0x4262d0		4883ec38		SUBQ $0x38, SP		
  0x4262d4		48896c2430		MOVQ BP, 0x30(SP)	
  0x4262d9		488d6c2430		LEAQ 0x30(SP), BP	
	if iscgo && !cgoHasExtraM {
  0x4262de		0fb605c7d50900		MOVZX runtime.iscgo(SB), AX		
  0x4262e5		84c0			TESTL AL, AL				
  0x4262e7		740f			JE 0x4262f8				
  0x4262e9		0fb605b2d50900		MOVZX runtime.cgoHasExtraM(SB), AX	
  0x4262f0		84c0			TESTL AL, AL				
  0x4262f2		0f84de000000		JE 0x4263d6				
	mp := lockextra(false)
  0x4262f8		c6042400		MOVB $0x0, 0(SP)		
  0x4262fc		e87f040000		CALL runtime.lockextra(SB)	
  0x426301		488b442408		MOVQ 0x8(SP), AX		
  0x426306		4889442420		MOVQ AX, 0x20(SP)		
	mp.needextram = mp.schedlink == 0
  0x42630b		488d8828010000		LEAQ 0x128(AX), CX	
  0x426312		488b9058010000		MOVQ 0x158(AX), DX	
  0x426319		4885d2			TESTQ DX, DX		
  0x42631c		0f9401			SETE 0(CX)		
	extraMCount--
  0x42631f		8305a2d50900ff		ADDL $-0x1, runtime.extraMCount(SB)	
	unlockextra(mp.schedlink.ptr())
  0x426326		488b8858010000		MOVQ 0x158(AX), CX	
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x42632d		48894c2428		MOVQ CX, 0x28(SP)		
  0x426332		488d151fd60900		LEAQ runtime.extram(SB), DX	
  0x426339		48870a			XCHGQ CX, 0(DX)			
	msigsave(mp)
  0x42633c		48890424		MOVQ AX, 0(SP)			
  0x426340		e87bcd0000		CALL runtime.msigsave(SB)	
	sigblock()
  0x426345		e8f6cd0000		CALL runtime.sigblock(SB)	
  0x42634a		488b442420		MOVQ 0x20(SP), AX		
	setg(mp.g0)
  0x42634f		488b08			MOVQ 0(AX), CX		
  0x426352		48890c24		MOVQ CX, 0(SP)		
  0x426356		e855f90100		CALL runtime.setg(SB)	
	_g_ := getg()
  0x42635b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&x))) + 1024
  0x426364		488d4c2440		LEAQ 0x40(SP), CX	
  0x426369		4881c100040000		ADDQ $0x400, CX		
  0x426370		48894808		MOVQ CX, 0x8(AX)	
	_g_.stack.lo = uintptr(noescape(unsafe.Pointer(&x))) - 32*1024
  0x426374		488d4c2440		LEAQ 0x40(SP), CX	
  0x426379		488d910080ffff		LEAQ 0xffff8000(CX), DX	
  0x426380		488910			MOVQ DX, 0(AX)		
	_g_.stackguard0 = _g_.stack.lo + _StackGuard
  0x426383		4881c17083ffff		ADDQ $-0x7c90, CX	
  0x42638a		48894810		MOVQ CX, 0x10(AX)	
	asminit()
  0x42638e		e89ddf0100		CALL runtime.asminit(SB)	
	minit()
  0x426393		e8c892ffff		CALL runtime.minit(SB)	
  0x426398		488b442420		MOVQ 0x20(SP), AX	
	casgstatus(mp.curg, _Gdead, _Gsyscall)
  0x42639d		488b80c0000000		MOVQ 0xc0(AX), AX		
  0x4263a4		48890424		MOVQ AX, 0(SP)			
  0x4263a8		48b80600000003000000	MOVQ $0x300000006, AX		
  0x4263b2		4889442408		MOVQ AX, 0x8(SP)		
  0x4263b7		e8c4e6ffff		CALL runtime.casgstatus(SB)	
	atomic.Xadd(&sched.ngsys, -1)
  0x4263bc		b8ffffffff		MOVL $-0x1, AX			
  0x4263c1		488d0d98150800		LEAQ runtime.sched+64(SB), CX	
  0x4263c8		f00fc101		LOCK XADDL AX, 0(CX)		
}
  0x4263cc		488b6c2430		MOVQ 0x30(SP), BP	
  0x4263d1		4883c438		ADDQ $0x38, SP		
  0x4263d5		c3			RET			
		write(2, unsafe.Pointer(&earlycgocallback[0]), int32(len(earlycgocallback)))
  0x4263d6		488b056bf70700		MOVQ runtime.earlycgocallback+8(SB), AX	
  0x4263dd		488b0d5cf70700		MOVQ runtime.earlycgocallback(SB), CX	
  0x4263e4		4885c0			TESTQ AX, AX				
  0x4263e7		7627			JBE 0x426410				
  0x4263e9		48894c2408		MOVQ CX, 0x8(SP)			
  0x4263ee		48c7042402000000	MOVQ $0x2, 0(SP)			
  0x4263f6		89442410		MOVL AX, 0x10(SP)			
  0x4263fa		e851140200		CALL runtime.write(SB)			
		exit(1)
  0x4263ff		c7042401000000		MOVL $0x1, 0(SP)	
  0x426406		e8c5130200		CALL runtime.exit(SB)	
  0x42640b		e9e8feffff		JMP 0x4262f8		
		write(2, unsafe.Pointer(&earlycgocallback[0]), int32(len(earlycgocallback)))
  0x426410		e82b96ffff		CALL runtime.panicindex(SB)	
  0x426415		0f0b			UD2				

TEXT runtime.newextram(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func newextram() {
  0x426420		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426429		483b6110		CMPQ 0x10(CX), SP	
  0x42642d		7673			JBE 0x4264a2		
  0x42642f		4883ec28		SUBQ $0x28, SP		
  0x426433		48896c2420		MOVQ BP, 0x20(SP)	
  0x426438		488d6c2420		LEAQ 0x20(SP), BP	
	c := atomic.Xchg(&extraMWaiters, 0)
  0x42643d		31c0			XORL AX, AX				
  0x42643f		488d0d86d40900		LEAQ runtime.extraMWaiters(SB), CX	
  0x426446		8701			XCHGL AX, 0(CX)				
	if c > 0 {
  0x426448		85c0			TESTL AX, AX		
  0x42644a		762a			JBE 0x426476		
  0x42644c		89442414		MOVL AX, 0x14(SP)	
  0x426450		31c9			XORL CX, CX		
		for i := uint32(0); i < c; i++ {
  0x426452		eb14			JMP 0x426468		
  0x426454		894c2410		MOVL CX, 0x10(SP)	
			oneNewExtraM()
  0x426458		e853000000		CALL runtime.oneNewExtraM(SB)	
  0x42645d		8b442410		MOVL 0x10(SP), AX		
		for i := uint32(0); i < c; i++ {
  0x426461		8d4801			LEAL 0x1(AX), CX	
  0x426464		8b442414		MOVL 0x14(SP), AX	
  0x426468		39c1			CMPL AX, CX		
  0x42646a		72e8			JB 0x426454		
  0x42646c		488b6c2420		MOVQ 0x20(SP), BP	
  0x426471		4883c428		ADDQ $0x28, SP		
  0x426475		c3			RET			
		mp := lockextra(true)
  0x426476		c6042401		MOVB $0x1, 0(SP)		
  0x42647a		e801030000		CALL runtime.lockextra(SB)	
  0x42647f		488b442408		MOVQ 0x8(SP), AX		
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x426484		4889442418		MOVQ AX, 0x18(SP)		
  0x426489		4889c1			MOVQ AX, CX			
  0x42648c		488d15c5d40900		LEAQ runtime.extram(SB), DX	
  0x426493		488702			XCHGQ AX, 0(DX)			
		if mp == nil {
  0x426496		4885c9			TESTQ CX, CX		
  0x426499		75d1			JNE 0x42646c		
			oneNewExtraM()
  0x42649b		e810000000		CALL runtime.oneNewExtraM(SB)	
  0x4264a0		ebca			JMP 0x42646c			
func newextram() {
  0x4264a2		e8c9e00100		CALL runtime.morestack_noctxt(SB)	
  0x4264a7		e974ffffff		JMP runtime.newextram(SB)		

TEXT runtime.oneNewExtraM(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func oneNewExtraM() {
  0x4264b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4264b9		483b6110		CMPQ 0x10(CX), SP	
  0x4264bd		0f86c1010000		JBE 0x426684		
  0x4264c3		4883ec48		SUBQ $0x48, SP		
  0x4264c7		48896c2440		MOVQ BP, 0x40(SP)	
  0x4264cc		488d6c2440		LEAQ 0x40(SP), BP	
	mp := allocm(nil, nil)
  0x4264d1		0f57c0			XORPS X0, X0		
  0x4264d4		0f110424		MOVUPS X0, 0(SP)	
  0x4264d8		e833fbffff		CALL runtime.allocm(SB)	
  0x4264dd		488b442410		MOVQ 0x10(SP), AX	
  0x4264e2		4889442418		MOVQ AX, 0x18(SP)	
	gp := malg(4096)
  0x4264e7		c7042400100000		MOVL $0x1000, 0(SP)	
  0x4264ee		e84d3d0000		CALL runtime.malg(SB)	
  0x4264f3		488b442408		MOVQ 0x8(SP), AX	
  0x4264f8		4889442420		MOVQ AX, 0x20(SP)	
	gp.sched.pc = funcPC(goexit) + sys.PCQuantum
  0x4264fd		488d0ddc080300		LEAQ 0x308dc(IP), CX	
  0x426504		48894c2430		MOVQ CX, 0x30(SP)	
  0x426509		488d0da07b0400		LEAQ 0x47ba0(IP), CX	
  0x426510		48894c2438		MOVQ CX, 0x38(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x426515		8401			TESTB AL, 0(CX)		
  0x426517		488d4c2438		LEAQ 0x38(SP), CX	
  0x42651c		8401			TESTB AL, 0(CX)		
  0x42651e		488b0d8b7b0400		MOVQ 0x47b8b(IP), CX	
	gp.sched.pc = funcPC(goexit) + sys.PCQuantum
  0x426525		48ffc1			INCQ CX			
  0x426528		48894840		MOVQ CX, 0x40(AX)	
	gp.sched.sp = gp.stack.hi
  0x42652c		488b4808		MOVQ 0x8(AX), CX	
	gp.sched.sp -= 4 * sys.RegSize // extra space in case of reads slightly beyond frame
  0x426530		4883c1e0		ADDQ $-0x20, CX		
  0x426534		48894838		MOVQ CX, 0x38(AX)	
	gp.sched.lr = 0
  0x426538		48c7406000000000	MOVQ $0x0, 0x60(AX)	
  0x426540		4889c1			MOVQ AX, CX		
	gp.sched.g = guintptr(unsafe.Pointer(gp))
  0x426543		48894148		MOVQ AX, 0x48(CX)	
	gp.syscallpc = gp.sched.pc
  0x426547		488b4140		MOVQ 0x40(CX), AX	
  0x42654b		48894178		MOVQ AX, 0x78(CX)	
	gp.syscallsp = gp.sched.sp
  0x42654f		488b4138		MOVQ 0x38(CX), AX	
  0x426553		48894170		MOVQ AX, 0x70(CX)	
	gp.stktopsp = gp.sched.sp
  0x426557		488b4138		MOVQ 0x38(CX), AX	
  0x42655b		48898180000000		MOVQ AX, 0x80(CX)	
	gp.gcscanvalid = true
  0x426562		c681c400000001		MOVB $0x1, 0xc4(CX)	
	gp.gcscandone = true
  0x426569		c681c300000001		MOVB $0x1, 0xc3(CX)	
	casgstatus(gp, _Gidle, _Gdead)
  0x426570		48890c24		MOVQ CX, 0(SP)			
  0x426574		48b80000000006000000	MOVQ $0x600000000, AX		
  0x42657e		4889442408		MOVQ AX, 0x8(SP)		
  0x426583		e8f8e4ffff		CALL runtime.casgstatus(SB)	
	gp.m = mp
  0x426588		8b0582d40900		MOVL runtime.writeBarrier(SB), AX	
  0x42658e		488b4c2420		MOVQ 0x20(SP), CX			
  0x426593		488d7930		LEAQ 0x30(CX), DI			
  0x426597		85c0			TESTL AX, AX				
  0x426599		0f85d3000000		JNE 0x426672				
  0x42659f		488b542418		MOVQ 0x18(SP), DX			
  0x4265a4		48895130		MOVQ DX, 0x30(CX)			
	mp.curg = gp
  0x4265a8		8402			TESTB AL, 0(DX)				
  0x4265aa		8b1d60d40900		MOVL runtime.writeBarrier(SB), BX	
  0x4265b0		488dbac0000000		LEAQ 0xc0(DX), DI			
  0x4265b7		85db			TESTL BX, BX				
  0x4265b9		0f85a6000000		JNE 0x426665				
  0x4265bf		48898ac0000000		MOVQ CX, 0xc0(DX)			
	mp.lockedInt++
  0x4265c6		ff82f8020000		INCL 0x2f8(DX)		
	mp.lockedg.set(gp)
  0x4265cc		488d8268010000		LEAQ 0x168(DX), AX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4265d3		8400			TESTB AL, 0(AX)		
  0x4265d5		4889c8			MOVQ CX, AX		
  0x4265d8		48898a68010000		MOVQ CX, 0x168(DX)	
	gp.lockedm.set(mp)
  0x4265df		488d88e0000000		LEAQ 0xe0(AX), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x4265e6		8401			TESTB AL, 0(CX)		
  0x4265e8		488990e0000000		MOVQ DX, 0xe0(AX)	
	gp.goid = int64(atomic.Xadd64(&sched.goidgen, 1))
  0x4265ef		ba01000000		MOVL $0x1, DX			
  0x4265f4		488d1d25130800		LEAQ runtime.sched(SB), BX	
  0x4265fb		f0480fc113		LOCK XADDQ DX, 0(BX)		
  0x426600		48ffc2			INCQ DX				
  0x426603		48899098000000		MOVQ DX, 0x98(AX)		
	allgadd(gp)
  0x42660a		48890424		MOVQ AX, 0(SP)			
  0x42660e		e80dd3ffff		CALL runtime.allgadd(SB)	
	atomic.Xadd(&sched.ngsys, +1)
  0x426613		b801000000		MOVL $0x1, AX			
  0x426618		488d0d41130800		LEAQ runtime.sched+64(SB), CX	
  0x42661f		f00fc101		LOCK XADDL AX, 0(CX)		
	mnext := lockextra(true)
  0x426623		c6042401		MOVB $0x1, 0(SP)		
  0x426627		e854010000		CALL runtime.lockextra(SB)	
  0x42662c		488b442418		MOVQ 0x18(SP), AX		
	mp.schedlink.set(mnext)
  0x426631		488d8858010000		LEAQ 0x158(AX), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x426638		8401			TESTB AL, 0(CX)		
	mnext := lockextra(true)
  0x42663a		488b4c2408		MOVQ 0x8(SP), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42663f		48898858010000		MOVQ CX, 0x158(AX)	
	extraMCount++
  0x426646		ff057cd20900		INCL runtime.extraMCount(SB)	
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x42664c		4889442428		MOVQ AX, 0x28(SP)		
  0x426651		488d0d00d30900		LEAQ runtime.extram(SB), CX	
  0x426658		488701			XCHGQ AX, 0(CX)			
  0x42665b		488b6c2440		MOVQ 0x40(SP), BP		
  0x426660		4883c448		ADDQ $0x48, SP			
  0x426664		c3			RET				
  0x426665		4889c8			MOVQ CX, AX			
	mp.curg = gp
  0x426668		e833020200		CALL runtime.gcWriteBarrier(SB)	
  0x42666d		e954ffffff		JMP 0x4265c6			
  0x426672		488b442418		MOVQ 0x18(SP), AX		
	gp.m = mp
  0x426677		e824020200		CALL runtime.gcWriteBarrier(SB)	
  0x42667c		4889c2			MOVQ AX, DX			
  0x42667f		e924ffffff		JMP 0x4265a8			
func oneNewExtraM() {
  0x426684		e8e7de0100		CALL runtime.morestack_noctxt(SB)	
  0x426689		e922feffff		JMP runtime.oneNewExtraM(SB)		

TEXT runtime.dropm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func dropm() {
  0x426690		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426699		483b6110		CMPQ 0x10(CX), SP	
  0x42669d		0f86cc000000		JBE 0x42676f		
  0x4266a3		4883ec30		SUBQ $0x30, SP		
  0x4266a7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4266ac		488d6c2428		LEAQ 0x28(SP), BP	
	mp := getg().m
  0x4266b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4266ba		488b4030		MOVQ 0x30(AX), AX	
  0x4266be		4889442418		MOVQ AX, 0x18(SP)	
	casgstatus(mp.curg, _Gsyscall, _Gdead)
  0x4266c3		488b88c0000000		MOVQ 0xc0(AX), CX		
  0x4266ca		48890c24		MOVQ CX, 0(SP)			
  0x4266ce		48b90300000006000000	MOVQ $0x600000003, CX		
  0x4266d8		48894c2408		MOVQ CX, 0x8(SP)		
  0x4266dd		e89ee3ffff		CALL runtime.casgstatus(SB)	
	atomic.Xadd(&sched.ngsys, +1)
  0x4266e2		b801000000		MOVL $0x1, AX			
  0x4266e7		488d0d72120800		LEAQ runtime.sched+64(SB), CX	
  0x4266ee		f00fc101		LOCK XADDL AX, 0(CX)		
	sigmask := mp.sigmask
  0x4266f2		488b442418		MOVQ 0x18(SP), AX	
  0x4266f7		488b8880000000		MOVQ 0x80(AX), CX	
  0x4266fe		48894c2410		MOVQ CX, 0x10(SP)	
	sigblock()
  0x426703		e838ca0000		CALL runtime.sigblock(SB)	
	unminit()
  0x426708		e8a38fffff		CALL runtime.unminit(SB)	
	mnext := lockextra(true)
  0x42670d		c6042401		MOVB $0x1, 0(SP)		
  0x426711		e86a000000		CALL runtime.lockextra(SB)	
  0x426716		488b442408		MOVQ 0x8(SP), AX		
	extraMCount++
  0x42671b		ff05a7d10900		INCL runtime.extraMCount(SB)	
  0x426721		488b4c2418		MOVQ 0x18(SP), CX		
	mp.schedlink.set(mnext)
  0x426726		488d9158010000		LEAQ 0x158(CX), DX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42672d		8402			TESTB AL, 0(DX)		
  0x42672f		48898158010000		MOVQ AX, 0x158(CX)	
	setg(nil)
  0x426736		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x42673e		e86df50100		CALL runtime.setg(SB)	
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x426743		488b442418		MOVQ 0x18(SP), AX		
  0x426748		4889442420		MOVQ AX, 0x20(SP)		
  0x42674d		488d0d04d20900		LEAQ runtime.extram(SB), CX	
  0x426754		488701			XCHGQ AX, 0(CX)			
	msigrestore(sigmask)
  0x426757		488b442410		MOVQ 0x10(SP), AX		
  0x42675c		48890424		MOVQ AX, 0(SP)			
  0x426760		e89bc90000		CALL runtime.msigrestore(SB)	
}
  0x426765		488b6c2428		MOVQ 0x28(SP), BP	
  0x42676a		4883c430		ADDQ $0x30, SP		
  0x42676e		c3			RET			
func dropm() {
  0x42676f		e8fcdd0100		CALL runtime.morestack_noctxt(SB)	
  0x426774		e917ffffff		JMP runtime.dropm(SB)			

TEXT runtime.lockextra(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func lockextra(nilokay bool) *m {
  0x426780		4883ec18		SUBQ $0x18, SP		
  0x426784		48896c2410		MOVQ BP, 0x10(SP)	
  0x426789		488d6c2410		LEAQ 0x10(SP), BP	
  0x42678e		31c0			XORL AX, AX		
	for {
  0x426790		8844240f		MOVB AL, 0xf(SP)	
		old := atomic.Loaduintptr(&extram)
  0x426794		488b0dbdd10900		MOVQ runtime.extram(SB), CX	
		if old == locked {
  0x42679b		4883f901		CMPQ $0x1, CX		
  0x42679f		0f8481000000		JE 0x426826		
		if old == 0 && !nilokay {
  0x4267a5		4885c9			TESTQ CX, CX		
  0x4267a8		7575			JNE 0x42681f		
  0x4267aa		0fb65c2420		MOVZX 0x20(SP), BX	
func lockextra(nilokay bool) *m {
  0x4267af		84db			TESTL BL, BL		
		if old == 0 && !nilokay {
  0x4267b1		7443			JE 0x4267f6		
  0x4267b3		4889c8			MOVQ CX, AX		
		if atomic.Casuintptr(&extram, old, locked) {
  0x4267b6		488d359bd10900		LEAQ runtime.extram(SB), SI	
  0x4267bd		bf01000000		MOVL $0x1, DI			
  0x4267c2		f0480fb13e		LOCK CMPXCHGQ DI, 0(SI)		
  0x4267c7		410f94c0		SETE R8				
  0x4267cb		4584c0			TESTL R8, R8			
  0x4267ce		7517			JNE 0x4267e7			
		yield()
  0x4267d0		488b05b9790400		MOVQ 0x479b9(IP), AX	
  0x4267d7		488d15b2790400		LEAQ 0x479b2(IP), DX	
  0x4267de		ffd0			CALL AX			
  0x4267e0		0fb644240f		MOVZX 0xf(SP), AX	
		continue
  0x4267e5		eba9			JMP 0x426790		
			return (*m)(unsafe.Pointer(old))
  0x4267e7		48894c2428		MOVQ CX, 0x28(SP)	
  0x4267ec		488b6c2410		MOVQ 0x10(SP), BP	
  0x4267f1		4883c418		ADDQ $0x18, SP		
  0x4267f5		c3			RET			
			if !incr {
  0x4267f6		84c0			TESTL AL, AL		
  0x4267f8		7413			JE 0x42680d		
			usleep(1)
  0x4267fa		c7042401000000		MOVL $0x1, 0(SP)	
  0x426801		e8aa100200		CALL runtime.usleep(SB)	
  0x426806		b801000000		MOVL $0x1, AX		
			continue
  0x42680b		eb83			JMP 0x426790		
				atomic.Xadd(&extraMWaiters, 1)
  0x42680d		b801000000		MOVL $0x1, AX				
  0x426812		488d0db3d00900		LEAQ runtime.extraMWaiters(SB), CX	
  0x426819		f00fc101		LOCK XADDL AX, 0(CX)			
				incr = true
  0x42681d		ebdb			JMP 0x4267fa		
  0x42681f		0fb65c2420		MOVZX 0x20(SP), BX	
		if old == 0 && !nilokay {
  0x426824		eb8d			JMP 0x4267b3		
			yield()
  0x426826		488b0563790400		MOVQ 0x47963(IP), AX	
  0x42682d		488d155c790400		LEAQ 0x4795c(IP), DX	
  0x426834		ffd0			CALL AX			
  0x426836		0fb644240f		MOVZX 0xf(SP), AX	
			continue
  0x42683b		e950ffffff		JMP 0x426790		

TEXT runtime.newm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func newm(fn func(), _p_ *p) {
  0x426840		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426849		483b6110		CMPQ 0x10(CX), SP	
  0x42684d		0f8628010000		JBE 0x42697b		
  0x426853		4883ec28		SUBQ $0x28, SP		
  0x426857		48896c2420		MOVQ BP, 0x20(SP)	
  0x42685c		488d6c2420		LEAQ 0x20(SP), BP	
  0x426861		488b442438		MOVQ 0x38(SP), AX	
	mp := allocm(_p_, fn)
  0x426866		48890424		MOVQ AX, 0(SP)		
func newm(fn func(), _p_ *p) {
  0x42686a		488b4c2430		MOVQ 0x30(SP), CX	
	mp := allocm(_p_, fn)
  0x42686f		48894c2408		MOVQ CX, 0x8(SP)	
  0x426874		e897f7ffff		CALL runtime.allocm(SB)	
  0x426879		488b442410		MOVQ 0x10(SP), AX	
	mp.nextp.set(_p_)
  0x42687e		488d88d8000000		LEAQ 0xd8(AX), CX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x426885		8401			TESTB AL, 0(CX)		
  0x426887		488b4c2438		MOVQ 0x38(SP), CX	
  0x42688c		488988d8000000		MOVQ CX, 0xd8(AX)	
	mp.sigmask = initSigmask
  0x426893		488b0dded00900		MOVQ runtime.initSigmask(SB), CX	
  0x42689a		48898880000000		MOVQ CX, 0x80(AX)			
	if gp := getg(); gp != nil && gp.m != nil && (gp.m.lockedExt != 0 || gp.m.incgo) && GOOS != "plan9" {
  0x4268a1		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4268aa		4885c9			TESTQ CX, CX		
  0x4268ad		7423			JE 0x4268d2		
  0x4268af		488b4930		MOVQ 0x30(CX), CX	
  0x4268b3		4885c9			TESTQ CX, CX		
  0x4268b6		741a			JE 0x4268d2		
  0x4268b8		4889442418		MOVQ AX, 0x18(SP)	
  0x4268bd		8b91f4020000		MOVL 0x2f4(CX), DX	
  0x4268c3		85d2			TESTL DX, DX		
  0x4268c5		751e			JNE 0x4268e5		
  0x4268c7		0fb68919010000		MOVZX 0x119(CX), CX	
  0x4268ce		84c9			TESTL CL, CL		
  0x4268d0		7513			JNE 0x4268e5		
	newm1(mp)
  0x4268d2		48890424		MOVQ AX, 0(SP)		
  0x4268d6		e8b5000000		CALL runtime.newm1(SB)	
}
  0x4268db		488b6c2420		MOVQ 0x20(SP), BP	
  0x4268e0		4883c428		ADDQ $0x28, SP		
  0x4268e4		c3			RET			
		lock(&newmHandoff.lock)
  0x4268e5		488d0554d10900		LEAQ runtime.newmHandoff(SB), AX	
  0x4268ec		48890424		MOVQ AX, 0(SP)				
  0x4268f0		e82b2cfeff		CALL runtime.lock(SB)			
		if newmHandoff.haveTemplateThread == 0 {
  0x4268f5		8b0565d10900		MOVL runtime.newmHandoff+32(SB), AX	
  0x4268fb		85c0			TESTL AX, AX				
  0x4268fd		7461			JE 0x426960				
		mp.schedlink = newmHandoff.newm
  0x4268ff		488b0542d10900		MOVQ runtime.newmHandoff+8(SB), AX	
  0x426906		488b4c2418		MOVQ 0x18(SP), CX			
  0x42690b		48898158010000		MOVQ AX, 0x158(CX)			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x426912		488d052fd10900		LEAQ runtime.newmHandoff+8(SB), AX	
  0x426919		8400			TESTB AL, 0(AX)				
  0x42691b		48890d26d10900		MOVQ CX, runtime.newmHandoff+8(SB)	
		if newmHandoff.waiting {
  0x426922		0fb60527d10900		MOVZX runtime.newmHandoff+16(SB), AX	
  0x426929		84c0			TESTL AL, AL				
  0x42692b		751a			JNE 0x426947				
		unlock(&newmHandoff.lock)
  0x42692d		488d050cd10900		LEAQ runtime.newmHandoff(SB), AX	
  0x426934		48890424		MOVQ AX, 0(SP)				
  0x426938		e8832dfeff		CALL runtime.unlock(SB)			
		return
  0x42693d		488b6c2420		MOVQ 0x20(SP), BP	
  0x426942		4883c428		ADDQ $0x28, SP		
  0x426946		c3			RET			
			newmHandoff.waiting = false
  0x426947		c60502d1090000		MOVB $0x0, runtime.newmHandoff+16(SB)	
			notewakeup(&newmHandoff.wake)
  0x42694e		488d0503d10900		LEAQ runtime.newmHandoff+24(SB), AX	
  0x426955		48890424		MOVQ AX, 0(SP)				
  0x426959		e8322efeff		CALL runtime.notewakeup(SB)		
  0x42695e		ebcd			JMP 0x42692d				
			throw("on a locked thread with no template thread")
  0x426960		488d053a6b0400		LEAQ 0x46b3a(IP), AX	
  0x426967		48890424		MOVQ AX, 0(SP)		
  0x42696b		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x426974		e857a8ffff		CALL runtime.throw(SB)	
  0x426979		0f0b			UD2			
func newm(fn func(), _p_ *p) {
  0x42697b		e8f0db0100		CALL runtime.morestack_noctxt(SB)	
  0x426980		e9bbfeffff		JMP runtime.newm(SB)			

TEXT runtime.newm1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func newm1(mp *m) {
  0x426990		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426999		483b6110		CMPQ 0x10(CX), SP	
  0x42699d		0f8635010000		JBE 0x426ad8		
  0x4269a3		4883ec48		SUBQ $0x48, SP		
  0x4269a7		48896c2440		MOVQ BP, 0x40(SP)	
  0x4269ac		488d6c2440		LEAQ 0x40(SP), BP	
	if iscgo {
  0x4269b1		0fb605f4ce0900		MOVZX runtime.iscgo(SB), AX	
  0x4269b8		84c0			TESTL AL, AL			
  0x4269ba		0f84b9000000		JE 0x426a79			
		var ts cgothreadstart
  0x4269c0		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x4269c9		0f57c0			XORPS X0, X0		
  0x4269cc		0f11442430		MOVUPS X0, 0x30(SP)	
		if _cgo_thread_start == nil {
  0x4269d1		488b05180c0800		MOVQ _cgo_thread_start(SB), AX	
  0x4269d8		4885c0			TESTQ AX, AX			
  0x4269db		0f84dc000000		JE 0x426abd			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4269e1		488d442428		LEAQ 0x28(SP), AX	
  0x4269e6		8400			TESTB AL, 0(AX)		
  0x4269e8		488b442450		MOVQ 0x50(SP), AX	
		ts.g.set(mp.g0)
  0x4269ed		488b08			MOVQ 0(AX), CX		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4269f0		48894c2428		MOVQ CX, 0x28(SP)	
		ts.tls = (*uint64)(unsafe.Pointer(&mp.tls[0]))
  0x4269f5		480588000000		ADDQ $0x88, AX		
  0x4269fb		4889442430		MOVQ AX, 0x30(SP)	
		ts.fn = unsafe.Pointer(funcPC(mstart))
  0x426a00		488d05d9fc0200		LEAQ 0x2fcd9(IP), AX	
  0x426a07		4889442418		MOVQ AX, 0x18(SP)	
  0x426a0c		488d0565770400		LEAQ 0x47765(IP), AX	
  0x426a13		4889442420		MOVQ AX, 0x20(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x426a18		b808000000		MOVL $0x8, AX		
  0x426a1d		488d4c2418		LEAQ 0x18(SP), CX	
  0x426a22		488b0401		MOVQ 0(CX)(AX*1), AX	
  0x426a26		488d4c2420		LEAQ 0x20(SP), CX	
  0x426a2b		8401			TESTB AL, 0(CX)		
  0x426a2d		488b00			MOVQ 0(AX), AX		
		ts.fn = unsafe.Pointer(funcPC(mstart))
  0x426a30		4889442438		MOVQ AX, 0x38(SP)	
		execLock.rlock() // Prevent process clone.
  0x426a35		488d0544d00900		LEAQ runtime.execLock(SB), AX		
  0x426a3c		48890424		MOVQ AX, 0(SP)				
  0x426a40		e82b930000		CALL runtime.(*rwmutex).rlock(SB)	
		asmcgocall(_cgo_thread_start, unsafe.Pointer(&ts))
  0x426a45		488b05a40b0800		MOVQ _cgo_thread_start(SB), AX	
  0x426a4c		48890424		MOVQ AX, 0(SP)			
  0x426a50		488d442428		LEAQ 0x28(SP), AX		
  0x426a55		4889442408		MOVQ AX, 0x8(SP)		
  0x426a5a		e891f10100		CALL runtime.asmcgocall(SB)	
		execLock.runlock()
  0x426a5f		488d051ad00900		LEAQ runtime.execLock(SB), AX		
  0x426a66		48890424		MOVQ AX, 0(SP)				
  0x426a6a		e881930000		CALL runtime.(*rwmutex).runlock(SB)	
		return
  0x426a6f		488b6c2440		MOVQ 0x40(SP), BP	
  0x426a74		4883c448		ADDQ $0x48, SP		
  0x426a78		c3			RET			
	execLock.rlock() // Prevent process clone.
  0x426a79		488d0500d00900		LEAQ runtime.execLock(SB), AX		
  0x426a80		48890424		MOVQ AX, 0(SP)				
  0x426a84		e8e7920000		CALL runtime.(*rwmutex).rlock(SB)	
  0x426a89		488b442450		MOVQ 0x50(SP), AX			
	newosproc(mp, unsafe.Pointer(mp.g0.stack.hi))
  0x426a8e		488b08			MOVQ 0(AX), CX			
  0x426a91		488b4908		MOVQ 0x8(CX), CX		
  0x426a95		48894c2408		MOVQ CX, 0x8(SP)		
  0x426a9a		48890424		MOVQ AX, 0(SP)			
  0x426a9e		e81d84ffff		CALL runtime.newosproc(SB)	
	execLock.runlock()
  0x426aa3		488d05d6cf0900		LEAQ runtime.execLock(SB), AX		
  0x426aaa		48890424		MOVQ AX, 0(SP)				
  0x426aae		e83d930000		CALL runtime.(*rwmutex).runlock(SB)	
}
  0x426ab3		488b6c2440		MOVQ 0x40(SP), BP	
  0x426ab8		4883c448		ADDQ $0x48, SP		
  0x426abc		c3			RET			
			throw("_cgo_thread_start missing")
  0x426abd		488d05bb4e0400		LEAQ 0x44ebb(IP), AX	
  0x426ac4		48890424		MOVQ AX, 0(SP)		
  0x426ac8		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x426ad1		e8faa6ffff		CALL runtime.throw(SB)	
  0x426ad6		0f0b			UD2			
func newm1(mp *m) {
  0x426ad8		e893da0100		CALL runtime.morestack_noctxt(SB)	
  0x426add		e9aefeffff		JMP runtime.newm1(SB)			

TEXT runtime.startTemplateThread(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func startTemplateThread() {
  0x426af0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426af9		483b6110		CMPQ 0x10(CX), SP	
  0x426afd		7654			JBE 0x426b53		
  0x426aff		4883ec18		SUBQ $0x18, SP		
  0x426b03		48896c2410		MOVQ BP, 0x10(SP)	
  0x426b08		488d6c2410		LEAQ 0x10(SP), BP	
	if !atomic.Cas(&newmHandoff.haveTemplateThread, 0, 1) {
  0x426b0d		31c0			XORL AX, AX				
  0x426b0f		488d0d4acf0900		LEAQ runtime.newmHandoff+32(SB), CX	
  0x426b16		ba01000000		MOVL $0x1, DX				
  0x426b1b		f00fb111		LOCK CMPXCHGL DX, 0(CX)			
  0x426b1f		0f94c1			SETE CL					
  0x426b22		84c9			TESTL CL, CL				
  0x426b24		7423			JE 0x426b49				
	newm(templateThread, nil)
  0x426b26		488d05fb760400		LEAQ 0x476fb(IP), AX	
  0x426b2d		48890424		MOVQ AX, 0(SP)		
  0x426b31		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x426b3a		e801fdffff		CALL runtime.newm(SB)	
}
  0x426b3f		488b6c2410		MOVQ 0x10(SP), BP	
  0x426b44		4883c418		ADDQ $0x18, SP		
  0x426b48		c3			RET			
		return
  0x426b49		488b6c2410		MOVQ 0x10(SP), BP	
  0x426b4e		4883c418		ADDQ $0x18, SP		
  0x426b52		c3			RET			
func startTemplateThread() {
  0x426b53		e818da0100		CALL runtime.morestack_noctxt(SB)	
  0x426b58		eb96			JMP runtime.startTemplateThread(SB)	

TEXT runtime.templateThread(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func templateThread() {
  0x426b60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426b69		483b6110		CMPQ 0x10(CX), SP	
  0x426b6d		0f86f8000000		JBE 0x426c6b		
  0x426b73		4883ec18		SUBQ $0x18, SP		
  0x426b77		48896c2410		MOVQ BP, 0x10(SP)	
  0x426b7c		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&sched.lock)
  0x426b81		488d05a80d0800		LEAQ runtime.sched+16(SB), AX	
  0x426b88		48890424		MOVQ AX, 0(SP)			
  0x426b8c		e88f29feff		CALL runtime.lock(SB)		
	sched.nmsys++
  0x426b91		ff05bd0d0800		INCL runtime.sched+52(SB)	
	checkdead()
  0x426b97		e8d4580000		CALL runtime.checkdead(SB)	
	unlock(&sched.lock)
  0x426b9c		488d058d0d0800		LEAQ runtime.sched+16(SB), AX	
  0x426ba3		48890424		MOVQ AX, 0(SP)			
  0x426ba7		e8142bfeff		CALL runtime.unlock(SB)		
	for {
  0x426bac		e9a8000000		JMP 0x426c59		
				next := newm.schedlink.ptr()
  0x426bb1		488b8858010000		MOVQ 0x158(AX), CX	
func (mp muintptr) ptr() *m { return (*m)(unsafe.Pointer(mp)) }
  0x426bb8		48894c2408		MOVQ CX, 0x8(SP)	
				newm.schedlink = 0
  0x426bbd		48c7805801000000000000	MOVQ $0x0, 0x158(AX)	
				newm1(newm)
  0x426bc8		48890424		MOVQ AX, 0(SP)		
  0x426bcc		e8bffdffff		CALL runtime.newm1(SB)	
  0x426bd1		488b442408		MOVQ 0x8(SP), AX	
			for newm != nil {
  0x426bd6		4885c0			TESTQ AX, AX		
  0x426bd9		75d6			JNE 0x426bb1		
			lock(&newmHandoff.lock)
  0x426bdb		488d055ece0900		LEAQ runtime.newmHandoff(SB), AX	
  0x426be2		48890424		MOVQ AX, 0(SP)				
  0x426be6		e83529feff		CALL runtime.lock(SB)			
		for newmHandoff.newm != 0 {
  0x426beb		488b0556ce0900		MOVQ runtime.newmHandoff+8(SB), AX	
  0x426bf2		4885c0			TESTQ AX, AX				
  0x426bf5		7427			JE 0x426c1e				
func (mp muintptr) ptr() *m { return (*m)(unsafe.Pointer(mp)) }
  0x426bf7		4889442408		MOVQ AX, 0x8(SP)	
			newmHandoff.newm = 0
  0x426bfc		48c70541ce090000000000	MOVQ $0x0, runtime.newmHandoff+8(SB)	
			unlock(&newmHandoff.lock)
  0x426c07		488d0d32ce0900		LEAQ runtime.newmHandoff(SB), CX	
  0x426c0e		48890c24		MOVQ CX, 0(SP)				
  0x426c12		e8a92afeff		CALL runtime.unlock(SB)			
  0x426c17		488b442408		MOVQ 0x8(SP), AX			
			for newm != nil {
  0x426c1c		ebb8			JMP 0x426bd6		
		newmHandoff.waiting = true
  0x426c1e		c6052bce090001		MOVB $0x1, runtime.newmHandoff+16(SB)	
	n.key = 0
  0x426c25		488d052cce0900		LEAQ runtime.newmHandoff+24(SB), AX	
  0x426c2c		8400			TESTB AL, 0(AX)				
  0x426c2e		48c7051fce090000000000	MOVQ $0x0, runtime.newmHandoff+24(SB)	
		unlock(&newmHandoff.lock)
  0x426c39		488d0d00ce0900		LEAQ runtime.newmHandoff(SB), CX	
  0x426c40		48890c24		MOVQ CX, 0(SP)				
  0x426c44		e8772afeff		CALL runtime.unlock(SB)			
		notesleep(&newmHandoff.wake)
  0x426c49		488d0508ce0900		LEAQ runtime.newmHandoff+24(SB), AX	
  0x426c50		48890424		MOVQ AX, 0(SP)				
  0x426c54		e8f72bfeff		CALL runtime.notesleep(SB)		
		lock(&newmHandoff.lock)
  0x426c59		488d05e0cd0900		LEAQ runtime.newmHandoff(SB), AX	
  0x426c60		48890424		MOVQ AX, 0(SP)				
  0x426c64		e8b728feff		CALL runtime.lock(SB)			
		for newmHandoff.newm != 0 {
  0x426c69		eb80			JMP 0x426beb		
func templateThread() {
  0x426c6b		e800d90100		CALL runtime.morestack_noctxt(SB)	
  0x426c70		e9ebfeffff		JMP runtime.templateThread(SB)		

TEXT runtime.stopm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func stopm() {
  0x426c80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426c89		483b6110		CMPQ 0x10(CX), SP	
  0x426c8d		0f8680010000		JBE 0x426e13		
  0x426c93		4883ec20		SUBQ $0x20, SP		
  0x426c97		48896c2418		MOVQ BP, 0x18(SP)	
  0x426c9c		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x426ca1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.locks != 0 {
  0x426caa		488b4830		MOVQ 0x30(AX), CX	
  0x426cae		8b9100010000		MOVL 0x100(CX), DX	
  0x426cb4		85d2			TESTL DX, DX		
  0x426cb6		0f853c010000		JNE 0x426df8		
	if _g_.m.p != 0 {
  0x426cbc		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x426cc3		4885d2			TESTQ DX, DX		
  0x426cc6		0f8511010000		JNE 0x426ddd		
	if _g_.m.spinning {
  0x426ccc		0fb68914010000		MOVZX 0x114(CX), CX	
  0x426cd3		84c9			TESTL CL, CL		
  0x426cd5		0f85e7000000		JNE 0x426dc2		
  0x426cdb		4889442410		MOVQ AX, 0x10(SP)	
	lock(&sched.lock)
  0x426ce0		eb36			JMP 0x426d18		
		gchelper()
  0x426ce2		e8d9c4feff		CALL runtime.gchelper(SB)	
  0x426ce7		488b442410		MOVQ 0x10(SP), AX		
		_g_.m.helpgc = 0
  0x426cec		488b4830		MOVQ 0x30(AX), CX	
  0x426cf0		c7811001000000000000	MOVL $0x0, 0x110(CX)	
		_g_.m.mcache = nil
  0x426cfa		488b4830		MOVQ 0x30(AX), CX	
  0x426cfe		48c7816001000000000000	MOVQ $0x0, 0x160(CX)	
		_g_.m.p = 0
  0x426d09		488b4830		MOVQ 0x30(AX), CX	
  0x426d0d		48c781d000000000000000	MOVQ $0x0, 0xd0(CX)	
	lock(&sched.lock)
  0x426d18		488d05110c0800		LEAQ runtime.sched+16(SB), AX	
  0x426d1f		48890424		MOVQ AX, 0(SP)			
  0x426d23		e8f827feff		CALL runtime.lock(SB)		
  0x426d28		488b442410		MOVQ 0x10(SP), AX		
	mput(_g_.m)
  0x426d2d		488b4830		MOVQ 0x30(AX), CX	
  0x426d31		48890c24		MOVQ CX, 0(SP)		
  0x426d35		e8966e0000		CALL runtime.mput(SB)	
	unlock(&sched.lock)
  0x426d3a		488d05ef0b0800		LEAQ runtime.sched+16(SB), AX	
  0x426d41		48890424		MOVQ AX, 0(SP)			
  0x426d45		e87629feff		CALL runtime.unlock(SB)		
  0x426d4a		488b442410		MOVQ 0x10(SP), AX		
	notesleep(&_g_.m.park)
  0x426d4f		488b4830		MOVQ 0x30(AX), CX		
  0x426d53		8401			TESTB AL, 0(CX)			
  0x426d55		4881c148010000		ADDQ $0x148, CX			
  0x426d5c		48890c24		MOVQ CX, 0(SP)			
  0x426d60		e8eb2afeff		CALL runtime.notesleep(SB)	
  0x426d65		488b442410		MOVQ 0x10(SP), AX		
	noteclear(&_g_.m.park)
  0x426d6a		488b4830		MOVQ 0x30(AX), CX	
  0x426d6e		488d9148010000		LEAQ 0x148(CX), DX	
	n.key = 0
  0x426d75		8402			TESTB AL, 0(DX)		
  0x426d77		48c7814801000000000000	MOVQ $0x0, 0x148(CX)	
	if _g_.m.helpgc != 0 {
  0x426d82		488b4830		MOVQ 0x30(AX), CX	
  0x426d86		8b9110010000		MOVL 0x110(CX), DX	
  0x426d8c		85d2			TESTL DX, DX		
  0x426d8e		0f854effffff		JNE 0x426ce2		
	acquirep(_g_.m.nextp.ptr())
  0x426d94		488b81d8000000		MOVQ 0xd8(CX), AX		
  0x426d9b		48890424		MOVQ AX, 0(SP)			
  0x426d9f		e83c520000		CALL runtime.acquirep(SB)	
  0x426da4		488b442410		MOVQ 0x10(SP), AX		
	_g_.m.nextp = 0
  0x426da9		488b4030		MOVQ 0x30(AX), AX	
  0x426dad		48c780d800000000000000	MOVQ $0x0, 0xd8(AX)	
}
  0x426db8		488b6c2418		MOVQ 0x18(SP), BP	
  0x426dbd		4883c420		ADDQ $0x20, SP		
  0x426dc1		c3			RET			
		throw("stopm spinning")
  0x426dc2		488d052d3b0400		LEAQ 0x43b2d(IP), AX	
  0x426dc9		48890424		MOVQ AX, 0(SP)		
  0x426dcd		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x426dd6		e8f5a3ffff		CALL runtime.throw(SB)	
  0x426ddb		0f0b			UD2			
		throw("stopm holding p")
  0x426ddd		488d05ff3b0400		LEAQ 0x43bff(IP), AX	
  0x426de4		48890424		MOVQ AX, 0(SP)		
  0x426de8		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x426df1		e8daa3ffff		CALL runtime.throw(SB)	
  0x426df6		0f0b			UD2			
		throw("stopm holding locks")
  0x426df8		488d05a4410400		LEAQ 0x441a4(IP), AX	
  0x426dff		48890424		MOVQ AX, 0(SP)		
  0x426e03		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x426e0c		e8bfa3ffff		CALL runtime.throw(SB)	
  0x426e11		0f0b			UD2			
func stopm() {
  0x426e13		e858d70100		CALL runtime.morestack_noctxt(SB)	
  0x426e18		e963feffff		JMP runtime.stopm(SB)			

TEXT runtime.mspinning(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	getg().m.spinning = true
  0x426e20		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x426e29		488b4030		MOVQ 0x30(AX), AX	
  0x426e2d		c6801401000001		MOVB $0x1, 0x114(AX)	
}
  0x426e34		c3			RET			

TEXT runtime.startm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func startm(_p_ *p, spinning bool) {
  0x426e40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426e49		483b6110		CMPQ 0x10(CX), SP	
  0x426e4d		0f8608020000		JBE 0x42705b		
  0x426e53		4883ec30		SUBQ $0x30, SP		
  0x426e57		48896c2428		MOVQ BP, 0x28(SP)	
  0x426e5c		488d6c2428		LEAQ 0x28(SP), BP	
	lock(&sched.lock)
  0x426e61		488d05c80a0800		LEAQ runtime.sched+16(SB), AX	
  0x426e68		48890424		MOVQ AX, 0(SP)			
  0x426e6c		e8af26feff		CALL runtime.lock(SB)		
func startm(_p_ *p, spinning bool) {
  0x426e71		488b442438		MOVQ 0x38(SP), AX	
	if _p_ == nil {
  0x426e76		4885c0			TESTQ AX, AX		
  0x426e79		0f8407010000		JE 0x426f86		
  0x426e7f		4889442410		MOVQ AX, 0x10(SP)	
	mp := sched.midle.ptr()
  0x426e84		488b0dad0a0800		MOVQ runtime.sched+24(SB), CX	
func (mp muintptr) ptr() *m { return (*m)(unsafe.Pointer(mp)) }
  0x426e8b		48894c2420		MOVQ CX, 0x20(SP)	
	if mp != nil {
  0x426e90		4885c9			TESTQ CX, CX		
  0x426e93		7415			JE 0x426eaa		
		sched.midle = mp.schedlink
  0x426e95		488b9158010000		MOVQ 0x158(CX), DX		
  0x426e9c		488915950a0800		MOVQ DX, runtime.sched+24(SB)	
		sched.nmidle--
  0x426ea3		8305960a0800ff		ADDL $-0x1, runtime.sched+32(SB)	
	unlock(&sched.lock)
  0x426eaa		488d057f0a0800		LEAQ runtime.sched+16(SB), AX	
  0x426eb1		48890424		MOVQ AX, 0(SP)			
  0x426eb5		e80628feff		CALL runtime.unlock(SB)		
  0x426eba		488b442420		MOVQ 0x20(SP), AX		
	if mp != nil {
  0x426ebf		4885c0			TESTQ AX, AX		
	if mp == nil {
  0x426ec2		0f848d000000		JE 0x426f55		
	if mp.spinning {
  0x426ec8		0fb68814010000		MOVZX 0x114(AX), CX	
  0x426ecf		84c9			TESTL CL, CL		
  0x426ed1		0f854e010000		JNE 0x427025		
	if mp.nextp != 0 {
  0x426ed7		488b88d8000000		MOVQ 0xd8(AX), CX	
  0x426ede		488d90d8000000		LEAQ 0xd8(AX), DX	
  0x426ee5		4885c9			TESTQ CX, CX		
  0x426ee8		0f851c010000		JNE 0x42700a		
  0x426eee		0fb64c2440		MOVZX 0x40(SP), CX	
func startm(_p_ *p, spinning bool) {
  0x426ef3		84c9			TESTL CL, CL		
	if spinning && !runqempty(_p_) {
  0x426ef5		752d			JNE 0x426f24		
	mp.spinning = spinning
  0x426ef7		888814010000		MOVB CL, 0x114(AX)	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x426efd		8402			TESTB AL, 0(DX)		
  0x426eff		488b4c2410		MOVQ 0x10(SP), CX	
  0x426f04		488988d8000000		MOVQ CX, 0xd8(AX)	
	notewakeup(&mp.park)
  0x426f0b		480548010000		ADDQ $0x148, AX			
  0x426f11		48890424		MOVQ AX, 0(SP)			
  0x426f15		e87628feff		CALL runtime.notewakeup(SB)	
}
  0x426f1a		488b6c2428		MOVQ 0x28(SP), BP	
  0x426f1f		4883c430		ADDQ $0x30, SP		
  0x426f23		c3			RET			
  0x426f24		4889542418		MOVQ DX, 0x18(SP)	
  0x426f29		488b442410		MOVQ 0x10(SP), AX	
	if spinning && !runqempty(_p_) {
  0x426f2e		48890424		MOVQ AX, 0(SP)			
  0x426f32		e8d96e0000		CALL runtime.runqempty(SB)	
  0x426f37		0fb6442408		MOVZX 0x8(SP), AX		
  0x426f3c		84c0			TESTL AL, AL			
  0x426f3e		0f84ab000000		JE 0x426fef			
  0x426f44		488b442420		MOVQ 0x20(SP), AX		
  0x426f49		0fb64c2440		MOVZX 0x40(SP), CX		
  0x426f4e		488b542418		MOVQ 0x18(SP), DX		
  0x426f53		eba2			JMP 0x426ef7			
  0x426f55		0fb6442440		MOVZX 0x40(SP), AX		
func startm(_p_ *p, spinning bool) {
  0x426f5a		84c0			TESTL AL, AL		
		if spinning {
  0x426f5c		7424			JE 0x426f82		
  0x426f5e		488d050b720400		LEAQ 0x4720b(IP), AX	
		newm(fn, _p_)
  0x426f65		48890424		MOVQ AX, 0(SP)		
  0x426f69		488b442410		MOVQ 0x10(SP), AX	
  0x426f6e		4889442408		MOVQ AX, 0x8(SP)	
  0x426f73		e8c8f8ffff		CALL runtime.newm(SB)	
		return
  0x426f78		488b6c2428		MOVQ 0x28(SP), BP	
  0x426f7d		4883c430		ADDQ $0x30, SP		
  0x426f81		c3			RET			
  0x426f82		31c0			XORL AX, AX		
		if spinning {
  0x426f84		ebdf			JMP 0x426f65		
	_p_ := sched.pidle.ptr()
  0x426f86		488b05db090800		MOVQ runtime.sched+72(SB), AX	
	if _p_ != nil {
  0x426f8d		4885c0			TESTQ AX, AX		
  0x426f90		741e			JE 0x426fb0		
		sched.pidle = _p_.link
  0x426f92		488b4810		MOVQ 0x10(AX), CX		
  0x426f96		48890dcb090800		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x426f9d		b9ffffffff		MOVL $-0x1, CX			
  0x426fa2		488d15c7090800		LEAQ runtime.sched+80(SB), DX	
  0x426fa9		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x426fad		4885c0			TESTQ AX, AX		
		if _p_ == nil {
  0x426fb0		0f85c9feffff		JNE 0x426e7f		
			unlock(&sched.lock)
  0x426fb6		488d0573090800		LEAQ runtime.sched+16(SB), AX	
  0x426fbd		48890424		MOVQ AX, 0(SP)			
  0x426fc1		e8fa26feff		CALL runtime.unlock(SB)		
  0x426fc6		0fb6442440		MOVZX 0x40(SP), AX		
func startm(_p_ *p, spinning bool) {
  0x426fcb		84c0			TESTL AL, AL		
			if spinning {
  0x426fcd		7416			JE 0x426fe5		
				if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
  0x426fcf		b8ffffffff		MOVL $-0x1, AX			
  0x426fd4		488d0d99090800		LEAQ runtime.sched+84(SB), CX	
  0x426fdb		f00fc101		LOCK XADDL AX, 0(CX)		
  0x426fdf		ffc8			DECL AX				
  0x426fe1		85c0			TESTL AX, AX			
  0x426fe3		7c5b			JL 0x427040			
			return
  0x426fe5		488b6c2428		MOVQ 0x28(SP), BP	
  0x426fea		4883c430		ADDQ $0x30, SP		
  0x426fee		c3			RET			
		throw("startm: p has runnable gs")
  0x426fef		488d054b4b0400		LEAQ 0x44b4b(IP), AX	
  0x426ff6		48890424		MOVQ AX, 0(SP)		
  0x426ffa		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x427003		e8c8a1ffff		CALL runtime.throw(SB)	
  0x427008		0f0b			UD2			
		throw("startm: m has p")
  0x42700a		488d05c3390400		LEAQ 0x439c3(IP), AX	
  0x427011		48890424		MOVQ AX, 0(SP)		
  0x427015		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x42701e		e8ada1ffff		CALL runtime.throw(SB)	
  0x427023		0f0b			UD2			
		throw("startm: m is spinning")
  0x427025		488d0544430400		LEAQ 0x44344(IP), AX	
  0x42702c		48890424		MOVQ AX, 0(SP)		
  0x427030		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x427039		e892a1ffff		CALL runtime.throw(SB)	
  0x42703e		0f0b			UD2			
					throw("startm: negative nmspinning")
  0x427040		488d05ea4e0400		LEAQ 0x44eea(IP), AX	
  0x427047		48890424		MOVQ AX, 0(SP)		
  0x42704b		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x427054		e877a1ffff		CALL runtime.throw(SB)	
  0x427059		0f0b			UD2			
func startm(_p_ *p, spinning bool) {
  0x42705b		e810d50100		CALL runtime.morestack_noctxt(SB)	
  0x427060		e9dbfdffff		JMP runtime.startm(SB)			

TEXT runtime.handoffp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func handoffp(_p_ *p) {
  0x427070		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427079		483b6110		CMPQ 0x10(CX), SP	
  0x42707d		0f86df020000		JBE 0x427362		
  0x427083		4883ec18		SUBQ $0x18, SP		
  0x427087		48896c2410		MOVQ BP, 0x10(SP)	
  0x42708c		488d6c2410		LEAQ 0x10(SP), BP	
  0x427091		488b442420		MOVQ 0x20(SP), AX	
	if !runqempty(_p_) || sched.runqsize != 0 {
  0x427096		48890424		MOVQ AX, 0(SP)			
  0x42709a		e8716d0000		CALL runtime.runqempty(SB)	
  0x42709f		0fb6442408		MOVZX 0x8(SP), AX		
  0x4270a4		84c0			TESTL AL, AL			
  0x4270a6		740a			JE 0x4270b2			
  0x4270a8		8b0dda080800		MOVL runtime.sched+104(SB), CX	
  0x4270ae		85c9			TESTL CX, CX			
  0x4270b0		741d			JE 0x4270cf			
  0x4270b2		488b442420		MOVQ 0x20(SP), AX		
		startm(_p_, false)
  0x4270b7		48890424		MOVQ AX, 0(SP)		
  0x4270bb		c644240800		MOVB $0x0, 0x8(SP)	
  0x4270c0		e87bfdffff		CALL runtime.startm(SB)	
		return
  0x4270c5		488b6c2410		MOVQ 0x10(SP), BP	
  0x4270ca		4883c418		ADDQ $0x18, SP		
  0x4270ce		c3			RET			
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x4270cf		8b0dffc70900		MOVL runtime.gcBlackenEnabled(SB), CX	
  0x4270d5		85c9			TESTL CX, CX				
  0x4270d7		0f847b020000		JE 0x427358				
  0x4270dd		488b4c2420		MOVQ 0x20(SP), CX			
	if p != nil && !p.gcw.empty() {
  0x4270e2		4885c9			TESTQ CX, CX		
  0x4270e5		743f			JE 0x427126		
  0x4270e7		488d9170120000		LEAQ 0x1270(CX), DX	
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x4270ee		8402			TESTB AL, 0(DX)		
  0x4270f0		488b9170120000		MOVQ 0x1270(CX), DX	
  0x4270f7		4885d2			TESTQ DX, DX		
  0x4270fa		0f844e020000		JE 0x42734e		
  0x427100		488b5210		MOVQ 0x10(DX), DX	
  0x427104		4885d2			TESTQ DX, DX		
  0x427107		0f853a020000		JNE 0x427347		
  0x42710d		488b9178120000		MOVQ 0x1278(CX), DX	
  0x427114		488b5210		MOVQ 0x10(DX), DX	
  0x427118		4885d2			TESTQ DX, DX		
  0x42711b		0f94c2			SETE DL			
  0x42711e		84d2			TESTL DL, DL		
	if p != nil && !p.gcw.empty() {
  0x427120		0f8417020000		JE 0x42733d		
	return atomic.Load64((*uint64)(head)) == 0
  0x427126		488b15730c0800		MOVQ runtime.work(SB), DX	
  0x42712d		4885d2			TESTQ DX, DX			
	if !work.full.empty() {
  0x427130		0f85fd010000		JNE 0x427333		
	if work.markrootNext < work.markrootJobs {
  0x427136		8b15ec0c0800		MOVL runtime.work+136(SB), DX	
  0x42713c		8b1dea0c0800		MOVL runtime.work+140(SB), BX	
  0x427142		39da			CMPL BX, DX			
  0x427144		0f83e2010000		JAE 0x42732c			
  0x42714a		b801000000		MOVL $0x1, AX			
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x42714f		84c0			TESTL AL, AL		
  0x427151		0f85bd010000		JNE 0x427314		
	if atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) == 0 && atomic.Cas(&sched.nmspinning, 0, 1) { // TODO: fast atomic
  0x427157		8b1517080800		MOVL runtime.sched+84(SB), DX	
  0x42715d		8b1d0d080800		MOVL runtime.sched+80(SB), BX	
  0x427163		01da			ADDL BX, DX			
  0x427165		85d2			TESTL DX, DX			
  0x427167		751d			JNE 0x427186			
  0x427169		31c0			XORL AX, AX			
  0x42716b		488d1502080800		LEAQ runtime.sched+84(SB), DX	
  0x427172		bb01000000		MOVL $0x1, BX			
  0x427177		f00fb11a		LOCK CMPXCHGL BX, 0(DX)		
  0x42717b		0f94c2			SETE DL				
  0x42717e		84d2			TESTL DL, DL			
  0x427180		0f8576010000		JNE 0x4272fc			
	lock(&sched.lock)
  0x427186		488d05a3070800		LEAQ runtime.sched+16(SB), AX	
  0x42718d		48890424		MOVQ AX, 0(SP)			
  0x427191		e88a23feff		CALL runtime.lock(SB)		
	if sched.gcwaiting != 0 {
  0x427196		8b055c080800		MOVL runtime.sched+216(SB), AX	
  0x42719c		85c0			TESTL AX, AX			
  0x42719e		744c			JE 0x4271ec			
  0x4271a0		488b442420		MOVQ 0x20(SP), AX		
		_p_.status = _Pgcstop
  0x4271a5		c7400c03000000		MOVL $0x3, 0xc(AX)	
		sched.stopwait--
  0x4271ac		8b054a080800		MOVL runtime.sched+220(SB), AX	
  0x4271b2		8d48ff			LEAL -0x1(AX), CX		
  0x4271b5		890d41080800		MOVL CX, runtime.sched+220(SB)	
		if sched.stopwait == 0 {
  0x4271bb		83f801			CMPL $0x1, AX		
  0x4271be		741a			JE 0x4271da		
		unlock(&sched.lock)
  0x4271c0		488d0569070800		LEAQ runtime.sched+16(SB), AX	
  0x4271c7		48890424		MOVQ AX, 0(SP)			
  0x4271cb		e8f024feff		CALL runtime.unlock(SB)		
		return
  0x4271d0		488b6c2410		MOVQ 0x10(SP), BP	
  0x4271d5		4883c418		ADDQ $0x18, SP		
  0x4271d9		c3			RET			
			notewakeup(&sched.stopnote)
  0x4271da		488d051f080800		LEAQ runtime.sched+224(SB), AX	
  0x4271e1		48890424		MOVQ AX, 0(SP)			
  0x4271e5		e8a625feff		CALL runtime.notewakeup(SB)	
  0x4271ea		ebd4			JMP 0x4271c0			
  0x4271ec		488b4c2420		MOVQ 0x20(SP), CX		
	if _p_.runSafePointFn != 0 && atomic.Cas(&_p_.runSafePointFn, 1, 0) {
  0x4271f1		8401			TESTB AL, 0(CX)			
  0x4271f3		8b99a0220000		MOVL 0x22a0(CX), BX		
  0x4271f9		85db			TESTL BX, BX			
  0x4271fb		741a			JE 0x427217			
  0x4271fd		b801000000		MOVL $0x1, AX			
  0x427202		31db			XORL BX, BX			
  0x427204		f00fb199a0220000	LOCK CMPXCHGL BX, 0x22a0(CX)	
  0x42720c		0f94c3			SETE BL				
  0x42720f		84db			TESTL BL, BL			
  0x427211		0f85a5000000		JNE 0x4272bc			
	if sched.runqsize != 0 {
  0x427217		8b056b070800		MOVL runtime.sched+104(SB), AX	
  0x42721d		85c0			TESTL AX, AX			
  0x42721f		756e			JNE 0x42728f			
	if sched.npidle == uint32(gomaxprocs-1) && atomic.Load64(&sched.lastpoll) != 0 {
  0x427221		8b0549070800		MOVL runtime.sched+80(SB), AX	
  0x427227		8b15b3c60900		MOVL runtime.gomaxprocs(SB), DX	
  0x42722d		ffca			DECL DX				
  0x42722f		39c2			CMPL AX, DX			
  0x427231		750c			JNE 0x42723f			
  0x427233		488b05ee060800		MOVQ runtime.sched+8(SB), AX	
  0x42723a		4885c0			TESTQ AX, AX			
  0x42723d		7523			JNE 0x427262			
	pidleput(_p_)
  0x42723f		48890c24		MOVQ CX, 0(SP)			
  0x427243		e8286b0000		CALL runtime.pidleput(SB)	
	unlock(&sched.lock)
  0x427248		488d05e1060800		LEAQ runtime.sched+16(SB), AX	
  0x42724f		48890424		MOVQ AX, 0(SP)			
  0x427253		e86824feff		CALL runtime.unlock(SB)		
}
  0x427258		488b6c2410		MOVQ 0x10(SP), BP	
  0x42725d		4883c418		ADDQ $0x18, SP		
  0x427261		c3			RET			
		unlock(&sched.lock)
  0x427262		488d05c7060800		LEAQ runtime.sched+16(SB), AX	
  0x427269		48890424		MOVQ AX, 0(SP)			
  0x42726d		e84e24feff		CALL runtime.unlock(SB)		
  0x427272		488b442420		MOVQ 0x20(SP), AX		
		startm(_p_, false)
  0x427277		48890424		MOVQ AX, 0(SP)		
  0x42727b		c644240800		MOVB $0x0, 0x8(SP)	
  0x427280		e8bbfbffff		CALL runtime.startm(SB)	
		return
  0x427285		488b6c2410		MOVQ 0x10(SP), BP	
  0x42728a		4883c418		ADDQ $0x18, SP		
  0x42728e		c3			RET			
		unlock(&sched.lock)
  0x42728f		488d059a060800		LEAQ runtime.sched+16(SB), AX	
  0x427296		48890424		MOVQ AX, 0(SP)			
  0x42729a		e82124feff		CALL runtime.unlock(SB)		
  0x42729f		488b442420		MOVQ 0x20(SP), AX		
		startm(_p_, false)
  0x4272a4		48890424		MOVQ AX, 0(SP)		
  0x4272a8		c644240800		MOVB $0x0, 0x8(SP)	
  0x4272ad		e88efbffff		CALL runtime.startm(SB)	
		return
  0x4272b2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4272b7		4883c418		ADDQ $0x18, SP		
  0x4272bb		c3			RET			
		sched.safePointFn(_p_)
  0x4272bc		488b1555070800		MOVQ runtime.sched+248(SB), DX	
  0x4272c3		48890c24		MOVQ CX, 0(SP)			
  0x4272c7		488b02			MOVQ 0(DX), AX			
  0x4272ca		ffd0			CALL AX				
		sched.safePointWait--
  0x4272cc		8b054e070800		MOVL runtime.sched+256(SB), AX	
  0x4272d2		8d48ff			LEAL -0x1(AX), CX		
  0x4272d5		890d45070800		MOVL CX, runtime.sched+256(SB)	
		if sched.safePointWait == 0 {
  0x4272db		83f801			CMPL $0x1, AX		
  0x4272de		740a			JE 0x4272ea		
  0x4272e0		488b4c2420		MOVQ 0x20(SP), CX	
	if sched.runqsize != 0 {
  0x4272e5		e92dffffff		JMP 0x427217		
			notewakeup(&sched.safePointNote)
  0x4272ea		488d0537070800		LEAQ runtime.sched+264(SB), AX	
  0x4272f1		48890424		MOVQ AX, 0(SP)			
  0x4272f5		e89624feff		CALL runtime.notewakeup(SB)	
  0x4272fa		ebe4			JMP 0x4272e0			
		startm(_p_, true)
  0x4272fc		48890c24		MOVQ CX, 0(SP)		
  0x427300		c644240801		MOVB $0x1, 0x8(SP)	
  0x427305		e836fbffff		CALL runtime.startm(SB)	
		return
  0x42730a		488b6c2410		MOVQ 0x10(SP), BP	
  0x42730f		4883c418		ADDQ $0x18, SP		
  0x427313		c3			RET			
		startm(_p_, false)
  0x427314		48890c24		MOVQ CX, 0(SP)		
  0x427318		c644240800		MOVB $0x0, 0x8(SP)	
  0x42731d		e81efbffff		CALL runtime.startm(SB)	
		return
  0x427322		488b6c2410		MOVQ 0x10(SP), BP	
  0x427327		4883c418		ADDQ $0x18, SP		
  0x42732b		c3			RET			
  0x42732c		31c0			XORL AX, AX		
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x42732e		e91cfeffff		JMP 0x42714f		
  0x427333		b801000000		MOVL $0x1, AX		
  0x427338		e912feffff		JMP 0x42714f		
  0x42733d		b801000000		MOVL $0x1, AX		
  0x427342		e908feffff		JMP 0x42714f		
  0x427347		31d2			XORL DX, DX		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x427349		e9d0fdffff		JMP 0x42711e		
  0x42734e		ba01000000		MOVL $0x1, DX		
  0x427353		e9c6fdffff		JMP 0x42711e		
  0x427358		488b4c2420		MOVQ 0x20(SP), CX	
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x42735d		e9f5fdffff		JMP 0x427157		
func handoffp(_p_ *p) {
  0x427362		e809d20100		CALL runtime.morestack_noctxt(SB)	
  0x427367		e904fdffff		JMP runtime.handoffp(SB)		

TEXT runtime.wakep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func wakep() {
  0x427370		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427379		483b6110		CMPQ 0x10(CX), SP	
  0x42737d		764d			JBE 0x4273cc		
  0x42737f		4883ec18		SUBQ $0x18, SP		
  0x427383		48896c2410		MOVQ BP, 0x10(SP)	
  0x427388		488d6c2410		LEAQ 0x10(SP), BP	
	if !atomic.Cas(&sched.nmspinning, 0, 1) {
  0x42738d		31c0			XORL AX, AX			
  0x42738f		488d0dde050800		LEAQ runtime.sched+84(SB), CX	
  0x427396		ba01000000		MOVL $0x1, DX			
  0x42739b		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x42739f		0f94c1			SETE CL				
  0x4273a2		84c9			TESTL CL, CL			
  0x4273a4		741c			JE 0x4273c2			
	startm(nil, true)
  0x4273a6		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x4273ae		c644240801		MOVB $0x1, 0x8(SP)	
  0x4273b3		e888faffff		CALL runtime.startm(SB)	
}
  0x4273b8		488b6c2410		MOVQ 0x10(SP), BP	
  0x4273bd		4883c418		ADDQ $0x18, SP		
  0x4273c1		c3			RET			
		return
  0x4273c2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4273c7		4883c418		ADDQ $0x18, SP		
  0x4273cb		c3			RET			
func wakep() {
  0x4273cc		e89fd10100		CALL runtime.morestack_noctxt(SB)	
  0x4273d1		eb9d			JMP runtime.wakep(SB)			

TEXT runtime.stoplockedm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func stoplockedm() {
  0x4273e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4273e9		483b6110		CMPQ 0x10(CX), SP	
  0x4273ed		0f869a020000		JBE 0x42768d		
  0x4273f3		4883ec38		SUBQ $0x38, SP		
  0x4273f7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4273fc		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x427401		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.lockedg == 0 || _g_.m.lockedg.ptr().lockedm.ptr() != _g_.m {
  0x42740a		488b4830		MOVQ 0x30(AX), CX	
  0x42740e		488b9168010000		MOVQ 0x168(CX), DX	
  0x427415		4885d2			TESTQ DX, DX		
  0x427418		0f8454020000		JE 0x427672		
  0x42741e		488b92e0000000		MOVQ 0xe0(DX), DX	
  0x427425		4839ca			CMPQ CX, DX		
  0x427428		0f8544020000		JNE 0x427672		
  0x42742e		4889442428		MOVQ AX, 0x28(SP)	
	if _g_.m.p != 0 {
  0x427433		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42743a		4885c9			TESTQ CX, CX		
  0x42743d		0f8594000000		JNE 0x4274d7		
	incidlelocked(1)
  0x427443		c7042401000000		MOVL $0x1, 0(SP)		
  0x42744a		e8b14f0000		CALL runtime.incidlelocked(SB)	
  0x42744f		488b442428		MOVQ 0x28(SP), AX		
	notesleep(&_g_.m.park)
  0x427454		488b4830		MOVQ 0x30(AX), CX		
  0x427458		8401			TESTB AL, 0(CX)			
  0x42745a		8400			TESTB AL, 0(AX)			
  0x42745c		4881c148010000		ADDQ $0x148, CX			
  0x427463		48890c24		MOVQ CX, 0(SP)			
  0x427467		e8e423feff		CALL runtime.notesleep(SB)	
  0x42746c		488b442428		MOVQ 0x28(SP), AX		
	noteclear(&_g_.m.park)
  0x427471		488b4830		MOVQ 0x30(AX), CX	
  0x427475		488d9148010000		LEAQ 0x148(CX), DX	
	n.key = 0
  0x42747c		8402			TESTB AL, 0(DX)		
  0x42747e		48c7814801000000000000	MOVQ $0x0, 0x148(CX)	
	status := readgstatus(_g_.m.lockedg.ptr())
  0x427489		488b4830		MOVQ 0x30(AX), CX	
  0x42748d		488b8968010000		MOVQ 0x168(CX), CX	
	return atomic.Load(&gp.atomicstatus)
  0x427494		8b8990000000		MOVL 0x90(CX), CX	
	if status&^_Gscan != _Grunnable {
  0x42749a		81e1ffefffff		ANDL $-0x1001, CX	
  0x4274a0		83f901			CMPL $0x1, CX		
  0x4274a3		7541			JNE 0x4274e6		
	acquirep(_g_.m.nextp.ptr())
  0x4274a5		488b4830		MOVQ 0x30(AX), CX		
  0x4274a9		488b89d8000000		MOVQ 0xd8(CX), CX		
  0x4274b0		48890c24		MOVQ CX, 0(SP)			
  0x4274b4		e8274b0000		CALL runtime.acquirep(SB)	
  0x4274b9		488b442428		MOVQ 0x28(SP), AX		
	_g_.m.nextp = 0
  0x4274be		488b4030		MOVQ 0x30(AX), AX	
  0x4274c2		48c780d800000000000000	MOVQ $0x0, 0xd8(AX)	
}
  0x4274cd		488b6c2430		MOVQ 0x30(SP), BP	
  0x4274d2		4883c438		ADDQ $0x38, SP		
  0x4274d6		c3			RET			
		_p_ := releasep()
  0x4274d7		e8f44c0000		CALL runtime.releasep(SB)	
		handoffp(_p_)
  0x4274dc		e88ffbffff		CALL runtime.handoffp(SB)	
  0x4274e1		e95dffffff		JMP 0x427443			
		print("runtime:stoplockedm: g is not Grunnable or Gscanrunnable\n")
  0x4274e6		e815a6ffff		CALL runtime.printlock(SB)	
  0x4274eb		488d0557680400		LEAQ 0x46857(IP), AX		
  0x4274f2		48890424		MOVQ AX, 0(SP)			
  0x4274f6		48c744240839000000	MOVQ $0x39, 0x8(SP)		
  0x4274ff		e83cafffff		CALL runtime.printstring(SB)	
  0x427504		e877a6ffff		CALL runtime.printunlock(SB)	
	_g_ := getg()
  0x427509		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x427512		4889442420		MOVQ AX, 0x20(SP)	
  0x427517		488b4c2428		MOVQ 0x28(SP), CX	
	return atomic.Load(&gp.atomicstatus)
  0x42751c		8b9190000000		MOVL 0x90(CX), DX	
  0x427522		89542414		MOVL DX, 0x14(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x427526		488b9998000000		MOVQ 0x98(CX), BX		
  0x42752d		48895c2418		MOVQ BX, 0x18(SP)		
  0x427532		e8c9a5ffff		CALL runtime.printlock(SB)	
  0x427537		488d0524360400		LEAQ 0x43624(IP), AX		
  0x42753e		48890424		MOVQ AX, 0(SP)			
  0x427542		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x42754b		e8f0aeffff		CALL runtime.printstring(SB)	
  0x427550		488b442428		MOVQ 0x28(SP), AX		
  0x427555		48890424		MOVQ AX, 0(SP)			
  0x427559		e8a2aeffff		CALL runtime.printpointer(SB)	
  0x42755e		488d052d290400		LEAQ 0x4292d(IP), AX		
  0x427565		48890424		MOVQ AX, 0(SP)			
  0x427569		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x427572		e8c9aeffff		CALL runtime.printstring(SB)	
  0x427577		488b442418		MOVQ 0x18(SP), AX		
  0x42757c		48890424		MOVQ AX, 0(SP)			
  0x427580		e8fbacffff		CALL runtime.printint(SB)	
  0x427585		488d0588380400		LEAQ 0x43888(IP), AX		
  0x42758c		48890424		MOVQ AX, 0(SP)			
  0x427590		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x427599		e8a2aeffff		CALL runtime.printstring(SB)	
  0x42759e		8b442414		MOVL 0x14(SP), AX		
  0x4275a2		89c0			MOVL AX, AX			
  0x4275a4		48890424		MOVQ AX, 0(SP)			
  0x4275a8		e8c3abffff		CALL runtime.printuint(SB)	
  0x4275ad		e8dea7ffff		CALL runtime.printnl(SB)	
  0x4275b2		e8c9a5ffff		CALL runtime.printunlock(SB)	
  0x4275b7		488b442420		MOVQ 0x20(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x4275bc		8b8890000000		MOVL 0x90(AX), CX	
  0x4275c2		894c2410		MOVL CX, 0x10(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x4275c6		488b9098000000		MOVQ 0x98(AX), DX		
  0x4275cd		4889542418		MOVQ DX, 0x18(SP)		
  0x4275d2		e829a5ffff		CALL runtime.printlock(SB)	
  0x4275d7		488d0574350400		LEAQ 0x43574(IP), AX		
  0x4275de		48890424		MOVQ AX, 0(SP)			
  0x4275e2		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4275eb		e850aeffff		CALL runtime.printstring(SB)	
  0x4275f0		488b442420		MOVQ 0x20(SP), AX		
  0x4275f5		48890424		MOVQ AX, 0(SP)			
  0x4275f9		e802aeffff		CALL runtime.printpointer(SB)	
  0x4275fe		488d058d280400		LEAQ 0x4288d(IP), AX		
  0x427605		48890424		MOVQ AX, 0(SP)			
  0x427609		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x427612		e829aeffff		CALL runtime.printstring(SB)	
  0x427617		488b442418		MOVQ 0x18(SP), AX		
  0x42761c		48890424		MOVQ AX, 0(SP)			
  0x427620		e85bacffff		CALL runtime.printint(SB)	
  0x427625		488d05d5370400		LEAQ 0x437d5(IP), AX		
  0x42762c		48890424		MOVQ AX, 0(SP)			
  0x427630		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x427639		e802aeffff		CALL runtime.printstring(SB)	
  0x42763e		8b442410		MOVL 0x10(SP), AX		
  0x427642		89c0			MOVL AX, AX			
  0x427644		48890424		MOVQ AX, 0(SP)			
  0x427648		e823abffff		CALL runtime.printuint(SB)	
  0x42764d		e83ea7ffff		CALL runtime.printnl(SB)	
  0x427652		e829a5ffff		CALL runtime.printunlock(SB)	
		throw("stoplockedm: not runnable")
  0x427657		488d05fc440400		LEAQ 0x444fc(IP), AX	
  0x42765e		48890424		MOVQ AX, 0(SP)		
  0x427662		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42766b		e8609bffff		CALL runtime.throw(SB)	
  0x427670		0f0b			UD2			
		throw("stoplockedm: inconsistent locking")
  0x427672		488d05b8540400		LEAQ 0x454b8(IP), AX	
  0x427679		48890424		MOVQ AX, 0(SP)		
  0x42767d		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x427686		e8459bffff		CALL runtime.throw(SB)	
  0x42768b		0f0b			UD2			
func stoplockedm() {
  0x42768d		e8dece0100		CALL runtime.morestack_noctxt(SB)	
  0x427692		e949fdffff		JMP runtime.stoplockedm(SB)		

TEXT runtime.startlockedm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func startlockedm(gp *g) {
  0x4276a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4276a9		483b6110		CMPQ 0x10(CX), SP	
  0x4276ad		0f86c6000000		JBE 0x427779		
  0x4276b3		4883ec28		SUBQ $0x28, SP		
  0x4276b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4276bc		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x4276c1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4276ca		488b4c2430		MOVQ 0x30(SP), CX	
	mp := gp.lockedm.ptr()
  0x4276cf		488b89e0000000		MOVQ 0xe0(CX), CX	
	if mp == _g_.m {
  0x4276d6		488b4030		MOVQ 0x30(AX), AX	
  0x4276da		4839c1			CMPQ AX, CX		
  0x4276dd		747f			JE 0x42775e		
	if mp.nextp != 0 {
  0x4276df		488b81d8000000		MOVQ 0xd8(CX), AX	
  0x4276e6		488d91d8000000		LEAQ 0xd8(CX), DX	
  0x4276ed		4885c0			TESTQ AX, AX		
  0x4276f0		7551			JNE 0x427743		
  0x4276f2		48894c2410		MOVQ CX, 0x10(SP)	
  0x4276f7		4889542418		MOVQ DX, 0x18(SP)	
	incidlelocked(-1)
  0x4276fc		c70424ffffffff		MOVL $-0x1, 0(SP)		
  0x427703		e8f84c0000		CALL runtime.incidlelocked(SB)	
	_p_ := releasep()
  0x427708		e8c34a0000		CALL runtime.releasep(SB)	
  0x42770d		488b442418		MOVQ 0x18(SP), AX		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x427712		8400			TESTB AL, 0(AX)		
	_p_ := releasep()
  0x427714		488b0424		MOVQ 0(SP), AX		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x427718		488b4c2410		MOVQ 0x10(SP), CX	
  0x42771d		488981d8000000		MOVQ AX, 0xd8(CX)	
	notewakeup(&mp.park)
  0x427724		488d8148010000		LEAQ 0x148(CX), AX		
  0x42772b		48890424		MOVQ AX, 0(SP)			
  0x42772f		e85c20feff		CALL runtime.notewakeup(SB)	
	stopm()
  0x427734		e847f5ffff		CALL runtime.stopm(SB)	
}
  0x427739		488b6c2420		MOVQ 0x20(SP), BP	
  0x42773e		4883c428		ADDQ $0x28, SP		
  0x427742		c3			RET			
		throw("startlockedm: m has p")
  0x427743		488d05113c0400		LEAQ 0x43c11(IP), AX	
  0x42774a		48890424		MOVQ AX, 0(SP)		
  0x42774e		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x427757		e8749affff		CALL runtime.throw(SB)	
  0x42775c		0f0b			UD2			
		throw("startlockedm: locked to me")
  0x42775e		488d0545450400		LEAQ 0x44545(IP), AX	
  0x427765		48890424		MOVQ AX, 0(SP)		
  0x427769		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x427772		e8599affff		CALL runtime.throw(SB)	
  0x427777		0f0b			UD2			
func startlockedm(gp *g) {
  0x427779		e8f2cd0100		CALL runtime.morestack_noctxt(SB)	
  0x42777e		e91dffffff		JMP runtime.startlockedm(SB)		

TEXT runtime.gcstopm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gcstopm() {
  0x427790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427799		483b6110		CMPQ 0x10(CX), SP	
  0x42779d		0f86f6000000		JBE 0x427899		
  0x4277a3		4883ec20		SUBQ $0x20, SP		
  0x4277a7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4277ac		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x4277b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if sched.gcwaiting == 0 {
  0x4277ba		8b0d38020800		MOVL runtime.sched+216(SB), CX	
  0x4277c0		85c9			TESTL CX, CX			
  0x4277c2		0f84b6000000		JE 0x42787e			
	if _g_.m.spinning {
  0x4277c8		488b4030		MOVQ 0x30(AX), AX	
  0x4277cc		0fb68814010000		MOVZX 0x114(AX), CX	
  0x4277d3		84c9			TESTL CL, CL		
  0x4277d5		741d			JE 0x4277f4		
		_g_.m.spinning = false
  0x4277d7		c6801401000000		MOVB $0x0, 0x114(AX)	
		if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
  0x4277de		b8ffffffff		MOVL $-0x1, AX			
  0x4277e3		488d0d8a010800		LEAQ runtime.sched+84(SB), CX	
  0x4277ea		f00fc101		LOCK XADDL AX, 0(CX)		
  0x4277ee		ffc8			DECL AX				
  0x4277f0		85c0			TESTL AX, AX			
  0x4277f2		7c6f			JL 0x427863			
	_p_ := releasep()
  0x4277f4		e8d7490000		CALL runtime.releasep(SB)	
  0x4277f9		488b0424		MOVQ 0(SP), AX			
  0x4277fd		4889442410		MOVQ AX, 0x10(SP)		
	lock(&sched.lock)
  0x427802		488d0d27010800		LEAQ runtime.sched+16(SB), CX	
  0x427809		48890c24		MOVQ CX, 0(SP)			
  0x42780d		e80e1dfeff		CALL runtime.lock(SB)		
  0x427812		488b442410		MOVQ 0x10(SP), AX		
	_p_.status = _Pgcstop
  0x427817		c7400c03000000		MOVL $0x3, 0xc(AX)	
	sched.stopwait--
  0x42781e		8b05d8010800		MOVL runtime.sched+220(SB), AX	
  0x427824		8d48ff			LEAL -0x1(AX), CX		
  0x427827		890dcf010800		MOVL CX, runtime.sched+220(SB)	
	if sched.stopwait == 0 {
  0x42782d		83f801			CMPL $0x1, AX		
  0x427830		741f			JE 0x427851		
	unlock(&sched.lock)
  0x427832		488d05f7000800		LEAQ runtime.sched+16(SB), AX	
  0x427839		48890424		MOVQ AX, 0(SP)			
  0x42783d		e87e1efeff		CALL runtime.unlock(SB)		
	stopm()
  0x427842		e839f4ffff		CALL runtime.stopm(SB)	
}
  0x427847		488b6c2418		MOVQ 0x18(SP), BP	
  0x42784c		4883c420		ADDQ $0x20, SP		
  0x427850		c3			RET			
		notewakeup(&sched.stopnote)
  0x427851		488d05a8010800		LEAQ runtime.sched+224(SB), AX	
  0x427858		48890424		MOVQ AX, 0(SP)			
  0x42785c		e82f1ffeff		CALL runtime.notewakeup(SB)	
  0x427861		ebcf			JMP 0x427832			
			throw("gcstopm: negative nmspinning")
  0x427863		488d0584480400		LEAQ 0x44884(IP), AX	
  0x42786a		48890424		MOVQ AX, 0(SP)		
  0x42786e		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x427877		e85499ffff		CALL runtime.throw(SB)	
  0x42787c		0f0b			UD2			
		throw("gcstopm: not waiting for gc")
  0x42787e		488d05ab440400		LEAQ 0x444ab(IP), AX	
  0x427885		48890424		MOVQ AX, 0(SP)		
  0x427889		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x427892		e83999ffff		CALL runtime.throw(SB)	
  0x427897		0f0b			UD2			
func gcstopm() {
  0x427899		e8d2cc0100		CALL runtime.morestack_noctxt(SB)	
  0x42789e		e9edfeffff		JMP runtime.gcstopm(SB)			

TEXT runtime.execute(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func execute(gp *g, inheritTime bool) {
  0x4278b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4278b9		483b6110		CMPQ 0x10(CX), SP	
  0x4278bd		0f8652010000		JBE 0x427a15		
  0x4278c3		4883ec20		SUBQ $0x20, SP		
  0x4278c7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4278cc		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x4278d1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4278da		4889442410		MOVQ AX, 0x10(SP)	
  0x4278df		488b4c2428		MOVQ 0x28(SP), CX	
	casgstatus(gp, _Grunnable, _Grunning)
  0x4278e4		48890c24		MOVQ CX, 0(SP)			
  0x4278e8		48ba0100000002000000	MOVQ $0x200000001, DX		
  0x4278f2		4889542408		MOVQ DX, 0x8(SP)		
  0x4278f7		e884d1ffff		CALL runtime.casgstatus(SB)	
  0x4278fc		488b442428		MOVQ 0x28(SP), AX		
	gp.waitsince = 0
  0x427901		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	gp.preempt = false
  0x42790c		c680c000000000		MOVB $0x0, 0xc0(AX)	
	gp.stackguard0 = gp.stack.lo + _StackGuard
  0x427913		488b08			MOVQ 0(AX), CX		
  0x427916		4881c170030000		ADDQ $0x370, CX		
  0x42791d		48894810		MOVQ CX, 0x10(AX)	
func execute(gp *g, inheritTime bool) {
  0x427921		0fb64c2430		MOVZX 0x30(SP), CX	
  0x427926		84c9			TESTL CL, CL		
	if !inheritTime {
  0x427928		0f84cf000000		JE 0x4279fd		
  0x42792e		488b4c2410		MOVQ 0x10(SP), CX	
	_g_.m.curg = gp
  0x427933		488b5130		MOVQ 0x30(CX), DX			
  0x427937		8402			TESTB AL, 0(DX)				
  0x427939		8b1dd1c00900		MOVL runtime.writeBarrier(SB), BX	
  0x42793f		488dbac0000000		LEAQ 0xc0(DX), DI			
  0x427946		85db			TESTL BX, BX				
  0x427948		0f85a5000000		JNE 0x4279f3				
  0x42794e		488982c0000000		MOVQ AX, 0xc0(DX)			
	gp.m = _g_.m
  0x427955		8b15b5c00900		MOVL runtime.writeBarrier(SB), DX	
  0x42795b		488d7830		LEAQ 0x30(AX), DI			
  0x42795f		488b5930		MOVQ 0x30(CX), BX			
  0x427963		85d2			TESTL DX, DX				
  0x427965		7579			JNE 0x4279e0				
  0x427967		48895830		MOVQ BX, 0x30(AX)			
	if _g_.m.profilehz != hz {
  0x42796b		488b4930		MOVQ 0x30(CX), CX	
	hz := sched.profilehz
  0x42796f		8b15bb000800		MOVL runtime.sched+272(SB), DX	
	if _g_.m.profilehz != hz {
  0x427975		8b890c010000		MOVL 0x10c(CX), CX	
  0x42797b		39d1			CMPL DX, CX		
  0x42797d		7552			JNE 0x4279d1		
	if trace.enabled {
  0x42797f		0fb60d4abe0800		MOVZX runtime.trace+16(SB), CX	
  0x427986		84c9			TESTL CL, CL			
  0x427988		7419			JE 0x4279a3			
		if gp.syscallsp != 0 && gp.sysblocktraced {
  0x42798a		488b4870		MOVQ 0x70(AX), CX	
  0x42798e		4885c9			TESTQ CX, CX		
  0x427991		740b			JE 0x42799e		
  0x427993		0fb688c7000000		MOVZX 0xc7(AX), CX	
  0x42799a		84c9			TESTL CL, CL		
  0x42799c		7521			JNE 0x4279bf		
		traceGoStart()
  0x42799e		e8ad2f0100		CALL runtime.traceGoStart(SB)	
  0x4279a3		488b442428		MOVQ 0x28(SP), AX		
	gogo(&gp.sched)
  0x4279a8		4883c038		ADDQ $0x38, AX		
  0x4279ac		48890424		MOVQ AX, 0(SP)		
  0x4279b0		e88bc90100		CALL runtime.gogo(SB)	
}
  0x4279b5		488b6c2418		MOVQ 0x18(SP), BP	
  0x4279ba		4883c420		ADDQ $0x20, SP		
  0x4279be		c3			RET			
			traceGoSysExit(gp.sysexitticks)
  0x4279bf		488b88c8000000		MOVQ 0xc8(AX), CX		
  0x4279c6		48890c24		MOVQ CX, 0(SP)			
  0x4279ca		e851340100		CALL runtime.traceGoSysExit(SB)	
  0x4279cf		ebcd			JMP 0x42799e			
		setThreadCPUProfiler(hz)
  0x4279d1		891424			MOVL DX, 0(SP)				
  0x4279d4		e8a7a80000		CALL runtime.setThreadCPUProfiler(SB)	
  0x4279d9		488b442428		MOVQ 0x28(SP), AX			
  0x4279de		eb9f			JMP 0x42797f				
  0x4279e0		4889c2			MOVQ AX, DX				
  0x4279e3		4889d8			MOVQ BX, AX				
	gp.m = _g_.m
  0x4279e6		e8b5ee0100		CALL runtime.gcWriteBarrier(SB)	
  0x4279eb		4889d0			MOVQ DX, AX			
  0x4279ee		e978ffffff		JMP 0x42796b			
	_g_.m.curg = gp
  0x4279f3		e8a8ee0100		CALL runtime.gcWriteBarrier(SB)	
  0x4279f8		e958ffffff		JMP 0x427955			
  0x4279fd		488b4c2410		MOVQ 0x10(SP), CX		
		_g_.m.p.ptr().schedtick++
  0x427a02		488b5130		MOVQ 0x30(CX), DX	
  0x427a06		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x427a0d		ff4218			INCL 0x18(DX)		
  0x427a10		e919ffffff		JMP 0x42792e		
func execute(gp *g, inheritTime bool) {
  0x427a15		e856cb0100		CALL runtime.morestack_noctxt(SB)	
  0x427a1a		e991feffff		JMP runtime.execute(SB)			

TEXT runtime.findrunnable(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func findrunnable() (gp *g, inheritTime bool) {
  0x427a20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427a29		488d4424e0		LEAQ -0x20(SP), AX	
  0x427a2e		483b4110		CMPQ 0x10(CX), AX	
  0x427a32		0f868c0b0000		JBE 0x4285c4		
  0x427a38		4881eca0000000		SUBQ $0xa0, SP		
  0x427a3f		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x427a47		488dac2498000000	LEAQ 0x98(SP), BP	
  0x427a4f		488d442410		LEAQ 0x10(SP), AX	
  0x427a54		4889842490000000	MOVQ AX, 0x90(SP)	
	_g_ := getg()
  0x427a5c		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427a65		48898c2480000000	MOVQ CX, 0x80(SP)	
top:
  0x427a6d		e9ca040000		JMP 0x427f3c		
	enum.pos = (enum.pos + enum.inc) % enum.count
  0x427a72		31d2			XORL DX, DX		
  0x427a74		f7f1			DIVL CX			
  0x427a76		89542440		MOVL DX, 0x40(SP)	
  0x427a7a		4c8b442430		MOVQ 0x30(SP), R8	
  0x427a7f		4c8b8c2480000000	MOVQ 0x80(SP), R9	
	return enum.i == enum.count
  0x427a87		8b4c2438		MOVL 0x38(SP), CX	
  0x427a8b		8b54243c		MOVL 0x3c(SP), DX	
  0x427a8f		39d1			CMPL DX, CX		
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x427a91		0f84a9000000		JE 0x427b40		
			if sched.gcwaiting != 0 {
  0x427a97		8b055bff0700		MOVL runtime.sched+216(SB), AX	
  0x427a9d		85c0			TESTL AX, AX			
  0x427a9f		0f858b000000		JNE 0x427b30			
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x427aa5		8b442440		MOVL 0x40(SP), AX		
  0x427aa9		488b0d08fc0700		MOVQ runtime.allp+8(SB), CX	
  0x427ab0		488b15f9fb0700		MOVQ runtime.allp(SB), DX	
  0x427ab7		4839c8			CMPQ CX, AX			
  0x427aba		0f83e80a0000		JAE 0x4285a8			
  0x427ac0		488b04c2		MOVQ 0(DX)(AX*8), AX		
  0x427ac4		4889442408		MOVQ AX, 0x8(SP)		
  0x427ac9		488b842488000000	MOVQ 0x88(SP), AX		
  0x427ad1		48890424		MOVQ AX, 0(SP)			
			stealRunNextG := i > 2 // first look for ready queues with more than 1 g
  0x427ad5		4983f802		CMPQ $0x2, R8		
  0x427ad9		488b8c2490000000	MOVQ 0x90(SP), CX	
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x427ae1		0f9f01			SETG 0(CX)			
  0x427ae4		e887680000		CALL runtime.runqsteal(SB)	
  0x427ae9		488b442418		MOVQ 0x18(SP), AX		
  0x427aee		4885c0			TESTQ AX, AX			
  0x427af1		751d			JNE 0x427b10			
	enum.i++
  0x427af3		ff442438		INCL 0x38(SP)		
	enum.pos = (enum.pos + enum.inc) % enum.count
  0x427af7		8b442440		MOVL 0x40(SP), AX	
  0x427afb		03442444		ADDL 0x44(SP), AX	
  0x427aff		8b4c243c		MOVL 0x3c(SP), CX	
  0x427b03		85c9			TESTL CX, CX		
  0x427b05		0f8567ffffff		JNE 0x427a72		
  0x427b0b		e9910a0000		JMP 0x4285a1		
				return gp, false
  0x427b10		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x427b18		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x427b20		488bac2498000000	MOVQ 0x98(SP), BP	
  0x427b28		4881c4a0000000		ADDQ $0xa0, SP		
  0x427b2f		c3			RET			
  0x427b30		488b842490000000	MOVQ 0x90(SP), AX	
  0x427b38		4c89c9			MOVQ R9, CX		
				goto top
  0x427b3b		e9fc030000		JMP 0x427f3c		
	for i := 0; i < 4; i++ {
  0x427b40		498d4001		LEAQ 0x1(R8), AX	
  0x427b44		4c89ca			MOVQ R9, DX		
  0x427b47		4883f804		CMPQ $0x4, AX		
  0x427b4b		0f8da3000000		JGE 0x427bf4		
	mp := getg().m
  0x427b51		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427b5a		488b4930		MOVQ 0x30(CX), CX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x427b5e		8b9920010000		MOVL 0x120(CX), BX	
  0x427b64		8bb124010000		MOVL 0x124(CX), SI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x427b6a		89b120010000		MOVL SI, 0x120(CX)	
  0x427b70		89df			MOVL BX, DI		
	s1 ^= s1 << 17
  0x427b72		c1e311			SHLL $0x11, BX		
  0x427b75		31fb			XORL DI, BX		
  0x427b77		89f7			MOVL SI, DI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x427b79		31de			XORL BX, SI		
  0x427b7b		c1eb07			SHRL $0x7, BX		
  0x427b7e		31f3			XORL SI, BX		
  0x427b80		89fe			MOVL DI, SI		
  0x427b82		c1ef10			SHRL $0x10, DI		
  0x427b85		31df			XORL BX, DI		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x427b87		89b924010000		MOVL DI, 0x124(CX)	
	return s0 + s1
  0x427b8d		8d0c37			LEAL 0(DI)(SI*1), CX	
		count: ord.count,
  0x427b90		8b1d2afc0700		MOVL runtime.stealOrder(SB), BX	
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x427b96		488b352bfc0700		MOVQ runtime.stealOrder+8(SB), SI	
  0x427b9d		488b3d2cfc0700		MOVQ runtime.stealOrder+16(SB), DI	
		pos:   i % ord.count,
  0x427ba4		85db			TESTL BX, BX		
  0x427ba6		0f84110a0000		JE 0x4285bd		
  0x427bac		4989c0			MOVQ AX, R8		
  0x427baf		89c8			MOVL CX, AX		
  0x427bb1		4989d1			MOVQ DX, R9		
  0x427bb4		31d2			XORL DX, DX		
  0x427bb6		f7f3			DIVL BX			
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x427bb8		85ff			TESTL DI, DI		
  0x427bba		0f84f6090000		JE 0x4285b6		
  0x427bc0		89c8			MOVL CX, AX		
  0x427bc2		89d1			MOVL DX, CX		
  0x427bc4		31d2			XORL DX, DX		
  0x427bc6		f7f7			DIVL DI			
  0x427bc8		89d2			MOVL DX, DX		
  0x427bca		4839fa			CMPQ DI, DX		
  0x427bcd		0f83dc090000		JAE 0x4285af		
  0x427bd3		4c89442430		MOVQ R8, 0x30(SP)	
  0x427bd8		8b1496			MOVL 0(SI)(DX*4), DX	
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x427bdb		c744243800000000	MOVL $0x0, 0x38(SP)	
  0x427be3		895c243c		MOVL BX, 0x3c(SP)	
  0x427be7		894c2440		MOVL CX, 0x40(SP)	
  0x427beb		89542444		MOVL DX, 0x44(SP)	
  0x427bef		e993feffff		JMP 0x427a87		
  0x427bf4		488b842488000000	MOVQ 0x88(SP), AX	
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x427bfc		e997010000		JMP 0x427d98		
  0x427c01		488b5c2430		MOVQ 0x30(SP), BX	
	for _, _p_ := range allpSnapshot {
  0x427c06		488d4b01		LEAQ 0x1(BX), CX	
  0x427c0a		488b842480000000	MOVQ 0x80(SP), AX	
  0x427c12		0fb6542427		MOVZX 0x27(SP), DX	
  0x427c17		488b5c2428		MOVQ 0x28(SP), BX	
  0x427c1c		4839d9			CMPQ BX, CX		
  0x427c1f		0f8d80000000		JGE 0x427ca5		
  0x427c25		48894c2430		MOVQ CX, 0x30(SP)	
  0x427c2a		488b442470		MOVQ 0x70(SP), AX	
  0x427c2f		488b14c8		MOVQ 0(AX)(CX*8), DX	
		if !runqempty(_p_) {
  0x427c33		48891424		MOVQ DX, 0(SP)			
  0x427c37		e8d4610000		CALL runtime.runqempty(SB)	
  0x427c3c		0fb6442408		MOVZX 0x8(SP), AX		
  0x427c41		84c0			TESTL AL, AL			
  0x427c43		75bc			JNE 0x427c01			
			lock(&sched.lock)
  0x427c45		488d05e4fc0700		LEAQ runtime.sched+16(SB), AX	
  0x427c4c		48890424		MOVQ AX, 0(SP)			
  0x427c50		e8cb18feff		CALL runtime.lock(SB)		
	_p_ := sched.pidle.ptr()
  0x427c55		488b050cfd0700		MOVQ runtime.sched+72(SB), AX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x427c5c		4889842488000000	MOVQ AX, 0x88(SP)	
	if _p_ != nil {
  0x427c64		4885c0			TESTQ AX, AX		
  0x427c67		741b			JE 0x427c84		
		sched.pidle = _p_.link
  0x427c69		488b4810		MOVQ 0x10(AX), CX		
  0x427c6d		48890df4fc0700		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x427c74		b9ffffffff		MOVL $-0x1, CX			
  0x427c79		488d15f0fc0700		LEAQ runtime.sched+80(SB), DX	
  0x427c80		f00fc10a		LOCK XADDL CX, 0(DX)		
			unlock(&sched.lock)
  0x427c84		488d05a5fc0700		LEAQ runtime.sched+16(SB), AX	
  0x427c8b		48890424		MOVQ AX, 0(SP)			
  0x427c8f		e82c1afeff		CALL runtime.unlock(SB)		
  0x427c94		488b842488000000	MOVQ 0x88(SP), AX		
	if _p_ != nil {
  0x427c9c		4885c0			TESTQ AX, AX		
			if _p_ != nil {
  0x427c9f		0f8521050000		JNE 0x4281c6		
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(nil) {
  0x427ca5		8b0529bc0900		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x427cab		85c0			TESTL AX, AX				
  0x427cad		0f844b020000		JE 0x427efe				
	return atomic.Load64((*uint64)(head)) == 0
  0x427cb3		488b05e6000800		MOVQ runtime.work(SB), AX	
  0x427cba		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x427cbd		0f85f9040000		JNE 0x4281bc		
	if work.markrootNext < work.markrootJobs {
  0x427cc3		8b055f010800		MOVL runtime.work+136(SB), AX	
  0x427cc9		8b0d5d010800		MOVL runtime.work+140(SB), CX	
  0x427ccf		39c8			CMPL CX, AX			
  0x427cd1		0f83de040000		JAE 0x4281b5			
  0x427cd7		b801000000		MOVL $0x1, AX			
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(nil) {
  0x427cdc		84c0			TESTL AL, AL		
  0x427cde		0f841a020000		JE 0x427efe		
		lock(&sched.lock)
  0x427ce4		488d0545fc0700		LEAQ runtime.sched+16(SB), AX	
  0x427ceb		48890424		MOVQ AX, 0(SP)			
  0x427cef		e82c18feff		CALL runtime.lock(SB)		
	_p_ := sched.pidle.ptr()
  0x427cf4		488b056dfc0700		MOVQ runtime.sched+72(SB), AX	
	if _p_ != nil {
  0x427cfb		4885c0			TESTQ AX, AX		
  0x427cfe		0f84a5040000		JE 0x4281a9		
		sched.pidle = _p_.link
  0x427d04		488b4810		MOVQ 0x10(AX), CX		
  0x427d08		48890d59fc0700		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x427d0f		b9ffffffff		MOVL $-0x1, CX			
  0x427d14		488d1555fc0700		LEAQ runtime.sched+80(SB), DX	
  0x427d1b		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x427d1f		4885c0			TESTQ AX, AX		
		if _p_ != nil && _p_.gcBgMarkWorker == 0 {
  0x427d22		7410			JE 0x427d34		
  0x427d24		488b8858120000		MOVQ 0x1258(AX), CX	
  0x427d2b		4885c9			TESTQ CX, CX		
  0x427d2e		0f8465040000		JE 0x428199		
  0x427d34		4889442478		MOVQ AX, 0x78(SP)	
		unlock(&sched.lock)
  0x427d39		488d0df0fb0700		LEAQ runtime.sched+16(SB), CX	
  0x427d40		48890c24		MOVQ CX, 0(SP)			
  0x427d44		e87719feff		CALL runtime.unlock(SB)		
  0x427d49		488b442478		MOVQ 0x78(SP), AX		
		if _p_ != nil {
  0x427d4e		4885c0			TESTQ AX, AX		
  0x427d51		0f84a7010000		JE 0x427efe		
			acquirep(_p_)
  0x427d57		48890424		MOVQ AX, 0(SP)			
  0x427d5b		e880420000		CALL runtime.acquirep(SB)	
  0x427d60		0fb6442427		MOVZX 0x27(SP), AX		
	wasSpinning := _g_.m.spinning
  0x427d65		84c0			TESTL AL, AL		
			if wasSpinning {
  0x427d67		0f8484010000		JE 0x427ef1		
  0x427d6d		488b842480000000	MOVQ 0x80(SP), AX	
				_g_.m.spinning = true
  0x427d75		488b4830		MOVQ 0x30(AX), CX	
  0x427d79		c6811401000001		MOVB $0x1, 0x114(CX)	
				atomic.Xadd(&sched.nmspinning, 1)
  0x427d80		b901000000		MOVL $0x1, CX			
  0x427d85		488d15e8fb0700		LEAQ runtime.sched+84(SB), DX	
  0x427d8c		f00fc10a		LOCK XADDL CX, 0(DX)		
  0x427d90		4889c2			MOVQ AX, DX			
  0x427d93		488b442478		MOVQ 0x78(SP), AX		
			goto stop
  0x427d98		4889442448		MOVQ AX, 0x48(SP)	
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x427d9d		8b0d31bb0900		MOVL runtime.gcBlackenEnabled(SB), CX	
  0x427da3		85c9			TESTL CX, CX				
  0x427da5		747e			JE 0x427e25				
  0x427da7		8400			TESTB AL, 0(AX)				
  0x427da9		488b8858120000		MOVQ 0x1258(AX), CX			
  0x427db0		4885c9			TESTQ CX, CX				
  0x427db3		7470			JE 0x427e25				
	if p != nil && !p.gcw.empty() {
  0x427db5		488d8870120000		LEAQ 0x1270(AX), CX	
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x427dbc		8401			TESTB AL, 0(CX)		
  0x427dbe		488b8870120000		MOVQ 0x1270(AX), CX	
  0x427dc5		4885c9			TESTQ CX, CX		
  0x427dc8		0f8464050000		JE 0x428332		
  0x427dce		488b4910		MOVQ 0x10(CX), CX	
  0x427dd2		4885c9			TESTQ CX, CX		
  0x427dd5		0f8550050000		JNE 0x42832b		
  0x427ddb		488b8878120000		MOVQ 0x1278(AX), CX	
  0x427de2		488b4910		MOVQ 0x10(CX), CX	
  0x427de6		4885c9			TESTQ CX, CX		
  0x427de9		0f94c1			SETE CL			
  0x427dec		84c9			TESTL CL, CL		
	if p != nil && !p.gcw.empty() {
  0x427dee		0f842d050000		JE 0x428321		
	return atomic.Load64((*uint64)(head)) == 0
  0x427df4		488b0da5ff0700		MOVQ runtime.work(SB), CX	
  0x427dfb		4885c9			TESTQ CX, CX			
	if !work.full.empty() {
  0x427dfe		0f8513050000		JNE 0x428317		
	if work.markrootNext < work.markrootJobs {
  0x427e04		8b0d1e000800		MOVL runtime.work+136(SB), CX	
  0x427e0a		8b1d1c000800		MOVL runtime.work+140(SB), BX	
  0x427e10		39d9			CMPL BX, CX			
  0x427e12		0f83f8040000		JAE 0x428310			
  0x427e18		b901000000		MOVL $0x1, CX			
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x427e1d		84c9			TESTL CL, CL		
  0x427e1f		0f856a040000		JNE 0x42828f		
	allpSnapshot := allp
  0x427e25		488b058cf80700		MOVQ runtime.allp+8(SB), AX	
  0x427e2c		4889442428		MOVQ AX, 0x28(SP)		
  0x427e31		488b0d78f80700		MOVQ runtime.allp(SB), CX	
  0x427e38		48894c2470		MOVQ CX, 0x70(SP)		
	lock(&sched.lock)
  0x427e3d		488d15ecfa0700		LEAQ runtime.sched+16(SB), DX	
  0x427e44		48891424		MOVQ DX, 0(SP)			
  0x427e48		e8d316feff		CALL runtime.lock(SB)		
	if sched.gcwaiting != 0 || _p_.runSafePointFn != 0 {
  0x427e4d		8b05a5fb0700		MOVL runtime.sched+216(SB), AX	
  0x427e53		85c0			TESTL AX, AX			
  0x427e55		0f850f040000		JNE 0x42826a			
  0x427e5b		488b442448		MOVQ 0x48(SP), AX		
  0x427e60		8400			TESTB AL, 0(AX)			
  0x427e62		8b88a0220000		MOVL 0x22a0(AX), CX		
  0x427e68		85c9			TESTL CX, CX			
  0x427e6a		0f85fa030000		JNE 0x42826a			
	if sched.runqsize != 0 {
  0x427e70		8b0d12fb0700		MOVL runtime.sched+104(SB), CX	
  0x427e76		85c9			TESTL CX, CX			
  0x427e78		0f859c030000		JNE 0x42821a			
	if releasep() != _p_ {
  0x427e7e		e84d430000		CALL runtime.releasep(SB)	
  0x427e83		488b0424		MOVQ 0(SP), AX			
  0x427e87		488b4c2448		MOVQ 0x48(SP), CX		
  0x427e8c		4839c8			CMPQ CX, AX			
  0x427e8f		0f85f1060000		JNE 0x428586			
	pidleput(_p_)
  0x427e95		48890c24		MOVQ CX, 0(SP)			
  0x427e99		e8d25e0000		CALL runtime.pidleput(SB)	
	unlock(&sched.lock)
  0x427e9e		488d058bfa0700		LEAQ runtime.sched+16(SB), AX	
  0x427ea5		48890424		MOVQ AX, 0(SP)			
  0x427ea9		e81218feff		CALL runtime.unlock(SB)		
  0x427eae		488b842480000000	MOVQ 0x80(SP), AX		
	if _g_.m.spinning {
  0x427eb6		488b4830		MOVQ 0x30(AX), CX	
	wasSpinning := _g_.m.spinning
  0x427eba		0fb69114010000		MOVZX 0x114(CX), DX	
  0x427ec1		84d2			TESTL DL, DL		
	if _g_.m.spinning {
  0x427ec3		7421			JE 0x427ee6		
		_g_.m.spinning = false
  0x427ec5		c6811401000000		MOVB $0x0, 0x114(CX)	
		if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
  0x427ecc		b9ffffffff		MOVL $-0x1, CX			
  0x427ed1		488d1d9cfa0700		LEAQ runtime.sched+84(SB), BX	
  0x427ed8		f00fc10b		LOCK XADDL CX, 0(BX)		
  0x427edc		ffc9			DECL CX				
  0x427ede		85c9			TESTL CX, CX			
  0x427ee0		0f8c85060000		JL 0x42856b			
  0x427ee6		88542427		MOVB DL, 0x27(SP)		
  0x427eea		31c9			XORL CX, CX			
	for _, _p_ := range allpSnapshot {
  0x427eec		e926fdffff		JMP 0x427c17		
  0x427ef1		488b842480000000	MOVQ 0x80(SP), AX	
			if wasSpinning {
  0x427ef9		e992feffff		JMP 0x427d90		
	return atomic.Load(&netpollInited) != 0
  0x427efe		8b05e4b90900		MOVL runtime.netpollInited(SB), AX	
  0x427f04		85c0			TESTL AX, AX				
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Xchg64(&sched.lastpoll, 0) != 0 {
  0x427f06		741f			JE 0x427f27				
  0x427f08		8b05deb90900		MOVL runtime.netpollWaiters(SB), AX	
  0x427f0e		85c0			TESTL AX, AX				
  0x427f10		7615			JBE 0x427f27				
  0x427f12		31c0			XORL AX, AX				
  0x427f14		488d0d0dfa0700		LEAQ runtime.sched+8(SB), CX		
  0x427f1b		488701			XCHGQ AX, 0(CX)				
  0x427f1e		4885c0			TESTQ AX, AX				
  0x427f21		0f8520010000		JNE 0x428047				
	stopm()
  0x427f27		e854edffff		CALL runtime.stopm(SB)	
  0x427f2c		488b842490000000	MOVQ 0x90(SP), AX	
  0x427f34		488b8c2480000000	MOVQ 0x80(SP), CX	
	_p_ := _g_.m.p.ptr()
  0x427f3c		488b5130		MOVQ 0x30(CX), DX	
  0x427f40		488b92d0000000		MOVQ 0xd0(DX), DX	
	if sched.gcwaiting != 0 {
  0x427f47		8b1dabfa0700		MOVL runtime.sched+216(SB), BX	
  0x427f4d		85db			TESTL BX, BX			
  0x427f4f		7417			JE 0x427f68			
		gcstopm()
  0x427f51		e83af8ffff		CALL runtime.gcstopm(SB)	
  0x427f56		488b842490000000	MOVQ 0x90(SP), AX		
  0x427f5e		488b8c2480000000	MOVQ 0x80(SP), CX		
		goto top
  0x427f66		ebd4			JMP 0x427f3c		
  0x427f68		4889942488000000	MOVQ DX, 0x88(SP)	
	if _p_.runSafePointFn != 0 {
  0x427f70		8402			TESTB AL, 0(DX)		
  0x427f72		8b9aa0220000		MOVL 0x22a0(DX), BX	
  0x427f78		85db			TESTL BX, BX		
  0x427f7a		0f8593050000		JNE 0x428513		
	if fingwait && fingwake {
  0x427f80		0fb61d1eb90900		MOVZX runtime.fingwait(SB), BX	
  0x427f87		84db			TESTL BL, BL			
  0x427f89		740f			JE 0x427f9a			
  0x427f8b		0fb61d14b90900		MOVZX runtime.fingwake(SB), BX	
  0x427f92		84db			TESTL BL, BL			
  0x427f94		0f8539050000		JNE 0x4284d3			
	if *cgo_yield != nil {
  0x427f9a		488b1d7fda0700		MOVQ 0x7da7f(IP), BX	
  0x427fa1		488b1b			MOVQ 0(BX), BX		
  0x427fa4		4885db			TESTQ BX, BX		
  0x427fa7		0f8507050000		JNE 0x4284b4		
	if gp, inheritTime := runqget(_p_); gp != nil {
  0x427fad		48891424		MOVQ DX, 0(SP)			
  0x427fb1		e8ba610000		CALL runtime.runqget(SB)	
  0x427fb6		488b442408		MOVQ 0x8(SP), AX		
  0x427fbb		0fb64c2410		MOVZX 0x10(SP), CX		
  0x427fc0		4885c0			TESTQ AX, AX			
  0x427fc3		0f85cc040000		JNE 0x428495			
	if sched.runqsize != 0 {
  0x427fc9		8b0db9f90700		MOVL runtime.sched+104(SB), CX	
  0x427fcf		85c9			TESTL CX, CX			
  0x427fd1		0f854d040000		JNE 0x428424			
	return atomic.Load(&netpollInited) != 0
  0x427fd7		8b0d0bb90900		MOVL runtime.netpollInited(SB), CX	
  0x427fdd		85c9			TESTL CX, CX				
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {
  0x427fdf		741a			JE 0x427ffb				
  0x427fe1		8b0d05b90900		MOVL runtime.netpollWaiters(SB), CX	
  0x427fe7		85c9			TESTL CX, CX				
  0x427fe9		7610			JBE 0x427ffb				
  0x427feb		488b0d36f90700		MOVQ runtime.sched+8(SB), CX		
  0x427ff2		4885c9			TESTQ CX, CX				
  0x427ff5		0f8597030000		JNE 0x428392				
	procs := uint32(gomaxprocs)
  0x427ffb		8b0ddfb80900		MOVL runtime.gomaxprocs(SB), CX	
	if atomic.Load(&sched.npidle) == procs-1 {
  0x428001		8b1569f90700		MOVL runtime.sched+80(SB), DX	
  0x428007		8d59ff			LEAL -0x1(CX), BX		
  0x42800a		39d3			CMPL DX, BX			
  0x42800c		0f846b030000		JE 0x42837d			
  0x428012		488b942480000000	MOVQ 0x80(SP), DX		
	if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= procs-atomic.Load(&sched.npidle) {
  0x42801a		488b5a30		MOVQ 0x30(DX), BX	
  0x42801e		0fb69b14010000		MOVZX 0x114(BX), BX	
  0x428025		84db			TESTL BL, BL		
  0x428027		0f842b030000		JE 0x428358		
	if !_g_.m.spinning {
  0x42802d		488b4a30		MOVQ 0x30(DX), CX	
  0x428031		0fb69914010000		MOVZX 0x114(CX), BX	
  0x428038		84db			TESTL BL, BL		
  0x42803a		0f84fc020000		JE 0x42833c		
  0x428040		31c0			XORL AX, AX		
	for i := 0; i < 4; i++ {
  0x428042		e900fbffff		JMP 0x427b47		
  0x428047		488b842480000000	MOVQ 0x80(SP), AX	
		if _g_.m.p != 0 {
  0x42804f		488b5030		MOVQ 0x30(AX), DX	
  0x428053		488b9ad0000000		MOVQ 0xd0(DX), BX	
  0x42805a		4885db			TESTQ BX, BX		
  0x42805d		0f85ed040000		JNE 0x428550		
		if _g_.m.spinning {
  0x428063		0fb69214010000		MOVZX 0x114(DX), DX	
  0x42806a		84d2			TESTL DL, DL		
  0x42806c		0f85c3040000		JNE 0x428535		
		gp := netpoll(true) // block until new work is available
  0x428072		c6042401		MOVB $0x1, 0(SP)		
  0x428076		e8b569ffff		CALL runtime.netpoll(SB)	
  0x42807b		488b442408		MOVQ 0x8(SP), AX		
  0x428080		4889442450		MOVQ AX, 0x50(SP)		
		atomic.Store64(&sched.lastpoll, uint64(nanotime()))
  0x428085		e8a6f90100		CALL runtime.nanotime(SB)	
  0x42808a		488b0424		MOVQ 0(SP), AX			
  0x42808e		488d0d93f80700		LEAQ runtime.sched+8(SB), CX	
  0x428095		488701			XCHGQ AX, 0(CX)			
  0x428098		488b442450		MOVQ 0x50(SP), AX		
		if gp != nil {
  0x42809d		4885c0			TESTQ AX, AX		
  0x4280a0		0f8481feffff		JE 0x427f27		
			lock(&sched.lock)
  0x4280a6		488d0583f80700		LEAQ runtime.sched+16(SB), AX	
  0x4280ad		48890424		MOVQ AX, 0(SP)			
  0x4280b1		e86a14feff		CALL runtime.lock(SB)		
	_p_ := sched.pidle.ptr()
  0x4280b6		488b05abf80700		MOVQ runtime.sched+72(SB), AX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x4280bd		4889842488000000	MOVQ AX, 0x88(SP)	
	if _p_ != nil {
  0x4280c5		4885c0			TESTQ AX, AX		
  0x4280c8		741b			JE 0x4280e5		
		sched.pidle = _p_.link
  0x4280ca		488b4810		MOVQ 0x10(AX), CX		
  0x4280ce		48890d93f80700		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x4280d5		b9ffffffff		MOVL $-0x1, CX			
  0x4280da		488d158ff80700		LEAQ runtime.sched+80(SB), DX	
  0x4280e1		f00fc10a		LOCK XADDL CX, 0(DX)		
			unlock(&sched.lock)
  0x4280e5		488d0544f80700		LEAQ runtime.sched+16(SB), AX	
  0x4280ec		48890424		MOVQ AX, 0(SP)			
  0x4280f0		e8cb15feff		CALL runtime.unlock(SB)		
  0x4280f5		488b842488000000	MOVQ 0x88(SP), AX		
	if _p_ != nil {
  0x4280fd		4885c0			TESTQ AX, AX		
			if _p_ != nil {
  0x428100		7513			JNE 0x428115		
  0x428102		488b442450		MOVQ 0x50(SP), AX	
			injectglist(gp)
  0x428107		48890424		MOVQ AX, 0(SP)			
  0x42810b		e860060000		CALL runtime.injectglist(SB)	
  0x428110		e912feffff		JMP 0x427f27			
				acquirep(_p_)
  0x428115		48890424		MOVQ AX, 0(SP)			
  0x428119		e8c23e0000		CALL runtime.acquirep(SB)	
  0x42811e		488b442450		MOVQ 0x50(SP), AX		
				injectglist(gp.schedlink.ptr())
  0x428123		488b88b8000000		MOVQ 0xb8(AX), CX		
  0x42812a		48890c24		MOVQ CX, 0(SP)			
  0x42812e		e83d060000		CALL runtime.injectglist(SB)	
  0x428133		488b442450		MOVQ 0x50(SP), AX		
				casgstatus(gp, _Gwaiting, _Grunnable)
  0x428138		48890424		MOVQ AX, 0(SP)			
  0x42813c		48b90400000001000000	MOVQ $0x100000004, CX		
  0x428146		48894c2408		MOVQ CX, 0x8(SP)		
  0x42814b		e830c9ffff		CALL runtime.casgstatus(SB)	
				if trace.enabled {
  0x428150		0fb60579b60800		MOVZX runtime.trace+16(SB), AX	
  0x428157		84c0			TESTL AL, AL			
  0x428159		7525			JNE 0x428180			
				return gp, false
  0x42815b		488b442450		MOVQ 0x50(SP), AX	
  0x428160		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x428168		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x428170		488bac2498000000	MOVQ 0x98(SP), BP	
  0x428178		4881c4a0000000		ADDQ $0xa0, SP		
  0x42817f		c3			RET			
  0x428180		488b442450		MOVQ 0x50(SP), AX	
					traceGoUnpark(gp, 0)
  0x428185		48890424		MOVQ AX, 0(SP)			
  0x428189		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x428192		e8292b0100		CALL runtime.traceGoUnpark(SB)	
  0x428197		ebc2			JMP 0x42815b			
			pidleput(_p_)
  0x428199		48890424		MOVQ AX, 0(SP)			
  0x42819d		e8ce5b0000		CALL runtime.pidleput(SB)	
  0x4281a2		31c0			XORL AX, AX			
			_p_ = nil
  0x4281a4		e98bfbffff		JMP 0x427d34			
  0x4281a9		488d15c0f70700		LEAQ runtime.sched+80(SB), DX	
	if _p_ != nil {
  0x4281b0		e96dfbffff		JMP 0x427d22		
  0x4281b5		31c0			XORL AX, AX		
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(nil) {
  0x4281b7		e920fbffff		JMP 0x427cdc		
  0x4281bc		b801000000		MOVL $0x1, AX		
  0x4281c1		e916fbffff		JMP 0x427cdc		
				acquirep(_p_)
  0x4281c6		48890424		MOVQ AX, 0(SP)			
  0x4281ca		e8113e0000		CALL runtime.acquirep(SB)	
  0x4281cf		0fb6442427		MOVZX 0x27(SP), AX		
	wasSpinning := _g_.m.spinning
  0x4281d4		84c0			TESTL AL, AL		
				if wasSpinning {
  0x4281d6		7438			JE 0x428210		
  0x4281d8		488b842480000000	MOVQ 0x80(SP), AX	
					_g_.m.spinning = true
  0x4281e0		488b4830		MOVQ 0x30(AX), CX	
  0x4281e4		c6811401000001		MOVB $0x1, 0x114(CX)	
					atomic.Xadd(&sched.nmspinning, 1)
  0x4281eb		b901000000		MOVL $0x1, CX			
  0x4281f0		488d157df70700		LEAQ runtime.sched+84(SB), DX	
  0x4281f7		f00fc10a		LOCK XADDL CX, 0(DX)		
  0x4281fb		488b842490000000	MOVQ 0x90(SP), AX		
  0x428203		488b8c2480000000	MOVQ 0x80(SP), CX		
				goto top
  0x42820b		e92cfdffff		JMP 0x427f3c		
  0x428210		488b842480000000	MOVQ 0x80(SP), AX	
				if wasSpinning {
  0x428218		ebe1			JMP 0x4281fb		
		gp := globrunqget(_p_, 0)
  0x42821a		48890424		MOVQ AX, 0(SP)			
  0x42821e		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x428226		e8055a0000		CALL runtime.globrunqget(SB)	
  0x42822b		488b442410		MOVQ 0x10(SP), AX		
  0x428230		4889442468		MOVQ AX, 0x68(SP)		
		unlock(&sched.lock)
  0x428235		488d0df4f60700		LEAQ runtime.sched+16(SB), CX	
  0x42823c		48890c24		MOVQ CX, 0(SP)			
  0x428240		e87b14feff		CALL runtime.unlock(SB)		
		return gp, false
  0x428245		488b442468		MOVQ 0x68(SP), AX	
  0x42824a		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x428252		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x42825a		488bac2498000000	MOVQ 0x98(SP), BP	
  0x428262		4881c4a0000000		ADDQ $0xa0, SP		
  0x428269		c3			RET			
		unlock(&sched.lock)
  0x42826a		488d05bff60700		LEAQ runtime.sched+16(SB), AX	
  0x428271		48890424		MOVQ AX, 0(SP)			
  0x428275		e84614feff		CALL runtime.unlock(SB)		
  0x42827a		488b842490000000	MOVQ 0x90(SP), AX		
  0x428282		488b8c2480000000	MOVQ 0x80(SP), CX		
		goto top
  0x42828a		e9adfcffff		JMP 0x427f3c		
		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode
  0x42828f		48c7806012000002000000	MOVQ $0x2, 0x1260(AX)	
		gp := _p_.gcBgMarkWorker.ptr()
  0x42829a		488b8058120000		MOVQ 0x1258(AX), AX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x4282a1		4889842488000000	MOVQ AX, 0x88(SP)	
		casgstatus(gp, _Gwaiting, _Grunnable)
  0x4282a9		48890424		MOVQ AX, 0(SP)			
  0x4282ad		48b90400000001000000	MOVQ $0x100000004, CX		
  0x4282b7		48894c2408		MOVQ CX, 0x8(SP)		
  0x4282bc		e8bfc7ffff		CALL runtime.casgstatus(SB)	
		if trace.enabled {
  0x4282c1		0fb60508b50800		MOVZX runtime.trace+16(SB), AX	
  0x4282c8		84c0			TESTL AL, AL			
  0x4282ca		7528			JNE 0x4282f4			
		return gp, false
  0x4282cc		488b842488000000	MOVQ 0x88(SP), AX	
  0x4282d4		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x4282dc		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x4282e4		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4282ec		4881c4a0000000		ADDQ $0xa0, SP		
  0x4282f3		c3			RET			
  0x4282f4		488b842488000000	MOVQ 0x88(SP), AX	
			traceGoUnpark(gp, 0)
  0x4282fc		48890424		MOVQ AX, 0(SP)			
  0x428300		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x428309		e8b2290100		CALL runtime.traceGoUnpark(SB)	
  0x42830e		ebbc			JMP 0x4282cc			
  0x428310		31c9			XORL CX, CX			
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x428312		e906fbffff		JMP 0x427e1d		
  0x428317		b901000000		MOVL $0x1, CX		
  0x42831c		e9fcfaffff		JMP 0x427e1d		
  0x428321		b901000000		MOVL $0x1, CX		
  0x428326		e9f2faffff		JMP 0x427e1d		
  0x42832b		31c9			XORL CX, CX		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x42832d		e9bafaffff		JMP 0x427dec		
  0x428332		b901000000		MOVL $0x1, CX		
  0x428337		e9b0faffff		JMP 0x427dec		
		_g_.m.spinning = true
  0x42833c		c6811401000001		MOVB $0x1, 0x114(CX)	
		atomic.Xadd(&sched.nmspinning, 1)
  0x428343		b901000000		MOVL $0x1, CX			
  0x428348		488d1d25f60700		LEAQ runtime.sched+84(SB), BX	
  0x42834f		f00fc10b		LOCK XADDL CX, 0(BX)		
  0x428353		e9e8fcffff		JMP 0x428040			
	if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= procs-atomic.Load(&sched.npidle) {
  0x428358		8b1d16f60700		MOVL runtime.sched+84(SB), BX	
  0x42835e		8b350cf60700		MOVL runtime.sched+80(SB), SI	
  0x428364		d1e3			SHLL $0x1, BX			
  0x428366		29f1			SUBL SI, CX			
  0x428368		39cb			CMPL CX, BX			
  0x42836a		0f82bdfcffff		JB 0x42802d			
  0x428370		488b842488000000	MOVQ 0x88(SP), AX		
		goto stop
  0x428378		e91bfaffff		JMP 0x427d98		
  0x42837d		488b942480000000	MOVQ 0x80(SP), DX	
  0x428385		488b842488000000	MOVQ 0x88(SP), AX	
		goto stop
  0x42838d		e906faffff		JMP 0x427d98		
		if gp := netpoll(false); gp != nil { // non-blocking
  0x428392		c6042400		MOVB $0x0, 0(SP)		
  0x428396		e89566ffff		CALL runtime.netpoll(SB)	
  0x42839b		488b442408		MOVQ 0x8(SP), AX		
  0x4283a0		4885c0			TESTQ AX, AX			
  0x4283a3		0f8452fcffff		JE 0x427ffb			
  0x4283a9		4889442458		MOVQ AX, 0x58(SP)		
			injectglist(gp.schedlink.ptr())
  0x4283ae		488b88b8000000		MOVQ 0xb8(AX), CX		
  0x4283b5		48890c24		MOVQ CX, 0(SP)			
  0x4283b9		e8b2030000		CALL runtime.injectglist(SB)	
  0x4283be		488b442458		MOVQ 0x58(SP), AX		
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x4283c3		48890424		MOVQ AX, 0(SP)			
  0x4283c7		48b90400000001000000	MOVQ $0x100000004, CX		
  0x4283d1		48894c2408		MOVQ CX, 0x8(SP)		
  0x4283d6		e8a5c6ffff		CALL runtime.casgstatus(SB)	
			if trace.enabled {
  0x4283db		0fb605eeb30800		MOVZX runtime.trace+16(SB), AX	
  0x4283e2		84c0			TESTL AL, AL			
  0x4283e4		7525			JNE 0x42840b			
			return gp, false
  0x4283e6		488b442458		MOVQ 0x58(SP), AX	
  0x4283eb		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x4283f3		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x4283fb		488bac2498000000	MOVQ 0x98(SP), BP	
  0x428403		4881c4a0000000		ADDQ $0xa0, SP		
  0x42840a		c3			RET			
  0x42840b		488b442458		MOVQ 0x58(SP), AX	
				traceGoUnpark(gp, 0)
  0x428410		48890424		MOVQ AX, 0(SP)			
  0x428414		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42841d		e89e280100		CALL runtime.traceGoUnpark(SB)	
  0x428422		ebc2			JMP 0x4283e6			
		lock(&sched.lock)
  0x428424		488d0505f50700		LEAQ runtime.sched+16(SB), AX	
  0x42842b		48890424		MOVQ AX, 0(SP)			
  0x42842f		e8ec10feff		CALL runtime.lock(SB)		
  0x428434		488b842488000000	MOVQ 0x88(SP), AX		
		gp := globrunqget(_p_, 0)
  0x42843c		48890424		MOVQ AX, 0(SP)			
  0x428440		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x428448		e8e3570000		CALL runtime.globrunqget(SB)	
  0x42844d		488b442410		MOVQ 0x10(SP), AX		
  0x428452		4889442460		MOVQ AX, 0x60(SP)		
		unlock(&sched.lock)
  0x428457		488d0dd2f40700		LEAQ runtime.sched+16(SB), CX	
  0x42845e		48890c24		MOVQ CX, 0(SP)			
  0x428462		e85912feff		CALL runtime.unlock(SB)		
  0x428467		488b442460		MOVQ 0x60(SP), AX		
		if gp != nil {
  0x42846c		4885c0			TESTQ AX, AX		
  0x42846f		0f8462fbffff		JE 0x427fd7		
			return gp, false
  0x428475		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x42847d		c68424b000000000	MOVB $0x0, 0xb0(SP)	
  0x428485		488bac2498000000	MOVQ 0x98(SP), BP	
  0x42848d		4881c4a0000000		ADDQ $0xa0, SP		
  0x428494		c3			RET			
		return gp, inheritTime
  0x428495		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x42849d		888c24b0000000		MOVB CL, 0xb0(SP)	
  0x4284a4		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4284ac		4881c4a0000000		ADDQ $0xa0, SP		
  0x4284b3		c3			RET			
		asmcgocall(*cgo_yield, nil)
  0x4284b4		48891c24		MOVQ BX, 0(SP)			
  0x4284b8		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4284c1		e82ad70100		CALL runtime.asmcgocall(SB)	
  0x4284c6		488b942488000000	MOVQ 0x88(SP), DX		
  0x4284ce		e9dafaffff		JMP 0x427fad			
		if gp := wakefing(); gp != nil {
  0x4284d3		e8c874feff		CALL runtime.wakefing(SB)	
  0x4284d8		488b0424		MOVQ 0(SP), AX			
  0x4284dc		4885c0			TESTQ AX, AX			
  0x4284df		751d			JNE 0x4284fe			
  0x4284e1		488b842490000000	MOVQ 0x90(SP), AX		
  0x4284e9		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x4284f1		488b942488000000	MOVQ 0x88(SP), DX		
	if *cgo_yield != nil {
  0x4284f9		e99cfaffff		JMP 0x427f9a		
			ready(gp, 0, true)
  0x4284fe		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x428507		c644241001		MOVB $0x1, 0x10(SP)	
  0x42850c		e83fbaffff		CALL runtime.ready(SB)	
  0x428511		ebce			JMP 0x4284e1		
		runSafePointFn()
  0x428513		e828daffff		CALL runtime.runSafePointFn(SB)	
  0x428518		488b842490000000	MOVQ 0x90(SP), AX		
  0x428520		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x428528		488b942488000000	MOVQ 0x88(SP), DX		
  0x428530		e94bfaffff		JMP 0x427f80			
			throw("findrunnable: netpoll with spinning")
  0x428535		488d05d0470400		LEAQ 0x447d0(IP), AX	
  0x42853c		48890424		MOVQ AX, 0(SP)		
  0x428540		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x428549		e8828cffff		CALL runtime.throw(SB)	
  0x42854e		0f0b			UD2			
			throw("findrunnable: netpoll with p")
  0x428550		488d055f3b0400		LEAQ 0x43b5f(IP), AX	
  0x428557		48890424		MOVQ AX, 0(SP)		
  0x42855b		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x428564		e8678cffff		CALL runtime.throw(SB)	
  0x428569		0f0b			UD2			
			throw("findrunnable: negative nmspinning")
  0x42856b		488d0575440400		LEAQ 0x44475(IP), AX	
  0x428572		48890424		MOVQ AX, 0(SP)		
  0x428576		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x42857f		e84c8cffff		CALL runtime.throw(SB)	
  0x428584		0f0b			UD2			
		throw("findrunnable: wrong p")
  0x428586		488d05262d0400		LEAQ 0x42d26(IP), AX	
  0x42858d		48890424		MOVQ AX, 0(SP)		
  0x428591		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42859a		e8318cffff		CALL runtime.throw(SB)	
  0x42859f		0f0b			UD2			
	enum.pos = (enum.pos + enum.inc) % enum.count
  0x4285a1		e87a75ffff		CALL runtime.panicdivide(SB)	
  0x4285a6		0f0b			UD2				
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x4285a8		e89374ffff		CALL runtime.panicindex(SB)	
  0x4285ad		0f0b			UD2				
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x4285af		e88c74ffff		CALL runtime.panicindex(SB)	
  0x4285b4		0f0b			UD2				
  0x4285b6		e86575ffff		CALL runtime.panicdivide(SB)	
  0x4285bb		0f0b			UD2				
		pos:   i % ord.count,
  0x4285bd		e85e75ffff		CALL runtime.panicdivide(SB)	
  0x4285c2		0f0b			UD2				
func findrunnable() (gp *g, inheritTime bool) {
  0x4285c4		e8a7bf0100		CALL runtime.morestack_noctxt(SB)	
  0x4285c9		e952f4ffff		JMP runtime.findrunnable(SB)		

TEXT runtime.pollWork(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func pollWork() bool {
  0x4285d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4285d9		483b6110		CMPQ 0x10(CX), SP	
  0x4285dd		0f86ba000000		JBE 0x42869d		
  0x4285e3		4883ec18		SUBQ $0x18, SP		
  0x4285e7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4285ec		488d6c2410		LEAQ 0x10(SP), BP	
	if sched.runqsize != 0 {
  0x4285f1		8b0591f30700		MOVL runtime.sched+104(SB), AX	
  0x4285f7		85c0			TESTL AX, AX			
  0x4285f9		0f858f000000		JNE 0x42868e			
	p := getg().m.p.ptr()
  0x4285ff		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x428608		488b4030		MOVQ 0x30(AX), AX	
  0x42860c		488b80d0000000		MOVQ 0xd0(AX), AX	
	if !runqempty(p) {
  0x428613		48890424		MOVQ AX, 0(SP)			
  0x428617		e8f4570000		CALL runtime.runqempty(SB)	
  0x42861c		0fb6442408		MOVZX 0x8(SP), AX		
  0x428621		84c0			TESTL AL, AL			
  0x428623		745a			JE 0x42867f			
	return atomic.Load(&netpollInited) != 0
  0x428625		8b05bdb20900		MOVL runtime.netpollInited(SB), AX	
  0x42862b		85c0			TESTL AX, AX				
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && sched.lastpoll != 0 {
  0x42862d		7416			JE 0x428645				
  0x42862f		8b05b7b20900		MOVL runtime.netpollWaiters(SB), AX	
  0x428635		85c0			TESTL AX, AX				
  0x428637		760c			JBE 0x428645				
  0x428639		488b05e8f20700		MOVQ runtime.sched+8(SB), AX		
  0x428640		4885c0			TESTQ AX, AX				
  0x428643		750f			JNE 0x428654				
	return false
  0x428645		c644242000		MOVB $0x0, 0x20(SP)	
  0x42864a		488b6c2410		MOVQ 0x10(SP), BP	
  0x42864f		4883c418		ADDQ $0x18, SP		
  0x428653		c3			RET			
		if gp := netpoll(false); gp != nil {
  0x428654		c6042400		MOVB $0x0, 0(SP)		
  0x428658		e8d363ffff		CALL runtime.netpoll(SB)	
  0x42865d		488b442408		MOVQ 0x8(SP), AX		
  0x428662		4885c0			TESTQ AX, AX			
  0x428665		74de			JE 0x428645			
			injectglist(gp)
  0x428667		48890424		MOVQ AX, 0(SP)			
  0x42866b		e800010000		CALL runtime.injectglist(SB)	
			return true
  0x428670		c644242001		MOVB $0x1, 0x20(SP)	
  0x428675		488b6c2410		MOVQ 0x10(SP), BP	
  0x42867a		4883c418		ADDQ $0x18, SP		
  0x42867e		c3			RET			
		return true
  0x42867f		c644242001		MOVB $0x1, 0x20(SP)	
  0x428684		488b6c2410		MOVQ 0x10(SP), BP	
  0x428689		4883c418		ADDQ $0x18, SP		
  0x42868d		c3			RET			
		return true
  0x42868e		c644242001		MOVB $0x1, 0x20(SP)	
  0x428693		488b6c2410		MOVQ 0x10(SP), BP	
  0x428698		4883c418		ADDQ $0x18, SP		
  0x42869c		c3			RET			
func pollWork() bool {
  0x42869d		e8cebe0100		CALL runtime.morestack_noctxt(SB)	
  0x4286a2		e929ffffff		JMP runtime.pollWork(SB)		

TEXT runtime.resetspinning(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func resetspinning() {
  0x4286b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4286b9		483b6110		CMPQ 0x10(CX), SP	
  0x4286bd		0f8696000000		JBE 0x428759		
  0x4286c3		4883ec18		SUBQ $0x18, SP		
  0x4286c7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4286cc		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x4286d1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if !_g_.m.spinning {
  0x4286da		488b4030		MOVQ 0x30(AX), AX	
  0x4286de		0fb68814010000		MOVZX 0x114(AX), CX	
  0x4286e5		84c9			TESTL CL, CL		
  0x4286e7		7455			JE 0x42873e		
	_g_.m.spinning = false
  0x4286e9		c6801401000000		MOVB $0x0, 0x114(AX)	
	nmspinning := atomic.Xadd(&sched.nmspinning, -1)
  0x4286f0		b8ffffffff		MOVL $-0x1, AX			
  0x4286f5		488d0d78f20700		LEAQ runtime.sched+84(SB), CX	
  0x4286fc		f00fc101		LOCK XADDL AX, 0(CX)		
  0x428700		ffc8			DECL AX				
	if int32(nmspinning) < 0 {
  0x428702		85c0			TESTL AX, AX		
  0x428704		7c1d			JL 0x428723		
	if nmspinning == 0 && atomic.Load(&sched.npidle) > 0 {
  0x428706		750a			JNE 0x428712			
  0x428708		8b0562f20700		MOVL runtime.sched+80(SB), AX	
  0x42870e		85c0			TESTL AX, AX			
  0x428710		770a			JA 0x42871c			
  0x428712		488b6c2410		MOVQ 0x10(SP), BP		
  0x428717		4883c418		ADDQ $0x18, SP			
  0x42871b		c3			RET				
		wakep()
  0x42871c		e84fecffff		CALL runtime.wakep(SB)	
  0x428721		ebef			JMP 0x428712		
		throw("findrunnable: negative nmspinning")
  0x428723		488d05bd420400		LEAQ 0x442bd(IP), AX	
  0x42872a		48890424		MOVQ AX, 0(SP)		
  0x42872e		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x428737		e8948affff		CALL runtime.throw(SB)	
  0x42873c		0f0b			UD2			
		throw("resetspinning: not a spinning m")
  0x42873e		488d05e23f0400		LEAQ 0x43fe2(IP), AX	
  0x428745		48890424		MOVQ AX, 0(SP)		
  0x428749		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x428752		e8798affff		CALL runtime.throw(SB)	
  0x428757		0f0b			UD2			
func resetspinning() {
  0x428759		e812be0100		CALL runtime.morestack_noctxt(SB)	
  0x42875e		e94dffffff		JMP runtime.resetspinning(SB)		

TEXT runtime.injectglist(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func injectglist(glist *g) {
  0x428770		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428779		483b6110		CMPQ 0x10(CX), SP	
  0x42877d		0f866e010000		JBE 0x4288f1		
  0x428783		4883ec38		SUBQ $0x38, SP		
  0x428787		48896c2430		MOVQ BP, 0x30(SP)	
  0x42878c		488d6c2430		LEAQ 0x30(SP), BP	
  0x428791		488b442440		MOVQ 0x40(SP), AX	
	if glist == nil {
  0x428796		4885c0			TESTQ AX, AX		
  0x428799		0f8448010000		JE 0x4288e7		
	if trace.enabled {
  0x42879f		0fb60d2ab00800		MOVZX runtime.trace+16(SB), CX	
  0x4287a6		84c9			TESTL CL, CL			
  0x4287a8		7432			JE 0x4287dc			
  0x4287aa		4889c1			MOVQ AX, CX			
		for gp := glist; gp != nil; gp = gp.schedlink.ptr() {
  0x4287ad		eb28			JMP 0x4287d7		
  0x4287af		4889442418		MOVQ AX, 0x18(SP)	
			traceGoUnpark(gp, 0)
  0x4287b4		48890424		MOVQ AX, 0(SP)			
  0x4287b8		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4287c1		e8fa240100		CALL runtime.traceGoUnpark(SB)	
  0x4287c6		488b442418		MOVQ 0x18(SP), AX		
		for gp := glist; gp != nil; gp = gp.schedlink.ptr() {
  0x4287cb		488b80b8000000		MOVQ 0xb8(AX), AX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x4287d2		488b4c2440		MOVQ 0x40(SP), CX	
		for gp := glist; gp != nil; gp = gp.schedlink.ptr() {
  0x4287d7		4885c0			TESTQ AX, AX		
  0x4287da		75d3			JNE 0x4287af		
	lock(&sched.lock)
  0x4287dc		488d054df10700		LEAQ runtime.sched+16(SB), AX	
  0x4287e3		48890424		MOVQ AX, 0(SP)			
  0x4287e7		e8340dfeff		CALL runtime.lock(SB)		
  0x4287ec		488b442440		MOVQ 0x40(SP), AX		
  0x4287f1		31c9			XORL CX, CX			
	for n = 0; glist != nil; n++ {
  0x4287f3		eb24			JMP 0x428819		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4287f5		488d1d84f10700		LEAQ runtime.sched+96(SB), BX	
  0x4287fc		8403			TESTB AL, 0(BX)			
  0x4287fe		4889157bf10700		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x428805		ff057df10700		INCL runtime.sched+104(SB)	
  0x42880b		488b542410		MOVQ 0x10(SP), DX		
	for n = 0; glist != nil; n++ {
  0x428810		488d4a01		LEAQ 0x1(DX), CX	
  0x428814		488b442428		MOVQ 0x28(SP), AX	
  0x428819		48894c2410		MOVQ CX, 0x10(SP)	
  0x42881e		4885c0			TESTQ AX, AX		
  0x428821		7475			JE 0x428898		
  0x428823		4889442420		MOVQ AX, 0x20(SP)	
		glist = gp.schedlink.ptr()
  0x428828		488b88b8000000		MOVQ 0xb8(AX), CX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42882f		48894c2428		MOVQ CX, 0x28(SP)	
		casgstatus(gp, _Gwaiting, _Grunnable)
  0x428834		48890424		MOVQ AX, 0(SP)			
  0x428838		48ba0400000001000000	MOVQ $0x100000004, DX		
  0x428842		4889542408		MOVQ DX, 0x8(SP)		
  0x428847		e834c2ffff		CALL runtime.casgstatus(SB)	
  0x42884c		488b442420		MOVQ 0x20(SP), AX		
	gp.schedlink = 0
  0x428851		48c780b800000000000000	MOVQ $0x0, 0xb8(AX)	
	if sched.runqtail != 0 {
  0x42885c		488b0d1df10700		MOVQ runtime.sched+96(SB), CX	
  0x428863		4885c9			TESTQ CX, CX			
  0x428866		7418			JE 0x428880			
		sched.runqtail.ptr().schedlink.set(gp)
  0x428868		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42886f		8402			TESTB AL, 0(DX)		
  0x428871		4889c2			MOVQ AX, DX		
  0x428874		488981b8000000		MOVQ AX, 0xb8(CX)	
	sched.runqtail.set(gp)
  0x42887b		e975ffffff		JMP 0x4287f5		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x428880		488d0df1f00700		LEAQ runtime.sched+88(SB), CX	
  0x428887		8401			TESTB AL, 0(CX)			
  0x428889		4889c2			MOVQ AX, DX			
  0x42888c		488905e5f00700		MOVQ AX, runtime.sched+88(SB)	
	sched.runqtail.set(gp)
  0x428893		e95dffffff		JMP 0x4287f5		
	unlock(&sched.lock)
  0x428898		488d0591f00700		LEAQ runtime.sched+16(SB), AX	
  0x42889f		48890424		MOVQ AX, 0(SP)			
  0x4288a3		e8180efeff		CALL runtime.unlock(SB)		
  0x4288a8		488b442410		MOVQ 0x10(SP), AX		
	for ; n != 0 && sched.npidle != 0; n-- {
  0x4288ad		eb1f			JMP 0x4288ce		
  0x4288af		4889442410		MOVQ AX, 0x10(SP)	
		startm(nil, false)
  0x4288b4		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x4288bc		c644240800		MOVB $0x0, 0x8(SP)	
  0x4288c1		e87ae5ffff		CALL runtime.startm(SB)	
  0x4288c6		488b442410		MOVQ 0x10(SP), AX	
	for ; n != 0 && sched.npidle != 0; n-- {
  0x4288cb		48ffc8			DECQ AX				
  0x4288ce		4885c0			TESTQ AX, AX			
  0x4288d1		740a			JE 0x4288dd			
  0x4288d3		8b0d97f00700		MOVL runtime.sched+80(SB), CX	
  0x4288d9		85c9			TESTL CX, CX			
  0x4288db		75d2			JNE 0x4288af			
  0x4288dd		488b6c2430		MOVQ 0x30(SP), BP		
  0x4288e2		4883c438		ADDQ $0x38, SP			
  0x4288e6		c3			RET				
		return
  0x4288e7		488b6c2430		MOVQ 0x30(SP), BP	
  0x4288ec		4883c438		ADDQ $0x38, SP		
  0x4288f0		c3			RET			
func injectglist(glist *g) {
  0x4288f1		e87abc0100		CALL runtime.morestack_noctxt(SB)	
  0x4288f6		e975feffff		JMP runtime.injectglist(SB)		

TEXT runtime.schedule(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func schedule() {
  0x428900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428909		483b6110		CMPQ 0x10(CX), SP	
  0x42890d		0f8640030000		JBE 0x428c53		
  0x428913		4883ec40		SUBQ $0x40, SP		
  0x428917		48896c2438		MOVQ BP, 0x38(SP)	
  0x42891c		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x428921		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.locks != 0 {
  0x42892a		488b4830		MOVQ 0x30(AX), CX	
  0x42892e		8b9100010000		MOVL 0x100(CX), DX	
  0x428934		85d2			TESTL DX, DX		
  0x428936		0f85fc020000		JNE 0x428c38		
  0x42893c		4889442428		MOVQ AX, 0x28(SP)	
	if _g_.m.lockedg != 0 {
  0x428941		488b8968010000		MOVQ 0x168(CX), CX	
  0x428948		4885c9			TESTQ CX, CX		
  0x42894b		0f8584020000		JNE 0x428bd5		
	if _g_.m.incgo {
  0x428951		488b4830		MOVQ 0x30(AX), CX	
  0x428955		0fb68919010000		MOVZX 0x119(CX), CX	
  0x42895c		84c9			TESTL CL, CL		
  0x42895e		0f85b9020000		JNE 0x428c1d		
  0x428964		eb0e			JMP 0x428974		
		startlockedm(gp)
  0x428966		48890424		MOVQ AX, 0(SP)			
  0x42896a		e831edffff		CALL runtime.startlockedm(SB)	
  0x42896f		488b442428		MOVQ 0x28(SP), AX		
	if sched.gcwaiting != 0 {
  0x428974		8b0d7ef00700		MOVL runtime.sched+216(SB), CX	
  0x42897a		85c9			TESTL CX, CX			
  0x42897c		0f8544020000		JNE 0x428bc6			
	if _g_.m.p.ptr().runSafePointFn != 0 {
  0x428982		488b4830		MOVQ 0x30(AX), CX	
  0x428986		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42898d		8401			TESTB AL, 0(CX)		
  0x42898f		8b89a0220000		MOVL 0x22a0(CX), CX	
  0x428995		85c9			TESTL CX, CX		
  0x428997		0f851a020000		JNE 0x428bb7		
	if trace.enabled || trace.shutdown {
  0x42899d		0fb60d2cae0800		MOVZX runtime.trace+16(SB), CX	
  0x4289a4		84c9			TESTL CL, CL			
  0x4289a6		0f84f5010000		JE 0x428ba1			
		gp = traceReader()
  0x4289ac		e89f0a0100		CALL runtime.traceReader(SB)	
  0x4289b1		488b0424		MOVQ 0(SP), AX			
		if gp != nil {
  0x4289b5		4885c0			TESTQ AX, AX		
  0x4289b8		0f85a9010000		JNE 0x428b67		
	if gp == nil && gcBlackenEnabled != 0 {
  0x4289be		4885c0			TESTQ AX, AX		
  0x4289c1		0f8463010000		JE 0x428b2a		
	if gp == nil {
  0x4289c7		4885c0			TESTQ AX, AX		
  0x4289ca		0f84c5000000		JE 0x428a95		
	if gp == nil {
  0x4289d0		4885c0			TESTQ AX, AX		
  0x4289d3		7471			JE 0x428a46		
  0x4289d5		31c9			XORL CX, CX		
	if gp == nil {
  0x4289d7		4885c0			TESTQ AX, AX		
  0x4289da		745a			JE 0x428a36		
  0x4289dc		488b542428		MOVQ 0x28(SP), DX	
	if _g_.m.spinning {
  0x4289e1		488b5a30		MOVQ 0x30(DX), BX	
  0x4289e5		0fb69b14010000		MOVZX 0x114(BX), BX	
  0x4289ec		84db			TESTL BL, BL		
  0x4289ee		7527			JNE 0x428a17		
	if gp.lockedm != 0 {
  0x4289f0		488b98e0000000		MOVQ 0xe0(AX), BX	
  0x4289f7		4885db			TESTQ BX, BX		
  0x4289fa		0f8566ffffff		JNE 0x428966		
	execute(gp, inheritTime)
  0x428a00		48890424		MOVQ AX, 0(SP)			
  0x428a04		884c2408		MOVB CL, 0x8(SP)		
  0x428a08		e8a3eeffff		CALL runtime.execute(SB)	
}
  0x428a0d		488b6c2438		MOVQ 0x38(SP), BP	
  0x428a12		4883c440		ADDQ $0x40, SP		
  0x428a16		c3			RET			
  0x428a17		884c241f		MOVB CL, 0x1f(SP)	
  0x428a1b		4889442420		MOVQ AX, 0x20(SP)	
		resetspinning()
  0x428a20		e88bfcffff		CALL runtime.resetspinning(SB)	
  0x428a25		488b442420		MOVQ 0x20(SP), AX		
  0x428a2a		0fb64c241f		MOVZX 0x1f(SP), CX		
  0x428a2f		488b542428		MOVQ 0x28(SP), DX		
  0x428a34		ebba			JMP 0x4289f0			
		gp, inheritTime = findrunnable() // blocks until work is available
  0x428a36		e8e5efffff		CALL runtime.findrunnable(SB)	
  0x428a3b		488b0424		MOVQ 0(SP), AX			
  0x428a3f		0fb64c2408		MOVZX 0x8(SP), CX		
  0x428a44		eb96			JMP 0x4289dc			
  0x428a46		488b442428		MOVQ 0x28(SP), AX		
		gp, inheritTime = runqget(_g_.m.p.ptr())
  0x428a4b		488b4830		MOVQ 0x30(AX), CX		
  0x428a4f		488b89d0000000		MOVQ 0xd0(CX), CX		
  0x428a56		48890c24		MOVQ CX, 0(SP)			
  0x428a5a		e811570000		CALL runtime.runqget(SB)	
  0x428a5f		488b442408		MOVQ 0x8(SP), AX		
  0x428a64		0fb64c2410		MOVZX 0x10(SP), CX		
		if gp != nil && _g_.m.spinning {
  0x428a69		4885c0			TESTQ AX, AX		
  0x428a6c		741d			JE 0x428a8b		
  0x428a6e		488b542428		MOVQ 0x28(SP), DX	
  0x428a73		488b5a30		MOVQ 0x30(DX), BX	
  0x428a77		0fb69b14010000		MOVZX 0x114(BX), BX	
  0x428a7e		84db			TESTL BL, BL		
  0x428a80		0f857c010000		JNE 0x428c02		
  0x428a86		e94cffffff		JMP 0x4289d7		
  0x428a8b		488b542428		MOVQ 0x28(SP), DX	
  0x428a90		e942ffffff		JMP 0x4289d7		
  0x428a95		488b4c2428		MOVQ 0x28(SP), CX	
		if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
  0x428a9a		488b5130		MOVQ 0x30(CX), DX		
  0x428a9e		488b92d0000000		MOVQ 0xd0(DX), DX		
  0x428aa5		8b5218			MOVL 0x18(DX), DX		
  0x428aa8		bb7e8a4b86		MOVL $-0x79b47582, BX		
  0x428aad		480fafda		IMULQ DX, BX			
  0x428ab1		48c1eb25		SHRQ $0x25, BX			
  0x428ab5		6bdb3d			IMULL $0x3d, BX, BX		
  0x428ab8		29da			SUBL BX, DX			
  0x428aba		85d2			TESTL DX, DX			
  0x428abc		0f850effffff		JNE 0x4289d0			
  0x428ac2		8b15c0ee0700		MOVL runtime.sched+104(SB), DX	
  0x428ac8		85d2			TESTL DX, DX			
  0x428aca		0f8e00ffffff		JLE 0x4289d0			
			lock(&sched.lock)
  0x428ad0		488d0559ee0700		LEAQ runtime.sched+16(SB), AX	
  0x428ad7		48890424		MOVQ AX, 0(SP)			
  0x428adb		e8400afeff		CALL runtime.lock(SB)		
  0x428ae0		488b442428		MOVQ 0x28(SP), AX		
			gp = globrunqget(_g_.m.p.ptr(), 1)
  0x428ae5		488b4830		MOVQ 0x30(AX), CX		
  0x428ae9		488b89d0000000		MOVQ 0xd0(CX), CX		
  0x428af0		48890c24		MOVQ CX, 0(SP)			
  0x428af4		c744240801000000	MOVL $0x1, 0x8(SP)		
  0x428afc		e82f510000		CALL runtime.globrunqget(SB)	
  0x428b01		488b442410		MOVQ 0x10(SP), AX		
  0x428b06		4889442420		MOVQ AX, 0x20(SP)		
			unlock(&sched.lock)
  0x428b0b		488d0d1eee0700		LEAQ runtime.sched+16(SB), CX	
  0x428b12		48890c24		MOVQ CX, 0(SP)			
  0x428b16		e8a50bfeff		CALL runtime.unlock(SB)		
  0x428b1b		488b4c2428		MOVQ 0x28(SP), CX		
  0x428b20		488b442420		MOVQ 0x20(SP), AX		
  0x428b25		e9a6feffff		JMP 0x4289d0			
	if gp == nil && gcBlackenEnabled != 0 {
  0x428b2a		8b0da4ad0900		MOVL runtime.gcBlackenEnabled(SB), CX	
  0x428b30		85c9			TESTL CX, CX				
  0x428b32		0f848ffeffff		JE 0x4289c7				
  0x428b38		488b442428		MOVQ 0x28(SP), AX			
		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
  0x428b3d		488b4830		MOVQ 0x30(AX), CX						
  0x428b41		488b89d0000000		MOVQ 0xd0(CX), CX						
  0x428b48		488d15d1b00900		LEAQ runtime.gcController(SB), DX				
  0x428b4f		48891424		MOVQ DX, 0(SP)							
  0x428b53		48894c2408		MOVQ CX, 0x8(SP)						
  0x428b58		e8b37efeff		CALL runtime.(*gcControllerState).findRunnableGCWorker(SB)	
  0x428b5d		488b442410		MOVQ 0x10(SP), AX						
  0x428b62		e960feffff		JMP 0x4289c7							
  0x428b67		4889442430		MOVQ AX, 0x30(SP)						
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x428b6c		48b80400000001000000	MOVQ $0x100000004, AX		
  0x428b76		4889442408		MOVQ AX, 0x8(SP)		
  0x428b7b		e800bfffff		CALL runtime.casgstatus(SB)	
  0x428b80		488b442430		MOVQ 0x30(SP), AX		
			traceGoUnpark(gp, 0)
  0x428b85		48890424		MOVQ AX, 0(SP)			
  0x428b89		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x428b92		e829210100		CALL runtime.traceGoUnpark(SB)	
  0x428b97		488b442430		MOVQ 0x30(SP), AX		
  0x428b9c		e91dfeffff		JMP 0x4289be			
	if trace.enabled || trace.shutdown {
  0x428ba1		0fb60d29ac0800		MOVZX runtime.trace+17(SB), CX	
  0x428ba8		84c9			TESTL CL, CL			
  0x428baa		0f85fcfdffff		JNE 0x4289ac			
  0x428bb0		31c0			XORL AX, AX			
  0x428bb2		e907feffff		JMP 0x4289be			
		runSafePointFn()
  0x428bb7		e884d3ffff		CALL runtime.runSafePointFn(SB)	
  0x428bbc		488b442428		MOVQ 0x28(SP), AX		
  0x428bc1		e9d7fdffff		JMP 0x42899d			
		gcstopm()
  0x428bc6		e8c5ebffff		CALL runtime.gcstopm(SB)	
  0x428bcb		488b442428		MOVQ 0x28(SP), AX		
		goto top
  0x428bd0		e99ffdffff		JMP 0x428974		
		stoplockedm()
  0x428bd5		e806e8ffff		CALL runtime.stoplockedm(SB)	
  0x428bda		488b442428		MOVQ 0x28(SP), AX		
		execute(_g_.m.lockedg.ptr(), false) // Never returns.
  0x428bdf		488b4830		MOVQ 0x30(AX), CX		
  0x428be3		488b8968010000		MOVQ 0x168(CX), CX		
  0x428bea		48890c24		MOVQ CX, 0(SP)			
  0x428bee		c644240800		MOVB $0x0, 0x8(SP)		
  0x428bf3		e8b8ecffff		CALL runtime.execute(SB)	
  0x428bf8		488b442428		MOVQ 0x28(SP), AX		
  0x428bfd		e94ffdffff		JMP 0x428951			
			throw("schedule: spinning with local work")
  0x428c02		488d0579400400		LEAQ 0x44079(IP), AX	
  0x428c09		48890424		MOVQ AX, 0(SP)		
  0x428c0d		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x428c16		e8b585ffff		CALL runtime.throw(SB)	
  0x428c1b		0f0b			UD2			
		throw("schedule: in cgo")
  0x428c1d		488d055e1f0400		LEAQ 0x41f5e(IP), AX	
  0x428c24		48890424		MOVQ AX, 0(SP)		
  0x428c28		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x428c31		e89a85ffff		CALL runtime.throw(SB)	
  0x428c36		0f0b			UD2			
		throw("schedule: holding locks")
  0x428c38		488d057d2b0400		LEAQ 0x42b7d(IP), AX	
  0x428c3f		48890424		MOVQ AX, 0(SP)		
  0x428c43		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x428c4c		e87f85ffff		CALL runtime.throw(SB)	
  0x428c51		0f0b			UD2			
func schedule() {
  0x428c53		e818b90100		CALL runtime.morestack_noctxt(SB)	
  0x428c58		e9a3fcffff		JMP runtime.schedule(SB)		

TEXT runtime.parkunlock_c(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func parkunlock_c(gp *g, lock unsafe.Pointer) bool {
  0x428c60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428c69		483b6110		CMPQ 0x10(CX), SP	
  0x428c6d		762b			JBE 0x428c9a		
  0x428c6f		4883ec10		SUBQ $0x10, SP		
  0x428c73		48896c2408		MOVQ BP, 0x8(SP)	
  0x428c78		488d6c2408		LEAQ 0x8(SP), BP	
  0x428c7d		488b442420		MOVQ 0x20(SP), AX	
	unlock((*mutex)(lock))
  0x428c82		48890424		MOVQ AX, 0(SP)		
  0x428c86		e8350afeff		CALL runtime.unlock(SB)	
	return true
  0x428c8b		c644242801		MOVB $0x1, 0x28(SP)	
  0x428c90		488b6c2408		MOVQ 0x8(SP), BP	
  0x428c95		4883c410		ADDQ $0x10, SP		
  0x428c99		c3			RET			
func parkunlock_c(gp *g, lock unsafe.Pointer) bool {
  0x428c9a		e8d1b80100		CALL runtime.morestack_noctxt(SB)	
  0x428c9f		ebbf			JMP runtime.parkunlock_c(SB)		

TEXT runtime.park_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func park_m(gp *g) {
  0x428cb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428cb9		483b6110		CMPQ 0x10(CX), SP	
  0x428cbd		0f86c2010000		JBE 0x428e85		
  0x428cc3		4883ec28		SUBQ $0x28, SP		
  0x428cc7		48896c2420		MOVQ BP, 0x20(SP)	
  0x428ccc		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x428cd1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x428cda		4889442418		MOVQ AX, 0x18(SP)	
	if trace.enabled {
  0x428cdf		0fb60deaaa0800		MOVZX runtime.trace+16(SB), CX	
  0x428ce6		84c9			TESTL CL, CL			
  0x428ce8		0f8573010000		JNE 0x428e61			
  0x428cee		488b442430		MOVQ 0x30(SP), AX		
	casgstatus(gp, _Grunning, _Gwaiting)
  0x428cf3		48890424		MOVQ AX, 0(SP)			
  0x428cf7		48b90200000004000000	MOVQ $0x400000002, CX		
  0x428d01		48894c2408		MOVQ CX, 0x8(SP)		
  0x428d06		e875bdffff		CALL runtime.casgstatus(SB)	
	_g_ := getg()
  0x428d0b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x428d14		488b4830		MOVQ 0x30(AX), CX	
  0x428d18		488b91c0000000		MOVQ 0xc0(CX), DX	
  0x428d1f		8401			TESTB AL, 0(CX)		
  0x428d21		488d4a30		LEAQ 0x30(DX), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x428d25		8401			TESTB AL, 0(CX)		
  0x428d27		31c9			XORL CX, CX		
  0x428d29		48894a30		MOVQ CX, 0x30(DX)	
	setGNoWB(&_g_.m.curg, nil)
  0x428d2d		488b4830		MOVQ 0x30(AX), CX	
  0x428d31		8400			TESTB AL, 0(AX)		
  0x428d33		488d81c0000000		LEAQ 0xc0(CX), AX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x428d3a		8400			TESTB AL, 0(AX)		
  0x428d3c		31c0			XORL AX, AX		
  0x428d3e		488981c0000000		MOVQ AX, 0xc0(CX)	
  0x428d45		488b442418		MOVQ 0x18(SP), AX	
	if _g_.m.waitunlockf != nil {
  0x428d4a		488b4830		MOVQ 0x30(AX), CX	
  0x428d4e		488b9108030000		MOVQ 0x308(CX), DX	
  0x428d55		488d9908030000		LEAQ 0x308(CX), BX	
  0x428d5c		4885d2			TESTQ DX, DX		
  0x428d5f		750f			JNE 0x428d70		
	schedule()
  0x428d61		e89afbffff		CALL runtime.schedule(SB)	
}
  0x428d66		488b6c2420		MOVQ 0x20(SP), BP	
  0x428d6b		4883c428		ADDQ $0x28, SP		
  0x428d6f		c3			RET			
		fn := *(*func(*g, unsafe.Pointer) bool)(unsafe.Pointer(&_g_.m.waitunlockf))
  0x428d70		8403			TESTB AL, 0(BX)		
  0x428d72		488b9108030000		MOVQ 0x308(CX), DX	
		ok := fn(gp, _g_.m.waitlock)
  0x428d79		488b8110030000		MOVQ 0x310(CX), AX	
  0x428d80		4889442408		MOVQ AX, 0x8(SP)	
  0x428d85		488b442430		MOVQ 0x30(SP), AX	
  0x428d8a		48890424		MOVQ AX, 0(SP)		
  0x428d8e		488b0a			MOVQ 0(DX), CX		
  0x428d91		ffd1			CALL CX			
  0x428d93		488b442418		MOVQ 0x18(SP), AX	
		_g_.m.waitunlockf = nil
  0x428d98		488b4830		MOVQ 0x30(AX), CX	
  0x428d9c		8401			TESTB AL, 0(CX)		
		ok := fn(gp, _g_.m.waitlock)
  0x428d9e		0fb65c2410		MOVZX 0x10(SP), BX	
		_g_.m.waitunlockf = nil
  0x428da3		8b3567ac0900		MOVL runtime.writeBarrier(SB), SI	
  0x428da9		488db908030000		LEAQ 0x308(CX), DI			
  0x428db0		85f6			TESTL SI, SI				
  0x428db2		0f8597000000		JNE 0x428e4f				
  0x428db8		48c7810803000000000000	MOVQ $0x0, 0x308(CX)			
		_g_.m.waitlock = nil
  0x428dc3		488b4830		MOVQ 0x30(AX), CX			
  0x428dc7		8401			TESTB AL, 0(CX)				
  0x428dc9		8b1541ac0900		MOVL runtime.writeBarrier(SB), DX	
  0x428dcf		488db910030000		LEAQ 0x310(CX), DI			
  0x428dd6		85d2			TESTL DX, DX				
  0x428dd8		756c			JNE 0x428e46				
  0x428dda		48c7811003000000000000	MOVQ $0x0, 0x310(CX)			
		ok := fn(gp, _g_.m.waitlock)
  0x428de5		84db			TESTL BL, BL		
		if !ok {
  0x428de7		0f8574ffffff		JNE 0x428d61		
			if trace.enabled {
  0x428ded		0fb605dca90800		MOVZX runtime.trace+16(SB), AX	
  0x428df4		84c0			TESTL AL, AL			
  0x428df6		7535			JNE 0x428e2d			
  0x428df8		488b442430		MOVQ 0x30(SP), AX		
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x428dfd		48890424		MOVQ AX, 0(SP)			
  0x428e01		48b90400000001000000	MOVQ $0x100000004, CX		
  0x428e0b		48894c2408		MOVQ CX, 0x8(SP)		
  0x428e10		e86bbcffff		CALL runtime.casgstatus(SB)	
  0x428e15		488b442430		MOVQ 0x30(SP), AX		
			execute(gp, true) // Schedule it back, never returns.
  0x428e1a		48890424		MOVQ AX, 0(SP)			
  0x428e1e		c644240801		MOVB $0x1, 0x8(SP)		
  0x428e23		e888eaffff		CALL runtime.execute(SB)	
  0x428e28		e934ffffff		JMP 0x428d61			
  0x428e2d		488b442430		MOVQ 0x30(SP), AX		
				traceGoUnpark(gp, 2)
  0x428e32		48890424		MOVQ AX, 0(SP)			
  0x428e36		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x428e3f		e87c1e0100		CALL runtime.traceGoUnpark(SB)	
  0x428e44		ebb2			JMP 0x428df8			
		_g_.m.waitlock = nil
  0x428e46		31c0			XORL AX, AX			
  0x428e48		e853da0100		CALL runtime.gcWriteBarrier(SB)	
  0x428e4d		eb96			JMP 0x428de5			
  0x428e4f		4889c1			MOVQ AX, CX			
		_g_.m.waitunlockf = nil
  0x428e52		31c0			XORL AX, AX			
  0x428e54		e847da0100		CALL runtime.gcWriteBarrier(SB)	
  0x428e59		4889c8			MOVQ CX, AX			
  0x428e5c		e962ffffff		JMP 0x428dc3			
		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
  0x428e61		488b4830		MOVQ 0x30(AX), CX		
  0x428e65		0fb69118030000		MOVZX 0x318(CX), DX		
  0x428e6c		488b8920030000		MOVQ 0x320(CX), CX		
  0x428e73		48894c2408		MOVQ CX, 0x8(SP)		
  0x428e78		881424			MOVB DL, 0(SP)			
  0x428e7b		e8b01d0100		CALL runtime.traceGoPark(SB)	
  0x428e80		e969feffff		JMP 0x428cee			
func park_m(gp *g) {
  0x428e85		e8e6b60100		CALL runtime.morestack_noctxt(SB)	
  0x428e8a		e921feffff		JMP runtime.park_m(SB)			

TEXT runtime.goschedImpl(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func goschedImpl(gp *g) {
  0x428e90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428e99		483b6110		CMPQ 0x10(CX), SP	
  0x428e9d		0f8667020000		JBE 0x42910a		
  0x428ea3		4883ec30		SUBQ $0x30, SP		
  0x428ea7		48896c2428		MOVQ BP, 0x28(SP)	
  0x428eac		488d6c2428		LEAQ 0x28(SP), BP	
  0x428eb1		488b442438		MOVQ 0x38(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x428eb6		8b8890000000		MOVL 0x90(AX), CX	
	if status&^_Gscan != _Grunning {
  0x428ebc		81e1ffefffff		ANDL $-0x1001, CX	
  0x428ec2		83f902			CMPL $0x2, CX		
  0x428ec5		0f85db000000		JNE 0x428fa6		
	casgstatus(gp, _Grunning, _Grunnable)
  0x428ecb		48890424		MOVQ AX, 0(SP)			
  0x428ecf		48b90200000001000000	MOVQ $0x100000002, CX		
  0x428ed9		48894c2408		MOVQ CX, 0x8(SP)		
  0x428ede		e89dbbffff		CALL runtime.casgstatus(SB)	
	_g_ := getg()
  0x428ee3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x428eec		488b4830		MOVQ 0x30(AX), CX	
  0x428ef0		488b91c0000000		MOVQ 0xc0(CX), DX	
  0x428ef7		8401			TESTB AL, 0(CX)		
  0x428ef9		488d4a30		LEAQ 0x30(DX), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x428efd		8401			TESTB AL, 0(CX)		
  0x428eff		31c9			XORL CX, CX		
  0x428f01		48894a30		MOVQ CX, 0x30(DX)	
	setGNoWB(&_g_.m.curg, nil)
  0x428f05		488b4830		MOVQ 0x30(AX), CX	
  0x428f09		8400			TESTB AL, 0(AX)		
  0x428f0b		488d81c0000000		LEAQ 0xc0(CX), AX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x428f12		8400			TESTB AL, 0(AX)		
  0x428f14		31c0			XORL AX, AX		
  0x428f16		488981c0000000		MOVQ AX, 0xc0(CX)	
	lock(&sched.lock)
  0x428f1d		488d050cea0700		LEAQ runtime.sched+16(SB), AX	
  0x428f24		48890424		MOVQ AX, 0(SP)			
  0x428f28		e8f305feff		CALL runtime.lock(SB)		
  0x428f2d		488b442438		MOVQ 0x38(SP), AX		
	gp.schedlink = 0
  0x428f32		48c780b800000000000000	MOVQ $0x0, 0xb8(AX)	
	if sched.runqtail != 0 {
  0x428f3d		488b0d3cea0700		MOVQ runtime.sched+96(SB), CX	
  0x428f44		4885c9			TESTQ CX, CX			
  0x428f47		7448			JE 0x428f91			
		sched.runqtail.ptr().schedlink.set(gp)
  0x428f49		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x428f50		8402			TESTB AL, 0(DX)			
  0x428f52		4889c2			MOVQ AX, DX			
  0x428f55		488981b8000000		MOVQ AX, 0xb8(CX)		
  0x428f5c		488d051dea0700		LEAQ runtime.sched+96(SB), AX	
  0x428f63		8400			TESTB AL, 0(AX)			
  0x428f65		48891514ea0700		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x428f6c		ff0516ea0700		INCL runtime.sched+104(SB)	
	unlock(&sched.lock)
  0x428f72		488d05b7e90700		LEAQ runtime.sched+16(SB), AX	
  0x428f79		48890424		MOVQ AX, 0(SP)			
  0x428f7d		e83e07feff		CALL runtime.unlock(SB)		
	schedule()
  0x428f82		e879f9ffff		CALL runtime.schedule(SB)	
}
  0x428f87		488b6c2428		MOVQ 0x28(SP), BP	
  0x428f8c		4883c430		ADDQ $0x30, SP		
  0x428f90		c3			RET			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x428f91		488d0de0e90700		LEAQ runtime.sched+88(SB), CX	
  0x428f98		8401			TESTB AL, 0(CX)			
  0x428f9a		4889c2			MOVQ AX, DX			
  0x428f9d		488905d4e90700		MOVQ AX, runtime.sched+88(SB)	
	sched.runqtail.set(gp)
  0x428fa4		ebb6			JMP 0x428f5c		
	_g_ := getg()
  0x428fa6		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428faf		48894c2420		MOVQ CX, 0x20(SP)	
	return atomic.Load(&gp.atomicstatus)
  0x428fb4		8b9090000000		MOVL 0x90(AX), DX	
  0x428fba		89542410		MOVL DX, 0x10(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x428fbe		488b9898000000		MOVQ 0x98(AX), BX		
  0x428fc5		48895c2418		MOVQ BX, 0x18(SP)		
  0x428fca		e8318bffff		CALL runtime.printlock(SB)	
  0x428fcf		488d058c1b0400		LEAQ 0x41b8c(IP), AX		
  0x428fd6		48890424		MOVQ AX, 0(SP)			
  0x428fda		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x428fe3		e85894ffff		CALL runtime.printstring(SB)	
  0x428fe8		488b442438		MOVQ 0x38(SP), AX		
  0x428fed		48890424		MOVQ AX, 0(SP)			
  0x428ff1		e80a94ffff		CALL runtime.printpointer(SB)	
  0x428ff6		488d05950e0400		LEAQ 0x40e95(IP), AX		
  0x428ffd		48890424		MOVQ AX, 0(SP)			
  0x429001		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42900a		e83194ffff		CALL runtime.printstring(SB)	
  0x42900f		488b442418		MOVQ 0x18(SP), AX		
  0x429014		48890424		MOVQ AX, 0(SP)			
  0x429018		e86392ffff		CALL runtime.printint(SB)	
  0x42901d		488d05f01d0400		LEAQ 0x41df0(IP), AX		
  0x429024		48890424		MOVQ AX, 0(SP)			
  0x429028		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x429031		e80a94ffff		CALL runtime.printstring(SB)	
  0x429036		8b442410		MOVL 0x10(SP), AX		
  0x42903a		89c0			MOVL AX, AX			
  0x42903c		48890424		MOVQ AX, 0(SP)			
  0x429040		e82b91ffff		CALL runtime.printuint(SB)	
  0x429045		e8468dffff		CALL runtime.printnl(SB)	
  0x42904a		e8318bffff		CALL runtime.printunlock(SB)	
  0x42904f		488b442420		MOVQ 0x20(SP), AX		
	return atomic.Load(&gp.atomicstatus)
  0x429054		8b8890000000		MOVL 0x90(AX), CX	
  0x42905a		894c2414		MOVL CX, 0x14(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x42905e		488b9098000000		MOVQ 0x98(AX), DX		
  0x429065		4889542418		MOVQ DX, 0x18(SP)		
  0x42906a		e8918affff		CALL runtime.printlock(SB)	
  0x42906f		488d05dc1a0400		LEAQ 0x41adc(IP), AX		
  0x429076		48890424		MOVQ AX, 0(SP)			
  0x42907a		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x429083		e8b893ffff		CALL runtime.printstring(SB)	
  0x429088		488b442420		MOVQ 0x20(SP), AX		
  0x42908d		48890424		MOVQ AX, 0(SP)			
  0x429091		e86a93ffff		CALL runtime.printpointer(SB)	
  0x429096		488d05f50d0400		LEAQ 0x40df5(IP), AX		
  0x42909d		48890424		MOVQ AX, 0(SP)			
  0x4290a1		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4290aa		e89193ffff		CALL runtime.printstring(SB)	
  0x4290af		488b442418		MOVQ 0x18(SP), AX		
  0x4290b4		48890424		MOVQ AX, 0(SP)			
  0x4290b8		e8c391ffff		CALL runtime.printint(SB)	
  0x4290bd		488d053d1d0400		LEAQ 0x41d3d(IP), AX		
  0x4290c4		48890424		MOVQ AX, 0(SP)			
  0x4290c8		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4290d1		e86a93ffff		CALL runtime.printstring(SB)	
  0x4290d6		8b442414		MOVL 0x14(SP), AX		
  0x4290da		89c0			MOVL AX, AX			
  0x4290dc		48890424		MOVQ AX, 0(SP)			
  0x4290e0		e88b90ffff		CALL runtime.printuint(SB)	
  0x4290e5		e8a68cffff		CALL runtime.printnl(SB)	
  0x4290ea		e8918affff		CALL runtime.printunlock(SB)	
		throw("bad g status")
  0x4290ef		488d05d0140400		LEAQ 0x414d0(IP), AX	
  0x4290f6		48890424		MOVQ AX, 0(SP)		
  0x4290fa		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x429103		e8c880ffff		CALL runtime.throw(SB)	
  0x429108		0f0b			UD2			
func goschedImpl(gp *g) {
  0x42910a		e861b40100		CALL runtime.morestack_noctxt(SB)	
  0x42910f		e97cfdffff		JMP runtime.goschedImpl(SB)		

TEXT runtime.gosched_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gosched_m(gp *g) {
  0x429120		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429129		483b6110		CMPQ 0x10(CX), SP	
  0x42912d		7638			JBE 0x429167		
  0x42912f		4883ec10		SUBQ $0x10, SP		
  0x429133		48896c2408		MOVQ BP, 0x8(SP)	
  0x429138		488d6c2408		LEAQ 0x8(SP), BP	
	if trace.enabled {
  0x42913d		0fb6058ca60800		MOVZX runtime.trace+16(SB), AX	
  0x429144		84c0			TESTL AL, AL			
  0x429146		7518			JNE 0x429160			
  0x429148		488b442418		MOVQ 0x18(SP), AX		
	goschedImpl(gp)
  0x42914d		48890424		MOVQ AX, 0(SP)			
  0x429151		e83afdffff		CALL runtime.goschedImpl(SB)	
}
  0x429156		488b6c2408		MOVQ 0x8(SP), BP	
  0x42915b		4883c410		ADDQ $0x10, SP		
  0x42915f		c3			RET			
		traceGoSched()
  0x429160		e8eb190100		CALL runtime.traceGoSched(SB)	
  0x429165		ebe1			JMP 0x429148			
func gosched_m(gp *g) {
  0x429167		e804b40100		CALL runtime.morestack_noctxt(SB)	
  0x42916c		ebb2			JMP runtime.gosched_m(SB)		

TEXT runtime.gopreempt_m(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gopreempt_m(gp *g) {
  0x429170		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429179		483b6110		CMPQ 0x10(CX), SP	
  0x42917d		7638			JBE 0x4291b7		
  0x42917f		4883ec10		SUBQ $0x10, SP		
  0x429183		48896c2408		MOVQ BP, 0x8(SP)	
  0x429188		488d6c2408		LEAQ 0x8(SP), BP	
	if trace.enabled {
  0x42918d		0fb6053ca60800		MOVZX runtime.trace+16(SB), AX	
  0x429194		84c0			TESTL AL, AL			
  0x429196		7518			JNE 0x4291b0			
  0x429198		488b442418		MOVQ 0x18(SP), AX		
	goschedImpl(gp)
  0x42919d		48890424		MOVQ AX, 0(SP)			
  0x4291a1		e8eafcffff		CALL runtime.goschedImpl(SB)	
}
  0x4291a6		488b6c2408		MOVQ 0x8(SP), BP	
  0x4291ab		4883c410		ADDQ $0x10, SP		
  0x4291af		c3			RET			
		traceGoPreempt()
  0x4291b0		e80b1a0100		CALL runtime.traceGoPreempt(SB)	
  0x4291b5		ebe1			JMP 0x429198			
func gopreempt_m(gp *g) {
  0x4291b7		e8b4b30100		CALL runtime.morestack_noctxt(SB)	
  0x4291bc		ebb2			JMP runtime.gopreempt_m(SB)		

TEXT runtime.goexit1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func goexit1() {
  0x4291c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4291c9		483b6110		CMPQ 0x10(CX), SP	
  0x4291cd		763a			JBE 0x429209		
  0x4291cf		4883ec10		SUBQ $0x10, SP		
  0x4291d3		48896c2408		MOVQ BP, 0x8(SP)	
  0x4291d8		488d6c2408		LEAQ 0x8(SP), BP	
	if trace.enabled {
  0x4291dd		0fb605eca50800		MOVZX runtime.trace+16(SB), AX	
  0x4291e4		84c0			TESTL AL, AL			
  0x4291e6		751a			JNE 0x429202			
	mcall(goexit0)
  0x4291e8		488d05b94e0400		LEAQ 0x44eb9(IP), AX	
  0x4291ef		48890424		MOVQ AX, 0(SP)		
  0x4291f3		e8a8b10100		CALL runtime.mcall(SB)	
}
  0x4291f8		488b6c2408		MOVQ 0x8(SP), BP	
  0x4291fd		4883c410		ADDQ $0x10, SP		
  0x429201		c3			RET			
		traceGoEnd()
  0x429202		e8e9180100		CALL runtime.traceGoEnd(SB)	
  0x429207		ebdf			JMP 0x4291e8			
func goexit1() {
  0x429209		e862b30100		CALL runtime.morestack_noctxt(SB)	
  0x42920e		ebb0			JMP runtime.goexit1(SB)			

TEXT runtime.goexit0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func goexit0(gp *g) {
  0x429210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429219		483b6110		CMPQ 0x10(CX), SP	
  0x42921d		0f86f2020000		JBE 0x429515		
  0x429223		4883ec30		SUBQ $0x30, SP		
  0x429227		48896c2428		MOVQ BP, 0x28(SP)	
  0x42922c		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x429231		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42923a		4889442420		MOVQ AX, 0x20(SP)	
  0x42923f		488b4c2438		MOVQ 0x38(SP), CX	
	casgstatus(gp, _Grunning, _Gdead)
  0x429244		48890c24		MOVQ CX, 0(SP)			
  0x429248		48ba0200000006000000	MOVQ $0x600000002, DX		
  0x429252		4889542408		MOVQ DX, 0x8(SP)		
  0x429257		e824b8ffff		CALL runtime.casgstatus(SB)	
  0x42925c		488b442438		MOVQ 0x38(SP), AX		
	if isSystemGoroutine(gp) {
  0x429261		48890424		MOVQ AX, 0(SP)				
  0x429265		e8c6510100		CALL runtime.isSystemGoroutine(SB)	
  0x42926a		0fb6442408		MOVZX 0x8(SP), AX			
  0x42926f		84c0			TESTL AL, AL				
  0x429271		7410			JE 0x429283				
		atomic.Xadd(&sched.ngsys, -1)
  0x429273		b9ffffffff		MOVL $-0x1, CX			
  0x429278		488d15e1e60700		LEAQ runtime.sched+64(SB), DX	
  0x42927f		f00fc10a		LOCK XADDL CX, 0(DX)		
  0x429283		488b4c2438		MOVQ 0x38(SP), CX		
	gp.m = nil
  0x429288		8401			TESTB AL, 0(CX)				
  0x42928a		8b1580a70900		MOVL runtime.writeBarrier(SB), DX	
  0x429290		488d7930		LEAQ 0x30(CX), DI			
  0x429294		85d2			TESTL DX, DX				
  0x429296		0f8519020000		JNE 0x4294b5				
  0x42929c		48c7413000000000	MOVQ $0x0, 0x30(CX)			
	locked := gp.lockedm != 0
  0x4292a4		488b91e0000000		MOVQ 0xe0(CX), DX	
	gp.lockedm = 0
  0x4292ab		48c781e000000000000000	MOVQ $0x0, 0xe0(CX)	
  0x4292b6		488b5c2420		MOVQ 0x20(SP), BX	
	_g_.m.lockedg = 0
  0x4292bb		488b7330		MOVQ 0x30(BX), SI	
  0x4292bf		48c7866801000000000000	MOVQ $0x0, 0x168(SI)	
	gp.paniconfault = false
  0x4292ca		c681c100000000		MOVB $0x0, 0xc1(CX)	
	gp._defer = nil // should be true already but just in case.
  0x4292d1		8b3539a70900		MOVL runtime.writeBarrier(SB), SI	
  0x4292d7		488d7928		LEAQ 0x28(CX), DI			
	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
  0x4292db		4c8d4120		LEAQ 0x20(CX), R8	
	gp._defer = nil // should be true already but just in case.
  0x4292df		85f6			TESTL SI, SI		
  0x4292e1		0f85b8010000		JNE 0x42949f		
  0x4292e7		48c7412800000000	MOVQ $0x0, 0x28(CX)	
	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
  0x4292ef		48c7412000000000	MOVQ $0x0, 0x20(CX)	
	gp.writebuf = nil
  0x4292f7		0f57c0			XORPS X0, X0				
  0x4292fa		0f1181f8000000		MOVUPS X0, 0xf8(CX)			
  0x429301		8b3509a70900		MOVL runtime.writeBarrier(SB), SI	
  0x429307		488db9f0000000		LEAQ 0xf0(CX), DI			
  0x42930e		85f6			TESTL SI, SI				
  0x429310		0f857a010000		JNE 0x429490				
  0x429316		48c781f000000000000000	MOVQ $0x0, 0xf0(CX)			
	gp.waitreason = ""
  0x429321		48c781b000000000000000	MOVQ $0x0, 0xb0(CX)			
  0x42932c		8b35dea60900		MOVL runtime.writeBarrier(SB), SI	
  0x429332		488db9a8000000		LEAQ 0xa8(CX), DI			
	gp.param = nil
  0x429339		4c8d8188000000		LEAQ 0x88(CX), R8	
	gp.labels = nil
  0x429340		4c8d8958010000		LEAQ 0x158(CX), R9	
	gp.timer = nil
  0x429347		4c8d9160010000		LEAQ 0x160(CX), R10	
	gp.waitreason = ""
  0x42934e		85f6			TESTL SI, SI		
  0x429350		0f8512010000		JNE 0x429468		
  0x429356		48c781a800000000000000	MOVQ $0x0, 0xa8(CX)	
	gp.param = nil
  0x429361		48c7818800000000000000	MOVQ $0x0, 0x88(CX)	
	gp.timer = nil
  0x42936c		0f118158010000		MOVUPS X0, 0x158(CX)	
	if gcBlackenEnabled != 0 && gp.gcAssistBytes > 0 {
  0x429373		8b055ba50900		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x429379		85c0			TESTL AX, AX				
  0x42937b		7438			JE 0x4293b5				
  0x42937d		488b8170010000		MOVQ 0x170(CX), AX			
  0x429384		4885c0			TESTQ AX, AX				
  0x429387		7e2c			JLE 0x4293b5				
		scanCredit := int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))
  0x429389		0f57c0			XORPS X0, X0				
  0x42938c		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x429391		f20f5905c7a80900	MULSD runtime.gcController+64(SB), X0	
  0x429399		f2480f2cc0		CVTTSD2SIQ X0, AX			
		atomic.Xaddint64(&gcController.bgScanCredit, scanCredit)
  0x42939e		488d3583a80900		LEAQ runtime.gcController+8(SB), SI	
  0x4293a5		f0480fc106		LOCK XADDQ AX, 0(SI)			
		gp.gcAssistBytes = 0
  0x4293aa		48c7817001000000000000	MOVQ $0x0, 0x170(CX)	
	gp.gcscanvalid = true
  0x4293b5		c681c400000001		MOVB $0x1, 0xc4(CX)	
	_g_ := getg()
  0x4293bc		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x4293c5		488b7030		MOVQ 0x30(AX), SI	
  0x4293c9		488bbec0000000		MOVQ 0xc0(SI), DI	
  0x4293d0		8406			TESTB AL, 0(SI)		
  0x4293d2		488d7730		LEAQ 0x30(DI), SI	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x4293d6		8406			TESTB AL, 0(SI)		
  0x4293d8		31f6			XORL SI, SI		
  0x4293da		48897730		MOVQ SI, 0x30(DI)	
	setGNoWB(&_g_.m.curg, nil)
  0x4293de		488b7030		MOVQ 0x30(AX), SI	
  0x4293e2		8400			TESTB AL, 0(AX)		
  0x4293e4		488d86c0000000		LEAQ 0xc0(SI), AX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4293eb		8400			TESTB AL, 0(AX)		
  0x4293ed		31c0			XORL AX, AX		
  0x4293ef		488986c0000000		MOVQ AX, 0xc0(SI)	
	if _g_.m.lockedInt != 0 {
  0x4293f6		488b4330		MOVQ 0x30(BX), AX	
  0x4293fa		8bb0f8020000		MOVL 0x2f8(AX), SI	
  0x429400		85f6			TESTL SI, SI		
  0x429402		0f85b9000000		JNE 0x4294c1		
  0x429408		4889542418		MOVQ DX, 0x18(SP)	
	_g_.m.lockedExt = 0
  0x42940d		c780f402000000000000	MOVL $0x0, 0x2f4(AX)	
	gfput(_g_.m.p.ptr(), gp)
  0x429417		488b4330		MOVQ 0x30(BX), AX	
  0x42941b		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x429422		48890424		MOVQ AX, 0(SP)		
  0x429426		48894c2408		MOVQ CX, 0x8(SP)	
  0x42942b		e820140000		CALL runtime.gfput(SB)	
  0x429430		488b442418		MOVQ 0x18(SP), AX	
	locked := gp.lockedm != 0
  0x429435		4885c0			TESTQ AX, AX		
	if locked {
  0x429438		750f			JNE 0x429449		
	schedule()
  0x42943a		e8c1f4ffff		CALL runtime.schedule(SB)	
}
  0x42943f		488b6c2428		MOVQ 0x28(SP), BP	
  0x429444		4883c430		ADDQ $0x30, SP		
  0x429448		c3			RET			
  0x429449		488b442420		MOVQ 0x20(SP), AX	
			gogo(&_g_.m.g0.sched)
  0x42944e		488b4030		MOVQ 0x30(AX), AX	
  0x429452		488b08			MOVQ 0(AX), CX		
  0x429455		8401			TESTB AL, 0(CX)		
  0x429457		8400			TESTB AL, 0(AX)		
  0x429459		488d4138		LEAQ 0x38(CX), AX	
  0x42945d		48890424		MOVQ AX, 0(SP)		
  0x429461		e8daae0100		CALL runtime.gogo(SB)	
	schedule()
  0x429466		ebd2			JMP 0x42943a		
	gp.waitreason = ""
  0x429468		31c0			XORL AX, AX			
  0x42946a		e831d40100		CALL runtime.gcWriteBarrier(SB)	
  0x42946f		4c89c7			MOVQ R8, DI			
	gp.param = nil
  0x429472		31c0			XORL AX, AX			
  0x429474		e827d40100		CALL runtime.gcWriteBarrier(SB)	
  0x429479		4c89cf			MOVQ R9, DI			
	gp.labels = nil
  0x42947c		e81fd40100		CALL runtime.gcWriteBarrier(SB)	
  0x429481		4c89d7			MOVQ R10, DI			
	gp.timer = nil
  0x429484		31c0			XORL AX, AX			
  0x429486		e815d40100		CALL runtime.gcWriteBarrier(SB)	
	gp.waitreason = ""
  0x42948b		e9e3feffff		JMP 0x429373		
	gp.writebuf = nil
  0x429490		31c0			XORL AX, AX			
  0x429492		e809d40100		CALL runtime.gcWriteBarrier(SB)	
  0x429497		0f57c0			XORPS X0, X0			
  0x42949a		e982feffff		JMP 0x429321			
	gp._defer = nil // should be true already but just in case.
  0x42949f		31c0			XORL AX, AX			
  0x4294a1		e8fad30100		CALL runtime.gcWriteBarrier(SB)	
  0x4294a6		4c89c7			MOVQ R8, DI			
	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
  0x4294a9		31c0			XORL AX, AX			
  0x4294ab		e8f0d30100		CALL runtime.gcWriteBarrier(SB)	
	gp._defer = nil // should be true already but just in case.
  0x4294b0		e942feffff		JMP 0x4292f7		
	gp.m = nil
  0x4294b5		31c0			XORL AX, AX			
  0x4294b7		e8e4d30100		CALL runtime.gcWriteBarrier(SB)	
  0x4294bc		e9e3fdffff		JMP 0x4292a4			
  0x4294c1		89742414		MOVL SI, 0x14(SP)		
		print("invalid m->lockedInt = ", _g_.m.lockedInt, "\n")
  0x4294c5		e83686ffff		CALL runtime.printlock(SB)	
  0x4294ca		488d05c0210400		LEAQ 0x421c0(IP), AX		
  0x4294d1		48890424		MOVQ AX, 0(SP)			
  0x4294d5		48c744240817000000	MOVQ $0x17, 0x8(SP)		
  0x4294de		e85d8fffff		CALL runtime.printstring(SB)	
  0x4294e3		8b442414		MOVL 0x14(SP), AX		
  0x4294e7		48890424		MOVQ AX, 0(SP)			
  0x4294eb		e8808cffff		CALL runtime.printuint(SB)	
  0x4294f0		e89b88ffff		CALL runtime.printnl(SB)	
  0x4294f5		e88686ffff		CALL runtime.printunlock(SB)	
		throw("internal lockOSThread error")
  0x4294fa		488d0565280400		LEAQ 0x42865(IP), AX	
  0x429501		48890424		MOVQ AX, 0(SP)		
  0x429505		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x42950e		e8bd7cffff		CALL runtime.throw(SB)	
  0x429513		0f0b			UD2			
func goexit0(gp *g) {
  0x429515		e856b00100		CALL runtime.morestack_noctxt(SB)	
  0x42951a		e9f1fcffff		JMP runtime.goexit0(SB)			

TEXT runtime.save(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	_g_ := getg()
  0x429520		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x429529		488b4c2408		MOVQ 0x8(SP), CX	
	_g_.sched.pc = pc
  0x42952e		48894840		MOVQ CX, 0x40(AX)	
func save(pc, sp uintptr) {
  0x429532		488b4c2410		MOVQ 0x10(SP), CX	
	_g_.sched.sp = sp
  0x429537		48894838		MOVQ CX, 0x38(AX)	
	_g_.sched.lr = 0
  0x42953b		48c7406000000000	MOVQ $0x0, 0x60(AX)	
	_g_.sched.ret = 0
  0x429543		48c7405800000000	MOVQ $0x0, 0x58(AX)	
  0x42954b		4889c1			MOVQ AX, CX		
	_g_.sched.g = guintptr(unsafe.Pointer(_g_))
  0x42954e		48894148		MOVQ AX, 0x48(CX)	
	if _g_.sched.ctxt != nil {
  0x429552		488b4150		MOVQ 0x50(CX), AX	
  0x429556		4885c0			TESTQ AX, AX		
  0x429559		7501			JNE 0x42955c		
  0x42955b		c3			RET			
		badctxt()
  0x42955c		e88fa3ffff		CALL runtime.badctxt(SB)	
  0x429561		ebf8			JMP 0x42955b			

TEXT runtime.reentersyscall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func reentersyscall(pc, sp uintptr) {
  0x429570		4883ec30		SUBQ $0x30, SP		
  0x429574		48896c2428		MOVQ BP, 0x28(SP)	
  0x429579		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x42957e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x429587		4889442410		MOVQ AX, 0x10(SP)	
	_g_.m.locks++
  0x42958c		488b4830		MOVQ 0x30(AX), CX	
  0x429590		ff8100010000		INCL 0x100(CX)		
	_g_.stackguard0 = stackPreempt
  0x429596		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	_g_.throwsplit = true
  0x42959e		c680c500000001		MOVB $0x1, 0xc5(AX)	
func reentersyscall(pc, sp uintptr) {
  0x4295a5		488b4c2438		MOVQ 0x38(SP), CX	
	save(pc, sp)
  0x4295aa		48890c24		MOVQ CX, 0(SP)		
func reentersyscall(pc, sp uintptr) {
  0x4295ae		488b542440		MOVQ 0x40(SP), DX	
	save(pc, sp)
  0x4295b3		4889542408		MOVQ DX, 0x8(SP)	
  0x4295b8		e863ffffff		CALL runtime.save(SB)	
  0x4295bd		488b442440		MOVQ 0x40(SP), AX	
  0x4295c2		488b4c2410		MOVQ 0x10(SP), CX	
	_g_.syscallsp = sp
  0x4295c7		48894170		MOVQ AX, 0x70(CX)	
  0x4295cb		488b542438		MOVQ 0x38(SP), DX	
	_g_.syscallpc = pc
  0x4295d0		48895178		MOVQ DX, 0x78(CX)	
	casgstatus(_g_, _Grunning, _Gsyscall)
  0x4295d4		48890c24		MOVQ CX, 0(SP)			
  0x4295d8		48bb0200000003000000	MOVQ $0x300000002, BX		
  0x4295e2		48895c2408		MOVQ BX, 0x8(SP)		
  0x4295e7		e894b4ffff		CALL runtime.casgstatus(SB)	
  0x4295ec		488b442410		MOVQ 0x10(SP), AX		
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x4295f1		488b4870		MOVQ 0x70(AX), CX	
  0x4295f5		488b10			MOVQ 0(AX), DX		
  0x4295f8		4839d1			CMPQ DX, CX		
  0x4295fb		0f8390010000		JAE 0x429791		
		systemstack(func() {
  0x429601		488d0d289f0100		LEAQ runtime.reentersyscall.func1(SB), CX	
  0x429608		48894c2418		MOVQ CX, 0x18(SP)				
  0x42960d		4889442420		MOVQ AX, 0x20(SP)				
  0x429612		488d4c2418		LEAQ 0x18(SP), CX				
  0x429617		48890c24		MOVQ CX, 0(SP)					
  0x42961b		e800ae0100		CALL runtime.systemstack(SB)			
	if trace.enabled {
  0x429620		0fb605a9a10800		MOVZX runtime.trace+16(SB), AX	
  0x429627		84c0			TESTL AL, AL			
  0x429629		0f8535010000		JNE 0x429764			
	if atomic.Load(&sched.sysmonwait) != 0 {
  0x42962f		8b05d3e30700		MOVL runtime.sched+232(SB), AX	
  0x429635		85c0			TESTL AX, AX			
  0x429637		0f85fa000000		JNE 0x429737			
  0x42963d		488b442410		MOVQ 0x10(SP), AX		
	if _g_.m.p.ptr().runSafePointFn != 0 {
  0x429642		488b4830		MOVQ 0x30(AX), CX	
  0x429646		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42964d		8401			TESTB AL, 0(CX)		
  0x42964f		8b89a0220000		MOVL 0x22a0(CX), CX	
  0x429655		85c9			TESTL CX, CX		
  0x429657		0f85a8000000		JNE 0x429705		
	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
  0x42965d		488b4830		MOVQ 0x30(AX), CX	
  0x429661		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x429668		8b521c			MOVL 0x1c(DX), DX	
  0x42966b		89912c030000		MOVL DX, 0x32c(CX)	
	_g_.sysblocktraced = true
  0x429671		c680c700000001		MOVB $0x1, 0xc7(AX)	
	_g_.m.mcache = nil
  0x429678		488b4830		MOVQ 0x30(AX), CX	
  0x42967c		48c7816001000000000000	MOVQ $0x0, 0x160(CX)	
	_g_.m.p.ptr().m = 0
  0x429687		488b4830		MOVQ 0x30(AX), CX	
  0x42968b		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x429692		48c7414000000000	MOVQ $0x0, 0x40(CX)	
	atomic.Store(&_g_.m.p.ptr().status, _Psyscall)
  0x42969a		488b4830		MOVQ 0x30(AX), CX	
  0x42969e		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x4296a5		8401			TESTB AL, 0(CX)		
  0x4296a7		b902000000		MOVL $0x2, CX		
  0x4296ac		874a0c			XCHGL CX, 0xc(DX)	
	if sched.gcwaiting != 0 {
  0x4296af		8b0d43e30700		MOVL runtime.sched+216(SB), CX	
  0x4296b5		85c9			TESTL CX, CX			
  0x4296b7		751d			JNE 0x4296d6			
	_g_.stackguard0 = stackPreempt
  0x4296b9		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	_g_.m.locks--
  0x4296c1		488b4030		MOVQ 0x30(AX), AX	
  0x4296c5		838000010000ff		ADDL $-0x1, 0x100(AX)	
}
  0x4296cc		488b6c2428		MOVQ 0x28(SP), BP	
  0x4296d1		4883c430		ADDQ $0x30, SP		
  0x4296d5		c3			RET			
		systemstack(entersyscall_gcwait)
  0x4296d6		488d0533490400		LEAQ 0x44933(IP), AX		
  0x4296dd		48890424		MOVQ AX, 0(SP)			
  0x4296e1		e83aad0100		CALL runtime.systemstack(SB)	
  0x4296e6		488b442438		MOVQ 0x38(SP), AX		
		save(pc, sp)
  0x4296eb		48890424		MOVQ AX, 0(SP)		
  0x4296ef		488b442440		MOVQ 0x40(SP), AX	
  0x4296f4		4889442408		MOVQ AX, 0x8(SP)	
  0x4296f9		e822feffff		CALL runtime.save(SB)	
  0x4296fe		488b442410		MOVQ 0x10(SP), AX	
  0x429703		ebb4			JMP 0x4296b9		
		systemstack(runSafePointFn)
  0x429705		488d05c44a0400		LEAQ 0x44ac4(IP), AX		
  0x42970c		48890424		MOVQ AX, 0(SP)			
  0x429710		e80bad0100		CALL runtime.systemstack(SB)	
  0x429715		488b442438		MOVQ 0x38(SP), AX		
		save(pc, sp)
  0x42971a		48890424		MOVQ AX, 0(SP)		
  0x42971e		488b4c2440		MOVQ 0x40(SP), CX	
  0x429723		48894c2408		MOVQ CX, 0x8(SP)	
  0x429728		e8f3fdffff		CALL runtime.save(SB)	
  0x42972d		488b442410		MOVQ 0x10(SP), AX	
  0x429732		e926ffffff		JMP 0x42965d		
		systemstack(entersyscall_sysmon)
  0x429737		488d05da480400		LEAQ 0x448da(IP), AX		
  0x42973e		48890424		MOVQ AX, 0(SP)			
  0x429742		e8d9ac0100		CALL runtime.systemstack(SB)	
  0x429747		488b442438		MOVQ 0x38(SP), AX		
		save(pc, sp)
  0x42974c		48890424		MOVQ AX, 0(SP)		
  0x429750		488b4c2440		MOVQ 0x40(SP), CX	
  0x429755		48894c2408		MOVQ CX, 0x8(SP)	
  0x42975a		e8c1fdffff		CALL runtime.save(SB)	
  0x42975f		e9d9feffff		JMP 0x42963d		
		systemstack(traceGoSysCall)
  0x429764		488d05cd4a0400		LEAQ 0x44acd(IP), AX		
  0x42976b		48890424		MOVQ AX, 0(SP)			
  0x42976f		e8acac0100		CALL runtime.systemstack(SB)	
  0x429774		488b442438		MOVQ 0x38(SP), AX		
		save(pc, sp)
  0x429779		48890424		MOVQ AX, 0(SP)		
  0x42977d		488b4c2440		MOVQ 0x40(SP), CX	
  0x429782		48894c2408		MOVQ CX, 0x8(SP)	
  0x429787		e894fdffff		CALL runtime.save(SB)	
  0x42978c		e99efeffff		JMP 0x42962f		
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x429791		488b5008		MOVQ 0x8(AX), DX	
  0x429795		4839ca			CMPQ CX, DX		
  0x429798		0f8263feffff		JB 0x429601		
  0x42979e		e97dfeffff		JMP 0x429620		

TEXT runtime.entersyscall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func entersyscall(dummy int32) {
  0x4297b0		4883ec18		SUBQ $0x18, SP		
  0x4297b4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4297b9		488d6c2410		LEAQ 0x10(SP), BP	
	reentersyscall(getcallerpc(), getcallersp(unsafe.Pointer(&dummy)))
  0x4297be		488b442418		MOVQ 0x18(SP), AX		
  0x4297c3		48890424		MOVQ AX, 0(SP)			
  0x4297c7		488d442420		LEAQ 0x20(SP), AX		
  0x4297cc		4889442408		MOVQ AX, 0x8(SP)		
  0x4297d1		e89afdffff		CALL runtime.reentersyscall(SB)	
}
  0x4297d6		488b6c2410		MOVQ 0x10(SP), BP	
  0x4297db		4883c418		ADDQ $0x18, SP		
  0x4297df		c3			RET			

TEXT runtime.entersyscall_sysmon(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func entersyscall_sysmon() {
  0x4297e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4297e9		483b6110		CMPQ 0x10(CX), SP	
  0x4297ed		765f			JBE 0x42984e		
  0x4297ef		4883ec10		SUBQ $0x10, SP		
  0x4297f3		48896c2408		MOVQ BP, 0x8(SP)	
  0x4297f8		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&sched.lock)
  0x4297fd		488d052ce10700		LEAQ runtime.sched+16(SB), AX	
  0x429804		48890424		MOVQ AX, 0(SP)			
  0x429808		e813fdfdff		CALL runtime.lock(SB)		
	if atomic.Load(&sched.sysmonwait) != 0 {
  0x42980d		8b05f5e10700		MOVL runtime.sched+232(SB), AX	
  0x429813		85c0			TESTL AX, AX			
  0x429815		751a			JNE 0x429831			
	unlock(&sched.lock)
  0x429817		488d0512e10700		LEAQ runtime.sched+16(SB), AX	
  0x42981e		48890424		MOVQ AX, 0(SP)			
  0x429822		e899fefdff		CALL runtime.unlock(SB)		
}
  0x429827		488b6c2408		MOVQ 0x8(SP), BP	
  0x42982c		4883c410		ADDQ $0x10, SP		
  0x429830		c3			RET			
		atomic.Store(&sched.sysmonwait, 0)
  0x429831		31c0			XORL AX, AX			
  0x429833		488d0dcee10700		LEAQ runtime.sched+232(SB), CX	
  0x42983a		8701			XCHGL AX, 0(CX)			
		notewakeup(&sched.sysmonnote)
  0x42983c		488d05cde10700		LEAQ runtime.sched+240(SB), AX	
  0x429843		48890424		MOVQ AX, 0(SP)			
  0x429847		e844fffdff		CALL runtime.notewakeup(SB)	
  0x42984c		ebc9			JMP 0x429817			
func entersyscall_sysmon() {
  0x42984e		e81dad0100		CALL runtime.morestack_noctxt(SB)	
  0x429853		eb8b			JMP runtime.entersyscall_sysmon(SB)	

TEXT runtime.entersyscall_gcwait(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func entersyscall_gcwait() {
  0x429860		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429869		483b6110		CMPQ 0x10(CX), SP	
  0x42986d		0f86c8000000		JBE 0x42993b		
  0x429873		4883ec18		SUBQ $0x18, SP		
  0x429877		48896c2410		MOVQ BP, 0x10(SP)	
  0x42987c		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x429881		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_p_ := _g_.m.p.ptr()
  0x42988a		488b4030		MOVQ 0x30(AX), AX	
  0x42988e		488b80d0000000		MOVQ 0xd0(AX), AX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x429895		4889442408		MOVQ AX, 0x8(SP)	
	lock(&sched.lock)
  0x42989a		488d0d8fe00700		LEAQ runtime.sched+16(SB), CX	
  0x4298a1		48890c24		MOVQ CX, 0(SP)			
  0x4298a5		e876fcfdff		CALL runtime.lock(SB)		
	if sched.stopwait > 0 && atomic.Cas(&_p_.status, _Psyscall, _Pgcstop) {
  0x4298aa		8b054ce10700		MOVL runtime.sched+220(SB), AX	
  0x4298b0		85c0			TESTL AX, AX			
  0x4298b2		7e3d			JLE 0x4298f1			
  0x4298b4		b802000000		MOVL $0x2, AX			
  0x4298b9		488b4c2408		MOVQ 0x8(SP), CX		
  0x4298be		ba03000000		MOVL $0x3, DX			
  0x4298c3		f00fb1510c		LOCK CMPXCHGL DX, 0xc(CX)	
  0x4298c8		0f94c2			SETE DL				
  0x4298cb		84d2			TESTL DL, DL			
  0x4298cd		7422			JE 0x4298f1			
		if trace.enabled {
  0x4298cf		0fb605fa9e0800		MOVZX runtime.trace+16(SB), AX	
  0x4298d6		84c0			TESTL AL, AL			
  0x4298d8		7543			JNE 0x42991d			
		_p_.syscalltick++
  0x4298da		ff411c			INCL 0x1c(CX)		
		if sched.stopwait--; sched.stopwait == 0 {
  0x4298dd		8b0519e10700		MOVL runtime.sched+220(SB), AX	
  0x4298e3		8d48ff			LEAL -0x1(AX), CX		
  0x4298e6		890d10e10700		MOVL CX, runtime.sched+220(SB)	
  0x4298ec		83f801			CMPL $0x1, AX			
  0x4298ef		741a			JE 0x42990b			
	unlock(&sched.lock)
  0x4298f1		488d0538e00700		LEAQ runtime.sched+16(SB), AX	
  0x4298f8		48890424		MOVQ AX, 0(SP)			
  0x4298fc		e8bffdfdff		CALL runtime.unlock(SB)		
}
  0x429901		488b6c2410		MOVQ 0x10(SP), BP	
  0x429906		4883c418		ADDQ $0x18, SP		
  0x42990a		c3			RET			
			notewakeup(&sched.stopnote)
  0x42990b		488d05eee00700		LEAQ runtime.sched+224(SB), AX	
  0x429912		48890424		MOVQ AX, 0(SP)			
  0x429916		e875fefdff		CALL runtime.notewakeup(SB)	
  0x42991b		ebd4			JMP 0x4298f1			
			traceGoSysBlock(_p_)
  0x42991d		48890c24		MOVQ CX, 0(SP)				
  0x429921		e8da150100		CALL runtime.traceGoSysBlock(SB)	
  0x429926		488b442408		MOVQ 0x8(SP), AX			
			traceProcStop(_p_)
  0x42992b		48890424		MOVQ AX, 0(SP)			
  0x42992f		e8bc090100		CALL runtime.traceProcStop(SB)	
  0x429934		488b4c2408		MOVQ 0x8(SP), CX		
  0x429939		eb9f			JMP 0x4298da			
func entersyscall_gcwait() {
  0x42993b		e830ac0100		CALL runtime.morestack_noctxt(SB)	
  0x429940		e91bffffff		JMP runtime.entersyscall_gcwait(SB)	

TEXT runtime.entersyscallblock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func entersyscallblock(dummy int32) {
  0x429950		4883ec60		SUBQ $0x60, SP		
  0x429954		48896c2458		MOVQ BP, 0x58(SP)	
  0x429959		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x42995e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x429967		4889442410		MOVQ AX, 0x10(SP)	
	_g_.m.locks++ // see comment in entersyscall
  0x42996c		488b4830		MOVQ 0x30(AX), CX	
  0x429970		ff8100010000		INCL 0x100(CX)		
	_g_.throwsplit = true
  0x429976		c680c500000001		MOVB $0x1, 0xc5(AX)	
	_g_.stackguard0 = stackPreempt // see comment in entersyscall
  0x42997d		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
  0x429985		488b4830		MOVQ 0x30(AX), CX	
  0x429989		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x429990		8b521c			MOVL 0x1c(DX), DX	
  0x429993		89912c030000		MOVL DX, 0x32c(CX)	
	_g_.sysblocktraced = true
  0x429999		c680c700000001		MOVB $0x1, 0xc7(AX)	
	_g_.m.p.ptr().syscalltick++
  0x4299a0		488b4830		MOVQ 0x30(AX), CX	
  0x4299a4		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x4299ab		ff411c			INCL 0x1c(CX)		
	save(pc, sp)
  0x4299ae		488b4c2460		MOVQ 0x60(SP), CX	
  0x4299b3		48890c24		MOVQ CX, 0(SP)		
  0x4299b7		488d542468		LEAQ 0x68(SP), DX	
  0x4299bc		4889542408		MOVQ DX, 0x8(SP)	
  0x4299c1		e85afbffff		CALL runtime.save(SB)	
  0x4299c6		488b442410		MOVQ 0x10(SP), AX	
	_g_.syscallsp = _g_.sched.sp
  0x4299cb		488b4838		MOVQ 0x38(AX), CX	
  0x4299cf		48894870		MOVQ CX, 0x70(AX)	
	_g_.syscallpc = _g_.sched.pc
  0x4299d3		488b4840		MOVQ 0x40(AX), CX	
  0x4299d7		48894878		MOVQ CX, 0x78(AX)	
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x4299db		488b4870		MOVQ 0x70(AX), CX	
  0x4299df		488b10			MOVQ 0(AX), DX		
  0x4299e2		4839d1			CMPQ DX, CX		
  0x4299e5		0f83f1000000		JAE 0x429adc		
		sp2 := _g_.sched.sp
  0x4299eb		488b5038		MOVQ 0x38(AX), DX	
		systemstack(func() {
  0x4299ef		48c744243000000000	MOVQ $0x0, 0x30(SP)				
  0x4299f8		0f57c0			XORPS X0, X0					
  0x4299fb		0f11442438		MOVUPS X0, 0x38(SP)				
  0x429a00		0f11442448		MOVUPS X0, 0x48(SP)				
  0x429a05		488d1d249c0100		LEAQ runtime.entersyscallblock.func1(SB), BX	
  0x429a0c		48895c2430		MOVQ BX, 0x30(SP)				
  0x429a11		488d5c2468		LEAQ 0x68(SP), BX				
  0x429a16		48895c2438		MOVQ BX, 0x38(SP)				
  0x429a1b		4889542440		MOVQ DX, 0x40(SP)				
  0x429a20		48894c2448		MOVQ CX, 0x48(SP)				
  0x429a25		4889442450		MOVQ AX, 0x50(SP)				
  0x429a2a		488d4c2430		LEAQ 0x30(SP), CX				
  0x429a2f		48890c24		MOVQ CX, 0(SP)					
  0x429a33		e8e8a90100		CALL runtime.systemstack(SB)			
  0x429a38		488b442410		MOVQ 0x10(SP), AX				
	casgstatus(_g_, _Grunning, _Gsyscall)
  0x429a3d		48890424		MOVQ AX, 0(SP)			
  0x429a41		48b90200000003000000	MOVQ $0x300000002, CX		
  0x429a4b		48894c2408		MOVQ CX, 0x8(SP)		
  0x429a50		e82bb0ffff		CALL runtime.casgstatus(SB)	
  0x429a55		488b442410		MOVQ 0x10(SP), AX		
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x429a5a		488b4870		MOVQ 0x70(AX), CX	
  0x429a5e		488b10			MOVQ 0(AX), DX		
  0x429a61		4839d1			CMPQ DX, CX		
  0x429a64		736b			JAE 0x429ad1		
		systemstack(func() {
  0x429a66		488d0d039d0100		LEAQ runtime.entersyscallblock.func2(SB), CX	
  0x429a6d		48894c2418		MOVQ CX, 0x18(SP)				
  0x429a72		488d4c2468		LEAQ 0x68(SP), CX				
  0x429a77		48894c2420		MOVQ CX, 0x20(SP)				
  0x429a7c		4889442428		MOVQ AX, 0x28(SP)				
  0x429a81		488d542418		LEAQ 0x18(SP), DX				
  0x429a86		48891424		MOVQ DX, 0(SP)					
  0x429a8a		e891a90100		CALL runtime.systemstack(SB)			
	systemstack(entersyscallblock_handoff)
  0x429a8f		488d058a450400		LEAQ 0x4458a(IP), AX		
  0x429a96		48890424		MOVQ AX, 0(SP)			
  0x429a9a		e881a90100		CALL runtime.systemstack(SB)	
	save(getcallerpc(), getcallersp(unsafe.Pointer(&dummy)))
  0x429a9f		488b442460		MOVQ 0x60(SP), AX	
  0x429aa4		48890424		MOVQ AX, 0(SP)		
  0x429aa8		488d442468		LEAQ 0x68(SP), AX	
  0x429aad		4889442408		MOVQ AX, 0x8(SP)	
  0x429ab2		e869faffff		CALL runtime.save(SB)	
  0x429ab7		488b442410		MOVQ 0x10(SP), AX	
	_g_.m.locks--
  0x429abc		488b4030		MOVQ 0x30(AX), AX	
  0x429ac0		838000010000ff		ADDL $-0x1, 0x100(AX)	
}
  0x429ac7		488b6c2458		MOVQ 0x58(SP), BP	
  0x429acc		4883c460		ADDQ $0x60, SP		
  0x429ad0		c3			RET			
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x429ad1		488b5008		MOVQ 0x8(AX), DX	
  0x429ad5		4839ca			CMPQ CX, DX		
  0x429ad8		728c			JB 0x429a66		
  0x429ada		ebb3			JMP 0x429a8f		
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x429adc		488b5008		MOVQ 0x8(AX), DX	
  0x429ae0		4839ca			CMPQ CX, DX		
  0x429ae3		0f8202ffffff		JB 0x4299eb		
  0x429ae9		e94affffff		JMP 0x429a38		

TEXT runtime.entersyscallblock_handoff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func entersyscallblock_handoff() {
  0x429af0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429af9		483b6110		CMPQ 0x10(CX), SP	
  0x429afd		7651			JBE 0x429b50		
  0x429aff		4883ec10		SUBQ $0x10, SP		
  0x429b03		48896c2408		MOVQ BP, 0x8(SP)	
  0x429b08		488d6c2408		LEAQ 0x8(SP), BP	
	if trace.enabled {
  0x429b0d		0fb605bc9c0800		MOVZX runtime.trace+16(SB), AX	
  0x429b14		84c0			TESTL AL, AL			
  0x429b16		7514			JNE 0x429b2c			
	handoffp(releasep())
  0x429b18		e8b3260000		CALL runtime.releasep(SB)	
  0x429b1d		e84ed5ffff		CALL runtime.handoffp(SB)	
}
  0x429b22		488b6c2408		MOVQ 0x8(SP), BP	
  0x429b27		4883c410		ADDQ $0x10, SP		
  0x429b2b		c3			RET			
		traceGoSysCall()
  0x429b2c		e88f120100		CALL runtime.traceGoSysCall(SB)	
		traceGoSysBlock(getg().m.p.ptr())
  0x429b31		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x429b3a		488b4030		MOVQ 0x30(AX), AX			
  0x429b3e		488b80d0000000		MOVQ 0xd0(AX), AX			
  0x429b45		48890424		MOVQ AX, 0(SP)				
  0x429b49		e8b2130100		CALL runtime.traceGoSysBlock(SB)	
  0x429b4e		ebc8			JMP 0x429b18				
func entersyscallblock_handoff() {
  0x429b50		e81baa0100		CALL runtime.morestack_noctxt(SB)		
  0x429b55		eb99			JMP runtime.entersyscallblock_handoff(SB)	

TEXT runtime.exitsyscall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func exitsyscall(dummy int32) {
  0x429b60		4883ec28		SUBQ $0x28, SP		
  0x429b64		48896c2420		MOVQ BP, 0x20(SP)	
  0x429b69		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x429b6e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x429b77		4889442410		MOVQ AX, 0x10(SP)	
	_g_.m.locks++ // see comment in entersyscall
  0x429b7c		488b4830		MOVQ 0x30(AX), CX	
  0x429b80		ff8100010000		INCL 0x100(CX)		
	if getcallersp(unsafe.Pointer(&dummy)) > _g_.syscallsp {
  0x429b86		488b4870		MOVQ 0x70(AX), CX	
  0x429b8a		488d542430		LEAQ 0x30(SP), DX	
  0x429b8f		4839ca			CMPQ CX, DX		
  0x429b92		0f87ed010000		JA 0x429d85		
	_g_.waitsince = 0
  0x429b98		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	oldp := _g_.m.p.ptr()
  0x429ba3		488b4830		MOVQ 0x30(AX), CX	
  0x429ba7		488b89d0000000		MOVQ 0xd0(CX), CX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x429bae		48894c2418		MOVQ CX, 0x18(SP)	
	if exitsyscallfast() {
  0x429bb3		e8e8010000		CALL runtime.exitsyscallfast(SB)	
  0x429bb8		0fb60424		MOVZX 0(SP), AX				
  0x429bbc		84c0			TESTL AL, AL				
  0x429bbe		0f85cd000000		JNE 0x429c91				
  0x429bc4		488b442410		MOVQ 0x10(SP), AX			
	_g_.sysexitticks = 0
  0x429bc9		48c780c800000000000000	MOVQ $0x0, 0xc8(AX)	
	if trace.enabled {
  0x429bd4		0fb60df59b0800		MOVZX runtime.trace+16(SB), CX	
  0x429bdb		84c9			TESTL CL, CL			
  0x429bdd		750f			JNE 0x429bee			
  0x429bdf		e9a8000000		JMP 0x429c8c			
			osyield()
  0x429be4		e867e30100		CALL runtime.osyield(SB)	
  0x429be9		488b442410		MOVQ 0x10(SP), AX		
		for oldp != nil && oldp.syscalltick == _g_.m.syscalltick {
  0x429bee		488b4c2418		MOVQ 0x18(SP), CX	
  0x429bf3		4885c9			TESTQ CX, CX		
  0x429bf6		7411			JE 0x429c09		
  0x429bf8		488b5030		MOVQ 0x30(AX), DX	
  0x429bfc		8b591c			MOVL 0x1c(CX), BX	
  0x429bff		8b922c030000		MOVL 0x32c(DX), DX	
  0x429c05		39d3			CMPL DX, BX		
  0x429c07		74db			JE 0x429be4		
		_g_.sysexitticks = cputicks()
  0x429c09		e8e2c00100		CALL runtime.cputicks(SB)	
  0x429c0e		488b0424		MOVQ 0(SP), AX			
  0x429c12		488b4c2410		MOVQ 0x10(SP), CX		
  0x429c17		488981c8000000		MOVQ AX, 0xc8(CX)		
	_g_.m.locks--
  0x429c1e		488b4130		MOVQ 0x30(CX), AX	
  0x429c22		838000010000ff		ADDL $-0x1, 0x100(AX)	
	mcall(exitsyscall0)
  0x429c29		488d0510440400		LEAQ 0x44410(IP), AX	
  0x429c30		48890424		MOVQ AX, 0(SP)		
  0x429c34		e867a70100		CALL runtime.mcall(SB)	
  0x429c39		488b442410		MOVQ 0x10(SP), AX	
	if _g_.m.mcache == nil {
  0x429c3e		488b4830		MOVQ 0x30(AX), CX	
  0x429c42		488b8960010000		MOVQ 0x160(CX), CX	
  0x429c49		4885c9			TESTQ CX, CX		
  0x429c4c		7427			JE 0x429c75		
	_g_.syscallsp = 0
  0x429c4e		48c7407000000000	MOVQ $0x0, 0x70(AX)	
	_g_.m.p.ptr().syscalltick++
  0x429c56		488b4830		MOVQ 0x30(AX), CX	
  0x429c5a		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x429c61		ff411c			INCL 0x1c(CX)		
	_g_.throwsplit = false
  0x429c64		c680c500000000		MOVB $0x0, 0xc5(AX)	
}
  0x429c6b		488b6c2420		MOVQ 0x20(SP), BP	
  0x429c70		4883c428		ADDQ $0x28, SP		
  0x429c74		c3			RET			
		systemstack(func() {
  0x429c75		488d05bc430400		LEAQ 0x443bc(IP), AX		
  0x429c7c		48890424		MOVQ AX, 0(SP)			
  0x429c80		e89ba70100		CALL runtime.systemstack(SB)	
  0x429c85		488b442410		MOVQ 0x10(SP), AX		
  0x429c8a		ebc2			JMP 0x429c4e			
  0x429c8c		4889c1			MOVQ AX, CX			
	if trace.enabled {
  0x429c8f		eb8d			JMP 0x429c1e		
  0x429c91		488b442410		MOVQ 0x10(SP), AX	
		if _g_.m.mcache == nil {
  0x429c96		488b4830		MOVQ 0x30(AX), CX	
  0x429c9a		488b8960010000		MOVQ 0x160(CX), CX	
  0x429ca1		4885c9			TESTQ CX, CX		
  0x429ca4		0f84c1000000		JE 0x429d6b		
		if trace.enabled {
  0x429caa		0fb60d1f9b0800		MOVZX runtime.trace+16(SB), CX	
  0x429cb1		84c9			TESTL CL, CL			
  0x429cb3		7429			JE 0x429cde			
			if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
  0x429cb5		488b4830		MOVQ 0x30(AX), CX	
  0x429cb9		488b91d0000000		MOVQ 0xd0(CX), DX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x429cc0		488b5c2418		MOVQ 0x18(SP), BX	
			if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
  0x429cc5		4839d3			CMPQ DX, BX		
  0x429cc8		0f8487000000		JE 0x429d55		
				systemstack(traceGoStart)
  0x429cce		488d055b450400		LEAQ 0x4455b(IP), AX		
  0x429cd5		48890424		MOVQ AX, 0(SP)			
  0x429cd9		e842a70100		CALL runtime.systemstack(SB)	
  0x429cde		488b442410		MOVQ 0x10(SP), AX		
		_g_.m.p.ptr().syscalltick++
  0x429ce3		488b4830		MOVQ 0x30(AX), CX	
  0x429ce7		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x429cee		ff411c			INCL 0x1c(CX)		
		casgstatus(_g_, _Gsyscall, _Grunning)
  0x429cf1		48890424		MOVQ AX, 0(SP)			
  0x429cf5		48b90300000002000000	MOVQ $0x200000003, CX		
  0x429cff		48894c2408		MOVQ CX, 0x8(SP)		
  0x429d04		e877adffff		CALL runtime.casgstatus(SB)	
  0x429d09		488b442410		MOVQ 0x10(SP), AX		
		_g_.syscallsp = 0
  0x429d0e		48c7407000000000	MOVQ $0x0, 0x70(AX)	
		_g_.m.locks--
  0x429d16		488b4830		MOVQ 0x30(AX), CX	
  0x429d1a		838100010000ff		ADDL $-0x1, 0x100(CX)	
		if _g_.preempt {
  0x429d21		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x429d28		84c9			TESTL CL, CL		
  0x429d2a		7419			JE 0x429d45		
			_g_.stackguard0 = stackPreempt
  0x429d2c		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
		_g_.throwsplit = false
  0x429d34		c680c500000000		MOVB $0x0, 0xc5(AX)	
		return
  0x429d3b		488b6c2420		MOVQ 0x20(SP), BP	
  0x429d40		4883c428		ADDQ $0x28, SP		
  0x429d44		c3			RET			
			_g_.stackguard0 = _g_.stack.lo + _StackGuard
  0x429d45		488b08			MOVQ 0(AX), CX		
  0x429d48		4881c170030000		ADDQ $0x370, CX		
  0x429d4f		48894810		MOVQ CX, 0x10(AX)	
  0x429d53		ebdf			JMP 0x429d34		
			if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
  0x429d55		8b892c030000		MOVL 0x32c(CX), CX	
  0x429d5b		8b521c			MOVL 0x1c(DX), DX	
  0x429d5e		39d1			CMPL DX, CX		
  0x429d60		0f8568ffffff		JNE 0x429cce		
  0x429d66		e973ffffff		JMP 0x429cde		
			systemstack(func() {
  0x429d6b		488d05be420400		LEAQ 0x442be(IP), AX		
  0x429d72		48890424		MOVQ AX, 0(SP)			
  0x429d76		e8a5a60100		CALL runtime.systemstack(SB)	
  0x429d7b		488b442410		MOVQ 0x10(SP), AX		
  0x429d80		e925ffffff		JMP 0x429caa			
		systemstack(func() {
  0x429d85		488d059c420400		LEAQ 0x4429c(IP), AX		
  0x429d8c		48890424		MOVQ AX, 0(SP)			
  0x429d90		e88ba60100		CALL runtime.systemstack(SB)	
  0x429d95		488b442410		MOVQ 0x10(SP), AX		
  0x429d9a		e9f9fdffff		JMP 0x429b98			

TEXT runtime.exitsyscallfast(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func exitsyscallfast() bool {
  0x429da0		4883ec38		SUBQ $0x38, SP		
  0x429da4		48896c2430		MOVQ BP, 0x30(SP)	
  0x429da9		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x429dae		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if sched.stopwait == freezeStopWait {
  0x429db7		8b153fdc0700		MOVL runtime.sched+220(SB), DX	
  0x429dbd		81faffffff7f		CMPL $0x7fffffff, DX		
  0x429dc3		0f84d1000000		JE 0x429e9a			
	if _g_.m.p != 0 && _g_.m.p.ptr().status == _Psyscall && atomic.Cas(&_g_.m.p.ptr().status, _Psyscall, _Prunning) {
  0x429dc9		488b5130		MOVQ 0x30(CX), DX		
  0x429dcd		488b92d0000000		MOVQ 0xd0(DX), DX		
  0x429dd4		4885d2			TESTQ DX, DX			
  0x429dd7		7422			JE 0x429dfb			
  0x429dd9		8b5a0c			MOVL 0xc(DX), BX		
  0x429ddc		83fb02			CMPL $0x2, BX			
  0x429ddf		751a			JNE 0x429dfb			
  0x429de1		b802000000		MOVL $0x2, AX			
  0x429de6		bb01000000		MOVL $0x1, BX			
  0x429deb		f00fb15a0c		LOCK CMPXCHGL BX, 0xc(DX)	
  0x429df0		0f94c2			SETE DL				
  0x429df3		84d2			TESTL DL, DL			
  0x429df5		0f858b000000		JNE 0x429e86			
	oldp := _g_.m.p.ptr()
  0x429dfb		488b4130		MOVQ 0x30(CX), AX	
  0x429dff		488b90d0000000		MOVQ 0xd0(AX), DX	
	_g_.m.mcache = nil
  0x429e06		48c7806001000000000000	MOVQ $0x0, 0x160(AX)	
	_g_.m.p = 0
  0x429e11		488b4130		MOVQ 0x30(CX), AX	
  0x429e15		48c780d000000000000000	MOVQ $0x0, 0xd0(AX)	
	if sched.pidle != 0 {
  0x429e20		488b0541db0700		MOVQ runtime.sched+72(SB), AX	
  0x429e27		4885c0			TESTQ AX, AX			
  0x429e2a		750f			JNE 0x429e3b			
	return false
  0x429e2c		c644244000		MOVB $0x0, 0x40(SP)	
  0x429e31		488b6c2430		MOVQ 0x30(SP), BP	
  0x429e36		4883c438		ADDQ $0x38, SP		
  0x429e3a		c3			RET			
		var ok bool
  0x429e3b		c644240f00		MOVB $0x0, 0xf(SP)	
		systemstack(func() {
  0x429e40		488d05299b0100		LEAQ runtime.exitsyscallfast.func1(SB), AX	
  0x429e47		4889442410		MOVQ AX, 0x10(SP)				
  0x429e4c		488d44240f		LEAQ 0xf(SP), AX				
  0x429e51		4889442418		MOVQ AX, 0x18(SP)				
  0x429e56		4889542420		MOVQ DX, 0x20(SP)				
  0x429e5b		48894c2428		MOVQ CX, 0x28(SP)				
  0x429e60		488d442410		LEAQ 0x10(SP), AX				
  0x429e65		48890424		MOVQ AX, 0(SP)					
  0x429e69		e8b2a50100		CALL runtime.systemstack(SB)			
		if ok {
  0x429e6e		0fb644240f		MOVZX 0xf(SP), AX	
  0x429e73		84c0			TESTL AL, AL		
  0x429e75		74b5			JE 0x429e2c		
			return true
  0x429e77		c644244001		MOVB $0x1, 0x40(SP)	
  0x429e7c		488b6c2430		MOVQ 0x30(SP), BP	
  0x429e81		4883c438		ADDQ $0x38, SP		
  0x429e85		c3			RET			
		exitsyscallfast_reacquired()
  0x429e86		e845000000		CALL runtime.exitsyscallfast_reacquired(SB)	
		return true
  0x429e8b		c644244001		MOVB $0x1, 0x40(SP)	
  0x429e90		488b6c2430		MOVQ 0x30(SP), BP	
  0x429e95		4883c438		ADDQ $0x38, SP		
  0x429e99		c3			RET			
		_g_.m.mcache = nil
  0x429e9a		488b4130		MOVQ 0x30(CX), AX	
  0x429e9e		48c7806001000000000000	MOVQ $0x0, 0x160(AX)	
		_g_.m.p = 0
  0x429ea9		488b4130		MOVQ 0x30(CX), AX	
  0x429ead		48c780d000000000000000	MOVQ $0x0, 0xd0(AX)	
		return false
  0x429eb8		c644244000		MOVB $0x0, 0x40(SP)	
  0x429ebd		488b6c2430		MOVQ 0x30(SP), BP	
  0x429ec2		4883c438		ADDQ $0x38, SP		
  0x429ec6		c3			RET			

TEXT runtime.exitsyscallfast_reacquired(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func exitsyscallfast_reacquired() {
  0x429ed0		4883ec28		SUBQ $0x28, SP		
  0x429ed4		48896c2420		MOVQ BP, 0x20(SP)	
  0x429ed9		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x429ede		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.mcache = _g_.m.p.ptr().mcache
  0x429ee7		488b4830		MOVQ 0x30(AX), CX	
  0x429eeb		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x429ef2		488b5248		MOVQ 0x48(DX), DX	
  0x429ef6		48899160010000		MOVQ DX, 0x160(CX)	
	_g_.m.p.ptr().m.set(_g_.m)
  0x429efd		488b4830		MOVQ 0x30(AX), CX	
  0x429f01		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x429f08		488d5a40		LEAQ 0x40(DX), BX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x429f0c		8403			TESTB AL, 0(BX)		
  0x429f0e		48894a40		MOVQ CX, 0x40(DX)	
	if _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
  0x429f12		488b4830		MOVQ 0x30(AX), CX	
  0x429f16		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x429f1d		8b892c030000		MOVL 0x32c(CX), CX	
  0x429f23		8b521c			MOVL 0x1c(DX), DX	
  0x429f26		39d1			CMPL DX, CX		
  0x429f28		7419			JE 0x429f43		
		if trace.enabled {
  0x429f2a		0fb60d9f980800		MOVZX runtime.trace+16(SB), CX	
  0x429f31		84c9			TESTL CL, CL			
  0x429f33		7518			JNE 0x429f4d			
		_g_.m.p.ptr().syscalltick++
  0x429f35		488b4030		MOVQ 0x30(AX), AX	
  0x429f39		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x429f40		ff401c			INCL 0x1c(AX)		
  0x429f43		488b6c2420		MOVQ 0x20(SP), BP	
  0x429f48		4883c428		ADDQ $0x28, SP		
  0x429f4c		c3			RET			
  0x429f4d		4889442408		MOVQ AX, 0x8(SP)	
			systemstack(func() {
  0x429f52		488d0dc79a0100		LEAQ runtime.exitsyscallfast_reacquired.func1(SB), CX	
  0x429f59		48894c2410		MOVQ CX, 0x10(SP)					
  0x429f5e		4889442418		MOVQ AX, 0x18(SP)					
  0x429f63		488d4c2410		LEAQ 0x10(SP), CX					
  0x429f68		48890c24		MOVQ CX, 0(SP)						
  0x429f6c		e8afa40100		CALL runtime.systemstack(SB)				
		if trace.enabled {
  0x429f71		488b442408		MOVQ 0x8(SP), AX	
			systemstack(func() {
  0x429f76		ebbd			JMP 0x429f35		

TEXT runtime.exitsyscallfast_pidle(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func exitsyscallfast_pidle() bool {
  0x429f80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429f89		483b6110		CMPQ 0x10(CX), SP	
  0x429f8d		0f86bb000000		JBE 0x42a04e		
  0x429f93		4883ec18		SUBQ $0x18, SP		
  0x429f97		48896c2410		MOVQ BP, 0x10(SP)	
  0x429f9c		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&sched.lock)
  0x429fa1		488d0588d90700		LEAQ runtime.sched+16(SB), AX	
  0x429fa8		48890424		MOVQ AX, 0(SP)			
  0x429fac		e86ff5fdff		CALL runtime.lock(SB)		
	_p_ := sched.pidle.ptr()
  0x429fb1		488b05b0d90700		MOVQ runtime.sched+72(SB), AX	
	if _p_ != nil {
  0x429fb8		4885c0			TESTQ AX, AX		
  0x429fbb		741e			JE 0x429fdb		
		sched.pidle = _p_.link
  0x429fbd		488b4810		MOVQ 0x10(AX), CX		
  0x429fc1		48890da0d90700		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x429fc8		b9ffffffff		MOVL $-0x1, CX			
  0x429fcd		488d159cd90700		LEAQ runtime.sched+80(SB), DX	
  0x429fd4		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x429fd8		4885c0			TESTQ AX, AX		
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x429fdb		4889442408		MOVQ AX, 0x8(SP)	
	if _p_ != nil && atomic.Load(&sched.sysmonwait) != 0 {
  0x429fe0		740a			JE 0x429fec			
  0x429fe2		8b0d20da0700		MOVL runtime.sched+232(SB), CX	
  0x429fe8		85c9			TESTL CX, CX			
  0x429fea		7541			JNE 0x42a02d			
	unlock(&sched.lock)
  0x429fec		488d053dd90700		LEAQ runtime.sched+16(SB), AX	
  0x429ff3		48890424		MOVQ AX, 0(SP)			
  0x429ff7		e8c4f6fdff		CALL runtime.unlock(SB)		
  0x429ffc		488b442408		MOVQ 0x8(SP), AX		
	if _p_ != nil {
  0x42a001		4885c0			TESTQ AX, AX		
	if _p_ != nil {
  0x42a004		7418			JE 0x42a01e		
		acquirep(_p_)
  0x42a006		48890424		MOVQ AX, 0(SP)			
  0x42a00a		e8d11f0000		CALL runtime.acquirep(SB)	
		return true
  0x42a00f		c644242001		MOVB $0x1, 0x20(SP)	
  0x42a014		488b6c2410		MOVQ 0x10(SP), BP	
  0x42a019		4883c418		ADDQ $0x18, SP		
  0x42a01d		c3			RET			
	return false
  0x42a01e		c644242000		MOVB $0x0, 0x20(SP)	
  0x42a023		488b6c2410		MOVQ 0x10(SP), BP	
  0x42a028		4883c418		ADDQ $0x18, SP		
  0x42a02c		c3			RET			
		atomic.Store(&sched.sysmonwait, 0)
  0x42a02d		31c0			XORL AX, AX			
  0x42a02f		488d0dead80700		LEAQ runtime.sched(SB), CX	
  0x42a036		8781e8000000		XCHGL AX, 0xe8(CX)		
		notewakeup(&sched.sysmonnote)
  0x42a03c		488d05cdd90700		LEAQ runtime.sched+240(SB), AX	
  0x42a043		48890424		MOVQ AX, 0(SP)			
  0x42a047		e844f7fdff		CALL runtime.notewakeup(SB)	
  0x42a04c		eb9e			JMP 0x429fec			
func exitsyscallfast_pidle() bool {
  0x42a04e		e81da50100		CALL runtime.morestack_noctxt(SB)	
  0x42a053		e928ffffff		JMP runtime.exitsyscallfast_pidle(SB)	

TEXT runtime.exitsyscall0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func exitsyscall0(gp *g) {
  0x42a060		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42a069		483b6110		CMPQ 0x10(CX), SP	
  0x42a06d		0f86c1010000		JBE 0x42a234		
  0x42a073		4883ec28		SUBQ $0x28, SP		
  0x42a077		48896c2420		MOVQ BP, 0x20(SP)	
  0x42a07c		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x42a081		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42a08a		4889442410		MOVQ AX, 0x10(SP)	
  0x42a08f		488b4c2430		MOVQ 0x30(SP), CX	
	casgstatus(gp, _Gsyscall, _Grunnable)
  0x42a094		48890c24		MOVQ CX, 0(SP)			
  0x42a098		48ba0300000001000000	MOVQ $0x100000003, DX		
  0x42a0a2		4889542408		MOVQ DX, 0x8(SP)		
  0x42a0a7		e8d4a9ffff		CALL runtime.casgstatus(SB)	
	_g_ := getg()
  0x42a0ac		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x42a0b5		488b4830		MOVQ 0x30(AX), CX	
  0x42a0b9		488b91c0000000		MOVQ 0xc0(CX), DX	
  0x42a0c0		8401			TESTB AL, 0(CX)		
  0x42a0c2		488d4a30		LEAQ 0x30(DX), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42a0c6		8401			TESTB AL, 0(CX)		
  0x42a0c8		31c9			XORL CX, CX		
  0x42a0ca		48894a30		MOVQ CX, 0x30(DX)	
	setGNoWB(&_g_.m.curg, nil)
  0x42a0ce		488b4830		MOVQ 0x30(AX), CX	
  0x42a0d2		8400			TESTB AL, 0(AX)		
  0x42a0d4		488d81c0000000		LEAQ 0xc0(CX), AX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a0db		8400			TESTB AL, 0(AX)		
  0x42a0dd		31c0			XORL AX, AX		
  0x42a0df		488981c0000000		MOVQ AX, 0xc0(CX)	
	lock(&sched.lock)
  0x42a0e6		488d0543d80700		LEAQ runtime.sched+16(SB), AX	
  0x42a0ed		48890424		MOVQ AX, 0(SP)			
  0x42a0f1		e82af4fdff		CALL runtime.lock(SB)		
	_p_ := sched.pidle.ptr()
  0x42a0f6		488b056bd80700		MOVQ runtime.sched+72(SB), AX	
	if _p_ != nil {
  0x42a0fd		4885c0			TESTQ AX, AX		
  0x42a100		741e			JE 0x42a120		
		sched.pidle = _p_.link
  0x42a102		488b4810		MOVQ 0x10(AX), CX		
  0x42a106		48890d5bd80700		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x42a10d		b9ffffffff		MOVL $-0x1, CX			
  0x42a112		488d1557d80700		LEAQ runtime.sched+80(SB), DX	
  0x42a119		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x42a11d		4885c0			TESTQ AX, AX		
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x42a120		4889442418		MOVQ AX, 0x18(SP)	
	if _p_ == nil {
  0x42a125		0f84aa000000		JE 0x42a1d5		
	} else if atomic.Load(&sched.sysmonwait) != 0 {
  0x42a12b		8b0dd7d80700		MOVL runtime.sched+232(SB), CX	
  0x42a131		85c9			TESTL CX, CX			
  0x42a133		757b			JNE 0x42a1b0			
	unlock(&sched.lock)
  0x42a135		488d05f4d70700		LEAQ runtime.sched+16(SB), AX	
  0x42a13c		48890424		MOVQ AX, 0(SP)			
  0x42a140		e87bf5fdff		CALL runtime.unlock(SB)		
  0x42a145		488b442418		MOVQ 0x18(SP), AX		
	if _p_ != nil {
  0x42a14a		4885c0			TESTQ AX, AX		
	if _p_ != nil {
  0x42a14d		7543			JNE 0x42a192		
  0x42a14f		488b442410		MOVQ 0x10(SP), AX	
	if _g_.m.lockedg != 0 {
  0x42a154		488b4030		MOVQ 0x30(AX), AX	
  0x42a158		488b8068010000		MOVQ 0x168(AX), AX	
  0x42a15f		4885c0			TESTQ AX, AX		
  0x42a162		7514			JNE 0x42a178		
	stopm()
  0x42a164		e817cbffff		CALL runtime.stopm(SB)	
	schedule() // Never returns.
  0x42a169		e892e7ffff		CALL runtime.schedule(SB)	
}
  0x42a16e		488b6c2420		MOVQ 0x20(SP), BP	
  0x42a173		4883c428		ADDQ $0x28, SP		
  0x42a177		c3			RET			
		stoplockedm()
  0x42a178		e863d2ffff		CALL runtime.stoplockedm(SB)	
  0x42a17d		488b442430		MOVQ 0x30(SP), AX		
		execute(gp, false) // Never returns.
  0x42a182		48890424		MOVQ AX, 0(SP)			
  0x42a186		c644240800		MOVB $0x0, 0x8(SP)		
  0x42a18b		e820d7ffff		CALL runtime.execute(SB)	
  0x42a190		ebd2			JMP 0x42a164			
		acquirep(_p_)
  0x42a192		48890424		MOVQ AX, 0(SP)			
  0x42a196		e8451e0000		CALL runtime.acquirep(SB)	
  0x42a19b		488b442430		MOVQ 0x30(SP), AX		
		execute(gp, false) // Never returns.
  0x42a1a0		48890424		MOVQ AX, 0(SP)			
  0x42a1a4		c644240800		MOVB $0x0, 0x8(SP)		
  0x42a1a9		e802d7ffff		CALL runtime.execute(SB)	
  0x42a1ae		eb9f			JMP 0x42a14f			
		atomic.Store(&sched.sysmonwait, 0)
  0x42a1b0		31c0			XORL AX, AX			
  0x42a1b2		488d0d4fd80700		LEAQ runtime.sched+232(SB), CX	
  0x42a1b9		8701			XCHGL AX, 0(CX)			
		notewakeup(&sched.sysmonnote)
  0x42a1bb		488d054ed80700		LEAQ runtime.sched+240(SB), AX	
  0x42a1c2		48890424		MOVQ AX, 0(SP)			
  0x42a1c6		e8c5f5fdff		CALL runtime.notewakeup(SB)	
  0x42a1cb		488b442418		MOVQ 0x18(SP), AX		
  0x42a1d0		e960ffffff		JMP 0x42a135			
  0x42a1d5		488b4c2430		MOVQ 0x30(SP), CX		
	gp.schedlink = 0
  0x42a1da		48c781b800000000000000	MOVQ $0x0, 0xb8(CX)	
	if sched.runqtail != 0 {
  0x42a1e5		488b1594d70700		MOVQ runtime.sched+96(SB), DX	
  0x42a1ec		4885d2			TESTQ DX, DX			
  0x42a1ef		742e			JE 0x42a21f			
		sched.runqtail.ptr().schedlink.set(gp)
  0x42a1f1		488d9ab8000000		LEAQ 0xb8(DX), BX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a1f8		8403			TESTB AL, 0(BX)			
  0x42a1fa		4889cb			MOVQ CX, BX			
  0x42a1fd		48898ab8000000		MOVQ CX, 0xb8(DX)		
  0x42a204		488d0d75d70700		LEAQ runtime.sched+96(SB), CX	
  0x42a20b		8401			TESTB AL, 0(CX)			
  0x42a20d		48891d6cd70700		MOVQ BX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42a214		ff056ed70700		INCL runtime.sched+104(SB)	
	unlock(&sched.lock)
  0x42a21a		e916ffffff		JMP 0x42a135		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a21f		488d1552d70700		LEAQ runtime.sched+88(SB), DX	
  0x42a226		8402			TESTB AL, 0(DX)			
  0x42a228		4889cb			MOVQ CX, BX			
  0x42a22b		48890d46d70700		MOVQ CX, runtime.sched+88(SB)	
	sched.runqtail.set(gp)
  0x42a232		ebd0			JMP 0x42a204		
func exitsyscall0(gp *g) {
  0x42a234		e837a30100		CALL runtime.morestack_noctxt(SB)	
  0x42a239		e922feffff		JMP runtime.exitsyscall0(SB)		

TEXT runtime.malg(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func malg(stacksize int32) *g {
  0x42a240		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42a249		483b6110		CMPQ 0x10(CX), SP	
  0x42a24d		0f8690000000		JBE 0x42a2e3		
  0x42a253		4883ec38		SUBQ $0x38, SP		
  0x42a257		48896c2430		MOVQ BP, 0x30(SP)	
  0x42a25c		488d6c2430		LEAQ 0x30(SP), BP	
	newg := new(g)
  0x42a261		488d0538ef0300		LEAQ 0x3ef38(IP), AX		
  0x42a268		48890424		MOVQ AX, 0(SP)			
  0x42a26c		e8af0efeff		CALL runtime.newobject(SB)	
  0x42a271		488b442408		MOVQ 0x8(SP), AX		
  0x42a276		8b4c2440		MOVL 0x40(SP), CX		
	if stacksize >= 0 {
  0x42a27a		85c9			TESTL CX, CX		
  0x42a27c		7d0f			JGE 0x42a28d		
	return newg
  0x42a27e		4889442448		MOVQ AX, 0x48(SP)	
  0x42a283		488b6c2430		MOVQ 0x30(SP), BP	
  0x42a288		4883c438		ADDQ $0x38, SP		
  0x42a28c		c3			RET			
  0x42a28d		4889442410		MOVQ AX, 0x10(SP)	
		stacksize = round2(_StackSystem + stacksize)
  0x42a292		890c24			MOVL CX, 0(SP)		
  0x42a295		e8e6b90000		CALL runtime.round2(SB)	
  0x42a29a		8b442408		MOVL 0x8(SP), AX	
		systemstack(func() {
  0x42a29e		488d0ddb970100		LEAQ runtime.malg.func1(SB), CX	
  0x42a2a5		48894c2418		MOVQ CX, 0x18(SP)		
  0x42a2aa		89442420		MOVL AX, 0x20(SP)		
  0x42a2ae		488b442410		MOVQ 0x10(SP), AX		
  0x42a2b3		4889442428		MOVQ AX, 0x28(SP)		
  0x42a2b8		488d4c2418		LEAQ 0x18(SP), CX		
  0x42a2bd		48890c24		MOVQ CX, 0(SP)			
  0x42a2c1		e85aa10100		CALL runtime.systemstack(SB)	
	if stacksize >= 0 {
  0x42a2c6		488b442410		MOVQ 0x10(SP), AX	
		newg.stackguard0 = newg.stack.lo + _StackGuard
  0x42a2cb		488b08			MOVQ 0(AX), CX		
  0x42a2ce		4881c170030000		ADDQ $0x370, CX		
  0x42a2d5		48894810		MOVQ CX, 0x10(AX)	
		newg.stackguard1 = ^uintptr(0)
  0x42a2d9		48c74018ffffffff	MOVQ $-0x1, 0x18(AX)	
  0x42a2e1		eb9b			JMP 0x42a27e		
func malg(stacksize int32) *g {
  0x42a2e3		e888a20100		CALL runtime.morestack_noctxt(SB)	
  0x42a2e8		e953ffffff		JMP runtime.malg(SB)			

TEXT runtime.newproc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func newproc(siz int32, fn *funcval) {
  0x42a2f0		4883ec38		SUBQ $0x38, SP		
  0x42a2f4		48896c2430		MOVQ BP, 0x30(SP)	
  0x42a2f9		488d6c2430		LEAQ 0x30(SP), BP	
	systemstack(func() {
  0x42a2fe		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x42a307		0f57c0			XORPS X0, X0				
  0x42a30a		0f11442410		MOVUPS X0, 0x10(SP)			
  0x42a30f		0f11442420		MOVUPS X0, 0x20(SP)			
  0x42a314		488d05c5970100		LEAQ runtime.newproc.func1(SB), AX	
  0x42a31b		4889442408		MOVQ AX, 0x8(SP)			
  0x42a320		488d442448		LEAQ 0x48(SP), AX			
  0x42a325		4889442410		MOVQ AX, 0x10(SP)			
  0x42a32a		488d442450		LEAQ 0x50(SP), AX			
  0x42a32f		4889442418		MOVQ AX, 0x18(SP)			
func newproc(siz int32, fn *funcval) {
  0x42a334		8b442440		MOVL 0x40(SP), AX	
	systemstack(func() {
  0x42a338		89442420		MOVL AX, 0x20(SP)		
  0x42a33c		488b442438		MOVQ 0x38(SP), AX		
  0x42a341		4889442428		MOVQ AX, 0x28(SP)		
  0x42a346		488d442408		LEAQ 0x8(SP), AX		
  0x42a34b		48890424		MOVQ AX, 0(SP)			
  0x42a34f		e8cca00100		CALL runtime.systemstack(SB)	
}
  0x42a354		488b6c2430		MOVQ 0x30(SP), BP	
  0x42a359		4883c438		ADDQ $0x38, SP		
  0x42a35d		c3			RET			

TEXT runtime.newproc1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func newproc1(fn *funcval, argp *uint8, narg int32, callerpc uintptr) {
  0x42a360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42a369		483b6110		CMPQ 0x10(CX), SP	
  0x42a36d		0f86ce040000		JBE 0x42a841		
  0x42a373		4881ec80000000		SUBQ $0x80, SP		
  0x42a37a		48896c2478		MOVQ BP, 0x78(SP)	
  0x42a37f		488d6c2478		LEAQ 0x78(SP), BP	
	_g_ := getg()
  0x42a384		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42a38d		488b8c2488000000	MOVQ 0x88(SP), CX	
	if fn == nil {
  0x42a395		4885c9			TESTQ CX, CX		
  0x42a398		0f847a040000		JE 0x42a818		
	_g_.m.locks++ // disable preemption because it can be holding p in a local var
  0x42a39e		488b5030		MOVQ 0x30(AX), DX	
  0x42a3a2		ff8200010000		INCL 0x100(DX)		
  0x42a3a8		8b942498000000		MOVL 0x98(SP), DX	
	siz = (siz + 7) &^ 7
  0x42a3af		8d5a07			LEAL 0x7(DX), BX	
  0x42a3b2		83e3f8			ANDL $-0x8, BX		
	if siz >= _StackMin-4*sys.RegSize-sys.RegSize {
  0x42a3b5		81fbd8070000		CMPL $0x7d8, BX		
  0x42a3bb		0f8d3c040000		JGE 0x42a7fd		
  0x42a3c1		4889442450		MOVQ AX, 0x50(SP)	
  0x42a3c6		895c242c		MOVL BX, 0x2c(SP)	
	_p_ := _g_.m.p.ptr()
  0x42a3ca		488b4830		MOVQ 0x30(AX), CX	
  0x42a3ce		488b89d0000000		MOVQ 0xd0(CX), CX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42a3d5		48894c2460		MOVQ CX, 0x60(SP)	
	newg := gfget(_p_)
  0x42a3da		48890c24		MOVQ CX, 0(SP)		
  0x42a3de		e87d060000		CALL runtime.gfget(SB)	
  0x42a3e3		488b442408		MOVQ 0x8(SP), AX	
	if newg == nil {
  0x42a3e8		4885c0			TESTQ AX, AX		
  0x42a3eb		0f8490030000		JE 0x42a781		
	if newg.stack.hi == 0 {
  0x42a3f1		488b4808		MOVQ 0x8(AX), CX	
  0x42a3f5		4885c9			TESTQ CX, CX		
  0x42a3f8		0f84e4030000		JE 0x42a7e2		
	return atomic.Load(&gp.atomicstatus)
  0x42a3fe		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(newg) != _Gdead {
  0x42a404		83f906			CMPL $0x6, CX		
  0x42a407		0f85ba030000		JNE 0x42a7c7		
  0x42a40d		4889442448		MOVQ AX, 0x48(SP)	
  0x42a412		8b4c242c		MOVL 0x2c(SP), CX	
	totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame
  0x42a416		4863c9			MOVSXD CX, CX		
  0x42a419		4883c120		ADDQ $0x20, CX		
	sp := newg.stack.hi - totalSize
  0x42a41d		488b5008		MOVQ 0x8(AX), DX	
  0x42a421		4829ca			SUBQ CX, DX		
  0x42a424		4889542430		MOVQ DX, 0x30(SP)	
  0x42a429		8b8c2498000000		MOVL 0x98(SP), CX	
	if narg > 0 {
  0x42a430		85c9			TESTL CX, CX		
  0x42a432		0f8f64020000		JG 0x42a69c		
	memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))
  0x42a438		488d4838		LEAQ 0x38(AX), CX			
  0x42a43c		48894c2458		MOVQ CX, 0x58(SP)			
  0x42a441		48890c24		MOVQ CX, 0(SP)				
  0x42a445		48c744240838000000	MOVQ $0x38, 0x8(SP)			
  0x42a44e		e81dca0100		CALL runtime.memclrNoHeapPointers(SB)	
  0x42a453		488b442430		MOVQ 0x30(SP), AX			
  0x42a458		488b4c2448		MOVQ 0x48(SP), CX			
	newg.sched.sp = sp
  0x42a45d		48894138		MOVQ AX, 0x38(CX)	
	newg.stktopsp = sp
  0x42a461		48898180000000		MOVQ AX, 0x80(CX)	
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
  0x42a468		488d0571c90200		LEAQ 0x2c971(IP), AX	
  0x42a46f		4889442468		MOVQ AX, 0x68(SP)	
  0x42a474		488d05353c0400		LEAQ 0x43c35(IP), AX	
  0x42a47b		4889442470		MOVQ AX, 0x70(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42a480		8400			TESTB AL, 0(AX)		
  0x42a482		488d442470		LEAQ 0x70(SP), AX	
  0x42a487		8400			TESTB AL, 0(AX)		
  0x42a489		488b05203c0400		MOVQ 0x43c20(IP), AX	
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
  0x42a490		48ffc0			INCQ AX			
  0x42a493		48894140		MOVQ AX, 0x40(CX)	
  0x42a497		4889c8			MOVQ CX, AX		
	newg.sched.g = guintptr(unsafe.Pointer(newg))
  0x42a49a		48894848		MOVQ CX, 0x48(AX)	
  0x42a49e		488b4c2458		MOVQ 0x58(SP), CX	
	sp := buf.sp
  0x42a4a3		8401			TESTB AL, 0(CX)		
  0x42a4a5		488b4838		MOVQ 0x38(AX), CX	
	sp -= sys.PtrSize
  0x42a4a9		4883c1f8		ADDQ $-0x8, CX		
  0x42a4ad		4889ca			MOVQ CX, DX		
	*(*uintptr)(unsafe.Pointer(sp)) = buf.pc
  0x42a4b0		488b9c2488000000	MOVQ 0x88(SP), BX	
		fn = unsafe.Pointer(fv.fn)
  0x42a4b8		488b33			MOVQ 0(BX), SI		
	*(*uintptr)(unsafe.Pointer(sp)) = buf.pc
  0x42a4bb		488b7840		MOVQ 0x40(AX), DI	
  0x42a4bf		488939			MOVQ DI, 0(CX)		
	buf.sp = sp
  0x42a4c2		48895038		MOVQ DX, 0x38(AX)	
	buf.pc = uintptr(fn)
  0x42a4c6		48897040		MOVQ SI, 0x40(AX)	
	buf.ctxt = ctxt
  0x42a4ca		8b0d40950900		MOVL runtime.writeBarrier(SB), CX	
  0x42a4d0		488d7850		LEAQ 0x50(AX), DI			
  0x42a4d4		85c9			TESTL CX, CX				
  0x42a4d6		0f85ad010000		JNE 0x42a689				
  0x42a4dc		48895850		MOVQ BX, 0x50(AX)			
  0x42a4e0		488b8c24a0000000	MOVQ 0xa0(SP), CX			
	newg.gopc = callerpc
  0x42a4e8		48898820010000		MOVQ CX, 0x120(AX)	
	newg.startpc = fn.fn
  0x42a4ef		488b0b			MOVQ 0(BX), CX		
  0x42a4f2		48898828010000		MOVQ CX, 0x128(AX)	
  0x42a4f9		488b4c2450		MOVQ 0x50(SP), CX	
	if _g_.m.curg != nil {
  0x42a4fe		488b5130		MOVQ 0x30(CX), DX	
  0x42a502		488b92c0000000		MOVQ 0xc0(DX), DX	
  0x42a509		4885d2			TESTQ DX, DX		
  0x42a50c		7423			JE 0x42a531		
		newg.labels = _g_.m.curg.labels
  0x42a50e		8b1dfc940900		MOVL runtime.writeBarrier(SB), BX	
  0x42a514		488db858010000		LEAQ 0x158(AX), DI			
  0x42a51b		488b9258010000		MOVQ 0x158(DX), DX			
  0x42a522		85db			TESTL BX, BX				
  0x42a524		0f854c010000		JNE 0x42a676				
  0x42a52a		48899058010000		MOVQ DX, 0x158(AX)			
	if isSystemGoroutine(newg) {
  0x42a531		48890424		MOVQ AX, 0(SP)				
  0x42a535		e8f63e0100		CALL runtime.isSystemGoroutine(SB)	
  0x42a53a		0fb6442408		MOVZX 0x8(SP), AX			
  0x42a53f		84c0			TESTL AL, AL				
  0x42a541		7410			JE 0x42a553				
		atomic.Xadd(&sched.ngsys, +1)
  0x42a543		b801000000		MOVL $0x1, AX			
  0x42a548		488d0d11d40700		LEAQ runtime.sched+64(SB), CX	
  0x42a54f		f00fc101		LOCK XADDL AX, 0(CX)		
  0x42a553		488b442448		MOVQ 0x48(SP), AX		
	newg.gcscanvalid = false
  0x42a558		c680c400000000		MOVB $0x0, 0xc4(AX)	
	casgstatus(newg, _Gdead, _Grunnable)
  0x42a55f		48890424		MOVQ AX, 0(SP)			
  0x42a563		48b90600000001000000	MOVQ $0x100000006, CX		
  0x42a56d		48894c2408		MOVQ CX, 0x8(SP)		
  0x42a572		e809a5ffff		CALL runtime.casgstatus(SB)	
  0x42a577		488b442460		MOVQ 0x60(SP), AX		
	if _p_.goidcache == _p_.goidcacheend {
  0x42a57c		488b88d0050000		MOVQ 0x5d0(AX), CX	
  0x42a583		488b90d8050000		MOVQ 0x5d8(AX), DX	
  0x42a58a		4839d1			CMPQ DX, CX		
  0x42a58d		7527			JNE 0x42a5b6		
		_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)
  0x42a58f		b910000000		MOVL $0x10, CX			
  0x42a594		488d1585d30700		LEAQ runtime.sched(SB), DX	
  0x42a59b		f0480fc10a		LOCK XADDQ CX, 0(DX)		
		_p_.goidcache -= _GoidCacheBatch - 1
  0x42a5a0		488d5101		LEAQ 0x1(CX), DX	
  0x42a5a4		488990d0050000		MOVQ DX, 0x5d0(AX)	
		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
  0x42a5ab		4883c111		ADDQ $0x11, CX		
  0x42a5af		488988d8050000		MOVQ CX, 0x5d8(AX)	
	newg.goid = int64(_p_.goidcache)
  0x42a5b6		488b88d0050000		MOVQ 0x5d0(AX), CX	
  0x42a5bd		488b542448		MOVQ 0x48(SP), DX	
  0x42a5c2		48898a98000000		MOVQ CX, 0x98(DX)	
	_p_.goidcache++
  0x42a5c9		48ff80d0050000		INCQ 0x5d0(AX)		
	if trace.enabled {
  0x42a5d0		0fb60df9910800		MOVZX runtime.trace+16(SB), CX	
  0x42a5d7		84c9			TESTL CL, CL			
  0x42a5d9		7577			JNE 0x42a652			
	runqput(_p_, newg, true)
  0x42a5db		48890424		MOVQ AX, 0(SP)			
  0x42a5df		4889542408		MOVQ DX, 0x8(SP)		
  0x42a5e4		c644241001		MOVB $0x1, 0x10(SP)		
  0x42a5e9		e862380000		CALL runtime.runqput(SB)	
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {
  0x42a5ee		8b057cd30700		MOVL runtime.sched+80(SB), AX		
  0x42a5f4		85c0			TESTL AX, AX				
  0x42a5f6		7415			JE 0x42a60d				
  0x42a5f8		8b0576d30700		MOVL runtime.sched+84(SB), AX		
  0x42a5fe		85c0			TESTL AX, AX				
  0x42a600		750b			JNE 0x42a60d				
  0x42a602		0fb605a6920900		MOVZX runtime.mainStarted(SB), AX	
  0x42a609		84c0			TESTL AL, AL				
  0x42a60b		753e			JNE 0x42a64b				
  0x42a60d		488b442450		MOVQ 0x50(SP), AX			
	_g_.m.locks--
  0x42a612		488b4830		MOVQ 0x30(AX), CX	
  0x42a616		838100010000ff		ADDL $-0x1, 0x100(CX)	
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
  0x42a61d		488b4830		MOVQ 0x30(AX), CX	
  0x42a621		8b8900010000		MOVL 0x100(CX), CX	
  0x42a627		85c9			TESTL CX, CX		
  0x42a629		7513			JNE 0x42a63e		
  0x42a62b		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x42a632		84c9			TESTL CL, CL		
  0x42a634		7408			JE 0x42a63e		
		_g_.stackguard0 = stackPreempt
  0x42a636		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x42a63e		488b6c2478		MOVQ 0x78(SP), BP	
  0x42a643		4881c480000000		ADDQ $0x80, SP		
  0x42a64a		c3			RET			
		wakep()
  0x42a64b		e820cdffff		CALL runtime.wakep(SB)	
  0x42a650		ebbb			JMP 0x42a60d		
		traceGoCreate(newg, newg.startpc)
  0x42a652		488b8228010000		MOVQ 0x128(DX), AX		
  0x42a659		4889442408		MOVQ AX, 0x8(SP)		
  0x42a65e		48891424		MOVQ DX, 0(SP)			
  0x42a662		e8e9010100		CALL runtime.traceGoCreate(SB)	
  0x42a667		488b442460		MOVQ 0x60(SP), AX		
  0x42a66c		488b542448		MOVQ 0x48(SP), DX		
  0x42a671		e965ffffff		JMP 0x42a5db			
  0x42a676		4889c3			MOVQ AX, BX			
  0x42a679		4889d0			MOVQ DX, AX			
		newg.labels = _g_.m.curg.labels
  0x42a67c		e81fc20100		CALL runtime.gcWriteBarrier(SB)	
  0x42a681		4889d8			MOVQ BX, AX			
  0x42a684		e9a8feffff		JMP 0x42a531			
  0x42a689		4889c1			MOVQ AX, CX			
  0x42a68c		4889d8			MOVQ BX, AX			
	buf.ctxt = ctxt
  0x42a68f		e80cc20100		CALL runtime.gcWriteBarrier(SB)	
  0x42a694		4889c8			MOVQ CX, AX			
  0x42a697		e944feffff		JMP 0x42a4e0			
		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))
  0x42a69c		48891424		MOVQ DX, 0(SP)			
  0x42a6a0		488b942490000000	MOVQ 0x90(SP), DX		
  0x42a6a8		4889542408		MOVQ DX, 0x8(SP)		
  0x42a6ad		4863c9			MOVSXD CX, CX			
  0x42a6b0		48894c2438		MOVQ CX, 0x38(SP)		
  0x42a6b5		48894c2410		MOVQ CX, 0x10(SP)		
  0x42a6ba		e841ca0100		CALL runtime.memmove(SB)	
		if writeBarrier.needed && !_g_.m.curg.gcscandone {
  0x42a6bf		0fb6054e930900		MOVZX runtime.writeBarrier+4(SB), AX	
  0x42a6c6		84c0			TESTL AL, AL				
  0x42a6c8		0f84a9000000		JE 0x42a777				
  0x42a6ce		488b442450		MOVQ 0x50(SP), AX			
  0x42a6d3		488b4830		MOVQ 0x30(AX), CX			
  0x42a6d7		488b89c0000000		MOVQ 0xc0(CX), CX			
  0x42a6de		0fb689c3000000		MOVZX 0xc3(CX), CX			
  0x42a6e5		84c9			TESTL CL, CL				
  0x42a6e7		740a			JE 0x42a6f3				
  0x42a6e9		488b442448		MOVQ 0x48(SP), AX			
	memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))
  0x42a6ee		e945fdffff		JMP 0x42a438		
  0x42a6f3		488b842488000000	MOVQ 0x88(SP), AX	
			f := findfunc(fn.fn)
  0x42a6fb		488b08			MOVQ 0(AX), CX			
  0x42a6fe		48890c24		MOVQ CX, 0(SP)			
  0x42a702		e8c9da0000		CALL runtime.findfunc(SB)	
  0x42a707		488b442410		MOVQ 0x10(SP), AX		
  0x42a70c		488b4c2408		MOVQ 0x8(SP), CX		
			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
  0x42a711		48890c24		MOVQ CX, 0(SP)			
  0x42a715		4889442408		MOVQ AX, 0x8(SP)		
  0x42a71a		c744241000000000	MOVL $0x0, 0x10(SP)		
  0x42a722		e8c9e70000		CALL runtime.funcdata(SB)	
  0x42a727		488b442418		MOVQ 0x18(SP), AX		
			bv := stackmapdata(stkmap, 0)
  0x42a72c		48890424		MOVQ AX, 0(SP)			
  0x42a730		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x42a738		e8b3ea0000		CALL runtime.stackmapdata(SB)	
  0x42a73d		488b442418		MOVQ 0x18(SP), AX		
  0x42a742		488b4c2430		MOVQ 0x30(SP), CX		
			bulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata)
  0x42a747		48890c24		MOVQ CX, 0(SP)				
  0x42a74b		48894c2408		MOVQ CX, 0x8(SP)			
  0x42a750		488b542438		MOVQ 0x38(SP), DX			
  0x42a755		4889542410		MOVQ DX, 0x10(SP)			
  0x42a75a		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x42a763		4889442420		MOVQ AX, 0x20(SP)			
  0x42a768		e89323feff		CALL runtime.bulkBarrierBitmap(SB)	
  0x42a76d		488b442450		MOVQ 0x50(SP), AX			
  0x42a772		e972ffffff		JMP 0x42a6e9				
  0x42a777		488b442450		MOVQ 0x50(SP), AX			
		if writeBarrier.needed && !_g_.m.curg.gcscandone {
  0x42a77c		e968ffffff		JMP 0x42a6e9		
		newg = malg(_StackMin)
  0x42a781		c7042400080000		MOVL $0x800, 0(SP)	
  0x42a788		e8b3faffff		CALL runtime.malg(SB)	
  0x42a78d		488b442408		MOVQ 0x8(SP), AX	
  0x42a792		4889442440		MOVQ AX, 0x40(SP)	
		casgstatus(newg, _Gidle, _Gdead)
  0x42a797		48890424		MOVQ AX, 0(SP)			
  0x42a79b		48b90000000006000000	MOVQ $0x600000000, CX		
  0x42a7a5		48894c2408		MOVQ CX, 0x8(SP)		
  0x42a7aa		e8d1a2ffff		CALL runtime.casgstatus(SB)	
  0x42a7af		488b442440		MOVQ 0x40(SP), AX		
		allgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.
  0x42a7b4		48890424		MOVQ AX, 0(SP)			
  0x42a7b8		e86391ffff		CALL runtime.allgadd(SB)	
  0x42a7bd		488b442440		MOVQ 0x40(SP), AX		
  0x42a7c2		e92afcffff		JMP 0x42a3f1			
		throw("newproc1: new g is not Gdead")
  0x42a7c7		488d0590190400		LEAQ 0x41990(IP), AX	
  0x42a7ce		48890424		MOVQ AX, 0(SP)		
  0x42a7d2		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x42a7db		e8f069ffff		CALL runtime.throw(SB)	
  0x42a7e0		0f0b			UD2			
		throw("newproc1: newg missing stack")
  0x42a7e2		488d0591190400		LEAQ 0x41991(IP), AX	
  0x42a7e9		48890424		MOVQ AX, 0(SP)		
  0x42a7ed		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x42a7f6		e8d569ffff		CALL runtime.throw(SB)	
  0x42a7fb		0f0b			UD2			
		throw("newproc: function arguments too large for new goroutine")
  0x42a7fd		488d0564340400		LEAQ 0x43464(IP), AX	
  0x42a804		48890424		MOVQ AX, 0(SP)		
  0x42a808		48c744240837000000	MOVQ $0x37, 0x8(SP)	
  0x42a811		e8ba69ffff		CALL runtime.throw(SB)	
  0x42a816		0f0b			UD2			
		_g_.m.throwing = -1 // do not dump full stacks
  0x42a818		488b4030		MOVQ 0x30(AX), AX	
  0x42a81c		c780ec000000ffffffff	MOVL $-0x1, 0xec(AX)	
		throw("go of nil func value")
  0x42a826		488d05f0080400		LEAQ 0x408f0(IP), AX	
  0x42a82d		48890424		MOVQ AX, 0(SP)		
  0x42a831		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x42a83a		e89169ffff		CALL runtime.throw(SB)	
  0x42a83f		0f0b			UD2			
func newproc1(fn *funcval, argp *uint8, narg int32, callerpc uintptr) {
  0x42a841		e82a9d0100		CALL runtime.morestack_noctxt(SB)	
  0x42a846		e915fbffff		JMP runtime.newproc1(SB)		

TEXT runtime.gfput(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gfput(_p_ *p, gp *g) {
  0x42a850		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42a859		483b6110		CMPQ 0x10(CX), SP	
  0x42a85d		0f86f0010000		JBE 0x42aa53		
  0x42a863		4883ec20		SUBQ $0x20, SP		
  0x42a867		48896c2418		MOVQ BP, 0x18(SP)	
  0x42a86c		488d6c2418		LEAQ 0x18(SP), BP	
  0x42a871		488b442430		MOVQ 0x30(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x42a876		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp) != _Gdead {
  0x42a87c		83f906			CMPL $0x6, CX		
  0x42a87f		0f85b3010000		JNE 0x42aa38		
	stksize := gp.stack.hi - gp.stack.lo
  0x42a885		488b4808		MOVQ 0x8(AX), CX	
  0x42a889		488b10			MOVQ 0(AX), DX		
  0x42a88c		4889cb			MOVQ CX, BX		
  0x42a88f		4829d1			SUBQ DX, CX		
	if stksize != _FixedStack {
  0x42a892		4881f900080000		CMPQ $0x800, CX		
  0x42a899		0f8573010000		JNE 0x42aa12		
	gp.schedlink.set(_p_.gfree)
  0x42a89f		488d88b8000000		LEAQ 0xb8(AX), CX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a8a6		8401			TESTB AL, 0(CX)		
  0x42a8a8		488b4c2428		MOVQ 0x28(SP), CX	
	gp.schedlink.set(_p_.gfree)
  0x42a8ad		488b91f00d0000		MOVQ 0xdf0(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a8b4		488990b8000000		MOVQ DX, 0xb8(AX)	
	gp.schedlink.set(_p_.gfree)
  0x42a8bb		488db9f00d0000		LEAQ 0xdf0(CX), DI	
	_p_.gfree = gp
  0x42a8c2		8b1548910900		MOVL runtime.writeBarrier(SB), DX	
  0x42a8c8		85d2			TESTL DX, DX				
  0x42a8ca		0f8538010000		JNE 0x42aa08				
  0x42a8d0		488981f00d0000		MOVQ AX, 0xdf0(CX)			
	_p_.gfreecnt++
  0x42a8d7		8b81f80d0000		MOVL 0xdf8(CX), AX	
  0x42a8dd		ffc0			INCL AX			
  0x42a8df		8981f80d0000		MOVL AX, 0xdf8(CX)	
	if _p_.gfreecnt >= 64 {
  0x42a8e5		83f840			CMPL $0x40, AX		
  0x42a8e8		0f8c10010000		JL 0x42a9fe		
  0x42a8ee		48897c2410		MOVQ DI, 0x10(SP)	
		lock(&sched.gflock)
  0x42a8f3		488d0596d00700		LEAQ runtime.sched+112(SB), AX	
  0x42a8fa		48890424		MOVQ AX, 0(SP)			
  0x42a8fe		e81decfdff		CALL runtime.lock(SB)		
  0x42a903		488b442428		MOVQ 0x28(SP), AX		
		for _p_.gfreecnt >= 32 {
  0x42a908		eb06			JMP 0x42a910		
			sched.ngfree++
  0x42a90a		ff0598d00700		INCL runtime.sched+136(SB)	
		for _p_.gfreecnt >= 32 {
  0x42a910		8b88f80d0000		MOVL 0xdf8(AX), CX	
  0x42a916		83f920			CMPL $0x20, CX		
  0x42a919		0f8ccf000000		JL 0x42a9ee		
			_p_.gfreecnt--
  0x42a91f		ffc9			DECL CX			
  0x42a921		8988f80d0000		MOVL CX, 0xdf8(AX)	
			gp = _p_.gfree
  0x42a927		488b88f00d0000		MOVQ 0xdf0(AX), CX	
			_p_.gfree = gp.schedlink.ptr()
  0x42a92e		8b15dc900900		MOVL runtime.writeBarrier(SB), DX	
  0x42a934		488b99b8000000		MOVQ 0xb8(CX), BX			
  0x42a93b		488db1b8000000		LEAQ 0xb8(CX), SI			
  0x42a942		85d2			TESTL DX, DX				
  0x42a944		0f858c000000		JNE 0x42a9d6				
  0x42a94a		488998f00d0000		MOVQ BX, 0xdf0(AX)			
			if gp.stack.lo == 0 {
  0x42a951		488b11			MOVQ 0(CX), DX		
  0x42a954		4885d2			TESTQ DX, DX		
  0x42a957		753d			JNE 0x42a996		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a959		8406			TESTB AL, 0(SI)		
				gp.schedlink.set(sched.gfreeNoStack)
  0x42a95b		488b153ed00700		MOVQ runtime.sched+128(SB), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a962		488991b8000000		MOVQ DX, 0xb8(CX)	
				sched.gfreeNoStack = gp
  0x42a969		8b15a1900900		MOVL runtime.writeBarrier(SB), DX	
  0x42a96f		85d2			TESTL DX, DX				
  0x42a971		7509			JNE 0x42a97c				
  0x42a973		48890d26d00700		MOVQ CX, runtime.sched+128(SB)		
  0x42a97a		eb8e			JMP 0x42a90a				
  0x42a97c		488d3d1dd00700		LEAQ runtime.sched+128(SB), DI		
  0x42a983		4889c2			MOVQ AX, DX				
  0x42a986		4889c8			MOVQ CX, AX				
  0x42a989		e812bf0100		CALL runtime.gcWriteBarrier(SB)		
  0x42a98e		4889d0			MOVQ DX, AX				
  0x42a991		e974ffffff		JMP 0x42a90a				
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a996		8406			TESTB AL, 0(SI)		
				gp.schedlink.set(sched.gfreeStack)
  0x42a998		488b15f9cf0700		MOVQ runtime.sched+120(SB), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a99f		488991b8000000		MOVQ DX, 0xb8(CX)	
				sched.gfreeStack = gp
  0x42a9a6		8b1564900900		MOVL runtime.writeBarrier(SB), DX	
  0x42a9ac		85d2			TESTL DX, DX				
  0x42a9ae		750c			JNE 0x42a9bc				
  0x42a9b0		48890de1cf0700		MOVQ CX, runtime.sched+120(SB)		
  0x42a9b7		e94effffff		JMP 0x42a90a				
  0x42a9bc		488d3dd5cf0700		LEAQ runtime.sched+120(SB), DI		
  0x42a9c3		4889c2			MOVQ AX, DX				
  0x42a9c6		4889c8			MOVQ CX, AX				
  0x42a9c9		e8d2be0100		CALL runtime.gcWriteBarrier(SB)		
  0x42a9ce		4889d0			MOVQ DX, AX				
  0x42a9d1		e934ffffff		JMP 0x42a90a				
  0x42a9d6		488b7c2410		MOVQ 0x10(SP), DI			
  0x42a9db		4889c2			MOVQ AX, DX				
  0x42a9de		4889d8			MOVQ BX, AX				
			_p_.gfree = gp.schedlink.ptr()
  0x42a9e1		e8babe0100		CALL runtime.gcWriteBarrier(SB)	
  0x42a9e6		4889d0			MOVQ DX, AX			
  0x42a9e9		e963ffffff		JMP 0x42a951			
		unlock(&sched.gflock)
  0x42a9ee		488d059bcf0700		LEAQ runtime.sched+112(SB), AX	
  0x42a9f5		48890424		MOVQ AX, 0(SP)			
  0x42a9f9		e8c2ecfdff		CALL runtime.unlock(SB)		
  0x42a9fe		488b6c2418		MOVQ 0x18(SP), BP		
  0x42aa03		4883c420		ADDQ $0x20, SP			
  0x42aa07		c3			RET				
	_p_.gfree = gp
  0x42aa08		e893be0100		CALL runtime.gcWriteBarrier(SB)	
  0x42aa0d		e9c5feffff		JMP 0x42a8d7			
		stackfree(gp.stack)
  0x42aa12		48891424		MOVQ DX, 0(SP)			
  0x42aa16		48895c2408		MOVQ BX, 0x8(SP)		
  0x42aa1b		e8109e0000		CALL runtime.stackfree(SB)	
		gp.stack.hi = 0
  0x42aa20		0f57c0			XORPS X0, X0		
  0x42aa23		488b442430		MOVQ 0x30(SP), AX	
  0x42aa28		0f1100			MOVUPS X0, 0(AX)	
		gp.stackguard0 = 0
  0x42aa2b		48c7401000000000	MOVQ $0x0, 0x10(AX)	
  0x42aa33		e967feffff		JMP 0x42a89f		
		throw("gfput: bad status (not Gdead)")
  0x42aa38		488d053b180400		LEAQ 0x4183b(IP), AX	
  0x42aa3f		48890424		MOVQ AX, 0(SP)		
  0x42aa43		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x42aa4c		e87f67ffff		CALL runtime.throw(SB)	
  0x42aa51		0f0b			UD2			
func gfput(_p_ *p, gp *g) {
  0x42aa53		e8189b0100		CALL runtime.morestack_noctxt(SB)	
  0x42aa58		e9f3fdffff		JMP runtime.gfput(SB)			

TEXT runtime.gfget(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gfget(_p_ *p) *g {
  0x42aa60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42aa69		483b6110		CMPQ 0x10(CX), SP	
  0x42aa6d		0f86c5010000		JBE 0x42ac38		
  0x42aa73		4883ec30		SUBQ $0x30, SP		
  0x42aa77		48896c2428		MOVQ BP, 0x28(SP)	
  0x42aa7c		488d6c2428		LEAQ 0x28(SP), BP	
retry:
  0x42aa81		e9e9000000		JMP 0x42ab6f		
		for _p_.gfreecnt < 32 {
  0x42aa86		8b88f80d0000		MOVL 0xdf8(AX), CX	
  0x42aa8c		83f920			CMPL $0x20, CX		
  0x42aa8f		0f8dca000000		JGE 0x42ab5f		
			if sched.gfreeStack != nil {
  0x42aa95		488b0dfcce0700		MOVQ runtime.sched+120(SB), CX	
  0x42aa9c		4885c9			TESTQ CX, CX			
  0x42aa9f		747b			JE 0x42ab1c			
				sched.gfreeStack = gp.schedlink.ptr()
  0x42aaa1		8b15698f0900		MOVL runtime.writeBarrier(SB), DX	
  0x42aaa7		488b99b8000000		MOVQ 0xb8(CX), BX			
  0x42aaae		85d2			TESTL DX, DX				
  0x42aab0		7553			JNE 0x42ab05				
  0x42aab2		48891ddfce0700		MOVQ BX, runtime.sched+120(SB)		
			_p_.gfreecnt++
  0x42aab9		ff80f80d0000		INCL 0xdf8(AX)		
			sched.ngfree--
  0x42aabf		8305e2ce0700ff		ADDL $-0x1, runtime.sched+136(SB)	
			gp.schedlink.set(_p_.gfree)
  0x42aac6		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42aacd		8402			TESTB AL, 0(DX)		
			gp.schedlink.set(_p_.gfree)
  0x42aacf		488b90f00d0000		MOVQ 0xdf0(AX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42aad6		488991b8000000		MOVQ DX, 0xb8(CX)	
			_p_.gfree = gp
  0x42aadd		8b152d8f0900		MOVL runtime.writeBarrier(SB), DX	
  0x42aae3		85d2			TESTL DX, DX				
  0x42aae5		7509			JNE 0x42aaf0				
  0x42aae7		488988f00d0000		MOVQ CX, 0xdf0(AX)			
  0x42aaee		eb96			JMP 0x42aa86				
  0x42aaf0		488b7c2410		MOVQ 0x10(SP), DI			
  0x42aaf5		4889c2			MOVQ AX, DX				
  0x42aaf8		4889c8			MOVQ CX, AX				
  0x42aafb		e8a0bd0100		CALL runtime.gcWriteBarrier(SB)		
  0x42ab00		4889d0			MOVQ DX, AX				
  0x42ab03		eb81			JMP 0x42aa86				
				sched.gfreeStack = gp.schedlink.ptr()
  0x42ab05		488d3d8cce0700		LEAQ runtime.sched+120(SB), DI	
  0x42ab0c		4889c2			MOVQ AX, DX			
  0x42ab0f		4889d8			MOVQ BX, AX			
  0x42ab12		e889bd0100		CALL runtime.gcWriteBarrier(SB)	
  0x42ab17		4889d0			MOVQ DX, AX			
  0x42ab1a		eb9d			JMP 0x42aab9			
			} else if sched.gfreeNoStack != nil {
  0x42ab1c		488b0d7dce0700		MOVQ runtime.sched+128(SB), CX	
  0x42ab23		4885c9			TESTQ CX, CX			
  0x42ab26		7437			JE 0x42ab5f			
				sched.gfreeNoStack = gp.schedlink.ptr()
  0x42ab28		8b15e28e0900		MOVL runtime.writeBarrier(SB), DX	
  0x42ab2e		488b99b8000000		MOVQ 0xb8(CX), BX			
  0x42ab35		85d2			TESTL DX, DX				
  0x42ab37		750c			JNE 0x42ab45				
  0x42ab39		48891d60ce0700		MOVQ BX, runtime.sched+128(SB)		
  0x42ab40		e974ffffff		JMP 0x42aab9				
  0x42ab45		488d3d54ce0700		LEAQ runtime.sched+128(SB), DI		
  0x42ab4c		4889c2			MOVQ AX, DX				
  0x42ab4f		4889d8			MOVQ BX, AX				
  0x42ab52		e849bd0100		CALL runtime.gcWriteBarrier(SB)		
  0x42ab57		4889d0			MOVQ DX, AX				
  0x42ab5a		e95affffff		JMP 0x42aab9				
		unlock(&sched.gflock)
  0x42ab5f		488d052ace0700		LEAQ runtime.sched+112(SB), AX	
  0x42ab66		48890424		MOVQ AX, 0(SP)			
  0x42ab6a		e851ebfdff		CALL runtime.unlock(SB)		
		goto retry
  0x42ab6f		488b4c2438		MOVQ 0x38(SP), CX	
	gp := _p_.gfree
  0x42ab74		488b91f00d0000		MOVQ 0xdf0(CX), DX	
  0x42ab7b		488db9f00d0000		LEAQ 0xdf0(CX), DI	
	if gp == nil && (sched.gfreeStack != nil || sched.gfreeNoStack != nil) {
  0x42ab82		4885d2			TESTQ DX, DX			
  0x42ab85		753a			JNE 0x42abc1			
  0x42ab87		48897c2410		MOVQ DI, 0x10(SP)		
  0x42ab8c		488b1d05ce0700		MOVQ runtime.sched+120(SB), BX	
  0x42ab93		4885db			TESTQ BX, BX			
  0x42ab96		741a			JE 0x42abb2			
		lock(&sched.gflock)
  0x42ab98		488d05f1cd0700		LEAQ runtime.sched+112(SB), AX	
  0x42ab9f		48890424		MOVQ AX, 0(SP)			
  0x42aba3		e878e9fdff		CALL runtime.lock(SB)		
  0x42aba8		488b442438		MOVQ 0x38(SP), AX		
		for _p_.gfreecnt < 32 {
  0x42abad		e9d4feffff		JMP 0x42aa86		
	if gp == nil && (sched.gfreeStack != nil || sched.gfreeNoStack != nil) {
  0x42abb2		488b1de7cd0700		MOVQ runtime.sched+128(SB), BX	
  0x42abb9		4885db			TESTQ BX, BX			
  0x42abbc		75da			JNE 0x42ab98			
  0x42abbe		4885d2			TESTQ DX, DX			
	if gp != nil {
  0x42abc1		7427			JE 0x42abea		
		_p_.gfree = gp.schedlink.ptr()
  0x42abc3		8b1d478e0900		MOVL runtime.writeBarrier(SB), BX	
  0x42abc9		488b82b8000000		MOVQ 0xb8(DX), AX			
  0x42abd0		85db			TESTL BX, BX				
  0x42abd2		755d			JNE 0x42ac31				
  0x42abd4		488981f00d0000		MOVQ AX, 0xdf0(CX)			
		_p_.gfreecnt--
  0x42abdb		8381f80d0000ff		ADDL $-0x1, 0xdf8(CX)	
		if gp.stack.lo == 0 {
  0x42abe2		488b02			MOVQ 0(DX), AX		
  0x42abe5		4885c0			TESTQ AX, AX		
  0x42abe8		740f			JE 0x42abf9		
	return gp
  0x42abea		4889542440		MOVQ DX, 0x40(SP)	
  0x42abef		488b6c2428		MOVQ 0x28(SP), BP	
  0x42abf4		4883c430		ADDQ $0x30, SP		
  0x42abf8		c3			RET			
  0x42abf9		4889542408		MOVQ DX, 0x8(SP)	
			systemstack(func() {
  0x42abfe		488d053b8f0100		LEAQ runtime.gfget.func1(SB), AX	
  0x42ac05		4889442418		MOVQ AX, 0x18(SP)			
  0x42ac0a		4889542420		MOVQ DX, 0x20(SP)			
  0x42ac0f		488d442418		LEAQ 0x18(SP), AX			
  0x42ac14		48890424		MOVQ AX, 0(SP)				
  0x42ac18		e803980100		CALL runtime.systemstack(SB)		
		if gp.stack.lo == 0 {
  0x42ac1d		488b542408		MOVQ 0x8(SP), DX	
			gp.stackguard0 = gp.stack.lo + _StackGuard
  0x42ac22		488b02			MOVQ 0(DX), AX		
  0x42ac25		480570030000		ADDQ $0x370, AX		
  0x42ac2b		48894210		MOVQ AX, 0x10(DX)	
  0x42ac2f		ebb9			JMP 0x42abea		
		_p_.gfree = gp.schedlink.ptr()
  0x42ac31		e86abc0100		CALL runtime.gcWriteBarrier(SB)	
  0x42ac36		eba3			JMP 0x42abdb			
func gfget(_p_ *p) *g {
  0x42ac38		e833990100		CALL runtime.morestack_noctxt(SB)	
  0x42ac3d		e91efeffff		JMP runtime.gfget(SB)			

TEXT runtime.gfpurge(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gfpurge(_p_ *p) {
  0x42ac50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ac59		483b6110		CMPQ 0x10(CX), SP	
  0x42ac5d		0f8624010000		JBE 0x42ad87		
  0x42ac63		4883ec10		SUBQ $0x10, SP		
  0x42ac67		48896c2408		MOVQ BP, 0x8(SP)	
  0x42ac6c		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&sched.gflock)
  0x42ac71		488d0518cd0700		LEAQ runtime.sched+112(SB), AX	
  0x42ac78		48890424		MOVQ AX, 0(SP)			
  0x42ac7c		e89fe8fdff		CALL runtime.lock(SB)		
func gfpurge(_p_ *p) {
  0x42ac81		488b442418		MOVQ 0x18(SP), AX	
	for _p_.gfreecnt != 0 {
  0x42ac86		eb06			JMP 0x42ac8e		
		sched.ngfree++
  0x42ac88		ff051acd0700		INCL runtime.sched+136(SB)	
	for _p_.gfreecnt != 0 {
  0x42ac8e		8b88f80d0000		MOVL 0xdf8(AX), CX	
  0x42ac94		85c9			TESTL CX, CX		
  0x42ac96		0f84d1000000		JE 0x42ad6d		
		_p_.gfreecnt--
  0x42ac9c		ffc9			DECL CX			
  0x42ac9e		8988f80d0000		MOVL CX, 0xdf8(AX)	
		gp := _p_.gfree
  0x42aca4		488b88f00d0000		MOVQ 0xdf0(AX), CX	
  0x42acab		488db8f00d0000		LEAQ 0xdf0(AX), DI	
		_p_.gfree = gp.schedlink.ptr()
  0x42acb2		8b15588d0900		MOVL runtime.writeBarrier(SB), DX	
  0x42acb8		488b99b8000000		MOVQ 0xb8(CX), BX			
  0x42acbf		488db1b8000000		LEAQ 0xb8(CX), SI			
  0x42acc6		85d2			TESTL DX, DX				
  0x42acc8		0f858c000000		JNE 0x42ad5a				
  0x42acce		488998f00d0000		MOVQ BX, 0xdf0(AX)			
		if gp.stack.lo == 0 {
  0x42acd5		488b11			MOVQ 0(CX), DX		
  0x42acd8		4885d2			TESTQ DX, DX		
  0x42acdb		753d			JNE 0x42ad1a		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42acdd		8406			TESTB AL, 0(SI)		
			gp.schedlink.set(sched.gfreeNoStack)
  0x42acdf		488b15bacc0700		MOVQ runtime.sched+128(SB), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42ace6		488991b8000000		MOVQ DX, 0xb8(CX)	
			sched.gfreeNoStack = gp
  0x42aced		8b151d8d0900		MOVL runtime.writeBarrier(SB), DX	
  0x42acf3		85d2			TESTL DX, DX				
  0x42acf5		7509			JNE 0x42ad00				
  0x42acf7		48890da2cc0700		MOVQ CX, runtime.sched+128(SB)		
  0x42acfe		eb88			JMP 0x42ac88				
  0x42ad00		488d3d99cc0700		LEAQ runtime.sched+128(SB), DI		
  0x42ad07		4889c2			MOVQ AX, DX				
  0x42ad0a		4889c8			MOVQ CX, AX				
  0x42ad0d		e88ebb0100		CALL runtime.gcWriteBarrier(SB)		
  0x42ad12		4889d0			MOVQ DX, AX				
  0x42ad15		e96effffff		JMP 0x42ac88				
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42ad1a		8406			TESTB AL, 0(SI)		
			gp.schedlink.set(sched.gfreeStack)
  0x42ad1c		488b1575cc0700		MOVQ runtime.sched+120(SB), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42ad23		488991b8000000		MOVQ DX, 0xb8(CX)	
			sched.gfreeStack = gp
  0x42ad2a		8b15e08c0900		MOVL runtime.writeBarrier(SB), DX	
  0x42ad30		85d2			TESTL DX, DX				
  0x42ad32		750c			JNE 0x42ad40				
  0x42ad34		48890d5dcc0700		MOVQ CX, runtime.sched+120(SB)		
  0x42ad3b		e948ffffff		JMP 0x42ac88				
  0x42ad40		488d3d51cc0700		LEAQ runtime.sched+120(SB), DI		
  0x42ad47		4889c2			MOVQ AX, DX				
  0x42ad4a		4889c8			MOVQ CX, AX				
  0x42ad4d		e84ebb0100		CALL runtime.gcWriteBarrier(SB)		
  0x42ad52		4889d0			MOVQ DX, AX				
  0x42ad55		e92effffff		JMP 0x42ac88				
  0x42ad5a		4889c2			MOVQ AX, DX				
  0x42ad5d		4889d8			MOVQ BX, AX				
		_p_.gfree = gp.schedlink.ptr()
  0x42ad60		e83bbb0100		CALL runtime.gcWriteBarrier(SB)	
  0x42ad65		4889d0			MOVQ DX, AX			
  0x42ad68		e968ffffff		JMP 0x42acd5			
	unlock(&sched.gflock)
  0x42ad6d		488d051ccc0700		LEAQ runtime.sched+112(SB), AX	
  0x42ad74		48890424		MOVQ AX, 0(SP)			
  0x42ad78		e843e9fdff		CALL runtime.unlock(SB)		
}
  0x42ad7d		488b6c2408		MOVQ 0x8(SP), BP	
  0x42ad82		4883c410		ADDQ $0x10, SP		
  0x42ad86		c3			RET			
func gfpurge(_p_ *p) {
  0x42ad87		e8e4970100		CALL runtime.morestack_noctxt(SB)	
  0x42ad8c		e9bffeffff		JMP runtime.gfpurge(SB)			

TEXT runtime.unlockOSThread(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func unlockOSThread() {
  0x42ada0		4883ec18		SUBQ $0x18, SP		
  0x42ada4		48896c2410		MOVQ BP, 0x10(SP)	
  0x42ada9		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x42adae		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.lockedInt == 0 {
  0x42adb7		488b4830		MOVQ 0x30(AX), CX	
  0x42adbb		8b89f8020000		MOVL 0x2f8(CX), CX	
  0x42adc1		85c9			TESTL CX, CX		
  0x42adc3		744e			JE 0x42ae13		
	_g_.m.lockedInt--
  0x42adc5		488b4030		MOVQ 0x30(AX), AX	
  0x42adc9		8380f8020000ff		ADDL $-0x1, 0x2f8(AX)	
	_g_ := getg()
  0x42add0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.lockedInt != 0 || _g_.m.lockedExt != 0 {
  0x42add9		488b4830		MOVQ 0x30(AX), CX	
  0x42addd		8b91f8020000		MOVL 0x2f8(CX), DX	
  0x42ade3		85d2			TESTL DX, DX		
  0x42ade5		740a			JE 0x42adf1		
  0x42ade7		488b6c2410		MOVQ 0x10(SP), BP	
  0x42adec		4883c418		ADDQ $0x18, SP		
  0x42adf0		c3			RET			
  0x42adf1		8b91f4020000		MOVL 0x2f4(CX), DX	
  0x42adf7		85d2			TESTL DX, DX		
  0x42adf9		75ec			JNE 0x42ade7		
	_g_.m.lockedg = 0
  0x42adfb		48c7816801000000000000	MOVQ $0x0, 0x168(CX)	
	_g_.lockedm = 0
  0x42ae06		48c780e000000000000000	MOVQ $0x0, 0xe0(AX)	
	dounlockOSThread()
  0x42ae11		ebd4			JMP 0x42ade7		
  0x42ae13		4889442408		MOVQ AX, 0x8(SP)	
		systemstack(badunlockosthread)
  0x42ae18		488d0589310400		LEAQ 0x43189(IP), AX		
  0x42ae1f		48890424		MOVQ AX, 0(SP)			
  0x42ae23		e8f8950100		CALL runtime.systemstack(SB)	
  0x42ae28		488b442408		MOVQ 0x8(SP), AX		
  0x42ae2d		eb96			JMP 0x42adc5			

TEXT runtime.badunlockosthread(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func badunlockosthread() {
  0x42ae30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ae39		483b6110		CMPQ 0x10(CX), SP	
  0x42ae3d		7629			JBE 0x42ae68		
  0x42ae3f		4883ec18		SUBQ $0x18, SP		
  0x42ae43		48896c2410		MOVQ BP, 0x10(SP)	
  0x42ae48		488d6c2410		LEAQ 0x10(SP), BP	
	throw("runtime: internal error: misuse of lockOSThread/unlockOSThread")
  0x42ae4d		488d05e42f0400		LEAQ 0x42fe4(IP), AX	
  0x42ae54		48890424		MOVQ AX, 0(SP)		
  0x42ae58		48c74424083e000000	MOVQ $0x3e, 0x8(SP)	
  0x42ae61		e86a63ffff		CALL runtime.throw(SB)	
  0x42ae66		0f0b			UD2			
func badunlockosthread() {
  0x42ae68		e803970100		CALL runtime.morestack_noctxt(SB)	
  0x42ae6d		ebc1			JMP runtime.badunlockosthread(SB)	

TEXT runtime._System(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func _System()                    { _System() }
  0x42ae70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42ae79		483b6110		CMPQ 0x10(CX), SP			
  0x42ae7d		761a			JBE 0x42ae99				
  0x42ae7f		4883ec08		SUBQ $0x8, SP				
  0x42ae83		48892c24		MOVQ BP, 0(SP)				
  0x42ae87		488d2c24		LEAQ 0(SP), BP				
  0x42ae8b		e8e0ffffff		CALL runtime._System(SB)		
  0x42ae90		488b2c24		MOVQ 0(SP), BP				
  0x42ae94		4883c408		ADDQ $0x8, SP				
  0x42ae98		c3			RET					
  0x42ae99		e8d2960100		CALL runtime.morestack_noctxt(SB)	
  0x42ae9e		ebd0			JMP runtime._System(SB)			

TEXT runtime._ExternalCode(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func _ExternalCode()              { _ExternalCode() }
  0x42aea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42aea9		483b6110		CMPQ 0x10(CX), SP			
  0x42aead		761a			JBE 0x42aec9				
  0x42aeaf		4883ec08		SUBQ $0x8, SP				
  0x42aeb3		48892c24		MOVQ BP, 0(SP)				
  0x42aeb7		488d2c24		LEAQ 0(SP), BP				
  0x42aebb		e8e0ffffff		CALL runtime._ExternalCode(SB)		
  0x42aec0		488b2c24		MOVQ 0(SP), BP				
  0x42aec4		4883c408		ADDQ $0x8, SP				
  0x42aec8		c3			RET					
  0x42aec9		e8a2960100		CALL runtime.morestack_noctxt(SB)	
  0x42aece		ebd0			JMP runtime._ExternalCode(SB)		

TEXT runtime._LostExternalCode(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func _LostExternalCode()          { _LostExternalCode() }
  0x42aed0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42aed9		483b6110		CMPQ 0x10(CX), SP			
  0x42aedd		761a			JBE 0x42aef9				
  0x42aedf		4883ec08		SUBQ $0x8, SP				
  0x42aee3		48892c24		MOVQ BP, 0(SP)				
  0x42aee7		488d2c24		LEAQ 0(SP), BP				
  0x42aeeb		e8e0ffffff		CALL runtime._LostExternalCode(SB)	
  0x42aef0		488b2c24		MOVQ 0(SP), BP				
  0x42aef4		4883c408		ADDQ $0x8, SP				
  0x42aef8		c3			RET					
  0x42aef9		e872960100		CALL runtime.morestack_noctxt(SB)	
  0x42aefe		ebd0			JMP runtime._LostExternalCode(SB)	

TEXT runtime._GC(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func _GC()                        { _GC() }
  0x42af00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42af09		483b6110		CMPQ 0x10(CX), SP			
  0x42af0d		761a			JBE 0x42af29				
  0x42af0f		4883ec08		SUBQ $0x8, SP				
  0x42af13		48892c24		MOVQ BP, 0(SP)				
  0x42af17		488d2c24		LEAQ 0(SP), BP				
  0x42af1b		e8e0ffffff		CALL runtime._GC(SB)			
  0x42af20		488b2c24		MOVQ 0(SP), BP				
  0x42af24		4883c408		ADDQ $0x8, SP				
  0x42af28		c3			RET					
  0x42af29		e842960100		CALL runtime.morestack_noctxt(SB)	
  0x42af2e		ebd0			JMP runtime._GC(SB)			

TEXT runtime.sigprof(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {
  0x42af30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42af39		488d8424e8fdffff	LEAQ 0xfffffde8(SP), AX	
  0x42af41		483b4110		CMPQ 0x10(CX), AX	
  0x42af45		0f866d040000		JBE 0x42b3b8		
  0x42af4b		4881ec98020000		SUBQ $0x298, SP		
  0x42af52		4889ac2490020000	MOVQ BP, 0x290(SP)	
  0x42af5a		488dac2490020000	LEAQ 0x290(SP), BP	
  0x42af62		0f57c0			XORPS X0, X0		
  0x42af65		0f11842460020000	MOVUPS X0, 0x260(SP)	
  0x42af6d		0f11842470020000	MOVUPS X0, 0x270(SP)	
  0x42af75		0f11842480020000	MOVUPS X0, 0x280(SP)	
	if prof.hz == 0 {
  0x42af7d		8b05318a0900		MOVL runtime.prof+4(SB), AX	
  0x42af83		85c0			TESTL AX, AX			
  0x42af85		0f8408040000		JE 0x42b393			
	getg().m.mallocing++
  0x42af8b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42af94		488b4030		MOVQ 0x30(AX), AX	
  0x42af98		ff80e8000000		INCL 0xe8(AX)		
  0x42af9e		488b8424b8020000	MOVQ 0x2b8(SP), AX	
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) {
  0x42afa6		4885c0			TESTQ AX, AX		
  0x42afa9		0f84d7030000		JE 0x42b386		
  0x42afaf		488b08			MOVQ 0(AX), CX		
  0x42afb2		488b9424a8020000	MOVQ 0x2a8(SP), DX	
  0x42afba		4839ca			CMPQ CX, DX		
  0x42afbd		0f836d030000		JAE 0x42b330		
  0x42afc3		31c9			XORL CX, CX		
	var stk [maxCPUProfStack]uintptr
  0x42afc5		488d7c2460		LEAQ 0x60(SP), DI	
  0x42afca		0f57c0			XORPS X0, X0		
  0x42afcd		48896c24f0		MOVQ BP, -0x10(SP)	
  0x42afd2		488d6c24f0		LEAQ -0x10(SP), BP	
  0x42afd7		e85cba0100		CALL 0x446a38		
  0x42afdc		488b6d00		MOVQ 0(BP), BP		
  0x42afe0		488b9c24c0020000	MOVQ 0x2c0(SP), BX	
	if mp.ncgo > 0 && mp.curg != nil && mp.curg.syscallpc != 0 && mp.curg.syscallsp != 0 {
  0x42afe8		8bb338010000		MOVL 0x138(BX), SI	
  0x42afee		85f6			TESTL SI, SI		
  0x42aff0		0f8ec3020000		JLE 0x42b2b9		
  0x42aff6		488bb3c0000000		MOVQ 0xc0(BX), SI	
  0x42affd		4885f6			TESTQ SI, SI		
  0x42b000		0f84b3020000		JE 0x42b2b9		
  0x42b006		488b7e78		MOVQ 0x78(SI), DI	
  0x42b00a		4885ff			TESTQ DI, DI		
  0x42b00d		0f84a6020000		JE 0x42b2b9		
  0x42b013		488b7670		MOVQ 0x70(SI), SI	
  0x42b017		4885f6			TESTQ SI, SI		
  0x42b01a		0f8499020000		JE 0x42b2b9		
		if atomic.Load(&mp.cgoCallersUse) == 0 && mp.cgoCallers != nil && mp.cgoCallers[0] != 0 {
  0x42b020		8b8b3c010000		MOVL 0x13c(BX), CX	
  0x42b026		85c9			TESTL CX, CX		
  0x42b028		0f8581020000		JNE 0x42b2af		
  0x42b02e		488b8b40010000		MOVQ 0x140(BX), CX	
  0x42b035		4885c9			TESTQ CX, CX		
  0x42b038		0f8471020000		JE 0x42b2af		
  0x42b03e		488b11			MOVQ 0(CX), DX		
  0x42b041		4885d2			TESTQ DX, DX		
  0x42b044		0f8465020000		JE 0x42b2af		
  0x42b04a		31d2			XORL DX, DX		
			for cgoOff < len(mp.cgoCallers) && mp.cgoCallers[cgoOff] != 0 {
  0x42b04c		eb03			JMP 0x42b051		
				cgoOff++
  0x42b04e		48ffc2			INCQ DX			
			for cgoOff < len(mp.cgoCallers) && mp.cgoCallers[cgoOff] != 0 {
  0x42b051		4883fa20		CMPQ $0x20, DX		
  0x42b055		7d0d			JGE 0x42b064		
  0x42b057		488b34d1		MOVQ 0(CX)(DX*8), SI	
  0x42b05b		4885f6			TESTQ SI, SI		
  0x42b05e		75ee			JNE 0x42b04e		
  0x42b060		4883fa20		CMPQ $0x20, DX		
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42b064		0f8747030000		JA 0x42b3b1			
  0x42b06a		4889542458		MOVQ DX, 0x58(SP)		
  0x42b06f		4883fa40		CMPQ $0x40, DX			
  0x42b073		0f8d2c020000		JGE 0x42b2a5			
  0x42b079		488d442460		LEAQ 0x60(SP), AX		
  0x42b07e		48890424		MOVQ AX, 0(SP)			
  0x42b082		48894c2408		MOVQ CX, 0x8(SP)		
  0x42b087		48c1e203		SHLQ $0x3, DX			
  0x42b08b		4889542410		MOVQ DX, 0x10(SP)		
  0x42b090		e86bc00100		CALL runtime.memmove(SB)	
  0x42b095		488b8424c0020000	MOVQ 0x2c0(SP), AX		
			mp.cgoCallers[0] = 0
  0x42b09d		488b8840010000		MOVQ 0x140(AX), CX	
  0x42b0a4		48c70100000000		MOVQ $0x0, 0(CX)	
  0x42b0ab		488b4c2458		MOVQ 0x58(SP), CX	
		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)
  0x42b0b0		488b90c0000000		MOVQ 0xc0(AX), DX		
  0x42b0b7		488b5a78		MOVQ 0x78(DX), BX		
  0x42b0bb		488b7270		MOVQ 0x70(DX), SI		
  0x42b0bf		4883f940		CMPQ $0x40, CX			
  0x42b0c3		0f83e1020000		JAE 0x42b3aa			
  0x42b0c9		488d44cc60		LEAQ 0x60(SP)(CX*8), AX		
  0x42b0ce		4889442428		MOVQ AX, 0x28(SP)		
  0x42b0d3		48891c24		MOVQ BX, 0(SP)			
  0x42b0d7		4889742408		MOVQ SI, 0x8(SP)		
  0x42b0dc		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42b0e5		4889542418		MOVQ DX, 0x18(SP)		
  0x42b0ea		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x42b0f3		488d41c0		LEAQ -0x40(CX), AX		
  0x42b0f7		48f7d8			NEGQ AX				
  0x42b0fa		4889442430		MOVQ AX, 0x30(SP)		
  0x42b0ff		0f57c0			XORPS X0, X0			
  0x42b102		0f11442438		MOVUPS X0, 0x38(SP)		
  0x42b107		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x42b110		e81b020100		CALL runtime.gentraceback(SB)	
  0x42b115		488b442450		MOVQ 0x50(SP), AX		
	if n <= 0 {
  0x42b11a		4885c0			TESTQ AX, AX		
  0x42b11d		0f8fb1000000		JG 0x42b1d4		
			if pc > firstmoduledata.etext {
  0x42b123		488b057ea70700		MOVQ runtime.firstmoduledata+104(SB), AX	
  0x42b12a		488b8c24a0020000	MOVQ 0x2a0(SP), CX				
  0x42b132		4839c1			CMPQ AX, CX					
  0x42b135		0f8651010000		JBE 0x42b28c					
				pc = funcPC(_ExternalCode) + sys.PCQuantum
  0x42b13b		488d059eb50200		LEAQ 0x2b59e(IP), AX	
  0x42b142		4889842460020000	MOVQ AX, 0x260(SP)	
  0x42b14a		488d0d0f2e0400		LEAQ 0x42e0f(IP), CX	
  0x42b151		48898c2468020000	MOVQ CX, 0x268(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42b159		b908000000		MOVL $0x8, CX		
  0x42b15e		488d942460020000	LEAQ 0x260(SP), DX	
  0x42b166		488b140a		MOVQ 0(DX)(CX*1), DX	
  0x42b16a		488d9c2468020000	LEAQ 0x268(SP), BX	
  0x42b172		8403			TESTB AL, 0(BX)		
  0x42b174		488b12			MOVQ 0(DX), DX		
				pc = funcPC(_ExternalCode) + sys.PCQuantum
  0x42b177		48ffc2			INCQ DX			
			stk[0] = pc
  0x42b17a		4889542460		MOVQ DX, 0x60(SP)	
  0x42b17f		488b9424c0020000	MOVQ 0x2c0(SP), DX	
			if mp.preemptoff != "" || mp.helpgc != 0 {
  0x42b187		488b9af8000000		MOVQ 0xf8(DX), BX	
  0x42b18e		4885db			TESTQ BX, BX		
  0x42b191		0f84aa000000		JE 0x42b241		
				stk[1] = funcPC(_GC) + sys.PCQuantum
  0x42b197		4889842480020000	MOVQ AX, 0x280(SP)	
  0x42b19f		488d05c22d0400		LEAQ 0x42dc2(IP), AX	
  0x42b1a6		4889842488020000	MOVQ AX, 0x288(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42b1ae		488d842480020000	LEAQ 0x280(SP), AX	
  0x42b1b6		488b0408		MOVQ 0(AX)(CX*1), AX	
  0x42b1ba		488d8c2488020000	LEAQ 0x288(SP), CX	
  0x42b1c2		8401			TESTB AL, 0(CX)		
  0x42b1c4		488b00			MOVQ 0(AX), AX		
				stk[1] = funcPC(_GC) + sys.PCQuantum
  0x42b1c7		48ffc0			INCQ AX			
  0x42b1ca		4889442468		MOVQ AX, 0x68(SP)	
  0x42b1cf		b802000000		MOVL $0x2, AX		
	if prof.hz != 0 {
  0x42b1d4		8b0dda870900		MOVL runtime.prof+4(SB), CX	
  0x42b1da		85c9			TESTL CX, CX			
  0x42b1dc		743f			JE 0x42b21d			
		cpuprof.add(gp, stk[:n])
  0x42b1de		4883f840		CMPQ $0x40, AX				
  0x42b1e2		0f87bb010000		JA 0x42b3a3				
  0x42b1e8		488d0d31d10700		LEAQ runtime.cpuprof(SB), CX		
  0x42b1ef		48890c24		MOVQ CX, 0(SP)				
  0x42b1f3		488b8c24b8020000	MOVQ 0x2b8(SP), CX			
  0x42b1fb		48894c2408		MOVQ CX, 0x8(SP)			
  0x42b200		488d4c2460		LEAQ 0x60(SP), CX			
  0x42b205		48894c2410		MOVQ CX, 0x10(SP)			
  0x42b20a		4889442418		MOVQ AX, 0x18(SP)			
  0x42b20f		48c744242040000000	MOVQ $0x40, 0x20(SP)			
  0x42b218		e8c393fdff		CALL runtime.(*cpuProfile).add(SB)	
	getg().m.mallocing--
  0x42b21d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42b226		488b4030		MOVQ 0x30(AX), AX	
  0x42b22a		8380e8000000ff		ADDL $-0x1, 0xe8(AX)	
}
  0x42b231		488bac2490020000	MOVQ 0x290(SP), BP	
  0x42b239		4881c498020000		ADDQ $0x298, SP		
  0x42b240		c3			RET			
			if mp.preemptoff != "" || mp.helpgc != 0 {
  0x42b241		8b9210010000		MOVL 0x110(DX), DX	
  0x42b247		85d2			TESTL DX, DX		
  0x42b249		0f8548ffffff		JNE 0x42b197		
				stk[1] = funcPC(_System) + sys.PCQuantum
  0x42b24f		4889842470020000	MOVQ AX, 0x270(SP)	
  0x42b257		488d051a2d0400		LEAQ 0x42d1a(IP), AX	
  0x42b25e		4889842478020000	MOVQ AX, 0x278(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42b266		488d842470020000	LEAQ 0x270(SP), AX	
  0x42b26e		488b0408		MOVQ 0(AX)(CX*1), AX	
  0x42b272		488d8c2478020000	LEAQ 0x278(SP), CX	
  0x42b27a		8401			TESTB AL, 0(CX)		
  0x42b27c		488b00			MOVQ 0(AX), AX		
				stk[1] = funcPC(_System) + sys.PCQuantum
  0x42b27f		48ffc0			INCQ AX			
  0x42b282		4889442468		MOVQ AX, 0x68(SP)	
  0x42b287		e943ffffff		JMP 0x42b1cf		
  0x42b28c		488d054db40200		LEAQ 0x2b44d(IP), AX	
  0x42b293		b908000000		MOVL $0x8, CX		
  0x42b298		488b9424a0020000	MOVQ 0x2a0(SP), DX	
			if pc > firstmoduledata.etext {
  0x42b2a0		e9d5feffff		JMP 0x42b17a		
  0x42b2a5		ba40000000		MOVL $0x40, DX		
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42b2aa		e9cafdffff		JMP 0x42b079		
  0x42b2af		4889d8			MOVQ BX, AX		
  0x42b2b2		31c9			XORL CX, CX		
		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)
  0x42b2b4		e9f7fdffff		JMP 0x42b0b0		
	} else if traceback {
  0x42b2b9		84c9			TESTL CL, CL		
  0x42b2bb		750a			JNE 0x42b2c7		
  0x42b2bd		31c9			XORL CX, CX		
  0x42b2bf		4889c8			MOVQ CX, AX		
	if n <= 0 {
  0x42b2c2		e953feffff		JMP 0x42b11a		
		n = gentraceback(pc, sp, lr, gp, 0, &stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)
  0x42b2c7		488d4c2460		LEAQ 0x60(SP), CX		
  0x42b2cc		48894c2428		MOVQ CX, 0x28(SP)		
  0x42b2d1		488b8c24a0020000	MOVQ 0x2a0(SP), CX		
  0x42b2d9		48890c24		MOVQ CX, 0(SP)			
  0x42b2dd		4889542408		MOVQ DX, 0x8(SP)		
  0x42b2e2		488b9424b0020000	MOVQ 0x2b0(SP), DX		
  0x42b2ea		4889542410		MOVQ DX, 0x10(SP)		
  0x42b2ef		4889442418		MOVQ AX, 0x18(SP)		
  0x42b2f4		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x42b2fd		48c744243040000000	MOVQ $0x40, 0x30(SP)		
  0x42b306		0f11442438		MOVUPS X0, 0x38(SP)		
  0x42b30b		48c744244806000000	MOVQ $0x6, 0x48(SP)		
  0x42b314		e817000100		CALL runtime.gentraceback(SB)	
  0x42b319		488b4c2450		MOVQ 0x50(SP), CX		
  0x42b31e		488b8424b8020000	MOVQ 0x2b8(SP), AX		
  0x42b326		488b9c24c0020000	MOVQ 0x2c0(SP), BX		
  0x42b32e		eb8f			JMP 0x42b2bf			
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) {
  0x42b330		488b4808		MOVQ 0x8(AX), CX	
  0x42b334		4839d1			CMPQ DX, CX		
  0x42b337		0f8286fcffff		JB 0x42afc3		
  0x42b33d		488b8424a0020000	MOVQ 0x2a0(SP), AX	
  0x42b345		48890424		MOVQ AX, 0(SP)		
  0x42b349		e8b2010000		CALL runtime.setsSP(SB)	
  0x42b34e		0fb6442408		MOVZX 0x8(SP), AX	
  0x42b353		84c0			TESTL AL, AL		
  0x42b355		7415			JE 0x42b36c		
  0x42b357		488b8424b8020000	MOVQ 0x2b8(SP), AX	
  0x42b35f		488b9424a8020000	MOVQ 0x2a8(SP), DX	
  0x42b367		e957fcffff		JMP 0x42afc3		
  0x42b36c		488b8424b8020000	MOVQ 0x2b8(SP), AX	
  0x42b374		488b9424a8020000	MOVQ 0x2a8(SP), DX	
  0x42b37c		b901000000		MOVL $0x1, CX		
	var stk [maxCPUProfStack]uintptr
  0x42b381		e93ffcffff		JMP 0x42afc5		
  0x42b386		488b9424a8020000	MOVQ 0x2a8(SP), DX	
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) {
  0x42b38e		e930fcffff		JMP 0x42afc3		
		return
  0x42b393		488bac2490020000	MOVQ 0x290(SP), BP	
  0x42b39b		4881c498020000		ADDQ $0x298, SP		
  0x42b3a2		c3			RET			
		cpuprof.add(gp, stk[:n])
  0x42b3a3		e80847ffff		CALL runtime.panicslice(SB)	
  0x42b3a8		0f0b			UD2				
		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)
  0x42b3aa		e89146ffff		CALL runtime.panicindex(SB)	
  0x42b3af		0f0b			UD2				
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42b3b1		e8fa46ffff		CALL runtime.panicslice(SB)	
  0x42b3b6		0f0b			UD2				
func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {
  0x42b3b8		e8b3910100		CALL runtime.morestack_noctxt(SB)	
  0x42b3bd		e96efbffff		JMP runtime.sigprof(SB)			

TEXT runtime.sigprofNonGo(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func sigprofNonGo() {
  0x42b3d0		4883ec28		SUBQ $0x28, SP		
  0x42b3d4		48896c2420		MOVQ BP, 0x20(SP)	
  0x42b3d9		488d6c2420		LEAQ 0x20(SP), BP	
	if prof.hz != 0 {
  0x42b3de		8b05d0850900		MOVL runtime.prof+4(SB), AX	
  0x42b3e4		85c0			TESTL AX, AX			
  0x42b3e6		7446			JE 0x42b42e			
  0x42b3e8		31c0			XORL AX, AX			
		for n < len(sigprofCallers) && sigprofCallers[n] != 0 {
  0x42b3ea		eb03			JMP 0x42b3ef		
			n++
  0x42b3ec		48ffc0			INCQ AX			
		for n < len(sigprofCallers) && sigprofCallers[n] != 0 {
  0x42b3ef		4883f820		CMPQ $0x20, AX				
  0x42b3f3		7d4e			JGE 0x42b443				
  0x42b3f5		488d0dc4880900		LEAQ runtime.sigprofCallers(SB), CX	
  0x42b3fc		488b14c1		MOVQ 0(CX)(AX*8), DX			
  0x42b400		4885d2			TESTQ DX, DX				
  0x42b403		75e7			JNE 0x42b3ec				
  0x42b405		4883f820		CMPQ $0x20, AX				
		cpuprof.addNonGo(sigprofCallers[:n])
  0x42b409		7741			JA 0x42b44c				
  0x42b40b		488d150ecf0700		LEAQ runtime.cpuprof(SB), DX		
  0x42b412		48891424		MOVQ DX, 0(SP)				
  0x42b416		48894c2408		MOVQ CX, 0x8(SP)			
  0x42b41b		4889442410		MOVQ AX, 0x10(SP)			
  0x42b420		48c744241820000000	MOVQ $0x20, 0x18(SP)			
  0x42b429		e8e292fdff		CALL runtime.(*cpuProfile).addNonGo(SB)	
	atomic.Store(&sigprofCallersUse, 0)
  0x42b42e		31c0			XORL AX, AX				
  0x42b430		488d0dc9840900		LEAQ runtime.sigprofCallersUse(SB), CX	
  0x42b437		8701			XCHGL AX, 0(CX)				
}
  0x42b439		488b6c2420		MOVQ 0x20(SP), BP			
  0x42b43e		4883c428		ADDQ $0x28, SP				
  0x42b442		c3			RET					
  0x42b443		488d0d76880900		LEAQ runtime.sigprofCallers(SB), CX	
		for n < len(sigprofCallers) && sigprofCallers[n] != 0 {
  0x42b44a		ebbd			JMP 0x42b409		
		cpuprof.addNonGo(sigprofCallers[:n])
  0x42b44c		e85f46ffff		CALL runtime.panicslice(SB)	
  0x42b451		0f0b			UD2				

TEXT runtime.sigprofNonGoPC(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func sigprofNonGoPC(pc uintptr) {
  0x42b460		4883ec48		SUBQ $0x48, SP		
  0x42b464		48896c2440		MOVQ BP, 0x40(SP)	
  0x42b469		488d6c2440		LEAQ 0x40(SP), BP	
	if prof.hz != 0 {
  0x42b46e		8b0540850900		MOVL runtime.prof+4(SB), AX	
  0x42b474		85c0			TESTL AX, AX			
  0x42b476		750a			JNE 0x42b482			
  0x42b478		488b6c2440		MOVQ 0x40(SP), BP		
  0x42b47d		4883c448		ADDQ $0x48, SP			
  0x42b481		c3			RET				
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x42b482		488d0557b20200		LEAQ 0x2b257(IP), AX	
  0x42b489		4889442430		MOVQ AX, 0x30(SP)	
  0x42b48e		488d05cb2a0400		LEAQ 0x42acb(IP), AX	
  0x42b495		4889442438		MOVQ AX, 0x38(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42b49a		b808000000		MOVL $0x8, AX		
  0x42b49f		488d4c2430		LEAQ 0x30(SP), CX	
  0x42b4a4		488b0401		MOVQ 0(CX)(AX*1), AX	
  0x42b4a8		488d4c2438		LEAQ 0x38(SP), CX	
  0x42b4ad		8401			TESTB AL, 0(CX)		
  0x42b4af		488b00			MOVQ 0(AX), AX		
		stk := []uintptr{
  0x42b4b2		0f57c0			XORPS X0, X0		
  0x42b4b5		0f11442420		MOVUPS X0, 0x20(SP)	
  0x42b4ba		488b4c2450		MOVQ 0x50(SP), CX	
  0x42b4bf		48894c2420		MOVQ CX, 0x20(SP)	
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x42b4c4		48ffc0			INCQ AX			
  0x42b4c7		4889442428		MOVQ AX, 0x28(SP)	
		cpuprof.addNonGo(stk)
  0x42b4cc		488d054dce0700		LEAQ runtime.cpuprof(SB), AX		
  0x42b4d3		48890424		MOVQ AX, 0(SP)				
  0x42b4d7		488d442420		LEAQ 0x20(SP), AX			
  0x42b4dc		4889442408		MOVQ AX, 0x8(SP)			
  0x42b4e1		48c744241002000000	MOVQ $0x2, 0x10(SP)			
  0x42b4ea		48c744241802000000	MOVQ $0x2, 0x18(SP)			
  0x42b4f3		e81892fdff		CALL runtime.(*cpuProfile).addNonGo(SB)	
  0x42b4f8		e97bffffff		JMP 0x42b478				

TEXT runtime.setsSP(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func setsSP(pc uintptr) bool {
  0x42b500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b509		483b6110		CMPQ 0x10(CX), SP	
  0x42b50d		7668			JBE 0x42b577		
  0x42b50f		4883ec20		SUBQ $0x20, SP		
  0x42b513		48896c2418		MOVQ BP, 0x18(SP)	
  0x42b518		488d6c2418		LEAQ 0x18(SP), BP	
  0x42b51d		488b442428		MOVQ 0x28(SP), AX	
	f := findfunc(pc)
  0x42b522		48890424		MOVQ AX, 0(SP)			
  0x42b526		e8a5cc0000		CALL runtime.findfunc(SB)	
  0x42b52b		488b442408		MOVQ 0x8(SP), AX		
	return f._func != nil
  0x42b530		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x42b533		7433			JE 0x42b568		
	switch f.funcID {
  0x42b535		8b4010			MOVL 0x10(AX), AX	
	case funcID_gogo, funcID_systemstack, funcID_mcall, funcID_morestack:
  0x42b538		8d48fd			LEAL -0x3(AX), CX	
  0x42b53b		83f901			CMPL $0x1, CX		
  0x42b53e		770f			JA 0x42b54f		
		return true
  0x42b540		c644243001		MOVB $0x1, 0x30(SP)	
  0x42b545		488b6c2418		MOVQ 0x18(SP), BP	
  0x42b54a		4883c420		ADDQ $0x20, SP		
  0x42b54e		c3			RET			
	case funcID_gogo, funcID_systemstack, funcID_mcall, funcID_morestack:
  0x42b54f		83f80f			CMPL $0xf, AX		
  0x42b552		74ec			JE 0x42b540		
  0x42b554		83f811			CMPL $0x11, AX		
  0x42b557		74e7			JE 0x42b540		
	return false
  0x42b559		c644243000		MOVB $0x0, 0x30(SP)	
  0x42b55e		488b6c2418		MOVQ 0x18(SP), BP	
  0x42b563		4883c420		ADDQ $0x20, SP		
  0x42b567		c3			RET			
		return true
  0x42b568		c644243001		MOVB $0x1, 0x30(SP)	
  0x42b56d		488b6c2418		MOVQ 0x18(SP), BP	
  0x42b572		4883c420		ADDQ $0x20, SP		
  0x42b576		c3			RET			
func setsSP(pc uintptr) bool {
  0x42b577		e8f48f0100		CALL runtime.morestack_noctxt(SB)	
  0x42b57c		eb82			JMP runtime.setsSP(SB)			

TEXT runtime.procresize(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func procresize(nprocs int32) *p {
  0x42b580		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b589		488d4424c8		LEAQ -0x38(SP), AX	
  0x42b58e		483b4110		CMPQ 0x10(CX), AX	
  0x42b592		0f863a0a0000		JBE 0x42bfd2		
  0x42b598		4881ecb8000000		SUBQ $0xb8, SP		
  0x42b59f		4889ac24b0000000	MOVQ BP, 0xb0(SP)	
  0x42b5a7		488dac24b0000000	LEAQ 0xb0(SP), BP	
	old := gomaxprocs
  0x42b5af		8b052b830900		MOVL runtime.gomaxprocs(SB), AX	
	if old < 0 || nprocs <= 0 {
  0x42b5b5		85c0			TESTL AX, AX		
  0x42b5b7		0f8cfa090000		JL 0x42bfb7		
  0x42b5bd		8b8c24c0000000		MOVL 0xc0(SP), CX	
  0x42b5c4		85c9			TESTL CX, CX		
  0x42b5c6		0f8eeb090000		JLE 0x42bfb7		
  0x42b5cc		89442440		MOVL AX, 0x40(SP)	
	if trace.enabled {
  0x42b5d0		0fb615f9810800		MOVZX runtime.trace+16(SB), DX	
  0x42b5d7		84d2			TESTL DL, DL			
  0x42b5d9		0f857f090000		JNE 0x42bf5e			
	now := nanotime()
  0x42b5df		e84cc40100		CALL runtime.nanotime(SB)	
  0x42b5e4		488b0424		MOVQ 0(SP), AX			
	if sched.procresizetime != 0 {
  0x42b5e8		488b0d49c40700		MOVQ runtime.sched+280(SB), CX	
  0x42b5ef		4885c9			TESTQ CX, CX			
  0x42b5f2		0f845a090000		JE 0x42bf52			
  0x42b5f8		8b542440		MOVL 0x40(SP), DX		
		sched.totaltime += int64(old) * (now - sched.procresizetime)
  0x42b5fc		4863da			MOVSXD DX, BX			
  0x42b5ff		4889c6			MOVQ AX, SI			
  0x42b602		4829c8			SUBQ CX, AX			
  0x42b605		480fafd8		IMULQ AX, BX			
  0x42b609		48031d30c40700		ADDQ runtime.sched+288(SB), BX	
  0x42b610		48891d29c40700		MOVQ BX, runtime.sched+288(SB)	
	sched.procresizetime = now
  0x42b617		4889351ac40700		MOVQ SI, runtime.sched+280(SB)	
	if nprocs > int32(len(allp)) {
  0x42b61e		488b0593c00700		MOVQ runtime.allp+8(SB), AX	
  0x42b625		8b8c24c0000000		MOVL 0xc0(SP), CX		
  0x42b62c		39c1			CMPL AX, CX			
  0x42b62e		0f8f00080000		JG 0x42be34			
  0x42b634		31c0			XORL AX, AX			
	for i := int32(0); i < nprocs; i++ {
  0x42b636		eb02			JMP 0x42b63a		
  0x42b638		ffc0			INCL AX			
  0x42b63a		39c8			CMPL CX, AX		
  0x42b63c		0f8db4010000		JGE 0x42b7f6		
		pp := allp[i]
  0x42b642		488b1d67c00700		MOVQ runtime.allp(SB), BX	
  0x42b649		488b3568c00700		MOVQ runtime.allp+8(SB), SI	
  0x42b650		4863f8			MOVSXD AX, DI			
  0x42b653		4839f7			CMPQ SI, DI			
  0x42b656		0f834d090000		JAE 0x42bfa9			
  0x42b65c		8944244c		MOVL AX, 0x4c(SP)		
  0x42b660		488b1cfb		MOVQ 0(BX)(DI*8), BX		
		if pp == nil {
  0x42b664		4885db			TESTQ BX, BX		
  0x42b667		745f			JE 0x42b6c8		
		if pp.mcache == nil {
  0x42b669		488b7348		MOVQ 0x48(BX), SI	
  0x42b66d		4885f6			TESTQ SI, SI		
  0x42b670		75c6			JNE 0x42b638		
  0x42b672		48895c2470		MOVQ BX, 0x70(SP)	
	if old < 0 || nprocs <= 0 {
  0x42b677		85d2			TESTL DX, DX		
			if old == 0 && i == 0 {
  0x42b679		7527			JNE 0x42b6a2		
  0x42b67b		85c0			TESTL AX, AX		
  0x42b67d		7523			JNE 0x42b6a2		
				if getg().m.mcache == nil {
  0x42b67f		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
  0x42b688		488b7630		MOVQ 0x30(SI), SI	
  0x42b68c		488bb660010000		MOVQ 0x160(SI), SI	
  0x42b693		4885f6			TESTQ SI, SI		
  0x42b696		0f84eb080000		JE 0x42bf87		
				pp.mcache = getg().m.mcache // bootstrap
  0x42b69c		48897348		MOVQ SI, 0x48(BX)	
  0x42b6a0		eb96			JMP 0x42b638		
				pp.mcache = allocmcache()
  0x42b6a2		e8792cfeff		CALL runtime.allocmcache(SB)	
  0x42b6a7		488b0424		MOVQ 0(SP), AX			
  0x42b6ab		488b4c2470		MOVQ 0x70(SP), CX		
  0x42b6b0		48894148		MOVQ AX, 0x48(CX)		
  0x42b6b4		8b44244c		MOVL 0x4c(SP), AX		
  0x42b6b8		8b8c24c0000000		MOVL 0xc0(SP), CX		
  0x42b6bf		8b542440		MOVL 0x40(SP), DX		
  0x42b6c3		e970ffffff		JMP 0x42b638			
  0x42b6c8		48897c2468		MOVQ DI, 0x68(SP)		
			pp = new(p)
  0x42b6cd		488d05acc60300		LEAQ 0x3c6ac(IP), AX		
  0x42b6d4		48890424		MOVQ AX, 0(SP)			
  0x42b6d8		e843fafdff		CALL runtime.newobject(SB)	
  0x42b6dd		488b442408		MOVQ 0x8(SP), AX		
  0x42b6e2		8b4c244c		MOVL 0x4c(SP), CX		
			pp.id = i
  0x42b6e6		894808			MOVL CX, 0x8(AX)	
			pp.status = _Pgcstop
  0x42b6e9		c7400c03000000		MOVL $0x3, 0xc(AX)	
			pp.sudogcache = pp.sudogbuf[:0]
  0x42b6f0		48c780080e000000000000	MOVQ $0x0, 0xe08(AX)			
  0x42b6fb		48c780100e000080000000	MOVQ $0x80, 0xe10(AX)			
  0x42b706		8b1504830900		MOVL runtime.writeBarrier(SB), DX	
  0x42b70c		488db8000e0000		LEAQ 0xe00(AX), DI			
  0x42b713		488d98180e0000		LEAQ 0xe18(AX), BX			
  0x42b71a		85d2			TESTL DX, DX				
  0x42b71c		0f85c1000000		JNE 0x42b7e3				
  0x42b722		488998000e0000		MOVQ BX, 0xe00(AX)			
  0x42b729		31d2			XORL DX, DX				
			for i := range pp.deferpool {
  0x42b72b		eb04			JMP 0x42b731		
  0x42b72d		498d5001		LEAQ 0x1(R8), DX	
  0x42b731		4883fa05		CMPQ $0x5, DX		
  0x42b735		7d4b			JGE 0x42b782		
				pp.deferpool[i] = pp.deferpoolbuf[i][:0]
  0x42b737		488d1c52		LEAQ 0(DX)(DX*2), BX			
  0x42b73b		48c744d86000000000	MOVQ $0x0, 0x60(AX)(BX*8)		
  0x42b744		48c744d86820000000	MOVQ $0x20, 0x68(AX)(BX*8)		
  0x42b74d		488d7cd858		LEAQ 0x58(AX)(BX*8), DI			
  0x42b752		8b35b8820900		MOVL runtime.writeBarrier(SB), SI	
  0x42b758		4989d0			MOVQ DX, R8				
  0x42b75b		48c1e208		SHLQ $0x8, DX				
  0x42b75f		488d9410d0000000	LEAQ 0xd0(AX)(DX*1), DX			
  0x42b767		85f6			TESTL SI, SI				
  0x42b769		7507			JNE 0x42b772				
  0x42b76b		488954d858		MOVQ DX, 0x58(AX)(BX*8)			
  0x42b770		ebbb			JMP 0x42b72d				
  0x42b772		4889c3			MOVQ AX, BX				
  0x42b775		4889d0			MOVQ DX, AX				
  0x42b778		e823b10100		CALL runtime.gcWriteBarrier(SB)		
  0x42b77d		4889d8			MOVQ BX, AX				
  0x42b780		ebab			JMP 0x42b72d				
  0x42b782		4889442470		MOVQ AX, 0x70(SP)			
			pp.wbBuf.reset()
  0x42b787		488d8890120000		LEAQ 0x1290(AX), CX		
  0x42b78e		48890c24		MOVQ CX, 0(SP)			
  0x42b792		e8b92cffff		CALL runtime.(*wbBuf).reset(SB)	
			atomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))
  0x42b797		488b051abf0700		MOVQ runtime.allp+8(SB), AX	
  0x42b79e		488b0d0bbf0700		MOVQ runtime.allp(SB), CX	
  0x42b7a5		488b542468		MOVQ 0x68(SP), DX		
  0x42b7aa		4839c2			CMPQ AX, DX			
  0x42b7ad		0f83ef070000		JAE 0x42bfa2			
  0x42b7b3		488d04d1		LEAQ 0(CX)(DX*8), AX		
  0x42b7b7		48890424		MOVQ AX, 0(SP)			
  0x42b7bb		488b442470		MOVQ 0x70(SP), AX		
  0x42b7c0		4889442408		MOVQ AX, 0x8(SP)		
  0x42b7c5		e81667fdff		CALL runtime.atomicstorep(SB)	
  0x42b7ca		8b44244c		MOVL 0x4c(SP), AX		
  0x42b7ce		8b8c24c0000000		MOVL 0xc0(SP), CX		
  0x42b7d5		8b542440		MOVL 0x40(SP), DX		
  0x42b7d9		488b5c2470		MOVQ 0x70(SP), BX		
  0x42b7de		e986feffff		JMP 0x42b669			
  0x42b7e3		4889c2			MOVQ AX, DX			
  0x42b7e6		4889d8			MOVQ BX, AX			
			pp.sudogcache = pp.sudogbuf[:0]
  0x42b7e9		e8b2b00100		CALL runtime.gcWriteBarrier(SB)	
  0x42b7ee		4889d0			MOVQ DX, AX			
  0x42b7f1		e933ffffff		JMP 0x42b729			
  0x42b7f6		89c8			MOVL CX, AX			
	for i := nprocs; i < old; i++ {
  0x42b7f8		e93e020000		JMP 0x42ba3b		
	sched.runqsize++
  0x42b7fd		ff0585c10700		INCL runtime.sched+104(SB)	
		for p.runqhead != p.runqtail {
  0x42b803		8bb3e0050000		MOVL 0x5e0(BX), SI	
  0x42b809		8bbbe4050000		MOVL 0x5e4(BX), DI	
  0x42b80f		39fe			CMPL DI, SI		
  0x42b811		7454			JE 0x42b867		
			p.runqtail--
  0x42b813		8d77ff			LEAL -0x1(DI), SI	
  0x42b816		89b3e4050000		MOVL SI, 0x5e4(BX)	
			gp := p.runq[p.runqtail%uint32(len(p.runq))].ptr()
  0x42b81c		400fb6f6		MOVZX SI, SI			
  0x42b820		488bb4f3e8050000	MOVQ 0x5e8(BX)(SI*8), SI	
	gp.schedlink = sched.runqhead
  0x42b828		488b3d49c10700		MOVQ runtime.sched+88(SB), DI	
  0x42b82f		4889beb8000000		MOVQ DI, 0xb8(SI)		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b836		488d3d3bc10700		LEAQ runtime.sched+88(SB), DI	
  0x42b83d		8407			TESTB AL, 0(DI)			
  0x42b83f		4889f7			MOVQ SI, DI			
  0x42b842		4889352fc10700		MOVQ SI, runtime.sched+88(SB)	
	if sched.runqtail == 0 {
  0x42b849		488b3530c10700		MOVQ runtime.sched+96(SB), SI	
  0x42b850		4885f6			TESTQ SI, SI			
  0x42b853		75a8			JNE 0x42b7fd			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b855		488d3524c10700		LEAQ runtime.sched+96(SB), SI	
  0x42b85c		8406			TESTB AL, 0(SI)			
  0x42b85e		48893d1bc10700		MOVQ DI, runtime.sched+96(SB)	
	sched.runqsize++
  0x42b865		eb96			JMP 0x42b7fd		
		if p.runnext != 0 {
  0x42b867		488bb3e80d0000		MOVQ 0xde8(BX), SI	
  0x42b86e		4885f6			TESTQ SI, SI		
  0x42b871		744e			JE 0x42b8c1		
	gp.schedlink = sched.runqhead
  0x42b873		488b3dfec00700		MOVQ runtime.sched+88(SB), DI	
  0x42b87a		4889beb8000000		MOVQ DI, 0xb8(SI)		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b881		488d3df0c00700		LEAQ runtime.sched+88(SB), DI	
  0x42b888		8407			TESTB AL, 0(DI)			
  0x42b88a		4889f7			MOVQ SI, DI			
  0x42b88d		488935e4c00700		MOVQ SI, runtime.sched+88(SB)	
	if sched.runqtail == 0 {
  0x42b894		488b35e5c00700		MOVQ runtime.sched+96(SB), SI	
  0x42b89b		4885f6			TESTQ SI, SI			
  0x42b89e		7510			JNE 0x42b8b0			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b8a0		488d35d9c00700		LEAQ runtime.sched+96(SB), SI	
  0x42b8a7		8406			TESTB AL, 0(SI)			
  0x42b8a9		48893dd0c00700		MOVQ DI, runtime.sched+96(SB)	
	sched.runqsize++
  0x42b8b0		ff05d2c00700		INCL runtime.sched+104(SB)	
			p.runnext = 0
  0x42b8b6		48c783e80d000000000000	MOVQ $0x0, 0xde8(BX)	
		if gp := p.gcBgMarkWorker.ptr(); gp != nil {
  0x42b8c1		488bb358120000		MOVQ 0x1258(BX), SI	
  0x42b8c8		488dbb58120000		LEAQ 0x1258(BX), DI	
  0x42b8cf		4885f6			TESTQ SI, SI		
  0x42b8d2		0f8508020000		JNE 0x42bae0		
		if gcphase != _GCoff {
  0x42b8d8		8b35fe7f0900		MOVL runtime.gcphase(SB), SI	
  0x42b8de		85f6			TESTL SI, SI			
  0x42b8e0		0f85cc010000		JNE 0x42bab2			
		for i := range p.sudogbuf {
  0x42b8e6		488d83180e0000		LEAQ 0xe18(BX), AX			
  0x42b8ed		48890424		MOVQ AX, 0(SP)				
  0x42b8f1		48c744240800040000	MOVQ $0x400, 0x8(SP)			
  0x42b8fa		e88104feff		CALL runtime.memclrHasPointers(SB)	
  0x42b8ff		488b842480000000	MOVQ 0x80(SP), AX			
		p.sudogcache = p.sudogbuf[:0]
  0x42b907		488d88180e0000		LEAQ 0xe18(AX), CX			
  0x42b90e		8401			TESTB AL, 0(CX)				
  0x42b910		48c780080e000000000000	MOVQ $0x0, 0xe08(AX)			
  0x42b91b		48c780100e000080000000	MOVQ $0x80, 0xe10(AX)			
  0x42b926		8b15e4800900		MOVL runtime.writeBarrier(SB), DX	
  0x42b92c		488db8000e0000		LEAQ 0xe00(AX), DI			
  0x42b933		85d2			TESTL DX, DX				
  0x42b935		0f8564010000		JNE 0x42ba9f				
  0x42b93b		488988000e0000		MOVQ CX, 0xe00(AX)			
  0x42b942		31c9			XORL CX, CX				
		for i := range p.deferpool {
  0x42b944		eb07			JMP 0x42b94d		
  0x42b946		488d4801		LEAQ 0x1(AX), CX	
  0x42b94a		4889d0			MOVQ DX, AX		
  0x42b94d		4883f905		CMPQ $0x5, CX		
  0x42b951		0f8d81000000		JGE 0x42b9d8		
  0x42b957		48894c2460		MOVQ CX, 0x60(SP)	
			for j := range p.deferpoolbuf[i] {
  0x42b95c		48c1e108		SHLQ $0x8, CX				
  0x42b960		48894c2468		MOVQ CX, 0x68(SP)			
  0x42b965		488d9c08d0000000	LEAQ 0xd0(AX)(CX*1), BX			
  0x42b96d		48891c24		MOVQ BX, 0(SP)				
  0x42b971		48c744240800010000	MOVQ $0x100, 0x8(SP)			
  0x42b97a		e80104feff		CALL runtime.memclrHasPointers(SB)	
  0x42b97f		488b442460		MOVQ 0x60(SP), AX			
			p.deferpool[i] = p.deferpoolbuf[i][:0]
  0x42b984		488d0c40		LEAQ 0(AX)(AX*2), CX		
  0x42b988		488b942480000000	MOVQ 0x80(SP), DX		
  0x42b990		48c744ca6000000000	MOVQ $0x0, 0x60(DX)(CX*8)	
  0x42b999		48c744ca6820000000	MOVQ $0x20, 0x68(DX)(CX*8)	
  0x42b9a2		488b5c2468		MOVQ 0x68(SP), BX		
			for j := range p.deferpoolbuf[i] {
  0x42b9a7		488d9c1ad0000000	LEAQ 0xd0(DX)(BX*1), BX	
			p.deferpool[i] = p.deferpoolbuf[i][:0]
  0x42b9af		488d7cca58		LEAQ 0x58(DX)(CX*8), DI			
  0x42b9b4		8b3556800900		MOVL runtime.writeBarrier(SB), SI	
  0x42b9ba		85f6			TESTL SI, SI				
  0x42b9bc		7507			JNE 0x42b9c5				
  0x42b9be		48895cca58		MOVQ BX, 0x58(DX)(CX*8)			
  0x42b9c3		eb81			JMP 0x42b946				
  0x42b9c5		4889c1			MOVQ AX, CX				
  0x42b9c8		4889d8			MOVQ BX, AX				
  0x42b9cb		e8d0ae0100		CALL runtime.gcWriteBarrier(SB)		
  0x42b9d0		4889c8			MOVQ CX, AX				
  0x42b9d3		e96effffff		JMP 0x42b946				
		freemcache(p.mcache)
  0x42b9d8		488b4848		MOVQ 0x48(AX), CX		
  0x42b9dc		48890c24		MOVQ CX, 0(SP)			
  0x42b9e0		e8eb29feff		CALL runtime.freemcache(SB)	
  0x42b9e5		488b842480000000	MOVQ 0x80(SP), AX		
		p.mcache = nil
  0x42b9ed		48c7404800000000	MOVQ $0x0, 0x48(AX)	
		gfpurge(p)
  0x42b9f5		48890424		MOVQ AX, 0(SP)			
  0x42b9f9		e852f2ffff		CALL runtime.gfpurge(SB)	
  0x42b9fe		488b842480000000	MOVQ 0x80(SP), AX		
		traceProcFree(p)
  0x42ba06		48890424		MOVQ AX, 0(SP)			
  0x42ba0a		e841db0000		CALL runtime.traceProcFree(SB)	
  0x42ba0f		488b842480000000	MOVQ 0x80(SP), AX		
		p.gcAssistTime = 0
  0x42ba17		48c7804812000000000000	MOVQ $0x0, 0x1248(AX)	
		p.status = _Pdead
  0x42ba22		c7400c04000000		MOVL $0x4, 0xc(AX)	
  0x42ba29		8b442448		MOVL 0x48(SP), AX	
	for i := nprocs; i < old; i++ {
  0x42ba2d		8d4801			LEAL 0x1(AX), CX	
  0x42ba30		8b8424c0000000		MOVL 0xc0(SP), AX	
  0x42ba37		8b542440		MOVL 0x40(SP), DX	
  0x42ba3b		39d1			CMPL DX, CX		
  0x42ba3d		0f8db1010000		JGE 0x42bbf4		
		p := allp[i]
  0x42ba43		488b1d6ebc0700		MOVQ runtime.allp+8(SB), BX	
  0x42ba4a		488b355fbc0700		MOVQ runtime.allp(SB), SI	
  0x42ba51		4863f9			MOVSXD CX, DI			
  0x42ba54		4839df			CMPQ BX, DI			
  0x42ba57		0f8323050000		JAE 0x42bf80			
  0x42ba5d		894c2448		MOVL CX, 0x48(SP)		
  0x42ba61		488b1cfe		MOVQ 0(SI)(DI*8), BX		
  0x42ba65		48899c2480000000	MOVQ BX, 0x80(SP)		
		if trace.enabled && p == getg().m.p.ptr() {
  0x42ba6d		0fb6355c7d0800		MOVZX runtime.trace+16(SB), SI	
  0x42ba74		4084f6			TESTL SI, SI			
  0x42ba77		0f8486fdffff		JE 0x42b803			
  0x42ba7d		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI		
  0x42ba86		488b7630		MOVQ 0x30(SI), SI		
  0x42ba8a		488bb6d0000000		MOVQ 0xd0(SI), SI		
  0x42ba91		4839de			CMPQ BX, SI			
  0x42ba94		0f8428010000		JE 0x42bbc2			
  0x42ba9a		e964fdffff		JMP 0x42b803			
  0x42ba9f		4889c2			MOVQ AX, DX			
  0x42baa2		4889c8			MOVQ CX, AX			
		p.sudogcache = p.sudogbuf[:0]
  0x42baa5		e8f6ad0100		CALL runtime.gcWriteBarrier(SB)	
  0x42baaa		4889d0			MOVQ DX, AX			
  0x42baad		e990feffff		JMP 0x42b942			
			wbBufFlush1(p)
  0x42bab2		48891c24		MOVQ BX, 0(SP)			
  0x42bab6		e8152bffff		CALL runtime.wbBufFlush1(SB)	
  0x42babb		488b842480000000	MOVQ 0x80(SP), AX		
			p.gcw.dispose()
  0x42bac3		488d8870120000		LEAQ 0x1270(AX), CX			
  0x42baca		48890c24		MOVQ CX, 0(SP)				
  0x42bace		e8add7feff		CALL runtime.(*gcWork).dispose(SB)	
  0x42bad3		488b9c2480000000	MOVQ 0x80(SP), BX			
  0x42badb		e906feffff		JMP 0x42b8e6				
  0x42bae0		4889bc24a8000000	MOVQ DI, 0xa8(SP)			
  0x42bae8		4889b424a0000000	MOVQ SI, 0xa0(SP)			
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x42baf0		48893424		MOVQ SI, 0(SP)			
  0x42baf4		48b80400000001000000	MOVQ $0x100000004, AX		
  0x42bafe		4889442408		MOVQ AX, 0x8(SP)		
  0x42bb03		e8788fffff		CALL runtime.casgstatus(SB)	
			if trace.enabled {
  0x42bb08		0fb605c17c0800		MOVZX runtime.trace+16(SB), AX	
  0x42bb0f		84c0			TESTL AL, AL			
  0x42bb11		0f858c000000		JNE 0x42bba3			
  0x42bb17		488b8424a0000000	MOVQ 0xa0(SP), AX		
	gp.schedlink = 0
  0x42bb1f		48c780b800000000000000	MOVQ $0x0, 0xb8(AX)	
	if sched.runqtail != 0 {
  0x42bb2a		488b0d4fbe0700		MOVQ runtime.sched+96(SB), CX	
  0x42bb31		4885c9			TESTQ CX, CX			
  0x42bb34		7458			JE 0x42bb8e			
		sched.runqtail.ptr().schedlink.set(gp)
  0x42bb36		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42bb3d		8402			TESTB AL, 0(DX)			
  0x42bb3f		4889c2			MOVQ AX, DX			
  0x42bb42		488981b8000000		MOVQ AX, 0xb8(CX)		
  0x42bb49		488d3530be0700		LEAQ runtime.sched+96(SB), SI	
  0x42bb50		8406			TESTB AL, 0(SI)			
  0x42bb52		48891527be0700		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42bb59		ff0529be0700		INCL runtime.sched+104(SB)	
  0x42bb5f		488bb424a8000000	MOVQ 0xa8(SP), SI		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42bb67		8406			TESTB AL, 0(SI)		
  0x42bb69		31f6			XORL SI, SI		
  0x42bb6b		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x42bb73		4889b358120000		MOVQ SI, 0x1258(BX)	
  0x42bb7a		8b8424c0000000		MOVL 0xc0(SP), AX	
  0x42bb81		8b4c2448		MOVL 0x48(SP), CX	
  0x42bb85		8b542440		MOVL 0x40(SP), DX	
		if gcphase != _GCoff {
  0x42bb89		e94afdffff		JMP 0x42b8d8		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42bb8e		488d0de3bd0700		LEAQ runtime.sched+88(SB), CX	
  0x42bb95		8401			TESTB AL, 0(CX)			
  0x42bb97		4889c2			MOVQ AX, DX			
  0x42bb9a		488905d7bd0700		MOVQ AX, runtime.sched+88(SB)	
	sched.runqtail.set(gp)
  0x42bba1		eba6			JMP 0x42bb49		
  0x42bba3		488b8424a0000000	MOVQ 0xa0(SP), AX	
				traceGoUnpark(gp, 0)
  0x42bbab		48890424		MOVQ AX, 0(SP)			
  0x42bbaf		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42bbb8		e803f10000		CALL runtime.traceGoUnpark(SB)	
  0x42bbbd		e955ffffff		JMP 0x42bb17			
			traceGoSched()
  0x42bbc2		e889ef0000		CALL runtime.traceGoSched(SB)	
  0x42bbc7		488b842480000000	MOVQ 0x80(SP), AX		
			traceProcStop(p)
  0x42bbcf		48890424		MOVQ AX, 0(SP)			
  0x42bbd3		e818e70000		CALL runtime.traceProcStop(SB)	
  0x42bbd8		8b8424c0000000		MOVL 0xc0(SP), AX		
  0x42bbdf		8b4c2448		MOVL 0x48(SP), CX		
  0x42bbe3		8b542440		MOVL 0x40(SP), DX		
  0x42bbe7		488b9c2480000000	MOVQ 0x80(SP), BX		
  0x42bbef		e90ffcffff		JMP 0x42b803			
	if int32(len(allp)) != nprocs {
  0x42bbf4		488b0dbdba0700		MOVQ runtime.allp+8(SB), CX	
  0x42bbfb		39c8			CMPL CX, AX			
  0x42bbfd		0f85e4010000		JNE 0x42bde7			
	_g_ := getg()
  0x42bc03		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42bc0c		48898c2498000000	MOVQ CX, 0x98(SP)	
	if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {
  0x42bc14		488b5130		MOVQ 0x30(CX), DX	
  0x42bc18		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x42bc1f		4885d2			TESTQ DX, DX		
  0x42bc22		0f84b7010000		JE 0x42bddf		
  0x42bc28		4889d3			MOVQ DX, BX		
  0x42bc2b		8b7208			MOVL 0x8(DX), SI	
  0x42bc2e		39c6			CMPL AX, SI		
  0x42bc30		0f8d26010000		JGE 0x42bd5c		
		_g_.m.p.ptr().status = _Prunning
  0x42bc36		c7420c01000000		MOVL $0x1, 0xc(DX)	
	for i := nprocs - 1; i >= 0; i-- {
  0x42bc3d		8d50ff			LEAL -0x1(AX), DX	
  0x42bc40		31db			XORL BX, BX		
  0x42bc42		eb02			JMP 0x42bc46		
  0x42bc44		ffca			DECL DX			
  0x42bc46		48895c2478		MOVQ BX, 0x78(SP)	
  0x42bc4b		85d2			TESTL DX, DX		
  0x42bc4d		0f8cc8000000		JL 0x42bd1b		
		p := allp[i]
  0x42bc53		488b355eba0700		MOVQ runtime.allp+8(SB), SI	
  0x42bc5a		488b3d4fba0700		MOVQ runtime.allp(SB), DI	
  0x42bc61		4c63c2			MOVSXD DX, R8			
  0x42bc64		4939f0			CMPQ SI, R8			
  0x42bc67		0f83fe020000		JAE 0x42bf6b			
		if _g_.m.p.ptr() == p {
  0x42bc6d		488b7130		MOVQ 0x30(CX), SI	
		p := allp[i]
  0x42bc71		4a8b3cc7		MOVQ 0(DI)(R8*8), DI	
		if _g_.m.p.ptr() == p {
  0x42bc75		488bb6d0000000		MOVQ 0xd0(SI), SI	
  0x42bc7c		4839fe			CMPQ DI, SI		
  0x42bc7f		74c3			JE 0x42bc44		
  0x42bc81		89542444		MOVL DX, 0x44(SP)	
  0x42bc85		4889bc2488000000	MOVQ DI, 0x88(SP)	
		p.status = _Pidle
  0x42bc8d		c7470c00000000		MOVL $0x0, 0xc(DI)	
		if runqempty(p) {
  0x42bc94		48893c24		MOVQ DI, 0(SP)			
  0x42bc98		e873210000		CALL runtime.runqempty(SB)	
  0x42bc9d		0fb6442408		MOVZX 0x8(SP), AX		
  0x42bca2		84c0			TESTL AL, AL			
  0x42bca4		755d			JNE 0x42bd03			
	mp := sched.midle.ptr()
  0x42bca6		488b058bbc0700		MOVQ runtime.sched+24(SB), AX	
	if mp != nil {
  0x42bcad		4885c0			TESTQ AX, AX		
  0x42bcb0		7415			JE 0x42bcc7		
		sched.midle = mp.schedlink
  0x42bcb2		488b8858010000		MOVQ 0x158(AX), CX		
  0x42bcb9		48890d78bc0700		MOVQ CX, runtime.sched+24(SB)	
		sched.nmidle--
  0x42bcc0		830579bc0700ff		ADDL $-0x1, runtime.sched+32(SB)	
  0x42bcc7		488b8c2488000000	MOVQ 0x88(SP), CX			
			p.m.set(mget())
  0x42bccf		488d5140		LEAQ 0x40(CX), DX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42bcd3		8402			TESTB AL, 0(DX)		
  0x42bcd5		48894140		MOVQ AX, 0x40(CX)	
			p.link.set(runnablePs)
  0x42bcd9		488d4110		LEAQ 0x10(CX), AX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42bcdd		8400			TESTB AL, 0(AX)		
  0x42bcdf		488b442478		MOVQ 0x78(SP), AX	
  0x42bce4		48894110		MOVQ AX, 0x10(CX)	
			runnablePs = p
  0x42bce8		8b8424c0000000		MOVL 0xc0(SP), AX	
  0x42bcef		8b542444		MOVL 0x44(SP), DX	
  0x42bcf3		4889cb			MOVQ CX, BX		
  0x42bcf6		488b8c2498000000	MOVQ 0x98(SP), CX	
	for i := nprocs - 1; i >= 0; i-- {
  0x42bcfe		e941ffffff		JMP 0x42bc44		
  0x42bd03		488b842488000000	MOVQ 0x88(SP), AX	
			pidleput(p)
  0x42bd0b		48890424		MOVQ AX, 0(SP)			
  0x42bd0f		e85c200000		CALL runtime.pidleput(SB)	
  0x42bd14		488b4c2478		MOVQ 0x78(SP), CX		
  0x42bd19		ebcd			JMP 0x42bce8			
	stealOrder.reset(uint32(nprocs))
  0x42bd1b		488d0d9eba0700		LEAQ runtime.stealOrder(SB), CX		
  0x42bd22		48890c24		MOVQ CX, 0(SP)				
  0x42bd26		89442408		MOVL AX, 0x8(SP)			
  0x42bd2a		e831270000		CALL runtime.(*randomOrder).reset(SB)	
  0x42bd2f		8b8424c0000000		MOVL 0xc0(SP), AX			
	atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))
  0x42bd36		488d0da37b0900		LEAQ runtime.gomaxprocs(SB), CX	
  0x42bd3d		8701			XCHGL AX, 0(CX)			
	return runnablePs
  0x42bd3f		488b442478		MOVQ 0x78(SP), AX	
  0x42bd44		48898424c8000000	MOVQ AX, 0xc8(SP)	
  0x42bd4c		488bac24b0000000	MOVQ 0xb0(SP), BP	
  0x42bd54		4881c4b8000000		ADDQ $0xb8, SP		
  0x42bd5b		c3			RET			
	if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {
  0x42bd5c		4885db			TESTQ BX, BX		
		if _g_.m.p != 0 {
  0x42bd5f		7408			JE 0x42bd69		
			_g_.m.p.ptr().m = 0
  0x42bd61		48c7434000000000	MOVQ $0x0, 0x40(BX)	
		_g_.m.p = 0
  0x42bd69		488b5130		MOVQ 0x30(CX), DX	
  0x42bd6d		48c782d000000000000000	MOVQ $0x0, 0xd0(DX)	
		_g_.m.mcache = nil
  0x42bd78		488b5130		MOVQ 0x30(CX), DX	
  0x42bd7c		48c7826001000000000000	MOVQ $0x0, 0x160(DX)	
		p := allp[0]
  0x42bd87		488b152ab90700		MOVQ runtime.allp+8(SB), DX	
  0x42bd8e		488b1d1bb90700		MOVQ runtime.allp(SB), BX	
  0x42bd95		4885d2			TESTQ DX, DX			
  0x42bd98		0f86d4010000		JBE 0x42bf72			
  0x42bd9e		488b03			MOVQ 0(BX), AX			
		p.m = 0
  0x42bda1		48c7404000000000	MOVQ $0x0, 0x40(AX)	
		p.status = _Pidle
  0x42bda9		c7400c00000000		MOVL $0x0, 0xc(AX)	
		acquirep(p)
  0x42bdb0		48890424		MOVQ AX, 0(SP)			
  0x42bdb4		e827020000		CALL runtime.acquirep(SB)	
		if trace.enabled {
  0x42bdb9		0fb605107a0800		MOVZX runtime.trace+16(SB), AX	
  0x42bdc0		84c0			TESTL AL, AL			
  0x42bdc2		7514			JNE 0x42bdd8			
  0x42bdc4		8b8424c0000000		MOVL 0xc0(SP), AX		
  0x42bdcb		488b8c2498000000	MOVQ 0x98(SP), CX		
	for i := nprocs - 1; i >= 0; i-- {
  0x42bdd3		e965feffff		JMP 0x42bc3d		
			traceGoStart()
  0x42bdd8		e873eb0000		CALL runtime.traceGoStart(SB)	
  0x42bddd		ebe5			JMP 0x42bdc4			
  0x42bddf		4889d3			MOVQ DX, BX			
	if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {
  0x42bde2		e978ffffff		JMP 0x42bd5f		
		lock(&allpLock)
  0x42bde7		488d05327b0900		LEAQ runtime.allpLock(SB), AX	
  0x42bdee		48890424		MOVQ AX, 0(SP)			
  0x42bdf2		e829d7fdff		CALL runtime.lock(SB)		
		allp = allp[:nprocs]
  0x42bdf7		488b05c2b80700		MOVQ runtime.allp+16(SB), AX	
  0x42bdfe		8b8c24c0000000		MOVL 0xc0(SP), CX		
  0x42be05		4863d1			MOVSXD CX, DX			
  0x42be08		4839c2			CMPQ AX, DX			
  0x42be0b		0f8768010000		JA 0x42bf79			
  0x42be11		488915a0b80700		MOVQ DX, runtime.allp+8(SB)	
		unlock(&allpLock)
  0x42be18		488d05017b0900		LEAQ runtime.allpLock(SB), AX	
  0x42be1f		48890424		MOVQ AX, 0(SP)			
  0x42be23		e898d8fdff		CALL runtime.unlock(SB)		
  0x42be28		8b8424c0000000		MOVL 0xc0(SP), AX		
  0x42be2f		e9cffdffff		JMP 0x42bc03			
		lock(&allpLock)
  0x42be34		488d05e57a0900		LEAQ runtime.allpLock(SB), AX	
  0x42be3b		48890424		MOVQ AX, 0(SP)			
  0x42be3f		e8dcd6fdff		CALL runtime.lock(SB)		
		if nprocs <= int32(cap(allp)) {
  0x42be44		488b0575b80700		MOVQ runtime.allp+16(SB), AX	
  0x42be4b		8b8c24c0000000		MOVL 0xc0(SP), CX		
  0x42be52		39c1			CMPL AX, CX			
  0x42be54		7f33			JG 0x42be89			
			allp = allp[:nprocs]
  0x42be56		4863d1			MOVSXD CX, DX			
  0x42be59		4839c2			CMPQ AX, DX			
  0x42be5c		0f874e010000		JA 0x42bfb0			
  0x42be62		4889154fb80700		MOVQ DX, runtime.allp+8(SB)	
		unlock(&allpLock)
  0x42be69		488d05b07a0900		LEAQ runtime.allpLock(SB), AX	
  0x42be70		48890424		MOVQ AX, 0(SP)			
  0x42be74		e847d8fdff		CALL runtime.unlock(SB)		
  0x42be79		8b8c24c0000000		MOVL 0xc0(SP), CX		
  0x42be80		8b542440		MOVL 0x40(SP), DX		
  0x42be84		e9abf7ffff		JMP 0x42b634			
			nallp := make([]*p, nprocs)
  0x42be89		488d05f08a0200		LEAQ 0x28af0(IP), AX		
  0x42be90		48890424		MOVQ AX, 0(SP)			
  0x42be94		4863d1			MOVSXD CX, DX			
  0x42be97		4889542408		MOVQ DX, 0x8(SP)		
  0x42be9c		4889542410		MOVQ DX, 0x10(SP)		
  0x42bea1		e8ba780000		CALL runtime.makeslice(SB)	
  0x42bea6		488b442428		MOVQ 0x28(SP), AX		
  0x42beab		4889442458		MOVQ AX, 0x58(SP)		
  0x42beb0		488b4c2420		MOVQ 0x20(SP), CX		
  0x42beb5		48894c2450		MOVQ CX, 0x50(SP)		
  0x42beba		488b542418		MOVQ 0x18(SP), DX		
  0x42bebf		4889942490000000	MOVQ DX, 0x90(SP)		
			copy(nallp, allp[:cap(allp)])
  0x42bec7		488b1df2b70700		MOVQ runtime.allp+16(SB), BX	
  0x42bece		488b35dbb70700		MOVQ runtime.allp(SB), SI	
  0x42bed5		488d3da48a0200		LEAQ 0x28aa4(IP), DI		
  0x42bedc		48893c24		MOVQ DI, 0(SP)			
  0x42bee0		4889542408		MOVQ DX, 0x8(SP)		
  0x42bee5		48894c2410		MOVQ CX, 0x10(SP)		
  0x42beea		4889442418		MOVQ AX, 0x18(SP)		
  0x42beef		4889742420		MOVQ SI, 0x20(SP)		
  0x42bef4		48895c2428		MOVQ BX, 0x28(SP)		
  0x42bef9		48895c2430		MOVQ BX, 0x30(SP)		
  0x42befe		e8ddfcfdff		CALL runtime.typedslicecopy(SB)	
  0x42bf03		488b442450		MOVQ 0x50(SP), AX		
			allp = nallp
  0x42bf08		488905a9b70700		MOVQ AX, runtime.allp+8(SB)		
  0x42bf0f		488b442458		MOVQ 0x58(SP), AX			
  0x42bf14		488905a5b70700		MOVQ AX, runtime.allp+16(SB)		
  0x42bf1b		8b05ef7a0900		MOVL runtime.writeBarrier(SB), AX	
  0x42bf21		85c0			TESTL AX, AX				
  0x42bf23		7514			JNE 0x42bf39				
  0x42bf25		488b842490000000	MOVQ 0x90(SP), AX			
  0x42bf2d		4889057cb70700		MOVQ AX, runtime.allp(SB)		
  0x42bf34		e930ffffff		JMP 0x42be69				
  0x42bf39		488d3d70b70700		LEAQ runtime.allp(SB), DI		
  0x42bf40		488b842490000000	MOVQ 0x90(SP), AX			
  0x42bf48		e853a90100		CALL runtime.gcWriteBarrier(SB)		
  0x42bf4d		e917ffffff		JMP 0x42be69				
  0x42bf52		8b542440		MOVL 0x40(SP), DX			
  0x42bf56		4889c6			MOVQ AX, SI				
	if sched.procresizetime != 0 {
  0x42bf59		e9b9f6ffff		JMP 0x42b617		
		traceGomaxprocs(nprocs)
  0x42bf5e		890c24			MOVL CX, 0(SP)				
  0x42bf61		e88ae20000		CALL runtime.traceGomaxprocs(SB)	
  0x42bf66		e974f6ffff		JMP 0x42b5df				
		p := allp[i]
  0x42bf6b		e8d03affff		CALL runtime.panicindex(SB)	
  0x42bf70		0f0b			UD2				
		p := allp[0]
  0x42bf72		e8c93affff		CALL runtime.panicindex(SB)	
  0x42bf77		0f0b			UD2				
		allp = allp[:nprocs]
  0x42bf79		e8323bffff		CALL runtime.panicslice(SB)	
  0x42bf7e		0f0b			UD2				
		p := allp[i]
  0x42bf80		e8bb3affff		CALL runtime.panicindex(SB)	
  0x42bf85		0f0b			UD2				
					throw("missing mcache?")
  0x42bf87		488d05ece90300		LEAQ 0x3e9ec(IP), AX	
  0x42bf8e		48890424		MOVQ AX, 0(SP)		
  0x42bf92		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x42bf9b		e83052ffff		CALL runtime.throw(SB)	
  0x42bfa0		0f0b			UD2			
			atomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))
  0x42bfa2		e8993affff		CALL runtime.panicindex(SB)	
  0x42bfa7		0f0b			UD2				
		pp := allp[i]
  0x42bfa9		e8923affff		CALL runtime.panicindex(SB)	
  0x42bfae		0f0b			UD2				
			allp = allp[:nprocs]
  0x42bfb0		e8fb3affff		CALL runtime.panicslice(SB)	
  0x42bfb5		0f0b			UD2				
		throw("procresize: invalid arg")
  0x42bfb7		488d055df70300		LEAQ 0x3f75d(IP), AX	
  0x42bfbe		48890424		MOVQ AX, 0(SP)		
  0x42bfc2		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x42bfcb		e80052ffff		CALL runtime.throw(SB)	
  0x42bfd0		0f0b			UD2			
func procresize(nprocs int32) *p {
  0x42bfd2		e899850100		CALL runtime.morestack_noctxt(SB)	
  0x42bfd7		e9a4f5ffff		JMP runtime.procresize(SB)		

TEXT runtime.acquirep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func acquirep(_p_ *p) {
  0x42bfe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42bfe9		483b6110		CMPQ 0x10(CX), SP	
  0x42bfed		7655			JBE 0x42c044		
  0x42bfef		4883ec10		SUBQ $0x10, SP		
  0x42bff3		48896c2408		MOVQ BP, 0x8(SP)	
  0x42bff8		488d6c2408		LEAQ 0x8(SP), BP	
  0x42bffd		488b442418		MOVQ 0x18(SP), AX	
	acquirep1(_p_)
  0x42c002		48890424		MOVQ AX, 0(SP)			
  0x42c006		e845000000		CALL runtime.acquirep1(SB)	
	_g_ := getg()
  0x42c00b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.mcache = _p_.mcache
  0x42c014		488b4030		MOVQ 0x30(AX), AX	
  0x42c018		488b4c2418		MOVQ 0x18(SP), CX	
  0x42c01d		488b4948		MOVQ 0x48(CX), CX	
  0x42c021		48898860010000		MOVQ CX, 0x160(AX)	
	if trace.enabled {
  0x42c028		0fb605a1770800		MOVZX runtime.trace+16(SB), AX	
  0x42c02f		84c0			TESTL AL, AL			
  0x42c031		750a			JNE 0x42c03d			
  0x42c033		488b6c2408		MOVQ 0x8(SP), BP		
  0x42c038		4883c410		ADDQ $0x10, SP			
  0x42c03c		c3			RET				
		traceProcStart()
  0x42c03d		e82ee20000		CALL runtime.traceProcStart(SB)	
  0x42c042		ebef			JMP 0x42c033			
func acquirep(_p_ *p) {
  0x42c044		e827850100		CALL runtime.morestack_noctxt(SB)	
  0x42c049		eb95			JMP runtime.acquirep(SB)		

TEXT runtime.acquirep1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func acquirep1(_p_ *p) {
  0x42c050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c059		483b6110		CMPQ 0x10(CX), SP	
  0x42c05d		0f8663010000		JBE 0x42c1c6		
  0x42c063		4883ec30		SUBQ $0x30, SP		
  0x42c067		48896c2428		MOVQ BP, 0x28(SP)	
  0x42c06c		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x42c071		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.p != 0 || _g_.m.mcache != nil {
  0x42c07a		488b4830		MOVQ 0x30(AX), CX	
  0x42c07e		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x42c085		488d99d0000000		LEAQ 0xd0(CX), BX	
  0x42c08c		4885d2			TESTQ DX, DX		
  0x42c08f		0f8516010000		JNE 0x42c1ab		
  0x42c095		488b9160010000		MOVQ 0x160(CX), DX	
  0x42c09c		4885d2			TESTQ DX, DX		
  0x42c09f		0f8506010000		JNE 0x42c1ab		
  0x42c0a5		488b542438		MOVQ 0x38(SP), DX	
	if _p_.m != 0 || _p_.status != _Pidle {
  0x42c0aa		488b7240		MOVQ 0x40(DX), SI	
  0x42c0ae		488d7a40		LEAQ 0x40(DX), DI	
  0x42c0b2		4885f6			TESTQ SI, SI		
  0x42c0b5		7533			JNE 0x42c0ea		
  0x42c0b7		448b420c		MOVL 0xc(DX), R8	
  0x42c0bb		4585c0			TESTL R8, R8		
  0x42c0be		7527			JNE 0x42c0e7		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42c0c0		8403			TESTB AL, 0(BX)		
  0x42c0c2		4889d3			MOVQ DX, BX		
  0x42c0c5		488991d0000000		MOVQ DX, 0xd0(CX)	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42c0cc		8407			TESTB AL, 0(DI)		
	_p_.m.set(_g_.m)
  0x42c0ce		488b4030		MOVQ 0x30(AX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42c0d2		48894340		MOVQ AX, 0x40(BX)	
	_p_.status = _Prunning
  0x42c0d6		c7430c01000000		MOVL $0x1, 0xc(BX)	
}
  0x42c0dd		488b6c2428		MOVQ 0x28(SP), BP	
  0x42c0e2		4883c430		ADDQ $0x30, SP		
  0x42c0e6		c3			RET			
	if _p_.m != 0 || _p_.status != _Pidle {
  0x42c0e7		4885f6			TESTQ SI, SI		
  0x42c0ea		4889742420		MOVQ SI, 0x20(SP)	
		if _p_.m != 0 {
  0x42c0ef		740c			JE 0x42c0fd		
			id = _p_.m.ptr().id
  0x42c0f1		488b8ee0000000		MOVQ 0xe0(SI), CX	
  0x42c0f8		4889c8			MOVQ CX, AX		
  0x42c0fb		eb02			JMP 0x42c0ff		
  0x42c0fd		31c0			XORL AX, AX		
		if _p_.m != 0 {
  0x42c0ff		4889442410		MOVQ AX, 0x10(SP)	
		print("acquirep: p->m=", _p_.m, "(", id, ") p->status=", _p_.status, "\n")
  0x42c104		8b4a0c			MOVL 0xc(DX), CX		
  0x42c107		48894c2418		MOVQ CX, 0x18(SP)		
  0x42c10c		e8ef59ffff		CALL runtime.printlock(SB)	
  0x42c111		488d0535e80300		LEAQ 0x3e835(IP), AX		
  0x42c118		48890424		MOVQ AX, 0(SP)			
  0x42c11c		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x42c125		e81663ffff		CALL runtime.printstring(SB)	
  0x42c12a		488b442420		MOVQ 0x20(SP), AX		
  0x42c12f		48890424		MOVQ AX, 0(SP)			
  0x42c133		e83860ffff		CALL runtime.printuint(SB)	
  0x42c138		488d0512db0300		LEAQ 0x3db12(IP), AX		
  0x42c13f		48890424		MOVQ AX, 0(SP)			
  0x42c143		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42c14c		e8ef62ffff		CALL runtime.printstring(SB)	
  0x42c151		488b442410		MOVQ 0x10(SP), AX		
  0x42c156		48890424		MOVQ AX, 0(SP)			
  0x42c15a		e82161ffff		CALL runtime.printint(SB)	
  0x42c15f		488d0518e40300		LEAQ 0x3e418(IP), AX		
  0x42c166		48890424		MOVQ AX, 0(SP)			
  0x42c16a		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x42c173		e8c862ffff		CALL runtime.printstring(SB)	
  0x42c178		488b442418		MOVQ 0x18(SP), AX		
  0x42c17d		48890424		MOVQ AX, 0(SP)			
  0x42c181		e8ea5fffff		CALL runtime.printuint(SB)	
  0x42c186		e8055cffff		CALL runtime.printnl(SB)	
  0x42c18b		e8f059ffff		CALL runtime.printunlock(SB)	
		throw("acquirep: invalid p state")
  0x42c190		488d0501f80300		LEAQ 0x3f801(IP), AX	
  0x42c197		48890424		MOVQ AX, 0(SP)		
  0x42c19b		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42c1a4		e82750ffff		CALL runtime.throw(SB)	
  0x42c1a9		0f0b			UD2			
		throw("acquirep: already in go")
  0x42c1ab		488d0555f40300		LEAQ 0x3f455(IP), AX	
  0x42c1b2		48890424		MOVQ AX, 0(SP)		
  0x42c1b6		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x42c1bf		e80c50ffff		CALL runtime.throw(SB)	
  0x42c1c4		0f0b			UD2			
func acquirep1(_p_ *p) {
  0x42c1c6		e8a5830100		CALL runtime.morestack_noctxt(SB)	
  0x42c1cb		e980feffff		JMP runtime.acquirep1(SB)		

TEXT runtime.releasep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func releasep() *p {
  0x42c1d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c1d9		483b6110		CMPQ 0x10(CX), SP	
  0x42c1dd		0f860a020000		JBE 0x42c3ed		
  0x42c1e3		4883ec50		SUBQ $0x50, SP		
  0x42c1e7		48896c2448		MOVQ BP, 0x48(SP)	
  0x42c1ec		488d6c2448		LEAQ 0x48(SP), BP	
	_g_ := getg()
  0x42c1f1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.p == 0 || _g_.m.mcache == nil {
  0x42c1fa		488b4830		MOVQ 0x30(AX), CX	
  0x42c1fe		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x42c205		4885d2			TESTQ DX, DX		
  0x42c208		0f84c4010000		JE 0x42c3d2		
  0x42c20e		488b9960010000		MOVQ 0x160(CX), BX	
  0x42c215		4885db			TESTQ BX, BX		
  0x42c218		0f84b4010000		JE 0x42c3d2		
  0x42c21e		48894c2440		MOVQ CX, 0x40(SP)	
  0x42c223		48895c2438		MOVQ BX, 0x38(SP)	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42c228		4889542430		MOVQ DX, 0x30(SP)	
	if _p_.m.ptr() != _g_.m || _p_.mcache != _g_.m.mcache || _p_.status != _Prunning {
  0x42c22d		488b7240		MOVQ 0x40(DX), SI	
  0x42c231		4889742410		MOVQ SI, 0x10(SP)	
  0x42c236		4839ce			CMPQ CX, SI		
  0x42c239		7572			JNE 0x42c2ad		
  0x42c23b		488b7248		MOVQ 0x48(DX), SI	
  0x42c23f		4839de			CMPQ BX, SI		
  0x42c242		7569			JNE 0x42c2ad		
  0x42c244		8b720c			MOVL 0xc(DX), SI	
  0x42c247		83fe01			CMPL $0x1, SI		
  0x42c24a		7561			JNE 0x42c2ad		
	if trace.enabled {
  0x42c24c		0fb60d7d750800		MOVZX runtime.trace+16(SB), CX	
  0x42c253		84c9			TESTL CL, CL			
  0x42c255		753c			JNE 0x42c293			
	_g_.m.p = 0
  0x42c257		488b4830		MOVQ 0x30(AX), CX	
  0x42c25b		48c781d000000000000000	MOVQ $0x0, 0xd0(CX)	
	_g_.m.mcache = nil
  0x42c266		488b4030		MOVQ 0x30(AX), AX	
  0x42c26a		48c7806001000000000000	MOVQ $0x0, 0x160(AX)	
	_p_.m = 0
  0x42c275		48c7424000000000	MOVQ $0x0, 0x40(DX)	
	_p_.status = _Pidle
  0x42c27d		c7420c00000000		MOVL $0x0, 0xc(DX)	
	return _p_
  0x42c284		4889542458		MOVQ DX, 0x58(SP)	
  0x42c289		488b6c2448		MOVQ 0x48(SP), BP	
  0x42c28e		4883c450		ADDQ $0x50, SP		
  0x42c292		c3			RET			
  0x42c293		4889442420		MOVQ AX, 0x20(SP)	
		traceProcStop(_g_.m.p.ptr())
  0x42c298		48891424		MOVQ DX, 0(SP)			
  0x42c29c		e84fe00000		CALL runtime.traceProcStop(SB)	
  0x42c2a1		488b442420		MOVQ 0x20(SP), AX		
  0x42c2a6		488b542430		MOVQ 0x30(SP), DX		
  0x42c2ab		ebaa			JMP 0x42c257			
		print("releasep: m=", _g_.m, " m->p=", _g_.m.p.ptr(), " p->m=", _p_.m, " m->mcache=", _g_.m.mcache, " p->mcache=", _p_.mcache, " p->status=", _p_.status, "\n")
  0x42c2ad		8b420c			MOVL 0xc(DX), AX		
  0x42c2b0		4889442418		MOVQ AX, 0x18(SP)		
  0x42c2b5		488b4a48		MOVQ 0x48(DX), CX		
  0x42c2b9		48894c2428		MOVQ CX, 0x28(SP)		
  0x42c2be		e83d58ffff		CALL runtime.printlock(SB)	
  0x42c2c3		488d0568e30300		LEAQ 0x3e368(IP), AX		
  0x42c2ca		48890424		MOVQ AX, 0(SP)			
  0x42c2ce		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x42c2d7		e86461ffff		CALL runtime.printstring(SB)	
  0x42c2dc		488b442440		MOVQ 0x40(SP), AX		
  0x42c2e1		48890424		MOVQ AX, 0(SP)			
  0x42c2e5		e81661ffff		CALL runtime.printpointer(SB)	
  0x42c2ea		488d0520db0300		LEAQ 0x3db20(IP), AX		
  0x42c2f1		48890424		MOVQ AX, 0(SP)			
  0x42c2f5		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x42c2fe		e83d61ffff		CALL runtime.printstring(SB)	
  0x42c303		488b442430		MOVQ 0x30(SP), AX		
  0x42c308		48890424		MOVQ AX, 0(SP)			
  0x42c30c		e8ef60ffff		CALL runtime.printpointer(SB)	
  0x42c311		488d05ffda0300		LEAQ 0x3daff(IP), AX		
  0x42c318		48890424		MOVQ AX, 0(SP)			
  0x42c31c		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x42c325		e81661ffff		CALL runtime.printstring(SB)	
  0x42c32a		488b442410		MOVQ 0x10(SP), AX		
  0x42c32f		48890424		MOVQ AX, 0(SP)			
  0x42c333		e8385effff		CALL runtime.printuint(SB)	
  0x42c338		488d05a6e00300		LEAQ 0x3e0a6(IP), AX		
  0x42c33f		48890424		MOVQ AX, 0(SP)			
  0x42c343		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42c34c		e8ef60ffff		CALL runtime.printstring(SB)	
  0x42c351		488b442438		MOVQ 0x38(SP), AX		
  0x42c356		48890424		MOVQ AX, 0(SP)			
  0x42c35a		e8a160ffff		CALL runtime.printpointer(SB)	
  0x42c35f		488d05a0e00300		LEAQ 0x3e0a0(IP), AX		
  0x42c366		48890424		MOVQ AX, 0(SP)			
  0x42c36a		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42c373		e8c860ffff		CALL runtime.printstring(SB)	
  0x42c378		488b442428		MOVQ 0x28(SP), AX		
  0x42c37d		48890424		MOVQ AX, 0(SP)			
  0x42c381		e87a60ffff		CALL runtime.printpointer(SB)	
  0x42c386		488d0584e00300		LEAQ 0x3e084(IP), AX		
  0x42c38d		48890424		MOVQ AX, 0(SP)			
  0x42c391		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42c39a		e8a160ffff		CALL runtime.printstring(SB)	
  0x42c39f		488b442418		MOVQ 0x18(SP), AX		
  0x42c3a4		48890424		MOVQ AX, 0(SP)			
  0x42c3a8		e8c35dffff		CALL runtime.printuint(SB)	
  0x42c3ad		e8de59ffff		CALL runtime.printnl(SB)	
  0x42c3b2		e8c957ffff		CALL runtime.printunlock(SB)	
		throw("releasep: invalid p state")
  0x42c3b7		488d05bbf60300		LEAQ 0x3f6bb(IP), AX	
  0x42c3be		48890424		MOVQ AX, 0(SP)		
  0x42c3c2		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42c3cb		e8004effff		CALL runtime.throw(SB)	
  0x42c3d0		0f0b			UD2			
		throw("releasep: invalid arg")
  0x42c3d2		488d0519ef0300		LEAQ 0x3ef19(IP), AX	
  0x42c3d9		48890424		MOVQ AX, 0(SP)		
  0x42c3dd		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42c3e6		e8e54dffff		CALL runtime.throw(SB)	
  0x42c3eb		0f0b			UD2			
func releasep() *p {
  0x42c3ed		e87e810100		CALL runtime.morestack_noctxt(SB)	
  0x42c3f2		e9d9fdffff		JMP runtime.releasep(SB)		

TEXT runtime.incidlelocked(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func incidlelocked(v int32) {
  0x42c400		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c409		483b6110		CMPQ 0x10(CX), SP	
  0x42c40d		7655			JBE 0x42c464		
  0x42c40f		4883ec10		SUBQ $0x10, SP		
  0x42c413		48896c2408		MOVQ BP, 0x8(SP)	
  0x42c418		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&sched.lock)
  0x42c41d		488d050cb50700		LEAQ runtime.sched+16(SB), AX	
  0x42c424		48890424		MOVQ AX, 0(SP)			
  0x42c428		e8f3d0fdff		CALL runtime.lock(SB)		
	sched.nmidlelocked += v
  0x42c42d		8b0511b50700		MOVL runtime.sched+36(SB), AX	
  0x42c433		8b4c2418		MOVL 0x18(SP), CX		
  0x42c437		01c8			ADDL CX, AX			
  0x42c439		890505b50700		MOVL AX, runtime.sched+36(SB)	
	if v > 0 {
  0x42c43f		85c9			TESTL CX, CX		
  0x42c441		7f1a			JG 0x42c45d		
	unlock(&sched.lock)
  0x42c443		488d05e6b40700		LEAQ runtime.sched+16(SB), AX	
  0x42c44a		48890424		MOVQ AX, 0(SP)			
  0x42c44e		e86dd2fdff		CALL runtime.unlock(SB)		
}
  0x42c453		488b6c2408		MOVQ 0x8(SP), BP	
  0x42c458		4883c410		ADDQ $0x10, SP		
  0x42c45c		c3			RET			
		checkdead()
  0x42c45d		e80e000000		CALL runtime.checkdead(SB)	
  0x42c462		ebdf			JMP 0x42c443			
func incidlelocked(v int32) {
  0x42c464		e807810100		CALL runtime.morestack_noctxt(SB)	
  0x42c469		eb95			JMP runtime.incidlelocked(SB)		

TEXT runtime.checkdead(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func checkdead() {
  0x42c470		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c479		483b6110		CMPQ 0x10(CX), SP	
  0x42c47d		0f8656040000		JBE 0x42c8d9		
  0x42c483		4883ec50		SUBQ $0x50, SP		
  0x42c487		48896c2448		MOVQ BP, 0x48(SP)	
  0x42c48c		488d6c2448		LEAQ 0x48(SP), BP	
	if islibrary || isarchive {
  0x42c491		0fb60515740900		MOVZX runtime.islibrary(SB), AX	
  0x42c498		84c0			TESTL AL, AL			
  0x42c49a		0f852e020000		JNE 0x42c6ce			
  0x42c4a0		0fb60504740900		MOVZX runtime.isarchive(SB), AX	
  0x42c4a7		84c0			TESTL AL, AL			
  0x42c4a9		0f851f020000		JNE 0x42c6ce			
	if panicking > 0 {
  0x42c4af		8b053f740900		MOVL runtime.panicking(SB), AX	
  0x42c4b5		85c0			TESTL AX, AX			
  0x42c4b7		0f8707020000		JA 0x42c6c4			
	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys
  0x42c4bd		8b057db40700		MOVL runtime.sched+32(SB), AX	
	return int32(sched.mnext - sched.nmfreed)
  0x42c4c3		488b0d7eb40700		MOVQ runtime.sched+40(SB), CX	
  0x42c4ca		482b0d87b40700		SUBQ runtime.sched+56(SB), CX	
  0x42c4d1		4889ca			MOVQ CX, DX			
	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys
  0x42c4d4		29c1			SUBL AX, CX			
  0x42c4d6		8b1d68b40700		MOVL runtime.sched+36(SB), BX	
  0x42c4dc		29d9			SUBL BX, CX			
  0x42c4de		8b3570b40700		MOVL runtime.sched+52(SB), SI	
  0x42c4e4		29f1			SUBL SI, CX			
	if run > 0 {
  0x42c4e6		85c9			TESTL CX, CX		
  0x42c4e8		0f8fcc010000		JG 0x42c6ba		
	if run < 0 {
  0x42c4ee		0f8c05030000		JL 0x42c7f9		
	lock(&allglock)
  0x42c4f4		488d051d740900		LEAQ runtime.allglock(SB), AX	
  0x42c4fb		48890424		MOVQ AX, 0(SP)			
  0x42c4ff		e81cd0fdff		CALL runtime.lock(SB)		
  0x42c504		31c0			XORL AX, AX			
  0x42c506		4889c1			MOVQ AX, CX			
	for i := 0; i < len(allgs); i++ {
  0x42c509		eb0e			JMP 0x42c519			
  0x42c50b		488b542420		MOVQ 0x20(SP), DX		
  0x42c510		48ffc2			INCQ DX				
  0x42c513		4889c1			MOVQ AX, CX			
  0x42c516		4889d0			MOVQ DX, AX			
  0x42c519		48894c2428		MOVQ CX, 0x28(SP)		
  0x42c51e		488b1573b10700		MOVQ runtime.allgs+8(SB), DX	
  0x42c525		488b1d64b10700		MOVQ runtime.allgs(SB), BX	
  0x42c52c		4839d0			CMPQ DX, AX			
  0x42c52f		7d5f			JGE 0x42c590			
  0x42c531		4889442420		MOVQ AX, 0x20(SP)		
		gp := allgs[i]
  0x42c536		488b0cc3		MOVQ 0(BX)(AX*8), CX	
  0x42c53a		48894c2438		MOVQ CX, 0x38(SP)	
		if isSystemGoroutine(gp) {
  0x42c53f		48890c24		MOVQ CX, 0(SP)				
  0x42c543		e8e81e0100		CALL runtime.isSystemGoroutine(SB)	
  0x42c548		0fb6442408		MOVZX 0x8(SP), AX			
  0x42c54d		84c0			TESTL AL, AL				
  0x42c54f		7407			JE 0x42c558				
  0x42c551		488b442428		MOVQ 0x28(SP), AX			
			continue
  0x42c556		ebb3			JMP 0x42c50b		
  0x42c558		488b442438		MOVQ 0x38(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x42c55d		8b8890000000		MOVL 0x90(AX), CX	
  0x42c563		89ca			MOVL CX, DX		
		switch s &^ _Gscan {
  0x42c565		81e1ffefffff		ANDL $-0x1001, CX	
		case _Grunnable,
  0x42c56b		8d59ff			LEAL -0x1(CX), BX	
  0x42c56e		83fb02			CMPL $0x2, BX		
  0x42c571		0f86e4010000		JBE 0x42c75b		
		case _Gwaiting:
  0x42c577		83f904			CMPL $0x4, CX		
  0x42c57a		750a			JNE 0x42c586		
  0x42c57c		488b442428		MOVQ 0x28(SP), AX	
			grunning++
  0x42c581		48ffc0			INCQ AX			
		switch s &^ _Gscan {
  0x42c584		eb85			JMP 0x42c50b		
  0x42c586		488b442428		MOVQ 0x28(SP), AX	
  0x42c58b		e97bffffff		JMP 0x42c50b		
	unlock(&allglock)
  0x42c590		488d0581730900		LEAQ runtime.allglock(SB), AX	
  0x42c597		48890424		MOVQ AX, 0(SP)			
  0x42c59b		e820d1fdff		CALL runtime.unlock(SB)		
  0x42c5a0		488b442428		MOVQ 0x28(SP), AX		
	if grunning == 0 { // possible if main goroutine calls runtime·Goexit()
  0x42c5a5		4885c0			TESTQ AX, AX		
  0x42c5a8		0f8492010000		JE 0x42c740		
	gp := timejump()
  0x42c5ae		e8bdcc0000		CALL runtime.timejump(SB)	
  0x42c5b3		488b0424		MOVQ 0(SP), AX			
	if gp != nil {
  0x42c5b7		4885c0			TESTQ AX, AX		
  0x42c5ba		0f844e010000		JE 0x42c70e		
  0x42c5c0		4889442440		MOVQ AX, 0x40(SP)	
		casgstatus(gp, _Gwaiting, _Grunnable)
  0x42c5c5		48b80400000001000000	MOVQ $0x100000004, AX		
  0x42c5cf		4889442408		MOVQ AX, 0x8(SP)		
  0x42c5d4		e8a784ffff		CALL runtime.casgstatus(SB)	
  0x42c5d9		488b442440		MOVQ 0x40(SP), AX		
	gp.schedlink = 0
  0x42c5de		48c780b800000000000000	MOVQ $0x0, 0xb8(AX)	
	if sched.runqtail != 0 {
  0x42c5e9		488b0d90b30700		MOVQ runtime.sched+96(SB), CX	
  0x42c5f0		4885c9			TESTQ CX, CX			
  0x42c5f3		0f84a9000000		JE 0x42c6a2			
		sched.runqtail.ptr().schedlink.set(gp)
  0x42c5f9		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42c600		8402			TESTB AL, 0(DX)			
  0x42c602		4889c2			MOVQ AX, DX			
  0x42c605		488981b8000000		MOVQ AX, 0xb8(CX)		
  0x42c60c		488d056db30700		LEAQ runtime.sched+96(SB), AX	
  0x42c613		8400			TESTB AL, 0(AX)			
  0x42c615		48891564b30700		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42c61c		ff0566b30700		INCL runtime.sched+104(SB)	
	_p_ := sched.pidle.ptr()
  0x42c622		488b053fb30700		MOVQ runtime.sched+72(SB), AX	
	if _p_ != nil {
  0x42c629		4885c0			TESTQ AX, AX		
  0x42c62c		741e			JE 0x42c64c		
		sched.pidle = _p_.link
  0x42c62e		488b4810		MOVQ 0x10(AX), CX		
  0x42c632		48890d2fb30700		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x42c639		b9ffffffff		MOVL $-0x1, CX			
  0x42c63e		488d152bb30700		LEAQ runtime.sched+80(SB), DX	
  0x42c645		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x42c649		4885c0			TESTQ AX, AX		
		if _p_ == nil {
  0x42c64c		0f84a1000000		JE 0x42c6f3		
	mp := sched.midle.ptr()
  0x42c652		488b0ddfb20700		MOVQ runtime.sched+24(SB), CX	
	if mp != nil {
  0x42c659		4885c9			TESTQ CX, CX		
  0x42c65c		7418			JE 0x42c676		
		sched.midle = mp.schedlink
  0x42c65e		488b9158010000		MOVQ 0x158(CX), DX		
  0x42c665		488915ccb20700		MOVQ DX, runtime.sched+24(SB)	
		sched.nmidle--
  0x42c66c		8305cdb20700ff		ADDL $-0x1, runtime.sched+32(SB)	
	if mp != nil {
  0x42c673		4885c9			TESTQ CX, CX		
		if mp == nil {
  0x42c676		7460			JE 0x42c6d8		
		mp.nextp.set(_p_)
  0x42c678		488d91d8000000		LEAQ 0xd8(CX), DX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42c67f		8402			TESTB AL, 0(DX)		
  0x42c681		488981d8000000		MOVQ AX, 0xd8(CX)	
		notewakeup(&mp.park)
  0x42c688		488d8148010000		LEAQ 0x148(CX), AX		
  0x42c68f		48890424		MOVQ AX, 0(SP)			
  0x42c693		e8f8d0fdff		CALL runtime.notewakeup(SB)	
		return
  0x42c698		488b6c2448		MOVQ 0x48(SP), BP	
  0x42c69d		4883c450		ADDQ $0x50, SP		
  0x42c6a1		c3			RET			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42c6a2		488d0dcfb20700		LEAQ runtime.sched+88(SB), CX	
  0x42c6a9		8401			TESTB AL, 0(CX)			
  0x42c6ab		4889c2			MOVQ AX, DX			
  0x42c6ae		488905c3b20700		MOVQ AX, runtime.sched+88(SB)	
	sched.runqtail.set(gp)
  0x42c6b5		e952ffffff		JMP 0x42c60c		
		return
  0x42c6ba		488b6c2448		MOVQ 0x48(SP), BP	
  0x42c6bf		4883c450		ADDQ $0x50, SP		
  0x42c6c3		c3			RET			
		return
  0x42c6c4		488b6c2448		MOVQ 0x48(SP), BP	
  0x42c6c9		4883c450		ADDQ $0x50, SP		
  0x42c6cd		c3			RET			
		return
  0x42c6ce		488b6c2448		MOVQ 0x48(SP), BP	
  0x42c6d3		4883c450		ADDQ $0x50, SP		
  0x42c6d7		c3			RET			
			throw("checkdead: no m for timer")
  0x42c6d8		488d0536f30300		LEAQ 0x3f336(IP), AX	
  0x42c6df		48890424		MOVQ AX, 0(SP)		
  0x42c6e3		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42c6ec		e8df4affff		CALL runtime.throw(SB)	
  0x42c6f1		0f0b			UD2			
			throw("checkdead: no p for timer")
  0x42c6f3		488d0534f30300		LEAQ 0x3f334(IP), AX	
  0x42c6fa		48890424		MOVQ AX, 0(SP)		
  0x42c6fe		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42c707		e8c44affff		CALL runtime.throw(SB)	
  0x42c70c		0f0b			UD2			
	getg().m.throwing = -1 // do not dump full stacks
  0x42c70e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42c717		488b4030		MOVQ 0x30(AX), AX	
  0x42c71b		c780ec000000ffffffff	MOVL $-0x1, 0xec(AX)	
	throw("all goroutines are asleep - deadlock!")
  0x42c725		488d0564080400		LEAQ 0x40864(IP), AX	
  0x42c72c		48890424		MOVQ AX, 0(SP)		
  0x42c730		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x42c739		e8924affff		CALL runtime.throw(SB)	
  0x42c73e		0f0b			UD2			
		throw("no goroutines (main called runtime.Goexit) - deadlock!")
  0x42c740		488d057d140400		LEAQ 0x4147d(IP), AX	
  0x42c747		48890424		MOVQ AX, 0(SP)		
  0x42c74b		48c744240836000000	MOVQ $0x36, 0x8(SP)	
  0x42c754		e8774affff		CALL runtime.throw(SB)	
  0x42c759		0f0b			UD2			
  0x42c75b		8954241c		MOVL DX, 0x1c(SP)	
			unlock(&allglock)
  0x42c75f		488d05b2710900		LEAQ runtime.allglock(SB), AX	
  0x42c766		48890424		MOVQ AX, 0(SP)			
  0x42c76a		e851cffdff		CALL runtime.unlock(SB)		
  0x42c76f		488b442438		MOVQ 0x38(SP), AX		
			print("runtime: checkdead: find g ", gp.goid, " in status ", s, "\n")
  0x42c774		488b8098000000		MOVQ 0x98(AX), AX		
  0x42c77b		4889442430		MOVQ AX, 0x30(SP)		
  0x42c780		e87b53ffff		CALL runtime.printlock(SB)	
  0x42c785		488d05cdf60300		LEAQ 0x3f6cd(IP), AX		
  0x42c78c		48890424		MOVQ AX, 0(SP)			
  0x42c790		48c74424081b000000	MOVQ $0x1b, 0x8(SP)		
  0x42c799		e8a25cffff		CALL runtime.printstring(SB)	
  0x42c79e		488b442430		MOVQ 0x30(SP), AX		
  0x42c7a3		48890424		MOVQ AX, 0(SP)			
  0x42c7a7		e8d45affff		CALL runtime.printint(SB)	
  0x42c7ac		488d0527dc0300		LEAQ 0x3dc27(IP), AX		
  0x42c7b3		48890424		MOVQ AX, 0(SP)			
  0x42c7b7		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42c7c0		e87b5cffff		CALL runtime.printstring(SB)	
  0x42c7c5		8b44241c		MOVL 0x1c(SP), AX		
  0x42c7c9		89c0			MOVL AX, AX			
  0x42c7cb		48890424		MOVQ AX, 0(SP)			
  0x42c7cf		e89c59ffff		CALL runtime.printuint(SB)	
  0x42c7d4		e8b755ffff		CALL runtime.printnl(SB)	
  0x42c7d9		e8a253ffff		CALL runtime.printunlock(SB)	
			throw("checkdead: runnable g")
  0x42c7de		488d058fea0300		LEAQ 0x3ea8f(IP), AX	
  0x42c7e5		48890424		MOVQ AX, 0(SP)		
  0x42c7e9		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42c7f2		e8d949ffff		CALL runtime.throw(SB)	
  0x42c7f7		0f0b			UD2			
  0x42c7f9		4889542430		MOVQ DX, 0x30(SP)	
  0x42c7fe		89442418		MOVL AX, 0x18(SP)	
  0x42c802		895c2414		MOVL BX, 0x14(SP)	
  0x42c806		89742410		MOVL SI, 0x10(SP)	
		print("runtime: checkdead: nmidle=", sched.nmidle, " nmidlelocked=", sched.nmidlelocked, " mcount=", mcount(), " nmsys=", sched.nmsys, "\n")
  0x42c80a		e8f152ffff		CALL runtime.printlock(SB)	
  0x42c80f		488d055ef60300		LEAQ 0x3f65e(IP), AX		
  0x42c816		48890424		MOVQ AX, 0(SP)			
  0x42c81a		48c74424081b000000	MOVQ $0x1b, 0x8(SP)		
  0x42c823		e8185cffff		CALL runtime.printstring(SB)	
  0x42c828		8b442418		MOVL 0x18(SP), AX		
  0x42c82c		4863c0			MOVSXD AX, AX			
  0x42c82f		48890424		MOVQ AX, 0(SP)			
  0x42c833		e8485affff		CALL runtime.printint(SB)	
  0x42c838		488d059fdf0300		LEAQ 0x3df9f(IP), AX		
  0x42c83f		48890424		MOVQ AX, 0(SP)			
  0x42c843		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x42c84c		e8ef5bffff		CALL runtime.printstring(SB)	
  0x42c851		8b442414		MOVL 0x14(SP), AX		
  0x42c855		4863c0			MOVSXD AX, AX			
  0x42c858		48890424		MOVQ AX, 0(SP)			
  0x42c85c		e81f5affff		CALL runtime.printint(SB)	
  0x42c861		488d053fd70300		LEAQ 0x3d73f(IP), AX		
  0x42c868		48890424		MOVQ AX, 0(SP)			
  0x42c86c		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x42c875		e8c65bffff		CALL runtime.printstring(SB)	
  0x42c87a		488b442430		MOVQ 0x30(SP), AX		
  0x42c87f		4863c0			MOVSXD AX, AX			
  0x42c882		48890424		MOVQ AX, 0(SP)			
  0x42c886		e8f559ffff		CALL runtime.printint(SB)	
  0x42c88b		488d05ebd50300		LEAQ 0x3d5eb(IP), AX		
  0x42c892		48890424		MOVQ AX, 0(SP)			
  0x42c896		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42c89f		e89c5bffff		CALL runtime.printstring(SB)	
  0x42c8a4		8b442410		MOVL 0x10(SP), AX		
  0x42c8a8		4863c0			MOVSXD AX, AX			
  0x42c8ab		48890424		MOVQ AX, 0(SP)			
  0x42c8af		e8cc59ffff		CALL runtime.printint(SB)	
  0x42c8b4		e8d754ffff		CALL runtime.printnl(SB)	
  0x42c8b9		e8c252ffff		CALL runtime.printunlock(SB)	
		throw("checkdead: inconsistent counts")
  0x42c8be		488d051efc0300		LEAQ 0x3fc1e(IP), AX	
  0x42c8c5		48890424		MOVQ AX, 0(SP)		
  0x42c8c9		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x42c8d2		e8f948ffff		CALL runtime.throw(SB)	
  0x42c8d7		0f0b			UD2			
func checkdead() {
  0x42c8d9		e8927c0100		CALL runtime.morestack_noctxt(SB)	
  0x42c8de		e98dfbffff		JMP runtime.checkdead(SB)		

TEXT runtime.sysmon(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func sysmon() {
  0x42c8f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c8f9		483b6110		CMPQ 0x10(CX), SP	
  0x42c8fd		0f86d5040000		JBE 0x42cdd8		
  0x42c903		4881ec80000000		SUBQ $0x80, SP		
  0x42c90a		48896c2478		MOVQ BP, 0x78(SP)	
  0x42c90f		488d6c2478		LEAQ 0x78(SP), BP	
	lock(&sched.lock)
  0x42c914		488d0515b00700		LEAQ runtime.sched+16(SB), AX	
  0x42c91b		48890424		MOVQ AX, 0(SP)			
  0x42c91f		e8fccbfdff		CALL runtime.lock(SB)		
	sched.nmsys++
  0x42c924		ff052ab00700		INCL runtime.sched+52(SB)	
	checkdead()
  0x42c92a		e841fbffff		CALL runtime.checkdead(SB)	
	unlock(&sched.lock)
  0x42c92f		488d05faaf0700		LEAQ runtime.sched+16(SB), AX	
  0x42c936		48890424		MOVQ AX, 0(SP)			
  0x42c93a		e881cdfdff		CALL runtime.unlock(SB)		
	if debug.scavenge > 0 {
  0x42c93f		8b05a7710900		MOVL runtime.debug+44(SB), AX	
  0x42c945		85c0			TESTL AX, AX			
  0x42c947		0f8e7c040000		JLE 0x42cdc9			
		forcegcperiod = 10 * 1e6
  0x42c94d		48c705d886070080969800	MOVQ $0x989680, runtime.forcegcperiod(SB)	
  0x42c958		b8002d3101		MOVL $0x1312d00, AX				
		scavengelimit = 20 * 1e6
  0x42c95d		4889442430		MOVQ AX, 0x30(SP)	
	lastscavenge := nanotime()
  0x42c962		e8c9b00100		CALL runtime.nanotime(SB)	
  0x42c967		488b0424		MOVQ 0(SP), AX			
  0x42c96b		31c9			XORL CX, CX			
  0x42c96d		31d2			XORL DX, DX			
  0x42c96f		4889cb			MOVQ CX, BX			
  0x42c972		31f6			XORL SI, SI			
	for {
  0x42c974		eb12			JMP 0x42c988		
  0x42c976		8b542424		MOVL 0x24(SP), DX	
  0x42c97a		4889d8			MOVQ BX, AX		
  0x42c97d		4889cb			MOVQ CX, BX		
  0x42c980		4c89c6			MOVQ R8, SI		
  0x42c983		488b4c2450		MOVQ 0x50(SP), CX	
		if idle == 0 { // start with 20us sleep...
  0x42c988		4885c9			TESTQ CX, CX		
  0x42c98b		0f8527040000		JNE 0x42cdb8		
  0x42c991		ba14000000		MOVL $0x14, DX		
		if delay > 10*1000 { // up to 10ms
  0x42c996		4889742440		MOVQ SI, 0x40(SP)	
  0x42c99b		48895c2438		MOVQ BX, 0x38(SP)	
  0x42c9a0		4889442448		MOVQ AX, 0x48(SP)	
  0x42c9a5		48894c2450		MOVQ CX, 0x50(SP)	
  0x42c9aa		81fa10270000		CMPL $0x2710, DX	
  0x42c9b0		7605			JBE 0x42c9b7		
  0x42c9b2		ba10270000		MOVL $0x2710, DX	
		usleep(delay)
  0x42c9b7		89542424		MOVL DX, 0x24(SP)	
  0x42c9bb		891424			MOVL DX, 0(SP)		
  0x42c9be		e8edae0100		CALL runtime.usleep(SB)	
		if debug.schedtrace <= 0 && (sched.gcwaiting != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs)) {
  0x42c9c3		8b052b710900		MOVL runtime.debug+52(SB), AX	
  0x42c9c9		85c0			TESTL AX, AX			
  0x42c9cb		0f8fd9030000		JG 0x42cdaa			
  0x42c9d1		8b0521b00700		MOVL runtime.sched+216(SB), AX	
  0x42c9d7		85c0			TESTL AX, AX			
  0x42c9d9		0f84b7030000		JE 0x42cd96			
			lock(&sched.lock)
  0x42c9df		488d054aaf0700		LEAQ runtime.sched+16(SB), AX	
  0x42c9e6		48890424		MOVQ AX, 0(SP)			
  0x42c9ea		e831cbfdff		CALL runtime.lock(SB)		
			if atomic.Load(&sched.gcwaiting) != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs) {
  0x42c9ef		8b0503b00700		MOVL runtime.sched+216(SB), AX	
  0x42c9f5		85c0			TESTL AX, AX			
  0x42c9f7		0f8477030000		JE 0x42cd74			
				atomic.Store(&sched.sysmonwait, 1)
  0x42c9fd		b801000000		MOVL $0x1, AX			
  0x42ca02		488d0dffaf0700		LEAQ runtime.sched+232(SB), CX	
  0x42ca09		8701			XCHGL AX, 0(CX)			
				unlock(&sched.lock)
  0x42ca0b		488d051eaf0700		LEAQ runtime.sched+16(SB), AX	
  0x42ca12		48890424		MOVQ AX, 0(SP)			
  0x42ca16		e8a5ccfdff		CALL runtime.unlock(SB)		
				maxsleep := forcegcperiod / 2
  0x42ca1b		488b050e860700		MOVQ runtime.forcegcperiod(SB), AX	
  0x42ca22		4889c1			MOVQ AX, CX				
  0x42ca25		48c1f83f		SARQ $0x3f, AX				
  0x42ca29		48c1e83f		SHRQ $0x3f, AX				
  0x42ca2d		4801c8			ADDQ CX, AX				
  0x42ca30		48d1f8			SARQ $0x1, AX				
  0x42ca33		488b542430		MOVQ 0x30(SP), DX			
				if scavengelimit < forcegcperiod {
  0x42ca38		4839ca			CMPQ CX, DX		
  0x42ca3b		0f8d2b030000		JGE 0x42cd6c		
  0x42ca41		4889d0			MOVQ DX, AX		
					maxsleep = scavengelimit / 2
  0x42ca44		48c1fa3f		SARQ $0x3f, DX		
  0x42ca48		48c1ea3f		SHRQ $0x3f, DX		
  0x42ca4c		488d0c10		LEAQ 0(AX)(DX*1), CX	
  0x42ca50		48d1f9			SARQ $0x1, CX		
				notetsleep(&sched.sysmonnote, maxsleep)
  0x42ca53		488d05b6af0700		LEAQ runtime.sched+240(SB), AX	
  0x42ca5a		48890424		MOVQ AX, 0(SP)			
  0x42ca5e		48894c2408		MOVQ CX, 0x8(SP)		
  0x42ca63		e898d0fdff		CALL runtime.notetsleep(SB)	
				lock(&sched.lock)
  0x42ca68		488d05c1ae0700		LEAQ runtime.sched+16(SB), AX	
  0x42ca6f		48890424		MOVQ AX, 0(SP)			
  0x42ca73		e8a8cafdff		CALL runtime.lock(SB)		
				atomic.Store(&sched.sysmonwait, 0)
  0x42ca78		31c0			XORL AX, AX			
  0x42ca7a		488d0d87af0700		LEAQ runtime.sched+232(SB), CX	
  0x42ca81		8701			XCHGL AX, 0(CX)			
	n.key = 0
  0x42ca83		488d0586af0700		LEAQ runtime.sched+240(SB), AX		
  0x42ca8a		8400			TESTB AL, 0(AX)				
  0x42ca8c		48c70579af070000000000	MOVQ $0x0, runtime.sched+240(SB)	
  0x42ca97		b814000000		MOVL $0x14, AX				
  0x42ca9c		31c9			XORL CX, CX				
			unlock(&sched.lock)
  0x42ca9e		48894c2450		MOVQ CX, 0x50(SP)		
  0x42caa3		89442424		MOVL AX, 0x24(SP)		
  0x42caa7		488d1582ae0700		LEAQ runtime.sched+16(SB), DX	
  0x42caae		48891424		MOVQ DX, 0(SP)			
  0x42cab2		e809ccfdff		CALL runtime.unlock(SB)		
  0x42cab7		8b442424		MOVL 0x24(SP), AX		
  0x42cabb		488b4c2450		MOVQ 0x50(SP), CX		
  0x42cac0		48894c2450		MOVQ CX, 0x50(SP)		
  0x42cac5		89442424		MOVL AX, 0x24(SP)		
		if *cgo_yield != nil {
  0x42cac9		488b15508f0700		MOVQ 0x78f50(IP), DX	
  0x42cad0		488b12			MOVQ 0(DX), DX		
  0x42cad3		4885d2			TESTQ DX, DX		
  0x42cad6		0f8579020000		JNE 0x42cd55		
		lastpoll := int64(atomic.Load64(&sched.lastpoll))
  0x42cadc		488b0545ae0700		MOVQ runtime.sched+8(SB), AX	
  0x42cae3		4889442468		MOVQ AX, 0x68(SP)		
		now := nanotime()
  0x42cae8		e843af0100		CALL runtime.nanotime(SB)	
  0x42caed		488b0424		MOVQ 0(SP), AX			
  0x42caf1		4889442428		MOVQ AX, 0x28(SP)		
	return atomic.Load(&netpollInited) != 0
  0x42caf6		8b0dec6d0900		MOVL runtime.netpollInited(SB), CX	
  0x42cafc		85c9			TESTL CX, CX				
		if netpollinited() && lastpoll != 0 && lastpoll+10*1000*1000 < now {
  0x42cafe		741a			JE 0x42cb1a		
  0x42cb00		488b4c2468		MOVQ 0x68(SP), CX	
  0x42cb05		4885c9			TESTQ CX, CX		
  0x42cb08		7410			JE 0x42cb1a		
  0x42cb0a		488d9180969800		LEAQ 0x989680(CX), DX	
  0x42cb11		4839c2			CMPQ AX, DX		
  0x42cb14		0f8cdc010000		JL 0x42ccf6		
		if retake(now) != 0 {
  0x42cb1a		48890424		MOVQ AX, 0(SP)		
  0x42cb1e		e8cd020000		CALL runtime.retake(SB)	
  0x42cb23		8b442408		MOVL 0x8(SP), AX	
  0x42cb27		85c0			TESTL AX, AX		
  0x42cb29		0f84b9010000		JE 0x42cce8		
  0x42cb2f		31c0			XORL AX, AX		
	if !memstats.enablegc || panicking != 0 {
  0x42cb31		0fb60d988c0900		MOVZX runtime.memstats+4304(SB), CX	
  0x42cb38		84c9			TESTL CL, CL				
  0x42cb3a		740e			JE 0x42cb4a				
  0x42cb3c		8b0db26d0900		MOVL runtime.panicking(SB), CX		
  0x42cb42		85c9			TESTL CX, CX				
  0x42cb44		0f8447010000		JE 0x42cc91				
  0x42cb4a		31c9			XORL CX, CX				
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42cb4c		4889442450		MOVQ AX, 0x50(SP)		
  0x42cb51		84c9			TESTL CL, CL			
  0x42cb53		740e			JE 0x42cb63			
  0x42cb55		8b0dc5ab0700		MOVL runtime.forcegc+16(SB), CX	
  0x42cb5b		85c9			TESTL CX, CX			
  0x42cb5d		0f85d8000000		JNE 0x42cc3b			
  0x42cb63		488b4c2430		MOVQ 0x30(SP), CX		
  0x42cb68		4889ca			MOVQ CX, DX			
		if lastscavenge+scavengelimit/2 < now {
  0x42cb6b		48c1f93f		SARQ $0x3f, CX		
  0x42cb6f		48c1e93f		SHRQ $0x3f, CX		
  0x42cb73		4801d1			ADDQ DX, CX		
  0x42cb76		48d1f9			SARQ $0x1, CX		
  0x42cb79		488b5c2448		MOVQ 0x48(SP), BX	
  0x42cb7e		4801d9			ADDQ BX, CX		
  0x42cb81		488b742428		MOVQ 0x28(SP), SI	
  0x42cb86		4839f1			CMPQ SI, CX		
  0x42cb89		7c6d			JL 0x42cbf8		
  0x42cb8b		488b4c2438		MOVQ 0x38(SP), CX	
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42cb90		8b3d5e6f0900		MOVL runtime.debug+52(SB), DI	
  0x42cb96		85ff			TESTL DI, DI			
  0x42cb98		7e54			JLE 0x42cbee			
  0x42cb9a		4863ff			MOVSXD DI, DI			
  0x42cb9d		4869ff40420f00		IMULQ $0xf4240, DI, DI		
  0x42cba4		4c8b442440		MOVQ 0x40(SP), R8		
  0x42cba9		4c01c7			ADDQ R8, DI			
  0x42cbac		4839f7			CMPQ SI, DI			
  0x42cbaf		0f8fc1fdffff		JG 0x42c976			
  0x42cbb5		48894c2460		MOVQ CX, 0x60(SP)		
  0x42cbba		48895c2458		MOVQ BX, 0x58(SP)		
			schedtrace(debug.scheddetail > 0)
  0x42cbbf		8b052b6f0900		MOVL runtime.debug+48(SB), AX	
  0x42cbc5		85c0			TESTL AX, AX			
  0x42cbc7		0f9f0424		SETG 0(SP)			
  0x42cbcb		e820050000		CALL runtime.schedtrace(SB)	
  0x42cbd0		488b442450		MOVQ 0x50(SP), AX		
  0x42cbd5		488b4c2460		MOVQ 0x60(SP), CX		
  0x42cbda		488b542430		MOVQ 0x30(SP), DX		
  0x42cbdf		488b5c2458		MOVQ 0x58(SP), BX		
  0x42cbe4		4c8b442428		MOVQ 0x28(SP), R8		
  0x42cbe9		e988fdffff		JMP 0x42c976			
  0x42cbee		4c8b442440		MOVQ 0x40(SP), R8		
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42cbf3		e97efdffff		JMP 0x42c976		
			mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))
  0x42cbf8		488d05a1f60700		LEAQ runtime.mheap_(SB), AX		
  0x42cbff		48890424		MOVQ AX, 0(SP)				
  0x42cc03		488b4c2438		MOVQ 0x38(SP), CX			
  0x42cc08		894c2408		MOVL CX, 0x8(SP)			
  0x42cc0c		4889742410		MOVQ SI, 0x10(SP)			
  0x42cc11		4889542418		MOVQ DX, 0x18(SP)			
  0x42cc16		e875f1feff		CALL runtime.(*mheap).scavenge(SB)	
  0x42cc1b		488b442438		MOVQ 0x38(SP), AX			
			nscavenge++
  0x42cc20		488d4801		LEAQ 0x1(AX), CX	
  0x42cc24		488b442450		MOVQ 0x50(SP), AX	
  0x42cc29		488b542430		MOVQ 0x30(SP), DX	
  0x42cc2e		488b742428		MOVQ 0x28(SP), SI	
  0x42cc33		4889f3			MOVQ SI, BX		
  0x42cc36		e955ffffff		JMP 0x42cb90		
			lock(&forcegc.lock)
  0x42cc3b		488d05ceaa0700		LEAQ runtime.forcegc(SB), AX	
  0x42cc42		48890424		MOVQ AX, 0(SP)			
  0x42cc46		e8d5c8fdff		CALL runtime.lock(SB)		
			forcegc.idle = 0
  0x42cc4b		c705cbaa070000000000	MOVL $0x0, runtime.forcegc+16(SB)	
			forcegc.g.schedlink = 0
  0x42cc55		488b05bcaa0700		MOVQ runtime.forcegc+8(SB), AX	
  0x42cc5c		48c780b800000000000000	MOVQ $0x0, 0xb8(AX)		
			injectglist(forcegc.g)
  0x42cc67		488b05aaaa0700		MOVQ runtime.forcegc+8(SB), AX	
  0x42cc6e		48890424		MOVQ AX, 0(SP)			
  0x42cc72		e8f9baffff		CALL runtime.injectglist(SB)	
			unlock(&forcegc.lock)
  0x42cc77		488d0592aa0700		LEAQ runtime.forcegc(SB), AX	
  0x42cc7e		48890424		MOVQ AX, 0(SP)			
  0x42cc82		e839cafdff		CALL runtime.unlock(SB)		
  0x42cc87		488b442450		MOVQ 0x50(SP), AX		
  0x42cc8c		e9d2feffff		JMP 0x42cb63			
	if gcphase != _GCoff {
  0x42cc91		8b0d456c0900		MOVL runtime.gcphase(SB), CX	
  0x42cc97		85c9			TESTL CX, CX			
  0x42cc99		7407			JE 0x42cca2			
  0x42cc9b		31c9			XORL CX, CX			
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42cc9d		e9aafeffff		JMP 0x42cb4c		
		if gcpercent < 0 {
  0x42cca2		8b0d306c0900		MOVL runtime.gcpercent(SB), CX	
  0x42cca8		85c9			TESTL CX, CX			
  0x42ccaa		7d07			JGE 0x42ccb3			
  0x42ccac		31c9			XORL CX, CX			
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42ccae		e999feffff		JMP 0x42cb4c		
		lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
  0x42ccb3		488b0d66910900		MOVQ runtime.memstats+5920(SB), CX	
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x42ccba		4885c9			TESTQ CX, CX				
  0x42ccbd		741d			JE 0x42ccdc				
  0x42ccbf		488b542428		MOVQ 0x28(SP), DX			
  0x42ccc4		4889d3			MOVQ DX, BX				
  0x42ccc7		4829ca			SUBQ CX, DX				
  0x42ccca		488b0d5f830700		MOVQ runtime.forcegcperiod(SB), CX	
  0x42ccd1		4839ca			CMPQ CX, DX				
  0x42ccd4		0f9fc1			SETG CL					
  0x42ccd7		e970feffff		JMP 0x42cb4c				
  0x42ccdc		488b5c2428		MOVQ 0x28(SP), BX			
  0x42cce1		31c9			XORL CX, CX				
  0x42cce3		e964feffff		JMP 0x42cb4c				
  0x42cce8		488b4c2450		MOVQ 0x50(SP), CX			
			idle++
  0x42cced		488d4101		LEAQ 0x1(CX), AX	
  0x42ccf1		e93bfeffff		JMP 0x42cb31		
  0x42ccf6		4889c2			MOVQ AX, DX		
  0x42ccf9		4889c8			MOVQ CX, AX		
			atomic.Cas64(&sched.lastpoll, uint64(lastpoll), uint64(now))
  0x42ccfc		488d1d25ac0700		LEAQ runtime.sched+8(SB), BX	
  0x42cd03		f0480fb113		LOCK CMPXCHGQ DX, 0(BX)		
  0x42cd08		0f94c1			SETE CL				
			gp := netpoll(false) // non-blocking - returns list of goroutines
  0x42cd0b		c6042400		MOVB $0x0, 0(SP)		
  0x42cd0f		e81c1dffff		CALL runtime.netpoll(SB)	
  0x42cd14		488b4c2408		MOVQ 0x8(SP), CX		
			if gp != nil {
  0x42cd19		4885c9			TESTQ CX, CX		
  0x42cd1c		750a			JNE 0x42cd28		
  0x42cd1e		488b442428		MOVQ 0x28(SP), AX	
		if retake(now) != 0 {
  0x42cd23		e9f2fdffff		JMP 0x42cb1a		
  0x42cd28		48894c2470		MOVQ CX, 0x70(SP)	
				incidlelocked(-1)
  0x42cd2d		c70424ffffffff		MOVL $-0x1, 0(SP)		
  0x42cd34		e8c7f6ffff		CALL runtime.incidlelocked(SB)	
  0x42cd39		488b442470		MOVQ 0x70(SP), AX		
				injectglist(gp)
  0x42cd3e		48890424		MOVQ AX, 0(SP)			
  0x42cd42		e829baffff		CALL runtime.injectglist(SB)	
				incidlelocked(1)
  0x42cd47		c7042401000000		MOVL $0x1, 0(SP)		
  0x42cd4e		e8adf6ffff		CALL runtime.incidlelocked(SB)	
  0x42cd53		ebc9			JMP 0x42cd1e			
			asmcgocall(*cgo_yield, nil)
  0x42cd55		48891424		MOVQ DX, 0(SP)			
  0x42cd59		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42cd62		e8898e0100		CALL runtime.asmcgocall(SB)	
  0x42cd67		e970fdffff		JMP 0x42cadc			
  0x42cd6c		4889c1			MOVQ AX, CX			
				if scavengelimit < forcegcperiod {
  0x42cd6f		e9dffcffff		JMP 0x42ca53		
			if atomic.Load(&sched.gcwaiting) != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs) {
  0x42cd74		8b05f6ab0700		MOVL runtime.sched+80(SB), AX	
  0x42cd7a		8b0d606b0900		MOVL runtime.gomaxprocs(SB), CX	
  0x42cd80		39c8			CMPL CX, AX			
  0x42cd82		0f8475fcffff		JE 0x42c9fd			
  0x42cd88		8b442424		MOVL 0x24(SP), AX		
  0x42cd8c		488b4c2450		MOVQ 0x50(SP), CX		
			unlock(&sched.lock)
  0x42cd91		e908fdffff		JMP 0x42ca9e		
		if debug.schedtrace <= 0 && (sched.gcwaiting != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs)) {
  0x42cd96		8b05d4ab0700		MOVL runtime.sched+80(SB), AX	
  0x42cd9c		8b0d3e6b0900		MOVL runtime.gomaxprocs(SB), CX	
  0x42cda2		39c8			CMPL CX, AX			
  0x42cda4		0f8435fcffff		JE 0x42c9df			
  0x42cdaa		8b442424		MOVL 0x24(SP), AX		
  0x42cdae		488b4c2450		MOVQ 0x50(SP), CX		
		if *cgo_yield != nil {
  0x42cdb3		e908fdffff		JMP 0x42cac0		
		} else if idle > 50 { // start doubling the sleep after 1ms...
  0x42cdb8		4883f932		CMPQ $0x32, CX		
  0x42cdbc		0f8ed4fbffff		JLE 0x42c996		
			delay *= 2
  0x42cdc2		d1e2			SHLL $0x1, DX		
  0x42cdc4		e9cdfbffff		JMP 0x42c996		
  0x42cdc9		48b800b864d945000000	MOVQ $0x45d964b800, AX	
	if debug.scavenge > 0 {
  0x42cdd3		e985fbffff		JMP 0x42c95d		
func sysmon() {
  0x42cdd8		e893770100		CALL runtime.morestack_noctxt(SB)	
  0x42cddd		e90efbffff		JMP runtime.sysmon(SB)			

TEXT runtime.retake(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func retake(now int64) uint32 {
  0x42cdf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42cdf9		483b6110		CMPQ 0x10(CX), SP	
  0x42cdfd		0f865c020000		JBE 0x42d05f		
  0x42ce03		4883ec38		SUBQ $0x38, SP		
  0x42ce07		48896c2430		MOVQ BP, 0x30(SP)	
  0x42ce0c		488d6c2430		LEAQ 0x30(SP), BP	
	lock(&allpLock)
  0x42ce11		488d05086b0900		LEAQ runtime.allpLock(SB), AX	
  0x42ce18		48890424		MOVQ AX, 0(SP)			
  0x42ce1c		e8ffc6fdff		CALL runtime.lock(SB)		
func retake(now int64) uint32 {
  0x42ce21		31c0			XORL AX, AX		
  0x42ce23		4889c1			MOVQ AX, CX		
	for i := 0; i < len(allp); i++ {
  0x42ce26		eb03			JMP 0x42ce2b			
  0x42ce28		48ffc0			INCQ AX				
  0x42ce2b		48894c2418		MOVQ CX, 0x18(SP)		
  0x42ce30		488b1581a80700		MOVQ runtime.allp+8(SB), DX	
  0x42ce37		488b1d72a80700		MOVQ runtime.allp(SB), BX	
  0x42ce3e		4839d0			CMPQ DX, AX			
  0x42ce41		0f8df5010000		JGE 0x42d03c			
		_p_ := allp[i]
  0x42ce47		488b14c3		MOVQ 0(BX)(AX*8), DX	
		if _p_ == nil {
  0x42ce4b		4885d2			TESTQ DX, DX		
  0x42ce4e		0f84de010000		JE 0x42d032		
  0x42ce54		4889442420		MOVQ AX, 0x20(SP)	
		pd := &_p_.sysmontick
  0x42ce59		488d5a20		LEAQ 0x20(DX), BX	
		s := _p_.status
  0x42ce5d		8b720c			MOVL 0xc(DX), SI	
		if s == _Psyscall {
  0x42ce60		83fe02			CMPL $0x2, SI		
  0x42ce63		0f8536010000		JNE 0x42cf9f		
			if int64(pd.syscalltick) != t {
  0x42ce69		8403			TESTB AL, 0(BX)		
			t := int64(_p_.syscalltick)
  0x42ce6b		8b5a1c			MOVL 0x1c(DX), BX	
			if int64(pd.syscalltick) != t {
  0x42ce6e		8b7a30			MOVL 0x30(DX), DI	
  0x42ce71		4839df			CMPQ BX, DI		
  0x42ce74		740e			JE 0x42ce84		
				pd.syscalltick = uint32(t)
  0x42ce76		895a30			MOVL BX, 0x30(DX)	
  0x42ce79		488b5c2440		MOVQ 0x40(SP), BX	
				pd.syscallwhen = now
  0x42ce7e		48895a38		MOVQ BX, 0x38(DX)	
				continue
  0x42ce82		eba4			JMP 0x42ce28		
  0x42ce84		4889542428		MOVQ DX, 0x28(SP)	
  0x42ce89		89742414		MOVL SI, 0x14(SP)	
			if runqempty(_p_) && atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) > 0 && pd.syscallwhen+10*1000*1000 > now {
  0x42ce8d		48891424		MOVQ DX, 0(SP)			
  0x42ce91		e87a0f0000		CALL runtime.runqempty(SB)	
  0x42ce96		0fb6442408		MOVZX 0x8(SP), AX		
  0x42ce9b		84c0			TESTL AL, AL			
  0x42ce9d		7442			JE 0x42cee1			
  0x42ce9f		8b05cfaa0700		MOVL runtime.sched+84(SB), AX	
  0x42cea5		8b0dc5aa0700		MOVL runtime.sched+80(SB), CX	
  0x42ceab		01c8			ADDL CX, AX			
  0x42cead		85c0			TESTL AX, AX			
  0x42ceaf		0f86db000000		JBE 0x42cf90			
  0x42ceb5		488b442428		MOVQ 0x28(SP), AX		
  0x42ceba		488b4838		MOVQ 0x38(AX), CX		
  0x42cebe		4881c180969800		ADDQ $0x989680, CX		
  0x42cec5		488b542440		MOVQ 0x40(SP), DX		
  0x42ceca		4839d1			CMPQ DX, CX			
  0x42cecd		7e12			JLE 0x42cee1			
  0x42cecf		488b442420		MOVQ 0x20(SP), AX		
  0x42ced4		4889d3			MOVQ DX, BX			
  0x42ced7		488b4c2418		MOVQ 0x18(SP), CX		
				continue
  0x42cedc		e947ffffff		JMP 0x42ce28		
			unlock(&allpLock)
  0x42cee1		488d05386a0900		LEAQ runtime.allpLock(SB), AX	
  0x42cee8		48890424		MOVQ AX, 0(SP)			
  0x42ceec		e8cfc7fdff		CALL runtime.unlock(SB)		
			incidlelocked(-1)
  0x42cef1		c70424ffffffff		MOVL $-0x1, 0(SP)		
  0x42cef8		e803f5ffff		CALL runtime.incidlelocked(SB)	
  0x42cefd		8b442414		MOVL 0x14(SP), AX		
  0x42cf01		488b4c2428		MOVQ 0x28(SP), CX		
			if atomic.Cas(&_p_.status, s, _Pidle) {
  0x42cf06		31d2			XORL DX, DX			
  0x42cf08		f00fb1510c		LOCK CMPXCHGL DX, 0xc(CX)	
  0x42cf0d		0f94c0			SETE AL				
  0x42cf10		84c0			TESTL AL, AL			
  0x42cf12		7475			JE 0x42cf89			
				if trace.enabled {
  0x42cf14		0fb605b5680800		MOVZX runtime.trace+16(SB), AX	
  0x42cf1b		84c0			TESTL AL, AL			
  0x42cf1d		754c			JNE 0x42cf6b			
				_p_.syscalltick++
  0x42cf1f		ff411c			INCL 0x1c(CX)		
				handoffp(_p_)
  0x42cf22		48890c24		MOVQ CX, 0(SP)			
  0x42cf26		e845a1ffff		CALL runtime.handoffp(SB)	
  0x42cf2b		488b442418		MOVQ 0x18(SP), AX		
				n++
  0x42cf30		48ffc0			INCQ AX			
				handoffp(_p_)
  0x42cf33		4889442418		MOVQ AX, 0x18(SP)	
			incidlelocked(1)
  0x42cf38		c7042401000000		MOVL $0x1, 0(SP)		
  0x42cf3f		e8bcf4ffff		CALL runtime.incidlelocked(SB)	
			lock(&allpLock)
  0x42cf44		488d05d5690900		LEAQ runtime.allpLock(SB), AX	
  0x42cf4b		48890424		MOVQ AX, 0(SP)			
  0x42cf4f		e8ccc5fdff		CALL runtime.lock(SB)		
  0x42cf54		488b442418		MOVQ 0x18(SP), AX		
  0x42cf59		488b5c2440		MOVQ 0x40(SP), BX		
  0x42cf5e		4889c1			MOVQ AX, CX			
  0x42cf61		488b442420		MOVQ 0x20(SP), AX		
	for i := 0; i < len(allp); i++ {
  0x42cf66		e9bdfeffff		JMP 0x42ce28		
					traceGoSysBlock(_p_)
  0x42cf6b		48890c24		MOVQ CX, 0(SP)				
  0x42cf6f		e88cdf0000		CALL runtime.traceGoSysBlock(SB)	
  0x42cf74		488b442428		MOVQ 0x28(SP), AX			
					traceProcStop(_p_)
  0x42cf79		48890424		MOVQ AX, 0(SP)			
  0x42cf7d		e86ed30000		CALL runtime.traceProcStop(SB)	
  0x42cf82		488b4c2428		MOVQ 0x28(SP), CX		
  0x42cf87		eb96			JMP 0x42cf1f			
  0x42cf89		488b442418		MOVQ 0x18(SP), AX		
			incidlelocked(1)
  0x42cf8e		eba3			JMP 0x42cf33		
  0x42cf90		488b442428		MOVQ 0x28(SP), AX	
  0x42cf95		488b542440		MOVQ 0x40(SP), DX	
			if runqempty(_p_) && atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) > 0 && pd.syscallwhen+10*1000*1000 > now {
  0x42cf9a		e942ffffff		JMP 0x42cee1		
		} else if s == _Prunning {
  0x42cf9f		83fe01			CMPL $0x1, SI		
  0x42cfa2		0f8583000000		JNE 0x42d02b		
			if int64(pd.schedtick) != t {
  0x42cfa8		8403			TESTB AL, 0(BX)		
			t := int64(_p_.schedtick)
  0x42cfaa		8b5a18			MOVL 0x18(DX), BX	
			if int64(pd.schedtick) != t {
  0x42cfad		8b7220			MOVL 0x20(DX), SI	
  0x42cfb0		4839de			CMPQ BX, SI		
  0x42cfb3		7411			JE 0x42cfc6		
				pd.schedtick = uint32(t)
  0x42cfb5		895a20			MOVL BX, 0x20(DX)	
  0x42cfb8		488b5c2440		MOVQ 0x40(SP), BX	
				pd.schedwhen = now
  0x42cfbd		48895a28		MOVQ BX, 0x28(DX)	
				continue
  0x42cfc1		e962feffff		JMP 0x42ce28		
			if pd.schedwhen+forcePreemptNS > now {
  0x42cfc6		488b5a28		MOVQ 0x28(DX), BX	
  0x42cfca		4881c380969800		ADDQ $0x989680, BX	
  0x42cfd1		488b742440		MOVQ 0x40(SP), SI	
  0x42cfd6		4839f3			CMPQ SI, BX		
  0x42cfd9		7e08			JLE 0x42cfe3		
  0x42cfdb		4889f3			MOVQ SI, BX		
				continue
  0x42cfde		e945feffff		JMP 0x42ce28		
	mp := _p_.m.ptr()
  0x42cfe3		488b5240		MOVQ 0x40(DX), DX	
	if mp == nil || mp == getg().m {
  0x42cfe7		4885d2			TESTQ DX, DX		
  0x42cfea		7412			JE 0x42cffe		
  0x42cfec		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x42cff5		488b5b30		MOVQ 0x30(BX), BX	
  0x42cff9		4839d3			CMPQ DX, BX		
  0x42cffc		7508			JNE 0x42d006		
  0x42cffe		4889c8			MOVQ CX, AX		
	for i := 0; i < len(allp); i++ {
  0x42d001		e953ffffff		JMP 0x42cf59		
	gp := mp.curg
  0x42d006		488b9ac0000000		MOVQ 0xc0(DX), BX	
	if gp == nil || gp == mp.g0 {
  0x42d00d		4885db			TESTQ BX, BX		
  0x42d010		74ec			JE 0x42cffe		
  0x42d012		488b12			MOVQ 0(DX), DX		
  0x42d015		4839d3			CMPQ DX, BX		
  0x42d018		74e4			JE 0x42cffe		
	gp.preempt = true
  0x42d01a		c683c000000001		MOVB $0x1, 0xc0(BX)	
	gp.stackguard0 = stackPreempt
  0x42d021		48c74310defaffff	MOVQ $-0x522, 0x10(BX)	
			preemptone(_p_)
  0x42d029		ebd3			JMP 0x42cffe		
  0x42d02b		488b742440		MOVQ 0x40(SP), SI	
		} else if s == _Prunning {
  0x42d030		ebcc			JMP 0x42cffe		
  0x42d032		488b5c2440		MOVQ 0x40(SP), BX	
			continue
  0x42d037		e9ecfdffff		JMP 0x42ce28		
	unlock(&allpLock)
  0x42d03c		488d05dd680900		LEAQ runtime.allpLock(SB), AX	
  0x42d043		48890424		MOVQ AX, 0(SP)			
  0x42d047		e874c6fdff		CALL runtime.unlock(SB)		
	return uint32(n)
  0x42d04c		488b442418		MOVQ 0x18(SP), AX	
  0x42d051		89442448		MOVL AX, 0x48(SP)	
  0x42d055		488b6c2430		MOVQ 0x30(SP), BP	
  0x42d05a		4883c438		ADDQ $0x38, SP		
  0x42d05e		c3			RET			
func retake(now int64) uint32 {
  0x42d05f		e80c750100		CALL runtime.morestack_noctxt(SB)	
  0x42d064		e987fdffff		JMP runtime.retake(SB)			

TEXT runtime.preemptall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	for _, _p_ := range allp {
  0x42d070		488b0541a60700		MOVQ runtime.allp+8(SB), AX	
  0x42d077		488b0d32a60700		MOVQ runtime.allp(SB), CX	
  0x42d07e		31d2			XORL DX, DX			
  0x42d080		31db			XORL BX, BX			
  0x42d082		eb03			JMP 0x42d087			
  0x42d084		48ffc2			INCQ DX				
  0x42d087		4839c2			CMPQ AX, DX			
  0x42d08a		7d5b			JGE 0x42d0e7			
  0x42d08c		488b34d1		MOVQ 0(CX)(DX*8), SI		
		if _p_.status != _Prunning {
  0x42d090		8b7e0c			MOVL 0xc(SI), DI	
  0x42d093		83ff01			CMPL $0x1, DI		
  0x42d096		75ec			JNE 0x42d084		
	mp := _p_.m.ptr()
  0x42d098		488b7640		MOVQ 0x40(SI), SI	
	if mp == nil || mp == getg().m {
  0x42d09c		4885f6			TESTQ SI, SI		
  0x42d09f		7412			JE 0x42d0b3		
  0x42d0a1		64488b3c25f8ffffff	MOVQ FS:0xfffffff8, DI	
  0x42d0aa		488b7f30		MOVQ 0x30(DI), DI	
  0x42d0ae		4839f7			CMPQ SI, DI		
  0x42d0b1		7506			JNE 0x42d0b9		
  0x42d0b3		31f6			XORL SI, SI		
	return res
  0x42d0b5		09f3			ORL SI, BX		
	for _, _p_ := range allp {
  0x42d0b7		ebcb			JMP 0x42d084		
	gp := mp.curg
  0x42d0b9		488bbec0000000		MOVQ 0xc0(SI), DI	
	if gp == nil || gp == mp.g0 {
  0x42d0c0		4885ff			TESTQ DI, DI		
  0x42d0c3		7408			JE 0x42d0cd		
  0x42d0c5		488b36			MOVQ 0(SI), SI		
  0x42d0c8		4839f7			CMPQ SI, DI		
  0x42d0cb		7504			JNE 0x42d0d1		
  0x42d0cd		31f6			XORL SI, SI		
		if preemptone(_p_) {
  0x42d0cf		ebe4			JMP 0x42d0b5		
	gp.preempt = true
  0x42d0d1		c687c000000001		MOVB $0x1, 0xc0(DI)	
	gp.stackguard0 = stackPreempt
  0x42d0d8		48c74710defaffff	MOVQ $-0x522, 0x10(DI)	
  0x42d0e0		be01000000		MOVL $0x1, SI		
		if preemptone(_p_) {
  0x42d0e5		ebce			JMP 0x42d0b5		
	return res
  0x42d0e7		885c2408		MOVB BL, 0x8(SP)	
  0x42d0eb		c3			RET			

TEXT runtime.schedtrace(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func schedtrace(detailed bool) {
  0x42d0f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42d0f9		488d4424a8		LEAQ -0x58(SP), AX	
  0x42d0fe		483b4110		CMPQ 0x10(CX), AX	
  0x42d102		0f86b50a0000		JBE 0x42dbbd		
  0x42d108		4881ecd8000000		SUBQ $0xd8, SP		
  0x42d10f		4889ac24d0000000	MOVQ BP, 0xd0(SP)	
  0x42d117		488dac24d0000000	LEAQ 0xd0(SP), BP	
	now := nanotime()
  0x42d11f		e80ca90100		CALL runtime.nanotime(SB)	
  0x42d124		488b0424		MOVQ 0(SP), AX			
  0x42d128		4889442428		MOVQ AX, 0x28(SP)		
	if starttime == 0 {
  0x42d12d		488b0dac680900		MOVQ runtime.starttime(SB), CX	
  0x42d134		4885c9			TESTQ CX, CX			
  0x42d137		7507			JNE 0x42d140			
		starttime = now
  0x42d139		488905a0680900		MOVQ AX, runtime.starttime(SB)	
	lock(&sched.lock)
  0x42d140		488d05e9a70700		LEAQ runtime.sched+16(SB), AX	
  0x42d147		48890424		MOVQ AX, 0(SP)			
  0x42d14b		e8d0c3fdff		CALL runtime.lock(SB)		
	print("SCHED ", (now-starttime)/1e6, "ms: gomaxprocs=", gomaxprocs, " idleprocs=", sched.npidle, " threads=", mcount(), " spinningthreads=", sched.nmspinning, " idlethreads=", sched.nmidle, " runqueue=", sched.runqsize)
  0x42d150		48630531a80700		MOVSXD runtime.sched+104(SB), AX	
  0x42d157		48898424b0000000	MOVQ AX, 0xb0(SP)			
  0x42d15f		48630ddaa70700		MOVSXD runtime.sched+32(SB), CX		
  0x42d166		48898c24a8000000	MOVQ CX, 0xa8(SP)			
  0x42d16e		8b1500a80700		MOVL runtime.sched+84(SB), DX		
  0x42d174		48899424a0000000	MOVQ DX, 0xa0(SP)			
  0x42d17c		8b1deea70700		MOVL runtime.sched+80(SB), BX		
  0x42d182		48899c2498000000	MOVQ BX, 0x98(SP)			
  0x42d18a		488b354f680900		MOVQ runtime.starttime(SB), SI		
  0x42d191		4889b42490000000	MOVQ SI, 0x90(SP)			
	return int32(sched.mnext - sched.nmfreed)
  0x42d199		488b3da8a70700		MOVQ runtime.sched+40(SB), DI	
  0x42d1a0		482b3db1a70700		SUBQ runtime.sched+56(SB), DI	
  0x42d1a7		4889bc2488000000	MOVQ DI, 0x88(SP)		
	print("SCHED ", (now-starttime)/1e6, "ms: gomaxprocs=", gomaxprocs, " idleprocs=", sched.npidle, " threads=", mcount(), " spinningthreads=", sched.nmspinning, " idlethreads=", sched.nmidle, " runqueue=", sched.runqsize)
  0x42d1af		e84c49ffff		CALL runtime.printlock(SB)		
  0x42d1b4		488d0580cc0300		LEAQ 0x3cc80(IP), AX			
  0x42d1bb		48890424		MOVQ AX, 0(SP)				
  0x42d1bf		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x42d1c8		e87352ffff		CALL runtime.printstring(SB)		
  0x42d1cd		488b442428		MOVQ 0x28(SP), AX			
  0x42d1d2		488b8c2490000000	MOVQ 0x90(SP), CX			
  0x42d1da		4829c8			SUBQ CX, AX				
  0x42d1dd		4889c1			MOVQ AX, CX				
  0x42d1e0		48b8db34b6d782de1b43	MOVQ $0x431bde82d7b634db, AX		
  0x42d1ea		48f7e9			IMULQ CX				
  0x42d1ed		48c1f93f		SARQ $0x3f, CX				
  0x42d1f1		48c1fa12		SARQ $0x12, DX				
  0x42d1f5		4829ca			SUBQ CX, DX				
  0x42d1f8		48891424		MOVQ DX, 0(SP)				
  0x42d1fc		e87f50ffff		CALL runtime.printint(SB)		
  0x42d201		488d0581d70300		LEAQ 0x3d781(IP), AX			
  0x42d208		48890424		MOVQ AX, 0(SP)				
  0x42d20c		48c74424080f000000	MOVQ $0xf, 0x8(SP)			
  0x42d215		e82652ffff		CALL runtime.printstring(SB)		
  0x42d21a		486305bf660900		MOVSXD runtime.gomaxprocs(SB), AX	
  0x42d221		48890424		MOVQ AX, 0(SP)				
  0x42d225		e85650ffff		CALL runtime.printint(SB)		
  0x42d22a		488d059ed10300		LEAQ 0x3d19e(IP), AX			
  0x42d231		48890424		MOVQ AX, 0(SP)				
  0x42d235		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x42d23e		e8fd51ffff		CALL runtime.printstring(SB)		
  0x42d243		488b842498000000	MOVQ 0x98(SP), AX			
  0x42d24b		48890424		MOVQ AX, 0(SP)				
  0x42d24f		e81c4fffff		CALL runtime.printuint(SB)		
  0x42d254		488d0559ce0300		LEAQ 0x3ce59(IP), AX			
  0x42d25b		48890424		MOVQ AX, 0(SP)				
  0x42d25f		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x42d268		e8d351ffff		CALL runtime.printstring(SB)		
  0x42d26d		488b842488000000	MOVQ 0x88(SP), AX			
  0x42d275		4863c0			MOVSXD AX, AX				
  0x42d278		48890424		MOVQ AX, 0(SP)				
  0x42d27c		e8ff4fffff		CALL runtime.printint(SB)		
  0x42d281		488d052bd90300		LEAQ 0x3d92b(IP), AX			
  0x42d288		48890424		MOVQ AX, 0(SP)				
  0x42d28c		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x42d295		e8a651ffff		CALL runtime.printstring(SB)		
  0x42d29a		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x42d2a2		48890424		MOVQ AX, 0(SP)				
  0x42d2a6		e8c54effff		CALL runtime.printuint(SB)		
  0x42d2ab		488d05e6d30300		LEAQ 0x3d3e6(IP), AX			
  0x42d2b2		48890424		MOVQ AX, 0(SP)				
  0x42d2b6		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x42d2bf		e87c51ffff		CALL runtime.printstring(SB)		
  0x42d2c4		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x42d2cc		48890424		MOVQ AX, 0(SP)				
  0x42d2d0		e8ab4fffff		CALL runtime.printint(SB)		
  0x42d2d5		488d05d6cf0300		LEAQ 0x3cfd6(IP), AX			
  0x42d2dc		48890424		MOVQ AX, 0(SP)				
  0x42d2e0		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x42d2e9		e85251ffff		CALL runtime.printstring(SB)		
  0x42d2ee		488b8424b0000000	MOVQ 0xb0(SP), AX			
  0x42d2f6		48890424		MOVQ AX, 0(SP)				
  0x42d2fa		e8814fffff		CALL runtime.printint(SB)		
  0x42d2ff		e87c48ffff		CALL runtime.printunlock(SB)		
  0x42d304		0fb68424e0000000	MOVZX 0xe0(SP), AX			
func schedtrace(detailed bool) {
  0x42d30c		84c0			TESTL AL, AL		
	if detailed {
  0x42d30e		0f85ab070000		JNE 0x42dabf		
	for i, _p_ := range allp {
  0x42d314		488b0d9da30700		MOVQ runtime.allp+8(SB), CX	
  0x42d31b		48898c2480000000	MOVQ CX, 0x80(SP)		
  0x42d323		488b1586a30700		MOVQ runtime.allp(SB), DX	
  0x42d32a		48899424c8000000	MOVQ DX, 0xc8(SP)		
  0x42d332		31db			XORL BX, BX			
  0x42d334		eb21			JMP 0x42d357			
  0x42d336		488b742458		MOVQ 0x58(SP), SI		
  0x42d33b		488d5e01		LEAQ 0x1(SI), BX		
  0x42d33f		0fb68424e0000000	MOVZX 0xe0(SP), AX		
  0x42d347		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x42d34f		488b9424c8000000	MOVQ 0xc8(SP), DX		
  0x42d357		4839cb			CMPQ CX, BX			
  0x42d35a		0f8d51020000		JGE 0x42d5b1			
  0x42d360		48895c2458		MOVQ BX, 0x58(SP)		
  0x42d365		488b34da		MOVQ 0(DX)(BX*8), SI		
		mp := _p_.m.ptr()
  0x42d369		488b7e40		MOVQ 0x40(SI), DI	
		h := atomic.Load(&_p_.runqhead)
  0x42d36d		448b86e0050000		MOVL 0x5e0(SI), R8	
  0x42d374		4489442424		MOVL R8, 0x24(SP)	
		t := atomic.Load(&_p_.runqtail)
  0x42d379		448b8ee4050000		MOVL 0x5e4(SI), R9	
  0x42d380		44894c241c		MOVL R9, 0x1c(SP)	
func schedtrace(detailed bool) {
  0x42d385		84c0			TESTL AL, AL		
		if detailed {
  0x42d387		0f8481010000		JE 0x42d50e		
			if mp != nil {
  0x42d38d		4885ff			TESTQ DI, DI		
  0x42d390		0f846c010000		JE 0x42d502		
				id = mp.id
  0x42d396		488bbfe0000000		MOVQ 0xe0(DI), DI	
  0x42d39d		48897c2450		MOVQ DI, 0x50(SP)	
			print("  P", i, ": status=", _p_.status, " schedtick=", _p_.schedtick, " syscalltick=", _p_.syscalltick, " m=", id, " runqsize=", t-h, " gfreecnt=", _p_.gfreecnt, "\n")
  0x42d3a2		486386f80d0000		MOVSXD 0xdf8(SI), AX		
  0x42d3a9		48898424b0000000	MOVQ AX, 0xb0(SP)		
  0x42d3b1		8b4e1c			MOVL 0x1c(SI), CX		
  0x42d3b4		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x42d3bc		8b5618			MOVL 0x18(SI), DX		
  0x42d3bf		4889942498000000	MOVQ DX, 0x98(SP)		
  0x42d3c7		8b5e0c			MOVL 0xc(SI), BX		
  0x42d3ca		48895c2478		MOVQ BX, 0x78(SP)		
  0x42d3cf		e82c47ffff		CALL runtime.printlock(SB)	
  0x42d3d4		488d05a9c80300		LEAQ 0x3c8a9(IP), AX		
  0x42d3db		48890424		MOVQ AX, 0(SP)			
  0x42d3df		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42d3e8		e85350ffff		CALL runtime.printstring(SB)	
  0x42d3ed		488b442458		MOVQ 0x58(SP), AX		
  0x42d3f2		48890424		MOVQ AX, 0(SP)			
  0x42d3f6		e8854effff		CALL runtime.printint(SB)	
  0x42d3fb		488d05e8cc0300		LEAQ 0x3cce8(IP), AX		
  0x42d402		48890424		MOVQ AX, 0(SP)			
  0x42d406		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42d40f		e82c50ffff		CALL runtime.printstring(SB)	
  0x42d414		488b442478		MOVQ 0x78(SP), AX		
  0x42d419		48890424		MOVQ AX, 0(SP)			
  0x42d41d		e84e4dffff		CALL runtime.printuint(SB)	
  0x42d422		488d05fecf0300		LEAQ 0x3cffe(IP), AX		
  0x42d429		48890424		MOVQ AX, 0(SP)			
  0x42d42d		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42d436		e80550ffff		CALL runtime.printstring(SB)	
  0x42d43b		488b842498000000	MOVQ 0x98(SP), AX		
  0x42d443		48890424		MOVQ AX, 0(SP)			
  0x42d447		e8244dffff		CALL runtime.printuint(SB)	
  0x42d44c		488d0579d20300		LEAQ 0x3d279(IP), AX		
  0x42d453		48890424		MOVQ AX, 0(SP)			
  0x42d457		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x42d460		e8db4fffff		CALL runtime.printstring(SB)	
  0x42d465		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x42d46d		48890424		MOVQ AX, 0(SP)			
  0x42d471		e8fa4cffff		CALL runtime.printuint(SB)	
  0x42d476		488d0519c80300		LEAQ 0x3c819(IP), AX		
  0x42d47d		48890424		MOVQ AX, 0(SP)			
  0x42d481		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42d48a		e8b14fffff		CALL runtime.printstring(SB)	
  0x42d48f		488b442450		MOVQ 0x50(SP), AX		
  0x42d494		48890424		MOVQ AX, 0(SP)			
  0x42d498		e8e34dffff		CALL runtime.printint(SB)	
  0x42d49d		488d0504ce0300		LEAQ 0x3ce04(IP), AX		
  0x42d4a4		48890424		MOVQ AX, 0(SP)			
  0x42d4a8		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42d4b1		e88a4fffff		CALL runtime.printstring(SB)	
  0x42d4b6		8b44241c		MOVL 0x1c(SP), AX		
  0x42d4ba		8b4c2424		MOVL 0x24(SP), CX		
  0x42d4be		29c8			SUBL CX, AX			
  0x42d4c0		48890424		MOVQ AX, 0(SP)			
  0x42d4c4		e8a74cffff		CALL runtime.printuint(SB)	
  0x42d4c9		488d05bacd0300		LEAQ 0x3cdba(IP), AX		
  0x42d4d0		48890424		MOVQ AX, 0(SP)			
  0x42d4d4		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42d4dd		e85e4fffff		CALL runtime.printstring(SB)	
  0x42d4e2		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x42d4ea		48890424		MOVQ AX, 0(SP)			
  0x42d4ee		e88d4dffff		CALL runtime.printint(SB)	
  0x42d4f3		e89848ffff		CALL runtime.printnl(SB)	
  0x42d4f8		e88346ffff		CALL runtime.printunlock(SB)	
  0x42d4fd		e934feffff		JMP 0x42d336			
  0x42d502		48c7c7ffffffff		MOVQ $-0x1, DI			
			if mp != nil {
  0x42d509		e98ffeffff		JMP 0x42d39d		
			print(" ")
  0x42d50e		e8ed45ffff		CALL runtime.printlock(SB)	
  0x42d513		e82848ffff		CALL runtime.printsp(SB)	
  0x42d518		e86346ffff		CALL runtime.printunlock(SB)	
  0x42d51d		488b442458		MOVQ 0x58(SP), AX		
			if i == 0 {
  0x42d522		4885c0			TESTQ AX, AX		
  0x42d525		7462			JE 0x42d589		
			print(t - h)
  0x42d527		e8d445ffff		CALL runtime.printlock(SB)	
  0x42d52c		8b44241c		MOVL 0x1c(SP), AX		
  0x42d530		8b4c2424		MOVL 0x24(SP), CX		
  0x42d534		29c8			SUBL CX, AX			
  0x42d536		48890424		MOVQ AX, 0(SP)			
  0x42d53a		e8314cffff		CALL runtime.printuint(SB)	
  0x42d53f		e83c46ffff		CALL runtime.printunlock(SB)	
			if i == len(allp)-1 {
  0x42d544		488b056da10700		MOVQ runtime.allp+8(SB), AX	
  0x42d54b		48ffc8			DECQ AX				
  0x42d54e		488b4c2458		MOVQ 0x58(SP), CX		
  0x42d553		4839c8			CMPQ CX, AX			
  0x42d556		0f85dafdffff		JNE 0x42d336			
				print("]\n")
  0x42d55c		e89f45ffff		CALL runtime.printlock(SB)	
  0x42d561		488d050ec70300		LEAQ 0x3c70e(IP), AX		
  0x42d568		48890424		MOVQ AX, 0(SP)			
  0x42d56c		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42d575		e8c64effff		CALL runtime.printstring(SB)	
  0x42d57a		e80146ffff		CALL runtime.printunlock(SB)	
  0x42d57f		488b4c2458		MOVQ 0x58(SP), CX		
  0x42d584		e9adfdffff		JMP 0x42d336			
				print("[")
  0x42d589		e87245ffff		CALL runtime.printlock(SB)	
  0x42d58e		488d05c7c60300		LEAQ 0x3c6c7(IP), AX		
  0x42d595		48890424		MOVQ AX, 0(SP)			
  0x42d599		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42d5a2		e8994effff		CALL runtime.printstring(SB)	
  0x42d5a7		e8d445ffff		CALL runtime.printunlock(SB)	
  0x42d5ac		e976ffffff		JMP 0x42d527			
func schedtrace(detailed bool) {
  0x42d5b1		84c0			TESTL AL, AL		
	if !detailed {
  0x42d5b3		0f84e6040000		JE 0x42da9f		
	for mp := allm; mp != nil; mp = mp.alllink {
  0x42d5b9		488b0558a00700		MOVQ runtime.allm(SB), AX	
  0x42d5c0		e9a7020000		JMP 0x42d86c			
  0x42d5c5		48898424b8000000	MOVQ AX, 0xb8(SP)		
  0x42d5cd		48895c2430		MOVQ BX, 0x30(SP)		
		print("  M", mp.id, ": p=", id1, " curg=", id2, " mallocing=", mp.mallocing, " throwing=", mp.throwing, " preemptoff=", mp.preemptoff, ""+" locks=", mp.locks, " dying=", mp.dying, " helpgc=", mp.helpgc, " spinning=", mp.spinning, " blocked=", mp.blocked, " lockedg=", id3, "\n")
  0x42d5d2		48638810010000		MOVSXD 0x110(AX), CX		
  0x42d5d9		48898c24b0000000	MOVQ CX, 0xb0(SP)		
  0x42d5e1		48639008010000		MOVSXD 0x108(AX), DX		
  0x42d5e8		48899424a8000000	MOVQ DX, 0xa8(SP)		
  0x42d5f0		4863b000010000		MOVSXD 0x100(AX), SI		
  0x42d5f7		4889b42490000000	MOVQ SI, 0x90(SP)		
  0x42d5ff		4863b8ec000000		MOVSXD 0xec(AX), DI		
  0x42d606		4889bc2488000000	MOVQ DI, 0x88(SP)		
  0x42d60e		4c6380e8000000		MOVSXD 0xe8(AX), R8		
  0x42d615		4c89442470		MOVQ R8, 0x70(SP)		
  0x42d61a		4c8b88e0000000		MOVQ 0xe0(AX), R9		
  0x42d621		4c894c2468		MOVQ R9, 0x68(SP)		
  0x42d626		4c8b90f0000000		MOVQ 0xf0(AX), R10		
  0x42d62d		4c899424c0000000	MOVQ R10, 0xc0(SP)		
  0x42d635		4c8b98f8000000		MOVQ 0xf8(AX), R11		
  0x42d63c		4c899c2480000000	MOVQ R11, 0x80(SP)		
  0x42d644		440fb6a014010000	MOVZX 0x114(AX), R12		
  0x42d64c		4488642417		MOVB R12, 0x17(SP)		
  0x42d651		440fb6a815010000	MOVZX 0x115(AX), R13		
  0x42d659		44886c2416		MOVB R13, 0x16(SP)		
  0x42d65e		e89d44ffff		CALL runtime.printlock(SB)	
  0x42d663		488d0517c60300		LEAQ 0x3c617(IP), AX		
  0x42d66a		48890424		MOVQ AX, 0(SP)			
  0x42d66e		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42d677		e8c44dffff		CALL runtime.printstring(SB)	
  0x42d67c		488b442468		MOVQ 0x68(SP), AX		
  0x42d681		48890424		MOVQ AX, 0(SP)			
  0x42d685		e8f64bffff		CALL runtime.printint(SB)	
  0x42d68a		488d0561c60300		LEAQ 0x3c661(IP), AX		
  0x42d691		48890424		MOVQ AX, 0(SP)			
  0x42d695		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x42d69e		e89d4dffff		CALL runtime.printstring(SB)	
  0x42d6a3		8b442420		MOVL 0x20(SP), AX		
  0x42d6a7		4863c0			MOVSXD AX, AX			
  0x42d6aa		48890424		MOVQ AX, 0(SP)			
  0x42d6ae		e8cd4bffff		CALL runtime.printint(SB)	
  0x42d6b3		488d0545c70300		LEAQ 0x3c745(IP), AX		
  0x42d6ba		48890424		MOVQ AX, 0(SP)			
  0x42d6be		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x42d6c7		e8744dffff		CALL runtime.printstring(SB)	
  0x42d6cc		488b442440		MOVQ 0x40(SP), AX		
  0x42d6d1		48890424		MOVQ AX, 0(SP)			
  0x42d6d5		e8a64bffff		CALL runtime.printint(SB)	
  0x42d6da		488d050fcd0300		LEAQ 0x3cd0f(IP), AX		
  0x42d6e1		48890424		MOVQ AX, 0(SP)			
  0x42d6e5		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42d6ee		e84d4dffff		CALL runtime.printstring(SB)	
  0x42d6f3		488b442470		MOVQ 0x70(SP), AX		
  0x42d6f8		48890424		MOVQ AX, 0(SP)			
  0x42d6fc		e87f4bffff		CALL runtime.printint(SB)	
  0x42d701		488d05f0cb0300		LEAQ 0x3cbf0(IP), AX		
  0x42d708		48890424		MOVQ AX, 0(SP)			
  0x42d70c		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42d715		e8264dffff		CALL runtime.printstring(SB)	
  0x42d71a		488b842488000000	MOVQ 0x88(SP), AX		
  0x42d722		48890424		MOVQ AX, 0(SP)			
  0x42d726		e8554bffff		CALL runtime.printint(SB)	
  0x42d72b		488d0504ce0300		LEAQ 0x3ce04(IP), AX		
  0x42d732		48890424		MOVQ AX, 0(SP)			
  0x42d736		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x42d73f		e8fc4cffff		CALL runtime.printstring(SB)	
  0x42d744		488b8424c0000000	MOVQ 0xc0(SP), AX		
  0x42d74c		48890424		MOVQ AX, 0(SP)			
  0x42d750		488b842480000000	MOVQ 0x80(SP), AX		
  0x42d758		4889442408		MOVQ AX, 0x8(SP)		
  0x42d75d		e8de4cffff		CALL runtime.printstring(SB)	
  0x42d762		488d0506c70300		LEAQ 0x3c706(IP), AX		
  0x42d769		48890424		MOVQ AX, 0(SP)			
  0x42d76d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42d776		e8c54cffff		CALL runtime.printstring(SB)	
  0x42d77b		488b842490000000	MOVQ 0x90(SP), AX		
  0x42d783		48890424		MOVQ AX, 0(SP)			
  0x42d787		e8f44affff		CALL runtime.printint(SB)	
  0x42d78c		488d05d5c60300		LEAQ 0x3c6d5(IP), AX		
  0x42d793		48890424		MOVQ AX, 0(SP)			
  0x42d797		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42d7a0		e89b4cffff		CALL runtime.printstring(SB)	
  0x42d7a5		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x42d7ad		48890424		MOVQ AX, 0(SP)			
  0x42d7b1		e8ca4affff		CALL runtime.printint(SB)	
  0x42d7b6		488d05dac70300		LEAQ 0x3c7da(IP), AX		
  0x42d7bd		48890424		MOVQ AX, 0(SP)			
  0x42d7c1		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x42d7ca		e8714cffff		CALL runtime.printstring(SB)	
  0x42d7cf		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x42d7d7		48890424		MOVQ AX, 0(SP)			
  0x42d7db		e8a04affff		CALL runtime.printint(SB)	
  0x42d7e0		488d05dfca0300		LEAQ 0x3cadf(IP), AX		
  0x42d7e7		48890424		MOVQ AX, 0(SP)			
  0x42d7eb		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42d7f4		e8474cffff		CALL runtime.printstring(SB)	
  0x42d7f9		0fb6442417		MOVZX 0x17(SP), AX		
  0x42d7fe		880424			MOVB AL, 0(SP)			
  0x42d801		e8da45ffff		CALL runtime.printbool(SB)	
  0x42d806		488d0544c80300		LEAQ 0x3c844(IP), AX		
  0x42d80d		48890424		MOVQ AX, 0(SP)			
  0x42d811		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42d81a		e8214cffff		CALL runtime.printstring(SB)	
  0x42d81f		0fb6442416		MOVZX 0x16(SP), AX		
  0x42d824		880424			MOVB AL, 0(SP)			
  0x42d827		e8b445ffff		CALL runtime.printbool(SB)	
  0x42d82c		488d0539c80300		LEAQ 0x3c839(IP), AX		
  0x42d833		48890424		MOVQ AX, 0(SP)			
  0x42d837		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42d840		e8fb4bffff		CALL runtime.printstring(SB)	
  0x42d845		488b442430		MOVQ 0x30(SP), AX		
  0x42d84a		48890424		MOVQ AX, 0(SP)			
  0x42d84e		e82d4affff		CALL runtime.printint(SB)	
  0x42d853		e83845ffff		CALL runtime.printnl(SB)	
  0x42d858		e82343ffff		CALL runtime.printunlock(SB)	
  0x42d85d		488b8424b8000000	MOVQ 0xb8(SP), AX		
	for mp := allm; mp != nil; mp = mp.alllink {
  0x42d865		488b8050010000		MOVQ 0x150(AX), AX	
  0x42d86c		4885c0			TESTQ AX, AX		
  0x42d86f		745f			JE 0x42d8d0		
		_p_ := mp.p.ptr()
  0x42d871		488b88d0000000		MOVQ 0xd0(AX), CX	
		gp := mp.curg
  0x42d878		488b90c0000000		MOVQ 0xc0(AX), DX	
		lockedg := mp.lockedg.ptr()
  0x42d87f		488b9868010000		MOVQ 0x168(AX), BX	
		if _p_ != nil {
  0x42d886		4885c9			TESTQ CX, CX		
  0x42d889		743e			JE 0x42d8c9		
			id1 = _p_.id
  0x42d88b		8b4908			MOVL 0x8(CX), CX	
		if gp != nil {
  0x42d88e		4885d2			TESTQ DX, DX		
  0x42d891		742d			JE 0x42d8c0		
			id2 = gp.goid
  0x42d893		488b9298000000		MOVQ 0x98(DX), DX	
  0x42d89a		4889542440		MOVQ DX, 0x40(SP)	
  0x42d89f		894c2420		MOVL CX, 0x20(SP)	
		if lockedg != nil {
  0x42d8a3		4885db			TESTQ BX, BX		
  0x42d8a6		740c			JE 0x42d8b4		
			id3 = lockedg.goid
  0x42d8a8		488b9b98000000		MOVQ 0x98(BX), BX	
  0x42d8af		e911fdffff		JMP 0x42d5c5		
  0x42d8b4		48c7c3ffffffff		MOVQ $-0x1, BX		
		if lockedg != nil {
  0x42d8bb		e905fdffff		JMP 0x42d5c5		
  0x42d8c0		48c7c2ffffffff		MOVQ $-0x1, DX		
		if gp != nil {
  0x42d8c7		ebd1			JMP 0x42d89a		
  0x42d8c9		b9ffffffff		MOVL $-0x1, CX		
		if _p_ != nil {
  0x42d8ce		ebbe			JMP 0x42d88e		
	lock(&allglock)
  0x42d8d0		488d0541600900		LEAQ runtime.allglock(SB), AX	
  0x42d8d7		48890424		MOVQ AX, 0(SP)			
  0x42d8db		e840bcfdff		CALL runtime.lock(SB)		
  0x42d8e0		31c0			XORL AX, AX			
	for gi := 0; gi < len(allgs); gi++ {
  0x42d8e2		e92a010000		JMP 0x42da11		
  0x42d8e7		48895c2438		MOVQ BX, 0x38(SP)	
	return atomic.Load(&gp.atomicstatus)
  0x42d8ec		8b8190000000		MOVL 0x90(CX), AX	
  0x42d8f2		89442418		MOVL AX, 0x18(SP)	
		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason, ") m=", id1, " lockedm=", id2, "\n")
  0x42d8f6		488b9198000000		MOVQ 0x98(CX), DX		
  0x42d8fd		48899424b0000000	MOVQ DX, 0xb0(SP)		
  0x42d905		488bb1b0000000		MOVQ 0xb0(CX), SI		
  0x42d90c		4889b42480000000	MOVQ SI, 0x80(SP)		
  0x42d914		488b89a8000000		MOVQ 0xa8(CX), CX		
  0x42d91b		48898c24c0000000	MOVQ CX, 0xc0(SP)		
  0x42d923		e8d841ffff		CALL runtime.printlock(SB)	
  0x42d928		488d054fc30300		LEAQ 0x3c34f(IP), AX		
  0x42d92f		48890424		MOVQ AX, 0(SP)			
  0x42d933		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42d93c		e8ff4affff		CALL runtime.printstring(SB)	
  0x42d941		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x42d949		48890424		MOVQ AX, 0(SP)			
  0x42d94d		e82e49ffff		CALL runtime.printint(SB)	
  0x42d952		488d0591c70300		LEAQ 0x3c791(IP), AX		
  0x42d959		48890424		MOVQ AX, 0(SP)			
  0x42d95d		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42d966		e8d54affff		CALL runtime.printstring(SB)	
  0x42d96b		8b442418		MOVL 0x18(SP), AX		
  0x42d96f		89c0			MOVL AX, AX			
  0x42d971		48890424		MOVQ AX, 0(SP)			
  0x42d975		e8f647ffff		CALL runtime.printuint(SB)	
  0x42d97a		488d05d0c20300		LEAQ 0x3c2d0(IP), AX		
  0x42d981		48890424		MOVQ AX, 0(SP)			
  0x42d985		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42d98e		e8ad4affff		CALL runtime.printstring(SB)	
  0x42d993		488b8424c0000000	MOVQ 0xc0(SP), AX		
  0x42d99b		48890424		MOVQ AX, 0(SP)			
  0x42d99f		488b842480000000	MOVQ 0x80(SP), AX		
  0x42d9a7		4889442408		MOVQ AX, 0x8(SP)		
  0x42d9ac		e88f4affff		CALL runtime.printstring(SB)	
  0x42d9b1		488d052ac30300		LEAQ 0x3c32a(IP), AX		
  0x42d9b8		48890424		MOVQ AX, 0(SP)			
  0x42d9bc		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x42d9c5		e8764affff		CALL runtime.printstring(SB)	
  0x42d9ca		488b442448		MOVQ 0x48(SP), AX		
  0x42d9cf		48890424		MOVQ AX, 0(SP)			
  0x42d9d3		e8a848ffff		CALL runtime.printint(SB)	
  0x42d9d8		488d0596c60300		LEAQ 0x3c696(IP), AX		
  0x42d9df		48890424		MOVQ AX, 0(SP)			
  0x42d9e3		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42d9ec		e84f4affff		CALL runtime.printstring(SB)	
  0x42d9f1		488b442438		MOVQ 0x38(SP), AX		
  0x42d9f6		48890424		MOVQ AX, 0(SP)			
  0x42d9fa		e88148ffff		CALL runtime.printint(SB)	
  0x42d9ff		e88c43ffff		CALL runtime.printnl(SB)	
  0x42da04		e87741ffff		CALL runtime.printunlock(SB)	
  0x42da09		488b442460		MOVQ 0x60(SP), AX		
	for gi := 0; gi < len(allgs); gi++ {
  0x42da0e		48ffc0			INCQ AX				
  0x42da11		488b0d789c0700		MOVQ runtime.allgs(SB), CX	
  0x42da18		488b15799c0700		MOVQ runtime.allgs+8(SB), DX	
  0x42da1f		4839d0			CMPQ DX, AX			
  0x42da22		7d4b			JGE 0x42da6f			
		gp := allgs[gi]
  0x42da24		488b0cc1		MOVQ 0(CX)(AX*8), CX	
		mp := gp.m
  0x42da28		488b5130		MOVQ 0x30(CX), DX	
		lockedm := gp.lockedm.ptr()
  0x42da2c		488b99e0000000		MOVQ 0xe0(CX), BX	
		if mp != nil {
  0x42da33		4885d2			TESTQ DX, DX		
  0x42da36		742e			JE 0x42da66		
			id1 = mp.id
  0x42da38		488b92e0000000		MOVQ 0xe0(DX), DX	
  0x42da3f		4889442460		MOVQ AX, 0x60(SP)	
  0x42da44		4889542448		MOVQ DX, 0x48(SP)	
		if lockedm != nil {
  0x42da49		4885db			TESTQ BX, BX		
  0x42da4c		740c			JE 0x42da5a		
			id2 = lockedm.id
  0x42da4e		488b9be0000000		MOVQ 0xe0(BX), BX	
  0x42da55		e98dfeffff		JMP 0x42d8e7		
  0x42da5a		48c7c3ffffffff		MOVQ $-0x1, BX		
		if lockedm != nil {
  0x42da61		e981feffff		JMP 0x42d8e7		
  0x42da66		48c7c2ffffffff		MOVQ $-0x1, DX		
		if mp != nil {
  0x42da6d		ebd0			JMP 0x42da3f		
	unlock(&allglock)
  0x42da6f		488d05a25e0900		LEAQ runtime.allglock(SB), AX	
  0x42da76		48890424		MOVQ AX, 0(SP)			
  0x42da7a		e841bcfdff		CALL runtime.unlock(SB)		
	unlock(&sched.lock)
  0x42da7f		488d05aa9e0700		LEAQ runtime.sched+16(SB), AX	
  0x42da86		48890424		MOVQ AX, 0(SP)			
  0x42da8a		e831bcfdff		CALL runtime.unlock(SB)		
}
  0x42da8f		488bac24d0000000	MOVQ 0xd0(SP), BP	
  0x42da97		4881c4d8000000		ADDQ $0xd8, SP		
  0x42da9e		c3			RET			
		unlock(&sched.lock)
  0x42da9f		488d058a9e0700		LEAQ runtime.sched+16(SB), AX	
  0x42daa6		48890424		MOVQ AX, 0(SP)			
  0x42daaa		e811bcfdff		CALL runtime.unlock(SB)		
		return
  0x42daaf		488bac24d0000000	MOVQ 0xd0(SP), BP	
  0x42dab7		4881c4d8000000		ADDQ $0xd8, SP		
  0x42dabe		c3			RET			
		print(" gcwaiting=", sched.gcwaiting, " nmidlelocked=", sched.nmidlelocked, " stopwait=", sched.stopwait, " sysmonwait=", sched.sysmonwait, "\n")
  0x42dabf		8b05439f0700		MOVL runtime.sched+232(SB), AX		
  0x42dac5		48898424a0000000	MOVQ AX, 0xa0(SP)			
  0x42dacd		48630d289f0700		MOVSXD runtime.sched+220(SB), CX	
  0x42dad4		48898c24b0000000	MOVQ CX, 0xb0(SP)			
  0x42dadc		486315619e0700		MOVSXD runtime.sched+36(SB), DX		
  0x42dae3		48899424a8000000	MOVQ DX, 0xa8(SP)			
  0x42daeb		8b1d079f0700		MOVL runtime.sched+216(SB), BX		
  0x42daf1		48899c2498000000	MOVQ BX, 0x98(SP)			
  0x42daf9		e80240ffff		CALL runtime.printlock(SB)		
  0x42dafe		488d05a9c80300		LEAQ 0x3c8a9(IP), AX			
  0x42db05		48890424		MOVQ AX, 0(SP)				
  0x42db09		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x42db12		e82949ffff		CALL runtime.printstring(SB)		
  0x42db17		488b842498000000	MOVQ 0x98(SP), AX			
  0x42db1f		48890424		MOVQ AX, 0(SP)				
  0x42db23		e84846ffff		CALL runtime.printuint(SB)		
  0x42db28		488d05afcc0300		LEAQ 0x3ccaf(IP), AX			
  0x42db2f		48890424		MOVQ AX, 0(SP)				
  0x42db33		48c74424080e000000	MOVQ $0xe, 0x8(SP)			
  0x42db3c		e8ff48ffff		CALL runtime.printstring(SB)		
  0x42db41		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x42db49		48890424		MOVQ AX, 0(SP)				
  0x42db4d		e82e47ffff		CALL runtime.printint(SB)		
  0x42db52		488d0577c70300		LEAQ 0x3c777(IP), AX			
  0x42db59		48890424		MOVQ AX, 0(SP)				
  0x42db5d		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x42db66		e8d548ffff		CALL runtime.printstring(SB)		
  0x42db6b		488b8424b0000000	MOVQ 0xb0(SP), AX			
  0x42db73		48890424		MOVQ AX, 0(SP)				
  0x42db77		e80447ffff		CALL runtime.printint(SB)		
  0x42db7c		488d05efc90300		LEAQ 0x3c9ef(IP), AX			
  0x42db83		48890424		MOVQ AX, 0(SP)				
  0x42db87		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x42db90		e8ab48ffff		CALL runtime.printstring(SB)		
  0x42db95		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x42db9d		48890424		MOVQ AX, 0(SP)				
  0x42dba1		e8ca45ffff		CALL runtime.printuint(SB)		
  0x42dba6		e8e541ffff		CALL runtime.printnl(SB)		
  0x42dbab		e8d03fffff		CALL runtime.printunlock(SB)		
  0x42dbb0		0fb68424e0000000	MOVZX 0xe0(SP), AX			
  0x42dbb8		e957f7ffff		JMP 0x42d314				
func schedtrace(detailed bool) {
  0x42dbbd		e8ae690100		CALL runtime.morestack_noctxt(SB)	
  0x42dbc2		e929f5ffff		JMP runtime.schedtrace(SB)		

TEXT runtime.mput(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func mput(mp *m) {
  0x42dbd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42dbd9		483b6110		CMPQ 0x10(CX), SP	
  0x42dbdd		7643			JBE 0x42dc22		
  0x42dbdf		4883ec08		SUBQ $0x8, SP		
  0x42dbe3		48892c24		MOVQ BP, 0(SP)		
  0x42dbe7		488d2c24		LEAQ 0(SP), BP		
	mp.schedlink = sched.midle
  0x42dbeb		488b05469d0700		MOVQ runtime.sched+24(SB), AX	
  0x42dbf2		488b4c2410		MOVQ 0x10(SP), CX		
  0x42dbf7		48898158010000		MOVQ AX, 0x158(CX)		
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42dbfe		488d05339d0700		LEAQ runtime.sched+24(SB), AX	
  0x42dc05		8400			TESTB AL, 0(AX)			
  0x42dc07		48890d2a9d0700		MOVQ CX, runtime.sched+24(SB)	
	sched.nmidle++
  0x42dc0e		ff052c9d0700		INCL runtime.sched+32(SB)	
	checkdead()
  0x42dc14		e857e8ffff		CALL runtime.checkdead(SB)	
}
  0x42dc19		488b2c24		MOVQ 0(SP), BP		
  0x42dc1d		4883c408		ADDQ $0x8, SP		
  0x42dc21		c3			RET			
func mput(mp *m) {
  0x42dc22		e849690100		CALL runtime.morestack_noctxt(SB)	
  0x42dc27		eba7			JMP runtime.mput(SB)			

TEXT runtime.globrunqget(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func globrunqget(_p_ *p, max int32) *g {
  0x42dc30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42dc39		483b6110		CMPQ 0x10(CX), SP	
  0x42dc3d		0f861a010000		JBE 0x42dd5d		
  0x42dc43		4883ec30		SUBQ $0x30, SP		
  0x42dc47		48896c2428		MOVQ BP, 0x28(SP)	
  0x42dc4c		488d6c2428		LEAQ 0x28(SP), BP	
	if sched.runqsize == 0 {
  0x42dc51		8b05319d0700		MOVL runtime.sched+104(SB), AX	
  0x42dc57		85c0			TESTL AX, AX			
  0x42dc59		0f84e4000000		JE 0x42dd43			
	n := sched.runqsize/gomaxprocs + 1
  0x42dc5f		8b0d7b5c0900		MOVL runtime.gomaxprocs(SB), CX	
  0x42dc65		85c9			TESTL CX, CX			
  0x42dc67		0f84e9000000		JE 0x42dd56			
  0x42dc6d		89c2			MOVL AX, DX			
  0x42dc6f		89d3			MOVL DX, BX			
  0x42dc71		83f9ff			CMPL $-0x1, CX			
  0x42dc74		7405			JE 0x42dc7b			
  0x42dc76		99			CDQ				
  0x42dc77		f7f9			IDIVL CX			
  0x42dc79		eb05			JMP 0x42dc80			
  0x42dc7b		48f7d8			NEGQ AX				
  0x42dc7e		31d2			XORL DX, DX			
  0x42dc80		8d4801			LEAL 0x1(AX), CX		
	if n > sched.runqsize {
  0x42dc83		39d9			CMPL BX, CX		
  0x42dc85		0f8eaf000000		JLE 0x42dd3a		
  0x42dc8b		89d8			MOVL BX, AX		
		n = sched.runqsize
  0x42dc8d		8b4c2440		MOVL 0x40(SP), CX	
	if max > 0 && n > max {
  0x42dc91		85c9			TESTL CX, CX		
  0x42dc93		0f8e9a000000		JLE 0x42dd33		
  0x42dc99		39cb			CMPL CX, BX		
  0x42dc9b		0f8e92000000		JLE 0x42dd33		
	if n > int32(len(_p_.runq))/2 {
  0x42dca1		81f980000000		CMPL $0x80, CX		
  0x42dca7		7e05			JLE 0x42dcae		
  0x42dca9		b980000000		MOVL $0x80, CX		
	sched.runqsize -= n
  0x42dcae		29c8			SUBL CX, AX			
  0x42dcb0		8905d29c0700		MOVL AX, runtime.sched+104(SB)	
	if sched.runqsize == 0 {
  0x42dcb6		85c0			TESTL AX, AX		
  0x42dcb8		750b			JNE 0x42dcc5		
		sched.runqtail = 0
  0x42dcba		48c705bb9c070000000000	MOVQ $0x0, runtime.sched+96(SB)	
	gp := sched.runqhead.ptr()
  0x42dcc5		488b05ac9c0700		MOVQ runtime.sched+88(SB), AX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42dccc		4889442420		MOVQ AX, 0x20(SP)	
	sched.runqhead = gp.schedlink
  0x42dcd1		488b90b8000000		MOVQ 0xb8(AX), DX		
  0x42dcd8		488915999c0700		MOVQ DX, runtime.sched+88(SB)	
	n--
  0x42dcdf		ffc9			DECL CX			
	for ; n > 0; n-- {
  0x42dce1		eb3d			JMP 0x42dd20		
  0x42dce3		894c241c		MOVL CX, 0x1c(SP)	
		gp1 := sched.runqhead.ptr()
  0x42dce7		488b058a9c0700		MOVQ runtime.sched+88(SB), AX	
		sched.runqhead = gp1.schedlink
  0x42dcee		488b88b8000000		MOVQ 0xb8(AX), CX		
  0x42dcf5		48890d7c9c0700		MOVQ CX, runtime.sched+88(SB)	
  0x42dcfc		488b4c2438		MOVQ 0x38(SP), CX		
		runqput(_p_, gp1, false)
  0x42dd01		48890c24		MOVQ CX, 0(SP)			
  0x42dd05		4889442408		MOVQ AX, 0x8(SP)		
  0x42dd0a		c644241000		MOVB $0x0, 0x10(SP)		
  0x42dd0f		e83c010000		CALL runtime.runqput(SB)	
  0x42dd14		8b44241c		MOVL 0x1c(SP), AX		
	for ; n > 0; n-- {
  0x42dd18		8d48ff			LEAL -0x1(AX), CX	
  0x42dd1b		488b442420		MOVQ 0x20(SP), AX	
  0x42dd20		85c9			TESTL CX, CX		
  0x42dd22		7fbf			JG 0x42dce3		
	return gp
  0x42dd24		4889442448		MOVQ AX, 0x48(SP)	
  0x42dd29		488b6c2428		MOVQ 0x28(SP), BP	
  0x42dd2e		4883c430		ADDQ $0x30, SP		
  0x42dd32		c3			RET			
  0x42dd33		89d9			MOVL BX, CX		
	if max > 0 && n > max {
  0x42dd35		e967ffffff		JMP 0x42dca1		
  0x42dd3a		89d8			MOVL BX, AX		
  0x42dd3c		89cb			MOVL CX, BX		
	if n > sched.runqsize {
  0x42dd3e		e94affffff		JMP 0x42dc8d		
		return nil
  0x42dd43		48c744244800000000	MOVQ $0x0, 0x48(SP)	
  0x42dd4c		488b6c2428		MOVQ 0x28(SP), BP	
  0x42dd51		4883c430		ADDQ $0x30, SP		
  0x42dd55		c3			RET			
	n := sched.runqsize/gomaxprocs + 1
  0x42dd56		e8c51dffff		CALL runtime.panicdivide(SB)	
  0x42dd5b		0f0b			UD2				
func globrunqget(_p_ *p, max int32) *g {
  0x42dd5d		e80e680100		CALL runtime.morestack_noctxt(SB)	
  0x42dd62		e9c9feffff		JMP runtime.globrunqget(SB)		

TEXT runtime.pidleput(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func pidleput(_p_ *p) {
  0x42dd70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42dd79		483b6110		CMPQ 0x10(CX), SP	
  0x42dd7d		767a			JBE 0x42ddf9		
  0x42dd7f		4883ec18		SUBQ $0x18, SP		
  0x42dd83		48896c2410		MOVQ BP, 0x10(SP)	
  0x42dd88		488d6c2410		LEAQ 0x10(SP), BP	
  0x42dd8d		488b442420		MOVQ 0x20(SP), AX	
	if !runqempty(_p_) {
  0x42dd92		48890424		MOVQ AX, 0(SP)			
  0x42dd96		e875000000		CALL runtime.runqempty(SB)	
  0x42dd9b		0fb6442408		MOVZX 0x8(SP), AX		
  0x42dda0		84c0			TESTL AL, AL			
  0x42dda2		743a			JE 0x42ddde			
	_p_.link = sched.pidle
  0x42dda4		488b05bd9b0700		MOVQ runtime.sched+72(SB), AX	
  0x42ddab		488b4c2420		MOVQ 0x20(SP), CX		
  0x42ddb0		48894110		MOVQ AX, 0x10(CX)		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42ddb4		488d05ad9b0700		LEAQ runtime.sched+72(SB), AX	
  0x42ddbb		8400			TESTB AL, 0(AX)			
  0x42ddbd		48890da49b0700		MOVQ CX, runtime.sched+72(SB)	
	atomic.Xadd(&sched.npidle, 1) // TODO: fast atomic
  0x42ddc4		b801000000		MOVL $0x1, AX			
  0x42ddc9		488d0da09b0700		LEAQ runtime.sched+80(SB), CX	
  0x42ddd0		f00fc101		LOCK XADDL AX, 0(CX)		
}
  0x42ddd4		488b6c2410		MOVQ 0x10(SP), BP	
  0x42ddd9		4883c418		ADDQ $0x18, SP		
  0x42dddd		c3			RET			
		throw("pidleput: P has non-empty run queue")
  0x42ddde		488d05b3ef0300		LEAQ 0x3efb3(IP), AX	
  0x42dde5		48890424		MOVQ AX, 0(SP)		
  0x42dde9		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x42ddf2		e8d933ffff		CALL runtime.throw(SB)	
  0x42ddf7		0f0b			UD2			
func pidleput(_p_ *p) {
  0x42ddf9		e872670100		CALL runtime.morestack_noctxt(SB)	
  0x42ddfe		e96dffffff		JMP runtime.pidleput(SB)		

TEXT runtime.runqempty(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func runqempty(_p_ *p) bool {
  0x42de10		488b442408		MOVQ 0x8(SP), AX	
		head := atomic.Load(&_p_.runqhead)
  0x42de15		8b88e0050000		MOVL 0x5e0(AX), CX	
		tail := atomic.Load(&_p_.runqtail)
  0x42de1b		8b90e4050000		MOVL 0x5e4(AX), DX	
		runnext := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(&_p_.runnext)))
  0x42de21		488b98e80d0000		MOVQ 0xde8(AX), BX	
		if tail == atomic.Load(&_p_.runqtail) {
  0x42de28		8bb0e4050000		MOVL 0x5e4(AX), SI	
  0x42de2e		39d6			CMPL DX, SI		
  0x42de30		75e3			JNE 0x42de15		
			return head == tail && runnext == 0
  0x42de32		39ca			CMPL CX, DX		
  0x42de34		750b			JNE 0x42de41		
  0x42de36		4885db			TESTQ BX, BX		
  0x42de39		0f94c0			SETE AL			
  0x42de3c		88442410		MOVB AL, 0x10(SP)	
  0x42de40		c3			RET			
  0x42de41		31c0			XORL AX, AX		
  0x42de43		ebf7			JMP 0x42de3c		

TEXT runtime.runqput(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func runqput(_p_ *p, gp *g, next bool) {
  0x42de50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42de59		483b6110		CMPQ 0x10(CX), SP	
  0x42de5d		0f86dd000000		JBE 0x42df40		
  0x42de63		4883ec38		SUBQ $0x38, SP		
  0x42de67		48896c2430		MOVQ BP, 0x30(SP)	
  0x42de6c		488d6c2430		LEAQ 0x30(SP), BP	
  0x42de71		0fb64c2450		MOVZX 0x50(SP), CX	
  0x42de76		84c9			TESTL CL, CL		
	if next {
  0x42de78		0f84b3000000		JE 0x42df31		
  0x42de7e		488b4c2440		MOVQ 0x40(SP), CX	
  0x42de83		488b542448		MOVQ 0x48(SP), DX	
		oldnext := _p_.runnext
  0x42de88		eb03			JMP 0x42de8d		
  0x42de8a		4889da			MOVQ BX, DX		
  0x42de8d		488b81e80d0000		MOVQ 0xde8(CX), AX	
  0x42de94		4889442420		MOVQ AX, 0x20(SP)	
  0x42de99		4889d3			MOVQ DX, BX		
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x42de9c		f0480fb191e80d0000	LOCK CMPXCHGQ DX, 0xde8(CX)	
  0x42dea5		0f94c2			SETE DL				
  0x42dea8		84d2			TESTL DL, DL			
		if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
  0x42deaa		74de			JE 0x42de8a		
  0x42deac		488b442420		MOVQ 0x20(SP), AX	
		if oldnext == 0 {
  0x42deb1		4885c0			TESTQ AX, AX		
  0x42deb4		7471			JE 0x42df27		
		gp = oldnext.ptr()
  0x42deb6		4889442428		MOVQ AX, 0x28(SP)	
	h := atomic.Load(&_p_.runqhead) // load-acquire, synchronize with consumers
  0x42debb		eb0a			JMP 0x42dec7		
  0x42debd		488b442428		MOVQ 0x28(SP), AX	
  0x42dec2		488b4c2440		MOVQ 0x40(SP), CX	
  0x42dec7		8b91e0050000		MOVL 0x5e0(CX), DX	
	t := _p_.runqtail
  0x42decd		8b99e4050000		MOVL 0x5e4(CX), BX	
  0x42ded3		89de			MOVL BX, SI		
	if t-h < uint32(len(_p_.runq)) {
  0x42ded5		29d3			SUBL DX, BX		
  0x42ded7		81fb00010000		CMPL $0x100, BX		
  0x42dedd		7229			JB 0x42df08		
	if runqputslow(_p_, gp, h, t) {
  0x42dedf		48890c24		MOVQ CX, 0(SP)			
  0x42dee3		4889442408		MOVQ AX, 0x8(SP)		
  0x42dee8		89542410		MOVL DX, 0x10(SP)		
  0x42deec		89742414		MOVL SI, 0x14(SP)		
  0x42def0		e85b000000		CALL runtime.runqputslow(SB)	
  0x42def5		0fb6442418		MOVZX 0x18(SP), AX		
  0x42defa		84c0			TESTL AL, AL			
  0x42defc		74bf			JE 0x42debd			
		return
  0x42defe		488b6c2430		MOVQ 0x30(SP), BP	
  0x42df03		4883c438		ADDQ $0x38, SP		
  0x42df07		c3			RET			
		_p_.runq[t%uint32(len(_p_.runq))].set(gp)
  0x42df08		400fb6d6		MOVZX SI, DX		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42df0c		488984d1e8050000	MOVQ AX, 0x5e8(CX)(DX*8)	
		atomic.Store(&_p_.runqtail, t+1) // store-release, makes the item available for consumption
  0x42df14		8d4601			LEAL 0x1(SI), AX	
  0x42df17		8781e4050000		XCHGL AX, 0x5e4(CX)	
		return
  0x42df1d		488b6c2430		MOVQ 0x30(SP), BP	
  0x42df22		4883c438		ADDQ $0x38, SP		
  0x42df26		c3			RET			
			return
  0x42df27		488b6c2430		MOVQ 0x30(SP), BP	
  0x42df2c		4883c438		ADDQ $0x38, SP		
  0x42df30		c3			RET			
  0x42df31		488b4c2440		MOVQ 0x40(SP), CX	
  0x42df36		488b442448		MOVQ 0x48(SP), AX	
	if next {
  0x42df3b		e976ffffff		JMP 0x42deb6		
func runqput(_p_ *p, gp *g, next bool) {
  0x42df40		e82b660100		CALL runtime.morestack_noctxt(SB)	
  0x42df45		e906ffffff		JMP runtime.runqput(SB)			

TEXT runtime.runqputslow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
  0x42df50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42df59		488d842458fcffff	LEAQ 0xfffffc58(SP), AX	
  0x42df61		483b4110		CMPQ 0x10(CX), AX	
  0x42df65		0f86f8010000		JBE 0x42e163		
  0x42df6b		4881ec28040000		SUBQ $0x428, SP		
  0x42df72		4889ac2420040000	MOVQ BP, 0x420(SP)	
  0x42df7a		488dac2420040000	LEAQ 0x420(SP), BP	
	var batch [len(_p_.runq)/2 + 1]*g
  0x42df82		48c744241800000000	MOVQ $0x0, 0x18(SP)		
  0x42df8b		488d7c2420		LEAQ 0x20(SP), DI		
  0x42df90		0f57c0			XORPS X0, X0			
  0x42df93		48896c24f0		MOVQ BP, -0x10(SP)		
  0x42df98		488d6c24f0		LEAQ -0x10(SP), BP		
  0x42df9d		e8fe890100		CALL runtime.duffzero(SB)	
  0x42dfa2		488b6d00		MOVQ 0(BP), BP			
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
  0x42dfa6		8b8c2444040000		MOVL 0x444(SP), CX	
  0x42dfad		8b842440040000		MOVL 0x440(SP), AX	
	n := t - h
  0x42dfb4		29c1			SUBL AX, CX		
	n = n / 2
  0x42dfb6		d1e9			SHRL $0x1, CX		
	if n != uint32(len(_p_.runq)/2) {
  0x42dfb8		81f980000000		CMPL $0x80, CX		
  0x42dfbe		0f8584010000		JNE 0x42e148		
  0x42dfc4		488b942430040000	MOVQ 0x430(SP), DX	
  0x42dfcc		31db			XORL BX, BX		
	for i := uint32(0); i < n; i++ {
  0x42dfce		eb0e			JMP 0x42dfde		
  0x42dfd0		89df			MOVL BX, DI		
		batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()
  0x42dfd2		48c1e303		SHLQ $0x3, BX		
  0x42dfd6		4889741c18		MOVQ SI, 0x18(SP)(BX*1)	
	for i := uint32(0); i < n; i++ {
  0x42dfdb		8d5f01			LEAL 0x1(DI), BX	
  0x42dfde		39cb			CMPL CX, BX		
  0x42dfe0		731f			JAE 0x42e001		
		batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()
  0x42dfe2		8402			TESTB AL, 0(DX)			
  0x42dfe4		8d3403			LEAL 0(BX)(AX*1), SI		
  0x42dfe7		400fb6f6		MOVZX SI, SI			
  0x42dfeb		488bb4f2e8050000	MOVQ 0x5e8(DX)(SI*8), SI	
  0x42dff3		4881fb81000000		CMPQ $0x81, BX			
  0x42dffa		72d4			JB 0x42dfd0			
  0x42dffc		e940010000		JMP 0x42e141			
	if !atomic.Cas(&_p_.runqhead, h, h+n) { // cas-release, commits consume
  0x42e001		8d1c01			LEAL 0(CX)(AX*1), BX		
  0x42e004		f00fb19ae0050000	LOCK CMPXCHGL BX, 0x5e0(DX)	
  0x42e00c		0f94c2			SETE DL				
  0x42e00f		84d2			TESTL DL, DL			
  0x42e011		0f8404010000		JE 0x42e11b			
	batch[n] = gp
  0x42e017		4881f981000000		CMPQ $0x81, CX		
  0x42e01e		0f8316010000		JAE 0x42e13a		
  0x42e024		89c8			MOVL CX, AX		
  0x42e026		48c1e103		SHLQ $0x3, CX		
  0x42e02a		488b942438040000	MOVQ 0x438(SP), DX	
  0x42e032		4889540c18		MOVQ DX, 0x18(SP)(CX*1)	
  0x42e037		31c9			XORL CX, CX		
	for i := uint32(0); i < n; i++ {
  0x42e039		eb15			JMP 0x42e050		
		batch[i].schedlink.set(batch[i+1])
  0x42e03b		488d9ab8000000		LEAQ 0xb8(DX), BX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42e042		8403			TESTB AL, 0(BX)		
		batch[i].schedlink.set(batch[i+1])
  0x42e044		488b5ccc18		MOVQ 0x18(SP)(CX*8), BX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42e049		48899ab8000000		MOVQ BX, 0xb8(DX)	
	for i := uint32(0); i < n; i++ {
  0x42e050		39c1			CMPL AX, CX		
  0x42e052		7324			JAE 0x42e078		
		batch[i].schedlink.set(batch[i+1])
  0x42e054		4881f981000000		CMPQ $0x81, CX		
  0x42e05b		0f83d2000000		JAE 0x42e133		
  0x42e061		488b54cc18		MOVQ 0x18(SP)(CX*8), DX	
  0x42e066		8402			TESTB AL, 0(DX)		
  0x42e068		ffc1			INCL CX			
  0x42e06a		4881f981000000		CMPQ $0x81, CX		
  0x42e071		72c8			JB 0x42e03b		
  0x42e073		e9bb000000		JMP 0x42e133		
  0x42e078		89442414		MOVL AX, 0x14(SP)	
	lock(&sched.lock)
  0x42e07c		488d05ad980700		LEAQ runtime.sched+16(SB), AX	
  0x42e083		48890424		MOVQ AX, 0(SP)			
  0x42e087		e894b4fdff		CALL runtime.lock(SB)		
  0x42e08c		8b442414		MOVL 0x14(SP), AX		
	globrunqputbatch(batch[0], batch[n], int32(n+1))
  0x42e090		488b4cc418		MOVQ 0x18(SP)(AX*8), CX	
  0x42e095		488b542418		MOVQ 0x18(SP), DX	
	gtail.schedlink = 0
  0x42e09a		48c781b800000000000000	MOVQ $0x0, 0xb8(CX)	
	if sched.runqtail != 0 {
  0x42e0a5		488b1dd4980700		MOVQ runtime.sched+96(SB), BX	
  0x42e0ac		4885db			TESTQ BX, BX			
  0x42e0af		7458			JE 0x42e109			
		sched.runqtail.ptr().schedlink.set(ghead)
  0x42e0b1		488db3b8000000		LEAQ 0xb8(BX), SI	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42e0b8		8406			TESTB AL, 0(SI)			
  0x42e0ba		488993b8000000		MOVQ DX, 0xb8(BX)		
  0x42e0c1		488d15b8980700		LEAQ runtime.sched+96(SB), DX	
  0x42e0c8		8402			TESTB AL, 0(DX)			
  0x42e0ca		48890daf980700		MOVQ CX, runtime.sched+96(SB)	
	sched.runqsize += n
  0x42e0d1		8b0db1980700		MOVL runtime.sched+104(SB), CX	
  0x42e0d7		01c8			ADDL CX, AX			
  0x42e0d9		ffc0			INCL AX				
  0x42e0db		8905a7980700		MOVL AX, runtime.sched+104(SB)	
	unlock(&sched.lock)
  0x42e0e1		488d0548980700		LEAQ runtime.sched+16(SB), AX	
  0x42e0e8		48890424		MOVQ AX, 0(SP)			
  0x42e0ec		e8cfb5fdff		CALL runtime.unlock(SB)		
	return true
  0x42e0f1		c684244804000001	MOVB $0x1, 0x448(SP)	
  0x42e0f9		488bac2420040000	MOVQ 0x420(SP), BP	
  0x42e101		4881c428040000		ADDQ $0x428, SP		
  0x42e108		c3			RET			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42e109		488d1d68980700		LEAQ runtime.sched+88(SB), BX	
  0x42e110		8403			TESTB AL, 0(BX)			
  0x42e112		4889155f980700		MOVQ DX, runtime.sched+88(SB)	
	sched.runqtail.set(gtail)
  0x42e119		eba6			JMP 0x42e0c1		
		return false
  0x42e11b		c684244804000000	MOVB $0x0, 0x448(SP)	
  0x42e123		488bac2420040000	MOVQ 0x420(SP), BP	
  0x42e12b		4881c428040000		ADDQ $0x428, SP		
  0x42e132		c3			RET			
		batch[i].schedlink.set(batch[i+1])
  0x42e133		e80819ffff		CALL runtime.panicindex(SB)	
  0x42e138		0f0b			UD2				
	batch[n] = gp
  0x42e13a		e80119ffff		CALL runtime.panicindex(SB)	
  0x42e13f		0f0b			UD2				
		batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()
  0x42e141		e8fa18ffff		CALL runtime.panicindex(SB)	
  0x42e146		0f0b			UD2				
		throw("runqputslow: queue is not full")
  0x42e148		488d052ae40300		LEAQ 0x3e42a(IP), AX	
  0x42e14f		48890424		MOVQ AX, 0(SP)		
  0x42e153		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x42e15c		e86f30ffff		CALL runtime.throw(SB)	
  0x42e161		0f0b			UD2			
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
  0x42e163		e808640100		CALL runtime.morestack_noctxt(SB)	
  0x42e168		e9e3fdffff		JMP runtime.runqputslow(SB)		

TEXT runtime.runqget(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func runqget(_p_ *p) (gp *g, inheritTime bool) {
  0x42e170		4883ec10		SUBQ $0x10, SP		
  0x42e174		48896c2408		MOVQ BP, 0x8(SP)	
  0x42e179		488d6c2408		LEAQ 0x8(SP), BP	
  0x42e17e		488b4c2418		MOVQ 0x18(SP), CX	
		next := _p_.runnext
  0x42e183		488b81e80d0000		MOVQ 0xde8(CX), AX	
		if next == 0 {
  0x42e18a		4885c0			TESTQ AX, AX		
  0x42e18d		742e			JE 0x42e1bd		
  0x42e18f		48890424		MOVQ AX, 0(SP)		
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x42e193		31d2			XORL DX, DX			
  0x42e195		f0480fb191e80d0000	LOCK CMPXCHGQ DX, 0xde8(CX)	
  0x42e19e		0f94c3			SETE BL				
  0x42e1a1		84db			TESTL BL, BL			
		if _p_.runnext.cas(next, 0) {
  0x42e1a3		74de			JE 0x42e183		
  0x42e1a5		488b0424		MOVQ 0(SP), AX		
			return next.ptr(), true
  0x42e1a9		4889442420		MOVQ AX, 0x20(SP)	
  0x42e1ae		c644242801		MOVB $0x1, 0x28(SP)	
  0x42e1b3		488b6c2408		MOVQ 0x8(SP), BP	
  0x42e1b8		4883c410		ADDQ $0x10, SP		
  0x42e1bc		c3			RET			
		h := atomic.Load(&_p_.runqhead) // load-acquire, synchronize with other consumers
  0x42e1bd		8b91e0050000		MOVL 0x5e0(CX), DX	
		t := _p_.runqtail
  0x42e1c3		8b99e4050000		MOVL 0x5e4(CX), BX	
		if t == h {
  0x42e1c9		39d3			CMPL DX, BX		
  0x42e1cb		7433			JE 0x42e200		
		gp := _p_.runq[h%uint32(len(_p_.runq))].ptr()
  0x42e1cd		0fb6da			MOVZX DL, BX			
  0x42e1d0		488b9cd9e8050000	MOVQ 0x5e8(CX)(BX*8), BX	
		if atomic.Cas(&_p_.runqhead, h, h+1) { // cas-release, commits consume
  0x42e1d8		8d7201			LEAL 0x1(DX), SI	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42e1db		89d0			MOVL DX, AX		
		if atomic.Cas(&_p_.runqhead, h, h+1) { // cas-release, commits consume
  0x42e1dd		f00fb1b1e0050000	LOCK CMPXCHGL SI, 0x5e0(CX)	
  0x42e1e5		0f94c2			SETE DL				
  0x42e1e8		84d2			TESTL DL, DL			
  0x42e1ea		74d1			JE 0x42e1bd			
			return gp, false
  0x42e1ec		48895c2420		MOVQ BX, 0x20(SP)	
  0x42e1f1		c644242800		MOVB $0x0, 0x28(SP)	
  0x42e1f6		488b6c2408		MOVQ 0x8(SP), BP	
  0x42e1fb		4883c410		ADDQ $0x10, SP		
  0x42e1ff		c3			RET			
			return nil, false
  0x42e200		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x42e209		c644242800		MOVB $0x0, 0x28(SP)	
  0x42e20e		488b6c2408		MOVQ 0x8(SP), BP	
  0x42e213		4883c410		ADDQ $0x10, SP		
  0x42e217		c3			RET			

TEXT runtime.runqgrab(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
  0x42e220		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e229		483b6110		CMPQ 0x10(CX), SP	
  0x42e22d		0f8632010000		JBE 0x42e365		
  0x42e233		4883ec18		SUBQ $0x18, SP		
  0x42e237		48896c2410		MOVQ BP, 0x10(SP)	
  0x42e23c		488d6c2410		LEAQ 0x10(SP), BP	
	for {
  0x42e241		488b4c2420		MOVQ 0x20(SP), CX	
		h := atomic.Load(&_p_.runqhead) // load-acquire, synchronize with other consumers
  0x42e246		8b91e0050000		MOVL 0x5e0(CX), DX	
		t := atomic.Load(&_p_.runqtail) // load-acquire, synchronize with the producer
  0x42e24c		8b99e4050000		MOVL 0x5e4(CX), BX	
		n := t - h
  0x42e252		29d3			SUBL DX, BX		
  0x42e254		89de			MOVL BX, SI		
		n = n - n/2
  0x42e256		d1eb			SHRL $0x1, BX		
  0x42e258		29de			SUBL BX, SI		
		if n == 0 {
  0x42e25a		85f6			TESTL SI, SI		
  0x42e25c		0f858e000000		JNE 0x42e2f0		
  0x42e262		0fb6542434		MOVZX 0x34(SP), DX	
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
  0x42e267		84d2			TESTL DL, DL		
			if stealRunNextG {
  0x42e269		7473			JE 0x42e2de		
				if next := _p_.runnext; next != 0 {
  0x42e26b		488b81e80d0000		MOVQ 0xde8(CX), AX	
  0x42e272		4885c0			TESTQ AX, AX		
  0x42e275		7467			JE 0x42e2de		
  0x42e277		4889442408		MOVQ AX, 0x8(SP)	
					if _p_.status == _Prunning {
  0x42e27c		8b590c			MOVL 0xc(CX), BX	
  0x42e27f		83fb01			CMPL $0x1, BX		
  0x42e282		743d			JE 0x42e2c1		
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x42e284		31db			XORL BX, BX			
  0x42e286		f0480fb199e80d0000	LOCK CMPXCHGQ BX, 0xde8(CX)	
  0x42e28f		400f94c6		SETE SI				
  0x42e293		4084f6			TESTL SI, SI			
					if !_p_.runnext.cas(next, 0) {
  0x42e296		74a9			JE 0x42e241		
  0x42e298		488b442428		MOVQ 0x28(SP), AX	
					batch[batchHead%uint32(len(batch))] = next
  0x42e29d		8400			TESTB AL, 0(AX)		
  0x42e29f		8b4c2430		MOVL 0x30(SP), CX	
  0x42e2a3		0fb6c9			MOVZX CL, CX		
  0x42e2a6		488b542408		MOVQ 0x8(SP), DX	
  0x42e2ab		488914c8		MOVQ DX, 0(AX)(CX*8)	
					return 1
  0x42e2af		c744243801000000	MOVL $0x1, 0x38(SP)	
  0x42e2b7		488b6c2410		MOVQ 0x10(SP), BP	
  0x42e2bc		4883c418		ADDQ $0x18, SP		
  0x42e2c0		c3			RET			
							usleep(3)
  0x42e2c1		c7042403000000		MOVL $0x3, 0(SP)	
  0x42e2c8		e8e3950100		CALL runtime.usleep(SB)	
  0x42e2cd		488b442408		MOVQ 0x8(SP), AX	
  0x42e2d2		488b4c2420		MOVQ 0x20(SP), CX	
  0x42e2d7		0fb6542434		MOVZX 0x34(SP), DX	
					if !_p_.runnext.cas(next, 0) {
  0x42e2dc		eba6			JMP 0x42e284		
			return 0
  0x42e2de		c744243800000000	MOVL $0x0, 0x38(SP)	
  0x42e2e6		488b6c2410		MOVQ 0x10(SP), BP	
  0x42e2eb		4883c418		ADDQ $0x18, SP		
  0x42e2ef		c3			RET			
		if n > uint32(len(_p_.runq)/2) { // read inconsistent h and t
  0x42e2f0		81fe80000000		CMPL $0x80, SI		
  0x42e2f6		760c			JBE 0x42e304		
  0x42e2f8		0fb6542434		MOVZX 0x34(SP), DX	
  0x42e2fd		31db			XORL BX, BX		
			continue
  0x42e2ff		e93dffffff		JMP 0x42e241		
  0x42e304		488b5c2428		MOVQ 0x28(SP), BX	
  0x42e309		8b7c2430		MOVL 0x30(SP), DI	
  0x42e30d		31c0			XORL AX, AX		
		for i := uint32(0); i < n; i++ {
  0x42e30f		eb20			JMP 0x42e331		
			batch[(batchHead+i)%uint32(len(batch))] = g
  0x42e311		8403			TESTB AL, 0(BX)		
			g := _p_.runq[(h+i)%uint32(len(_p_.runq))]
  0x42e313		448d0410		LEAL 0(AX)(DX*1), R8		
  0x42e317		450fb6c0		MOVZX R8, R8			
  0x42e31b		4e8b84c1e8050000	MOVQ 0x5e8(CX)(R8*8), R8	
			batch[(batchHead+i)%uint32(len(batch))] = g
  0x42e323		448d0c38		LEAL 0(AX)(DI*1), R9	
  0x42e327		450fb6c9		MOVZX R9, R9		
  0x42e32b		4e8904cb		MOVQ R8, 0(BX)(R9*8)	
		for i := uint32(0); i < n; i++ {
  0x42e32f		ffc0			INCL AX			
  0x42e331		39f0			CMPL SI, AX		
  0x42e333		72dc			JB 0x42e311		
		if atomic.Cas(&_p_.runqhead, h, h+n) { // cas-release, commits consume
  0x42e335		448d0416		LEAL 0(SI)(DX*1), R8		
  0x42e339		89d0			MOVL DX, AX			
  0x42e33b		f0440fb181e0050000	LOCK CMPXCHGL R8, 0x5e0(CX)	
  0x42e344		0f94c2			SETE DL				
  0x42e347		84d2			TESTL DL, DL			
  0x42e349		750c			JNE 0x42e357			
  0x42e34b		0fb6542434		MOVZX 0x34(SP), DX		
  0x42e350		31db			XORL BX, BX			
		h := atomic.Load(&_p_.runqhead) // load-acquire, synchronize with other consumers
  0x42e352		e9eafeffff		JMP 0x42e241		
			return n
  0x42e357		89742438		MOVL SI, 0x38(SP)	
  0x42e35b		488b6c2410		MOVQ 0x10(SP), BP	
  0x42e360		4883c418		ADDQ $0x18, SP		
  0x42e364		c3			RET			
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
  0x42e365		e806620100		CALL runtime.morestack_noctxt(SB)	
  0x42e36a		e9b1feffff		JMP runtime.runqgrab(SB)		

TEXT runtime.runqsteal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {
  0x42e370		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e379		483b6110		CMPQ 0x10(CX), SP	
  0x42e37d		0f86cf000000		JBE 0x42e452		
  0x42e383		4883ec30		SUBQ $0x30, SP		
  0x42e387		48896c2428		MOVQ BP, 0x28(SP)	
  0x42e38c		488d6c2428		LEAQ 0x28(SP), BP	
  0x42e391		488b442438		MOVQ 0x38(SP), AX	
	t := _p_.runqtail
  0x42e396		8b88e4050000		MOVL 0x5e4(AX), CX	
  0x42e39c		894c2424		MOVL CX, 0x24(SP)	
	n := runqgrab(p2, &_p_.runq, t, stealRunNextG)
  0x42e3a0		488d90e8050000		LEAQ 0x5e8(AX), DX	
  0x42e3a7		4889542408		MOVQ DX, 0x8(SP)	
func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {
  0x42e3ac		488b542440		MOVQ 0x40(SP), DX	
	n := runqgrab(p2, &_p_.runq, t, stealRunNextG)
  0x42e3b1		48891424		MOVQ DX, 0(SP)		
  0x42e3b5		894c2410		MOVL CX, 0x10(SP)	
func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {
  0x42e3b9		0fb6542448		MOVZX 0x48(SP), DX	
	n := runqgrab(p2, &_p_.runq, t, stealRunNextG)
  0x42e3be		88542414		MOVB DL, 0x14(SP)		
  0x42e3c2		e859feffff		CALL runtime.runqgrab(SB)	
  0x42e3c7		8b442418		MOVL 0x18(SP), AX		
	if n == 0 {
  0x42e3cb		85c0			TESTL AX, AX		
  0x42e3cd		7455			JE 0x42e424		
  0x42e3cf		8b4c2424		MOVL 0x24(SP), CX	
	gp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr()
  0x42e3d3		8d1408			LEAL 0(AX)(CX*1), DX		
  0x42e3d6		ffca			DECL DX				
  0x42e3d8		0fb6da			MOVZX DL, BX			
  0x42e3db		488b742438		MOVQ 0x38(SP), SI		
  0x42e3e0		488b9cdee8050000	MOVQ 0x5e8(SI)(BX*8), BX	
	if n == 0 {
  0x42e3e8		83f801			CMPL $0x1, AX		
  0x42e3eb		7428			JE 0x42e415		
	h := atomic.Load(&_p_.runqhead) // load-acquire, synchronize with consumers
  0x42e3ed		8bbee0050000		MOVL 0x5e0(SI), DI	
	if t-h+n >= uint32(len(_p_.runq)) {
  0x42e3f3		29f9			SUBL DI, CX		
  0x42e3f5		01c8			ADDL CX, AX		
  0x42e3f7		ffc8			DECL AX			
  0x42e3f9		3d00010000		CMPL $0x100, AX		
  0x42e3fe		7337			JAE 0x42e437		
	atomic.Store(&_p_.runqtail, t+n) // store-release, makes the item available for consumption
  0x42e400		8796e4050000		XCHGL DX, 0x5e4(SI)	
	return gp
  0x42e406		48895c2450		MOVQ BX, 0x50(SP)	
  0x42e40b		488b6c2428		MOVQ 0x28(SP), BP	
  0x42e410		4883c430		ADDQ $0x30, SP		
  0x42e414		c3			RET			
		return gp
  0x42e415		48895c2450		MOVQ BX, 0x50(SP)	
  0x42e41a		488b6c2428		MOVQ 0x28(SP), BP	
  0x42e41f		4883c430		ADDQ $0x30, SP		
  0x42e423		c3			RET			
		return nil
  0x42e424		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x42e42d		488b6c2428		MOVQ 0x28(SP), BP	
  0x42e432		4883c430		ADDQ $0x30, SP		
  0x42e436		c3			RET			
		throw("runqsteal: runq overflow")
  0x42e437		488d05c8d40300		LEAQ 0x3d4c8(IP), AX	
  0x42e43e		48890424		MOVQ AX, 0(SP)		
  0x42e442		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x42e44b		e8802dffff		CALL runtime.throw(SB)	
  0x42e450		0f0b			UD2			
func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {
  0x42e452		e819610100		CALL runtime.morestack_noctxt(SB)	
  0x42e457		e914ffffff		JMP runtime.runqsteal(SB)		

TEXT runtime.(*randomOrder).reset(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func (ord *randomOrder) reset(count uint32) {
  0x42e460		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e469		483b6110		CMPQ 0x10(CX), SP	
  0x42e46d		0f8603010000		JBE 0x42e576		
  0x42e473		4883ec58		SUBQ $0x58, SP		
  0x42e477		48896c2450		MOVQ BP, 0x50(SP)	
  0x42e47c		488d6c2450		LEAQ 0x50(SP), BP	
  0x42e481		8b442468		MOVL 0x68(SP), AX	
  0x42e485		488b4c2460		MOVQ 0x60(SP), CX	
	ord.count = count
  0x42e48a		8901			MOVL AX, 0(CX)		
	ord.coprimes = ord.coprimes[:0]
  0x42e48c		48c7411000000000	MOVQ $0x0, 0x10(CX)	
  0x42e494		ba01000000		MOVL $0x1, DX		
	for i := uint32(1); i <= count; i++ {
  0x42e499		eb0c			JMP 0x42e4a7		
  0x42e49b		8d5301			LEAL 0x1(BX), DX	
  0x42e49e		8b442468		MOVL 0x68(SP), AX	
  0x42e4a2		488b4c2460		MOVQ 0x60(SP), CX	
  0x42e4a7		39c2			CMPL AX, DX		
  0x42e4a9		0f87bd000000		JA 0x42e56c		
  0x42e4af		89542444		MOVL DX, 0x44(SP)	
		if gcd(i, count) == 1 {
  0x42e4b3		891424			MOVL DX, 0(SP)		
  0x42e4b6		89442404		MOVL AX, 0x4(SP)	
  0x42e4ba		e8c1000000		CALL runtime.gcd(SB)	
  0x42e4bf		8b442408		MOVL 0x8(SP), AX	
  0x42e4c3		83f801			CMPL $0x1, AX		
  0x42e4c6		0f8592000000		JNE 0x42e55e		
  0x42e4cc		488b442460		MOVQ 0x60(SP), AX	
			ord.coprimes = append(ord.coprimes, i)
  0x42e4d1		488b4810		MOVQ 0x10(AX), CX			
  0x42e4d5		488b5008		MOVQ 0x8(AX), DX			
  0x42e4d9		488b5818		MOVQ 0x18(AX), BX			
  0x42e4dd		488d7008		LEAQ 0x8(AX), SI			
  0x42e4e1		488d7901		LEAQ 0x1(CX), DI			
  0x42e4e5		4839df			CMPQ BX, DI				
  0x42e4e8		7f11			JG 0x42e4fb				
  0x42e4ea		488d5901		LEAQ 0x1(CX), BX			
  0x42e4ee		48895810		MOVQ BX, 0x10(AX)			
  0x42e4f2		8b5c2444		MOVL 0x44(SP), BX			
  0x42e4f6		891c8a			MOVL BX, 0(DX)(CX*4)			
  0x42e4f9		eba0			JMP 0x42e49b				
  0x42e4fb		4889742448		MOVQ SI, 0x48(SP)			
  0x42e500		488d05598f0200		LEAQ 0x28f59(IP), AX			
  0x42e507		48890424		MOVQ AX, 0(SP)				
  0x42e50b		4889542408		MOVQ DX, 0x8(SP)			
  0x42e510		48894c2410		MOVQ CX, 0x10(SP)			
  0x42e515		48895c2418		MOVQ BX, 0x18(SP)			
  0x42e51a		48897c2420		MOVQ DI, 0x20(SP)			
  0x42e51f		e83c530000		CALL runtime.growslice(SB)		
  0x42e524		488b442428		MOVQ 0x28(SP), AX			
  0x42e529		488b4c2430		MOVQ 0x30(SP), CX			
  0x42e52e		488b542438		MOVQ 0x38(SP), DX			
  0x42e533		488b5c2460		MOVQ 0x60(SP), BX			
  0x42e538		48895318		MOVQ DX, 0x18(BX)			
  0x42e53c		8b15ce540900		MOVL runtime.writeBarrier(SB), DX	
  0x42e542		85d2			TESTL DX, DX				
  0x42e544		750c			JNE 0x42e552				
  0x42e546		48894308		MOVQ AX, 0x8(BX)			
  0x42e54a		4889c2			MOVQ AX, DX				
  0x42e54d		4889d8			MOVQ BX, AX				
  0x42e550		eb98			JMP 0x42e4ea				
  0x42e552		488b7c2448		MOVQ 0x48(SP), DI			
  0x42e557		e844830100		CALL runtime.gcWriteBarrier(SB)		
  0x42e55c		ebec			JMP 0x42e54a				
  0x42e55e		488b442460		MOVQ 0x60(SP), AX			
  0x42e563		8b5c2444		MOVL 0x44(SP), BX			
	for i := uint32(1); i <= count; i++ {
  0x42e567		e92fffffff		JMP 0x42e49b		
  0x42e56c		488b6c2450		MOVQ 0x50(SP), BP	
  0x42e571		4883c458		ADDQ $0x58, SP		
  0x42e575		c3			RET			
func (ord *randomOrder) reset(count uint32) {
  0x42e576		e8f55f0100		CALL runtime.morestack_noctxt(SB)	
  0x42e57b		e9e0feffff		JMP runtime.(*randomOrder).reset(SB)	

TEXT runtime.gcd(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
func gcd(a, b uint32) uint32 {
  0x42e580		8b4c2408		MOVL 0x8(SP), CX	
  0x42e584		8b54240c		MOVL 0xc(SP), DX	
	for b != 0 {
  0x42e588		eb0a			JMP 0x42e594		
  0x42e58a		89c8			MOVL CX, AX		
  0x42e58c		89d3			MOVL DX, BX		
		a, b = b, a%b
  0x42e58e		31d2			XORL DX, DX		
  0x42e590		f7f3			DIVL BX			
  0x42e592		89d9			MOVL BX, CX		
	for b != 0 {
  0x42e594		85d2			TESTL DX, DX		
  0x42e596		75f2			JNE 0x42e58a		
	return a
  0x42e598		894c2410		MOVL CX, 0x10(SP)	
  0x42e59c		c3			RET			

TEXT runtime.(*profBuf).takeOverflow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/profbuf.go
func (b *profBuf) takeOverflow() (count uint32, time uint64) {
  0x42e5a0		4883ec10		SUBQ $0x10, SP		
  0x42e5a4		48896c2408		MOVQ BP, 0x8(SP)	
  0x42e5a9		488d6c2408		LEAQ 0x8(SP), BP	
  0x42e5ae		488b4c2418		MOVQ 0x18(SP), CX	
	overflow := atomic.Load64(&b.overflow)
  0x42e5b3		488b5110		MOVQ 0x10(CX), DX	
	time = atomic.Load64(&b.overflowTime)
  0x42e5b7		488b5918		MOVQ 0x18(CX), BX	
	for {
  0x42e5bb		eb0e			JMP 0x42e5cb		
		overflow = atomic.Load64(&b.overflow)
  0x42e5bd		488b7110		MOVQ 0x10(CX), SI	
		time = atomic.Load64(&b.overflowTime)
  0x42e5c1		488b7918		MOVQ 0x18(CX), DI	
  0x42e5c5		4889f2			MOVQ SI, DX		
  0x42e5c8		4889fb			MOVQ DI, BX		
		count = uint32(overflow)
  0x42e5cb		48891424		MOVQ DX, 0(SP)		
		if count == 0 {
  0x42e5cf		85d2			TESTL DX, DX		
  0x42e5d1		7432			JE 0x42e605		
  0x42e5d3		4889d0			MOVQ DX, AX		
		if atomic.Cas64(&b.overflow, overflow, ((overflow>>32)+1)<<32) {
  0x42e5d6		48c1ea20		SHRQ $0x20, DX			
  0x42e5da		48ffc2			INCQ DX				
  0x42e5dd		48c1e220		SHLQ $0x20, DX			
  0x42e5e1		f0480fb15110		LOCK CMPXCHGQ DX, 0x10(CX)	
  0x42e5e7		0f94c2			SETE DL				
  0x42e5ea		84d2			TESTL DL, DL			
  0x42e5ec		74cf			JE 0x42e5bd			
	return uint32(overflow), time
  0x42e5ee		488b0424		MOVQ 0(SP), AX		
  0x42e5f2		89442420		MOVL AX, 0x20(SP)	
  0x42e5f6		48895c2428		MOVQ BX, 0x28(SP)	
  0x42e5fb		488b6c2408		MOVQ 0x8(SP), BP	
  0x42e600		4883c410		ADDQ $0x10, SP		
  0x42e604		c3			RET			
  0x42e605		31db			XORL BX, BX		
			break
  0x42e607		ebe5			JMP 0x42e5ee		

TEXT runtime.(*profBuf).incrementOverflow(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/profbuf.go
func (b *profBuf) incrementOverflow(now int64) {
  0x42e610		488b4c2408		MOVQ 0x8(SP), CX	
		overflow := atomic.Load64(&b.overflow)
  0x42e615		488b5110		MOVQ 0x10(CX), DX	
		if uint32(overflow) == 0 {
  0x42e619		85d2			TESTL DX, DX		
  0x42e61b		741a			JE 0x42e637		
		if int32(overflow) == -1 {
  0x42e61d		83faff			CMPL $-0x1, DX		
  0x42e620		7414			JE 0x42e636		
		if atomic.Cas64(&b.overflow, overflow, overflow+1) {
  0x42e622		488d5a01		LEAQ 0x1(DX), BX		
  0x42e626		4889d0			MOVQ DX, AX			
  0x42e629		f0480fb15910		LOCK CMPXCHGQ BX, 0x10(CX)	
  0x42e62f		0f94c2			SETE DL				
  0x42e632		84d2			TESTL DL, DL			
  0x42e634		74df			JE 0x42e615			
  0x42e636		c3			RET				
  0x42e637		488b442410		MOVQ 0x10(SP), AX		
			atomic.Store64(&b.overflowTime, uint64(now))
  0x42e63c		48874118		XCHGQ AX, 0x18(CX)	
			atomic.Store64(&b.overflow, (((overflow>>32)+1)<<32)+1)
  0x42e640		48c1ea20		SHRQ $0x20, DX		
  0x42e644		488d4201		LEAQ 0x1(DX), AX	
  0x42e648		48c1e020		SHLQ $0x20, AX		
  0x42e64c		48ffc0			INCQ AX			
  0x42e64f		48874110		XCHGQ AX, 0x10(CX)	
			break
  0x42e653		ebe1			JMP 0x42e636		

TEXT runtime.(*profBuf).canWriteRecord(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/profbuf.go
func (b *profBuf) canWriteRecord(nstk int) bool {
  0x42e660		4883ec08		SUBQ $0x8, SP		
  0x42e664		48892c24		MOVQ BP, 0(SP)		
  0x42e668		488d2c24		LEAQ 0(SP), BP		
  0x42e66c		488b4c2410		MOVQ 0x10(SP), CX	
	return profIndex(atomic.Load64((*uint64)(x)))
  0x42e671		488b11			MOVQ 0(CX), DX		
  0x42e674		488b5908		MOVQ 0x8(CX), BX	
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 1 {
  0x42e678		488b7150		MOVQ 0x50(CX), SI	
  0x42e67c		4889d7			MOVQ DX, DI		
	return uint32(x >> 34)
  0x42e67f		48c1ea22		SHRQ $0x22, DX		
  0x42e683		4889d8			MOVQ BX, AX		
  0x42e686		48c1eb22		SHRQ $0x22, BX		
	return int(int32(x-y) << 2 >> 2)
  0x42e68a		29da			SUBL BX, DX		
  0x42e68c		c1e202			SHLL $0x2, DX		
  0x42e68f		c1fa02			SARL $0x2, DX		
  0x42e692		4863d2			MOVSXD DX, DX		
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 1 {
  0x42e695		4801f2			ADDQ SI, DX		
  0x42e698		4883fa01		CMPQ $0x1, DX		
  0x42e69c		7c50			JL 0x42e6ee		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x42e69e		488b5138		MOVQ 0x38(CX), DX	
	return int(int32(x-y) << 2 >> 2)
  0x42e6a2		29c7			SUBL AX, DI		
  0x42e6a4		c1e702			SHLL $0x2, DI		
  0x42e6a7		c1ff02			SARL $0x2, DI		
  0x42e6aa		4863df			MOVSXD DI, BX		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x42e6ad		4801d3			ADDQ DX, BX		
  0x42e6b0		488b742418		MOVQ 0x18(SP), SI	
	want := 2 + int(b.hdrsize) + nstk
  0x42e6b5		48037128		ADDQ 0x28(CX), SI	
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x42e6b9		85d2			TESTL DX, DX		
  0x42e6bb		743f			JE 0x42e6fc		
  0x42e6bd		4889d1			MOVQ DX, CX		
  0x42e6c0		31d2			XORL DX, DX		
  0x42e6c2		f7f1			DIVL CX			
  0x42e6c4		89d2			MOVL DX, DX		
	if i+want > len(b.data) {
  0x42e6c6		488d7c3202		LEAQ 0x2(DX)(SI*1), DI	
  0x42e6cb		4839cf			CMPQ CX, DI		
  0x42e6ce		7e06			JLE 0x42e6d6		
		nd -= len(b.data) - i
  0x42e6d0		4829d1			SUBQ DX, CX		
  0x42e6d3		4829cb			SUBQ CX, BX		
	want := 2 + int(b.hdrsize) + nstk
  0x42e6d6		488d4602		LEAQ 0x2(SI), AX	
	return nd >= want
  0x42e6da		4839c3			CMPQ AX, BX		
  0x42e6dd		488d442420		LEAQ 0x20(SP), AX	
  0x42e6e2		0f9d00			SETGE 0(AX)		
  0x42e6e5		488b2c24		MOVQ 0(SP), BP		
  0x42e6e9		4883c408		ADDQ $0x8, SP		
  0x42e6ed		c3			RET			
		return false
  0x42e6ee		c644242000		MOVB $0x0, 0x20(SP)	
  0x42e6f3		488b2c24		MOVQ 0(SP), BP		
  0x42e6f7		4883c408		ADDQ $0x8, SP		
  0x42e6fb		c3			RET			
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x42e6fc		e81f14ffff		CALL runtime.panicdivide(SB)	
  0x42e701		0f0b			UD2				

TEXT runtime.(*profBuf).canWriteTwoRecords(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/profbuf.go
func (b *profBuf) canWriteTwoRecords(nstk1, nstk2 int) bool {
  0x42e710		4883ec08		SUBQ $0x8, SP		
  0x42e714		48892c24		MOVQ BP, 0(SP)		
  0x42e718		488d2c24		LEAQ 0(SP), BP		
  0x42e71c		488b4c2410		MOVQ 0x10(SP), CX	
	return profIndex(atomic.Load64((*uint64)(x)))
  0x42e721		488b11			MOVQ 0(CX), DX		
  0x42e724		488b5908		MOVQ 0x8(CX), BX	
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 2 {
  0x42e728		488b7150		MOVQ 0x50(CX), SI	
  0x42e72c		4889d7			MOVQ DX, DI		
	return uint32(x >> 34)
  0x42e72f		48c1ea22		SHRQ $0x22, DX		
  0x42e733		4889d8			MOVQ BX, AX		
  0x42e736		48c1eb22		SHRQ $0x22, BX		
	return int(int32(x-y) << 2 >> 2)
  0x42e73a		29da			SUBL BX, DX		
  0x42e73c		c1e202			SHLL $0x2, DX		
  0x42e73f		c1fa02			SARL $0x2, DX		
  0x42e742		4863d2			MOVSXD DX, DX		
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 2 {
  0x42e745		4801f2			ADDQ SI, DX		
  0x42e748		4883fa02		CMPQ $0x2, DX		
  0x42e74c		0f8c8a000000		JL 0x42e7dc		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x42e752		488b5138		MOVQ 0x38(CX), DX	
	return int(int32(x-y) << 2 >> 2)
  0x42e756		29c7			SUBL AX, DI		
  0x42e758		c1e702			SHLL $0x2, DI		
  0x42e75b		c1ff02			SARL $0x2, DI		
  0x42e75e		4863df			MOVSXD DI, BX		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x42e761		4801d3			ADDQ DX, BX		
	want := 2 + int(b.hdrsize) + nstk1
  0x42e764		488b4928		MOVQ 0x28(CX), CX	
  0x42e768		488b742418		MOVQ 0x18(SP), SI	
  0x42e76d		488d3c31		LEAQ 0(CX)(SI*1), DI	
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x42e771		85d2			TESTL DX, DX		
  0x42e773		7475			JE 0x42e7ea		
  0x42e775		4989d0			MOVQ DX, R8		
  0x42e778		31d2			XORL DX, DX		
  0x42e77a		41f7f0			DIVL R8			
  0x42e77d		89d2			MOVL DX, DX		
	if i+want > len(b.data) {
  0x42e77f		4c8d4c1702		LEAQ 0x2(DI)(DX*1), R9	
  0x42e784		4d39c1			CMPQ R8, R9		
  0x42e787		7e4e			JLE 0x42e7d7		
  0x42e789		4c89c0			MOVQ R8, AX		
		nd -= len(b.data) - i
  0x42e78c		4929d0			SUBQ DX, R8		
  0x42e78f		4c29c3			SUBQ R8, BX		
  0x42e792		31d2			XORL DX, DX		
	want := 2 + int(b.hdrsize) + nstk1
  0x42e794		488d743102		LEAQ 0x2(CX)(SI*1), SI	
	i += want
  0x42e799		4c8d0417		LEAQ 0(DI)(DX*1), R8	
	nd -= want
  0x42e79d		4829f3			SUBQ SI, BX		
  0x42e7a0		488b742420		MOVQ 0x20(SP), SI	
	want = 2 + int(b.hdrsize) + nstk2
  0x42e7a5		4c8d0c31		LEAQ 0(CX)(SI*1), R9	
	if i+want > len(b.data) {
  0x42e7a9		4f8d440104		LEAQ 0x4(R9)(R8*1), R8	
  0x42e7ae		4939c0			CMPQ AX, R8		
  0x42e7b1		7e0b			JLE 0x42e7be		
	i += want
  0x42e7b3		488d541702		LEAQ 0x2(DI)(DX*1), DX	
		nd -= len(b.data) - i
  0x42e7b8		4829d0			SUBQ DX, AX		
  0x42e7bb		4829c3			SUBQ AX, BX		
	want = 2 + int(b.hdrsize) + nstk2
  0x42e7be		488d443102		LEAQ 0x2(CX)(SI*1), AX	
	return nd >= want
  0x42e7c3		4839c3			CMPQ AX, BX		
  0x42e7c6		488d442428		LEAQ 0x28(SP), AX	
  0x42e7cb		0f9d00			SETGE 0(AX)		
  0x42e7ce		488b2c24		MOVQ 0(SP), BP		
  0x42e7d2		4883c408		ADDQ $0x8, SP		
  0x42e7d6		c3			RET			
  0x42e7d7		4c89c0			MOVQ R8, AX		
	i += want
  0x42e7da		ebb8			JMP 0x42e794		
		return false
  0x42e7dc		c644242800		MOVB $0x0, 0x28(SP)	
  0x42e7e1		488b2c24		MOVQ 0(SP), BP		
  0x42e7e5		4883c408		ADDQ $0x8, SP		
  0x42e7e9		c3			RET			
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x42e7ea		e83113ffff		CALL runtime.panicdivide(SB)	
  0x42e7ef		0f0b			UD2				

TEXT runtime.(*profBuf).write(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/profbuf.go
func (b *profBuf) write(tagPtr *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr) {
  0x42e800		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e809		483b6110		CMPQ 0x10(CX), SP	
  0x42e80d		0f8636040000		JBE 0x42ec49		
  0x42e813		4881ec80000000		SUBQ $0x80, SP		
  0x42e81a		48896c2478		MOVQ BP, 0x78(SP)	
  0x42e81f		488d6c2478		LEAQ 0x78(SP), BP	
  0x42e824		488b842488000000	MOVQ 0x88(SP), AX	
	if b == nil {
  0x42e82c		4885c0			TESTQ AX, AX		
  0x42e82f		0f84a6030000		JE 0x42ebdb		
	if len(hdr) > int(b.hdrsize) {
  0x42e835		488b4828		MOVQ 0x28(AX), CX	
  0x42e839		488b9424a8000000	MOVQ 0xa8(SP), DX	
  0x42e841		4839ca			CMPQ CX, DX		
  0x42e844		0f8fe4030000		JG 0x42ec2e		
	return uint32(atomic.Load64(&b.overflow)) > 0
  0x42e84a		488b4810		MOVQ 0x10(AX), CX	
  0x42e84e		85c9			TESTL CX, CX		
	if hasOverflow := b.hasOverflow(); hasOverflow && b.canWriteTwoRecords(1, len(stk)) {
  0x42e850		0f87bb020000		JA 0x42eb11		
	} else if hasOverflow || !b.canWriteRecord(len(stk)) {
  0x42e856		0f8779020000		JA 0x42ead5					
  0x42e85c		48890424		MOVQ AX, 0(SP)					
  0x42e860		488b8c24c0000000	MOVQ 0xc0(SP), CX				
  0x42e868		48894c2408		MOVQ CX, 0x8(SP)				
  0x42e86d		e8eefdffff		CALL runtime.(*profBuf).canWriteRecord(SB)	
  0x42e872		0fb6442410		MOVZX 0x10(SP), AX				
  0x42e877		84c0			TESTL AL, AL					
  0x42e879		0f8456020000		JE 0x42ead5					
  0x42e87f		488b8c2488000000	MOVQ 0x88(SP), CX				
	return profIndex(atomic.Load64((*uint64)(x)))
  0x42e887		488b11			MOVQ 0(CX), DX		
  0x42e88a		488b5108		MOVQ 0x8(CX), DX	
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x42e88e		488b5950		MOVQ 0x50(CX), BX	
  0x42e892		488b7148		MOVQ 0x48(CX), SI	
  0x42e896		85db			TESTL BX, BX		
  0x42e898		0f8489030000		JE 0x42ec27		
  0x42e89e		4889d0			MOVQ DX, AX		
	return uint32(x >> 34)
  0x42e8a1		48c1e822		SHRQ $0x22, AX		
  0x42e8a5		4889d7			MOVQ DX, DI		
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x42e8a8		31d2			XORL DX, DX		
  0x42e8aa		f7f3			DIVL BX			
  0x42e8ac		4c8b842490000000	MOVQ 0x90(SP), R8	
	if tagPtr != nil {
  0x42e8b4		4d85c0			TESTQ R8, R8		
  0x42e8b7		7412			JE 0x42e8cb		
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x42e8b9		89d2			MOVL DX, DX		
		*(*uintptr)(unsafe.Pointer(&b.tags[wt])) = uintptr(unsafe.Pointer(*tagPtr))
  0x42e8bb		4839da			CMPQ BX, DX		
  0x42e8be		0f835c030000		JAE 0x42ec20		
  0x42e8c4		498b18			MOVQ 0(R8), BX		
  0x42e8c7		48891cd6		MOVQ BX, 0(SI)(DX*8)	
	wd := int(bw.dataCount() % uint32(len(b.data)))
  0x42e8cb		488b5138		MOVQ 0x38(CX), DX	
  0x42e8cf		488b5930		MOVQ 0x30(CX), BX	
  0x42e8d3		85d2			TESTL DX, DX		
  0x42e8d5		0f843e030000		JE 0x42ec19		
  0x42e8db		4889f8			MOVQ DI, AX		
  0x42e8de		4889d6			MOVQ DX, SI		
  0x42e8e1		31d2			XORL DX, DX		
  0x42e8e3		f7f6			DIVL SI			
  0x42e8e5		89d2			MOVL DX, DX		
	if wd+2+int(b.hdrsize)+len(stk) > len(b.data) {
  0x42e8e7		488b7928		MOVQ 0x28(CX), DI	
  0x42e8eb		4801d7			ADDQ DX, DI		
  0x42e8ee		4c8b8424c0000000	MOVQ 0xc0(SP), R8	
  0x42e8f6		4a8d7c0702		LEAQ 0x2(DI)(R8*1), DI	
  0x42e8fb		4839f7			CMPQ SI, DI		
  0x42e8fe		0f8eca010000		JLE 0x42eace		
		b.data[wd] = 0
  0x42e904		4839f2			CMPQ SI, DX		
  0x42e907		0f8305030000		JAE 0x42ec12		
  0x42e90d		48c704d300000000	MOVQ $0x0, 0(BX)(DX*8)	
		skip = len(b.data) - wd
  0x42e915		488b4138		MOVQ 0x38(CX), AX	
  0x42e919		4829d0			SUBQ DX, AX		
  0x42e91c		31d2			XORL DX, DX		
	data := b.data[wd:]
  0x42e91e		488b5938		MOVQ 0x38(CX), BX	
  0x42e922		488b7140		MOVQ 0x40(CX), SI	
  0x42e926		488b7930		MOVQ 0x30(CX), DI	
  0x42e92a		4839da			CMPQ BX, DX		
  0x42e92d		0f87d8020000		JA 0x42ec0b		
  0x42e933		4829d3			SUBQ DX, BX		
  0x42e936		4829d6			SUBQ DX, SI		
  0x42e939		4989f1			MOVQ SI, R9		
  0x42e93c		48f7de			NEGQ SI			
  0x42e93f		48c1fe3f		SARQ $0x3f, SI		
  0x42e943		48c1e203		SHLQ $0x3, DX		
  0x42e947		4821d6			ANDQ DX, SI		
  0x42e94a		488d143e		LEAQ 0(SI)(DI*1), DX	
	data[0] = uint64(2 + b.hdrsize + uintptr(len(stk))) // length
  0x42e94e		4c8b5128		MOVQ 0x28(CX), R10		
  0x42e952		4885db			TESTQ BX, BX			
  0x42e955		0f86a9020000		JBE 0x42ec04			
  0x42e95b		4f8d541002		LEAQ 0x2(R8)(R10*1), R10	
  0x42e960		4c891437		MOVQ R10, 0(DI)(SI*1)		
	data[1] = uint64(now)                               // time stamp
  0x42e964		4883fb01		CMPQ $0x1, BX		
  0x42e968		0f868f020000		JBE 0x42ebfd		
  0x42e96e		4c8b942498000000	MOVQ 0x98(SP), R10	
  0x42e976		4c89543708		MOVQ R10, 0x8(DI)(SI*1)	
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x42e97b		488b7128		MOVQ 0x28(CX), SI		
  0x42e97f		488d7e02		LEAQ 0x2(SI), DI		
  0x42e983		4883ff02		CMPQ $0x2, DI			
  0x42e987		0f8269020000		JB 0x42ebf6			
  0x42e98d		4c39cf			CMPQ R9, DI			
  0x42e990		0f8760020000		JA 0x42ebf6			
  0x42e996		48895c2458		MOVQ BX, 0x58(SP)		
  0x42e99b		4889542470		MOVQ DX, 0x70(SP)		
  0x42e9a0		4889442450		MOVQ AX, 0x50(SP)		
  0x42e9a5		498d79fe		LEAQ -0x2(R9), DI		
  0x42e9a9		48f7df			NEGQ DI				
  0x42e9ac		48c1ff3f		SARQ $0x3f, DI			
  0x42e9b0		4883e710		ANDQ $0x10, DI			
  0x42e9b4		4801d7			ADDQ DX, DI			
  0x42e9b7		4c8b8c24a8000000	MOVQ 0xa8(SP), R9		
  0x42e9bf		4c39ce			CMPQ R9, SI			
  0x42e9c2		0f8efe000000		JLE 0x42eac6			
  0x42e9c8		4c894c2468		MOVQ R9, 0x68(SP)		
  0x42e9cd		48893c24		MOVQ DI, 0(SP)			
  0x42e9d1		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x42e9d9		4889442408		MOVQ AX, 0x8(SP)		
  0x42e9de		49c1e103		SHLQ $0x3, R9			
  0x42e9e2		4c894c2410		MOVQ R9, 0x10(SP)		
  0x42e9e7		e814870100		CALL runtime.memmove(SB)	
  0x42e9ec		488b442470		MOVQ 0x70(SP), AX		
  0x42e9f1		488b4c2458		MOVQ 0x58(SP), CX		
  0x42e9f6		488b942488000000	MOVQ 0x88(SP), DX		
  0x42e9fe		488b5c2468		MOVQ 0x68(SP), BX		
	for ; i < b.hdrsize; i++ {
  0x42ea03		eb0c			JMP 0x42ea11		
		data[2+i] = 0
  0x42ea05		48c744d81000000000	MOVQ $0x0, 0x10(AX)(BX*8)	
	for ; i < b.hdrsize; i++ {
  0x42ea0e		48ffc3			INCQ BX			
  0x42ea11		488b7228		MOVQ 0x28(DX), SI	
  0x42ea15		4839f3			CMPQ SI, BX		
  0x42ea18		730e			JAE 0x42ea28		
		data[2+i] = 0
  0x42ea1a		488d7302		LEAQ 0x2(BX), SI	
  0x42ea1e		4839ce			CMPQ CX, SI		
  0x42ea21		72e2			JB 0x42ea05		
  0x42ea23		e9c7010000		JMP 0x42ebef		
  0x42ea28		488b9c24c0000000	MOVQ 0xc0(SP), BX	
  0x42ea30		488bb424b8000000	MOVQ 0xb8(SP), SI	
  0x42ea38		31ff			XORL DI, DI		
	for i, pc := range stk {
  0x42ea3a		eb07			JMP 0x42ea43		
		data[2+b.hdrsize+uintptr(i)] = uint64(pc)
  0x42ea3c		4e8904c8		MOVQ R8, 0(AX)(R9*8)	
	for i, pc := range stk {
  0x42ea40		48ffc7			INCQ DI			
  0x42ea43		4839df			CMPQ BX, DI		
  0x42ea46		7d17			JGE 0x42ea5f		
  0x42ea48		4c8b04fe		MOVQ 0(SI)(DI*8), R8	
		data[2+b.hdrsize+uintptr(i)] = uint64(pc)
  0x42ea4c		4c8b4a28		MOVQ 0x28(DX), R9	
  0x42ea50		4d8d4c3902		LEAQ 0x2(R9)(DI*1), R9	
  0x42ea55		4939c9			CMPQ CX, R9		
  0x42ea58		72e2			JB 0x42ea3c		
  0x42ea5a		e989010000		JMP 0x42ebe8		
  0x42ea5f		488b4c2450		MOVQ 0x50(SP), CX	
	return profIndex(atomic.Load64((*uint64)(x)))
  0x42ea64		488b7208		MOVQ 0x8(DX), SI	
  0x42ea68		4889742460		MOVQ SI, 0x60(SP)	
		new := old.addCountsAndClearFlags(skip+2+len(stk)+int(b.hdrsize), 1)
  0x42ea6d		488d3c0b		LEAQ 0(BX)(CX*1), DI	
  0x42ea71		48037a28		ADDQ 0x28(DX), DI	
  0x42ea75		4883c702		ADDQ $0x2, DI		
  0x42ea79		4889f0			MOVQ SI, AX		
	return profIndex((uint64(x)>>34+uint64(uint32(tag)<<2>>2))<<34 | uint64(uint32(x)+uint32(data)))
  0x42ea7c		48c1ee22		SHRQ $0x22, SI		
  0x42ea80		48ffc6			INCQ SI			
  0x42ea83		48c1e622		SHLQ $0x22, SI		
  0x42ea87		01c7			ADDL AX, DI		
  0x42ea89		4809fe			ORQ DI, SI		
	return atomic.Cas64((*uint64)(x), uint64(old), uint64(new))
  0x42ea8c		f0480fb17208		LOCK CMPXCHGQ SI, 0x8(DX)	
  0x42ea92		400f94c6		SETE SI				
  0x42ea96		4084f6			TESTL SI, SI			
		if !b.w.cas(old, new) {
  0x42ea99		74c9			JE 0x42ea64		
  0x42ea9b		488b442460		MOVQ 0x60(SP), AX	
		if old&profReaderSleeping != 0 {
  0x42eaa0		480fbae020		BTQ $0x20, AX		
  0x42eaa5		720d			JB 0x42eab4		
  0x42eaa7		488b6c2478		MOVQ 0x78(SP), BP	
  0x42eaac		4881c480000000		ADDQ $0x80, SP		
  0x42eab3		c3			RET			
			notewakeup(&b.wait)
  0x42eab4		488d8280000000		LEAQ 0x80(DX), AX		
  0x42eabb		48890424		MOVQ AX, 0(SP)			
  0x42eabf		e8ccacfdff		CALL runtime.notewakeup(SB)	
  0x42eac4		ebe1			JMP 0x42eaa7			
  0x42eac6		4989f1			MOVQ SI, R9			
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x42eac9		e9fafeffff		JMP 0x42e9c8		
  0x42eace		31c0			XORL AX, AX		
	data := b.data[wd:]
  0x42ead0		e949feffff		JMP 0x42e91e		
  0x42ead5		488b842488000000	MOVQ 0x88(SP), AX	
		b.incrementOverflow(now)
  0x42eadd		48890424		MOVQ AX, 0(SP)					
  0x42eae1		488b8c2498000000	MOVQ 0x98(SP), CX				
  0x42eae9		48894c2408		MOVQ CX, 0x8(SP)				
  0x42eaee		e81dfbffff		CALL runtime.(*profBuf).incrementOverflow(SB)	
  0x42eaf3		488b842488000000	MOVQ 0x88(SP), AX				
		b.wakeupExtra()
  0x42eafb		48890424		MOVQ AX, 0(SP)				
  0x42eaff		e85c010000		CALL runtime.(*profBuf).wakeupExtra(SB)	
		return
  0x42eb04		488b6c2478		MOVQ 0x78(SP), BP	
  0x42eb09		4881c480000000		ADDQ $0x80, SP		
  0x42eb10		c3			RET			
  0x42eb11		48894c2460		MOVQ CX, 0x60(SP)	
	if hasOverflow := b.hasOverflow(); hasOverflow && b.canWriteTwoRecords(1, len(stk)) {
  0x42eb16		48890424		MOVQ AX, 0(SP)					
  0x42eb1a		48c744240801000000	MOVQ $0x1, 0x8(SP)				
  0x42eb23		488b8c24c0000000	MOVQ 0xc0(SP), CX				
  0x42eb2b		48894c2410		MOVQ CX, 0x10(SP)				
  0x42eb30		e8dbfbffff		CALL runtime.(*profBuf).canWriteTwoRecords(SB)	
  0x42eb35		0fb6442418		MOVZX 0x18(SP), AX				
  0x42eb3a		84c0			TESTL AL, AL					
  0x42eb3c		751c			JNE 0x42eb5a					
  0x42eb3e		488b4c2460		MOVQ 0x60(SP), CX				
	return uint32(atomic.Load64(&b.overflow)) > 0
  0x42eb43		85c9			TESTL CX, CX		
  0x42eb45		488b842488000000	MOVQ 0x88(SP), AX	
  0x42eb4d		488b9424a8000000	MOVQ 0xa8(SP), DX	
	if hasOverflow := b.hasOverflow(); hasOverflow && b.canWriteTwoRecords(1, len(stk)) {
  0x42eb55		e9fcfcffff		JMP 0x42e856		
  0x42eb5a		488b842488000000	MOVQ 0x88(SP), AX	
		count, time := b.takeOverflow()
  0x42eb62		48890424		MOVQ AX, 0(SP)					
  0x42eb66		e835faffff		CALL runtime.(*profBuf).takeOverflow(SB)	
  0x42eb6b		8b442408		MOVL 0x8(SP), AX				
  0x42eb6f		488b4c2410		MOVQ 0x10(SP), CX				
		if count > 0 {
  0x42eb74		85c0			TESTL AX, AX		
  0x42eb76		0f8603fdffff		JBE 0x42e87f		
			var stk [1]uintptr
  0x42eb7c		48c744244800000000	MOVQ $0x0, 0x48(SP)	
			stk[0] = uintptr(count)
  0x42eb85		4889442448		MOVQ AX, 0x48(SP)	
  0x42eb8a		488b842488000000	MOVQ 0x88(SP), AX	
			b.write(nil, int64(time), nil, stk[:])
  0x42eb92		48890424		MOVQ AX, 0(SP)				
  0x42eb96		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x42eb9f		48894c2410		MOVQ CX, 0x10(SP)			
  0x42eba4		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x42ebad		0f57c0			XORPS X0, X0				
  0x42ebb0		0f11442420		MOVUPS X0, 0x20(SP)			
  0x42ebb5		488d4c2448		LEAQ 0x48(SP), CX			
  0x42ebba		48894c2430		MOVQ CX, 0x30(SP)			
  0x42ebbf		48c744243801000000	MOVQ $0x1, 0x38(SP)			
  0x42ebc8		48c744244001000000	MOVQ $0x1, 0x40(SP)			
  0x42ebd1		e82afcffff		CALL runtime.(*profBuf).write(SB)	
  0x42ebd6		e9a4fcffff		JMP 0x42e87f				
		return
  0x42ebdb		488b6c2478		MOVQ 0x78(SP), BP	
  0x42ebe0		4881c480000000		ADDQ $0x80, SP		
  0x42ebe7		c3			RET			
		data[2+b.hdrsize+uintptr(i)] = uint64(pc)
  0x42ebe8		e8530effff		CALL runtime.panicindex(SB)	
  0x42ebed		0f0b			UD2				
		data[2+i] = 0
  0x42ebef		e84c0effff		CALL runtime.panicindex(SB)	
  0x42ebf4		0f0b			UD2				
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x42ebf6		e8b50effff		CALL runtime.panicslice(SB)	
  0x42ebfb		0f0b			UD2				
	data[1] = uint64(now)                               // time stamp
  0x42ebfd		e83e0effff		CALL runtime.panicindex(SB)	
  0x42ec02		0f0b			UD2				
	data[0] = uint64(2 + b.hdrsize + uintptr(len(stk))) // length
  0x42ec04		e8370effff		CALL runtime.panicindex(SB)	
  0x42ec09		0f0b			UD2				
	data := b.data[wd:]
  0x42ec0b		e8a00effff		CALL runtime.panicslice(SB)	
  0x42ec10		0f0b			UD2				
		b.data[wd] = 0
  0x42ec12		e8290effff		CALL runtime.panicindex(SB)	
  0x42ec17		0f0b			UD2				
	wd := int(bw.dataCount() % uint32(len(b.data)))
  0x42ec19		e8020fffff		CALL runtime.panicdivide(SB)	
  0x42ec1e		0f0b			UD2				
		*(*uintptr)(unsafe.Pointer(&b.tags[wt])) = uintptr(unsafe.Pointer(*tagPtr))
  0x42ec20		e81b0effff		CALL runtime.panicindex(SB)	
  0x42ec25		0f0b			UD2				
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x42ec27		e8f40effff		CALL runtime.panicdivide(SB)	
  0x42ec2c		0f0b			UD2				
		throw("misuse of profBuf.write")
  0x42ec2e		488d05a1ca0300		LEAQ 0x3caa1(IP), AX	
  0x42ec35		48890424		MOVQ AX, 0(SP)		
  0x42ec39		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x42ec42		e88925ffff		CALL runtime.throw(SB)	
  0x42ec47		0f0b			UD2			
func (b *profBuf) write(tagPtr *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr) {
  0x42ec49		e822590100		CALL runtime.morestack_noctxt(SB)	
  0x42ec4e		e9adfbffff		JMP runtime.(*profBuf).write(SB)	

TEXT runtime.(*profBuf).wakeupExtra(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/profbuf.go
func (b *profBuf) wakeupExtra() {
  0x42ec60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ec69		483b6110		CMPQ 0x10(CX), SP	
  0x42ec6d		7657			JBE 0x42ecc6		
  0x42ec6f		4883ec10		SUBQ $0x10, SP		
  0x42ec73		48896c2408		MOVQ BP, 0x8(SP)	
  0x42ec78		488d6c2408		LEAQ 0x8(SP), BP	
  0x42ec7d		488b4c2418		MOVQ 0x18(SP), CX	
	return profIndex(atomic.Load64((*uint64)(x)))
  0x42ec82		488b5108		MOVQ 0x8(CX), DX	
		new := old | profWriteExtra
  0x42ec86		48bb0000000002000000	MOVQ $0x200000000, BX	
  0x42ec90		4809d3			ORQ DX, BX		
  0x42ec93		4889d0			MOVQ DX, AX		
	return atomic.Cas64((*uint64)(x), uint64(old), uint64(new))
  0x42ec96		f0480fb15908		LOCK CMPXCHGQ BX, 0x8(CX)	
  0x42ec9c		0f94c3			SETE BL				
  0x42ec9f		84db			TESTL BL, BL			
		if !b.w.cas(old, new) {
  0x42eca1		74df			JE 0x42ec82		
		if old&profReaderSleeping != 0 {
  0x42eca3		480fbae220		BTQ $0x20, DX		
  0x42eca8		720a			JB 0x42ecb4		
  0x42ecaa		488b6c2408		MOVQ 0x8(SP), BP	
  0x42ecaf		4883c410		ADDQ $0x10, SP		
  0x42ecb3		c3			RET			
			notewakeup(&b.wait)
  0x42ecb4		488d8180000000		LEAQ 0x80(CX), AX		
  0x42ecbb		48890424		MOVQ AX, 0(SP)			
  0x42ecbf		e8ccaafdff		CALL runtime.notewakeup(SB)	
  0x42ecc4		ebe4			JMP 0x42ecaa			
func (b *profBuf) wakeupExtra() {
  0x42ecc6		e8a5580100		CALL runtime.morestack_noctxt(SB)	
  0x42eccb		eb93			JMP runtime.(*profBuf).wakeupExtra(SB)	

TEXT runtime.args(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func args(c int32, v **byte) {
  0x42ecd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ecd9		483b6110		CMPQ 0x10(CX), SP	
  0x42ecdd		7658			JBE 0x42ed37		
  0x42ecdf		4883ec18		SUBQ $0x18, SP		
  0x42ece3		48896c2410		MOVQ BP, 0x10(SP)	
  0x42ece8		488d6c2410		LEAQ 0x10(SP), BP	
  0x42eced		8b4c2420		MOVL 0x20(SP), CX	
	argc = c
  0x42ecf1		890dc94b0900		MOVL CX, runtime.argc(SB)	
	argv = v
  0x42ecf7		8b15134d0900		MOVL runtime.writeBarrier(SB), DX	
  0x42ecfd		85d2			TESTL DX, DX				
  0x42ecff		7523			JNE 0x42ed24				
  0x42ed01		488b442428		MOVQ 0x28(SP), AX			
  0x42ed06		48890513890700		MOVQ AX, runtime.argv(SB)		
	sysargs(c, v)
  0x42ed0d		890c24			MOVL CX, 0(SP)			
  0x42ed10		4889442408		MOVQ AX, 0x8(SP)		
  0x42ed15		e86603ffff		CALL runtime.sysargs(SB)	
}
  0x42ed1a		488b6c2410		MOVQ 0x10(SP), BP	
  0x42ed1f		4883c418		ADDQ $0x18, SP		
  0x42ed23		c3			RET			
	argv = v
  0x42ed24		488d3df5880700		LEAQ runtime.argv(SB), DI	
  0x42ed2b		488b442428		MOVQ 0x28(SP), AX		
  0x42ed30		e86b7b0100		CALL runtime.gcWriteBarrier(SB)	
  0x42ed35		ebd6			JMP 0x42ed0d			
func args(c int32, v **byte) {
  0x42ed37		e834580100		CALL runtime.morestack_noctxt(SB)	
  0x42ed3c		eb92			JMP runtime.args(SB)			

TEXT runtime.goargs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func goargs() {
  0x42ed40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ed49		483b6110		CMPQ 0x10(CX), SP	
  0x42ed4d		0f860d010000		JBE 0x42ee60		
  0x42ed53		4883ec40		SUBQ $0x40, SP		
  0x42ed57		48896c2438		MOVQ BP, 0x38(SP)	
  0x42ed5c		488d6c2438		LEAQ 0x38(SP), BP	
	argslice = make([]string, argc)
  0x42ed61		488d0538860200		LEAQ 0x28638(IP), AX			
  0x42ed68		48890424		MOVQ AX, 0(SP)				
  0x42ed6c		4863054d4b0900		MOVSXD runtime.argc(SB), AX		
  0x42ed73		4889442408		MOVQ AX, 0x8(SP)			
  0x42ed78		486305414b0900		MOVSXD runtime.argc(SB), AX		
  0x42ed7f		4889442410		MOVQ AX, 0x10(SP)			
  0x42ed84		e8d7490000		CALL runtime.makeslice(SB)		
  0x42ed89		488b442428		MOVQ 0x28(SP), AX			
  0x42ed8e		488b4c2420		MOVQ 0x20(SP), CX			
  0x42ed93		488b542418		MOVQ 0x18(SP), DX			
  0x42ed98		48890d39890700		MOVQ CX, runtime.argslice+8(SB)		
  0x42ed9f		4889053a890700		MOVQ AX, runtime.argslice+16(SB)	
  0x42eda6		8b05644c0900		MOVL runtime.writeBarrier(SB), AX	
  0x42edac		85c0			TESTL AX, AX				
  0x42edae		0f8591000000		JNE 0x42ee45				
  0x42edb4		48891515890700		MOVQ DX, runtime.argslice(SB)		
  0x42edbb		31c0			XORL AX, AX				
	for i := int32(0); i < argc; i++ {
  0x42edbd		eb03			JMP 0x42edc2			
  0x42edbf		8d4201			LEAL 0x1(DX), AX		
  0x42edc2		8b0df84a0900		MOVL runtime.argc(SB), CX	
  0x42edc8		39c8			CMPL CX, AX			
  0x42edca		7d6f			JGE 0x42ee3b			
  0x42edcc		89442434		MOVL AX, 0x34(SP)		
		argslice[i] = gostringnocopy(argv_index(argv, i))
  0x42edd0		488b0d49880700		MOVQ runtime.argv(SB), CX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x42edd7		4863d0			MOVSXD AX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x42edda		488d1cd1		LEAQ 0(CX)(DX*8), BX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x42edde		8403			TESTB AL, 0(BX)		
  0x42ede0		488b0cd1		MOVQ 0(CX)(DX*8), CX	
		argslice[i] = gostringnocopy(argv_index(argv, i))
  0x42ede4		48890c24		MOVQ CX, 0(SP)				
  0x42ede8		e803890000		CALL runtime.gostringnocopy(SB)		
  0x42eded		488b05e4880700		MOVQ runtime.argslice+8(SB), AX		
  0x42edf4		488b0dd5880700		MOVQ runtime.argslice(SB), CX		
  0x42edfb		8b542434		MOVL 0x34(SP), DX			
  0x42edff		4863da			MOVSXD DX, BX				
  0x42ee02		488b742410		MOVQ 0x10(SP), SI			
  0x42ee07		488b7c2408		MOVQ 0x8(SP), DI			
  0x42ee0c		4839c3			CMPQ AX, BX				
  0x42ee0f		7348			JAE 0x42ee59				
  0x42ee11		48c1e304		SHLQ $0x4, BX				
  0x42ee15		4889741908		MOVQ SI, 0x8(CX)(BX*1)			
  0x42ee1a		8b35f04b0900		MOVL runtime.writeBarrier(SB), SI	
  0x42ee20		4c8d0419		LEAQ 0(CX)(BX*1), R8			
  0x42ee24		85f6			TESTL SI, SI				
  0x42ee26		7506			JNE 0x42ee2e				
  0x42ee28		48893c19		MOVQ DI, 0(CX)(BX*1)			
  0x42ee2c		eb91			JMP 0x42edbf				
  0x42ee2e		4889f8			MOVQ DI, AX				
  0x42ee31		4c89c7			MOVQ R8, DI				
  0x42ee34		e8677a0100		CALL runtime.gcWriteBarrier(SB)		
  0x42ee39		eb84			JMP 0x42edbf				
  0x42ee3b		488b6c2438		MOVQ 0x38(SP), BP			
  0x42ee40		4883c440		ADDQ $0x40, SP				
  0x42ee44		c3			RET					
	argslice = make([]string, argc)
  0x42ee45		488d3d84880700		LEAQ runtime.argslice(SB), DI	
  0x42ee4c		4889d0			MOVQ DX, AX			
  0x42ee4f		e84c7a0100		CALL runtime.gcWriteBarrier(SB)	
  0x42ee54		e962ffffff		JMP 0x42edbb			
		argslice[i] = gostringnocopy(argv_index(argv, i))
  0x42ee59		e8e20bffff		CALL runtime.panicindex(SB)	
  0x42ee5e		0f0b			UD2				
func goargs() {
  0x42ee60		e80b570100		CALL runtime.morestack_noctxt(SB)	
  0x42ee65		e9d6feffff		JMP runtime.goargs(SB)			

TEXT runtime.goenvs_unix(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func goenvs_unix() {
  0x42ee70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ee79		483b6110		CMPQ 0x10(CX), SP	
  0x42ee7d		0f863a010000		JBE 0x42efbd		
  0x42ee83		4883ec40		SUBQ $0x40, SP		
  0x42ee87		48896c2438		MOVQ BP, 0x38(SP)	
  0x42ee8c		488d6c2438		LEAQ 0x38(SP), BP	
  0x42ee91		31c0			XORL AX, AX		
	for argv_index(argv, argc+1+n) != nil {
  0x42ee93		eb02			JMP 0x42ee97		
		n++
  0x42ee95		ffc0			INCL AX			
	for argv_index(argv, argc+1+n) != nil {
  0x42ee97		488b0d82870700		MOVQ runtime.argv(SB), CX	
  0x42ee9e		8b151c4a0900		MOVL runtime.argc(SB), DX	
  0x42eea4		01c2			ADDL AX, DX			
  0x42eea6		ffc2			INCL DX				
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x42eea8		4863d2			MOVSXD DX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x42eeab		488d1cd1		LEAQ 0(CX)(DX*8), BX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x42eeaf		8403			TESTB AL, 0(BX)		
  0x42eeb1		488b0cd1		MOVQ 0(CX)(DX*8), CX	
	for argv_index(argv, argc+1+n) != nil {
  0x42eeb5		4885c9			TESTQ CX, CX		
  0x42eeb8		75db			JNE 0x42ee95		
  0x42eeba		89442430		MOVL AX, 0x30(SP)	
	envs = make([]string, n)
  0x42eebe		488d0ddb840200		LEAQ 0x284db(IP), CX			
  0x42eec5		48890c24		MOVQ CX, 0(SP)				
  0x42eec9		4863c8			MOVSXD AX, CX				
  0x42eecc		48894c2408		MOVQ CX, 0x8(SP)			
  0x42eed1		48894c2410		MOVQ CX, 0x10(SP)			
  0x42eed6		e885480000		CALL runtime.makeslice(SB)		
  0x42eedb		488b442428		MOVQ 0x28(SP), AX			
  0x42eee0		488b4c2420		MOVQ 0x20(SP), CX			
  0x42eee5		488b542418		MOVQ 0x18(SP), DX			
  0x42eeea		48890d07880700		MOVQ CX, runtime.envs+8(SB)		
  0x42eef1		48890508880700		MOVQ AX, runtime.envs+16(SB)		
  0x42eef8		8b05124b0900		MOVL runtime.writeBarrier(SB), AX	
  0x42eefe		85c0			TESTL AX, AX				
  0x42ef00		0f859c000000		JNE 0x42efa2				
  0x42ef06		488915e3870700		MOVQ DX, runtime.envs(SB)		
  0x42ef0d		31c0			XORL AX, AX				
	for i := int32(0); i < n; i++ {
  0x42ef0f		eb03			JMP 0x42ef14		
  0x42ef11		8d4201			LEAL 0x1(DX), AX	
  0x42ef14		8b4c2430		MOVL 0x30(SP), CX	
  0x42ef18		39c8			CMPL CX, AX		
  0x42ef1a		7d7c			JGE 0x42ef98		
  0x42ef1c		89442434		MOVL AX, 0x34(SP)	
		envs[i] = gostring(argv_index(argv, argc+1+i))
  0x42ef20		488b0df9860700		MOVQ runtime.argv(SB), CX	
  0x42ef27		8b1593490900		MOVL runtime.argc(SB), DX	
  0x42ef2d		01c2			ADDL AX, DX			
  0x42ef2f		ffc2			INCL DX				
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x42ef31		4863d2			MOVSXD DX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x42ef34		488d1cd1		LEAQ 0(CX)(DX*8), BX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x42ef38		8403			TESTB AL, 0(BX)		
  0x42ef3a		488b0cd1		MOVQ 0(CX)(DX*8), CX	
		envs[i] = gostring(argv_index(argv, argc+1+i))
  0x42ef3e		48890c24		MOVQ CX, 0(SP)				
  0x42ef42		e879830000		CALL runtime.gostring(SB)		
  0x42ef47		488b05aa870700		MOVQ runtime.envs+8(SB), AX		
  0x42ef4e		488b0d9b870700		MOVQ runtime.envs(SB), CX		
  0x42ef55		8b542434		MOVL 0x34(SP), DX			
  0x42ef59		4863da			MOVSXD DX, BX				
  0x42ef5c		488b742410		MOVQ 0x10(SP), SI			
  0x42ef61		488b7c2408		MOVQ 0x8(SP), DI			
  0x42ef66		4839c3			CMPQ AX, BX				
  0x42ef69		734b			JAE 0x42efb6				
  0x42ef6b		48c1e304		SHLQ $0x4, BX				
  0x42ef6f		4889741908		MOVQ SI, 0x8(CX)(BX*1)			
  0x42ef74		8b35964a0900		MOVL runtime.writeBarrier(SB), SI	
  0x42ef7a		4c8d0419		LEAQ 0(CX)(BX*1), R8			
  0x42ef7e		85f6			TESTL SI, SI				
  0x42ef80		7506			JNE 0x42ef88				
  0x42ef82		48893c19		MOVQ DI, 0(CX)(BX*1)			
  0x42ef86		eb89			JMP 0x42ef11				
  0x42ef88		4889f8			MOVQ DI, AX				
  0x42ef8b		4c89c7			MOVQ R8, DI				
  0x42ef8e		e80d790100		CALL runtime.gcWriteBarrier(SB)		
  0x42ef93		e979ffffff		JMP 0x42ef11				
  0x42ef98		488b6c2438		MOVQ 0x38(SP), BP			
  0x42ef9d		4883c440		ADDQ $0x40, SP				
  0x42efa1		c3			RET					
	envs = make([]string, n)
  0x42efa2		488d3d47870700		LEAQ runtime.envs(SB), DI	
  0x42efa9		4889d0			MOVQ DX, AX			
  0x42efac		e8ef780100		CALL runtime.gcWriteBarrier(SB)	
  0x42efb1		e957ffffff		JMP 0x42ef0d			
		envs[i] = gostring(argv_index(argv, argc+1+i))
  0x42efb6		e8850affff		CALL runtime.panicindex(SB)	
  0x42efbb		0f0b			UD2				
func goenvs_unix() {
  0x42efbd		e8ae550100		CALL runtime.morestack_noctxt(SB)	
  0x42efc2		e9a9feffff		JMP runtime.goenvs_unix(SB)		

TEXT runtime.testAtomic64(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func testAtomic64() {
  0x42efd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42efd9		483b6110		CMPQ 0x10(CX), SP	
  0x42efdd		0f8647020000		JBE 0x42f22a		
  0x42efe3		4883ec18		SUBQ $0x18, SP		
  0x42efe7		48896c2410		MOVQ BP, 0x10(SP)	
  0x42efec		488d6c2410		LEAQ 0x10(SP), BP	
	test_z64 = 42
  0x42eff1		48c705f44909002a000000	MOVQ $0x2a, runtime.test_z64(SB)	
	test_x64 = 0
  0x42effc		48c705e149090000000000	MOVQ $0x0, runtime.test_x64(SB)	
	if atomic.Cas64(&test_z64, test_x64, 1) {
  0x42f007		31c0			XORL AX, AX			
  0x42f009		488d0de0490900		LEAQ runtime.test_z64(SB), CX	
  0x42f010		ba01000000		MOVL $0x1, DX			
  0x42f015		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)		
  0x42f01a		0f94c3			SETE BL				
  0x42f01d		84db			TESTL BL, BL			
  0x42f01f		0f85ea010000		JNE 0x42f20f			
	if test_x64 != 0 {
  0x42f025		488b1dbc490900		MOVQ runtime.test_x64(SB), BX	
  0x42f02c		4885db			TESTQ BX, BX			
  0x42f02f		0f85bf010000		JNE 0x42f1f4			
	test_x64 = 42
  0x42f035		48c705a84909002a000000	MOVQ $0x2a, runtime.test_x64(SB)	
	if !atomic.Cas64(&test_z64, test_x64, 1) {
  0x42f040		b82a000000		MOVL $0x2a, AX		
  0x42f045		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)	
  0x42f04a		0f94c2			SETE DL			
  0x42f04d		84d2			TESTL DL, DL		
  0x42f04f		0f8484010000		JE 0x42f1d9		
	if test_x64 != 42 || test_z64 != 1 {
  0x42f055		488b058c490900		MOVQ runtime.test_x64(SB), AX	
  0x42f05c		4883f82a		CMPQ $0x2a, AX			
  0x42f060		0f8558010000		JNE 0x42f1be			
  0x42f066		488b0583490900		MOVQ runtime.test_z64(SB), AX	
  0x42f06d		4883f801		CMPQ $0x1, AX			
  0x42f071		0f8547010000		JNE 0x42f1be			
	if atomic.Load64(&test_z64) != 1 {
  0x42f077		488b0572490900		MOVQ runtime.test_z64(SB), AX	
  0x42f07e		4883f801		CMPQ $0x1, AX			
  0x42f082		0f851b010000		JNE 0x42f1a3			
	atomic.Store64(&test_z64, (1<<40)+1)
  0x42f088		48b80100000000010000	MOVQ $0x10000000001, AX	
  0x42f092		488701			XCHGQ AX, 0(CX)		
	if atomic.Load64(&test_z64) != (1<<40)+1 {
  0x42f095		488b0554490900		MOVQ runtime.test_z64(SB), AX	
  0x42f09c		48ba0100000000010000	MOVQ $0x10000000001, DX		
  0x42f0a6		4839c2			CMPQ AX, DX			
  0x42f0a9		0f85d9000000		JNE 0x42f188			
	if atomic.Xadd64(&test_z64, (1<<40)+1) != (2<<40)+2 {
  0x42f0af		48b80100000000010000	MOVQ $0x10000000001, AX	
  0x42f0b9		f0480fc101		LOCK XADDQ AX, 0(CX)	
  0x42f0be		48ba0100000000010000	MOVQ $0x10000000001, DX	
  0x42f0c8		4801d0			ADDQ DX, AX		
  0x42f0cb		48ba0200000000020000	MOVQ $0x20000000002, DX	
  0x42f0d5		4839c2			CMPQ AX, DX		
  0x42f0d8		0f858f000000		JNE 0x42f16d		
	if atomic.Load64(&test_z64) != (2<<40)+2 {
  0x42f0de		488b050b490900		MOVQ runtime.test_z64(SB), AX	
  0x42f0e5		4839d0			CMPQ DX, AX			
  0x42f0e8		7568			JNE 0x42f152			
	if atomic.Xchg64(&test_z64, (3<<40)+3) != (2<<40)+2 {
  0x42f0ea		48b80300000000030000	MOVQ $0x30000000003, AX	
  0x42f0f4		488701			XCHGQ AX, 0(CX)		
  0x42f0f7		4839d0			CMPQ DX, AX		
  0x42f0fa		753b			JNE 0x42f137		
	if atomic.Load64(&test_z64) != (3<<40)+3 {
  0x42f0fc		488b05ed480900		MOVQ runtime.test_z64(SB), AX	
  0x42f103		48b90300000000030000	MOVQ $0x30000000003, CX		
  0x42f10d		4839c1			CMPQ AX, CX			
  0x42f110		750a			JNE 0x42f11c			
  0x42f112		488b6c2410		MOVQ 0x10(SP), BP		
  0x42f117		4883c418		ADDQ $0x18, SP			
  0x42f11b		c3			RET				
		throw("xchg64 failed")
  0x42f11c		488d0593b60300		LEAQ 0x3b693(IP), AX	
  0x42f123		48890424		MOVQ AX, 0(SP)		
  0x42f127		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x42f130		e89b20ffff		CALL runtime.throw(SB)	
  0x42f135		0f0b			UD2			
		throw("xchg64 failed")
  0x42f137		488d0578b60300		LEAQ 0x3b678(IP), AX	
  0x42f13e		48890424		MOVQ AX, 0(SP)		
  0x42f142		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x42f14b		e88020ffff		CALL runtime.throw(SB)	
  0x42f150		0f0b			UD2			
		throw("xadd64 failed")
  0x42f152		488d0550b60300		LEAQ 0x3b650(IP), AX	
  0x42f159		48890424		MOVQ AX, 0(SP)		
  0x42f15d		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x42f166		e86520ffff		CALL runtime.throw(SB)	
  0x42f16b		0f0b			UD2			
		throw("xadd64 failed")
  0x42f16d		488d0535b60300		LEAQ 0x3b635(IP), AX	
  0x42f174		48890424		MOVQ AX, 0(SP)		
  0x42f178		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x42f181		e84a20ffff		CALL runtime.throw(SB)	
  0x42f186		0f0b			UD2			
		throw("store64 failed")
  0x42f188		488d0575b70300		LEAQ 0x3b775(IP), AX	
  0x42f18f		48890424		MOVQ AX, 0(SP)		
  0x42f193		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x42f19c		e82f20ffff		CALL runtime.throw(SB)	
  0x42f1a1		0f0b			UD2			
		throw("load64 failed")
  0x42f1a3		488d05b1b50300		LEAQ 0x3b5b1(IP), AX	
  0x42f1aa		48890424		MOVQ AX, 0(SP)		
  0x42f1ae		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x42f1b7		e81420ffff		CALL runtime.throw(SB)	
  0x42f1bc		0f0b			UD2			
		throw("cas64 failed")
  0x42f1be		488d0525b40300		LEAQ 0x3b425(IP), AX	
  0x42f1c5		48890424		MOVQ AX, 0(SP)		
  0x42f1c9		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x42f1d2		e8f91fffff		CALL runtime.throw(SB)	
  0x42f1d7		0f0b			UD2			
		throw("cas64 failed")
  0x42f1d9		488d050ab40300		LEAQ 0x3b40a(IP), AX	
  0x42f1e0		48890424		MOVQ AX, 0(SP)		
  0x42f1e4		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x42f1ed		e8de1fffff		CALL runtime.throw(SB)	
  0x42f1f2		0f0b			UD2			
		throw("cas64 failed")
  0x42f1f4		488d05efb30300		LEAQ 0x3b3ef(IP), AX	
  0x42f1fb		48890424		MOVQ AX, 0(SP)		
  0x42f1ff		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x42f208		e8c31fffff		CALL runtime.throw(SB)	
  0x42f20d		0f0b			UD2			
		throw("cas64 failed")
  0x42f20f		488d05d4b30300		LEAQ 0x3b3d4(IP), AX	
  0x42f216		48890424		MOVQ AX, 0(SP)		
  0x42f21a		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x42f223		e8a81fffff		CALL runtime.throw(SB)	
  0x42f228		0f0b			UD2			
func testAtomic64() {
  0x42f22a		e841530100		CALL runtime.morestack_noctxt(SB)	
  0x42f22f		e99cfdffff		JMP runtime.testAtomic64(SB)		

TEXT runtime.check(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func check() {
  0x42f240		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42f249		483b6110		CMPQ 0x10(CX), SP	
  0x42f24d		0f866f040000		JBE 0x42f6c2		
  0x42f253		4883ec50		SUBQ $0x50, SP		
  0x42f257		48896c2448		MOVQ BP, 0x48(SP)	
  0x42f25c		488d6c2448		LEAQ 0x48(SP), BP	
		e     int32
  0x42f261		c744242c00000000	MOVL $0x0, 0x2c(SP)	
		i, i1 float32
  0x42f269		0f57c0			XORPS X0, X0		
  0x42f26c		f30f11442428		MOVSS X0, 0x28(SP)	
		j, j1 float64
  0x42f272		0f57c0			XORPS X0, X0		
  0x42f275		f20f11442430		MOVSD_XMM X0, 0x30(SP)	
		k, k1 unsafe.Pointer
  0x42f27b		48c744244000000000	MOVQ $0x0, 0x40(SP)	
		m     [4]byte
  0x42f284		c744242400000000	MOVL $0x0, 0x24(SP)	
	if timediv(12345*1000000000+54321, 1000000000, &e) != 12345 || e != 54321 {
  0x42f28c		48b831ce574b3a0b0000	MOVQ $0xb3a4b57ce31, AX		
  0x42f296		48890424		MOVQ AX, 0(SP)			
  0x42f29a		c744240800ca9a3b	MOVL $0x3b9aca00, 0x8(SP)	
  0x42f2a2		488d44242c		LEAQ 0x2c(SP), AX		
  0x42f2a7		4889442410		MOVQ AX, 0x10(SP)		
  0x42f2ac		e84f090000		CALL runtime.timediv(SB)	
  0x42f2b1		8b442418		MOVL 0x18(SP), AX		
  0x42f2b5		3d39300000		CMPL $0x3039, AX		
  0x42f2ba		0f85e7030000		JNE 0x42f6a7			
  0x42f2c0		8b4c242c		MOVL 0x2c(SP), CX		
  0x42f2c4		81f931d40000		CMPL $0xd431, CX		
  0x42f2ca		0f85d7030000		JNE 0x42f6a7			
	z = 1
  0x42f2d0		c744242001000000	MOVL $0x1, 0x20(SP)	
	if !atomic.Cas(&z, 1, 2) {
  0x42f2d8		b801000000		MOVL $0x1, AX		
  0x42f2dd		488d4c2420		LEAQ 0x20(SP), CX	
  0x42f2e2		ba02000000		MOVL $0x2, DX		
  0x42f2e7		f00fb111		LOCK CMPXCHGL DX, 0(CX)	
  0x42f2eb		0f94c2			SETE DL			
  0x42f2ee		84d2			TESTL DL, DL		
  0x42f2f0		0f8496030000		JE 0x42f68c		
	if z != 2 {
  0x42f2f6		8b542420		MOVL 0x20(SP), DX	
  0x42f2fa		83fa02			CMPL $0x2, DX		
  0x42f2fd		0f856e030000		JNE 0x42f671		
	z = 4
  0x42f303		c744242004000000	MOVL $0x4, 0x20(SP)	
	if atomic.Cas(&z, 5, 6) {
  0x42f30b		b805000000		MOVL $0x5, AX		
  0x42f310		ba06000000		MOVL $0x6, DX		
  0x42f315		f00fb111		LOCK CMPXCHGL DX, 0(CX)	
  0x42f319		0f94c2			SETE DL			
  0x42f31c		84d2			TESTL DL, DL		
  0x42f31e		0f8532030000		JNE 0x42f656		
	if z != 4 {
  0x42f324		8b542420		MOVL 0x20(SP), DX	
  0x42f328		83fa04			CMPL $0x4, DX		
  0x42f32b		0f850a030000		JNE 0x42f63b		
	z = 0xffffffff
  0x42f331		c7442420ffffffff	MOVL $-0x1, 0x20(SP)	
	if !atomic.Cas(&z, 0xffffffff, 0xfffffffe) {
  0x42f339		b8ffffffff		MOVL $-0x1, AX		
  0x42f33e		bafeffffff		MOVL $-0x2, DX		
  0x42f343		f00fb111		LOCK CMPXCHGL DX, 0(CX)	
  0x42f347		0f94c1			SETE CL			
  0x42f34a		84c9			TESTL CL, CL		
  0x42f34c		0f84ce020000		JE 0x42f620		
	if z != 0xfffffffe {
  0x42f352		8b442420		MOVL 0x20(SP), AX	
  0x42f356		83f8fe			CMPL $-0x2, AX		
  0x42f359		0f85a6020000		JNE 0x42f605		
	k = unsafe.Pointer(uintptr(0xfedcb123))
  0x42f35f		b823b1dcfe		MOVL $-0x1234edd, AX	
  0x42f364		4889442440		MOVQ AX, 0x40(SP)	
		k = unsafe.Pointer(uintptr(k) << 10)
  0x42f369		48c1e00a		SHLQ $0xa, AX		
  0x42f36d		4889442440		MOVQ AX, 0x40(SP)	
	if casp(&k, nil, nil) {
  0x42f372		488d442440		LEAQ 0x40(SP), AX	
  0x42f377		48890424		MOVQ AX, 0(SP)		
  0x42f37b		0f57c0			XORPS X0, X0		
  0x42f37e		0f11442408		MOVUPS X0, 0x8(SP)	
  0x42f383		e8982bfdff		CALL runtime.casp(SB)	
  0x42f388		0fb6442418		MOVZX 0x18(SP), AX	
  0x42f38d		84c0			TESTL AL, AL		
  0x42f38f		0f8555020000		JNE 0x42f5ea		
	k1 = add(k, 1)
  0x42f395		488b442440		MOVQ 0x40(SP), AX	
	if !casp(&k, k, k1) {
  0x42f39a		488d4c2440		LEAQ 0x40(SP), CX	
  0x42f39f		48890c24		MOVQ CX, 0(SP)		
  0x42f3a3		488b4c2440		MOVQ 0x40(SP), CX	
  0x42f3a8		48894c2408		MOVQ CX, 0x8(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x42f3ad		48ffc0			INCQ AX			
  0x42f3b0		4889442438		MOVQ AX, 0x38(SP)	
	if !casp(&k, k, k1) {
  0x42f3b5		4889442410		MOVQ AX, 0x10(SP)	
  0x42f3ba		e8612bfdff		CALL runtime.casp(SB)	
  0x42f3bf		0fb6442418		MOVZX 0x18(SP), AX	
  0x42f3c4		84c0			TESTL AL, AL		
  0x42f3c6		0f8403020000		JE 0x42f5cf		
	if k != k1 {
  0x42f3cc		488b442440		MOVQ 0x40(SP), AX	
  0x42f3d1		488b4c2438		MOVQ 0x38(SP), CX	
  0x42f3d6		4839c8			CMPQ CX, AX		
  0x42f3d9		0f85d5010000		JNE 0x42f5b4		
	m = [4]byte{1, 1, 1, 1}
  0x42f3df		c744242400000000	MOVL $0x0, 0x24(SP)		
  0x42f3e7		c744242401010101	MOVL $0x1010101, 0x24(SP)	
	atomic.Or8(&m[1], 0xf0)
  0x42f3ef		b8f0ffffff		MOVL $-0x10, AX		
  0x42f3f4		488d4c2425		LEAQ 0x25(SP), CX	
  0x42f3f9		f00801			LOCK ORB AL, 0(CX)	
	if m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1 {
  0x42f3fc		0fb6442424		MOVZX 0x24(SP), AX	
  0x42f401		3c01			CMPL $0x1, AL		
  0x42f403		0f8590010000		JNE 0x42f599		
  0x42f409		0fb6442425		MOVZX 0x25(SP), AX	
  0x42f40e		3cf1			CMPL $0xf1, AL		
  0x42f410		0f8583010000		JNE 0x42f599		
  0x42f416		0fb6442426		MOVZX 0x26(SP), AX	
  0x42f41b		3c01			CMPL $0x1, AL		
  0x42f41d		0f8576010000		JNE 0x42f599		
  0x42f423		0fb6442427		MOVZX 0x27(SP), AX	
  0x42f428		3c01			CMPL $0x1, AL		
  0x42f42a		0f8569010000		JNE 0x42f599		
	m = [4]byte{0xff, 0xff, 0xff, 0xff}
  0x42f430		c744242400000000	MOVL $0x0, 0x24(SP)	
  0x42f438		c7442424ffffffff	MOVL $-0x1, 0x24(SP)	
	atomic.And8(&m[1], 0x1)
  0x42f440		b801000000		MOVL $0x1, AX		
  0x42f445		f02001			LOCK ANDB AL, 0(CX)	
	if m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff {
  0x42f448		0fb6442424		MOVZX 0x24(SP), AX	
  0x42f44d		3cff			CMPL $0xff, AL		
  0x42f44f		0f8529010000		JNE 0x42f57e		
  0x42f455		0fb6442425		MOVZX 0x25(SP), AX	
  0x42f45a		3c01			CMPL $0x1, AL		
  0x42f45c		0f851c010000		JNE 0x42f57e		
  0x42f462		0fb6442426		MOVZX 0x26(SP), AX	
  0x42f467		3cff			CMPL $0xff, AL		
  0x42f469		0f850f010000		JNE 0x42f57e		
  0x42f46f		0fb6442427		MOVZX 0x27(SP), AX	
  0x42f474		3cff			CMPL $0xff, AL		
  0x42f476		0f8502010000		JNE 0x42f57e		
	*(*uint64)(unsafe.Pointer(&j)) = ^uint64(0)
  0x42f47c		48c7442430ffffffff	MOVQ $-0x1, 0x30(SP)	
	if j == j1 {
  0x42f485		f20f10442430		MOVSD_XMM 0x30(SP), X0			
  0x42f48b		f20f100da5560400	MOVSD_XMM $f64.fffffffffffffffe(SB), X1	
  0x42f493		660f2ec1		UCOMISD X1, X0				
  0x42f497		7506			JNE 0x42f49f				
  0x42f499		0f8bc4000000		JNP 0x42f563				
	if !(j != j1) {
  0x42f49f		7506			JNE 0x42f4a7		
  0x42f4a1		0f8ba1000000		JNP 0x42f548		
	*(*uint32)(unsafe.Pointer(&i)) = ^uint32(0)
  0x42f4a7		c7442428ffffffff	MOVL $-0x1, 0x28(SP)	
	if i == i1 {
  0x42f4af		f30f10442428		MOVSS 0x28(SP), X0		
  0x42f4b5		f30f100ddb550400	MOVSS $f32.fffffffe(SB), X1	
  0x42f4bd		0f2ec8			UCOMISS X0, X1			
  0x42f4c0		7502			JNE 0x42f4c4			
  0x42f4c2		7b69			JNP 0x42f52d			
	testAtomic64()
  0x42f4c4		e807fbffff		CALL runtime.testAtomic64(SB)	
	if _FixedStack != round2(_FixedStack) {
  0x42f4c9		c7042400080000		MOVL $0x800, 0(SP)	
  0x42f4d0		e8ab670000		CALL runtime.round2(SB)	
  0x42f4d5		8b442408		MOVL 0x8(SP), AX	
  0x42f4d9		3d00080000		CMPL $0x800, AX		
  0x42f4de		7532			JNE 0x42f512		
	if !checkASM() {
  0x42f4e0		e83b6e0100		CALL runtime.checkASM(SB)	
  0x42f4e5		0fb60424		MOVZX 0(SP), AX			
  0x42f4e9		84c0			TESTL AL, AL			
  0x42f4eb		740a			JE 0x42f4f7			
  0x42f4ed		488b6c2448		MOVQ 0x48(SP), BP		
  0x42f4f2		4883c450		ADDQ $0x50, SP			
  0x42f4f6		c3			RET				
		throw("assembly checks failed")
  0x42f4f7		488d05debe0300		LEAQ 0x3bede(IP), AX	
  0x42f4fe		48890424		MOVQ AX, 0(SP)		
  0x42f502		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x42f50b		e8c01cffff		CALL runtime.throw(SB)	
  0x42f510		0f0b			UD2			
		throw("FixedStack is not power-of-2")
  0x42f512		488d0585ca0300		LEAQ 0x3ca85(IP), AX	
  0x42f519		48890424		MOVQ AX, 0(SP)		
  0x42f51d		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x42f526		e8a51cffff		CALL runtime.throw(SB)	
  0x42f52b		0f0b			UD2			
		throw("float32nan2")
  0x42f52d		488d0556af0300		LEAQ 0x3af56(IP), AX	
  0x42f534		48890424		MOVQ AX, 0(SP)		
  0x42f538		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x42f541		e88a1cffff		CALL runtime.throw(SB)	
  0x42f546		0f0b			UD2			
		throw("float64nan3")
  0x42f548		488d0551af0300		LEAQ 0x3af51(IP), AX	
  0x42f54f		48890424		MOVQ AX, 0(SP)		
  0x42f553		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x42f55c		e86f1cffff		CALL runtime.throw(SB)	
  0x42f561		0f0b			UD2			
		throw("float64nan2")
  0x42f563		488d052baf0300		LEAQ 0x3af2b(IP), AX	
  0x42f56a		48890424		MOVQ AX, 0(SP)		
  0x42f56e		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x42f577		e8541cffff		CALL runtime.throw(SB)	
  0x42f57c		0f0b			UD2			
		throw("atomicand8")
  0x42f57e		488d05afad0300		LEAQ 0x3adaf(IP), AX	
  0x42f585		48890424		MOVQ AX, 0(SP)		
  0x42f589		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x42f592		e8391cffff		CALL runtime.throw(SB)	
  0x42f597		0f0b			UD2			
		throw("atomicor8")
  0x42f599		488d055cab0300		LEAQ 0x3ab5c(IP), AX	
  0x42f5a0		48890424		MOVQ AX, 0(SP)		
  0x42f5a4		48c744240809000000	MOVQ $0x9, 0x8(SP)	
  0x42f5ad		e81e1cffff		CALL runtime.throw(SB)	
  0x42f5b2		0f0b			UD2			
		throw("casp3")
  0x42f5b4		488d05f3a70300		LEAQ 0x3a7f3(IP), AX	
  0x42f5bb		48890424		MOVQ AX, 0(SP)		
  0x42f5bf		48c744240805000000	MOVQ $0x5, 0x8(SP)	
  0x42f5c8		e8031cffff		CALL runtime.throw(SB)	
  0x42f5cd		0f0b			UD2			
		throw("casp2")
  0x42f5cf		488d05d3a70300		LEAQ 0x3a7d3(IP), AX	
  0x42f5d6		48890424		MOVQ AX, 0(SP)		
  0x42f5da		48c744240805000000	MOVQ $0x5, 0x8(SP)	
  0x42f5e3		e8e81bffff		CALL runtime.throw(SB)	
  0x42f5e8		0f0b			UD2			
		throw("casp1")
  0x42f5ea		488d05b3a70300		LEAQ 0x3a7b3(IP), AX	
  0x42f5f1		48890424		MOVQ AX, 0(SP)		
  0x42f5f5		48c744240805000000	MOVQ $0x5, 0x8(SP)	
  0x42f5fe		e8cd1bffff		CALL runtime.throw(SB)	
  0x42f603		0f0b			UD2			
		throw("cas6")
  0x42f605		488d050ea70300		LEAQ 0x3a70e(IP), AX	
  0x42f60c		48890424		MOVQ AX, 0(SP)		
  0x42f610		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x42f619		e8b21bffff		CALL runtime.throw(SB)	
  0x42f61e		0f0b			UD2			
		throw("cas5")
  0x42f620		488d05efa60300		LEAQ 0x3a6ef(IP), AX	
  0x42f627		48890424		MOVQ AX, 0(SP)		
  0x42f62b		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x42f634		e8971bffff		CALL runtime.throw(SB)	
  0x42f639		0f0b			UD2			
		throw("cas4")
  0x42f63b		488d05d0a60300		LEAQ 0x3a6d0(IP), AX	
  0x42f642		48890424		MOVQ AX, 0(SP)		
  0x42f646		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x42f64f		e87c1bffff		CALL runtime.throw(SB)	
  0x42f654		0f0b			UD2			
		throw("cas3")
  0x42f656		488d05b1a60300		LEAQ 0x3a6b1(IP), AX	
  0x42f65d		48890424		MOVQ AX, 0(SP)		
  0x42f661		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x42f66a		e8611bffff		CALL runtime.throw(SB)	
  0x42f66f		0f0b			UD2			
		throw("cas2")
  0x42f671		488d0592a60300		LEAQ 0x3a692(IP), AX	
  0x42f678		48890424		MOVQ AX, 0(SP)		
  0x42f67c		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x42f685		e8461bffff		CALL runtime.throw(SB)	
  0x42f68a		0f0b			UD2			
		throw("cas1")
  0x42f68c		488d0573a60300		LEAQ 0x3a673(IP), AX	
  0x42f693		48890424		MOVQ AX, 0(SP)		
  0x42f697		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x42f6a0		e82b1bffff		CALL runtime.throw(SB)	
  0x42f6a5		0f0b			UD2			
		throw("bad timediv")
  0x42f6a7		488d05bbad0300		LEAQ 0x3adbb(IP), AX	
  0x42f6ae		48890424		MOVQ AX, 0(SP)		
  0x42f6b2		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x42f6bb		e8101bffff		CALL runtime.throw(SB)	
  0x42f6c0		0f0b			UD2			
func check() {
  0x42f6c2		e8a94e0100		CALL runtime.morestack_noctxt(SB)	
  0x42f6c7		e974fbffff		JMP runtime.check(SB)			

TEXT runtime.parsedebugvars(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func parsedebugvars() {
  0x42f6d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42f6d9		488d4424f8		LEAQ -0x8(SP), AX	
  0x42f6de		483b4110		CMPQ 0x10(CX), AX	
  0x42f6e2		0f862e030000		JBE 0x42fa16		
  0x42f6e8		4881ec88000000		SUBQ $0x88, SP		
  0x42f6ef		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x42f6f7		488dac2480000000	LEAQ 0x80(SP), BP	
	debug.cgocheck = 1
  0x42f6ff		c705bb43090001000000	MOVL $0x1, runtime.debug+4(SB)	
	debug.invalidptr = 1
  0x42f709		c705d143090001000000	MOVL $0x1, runtime.debug+36(SB)	
	for p := gogetenv("GODEBUG"); p != ""; {
  0x42f713		488d0586a70300		LEAQ 0x3a786(IP), AX		
  0x42f71a		48890424		MOVQ AX, 0(SP)			
  0x42f71e		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42f727		e84453fdff		CALL runtime.gogetenv(SB)	
  0x42f72c		488b442418		MOVQ 0x18(SP), AX		
  0x42f731		488b4c2410		MOVQ 0x10(SP), CX		
  0x42f736		eb0a			JMP 0x42f742			
  0x42f738		488b4c2460		MOVQ 0x60(SP), CX		
  0x42f73d		488b442428		MOVQ 0x28(SP), AX		
  0x42f742		4885c0			TESTQ AX, AX			
  0x42f745		0f8470020000		JE 0x42f9bb			
  0x42f74b		48894c2468		MOVQ CX, 0x68(SP)		
  0x42f750		4889442438		MOVQ AX, 0x38(SP)		
		i := index(p, ",")
  0x42f755		48890c24		MOVQ CX, 0(SP)		
  0x42f759		4889442408		MOVQ AX, 0x8(SP)	
  0x42f75e		488d15efa40300		LEAQ 0x3a4ef(IP), DX	
  0x42f765		4889542410		MOVQ DX, 0x10(SP)	
  0x42f76a		48c744241801000000	MOVQ $0x1, 0x18(SP)	
  0x42f773		e8187c0000		CALL runtime.index(SB)	
  0x42f778		488b442420		MOVQ 0x20(SP), AX	
		if i < 0 {
  0x42f77d		4885c0			TESTQ AX, AX		
  0x42f780		0f8df7010000		JGE 0x42f97d		
  0x42f786		31c0			XORL AX, AX		
  0x42f788		31c9			XORL CX, CX		
  0x42f78a		488b542438		MOVQ 0x38(SP), DX	
			field, p = p, ""
  0x42f78f		4889442460		MOVQ AX, 0x60(SP)	
  0x42f794		48894c2428		MOVQ CX, 0x28(SP)	
  0x42f799		4889542438		MOVQ DX, 0x38(SP)	
  0x42f79e		488b5c2468		MOVQ 0x68(SP), BX	
		i = index(field, "=")
  0x42f7a3		48891c24		MOVQ BX, 0(SP)		
  0x42f7a7		4889542408		MOVQ DX, 0x8(SP)	
  0x42f7ac		488d35a7a40300		LEAQ 0x3a4a7(IP), SI	
  0x42f7b3		4889742410		MOVQ SI, 0x10(SP)	
  0x42f7b8		48c744241801000000	MOVQ $0x1, 0x18(SP)	
  0x42f7c1		e8ca7b0000		CALL runtime.index(SB)	
  0x42f7c6		488b442420		MOVQ 0x20(SP), AX	
		if i < 0 {
  0x42f7cb		4885c0			TESTQ AX, AX		
  0x42f7ce		0f8c64ffffff		JL 0x42f738		
  0x42f7d4		488b4c2438		MOVQ 0x38(SP), CX	
		key, value := field[:i], field[i+1:]
  0x42f7d9		4839c8			CMPQ CX, AX		
  0x42f7dc		0f8726020000		JA 0x42fa08		
  0x42f7e2		488d5001		LEAQ 0x1(AX), DX	
  0x42f7e6		4839ca			CMPQ CX, DX		
  0x42f7e9		0f8719020000		JA 0x42fa08		
  0x42f7ef		4829d1			SUBQ DX, CX		
  0x42f7f2		4889cb			MOVQ CX, BX		
  0x42f7f5		48f7d9			NEGQ CX			
  0x42f7f8		48c1f93f		SARQ $0x3f, CX		
  0x42f7fc		4821d1			ANDQ DX, CX		
  0x42f7ff		488b542468		MOVQ 0x68(SP), DX	
  0x42f804		4801d1			ADDQ DX, CX		
		if key == "memprofilerate" {
  0x42f807		4883f80e		CMPQ $0xe, AX			
  0x42f80b		0f855d010000		JNE 0x42f96e			
  0x42f811		488b32			MOVQ 0(DX), SI			
  0x42f814		48bf6d656d70726f6669	MOVQ $0x69666f72706d656d, DI	
  0x42f81e		4839fe			CMPQ DI, SI			
  0x42f821		751a			JNE 0x42f83d			
  0x42f823		8b7208			MOVL 0x8(DX), SI		
  0x42f826		81fe6c657261		CMPL $0x6172656c, SI		
  0x42f82c		750f			JNE 0x42f83d			
  0x42f82e		0fb7720c		MOVZX 0xc(DX), SI		
  0x42f832		6681fe7465		CMPW $0x6574, SI		
  0x42f837		0f84ff000000		JE 0x42f93c			
  0x42f83d		4889442430		MOVQ AX, 0x30(SP)		
  0x42f842		48895c2450		MOVQ BX, 0x50(SP)		
  0x42f847		48894c2458		MOVQ CX, 0x58(SP)		
			for _, v := range dbgvars {
  0x42f84c		488b35d5620700		MOVQ runtime.dbgvars+8(SB), SI	
  0x42f853		4889742448		MOVQ SI, 0x48(SP)		
  0x42f858		4c8b05c1620700		MOVQ runtime.dbgvars(SB), R8	
  0x42f85f		4531c9			XORL R9, R9			
  0x42f862		eb07			JMP 0x42f86b			
  0x42f864		4983c018		ADDQ $0x18, R8			
  0x42f868		49ffc1			INCQ R9				
  0x42f86b		4939f1			CMPQ SI, R9			
  0x42f86e		0f8dc4feffff		JGE 0x42f738			
  0x42f874		4d8b5008		MOVQ 0x8(R8), R10		
  0x42f878		4d8b18			MOVQ 0(R8), R11			
  0x42f87b		4d8b6010		MOVQ 0x10(R8), R12		
				if v.name == key {
  0x42f87f		4939c2			CMPQ AX, R10			
  0x42f882		75e0			JNE 0x42f864			
  0x42f884		4c894c2440		MOVQ R9, 0x40(SP)		
  0x42f889		4c89642478		MOVQ R12, 0x78(SP)		
  0x42f88e		4c89442470		MOVQ R8, 0x70(SP)		
  0x42f893		4c891c24		MOVQ R11, 0(SP)			
  0x42f897		4889542408		MOVQ DX, 0x8(SP)		
  0x42f89c		4c89542410		MOVQ R10, 0x10(SP)		
  0x42f8a1		e89a6a0100		CALL runtime.memequal(SB)	
  0x42f8a6		0fb6442418		MOVZX 0x18(SP), AX		
  0x42f8ab		84c0			TESTL AL, AL			
  0x42f8ad		752f			JNE 0x42f8de			
  0x42f8af		488b442430		MOVQ 0x30(SP), AX		
  0x42f8b4		488b4c2458		MOVQ 0x58(SP), CX		
  0x42f8b9		488b542468		MOVQ 0x68(SP), DX		
  0x42f8be		488b5c2450		MOVQ 0x50(SP), BX		
  0x42f8c3		488b742448		MOVQ 0x48(SP), SI		
  0x42f8c8		48bf6d656d70726f6669	MOVQ $0x69666f72706d656d, DI	
  0x42f8d2		4c8b442470		MOVQ 0x70(SP), R8		
  0x42f8d7		4c8b4c2440		MOVQ 0x40(SP), R9		
  0x42f8dc		eb86			JMP 0x42f864			
  0x42f8de		488b442458		MOVQ 0x58(SP), AX		
					if n, ok := atoi32(value); ok {
  0x42f8e3		48890424		MOVQ AX, 0(SP)		
  0x42f8e7		488b4c2450		MOVQ 0x50(SP), CX	
  0x42f8ec		48894c2408		MOVQ CX, 0x8(SP)	
  0x42f8f1		e83a7d0000		CALL runtime.atoi32(SB)	
  0x42f8f6		8b442410		MOVL 0x10(SP), AX	
  0x42f8fa		0fb64c2414		MOVZX 0x14(SP), CX	
  0x42f8ff		84c9			TESTL CL, CL		
  0x42f901		7407			JE 0x42f90a		
  0x42f903		488b4c2478		MOVQ 0x78(SP), CX	
						*v.value = n
  0x42f908		8901			MOVL AX, 0(CX)			
  0x42f90a		488b442430		MOVQ 0x30(SP), AX		
  0x42f90f		488b4c2458		MOVQ 0x58(SP), CX		
  0x42f914		488b542468		MOVQ 0x68(SP), DX		
  0x42f919		488b5c2450		MOVQ 0x50(SP), BX		
  0x42f91e		488b742448		MOVQ 0x48(SP), SI		
  0x42f923		48bf6d656d70726f6669	MOVQ $0x69666f72706d656d, DI	
  0x42f92d		4c8b442470		MOVQ 0x70(SP), R8		
  0x42f932		4c8b4c2440		MOVQ 0x40(SP), R9		
			for _, v := range dbgvars {
  0x42f937		e928ffffff		JMP 0x42f864		
			if n, ok := atoi(value); ok {
  0x42f93c		48890c24		MOVQ CX, 0(SP)		
  0x42f940		48895c2408		MOVQ BX, 0x8(SP)	
  0x42f945		e8b67b0000		CALL runtime.atoi(SB)	
  0x42f94a		488b442410		MOVQ 0x10(SP), AX	
  0x42f94f		0fb64c2418		MOVZX 0x18(SP), CX	
  0x42f954		84c9			TESTL CL, CL		
  0x42f956		7407			JE 0x42f95f		
				MemProfileRate = n
  0x42f958		488905b9560700		MOVQ AX, runtime.MemProfileRate(SB)	
  0x42f95f		48bf6d656d70726f6669	MOVQ $0x69666f72706d656d, DI		
	for p := gogetenv("GODEBUG"); p != ""; {
  0x42f969		e9cafdffff		JMP 0x42f738			
  0x42f96e		48bf6d656d70726f6669	MOVQ $0x69666f72706d656d, DI	
		if key == "memprofilerate" {
  0x42f978		e9c0feffff		JMP 0x42f83d		
  0x42f97d		488b4c2438		MOVQ 0x38(SP), CX	
			field, p = p[:i], p[i+1:]
  0x42f982		4839c8			CMPQ CX, AX		
  0x42f985		0f8784000000		JA 0x42fa0f		
  0x42f98b		488d5001		LEAQ 0x1(AX), DX	
  0x42f98f		4839ca			CMPQ CX, DX		
  0x42f992		777b			JA 0x42fa0f		
  0x42f994		4829d1			SUBQ DX, CX		
  0x42f997		4889cb			MOVQ CX, BX		
  0x42f99a		48f7d9			NEGQ CX			
  0x42f99d		48c1f93f		SARQ $0x3f, CX		
  0x42f9a1		4821d1			ANDQ DX, CX		
  0x42f9a4		488b742468		MOVQ 0x68(SP), SI	
  0x42f9a9		488d3c0e		LEAQ 0(SI)(CX*1), DI	
  0x42f9ad		4889d9			MOVQ BX, CX		
  0x42f9b0		4889c2			MOVQ AX, DX		
  0x42f9b3		4889f8			MOVQ DI, AX		
  0x42f9b6		e9d4fdffff		JMP 0x42f78f		
	setTraceback(gogetenv("GOTRACEBACK"))
  0x42f9bb		488d0586aa0300		LEAQ 0x3aa86(IP), AX			
  0x42f9c2		48890424		MOVQ AX, 0(SP)				
  0x42f9c6		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x42f9cf		e89c50fdff		CALL runtime.gogetenv(SB)		
  0x42f9d4		488b442418		MOVQ 0x18(SP), AX			
  0x42f9d9		488b4c2410		MOVQ 0x10(SP), CX			
  0x42f9de		48890c24		MOVQ CX, 0(SP)				
  0x42f9e2		4889442408		MOVQ AX, 0x8(SP)			
  0x42f9e7		e834000000		CALL runtime/debug.SetTraceback(SB)	
	traceback_env = traceback_cache
  0x42f9ec		8b0516560700		MOVL runtime.traceback_cache(SB), AX	
  0x42f9f2		89050c3f0900		MOVL AX, runtime.traceback_env(SB)	
}
  0x42f9f8		488bac2480000000	MOVQ 0x80(SP), BP	
  0x42fa00		4881c488000000		ADDQ $0x88, SP		
  0x42fa07		c3			RET			
		key, value := field[:i], field[i+1:]
  0x42fa08		e8a300ffff		CALL runtime.panicslice(SB)	
  0x42fa0d		0f0b			UD2				
			field, p = p[:i], p[i+1:]
  0x42fa0f		e89c00ffff		CALL runtime.panicslice(SB)	
  0x42fa14		0f0b			UD2				
func parsedebugvars() {
  0x42fa16		e8554b0100		CALL runtime.morestack_noctxt(SB)	
  0x42fa1b		e9b0fcffff		JMP runtime.parsedebugvars(SB)		

TEXT runtime/debug.SetTraceback(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func setTraceback(level string) {
  0x42fa20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42fa29		483b6110		CMPQ 0x10(CX), SP	
  0x42fa2d		0f86b8010000		JBE 0x42fbeb		
  0x42fa33		4883ec30		SUBQ $0x30, SP		
  0x42fa37		48896c2428		MOVQ BP, 0x28(SP)	
  0x42fa3c		488d6c2428		LEAQ 0x28(SP), BP	
  0x42fa41		488b442440		MOVQ 0x40(SP), AX	
	switch level {
  0x42fa46		4883f804		CMPQ $0x4, AX		
  0x42fa4a		0f8dca000000		JGE 0x42fb1a		
	case "single", "":
  0x42fa50		4885c0			TESTQ AX, AX		
  0x42fa53		7539			JNE 0x42fa8e		
  0x42fa55		b804000000		MOVL $0x4, AX		
	if islibrary || isarchive {
  0x42fa5a		0fb60d4c3e0900		MOVZX runtime.islibrary(SB), CX	
  0x42fa61		84c9			TESTL CL, CL			
  0x42fa63		741c			JE 0x42fa81			
		t |= tracebackCrash
  0x42fa65		83c801			ORL $0x1, AX		
	t |= traceback_env
  0x42fa68		0b05963e0900		ORL runtime.traceback_env(SB), AX	
	atomic.Store(&traceback_cache, t)
  0x42fa6e		488d0d93550700		LEAQ runtime.traceback_cache(SB), CX	
  0x42fa75		8701			XCHGL AX, 0(CX)				
}
  0x42fa77		488b6c2428		MOVQ 0x28(SP), BP	
  0x42fa7c		4883c430		ADDQ $0x30, SP		
  0x42fa80		c3			RET			
	if islibrary || isarchive {
  0x42fa81		0fb60d233e0900		MOVZX runtime.isarchive(SB), CX	
  0x42fa88		84c9			TESTL CL, CL			
  0x42fa8a		75d9			JNE 0x42fa65			
  0x42fa8c		ebda			JMP 0x42fa68			
	case "all":
  0x42fa8e		4883f803		CMPQ $0x3, AX		
  0x42fa92		757b			JNE 0x42fb0f		
  0x42fa94		488b4c2438		MOVQ 0x38(SP), CX	
  0x42fa99		0fb711			MOVZX 0(CX), DX		
  0x42fa9c		6681fa616c		CMPW $0x6c61, DX	
  0x42faa1		7566			JNE 0x42fb09		
  0x42faa3		0fb65102		MOVZX 0x2(CX), DX	
  0x42faa7		80fa6c			CMPL $0x6c, DL		
  0x42faaa		7507			JNE 0x42fab3		
  0x42faac		b806000000		MOVL $0x6, AX		
	switch level {
  0x42fab1		eba7			JMP 0x42fa5a		
  0x42fab3		4883f804		CMPQ $0x4, AX		
	case "none":
  0x42fab7		750e			JNE 0x42fac7		
  0x42fab9		8b11			MOVL 0(CX), DX		
  0x42fabb		81fa6e6f6e65		CMPL $0x656e6f6e, DX	
  0x42fac1		7504			JNE 0x42fac7		
  0x42fac3		31c0			XORL AX, AX		
	switch level {
  0x42fac5		eb93			JMP 0x42fa5a		
		if n, ok := atoi(level); ok && n == int(uint32(n)) {
  0x42fac7		48890c24		MOVQ CX, 0(SP)		
  0x42facb		4889442408		MOVQ AX, 0x8(SP)	
  0x42fad0		e82b7a0000		CALL runtime.atoi(SB)	
  0x42fad5		488b442410		MOVQ 0x10(SP), AX	
  0x42fada		0fb64c2418		MOVZX 0x18(SP), CX	
  0x42fadf		84c9			TESTL CL, CL		
  0x42fae1		741c			JE 0x42faff		
  0x42fae3		89c1			MOVL AX, CX		
  0x42fae5		4839c1			CMPQ AX, CX		
  0x42fae8		750b			JNE 0x42faf5		
			t |= uint32(n) << tracebackShift
  0x42faea		c1e002			SHLL $0x2, AX		
  0x42faed		83c802			ORL $0x2, AX		
  0x42faf0		e965ffffff		JMP 0x42fa5a		
  0x42faf5		b802000000		MOVL $0x2, AX		
		if n, ok := atoi(level); ok && n == int(uint32(n)) {
  0x42fafa		e95bffffff		JMP 0x42fa5a		
  0x42faff		b802000000		MOVL $0x2, AX		
  0x42fb04		e951ffffff		JMP 0x42fa5a		
	switch level {
  0x42fb09		4883f804		CMPQ $0x4, AX		
	case "all":
  0x42fb0d		eba8			JMP 0x42fab7		
	switch level {
  0x42fb0f		4883f804		CMPQ $0x4, AX		
  0x42fb13		488b4c2438		MOVQ 0x38(SP), CX	
	case "all":
  0x42fb18		eb9d			JMP 0x42fab7		
	switch level {
  0x42fb1a		0f8485000000		JE 0x42fba5		
	case "crash":
  0x42fb20		4883f805		CMPQ $0x5, AX		
  0x42fb24		7578			JNE 0x42fb9e		
  0x42fb26		488b4c2438		MOVQ 0x38(SP), CX	
  0x42fb2b		8b11			MOVL 0(CX), DX		
  0x42fb2d		81fa63726173		CMPL $0x73617263, DX	
  0x42fb33		7513			JNE 0x42fb48		
  0x42fb35		0fb65104		MOVZX 0x4(CX), DX	
  0x42fb39		80fa68			CMPL $0x68, DL		
  0x42fb3c		750a			JNE 0x42fb48		
  0x42fb3e		b80b000000		MOVL $0xb, AX		
	switch level {
  0x42fb43		e912ffffff		JMP 0x42fa5a		
	case "single", "":
  0x42fb48		4883f806		CMPQ $0x6, AX		
  0x42fb4c		751d			JNE 0x42fb6b		
  0x42fb4e		8b11			MOVL 0(CX), DX		
  0x42fb50		81fa73696e67		CMPL $0x676e6973, DX	
  0x42fb56		7540			JNE 0x42fb98		
  0x42fb58		0fb75104		MOVZX 0x4(CX), DX	
  0x42fb5c		6681fa6c65		CMPW $0x656c, DX	
  0x42fb61		0f84eefeffff		JE 0x42fa55		
  0x42fb67		4883f806		CMPQ $0x6, AX		
	case "system":
  0x42fb6b		0f8556ffffff		JNE 0x42fac7		
  0x42fb71		8b11			MOVL 0(CX), DX		
  0x42fb73		81fa73797374		CMPL $0x74737973, DX	
  0x42fb79		0f8548ffffff		JNE 0x42fac7		
  0x42fb7f		0fb75104		MOVZX 0x4(CX), DX	
  0x42fb83		6681fa656d		CMPW $0x6d65, DX	
  0x42fb88		0f8539ffffff		JNE 0x42fac7		
  0x42fb8e		b80a000000		MOVL $0xa, AX		
	switch level {
  0x42fb93		e9c2feffff		JMP 0x42fa5a		
	case "single", "":
  0x42fb98		4883f806		CMPQ $0x6, AX		
  0x42fb9c		ebcd			JMP 0x42fb6b		
  0x42fb9e		488b4c2438		MOVQ 0x38(SP), CX	
	case "crash":
  0x42fba3		eba3			JMP 0x42fb48		
  0x42fba5		488b4c2438		MOVQ 0x38(SP), CX	
	switch level {
  0x42fbaa		48890c24		MOVQ CX, 0(SP)			
  0x42fbae		4889442408		MOVQ AX, 0x8(SP)		
  0x42fbb3		488d156ca10300		LEAQ 0x3a16c(IP), DX		
  0x42fbba		4889542410		MOVQ DX, 0x10(SP)		
  0x42fbbf		48c744241804000000	MOVQ $0x4, 0x18(SP)		
  0x42fbc8		e813690100		CALL runtime.cmpstring(SB)	
  0x42fbcd		488b442420		MOVQ 0x20(SP), AX		
  0x42fbd2		4885c0			TESTQ AX, AX			
  0x42fbd5		7f0a			JG 0x42fbe1			
  0x42fbd7		488b442440		MOVQ 0x40(SP), AX		
  0x42fbdc		e96ffeffff		JMP 0x42fa50			
  0x42fbe1		488b442440		MOVQ 0x40(SP), AX		
  0x42fbe6		e935ffffff		JMP 0x42fb20			
func setTraceback(level string) {
  0x42fbeb		e880490100		CALL runtime.morestack_noctxt(SB)	
  0x42fbf0		e92bfeffff		JMP runtime/debug.SetTraceback(SB)	

TEXT runtime.timediv(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime1.go
func timediv(v int64, div int32, rem *int32) int32 {
  0x42fc00		8b442410		MOVL 0x10(SP), AX	
  0x42fc04		488b542408		MOVQ 0x8(SP), DX	
  0x42fc09		b91e000000		MOVL $0x1e, CX		
  0x42fc0e		31db			XORL BX, BX		
	for bit := 30; bit >= 0; bit-- {
  0x42fc10		eb03			JMP 0x42fc15		
  0x42fc12		48ffc9			DECQ CX			
  0x42fc15		4885c9			TESTQ CX, CX		
  0x42fc18		7c2b			JL 0x42fc45		
		if v >= int64(div)<<uint(bit) {
  0x42fc1a		4863f0			MOVSXD AX, SI		
  0x42fc1d		48d3e6			SHLQ CL, SI		
  0x42fc20		4883f940		CMPQ $0x40, CX		
  0x42fc24		4819ff			SBBQ DI, DI		
  0x42fc27		4821fe			ANDQ DI, SI		
  0x42fc2a		4839f2			CMPQ SI, DX		
  0x42fc2d		7ce3			JL 0x42fc12		
			v = v - (int64(div) << uint(bit))
  0x42fc2f		4829f2			SUBQ SI, DX		
			res += 1 << uint(bit)
  0x42fc32		be01000000		MOVL $0x1, SI		
  0x42fc37		d3e6			SHLL CL, SI		
  0x42fc39		4883f920		CMPQ $0x20, CX		
  0x42fc3d		19ff			SBBL DI, DI		
  0x42fc3f		21fe			ANDL DI, SI		
  0x42fc41		01f3			ADDL SI, BX		
  0x42fc43		ebcd			JMP 0x42fc12		
	if v >= int64(div) {
  0x42fc45		4863c0			MOVSXD AX, AX		
  0x42fc48		4839c2			CMPQ AX, DX		
  0x42fc4b		7c19			JL 0x42fc66		
  0x42fc4d		488b442418		MOVQ 0x18(SP), AX	
		if rem != nil {
  0x42fc52		4885c0			TESTQ AX, AX		
  0x42fc55		7406			JE 0x42fc5d		
			*rem = 0
  0x42fc57		c70000000000		MOVL $0x0, 0(AX)	
		return 0x7fffffff
  0x42fc5d		c7442420ffffff7f	MOVL $0x7fffffff, 0x20(SP)	
  0x42fc65		c3			RET				
  0x42fc66		488b442418		MOVQ 0x18(SP), AX		
	if rem != nil {
  0x42fc6b		4885c0			TESTQ AX, AX		
  0x42fc6e		7402			JE 0x42fc72		
		*rem = int32(v)
  0x42fc70		8910			MOVL DX, 0(AX)		
	return res
  0x42fc72		895c2420		MOVL BX, 0x20(SP)	
  0x42fc76		c3			RET			

TEXT runtime.extendRandom(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/runtime2.go
func extendRandom(r []byte, n int) {
  0x42fc80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42fc89		483b6110		CMPQ 0x10(CX), SP	
  0x42fc8d		0f86d0000000		JBE 0x42fd63		
  0x42fc93		4883ec38		SUBQ $0x38, SP		
  0x42fc97		48896c2430		MOVQ BP, 0x30(SP)	
  0x42fc9c		488d6c2430		LEAQ 0x30(SP), BP	
  0x42fca1		488b442458		MOVQ 0x58(SP), AX	
	if n < 0 {
  0x42fca6		4885c0			TESTQ AX, AX		
  0x42fca9		7d26			JGE 0x42fcd1		
  0x42fcab		31c0			XORL AX, AX		
	for n < len(r) {
  0x42fcad		eb22			JMP 0x42fcd1		
			r[n] = byte(h)
  0x42fcaf		88041a			MOVB AL, 0(DX)(BX*1)	
		for i := 0; i < sys.PtrSize && n < len(r); i++ {
  0x42fcb2		48ffc6			INCQ SI			
			n++
  0x42fcb5		48ffc3			INCQ BX			
			h >>= 8
  0x42fcb8		48c1e808		SHRQ $0x8, AX		
		for i := 0; i < sys.PtrSize && n < len(r); i++ {
  0x42fcbc		4883fe08		CMPQ $0x8, SI		
  0x42fcc0		7d0c			JGE 0x42fcce		
  0x42fcc2		4839cb			CMPQ CX, BX		
  0x42fcc5		7d07			JGE 0x42fcce		
			r[n] = byte(h)
  0x42fcc7		72e6			JB 0x42fcaf		
  0x42fcc9		e987000000		JMP 0x42fd55		
  0x42fcce		4889d8			MOVQ BX, AX		
	for n < len(r) {
  0x42fcd1		488b4c2448		MOVQ 0x48(SP), CX	
  0x42fcd6		4839c8			CMPQ CX, AX		
  0x42fcd9		7d70			JGE 0x42fd4b		
  0x42fcdb		4889442420		MOVQ AX, 0x20(SP)	
		if w > 16 {
  0x42fce0		4883f810		CMPQ $0x10, AX		
  0x42fce4		7e60			JLE 0x42fd46		
  0x42fce6		ba10000000		MOVL $0x10, DX		
		h := memhash(unsafe.Pointer(&r[n-w]), uintptr(nanotime()), uintptr(w))
  0x42fceb		4889542428		MOVQ DX, 0x28(SP)		
  0x42fcf0		e83b7d0100		CALL runtime.nanotime(SB)	
  0x42fcf5		488b442420		MOVQ 0x20(SP), AX		
  0x42fcfa		488b4c2428		MOVQ 0x28(SP), CX		
  0x42fcff		4829c8			SUBQ CX, AX			
  0x42fd02		488b1c24		MOVQ 0(SP), BX			
  0x42fd06		488b742448		MOVQ 0x48(SP), SI		
  0x42fd0b		4839f0			CMPQ SI, AX			
  0x42fd0e		734c			JAE 0x42fd5c			
  0x42fd10		488b542440		MOVQ 0x40(SP), DX		
  0x42fd15		4801d0			ADDQ DX, AX			
  0x42fd18		48890424		MOVQ AX, 0(SP)			
  0x42fd1c		48895c2408		MOVQ BX, 0x8(SP)		
  0x42fd21		48894c2410		MOVQ CX, 0x10(SP)		
  0x42fd26		e8e55dfdff		CALL runtime.memhash(SB)	
  0x42fd2b		488b442418		MOVQ 0x18(SP), AX		
  0x42fd30		488b4c2448		MOVQ 0x48(SP), CX		
  0x42fd35		488b542440		MOVQ 0x40(SP), DX		
  0x42fd3a		488b5c2420		MOVQ 0x20(SP), BX		
  0x42fd3f		31f6			XORL SI, SI			
		for i := 0; i < sys.PtrSize && n < len(r); i++ {
  0x42fd41		e976ffffff		JMP 0x42fcbc		
  0x42fd46		4889c2			MOVQ AX, DX		
		if w > 16 {
  0x42fd49		eba0			JMP 0x42fceb		
  0x42fd4b		488b6c2430		MOVQ 0x30(SP), BP	
  0x42fd50		4883c438		ADDQ $0x38, SP		
  0x42fd54		c3			RET			
			r[n] = byte(h)
  0x42fd55		e8e6fcfeff		CALL runtime.panicindex(SB)	
  0x42fd5a		0f0b			UD2				
		h := memhash(unsafe.Pointer(&r[n-w]), uintptr(nanotime()), uintptr(w))
  0x42fd5c		e8dffcfeff		CALL runtime.panicindex(SB)	
  0x42fd61		0f0b			UD2				
func extendRandom(r []byte, n int) {
  0x42fd63		e808480100		CALL runtime.morestack_noctxt(SB)	
  0x42fd68		e913ffffff		JMP runtime.extendRandom(SB)		

TEXT runtime.(*rwmutex).rlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/rwmutex.go
func (rw *rwmutex) rlock() {
  0x42fd70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42fd79		483b6110		CMPQ 0x10(CX), SP	
  0x42fd7d		7663			JBE 0x42fde2		
  0x42fd7f		4883ec20		SUBQ $0x20, SP		
  0x42fd83		48896c2418		MOVQ BP, 0x18(SP)	
  0x42fd88		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x42fd8d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x42fd96		488b4830		MOVQ 0x30(AX), CX	
  0x42fd9a		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x42fda0		8400			TESTB AL, 0(AX)		
	if int32(atomic.Xadd(&rw.readerCount, 1)) < 0 {
  0x42fda2		b801000000		MOVL $0x1, AX		
  0x42fda7		488b4c2428		MOVQ 0x28(SP), CX	
  0x42fdac		f00fc14128		LOCK XADDL AX, 0x28(CX)	
  0x42fdb1		ffc0			INCL AX			
  0x42fdb3		85c0			TESTL AX, AX		
  0x42fdb5		7c0a			JL 0x42fdc1		
  0x42fdb7		488b6c2418		MOVQ 0x18(SP), BP	
  0x42fdbc		4883c420		ADDQ $0x20, SP		
  0x42fdc0		c3			RET			
		systemstack(func() {
  0x42fdc1		488d05d83d0100		LEAQ runtime.(*rwmutex).rlock.func1(SB), AX	
  0x42fdc8		4889442408		MOVQ AX, 0x8(SP)				
  0x42fdcd		48894c2410		MOVQ CX, 0x10(SP)				
  0x42fdd2		488d442408		LEAQ 0x8(SP), AX				
  0x42fdd7		48890424		MOVQ AX, 0(SP)					
  0x42fddb		e840460100		CALL runtime.systemstack(SB)			
  0x42fde0		ebd5			JMP 0x42fdb7					
func (rw *rwmutex) rlock() {
  0x42fde2		e889470100		CALL runtime.morestack_noctxt(SB)	
  0x42fde7		eb87			JMP runtime.(*rwmutex).rlock(SB)	

TEXT runtime.(*rwmutex).runlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/rwmutex.go
func (rw *rwmutex) runlock() {
  0x42fdf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42fdf9		483b6110		CMPQ 0x10(CX), SP	
  0x42fdfd		0f86d9000000		JBE 0x42fedc		
  0x42fe03		4883ec18		SUBQ $0x18, SP		
  0x42fe07		48896c2410		MOVQ BP, 0x10(SP)	
  0x42fe0c		488d6c2410		LEAQ 0x10(SP), BP	
	if r := int32(atomic.Xadd(&rw.readerCount, -1)); r < 0 {
  0x42fe11		b8ffffffff		MOVL $-0x1, AX		
  0x42fe16		488b4c2420		MOVQ 0x20(SP), CX	
  0x42fe1b		f00fc14128		LOCK XADDL AX, 0x28(CX)	
  0x42fe20		ffc8			DECL AX			
  0x42fe22		85c0			TESTL AX, AX		
  0x42fe24		7d24			JGE 0x42fe4a		
		if r+1 == 0 || r+1 == -rwmutexMaxReaders {
  0x42fe26		83f8ff			CMPL $-0x1, AX		
  0x42fe29		0f8492000000		JE 0x42fec1		
  0x42fe2f		3dffffffbf		CMPL $-0x40000001, AX	
  0x42fe34		0f8487000000		JE 0x42fec1		
		if atomic.Xadd(&rw.readerWait, -1) == 0 {
  0x42fe3a		b8ffffffff		MOVL $-0x1, AX		
  0x42fe3f		f00fc1412c		LOCK XADDL AX, 0x2c(CX)	
  0x42fe44		ffc8			DECL AX			
  0x42fe46		85c0			TESTL AX, AX		
  0x42fe48		743e			JE 0x42fe88		
	releasem(getg().m)
  0x42fe4a		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42fe53		488b4830		MOVQ 0x30(AX), CX	
	mp.locks--
  0x42fe57		8b9100010000		MOVL 0x100(CX), DX	
  0x42fe5d		8d5aff			LEAL -0x1(DX), BX	
  0x42fe60		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x42fe66		83fa01			CMPL $0x1, DX		
  0x42fe69		7513			JNE 0x42fe7e		
  0x42fe6b		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x42fe72		84c9			TESTL CL, CL		
  0x42fe74		7408			JE 0x42fe7e		
		_g_.stackguard0 = stackPreempt
  0x42fe76		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x42fe7e		488b6c2410		MOVQ 0x10(SP), BP	
  0x42fe83		4883c418		ADDQ $0x18, SP		
  0x42fe87		c3			RET			
			lock(&rw.rLock)
  0x42fe88		48890c24		MOVQ CX, 0(SP)		
  0x42fe8c		e88f96fdff		CALL runtime.lock(SB)	
  0x42fe91		488b442420		MOVQ 0x20(SP), AX	
			w := rw.writer.ptr()
  0x42fe96		488b4820		MOVQ 0x20(AX), CX	
			if w != nil {
  0x42fe9a		4885c9			TESTQ CX, CX		
  0x42fe9d		750b			JNE 0x42feaa		
			unlock(&rw.rLock)
  0x42fe9f		48890424		MOVQ AX, 0(SP)		
  0x42fea3		e81898fdff		CALL runtime.unlock(SB)	
  0x42fea8		eba0			JMP 0x42fe4a		
				notewakeup(&w.park)
  0x42feaa		488d8148010000		LEAQ 0x148(CX), AX		
  0x42feb1		48890424		MOVQ AX, 0(SP)			
  0x42feb5		e8d698fdff		CALL runtime.notewakeup(SB)	
  0x42feba		488b442420		MOVQ 0x20(SP), AX		
  0x42febf		ebde			JMP 0x42fe9f			
			throw("runlock of unlocked rwmutex")
  0x42fec1		488d0576bf0300		LEAQ 0x3bf76(IP), AX	
  0x42fec8		48890424		MOVQ AX, 0(SP)		
  0x42fecc		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x42fed5		e8f612ffff		CALL runtime.throw(SB)	
  0x42feda		0f0b			UD2			
func (rw *rwmutex) runlock() {
  0x42fedc		e88f460100		CALL runtime.morestack_noctxt(SB)	
  0x42fee1		e90affffff		JMP runtime.(*rwmutex).runlock(SB)	

TEXT runtime.readyWithTime(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func readyWithTime(s *sudog, traceskip int) {
  0x42fef0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42fef9		483b6110		CMPQ 0x10(CX), SP	
  0x42fefd		7653			JBE 0x42ff52		
  0x42feff		4883ec18		SUBQ $0x18, SP		
  0x42ff03		48896c2410		MOVQ BP, 0x10(SP)	
  0x42ff08		488d6c2410		LEAQ 0x10(SP), BP	
  0x42ff0d		488b442420		MOVQ 0x20(SP), AX	
	if s.releasetime != 0 {
  0x42ff12		488b4830		MOVQ 0x30(AX), CX	
  0x42ff16		4885c9			TESTQ CX, CX		
  0x42ff19		7520			JNE 0x42ff3b		
	goready(s.g, traceskip)
  0x42ff1b		488b00			MOVQ 0(AX), AX			
  0x42ff1e		48890424		MOVQ AX, 0(SP)			
  0x42ff22		488b442428		MOVQ 0x28(SP), AX		
  0x42ff27		4889442408		MOVQ AX, 0x8(SP)		
  0x42ff2c		e89f30ffff		CALL runtime.goready(SB)	
}
  0x42ff31		488b6c2410		MOVQ 0x10(SP), BP	
  0x42ff36		4883c418		ADDQ $0x18, SP		
  0x42ff3a		c3			RET			
		s.releasetime = cputicks()
  0x42ff3b		e8b05d0100		CALL runtime.cputicks(SB)	
  0x42ff40		488b0424		MOVQ 0(SP), AX			
  0x42ff44		488b4c2420		MOVQ 0x20(SP), CX		
  0x42ff49		48894130		MOVQ AX, 0x30(CX)		
  0x42ff4d		4889c8			MOVQ CX, AX			
  0x42ff50		ebc9			JMP 0x42ff1b			
func readyWithTime(s *sudog, traceskip int) {
  0x42ff52		e819460100		CALL runtime.morestack_noctxt(SB)	
  0x42ff57		eb97			JMP runtime.readyWithTime(SB)		

TEXT runtime.semacquire(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func semacquire(addr *uint32) {
  0x42ff60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ff69		483b6110		CMPQ 0x10(CX), SP	
  0x42ff6d		7634			JBE 0x42ffa3		
  0x42ff6f		4883ec20		SUBQ $0x20, SP		
  0x42ff73		48896c2418		MOVQ BP, 0x18(SP)	
  0x42ff78		488d6c2418		LEAQ 0x18(SP), BP	
  0x42ff7d		488b442428		MOVQ 0x28(SP), AX	
	semacquire1(addr, false, 0)
  0x42ff82		48890424		MOVQ AX, 0(SP)			
  0x42ff86		c644240800		MOVB $0x0, 0x8(SP)		
  0x42ff8b		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42ff94		e817000000		CALL runtime.semacquire1(SB)	
}
  0x42ff99		488b6c2418		MOVQ 0x18(SP), BP	
  0x42ff9e		4883c420		ADDQ $0x20, SP		
  0x42ffa2		c3			RET			
func semacquire(addr *uint32) {
  0x42ffa3		e8c8450100		CALL runtime.morestack_noctxt(SB)	
  0x42ffa8		ebb6			JMP runtime.semacquire(SB)		

TEXT runtime.semacquire1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {
  0x42ffb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ffb9		483b6110		CMPQ 0x10(CX), SP	
  0x42ffbd		0f86be020000		JBE 0x430281		
  0x42ffc3		4883ec68		SUBQ $0x68, SP		
  0x42ffc7		48896c2460		MOVQ BP, 0x60(SP)	
  0x42ffcc		488d6c2460		LEAQ 0x60(SP), BP	
	gp := getg()
  0x42ffd1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != gp.m.curg {
  0x42ffda		488b4830		MOVQ 0x30(AX), CX	
  0x42ffde		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x42ffe5		4839c8			CMPQ CX, AX		
  0x42ffe8		0f8578020000		JNE 0x430266		
  0x42ffee		488b442470		MOVQ 0x70(SP), AX	
	if cansemacquire(addr) {
  0x42fff3		48890424		MOVQ AX, 0(SP)			
  0x42fff7		e8b4040000		CALL runtime.cansemacquire(SB)	
  0x42fffc		0fb6442408		MOVZX 0x8(SP), AX		
  0x430001		84c0			TESTL AL, AL			
  0x430003		0f8553020000		JNE 0x43025c			
	s := acquireSudog()
  0x430009		e82230ffff		CALL runtime.acquireSudog(SB)	
  0x43000e		488b0424		MOVQ 0(SP), AX			
  0x430012		4889442440		MOVQ AX, 0x40(SP)		
  0x430017		488b4c2470		MOVQ 0x70(SP), CX		
  0x43001c		4889ca			MOVQ CX, DX			
	s.releasetime = 0
  0x43001f		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	s.acquiretime = 0
  0x430027		48c7402800000000	MOVQ $0x0, 0x28(AX)	
	s.ticket = 0
  0x43002f		c7403800000000		MOVL $0x0, 0x38(AX)	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x430036		48c1e903		SHRQ $0x3, CX			
  0x43003a		4889c3			MOVQ AX, BX			
  0x43003d		48b8474140737d7f1905	MOVQ $0x5197f7d73404147, AX	
  0x430047		4889d6			MOVQ DX, SI			
  0x43004a		48f7e1			MULQ CX				
  0x43004d		4801ca			ADDQ CX, DX			
  0x430050		48d1da			RCRQ $0x1, DX			
  0x430053		48c1ea07		SHRQ $0x7, DX			
  0x430057		4869d2fb000000		IMULQ $0xfb, DX, DX		
  0x43005e		4829d1			SUBQ DX, CX			
  0x430061		48894c2438		MOVQ CX, 0x38(SP)		
  0x430066		488b842480000000	MOVQ 0x80(SP), AX		
	if profile&semaBlockProfile != 0 && blockprofilerate > 0 {
  0x43006e		0fbae000		BTL $0x0, AX				
  0x430072		0f83dd010000		JAE 0x430255				
  0x430078		488b15a9380900		MOVQ runtime.blockprofilerate(SB), DX	
  0x43007f		4885d2			TESTQ DX, DX				
  0x430082		0f87a0010000		JA 0x430228				
  0x430088		31d2			XORL DX, DX				
	if profile&semaMutexProfile != 0 && mutexprofilerate > 0 {
  0x43008a		0fbae001		BTL $0x1, AX				
  0x43008e		7319			JAE 0x4300a9				
  0x430090		488b05f9380900		MOVQ runtime.mutexprofilerate(SB), AX	
  0x430097		4885c0			TESTQ AX, AX				
  0x43009a		760d			JBE 0x4300a9				
		if t0 == 0 {
  0x43009c		4885d2			TESTQ DX, DX		
  0x43009f		0f8466010000		JE 0x43020b		
		s.acquiretime = t0
  0x4300a5		48895328		MOVQ DX, 0x28(BX)	
  0x4300a9		4889542428		MOVQ DX, 0x28(SP)	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x4300ae		48c1e106		SHLQ $0x6, CX			
  0x4300b2		48894c2430		MOVQ CX, 0x30(SP)		
  0x4300b7		488d0542f80700		LEAQ runtime.semtable(SB), AX	
  0x4300be		488d3c08		LEAQ 0(AX)(CX*1), DI		
  0x4300c2		48897c2448		MOVQ DI, 0x48(SP)		
		lock(&root.lock)
  0x4300c7		eb11			JMP 0x4300da			
  0x4300c9		488d0530f80700		LEAQ runtime.semtable(SB), AX	
  0x4300d0		488b4c2430		MOVQ 0x30(SP), CX		
  0x4300d5		488b7c2448		MOVQ 0x48(SP), DI		
  0x4300da		8407			TESTB AL, 0(DI)			
  0x4300dc		488d1408		LEAQ 0(AX)(CX*1), DX		
  0x4300e0		4889542458		MOVQ DX, 0x58(SP)		
  0x4300e5		48891424		MOVQ DX, 0(SP)			
  0x4300e9		e83294fdff		CALL runtime.lock(SB)		
  0x4300ee		488b442430		MOVQ 0x30(SP), AX		
		atomic.Xadd(&root.nwait, 1)
  0x4300f3		488d0d06f80700		LEAQ runtime.semtable(SB), CX	
  0x4300fa		488d540110		LEAQ 0x10(CX)(AX*1), DX		
  0x4300ff		4889542450		MOVQ DX, 0x50(SP)		
  0x430104		bb01000000		MOVL $0x1, BX			
  0x430109		f00fc11a		LOCK XADDL BX, 0(DX)		
  0x43010d		488b5c2470		MOVQ 0x70(SP), BX		
		if cansemacquire(addr) {
  0x430112		48891c24		MOVQ BX, 0(SP)			
  0x430116		e895030000		CALL runtime.cansemacquire(SB)	
  0x43011b		0fb6442408		MOVZX 0x8(SP), AX		
  0x430120		84c0			TESTL AL, AL			
  0x430122		0f85c5000000		JNE 0x4301ed			
  0x430128		488b442448		MOVQ 0x48(SP), AX		
		root.queue(addr, s, lifo)
  0x43012d		48890424		MOVQ AX, 0(SP)				
  0x430131		488b4c2470		MOVQ 0x70(SP), CX			
  0x430136		48894c2408		MOVQ CX, 0x8(SP)			
  0x43013b		488b542440		MOVQ 0x40(SP), DX			
  0x430140		4889542410		MOVQ DX, 0x10(SP)			
  0x430145		0fb65c2478		MOVZX 0x78(SP), BX			
  0x43014a		885c2418		MOVB BL, 0x18(SP)			
  0x43014e		e88d030000		CALL runtime.(*semaRoot).queue(SB)	
  0x430153		488b442458		MOVQ 0x58(SP), AX			
		goparkunlock(&root.lock, "semacquire", traceEvGoBlockSync, 4)
  0x430158		48890424		MOVQ AX, 0(SP)			
  0x43015c		488d050da20300		LEAQ 0x3a20d(IP), AX		
  0x430163		4889442408		MOVQ AX, 0x8(SP)		
  0x430168		48c74424100a000000	MOVQ $0xa, 0x10(SP)		
  0x430171		c644241819		MOVB $0x19, 0x18(SP)		
  0x430176		48c744242004000000	MOVQ $0x4, 0x20(SP)		
  0x43017f		e8dc2dffff		CALL runtime.goparkunlock(SB)	
  0x430184		488b442440		MOVQ 0x40(SP), AX		
		if s.ticket != 0 || cansemacquire(addr) {
  0x430189		8b4838			MOVL 0x38(AX), CX		
  0x43018c		85c9			TESTL CX, CX			
  0x43018e		751b			JNE 0x4301ab			
  0x430190		488b442470		MOVQ 0x70(SP), AX		
  0x430195		48890424		MOVQ AX, 0(SP)			
  0x430199		e812030000		CALL runtime.cansemacquire(SB)	
  0x43019e		0fb6442408		MOVZX 0x8(SP), AX		
  0x4301a3		84c0			TESTL AL, AL			
  0x4301a5		0f841effffff		JE 0x4300c9			
  0x4301ab		488b442440		MOVQ 0x40(SP), AX		
	if s.releasetime > 0 {
  0x4301b0		488b4830		MOVQ 0x30(AX), CX	
  0x4301b4		4885c9			TESTQ CX, CX		
  0x4301b7		7f13			JG 0x4301cc		
	releaseSudog(s)
  0x4301b9		48890424		MOVQ AX, 0(SP)			
  0x4301bd		e8fe31ffff		CALL runtime.releaseSudog(SB)	
}
  0x4301c2		488b6c2460		MOVQ 0x60(SP), BP	
  0x4301c7		4883c468		ADDQ $0x68, SP		
  0x4301cb		c3			RET			
  0x4301cc		488b442428		MOVQ 0x28(SP), AX	
		blockevent(s.releasetime-t0, 3)
  0x4301d1		4829c1			SUBQ AX, CX			
  0x4301d4		48890c24		MOVQ CX, 0(SP)			
  0x4301d8		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4301e1		e80ad6feff		CALL runtime.blockevent(SB)	
  0x4301e6		488b442440		MOVQ 0x40(SP), AX		
  0x4301eb		ebcc			JMP 0x4301b9			
			atomic.Xadd(&root.nwait, -1)
  0x4301ed		b8ffffffff		MOVL $-0x1, AX		
  0x4301f2		488b4c2450		MOVQ 0x50(SP), CX	
  0x4301f7		f00fc101		LOCK XADDL AX, 0(CX)	
  0x4301fb		488b442458		MOVQ 0x58(SP), AX	
			unlock(&root.lock)
  0x430200		48890424		MOVQ AX, 0(SP)		
  0x430204		e8b794fdff		CALL runtime.unlock(SB)	
			break
  0x430209		eba0			JMP 0x4301ab		
			t0 = cputicks()
  0x43020b		e8e05a0100		CALL runtime.cputicks(SB)	
  0x430210		488b1424		MOVQ 0(SP), DX			
  0x430214		488b4c2438		MOVQ 0x38(SP), CX		
  0x430219		488b5c2440		MOVQ 0x40(SP), BX		
  0x43021e		488b742470		MOVQ 0x70(SP), SI		
  0x430223		e97dfeffff		JMP 0x4300a5			
		t0 = cputicks()
  0x430228		e8c35a0100		CALL runtime.cputicks(SB)	
  0x43022d		488b1424		MOVQ 0(SP), DX			
  0x430231		488b5c2440		MOVQ 0x40(SP), BX		
		s.releasetime = -1
  0x430236		48c74330ffffffff	MOVQ $-0x1, 0x30(BX)	
  0x43023e		488b842480000000	MOVQ 0x80(SP), AX	
  0x430246		488b4c2438		MOVQ 0x38(SP), CX	
  0x43024b		488b742470		MOVQ 0x70(SP), SI	
  0x430250		e935feffff		JMP 0x43008a		
  0x430255		31d2			XORL DX, DX		
	if profile&semaBlockProfile != 0 && blockprofilerate > 0 {
  0x430257		e92efeffff		JMP 0x43008a		
		return
  0x43025c		488b6c2460		MOVQ 0x60(SP), BP	
  0x430261		4883c468		ADDQ $0x68, SP		
  0x430265		c3			RET			
		throw("semacquire not on the G stack")
  0x430266		488d052fc10300		LEAQ 0x3c12f(IP), AX	
  0x43026d		48890424		MOVQ AX, 0(SP)		
  0x430271		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x43027a		e8510fffff		CALL runtime.throw(SB)	
  0x43027f		0f0b			UD2			
func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {
  0x430281		e8ea420100		CALL runtime.morestack_noctxt(SB)	
  0x430286		e925fdffff		JMP runtime.semacquire1(SB)		

TEXT runtime.semrelease(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func semrelease(addr *uint32) {
  0x430290		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430299		483b6110		CMPQ 0x10(CX), SP	
  0x43029d		762b			JBE 0x4302ca		
  0x43029f		4883ec18		SUBQ $0x18, SP		
  0x4302a3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4302a8		488d6c2410		LEAQ 0x10(SP), BP	
  0x4302ad		488b442420		MOVQ 0x20(SP), AX	
	semrelease1(addr, false)
  0x4302b2		48890424		MOVQ AX, 0(SP)			
  0x4302b6		c644240800		MOVB $0x0, 0x8(SP)		
  0x4302bb		e820000000		CALL runtime.semrelease1(SB)	
}
  0x4302c0		488b6c2410		MOVQ 0x10(SP), BP	
  0x4302c5		4883c418		ADDQ $0x18, SP		
  0x4302c9		c3			RET			
func semrelease(addr *uint32) {
  0x4302ca		e8a1420100		CALL runtime.morestack_noctxt(SB)	
  0x4302cf		ebbf			JMP runtime.semrelease(SB)		

TEXT runtime.semrelease1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func semrelease1(addr *uint32, handoff bool) {
  0x4302e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4302e9		483b6110		CMPQ 0x10(CX), SP	
  0x4302ed		0f86ae010000		JBE 0x4304a1		
  0x4302f3		4883ec50		SUBQ $0x50, SP		
  0x4302f7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4302fc		488d6c2448		LEAQ 0x48(SP), BP	
  0x430301		488b4c2458		MOVQ 0x58(SP), CX	
  0x430306		4889ca			MOVQ CX, DX		
	atomic.Xadd(addr, 1)
  0x430309		bb01000000		MOVL $0x1, BX		
  0x43030e		f00fc11a		LOCK XADDL BX, 0(DX)	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x430312		48c1e903		SHRQ $0x3, CX			
  0x430316		48b8474140737d7f1905	MOVQ $0x5197f7d73404147, AX	
  0x430320		48f7e1			MULQ CX				
  0x430323		4801ca			ADDQ CX, DX			
  0x430326		48d1da			RCRQ $0x1, DX			
  0x430329		48c1ea07		SHRQ $0x7, DX			
  0x43032d		4869d2fb000000		IMULQ $0xfb, DX, DX		
  0x430334		4829d1			SUBQ DX, CX			
  0x430337		48c1e106		SHLQ $0x6, CX			
  0x43033b		488d15bef50700		LEAQ runtime.semtable(SB), DX	
  0x430342		488d340a		LEAQ 0(DX)(CX*1), SI		
	if atomic.Load(&root.nwait) == 0 {
  0x430346		8406			TESTB AL, 0(SI)		
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x430348		488d3c0a		LEAQ 0(DX)(CX*1), DI	
	if atomic.Load(&root.nwait) == 0 {
  0x43034c		8b7f10			MOVL 0x10(DI), DI	
  0x43034f		4c8d440a10		LEAQ 0x10(DX)(CX*1), R8	
  0x430354		85ff			TESTL DI, DI		
  0x430356		0f8420010000		JE 0x43047c		
  0x43035c		4889742430		MOVQ SI, 0x30(SP)	
  0x430361		4c89442440		MOVQ R8, 0x40(SP)	
	lock(&root.lock)
  0x430366		488d040a		LEAQ 0(DX)(CX*1), AX	
  0x43036a		4889442438		MOVQ AX, 0x38(SP)	
  0x43036f		48890424		MOVQ AX, 0(SP)		
  0x430373		e8a891fdff		CALL runtime.lock(SB)	
  0x430378		488b442440		MOVQ 0x40(SP), AX	
	if atomic.Load(&root.nwait) == 0 {
  0x43037d		8b08			MOVL 0(AX), CX		
  0x43037f		85c9			TESTL CX, CX		
  0x430381		0f84dd000000		JE 0x430464		
  0x430387		488b442430		MOVQ 0x30(SP), AX	
	s, t0 := root.dequeue(addr)
  0x43038c		48890424		MOVQ AX, 0(SP)				
  0x430390		488b442458		MOVQ 0x58(SP), AX			
  0x430395		4889442408		MOVQ AX, 0x8(SP)			
  0x43039a		e8d1050000		CALL runtime.(*semaRoot).dequeue(SB)	
  0x43039f		488b442410		MOVQ 0x10(SP), AX			
  0x4303a4		4889442428		MOVQ AX, 0x28(SP)			
  0x4303a9		488b4c2418		MOVQ 0x18(SP), CX			
  0x4303ae		48894c2420		MOVQ CX, 0x20(SP)			
	if s != nil {
  0x4303b3		4885c0			TESTQ AX, AX		
  0x4303b6		740e			JE 0x4303c6		
		atomic.Xadd(&root.nwait, -1)
  0x4303b8		baffffffff		MOVL $-0x1, DX		
  0x4303bd		488b5c2440		MOVQ 0x40(SP), BX	
  0x4303c2		f00fc113		LOCK XADDL DX, 0(BX)	
  0x4303c6		488b442438		MOVQ 0x38(SP), AX	
	unlock(&root.lock)
  0x4303cb		48890424		MOVQ AX, 0(SP)		
  0x4303cf		e8ec92fdff		CALL runtime.unlock(SB)	
  0x4303d4		488b442428		MOVQ 0x28(SP), AX	
	if s != nil {
  0x4303d9		4885c0			TESTQ AX, AX		
	if s != nil { // May be slow, so unlock first
  0x4303dc		742f			JE 0x43040d		
		acquiretime := s.acquiretime
  0x4303de		488b4828		MOVQ 0x28(AX), CX	
		if acquiretime != 0 {
  0x4303e2		4885c9			TESTQ CX, CX		
  0x4303e5		755c			JNE 0x430443		
		if s.ticket != 0 {
  0x4303e7		8b4838			MOVL 0x38(AX), CX	
  0x4303ea		85c9			TESTL CX, CX		
  0x4303ec		0f8594000000		JNE 0x430486		
  0x4303f2		0fb64c2460		MOVZX 0x60(SP), CX	
func semrelease1(addr *uint32, handoff bool) {
  0x4303f7		84c9			TESTL CL, CL		
		if handoff && cansemacquire(addr) {
  0x4303f9		751c			JNE 0x430417		
		readyWithTime(s, 5)
  0x4303fb		48890424		MOVQ AX, 0(SP)			
  0x4303ff		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x430408		e8e3faffff		CALL runtime.readyWithTime(SB)	
  0x43040d		488b6c2448		MOVQ 0x48(SP), BP		
  0x430412		4883c450		ADDQ $0x50, SP			
  0x430416		c3			RET				
  0x430417		488b442458		MOVQ 0x58(SP), AX		
		if handoff && cansemacquire(addr) {
  0x43041c		48890424		MOVQ AX, 0(SP)			
  0x430420		e88b000000		CALL runtime.cansemacquire(SB)	
  0x430425		0fb6442408		MOVZX 0x8(SP), AX		
  0x43042a		84c0			TESTL AL, AL			
  0x43042c		740e			JE 0x43043c			
  0x43042e		488b442428		MOVQ 0x28(SP), AX		
			s.ticket = 1
  0x430433		c7403801000000		MOVL $0x1, 0x38(AX)	
  0x43043a		ebbf			JMP 0x4303fb		
  0x43043c		488b442428		MOVQ 0x28(SP), AX	
		if handoff && cansemacquire(addr) {
  0x430441		ebb8			JMP 0x4303fb		
  0x430443		488b442420		MOVQ 0x20(SP), AX	
			mutexevent(t0-acquiretime, 3)
  0x430448		4829c8			SUBQ CX, AX		
  0x43044b		48890424		MOVQ AX, 0(SP)		
  0x43044f		48c744240803000000	MOVQ $0x3, 0x8(SP)	
  0x430458		e853d6feff		CALL sync.event(SB)	
  0x43045d		488b442428		MOVQ 0x28(SP), AX	
  0x430462		eb83			JMP 0x4303e7		
  0x430464		488b442438		MOVQ 0x38(SP), AX	
		unlock(&root.lock)
  0x430469		48890424		MOVQ AX, 0(SP)		
  0x43046d		e84e92fdff		CALL runtime.unlock(SB)	
		return
  0x430472		488b6c2448		MOVQ 0x48(SP), BP	
  0x430477		4883c450		ADDQ $0x50, SP		
  0x43047b		c3			RET			
		return
  0x43047c		488b6c2448		MOVQ 0x48(SP), BP	
  0x430481		4883c450		ADDQ $0x50, SP		
  0x430485		c3			RET			
			throw("corrupted semaphore ticket")
  0x430486		488d0519b70300		LEAQ 0x3b719(IP), AX	
  0x43048d		48890424		MOVQ AX, 0(SP)		
  0x430491		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x43049a		e8310dffff		CALL runtime.throw(SB)	
  0x43049f		0f0b			UD2			
func semrelease1(addr *uint32, handoff bool) {
  0x4304a1		e8ca400100		CALL runtime.morestack_noctxt(SB)	
  0x4304a6		e935feffff		JMP runtime.semrelease1(SB)		

TEXT runtime.cansemacquire(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func cansemacquire(addr *uint32) bool {
  0x4304b0		488b4c2408		MOVQ 0x8(SP), CX	
		v := atomic.Load(addr)
  0x4304b5		8b11			MOVL 0(CX), DX		
		if v == 0 {
  0x4304b7		85d2			TESTL DX, DX		
  0x4304b9		7416			JE 0x4304d1		
		if atomic.Cas(addr, v, v-1) {
  0x4304bb		8d5aff			LEAL -0x1(DX), BX	
  0x4304be		89d0			MOVL DX, AX		
  0x4304c0		f00fb119		LOCK CMPXCHGL BX, 0(CX)	
  0x4304c4		0f94c2			SETE DL			
  0x4304c7		84d2			TESTL DL, DL		
  0x4304c9		74ea			JE 0x4304b5		
			return true
  0x4304cb		c644241001		MOVB $0x1, 0x10(SP)	
  0x4304d0		c3			RET			
			return false
  0x4304d1		c644241000		MOVB $0x0, 0x10(SP)	
  0x4304d6		c3			RET			

TEXT runtime.(*semaRoot).queue(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x4304e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4304e9		483b6110		CMPQ 0x10(CX), SP	
  0x4304ed		0f866b040000		JBE 0x43095e		
  0x4304f3		4883ec18		SUBQ $0x18, SP		
  0x4304f7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4304fc		488d6c2410		LEAQ 0x10(SP), BP	
  0x430501		488b442430		MOVQ 0x30(SP), AX	
	s.g = getg()
  0x430506		8400			TESTB AL, 0(AX)				
  0x430508		8b0d02350900		MOVL runtime.writeBarrier(SB), CX	
  0x43050e		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX			
	s.elem = unsafe.Pointer(addr)
  0x430517		488d5820		LEAQ 0x20(AX), BX	
	s.next = nil
  0x43051b		488d7810		LEAQ 0x10(AX), DI	
	s.prev = nil
  0x43051f		488d7018		LEAQ 0x18(AX), SI	
	s.g = getg()
  0x430523		85c9			TESTL CX, CX		
  0x430525		0f85d1030000		JNE 0x4308fc		
  0x43052b		488910			MOVQ DX, 0(AX)		
  0x43052e		488b4c2428		MOVQ 0x28(SP), CX	
	s.elem = unsafe.Pointer(addr)
  0x430533		48894820		MOVQ CX, 0x20(AX)	
	s.prev = nil
  0x430537		0f57c0			XORPS X0, X0		
  0x43053a		0f114010		MOVUPS X0, 0x10(AX)	
	s.g = getg()
  0x43053e		488b542420		MOVQ 0x20(SP), DX	
	pt := &root.treap
  0x430543		488d5a08		LEAQ 0x8(DX), BX	
	for t := *pt; t != nil; t = *pt {
  0x430547		8403			TESTB AL, 0(BX)		
  0x430549		4c8b4208		MOVQ 0x8(DX), R8	
  0x43054d		4531c9			XORL R9, R9		
  0x430550		eb12			JMP 0x430564		
  0x430552		4c8b11			MOVQ 0(CX), R10		
  0x430555		4d89c1			MOVQ R8, R9		
  0x430558		4d89d0			MOVQ R10, R8		
  0x43055b		4989cb			MOVQ CX, R11		
  0x43055e		4889d9			MOVQ BX, CX		
  0x430561		4c89db			MOVQ R11, BX		
  0x430564		4d85c0			TESTQ R8, R8		
  0x430567		0f84a1020000		JE 0x43080e		
		if t.elem == unsafe.Pointer(addr) {
  0x43056d		4d8b4820		MOVQ 0x20(R8), R9	
  0x430571		4c39c9			CMPQ R9, CX		
  0x430574		7414			JE 0x43058a		
  0x430576		4889cb			MOVQ CX, BX		
		if uintptr(unsafe.Pointer(addr)) < uintptr(t.elem) {
  0x430579		4c39c9			CMPQ R9, CX		
  0x43057c		7306			JAE 0x430584		
			pt = &t.prev
  0x43057e		498d4818		LEAQ 0x18(R8), CX	
  0x430582		ebce			JMP 0x430552		
			pt = &t.next
  0x430584		498d4810		LEAQ 0x10(R8), CX	
  0x430588		ebc8			JMP 0x430552		
  0x43058a		0fb64c2438		MOVZX 0x38(SP), CX	
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x43058f		84c9			TESTL CL, CL		
			if lifo {
  0x430591		0f84f1010000		JE 0x430788		
				*pt = s
  0x430597		8403			TESTB AL, 0(BX)				
  0x430599		8b0d71340900		MOVL runtime.writeBarrier(SB), CX	
  0x43059f		85c9			TESTL CX, CX				
  0x4305a1		0f85ce010000		JNE 0x430775				
  0x4305a7		488903			MOVQ AX, 0(BX)				
				s.ticket = t.ticket
  0x4305aa		418b4838		MOVL 0x38(R8), CX	
  0x4305ae		894838			MOVL CX, 0x38(AX)	
				s.acquiretime = t.acquiretime
  0x4305b1		498b4828		MOVQ 0x28(R8), CX	
  0x4305b5		48894828		MOVQ CX, 0x28(AX)	
				s.parent = t.parent
  0x4305b9		8b0d51340900		MOVL runtime.writeBarrier(SB), CX	
  0x4305bf		488d5040		LEAQ 0x40(AX), DX			
  0x4305c3		498b5840		MOVQ 0x40(R8), BX			
  0x4305c7		4d8d4840		LEAQ 0x40(R8), R9			
  0x4305cb		85c9			TESTL CX, CX				
  0x4305cd		0f8586010000		JNE 0x430759				
  0x4305d3		48895840		MOVQ BX, 0x40(AX)			
				s.prev = t.prev
  0x4305d7		8b0d33340900		MOVL runtime.writeBarrier(SB), CX	
  0x4305dd		498b5018		MOVQ 0x18(R8), DX			
  0x4305e1		498d5818		LEAQ 0x18(R8), BX			
  0x4305e5		85c9			TESTL CX, CX				
  0x4305e7		0f8550010000		JNE 0x43073d				
  0x4305ed		48895018		MOVQ DX, 0x18(AX)			
				s.next = t.next
  0x4305f1		8b0d19340900		MOVL runtime.writeBarrier(SB), CX	
  0x4305f7		498b5010		MOVQ 0x10(R8), DX			
  0x4305fb		498d7010		LEAQ 0x10(R8), SI			
  0x4305ff		85c9			TESTL CX, CX				
  0x430601		0f8523010000		JNE 0x43072a				
  0x430607		48895010		MOVQ DX, 0x10(AX)			
				if s.prev != nil {
  0x43060b		488b4818		MOVQ 0x18(AX), CX	
  0x43060f		4885c9			TESTQ CX, CX		
  0x430612		7416			JE 0x43062a		
					s.prev.parent = s
  0x430614		8b15f6330900		MOVL runtime.writeBarrier(SB), DX	
  0x43061a		488d7940		LEAQ 0x40(CX), DI			
  0x43061e		85d2			TESTL DX, DX				
  0x430620		0f85fa000000		JNE 0x430720				
  0x430626		48894140		MOVQ AX, 0x40(CX)			
				if s.next != nil {
  0x43062a		488b4810		MOVQ 0x10(AX), CX	
  0x43062e		4885c9			TESTQ CX, CX		
  0x430631		7416			JE 0x430649		
					s.next.parent = s
  0x430633		8b15d7330900		MOVL runtime.writeBarrier(SB), DX	
  0x430639		488d7940		LEAQ 0x40(CX), DI			
  0x43063d		85d2			TESTL DX, DX				
  0x43063f		0f85d1000000		JNE 0x430716				
  0x430645		48894140		MOVQ AX, 0x40(CX)			
				s.waitlink = t
  0x430649		8b0dc1330900		MOVL runtime.writeBarrier(SB), CX	
  0x43064f		488d7848		LEAQ 0x48(AX), DI			
  0x430653		85c9			TESTL CX, CX				
  0x430655		0f85a8000000		JNE 0x430703				
  0x43065b		4c894048		MOVQ R8, 0x48(AX)			
				s.waittail = t.waittail
  0x43065f		8b0dab330900		MOVL runtime.writeBarrier(SB), CX	
  0x430665		488d7850		LEAQ 0x50(AX), DI			
  0x430669		498b5050		MOVQ 0x50(R8), DX			
  0x43066d		4d8d5050		LEAQ 0x50(R8), R10			
  0x430671		85c9			TESTL CX, CX				
  0x430673		757b			JNE 0x4306f0				
  0x430675		48895050		MOVQ DX, 0x50(AX)			
				if s.waittail == nil {
  0x430679		4885d2			TESTQ DX, DX		
  0x43067c		7458			JE 0x4306d6		
				t.parent = nil
  0x43067e		8b0d8c330900		MOVL runtime.writeBarrier(SB), CX	
  0x430684		85c9			TESTL CX, CX				
  0x430686		752a			JNE 0x4306b2				
  0x430688		49c7404000000000	MOVQ $0x0, 0x40(R8)			
				t.prev = nil
  0x430690		49c7401800000000	MOVQ $0x0, 0x18(R8)	
				t.next = nil
  0x430698		49c7401000000000	MOVQ $0x0, 0x10(R8)	
				t.waittail = nil
  0x4306a0		49c7405000000000	MOVQ $0x0, 0x50(R8)	
			return
  0x4306a8		488b6c2410		MOVQ 0x10(SP), BP	
  0x4306ad		4883c418		ADDQ $0x18, SP		
  0x4306b1		c3			RET			
  0x4306b2		4c89cf			MOVQ R9, DI		
				t.parent = nil
  0x4306b5		31c0			XORL AX, AX			
  0x4306b7		e8e4610100		CALL runtime.gcWriteBarrier(SB)	
  0x4306bc		4889df			MOVQ BX, DI			
				t.prev = nil
  0x4306bf		e8dc610100		CALL runtime.gcWriteBarrier(SB)	
  0x4306c4		4889f7			MOVQ SI, DI			
				t.next = nil
  0x4306c7		e8d4610100		CALL runtime.gcWriteBarrier(SB)	
  0x4306cc		4c89d7			MOVQ R10, DI			
				t.waittail = nil
  0x4306cf		e8cc610100		CALL runtime.gcWriteBarrier(SB)	
				t.parent = nil
  0x4306d4		ebd2			JMP 0x4306a8		
					s.waittail = t
  0x4306d6		8b0d34330900		MOVL runtime.writeBarrier(SB), CX	
  0x4306dc		85c9			TESTL CX, CX				
  0x4306de		7506			JNE 0x4306e6				
  0x4306e0		4c894050		MOVQ R8, 0x50(AX)			
  0x4306e4		eb98			JMP 0x43067e				
  0x4306e6		4c89c0			MOVQ R8, AX				
  0x4306e9		e8b2610100		CALL runtime.gcWriteBarrier(SB)		
  0x4306ee		eb8e			JMP 0x43067e				
  0x4306f0		4889c1			MOVQ AX, CX				
  0x4306f3		4889d0			MOVQ DX, AX				
				s.waittail = t.waittail
  0x4306f6		e8a5610100		CALL runtime.gcWriteBarrier(SB)	
  0x4306fb		4889c8			MOVQ CX, AX			
  0x4306fe		e976ffffff		JMP 0x430679			
  0x430703		4889c1			MOVQ AX, CX			
  0x430706		4c89c0			MOVQ R8, AX			
				s.waitlink = t
  0x430709		e892610100		CALL runtime.gcWriteBarrier(SB)	
  0x43070e		4889c8			MOVQ CX, AX			
  0x430711		e949ffffff		JMP 0x43065f			
					s.next.parent = s
  0x430716		e885610100		CALL runtime.gcWriteBarrier(SB)	
  0x43071b		e929ffffff		JMP 0x430649			
					s.prev.parent = s
  0x430720		e87b610100		CALL runtime.gcWriteBarrier(SB)	
  0x430725		e900ffffff		JMP 0x43062a			
  0x43072a		4889c1			MOVQ AX, CX			
  0x43072d		4889d0			MOVQ DX, AX			
				s.next = t.next
  0x430730		e86b610100		CALL runtime.gcWriteBarrier(SB)	
  0x430735		4889c8			MOVQ CX, AX			
  0x430738		e9cefeffff		JMP 0x43060b			
  0x43073d		4889f9			MOVQ DI, CX			
  0x430740		4889f7			MOVQ SI, DI			
  0x430743		4989c2			MOVQ AX, R10			
  0x430746		4889d0			MOVQ DX, AX			
				s.prev = t.prev
  0x430749		e852610100		CALL runtime.gcWriteBarrier(SB)	
  0x43074e		4c89d0			MOVQ R10, AX			
  0x430751		4889cf			MOVQ CX, DI			
  0x430754		e998feffff		JMP 0x4305f1			
  0x430759		4889f9			MOVQ DI, CX			
  0x43075c		4889d7			MOVQ DX, DI			
  0x43075f		4989c2			MOVQ AX, R10			
  0x430762		4889d8			MOVQ BX, AX			
				s.parent = t.parent
  0x430765		e836610100		CALL runtime.gcWriteBarrier(SB)	
  0x43076a		4c89d0			MOVQ R10, AX			
  0x43076d		4889cf			MOVQ CX, DI			
  0x430770		e962feffff		JMP 0x4305d7			
  0x430775		4889f9			MOVQ DI, CX			
  0x430778		4889df			MOVQ BX, DI			
				*pt = s
  0x43077b		e820610100		CALL runtime.gcWriteBarrier(SB)	
  0x430780		4889cf			MOVQ CX, DI			
  0x430783		e922feffff		JMP 0x4305aa			
				if t.waittail == nil {
  0x430788		498b4850		MOVQ 0x50(R8), CX	
  0x43078c		498d7850		LEAQ 0x50(R8), DI	
  0x430790		4885c9			TESTQ CX, CX		
  0x430793		7455			JE 0x4307ea		
					t.waittail.waitlink = s
  0x430795		8b1575320900		MOVL runtime.writeBarrier(SB), DX	
  0x43079b		488d5948		LEAQ 0x48(CX), BX			
  0x43079f		85d2			TESTL DX, DX				
  0x4307a1		7537			JNE 0x4307da				
  0x4307a3		48894148		MOVQ AX, 0x48(CX)			
				t.waittail = s
  0x4307a7		8b0d63320900		MOVL runtime.writeBarrier(SB), CX	
				s.waitlink = nil
  0x4307ad		488d5048		LEAQ 0x48(AX), DX	
				t.waittail = s
  0x4307b1		85c9			TESTL CX, CX		
  0x4307b3		7511			JNE 0x4307c6		
  0x4307b5		49894050		MOVQ AX, 0x50(R8)	
				s.waitlink = nil
  0x4307b9		48c7404800000000	MOVQ $0x0, 0x48(AX)	
				t.waittail = s
  0x4307c1		e9e2feffff		JMP 0x4306a8			
  0x4307c6		e8d5600100		CALL runtime.gcWriteBarrier(SB)	
  0x4307cb		4889d7			MOVQ DX, DI			
				s.waitlink = nil
  0x4307ce		31c0			XORL AX, AX			
  0x4307d0		e8cb600100		CALL runtime.gcWriteBarrier(SB)	
				t.waittail = s
  0x4307d5		e9cefeffff		JMP 0x4306a8		
  0x4307da		4889f9			MOVQ DI, CX		
  0x4307dd		4889df			MOVQ BX, DI		
					t.waittail.waitlink = s
  0x4307e0		e8bb600100		CALL runtime.gcWriteBarrier(SB)	
  0x4307e5		4889cf			MOVQ CX, DI			
  0x4307e8		ebbd			JMP 0x4307a7			
					t.waitlink = s
  0x4307ea		8b0d20320900		MOVL runtime.writeBarrier(SB), CX	
  0x4307f0		498d5048		LEAQ 0x48(R8), DX			
  0x4307f4		85c9			TESTL CX, CX				
  0x4307f6		7506			JNE 0x4307fe				
  0x4307f8		49894048		MOVQ AX, 0x48(R8)			
  0x4307fc		eba9			JMP 0x4307a7				
  0x4307fe		4889f9			MOVQ DI, CX				
  0x430801		4889d7			MOVQ DX, DI				
  0x430804		e897600100		CALL runtime.gcWriteBarrier(SB)		
  0x430809		4889cf			MOVQ CX, DI				
  0x43080c		eb99			JMP 0x4307a7				
	mp := getg().m
  0x43080e		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430817		488b4930		MOVQ 0x30(CX), CX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x43081b		8bb120010000		MOVL 0x120(CX), SI	
  0x430821		448b8124010000		MOVL 0x124(CX), R8	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x430828		44898120010000		MOVL R8, 0x120(CX)	
  0x43082f		4189f2			MOVL SI, R10		
	s1 ^= s1 << 17
  0x430832		c1e611			SHLL $0x11, SI		
  0x430835		4431d6			XORL R10, SI		
  0x430838		4589c2			MOVL R8, R10		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x43083b		4131f0			XORL SI, R8		
  0x43083e		c1ee07			SHRL $0x7, SI		
  0x430841		4431c6			XORL R8, SI		
  0x430844		4589d0			MOVL R10, R8		
  0x430847		41c1ea10		SHRL $0x10, R10		
  0x43084b		4131f2			XORL SI, R10		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x43084e		44899124010000		MOVL R10, 0x124(CX)	
	return s0 + s1
  0x430855		438d0c10		LEAL 0(R8)(R10*1), CX	
	s.ticket = fastrand() | 1
  0x430859		83c901			ORL $0x1, CX		
  0x43085c		894838			MOVL CX, 0x38(AX)	
	s.parent = last
  0x43085f		8b0dab310900		MOVL runtime.writeBarrier(SB), CX	
  0x430865		488d7840		LEAQ 0x40(AX), DI			
  0x430869		85c9			TESTL CX, CX				
  0x43086b		757c			JNE 0x4308e9				
  0x43086d		4c894840		MOVQ R9, 0x40(AX)			
	*pt = s
  0x430871		8403			TESTB AL, 0(BX)				
  0x430873		8b0d97310900		MOVL runtime.writeBarrier(SB), CX	
  0x430879		85c9			TESTL CX, CX				
  0x43087b		7562			JNE 0x4308df				
  0x43087d		488903			MOVQ AX, 0(BX)				
	for s.parent != nil && s.parent.ticket > s.ticket {
  0x430880		eb0a			JMP 0x43088c		
  0x430882		488b442430		MOVQ 0x30(SP), AX	
  0x430887		488b542420		MOVQ 0x20(SP), DX	
  0x43088c		488b4840		MOVQ 0x40(AX), CX	
  0x430890		4885c9			TESTQ CX, CX		
  0x430893		7440			JE 0x4308d5		
  0x430895		8b5938			MOVL 0x38(CX), BX	
  0x430898		8b7038			MOVL 0x38(AX), SI	
  0x43089b		39f3			CMPL SI, BX		
  0x43089d		7636			JBE 0x4308d5		
		if s.parent.prev == s {
  0x43089f		488b5918		MOVQ 0x18(CX), BX	
  0x4308a3		4839d8			CMPQ BX, AX		
  0x4308a6		741d			JE 0x4308c5		
			if s.parent.next != s {
  0x4308a8		488b5910		MOVQ 0x10(CX), BX	
  0x4308ac		4839c3			CMPQ AX, BX		
  0x4308af		0f858b000000		JNE 0x430940		
			root.rotateLeft(s.parent)
  0x4308b5		48894c2408		MOVQ CX, 0x8(SP)			
  0x4308ba		48891424		MOVQ DX, 0(SP)				
  0x4308be		e85d040000		CALL runtime.(*semaRoot).rotateLeft(SB)	
  0x4308c3		ebbd			JMP 0x430882				
			root.rotateRight(s.parent)
  0x4308c5		48894c2408		MOVQ CX, 0x8(SP)				
  0x4308ca		48891424		MOVQ DX, 0(SP)					
  0x4308ce		e88d060000		CALL runtime.(*semaRoot).rotateRight(SB)	
  0x4308d3		ebad			JMP 0x430882					
  0x4308d5		488b6c2410		MOVQ 0x10(SP), BP				
  0x4308da		4883c418		ADDQ $0x18, SP					
  0x4308de		c3			RET						
  0x4308df		4889df			MOVQ BX, DI					
	*pt = s
  0x4308e2		e8b95f0100		CALL runtime.gcWriteBarrier(SB)	
  0x4308e7		eba3			JMP 0x43088c			
  0x4308e9		4889c1			MOVQ AX, CX			
  0x4308ec		4c89c8			MOVQ R9, AX			
	s.parent = last
  0x4308ef		e8ac5f0100		CALL runtime.gcWriteBarrier(SB)	
  0x4308f4		4889c8			MOVQ CX, AX			
  0x4308f7		e975ffffff		JMP 0x430871			
  0x4308fc		4889f9			MOVQ DI, CX			
  0x4308ff		4889c7			MOVQ AX, DI			
  0x430902		4889d0			MOVQ DX, AX			
	s.g = getg()
  0x430905		e8965f0100		CALL runtime.gcWriteBarrier(SB)	
  0x43090a		4889f8			MOVQ DI, AX			
  0x43090d		4889df			MOVQ BX, DI			
  0x430910		4889c2			MOVQ AX, DX			
  0x430913		488b442428		MOVQ 0x28(SP), AX		
	s.elem = unsafe.Pointer(addr)
  0x430918		e8835f0100		CALL runtime.gcWriteBarrier(SB)	
  0x43091d		4889cf			MOVQ CX, DI			
  0x430920		4889c3			MOVQ AX, BX			
	s.next = nil
  0x430923		31c0			XORL AX, AX			
  0x430925		e8765f0100		CALL runtime.gcWriteBarrier(SB)	
  0x43092a		4889f7			MOVQ SI, DI			
	s.prev = nil
  0x43092d		e86e5f0100		CALL runtime.gcWriteBarrier(SB)	
  0x430932		4889d0			MOVQ DX, AX			
  0x430935		4889cf			MOVQ CX, DI			
  0x430938		4889d9			MOVQ BX, CX			
	s.g = getg()
  0x43093b		e9fefbffff		JMP 0x43053e		
				panic("semaRoot queue")
  0x430940		488d05596a0200		LEAQ 0x26a59(IP), AX			
  0x430947		48890424		MOVQ AX, 0(SP)				
  0x43094b		488d054e440400		LEAQ runtime.statictmp_25(SB), AX	
  0x430952		4889442408		MOVQ AX, 0x8(SP)			
  0x430957		e8d400ffff		CALL runtime.gopanic(SB)		
  0x43095c		0f0b			UD2					
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x43095e		e80d3c0100		CALL runtime.morestack_noctxt(SB)	
  0x430963		e978fbffff		JMP runtime.(*semaRoot).queue(SB)	

TEXT runtime.(*semaRoot).dequeue(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func (root *semaRoot) dequeue(addr *uint32) (found *sudog, now int64) {
  0x430970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430979		483b6110		CMPQ 0x10(CX), SP	
  0x43097d		0f8691030000		JBE 0x430d14		
  0x430983		4883ec40		SUBQ $0x40, SP		
  0x430987		48896c2438		MOVQ BP, 0x38(SP)	
  0x43098c		488d6c2438		LEAQ 0x38(SP), BP	
  0x430991		488b4c2448		MOVQ 0x48(SP), CX	
	ps := &root.treap
  0x430996		488d7908		LEAQ 0x8(CX), DI	
	s := *ps
  0x43099a		8407			TESTB AL, 0(DI)		
  0x43099c		488b5108		MOVQ 0x8(CX), DX	
  0x4309a0		488b5c2450		MOVQ 0x50(SP), BX	
  0x4309a5		4889f8			MOVQ DI, AX		
	for ; s != nil; s = *ps {
  0x4309a8		eb0c			JMP 0x4309b6		
  0x4309aa		488b32			MOVQ 0(DX), SI		
  0x4309ad		4c89c3			MOVQ R8, BX		
  0x4309b0		4889d7			MOVQ DX, DI		
  0x4309b3		4889f2			MOVQ SI, DX		
  0x4309b6		4885d2			TESTQ DX, DX		
  0x4309b9		0f8439030000		JE 0x430cf8		
		if s.elem == unsafe.Pointer(addr) {
  0x4309bf		488b7220		MOVQ 0x20(DX), SI	
  0x4309c3		4c8d4220		LEAQ 0x20(DX), R8	
  0x4309c7		4839f3			CMPQ SI, BX		
  0x4309ca		7414			JE 0x4309e0		
  0x4309cc		4989d8			MOVQ BX, R8		
		if uintptr(unsafe.Pointer(addr)) < uintptr(s.elem) {
  0x4309cf		4839f3			CMPQ SI, BX		
  0x4309d2		7306			JAE 0x4309da		
			ps = &s.prev
  0x4309d4		4883c218		ADDQ $0x18, DX		
  0x4309d8		ebd0			JMP 0x4309aa		
			ps = &s.next
  0x4309da		4883c210		ADDQ $0x10, DX		
  0x4309de		ebca			JMP 0x4309aa		
  0x4309e0		4889442430		MOVQ AX, 0x30(SP)	
  0x4309e5		4889542418		MOVQ DX, 0x18(SP)	
  0x4309ea		4c89442428		MOVQ R8, 0x28(SP)	
	if s.acquiretime != 0 {
  0x4309ef		488b5a28		MOVQ 0x28(DX), BX	
  0x4309f3		4885db			TESTQ BX, BX		
  0x4309f6		0f85d0020000		JNE 0x430ccc		
  0x4309fc		31db			XORL BX, BX		
	if t := s.waitlink; t != nil {
  0x4309fe		488b7248		MOVQ 0x48(DX), SI	
  0x430a02		4c8d4a48		LEAQ 0x48(DX), R9	
  0x430a06		4885f6			TESTQ SI, SI		
  0x430a09		0f855f010000		JNE 0x430b6e		
  0x430a0f		48895c2410		MOVQ BX, 0x10(SP)	
		for s.next != nil || s.prev != nil {
  0x430a14		eb19			JMP 0x430a2f		
  0x430a16		488b442430		MOVQ 0x30(SP), AX	
  0x430a1b		488b4c2448		MOVQ 0x48(SP), CX	
  0x430a20		488b542418		MOVQ 0x18(SP), DX	
  0x430a25		488b5c2410		MOVQ 0x10(SP), BX	
  0x430a2a		4c8b442428		MOVQ 0x28(SP), R8	
  0x430a2f		488b7210		MOVQ 0x10(DX), SI	
  0x430a33		4885f6			TESTQ SI, SI		
  0x430a36		7435			JE 0x430a6d		
			if s.next == nil || s.prev != nil && s.prev.ticket < s.next.ticket {
  0x430a38		7413			JE 0x430a4d		
  0x430a3a		488b7a18		MOVQ 0x18(DX), DI	
  0x430a3e		4885ff			TESTQ DI, DI		
  0x430a41		741a			JE 0x430a5d		
  0x430a43		8b7f38			MOVL 0x38(DI), DI	
  0x430a46		8b7638			MOVL 0x38(SI), SI	
  0x430a49		39f7			CMPL SI, DI		
  0x430a4b		7310			JAE 0x430a5d		
				root.rotateRight(s)
  0x430a4d		48890c24		MOVQ CX, 0(SP)					
  0x430a51		4889542408		MOVQ DX, 0x8(SP)				
  0x430a56		e805050000		CALL runtime.(*semaRoot).rotateRight(SB)	
  0x430a5b		ebb9			JMP 0x430a16					
				root.rotateLeft(s)
  0x430a5d		48890c24		MOVQ CX, 0(SP)				
  0x430a61		4889542408		MOVQ DX, 0x8(SP)			
  0x430a66		e8b5020000		CALL runtime.(*semaRoot).rotateLeft(SB)	
  0x430a6b		eba9			JMP 0x430a16				
		for s.next != nil || s.prev != nil {
  0x430a6d		4c8b4a18		MOVQ 0x18(DX), R9	
  0x430a71		4d85c9			TESTQ R9, R9		
  0x430a74		7405			JE 0x430a7b		
  0x430a76		4885f6			TESTQ SI, SI		
  0x430a79		ebbd			JMP 0x430a38		
		if s.parent != nil {
  0x430a7b		488b7240		MOVQ 0x40(DX), SI	
  0x430a7f		4885f6			TESTQ SI, SI		
  0x430a82		0f84c0000000		JE 0x430b48		
			if s.parent.prev == s {
  0x430a88		488b4e18		MOVQ 0x18(SI), CX	
  0x430a8c		488d7e18		LEAQ 0x18(SI), DI	
  0x430a90		4839ca			CMPQ CX, DX		
  0x430a93		0f8588000000		JNE 0x430b21		
				s.parent.prev = nil
  0x430a99		8b0d712f0900		MOVL runtime.writeBarrier(SB), CX	
  0x430a9f		85c9			TESTL CX, CX				
  0x430aa1		7575			JNE 0x430b18				
  0x430aa3		48c7461800000000	MOVQ $0x0, 0x18(SI)			
	s.parent = nil
  0x430aab		8b0d5f2f0900		MOVL runtime.writeBarrier(SB), CX	
  0x430ab1		488d7a40		LEAQ 0x40(DX), DI			
	s.next = nil
  0x430ab5		488d7210		LEAQ 0x10(DX), SI	
	s.prev = nil
  0x430ab9		4c8d4a18		LEAQ 0x18(DX), R9	
	s.parent = nil
  0x430abd		85c9			TESTL CX, CX		
  0x430abf		7532			JNE 0x430af3		
  0x430ac1		48c7424000000000	MOVQ $0x0, 0x40(DX)	
	s.elem = nil
  0x430ac9		48c7422000000000	MOVQ $0x0, 0x20(DX)	
	s.prev = nil
  0x430ad1		0f57c0			XORPS X0, X0		
  0x430ad4		0f114210		MOVUPS X0, 0x10(DX)	
	s.ticket = 0
  0x430ad8		c7423800000000		MOVL $0x0, 0x38(DX)	
	return s, now
  0x430adf		4889542458		MOVQ DX, 0x58(SP)	
  0x430ae4		48895c2460		MOVQ BX, 0x60(SP)	
  0x430ae9		488b6c2438		MOVQ 0x38(SP), BP	
  0x430aee		4883c440		ADDQ $0x40, SP		
  0x430af2		c3			RET			
	s.parent = nil
  0x430af3		31c0			XORL AX, AX			
  0x430af5		e8a65d0100		CALL runtime.gcWriteBarrier(SB)	
  0x430afa		4c89c7			MOVQ R8, DI			
	s.elem = nil
  0x430afd		31c0			XORL AX, AX			
  0x430aff		e89c5d0100		CALL runtime.gcWriteBarrier(SB)	
  0x430b04		4889f7			MOVQ SI, DI			
	s.next = nil
  0x430b07		31c0			XORL AX, AX			
  0x430b09		e8925d0100		CALL runtime.gcWriteBarrier(SB)	
  0x430b0e		4c89cf			MOVQ R9, DI			
	s.prev = nil
  0x430b11		e88a5d0100		CALL runtime.gcWriteBarrier(SB)	
	s.parent = nil
  0x430b16		ebc0			JMP 0x430ad8		
				s.parent.prev = nil
  0x430b18		31c0			XORL AX, AX			
  0x430b1a		e8815d0100		CALL runtime.gcWriteBarrier(SB)	
  0x430b1f		eb8a			JMP 0x430aab			
				s.parent.next = nil
  0x430b21		8b0de92e0900		MOVL runtime.writeBarrier(SB), CX	
  0x430b27		488d7e10		LEAQ 0x10(SI), DI			
  0x430b2b		85c9			TESTL CX, CX				
  0x430b2d		750d			JNE 0x430b3c				
  0x430b2f		48c7461000000000	MOVQ $0x0, 0x10(SI)			
  0x430b37		e96fffffff		JMP 0x430aab				
  0x430b3c		31c0			XORL AX, AX				
  0x430b3e		e85d5d0100		CALL runtime.gcWriteBarrier(SB)		
  0x430b43		e963ffffff		JMP 0x430aab				
			root.treap = nil
  0x430b48		8b35c22e0900		MOVL runtime.writeBarrier(SB), SI	
  0x430b4e		85f6			TESTL SI, SI				
  0x430b50		750d			JNE 0x430b5f				
  0x430b52		48c7410800000000	MOVQ $0x0, 0x8(CX)			
  0x430b5a		e94cffffff		JMP 0x430aab				
  0x430b5f		4889c7			MOVQ AX, DI				
  0x430b62		31c0			XORL AX, AX				
  0x430b64		e8375d0100		CALL runtime.gcWriteBarrier(SB)		
  0x430b69		e93dffffff		JMP 0x430aab				
		*ps = t
  0x430b6e		8407			TESTB AL, 0(DI)				
  0x430b70		8b0d9a2e0900		MOVL runtime.writeBarrier(SB), CX	
  0x430b76		85c9			TESTL CX, CX				
  0x430b78		0f8541010000		JNE 0x430cbf				
  0x430b7e		488937			MOVQ SI, 0(DI)				
		t.ticket = s.ticket
  0x430b81		8b4a38			MOVL 0x38(DX), CX	
  0x430b84		894e38			MOVL CX, 0x38(SI)	
		t.parent = s.parent
  0x430b87		8b0d832e0900		MOVL runtime.writeBarrier(SB), CX	
  0x430b8d		488d7e40		LEAQ 0x40(SI), DI			
  0x430b91		488b4240		MOVQ 0x40(DX), AX			
  0x430b95		85c9			TESTL CX, CX				
  0x430b97		0f8518010000		JNE 0x430cb5				
  0x430b9d		48894640		MOVQ AX, 0x40(SI)			
		t.prev = s.prev
  0x430ba1		8b0d692e0900		MOVL runtime.writeBarrier(SB), CX	
  0x430ba7		488d7e18		LEAQ 0x18(SI), DI			
  0x430bab		488b4218		MOVQ 0x18(DX), AX			
  0x430baf		85c9			TESTL CX, CX				
  0x430bb1		0f85f4000000		JNE 0x430cab				
  0x430bb7		48894618		MOVQ AX, 0x18(SI)			
		if t.prev != nil {
  0x430bbb		4885c0			TESTQ AX, AX		
  0x430bbe		7416			JE 0x430bd6		
			t.prev.parent = t
  0x430bc0		8b0d4a2e0900		MOVL runtime.writeBarrier(SB), CX	
  0x430bc6		488d7840		LEAQ 0x40(AX), DI			
  0x430bca		85c9			TESTL CX, CX				
  0x430bcc		0f85cc000000		JNE 0x430c9e				
  0x430bd2		48897040		MOVQ SI, 0x40(AX)			
		t.next = s.next
  0x430bd6		8b0d342e0900		MOVL runtime.writeBarrier(SB), CX	
  0x430bdc		488d7e10		LEAQ 0x10(SI), DI			
  0x430be0		488b4210		MOVQ 0x10(DX), AX			
  0x430be4		85c9			TESTL CX, CX				
  0x430be6		0f85a8000000		JNE 0x430c94				
  0x430bec		48894610		MOVQ AX, 0x10(SI)			
		if t.next != nil {
  0x430bf0		4885c0			TESTQ AX, AX		
  0x430bf3		7416			JE 0x430c0b		
			t.next.parent = t
  0x430bf5		8b0d152e0900		MOVL runtime.writeBarrier(SB), CX	
  0x430bfb		488d7840		LEAQ 0x40(AX), DI			
  0x430bff		85c9			TESTL CX, CX				
  0x430c01		0f8580000000		JNE 0x430c87				
  0x430c07		48897040		MOVQ SI, 0x40(AX)			
		if t.waitlink != nil {
  0x430c0b		488b4e48		MOVQ 0x48(SI), CX	
  0x430c0f		4885c9			TESTQ CX, CX		
  0x430c12		7452			JE 0x430c66		
			t.waittail = s.waittail
  0x430c14		8b0df62d0900		MOVL runtime.writeBarrier(SB), CX	
  0x430c1a		488d7e50		LEAQ 0x50(SI), DI			
  0x430c1e		488b4250		MOVQ 0x50(DX), AX			
  0x430c22		85c9			TESTL CX, CX				
  0x430c24		7539			JNE 0x430c5f				
  0x430c26		48894650		MOVQ AX, 0x50(SI)			
		t.acquiretime = now
  0x430c2a		48895e28		MOVQ BX, 0x28(SI)	
		s.waitlink = nil
  0x430c2e		8b0ddc2d0900		MOVL runtime.writeBarrier(SB), CX	
		s.waittail = nil
  0x430c34		488d7250		LEAQ 0x50(DX), SI	
		s.waitlink = nil
  0x430c38		85c9			TESTL CX, CX		
  0x430c3a		750c			JNE 0x430c48		
		s.waittail = nil
  0x430c3c		0f57c0			XORPS X0, X0		
  0x430c3f		0f114248		MOVUPS X0, 0x48(DX)	
		s.waitlink = nil
  0x430c43		e963feffff		JMP 0x430aab			
  0x430c48		4c89cf			MOVQ R9, DI			
  0x430c4b		31c0			XORL AX, AX			
  0x430c4d		e84e5c0100		CALL runtime.gcWriteBarrier(SB)	
  0x430c52		4889f7			MOVQ SI, DI			
		s.waittail = nil
  0x430c55		e8465c0100		CALL runtime.gcWriteBarrier(SB)	
		s.waitlink = nil
  0x430c5a		e94cfeffff		JMP 0x430aab		
			t.waittail = s.waittail
  0x430c5f		e83c5c0100		CALL runtime.gcWriteBarrier(SB)	
  0x430c64		ebc4			JMP 0x430c2a			
			t.waittail = nil
  0x430c66		8b0da42d0900		MOVL runtime.writeBarrier(SB), CX	
  0x430c6c		488d7e50		LEAQ 0x50(SI), DI			
  0x430c70		85c9			TESTL CX, CX				
  0x430c72		750a			JNE 0x430c7e				
  0x430c74		48c7465000000000	MOVQ $0x0, 0x50(SI)			
  0x430c7c		ebac			JMP 0x430c2a				
  0x430c7e		31c0			XORL AX, AX				
  0x430c80		e81b5c0100		CALL runtime.gcWriteBarrier(SB)		
  0x430c85		eba3			JMP 0x430c2a				
  0x430c87		4889f0			MOVQ SI, AX				
			t.next.parent = t
  0x430c8a		e8115c0100		CALL runtime.gcWriteBarrier(SB)	
  0x430c8f		e977ffffff		JMP 0x430c0b			
		t.next = s.next
  0x430c94		e8075c0100		CALL runtime.gcWriteBarrier(SB)	
  0x430c99		e952ffffff		JMP 0x430bf0			
  0x430c9e		4889f0			MOVQ SI, AX			
			t.prev.parent = t
  0x430ca1		e8fa5b0100		CALL runtime.gcWriteBarrier(SB)	
  0x430ca6		e92bffffff		JMP 0x430bd6			
		t.prev = s.prev
  0x430cab		e8f05b0100		CALL runtime.gcWriteBarrier(SB)	
  0x430cb0		e906ffffff		JMP 0x430bbb			
		t.parent = s.parent
  0x430cb5		e8e65b0100		CALL runtime.gcWriteBarrier(SB)	
  0x430cba		e9e2feffff		JMP 0x430ba1			
  0x430cbf		4889f0			MOVQ SI, AX			
		*ps = t
  0x430cc2		e8d95b0100		CALL runtime.gcWriteBarrier(SB)	
  0x430cc7		e9b5feffff		JMP 0x430b81			
  0x430ccc		48897c2420		MOVQ DI, 0x20(SP)		
		now = cputicks()
  0x430cd1		e81a500100		CALL runtime.cputicks(SB)	
  0x430cd6		488b1c24		MOVQ 0(SP), BX			
  0x430cda		488b442430		MOVQ 0x30(SP), AX		
  0x430cdf		488b4c2448		MOVQ 0x48(SP), CX		
  0x430ce4		488b542418		MOVQ 0x18(SP), DX		
  0x430ce9		488b7c2420		MOVQ 0x20(SP), DI		
  0x430cee		4c8b442428		MOVQ 0x28(SP), R8		
  0x430cf3		e906fdffff		JMP 0x4309fe			
	return nil, 0
  0x430cf8		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x430d01		48c744246000000000	MOVQ $0x0, 0x60(SP)	
  0x430d0a		488b6c2438		MOVQ 0x38(SP), BP	
  0x430d0f		4883c440		ADDQ $0x40, SP		
  0x430d13		c3			RET			
func (root *semaRoot) dequeue(addr *uint32) (found *sudog, now int64) {
  0x430d14		e857380100		CALL runtime.morestack_noctxt(SB)	
  0x430d19		e952fcffff		JMP runtime.(*semaRoot).dequeue(SB)	

TEXT runtime.(*semaRoot).rotateLeft(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func (root *semaRoot) rotateLeft(x *sudog) {
  0x430d20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430d29		483b6110		CMPQ 0x10(CX), SP	
  0x430d2d		0f861c020000		JBE 0x430f4f		
  0x430d33		4883ec18		SUBQ $0x18, SP		
  0x430d37		48896c2410		MOVQ BP, 0x10(SP)	
  0x430d3c		488d6c2410		LEAQ 0x10(SP), BP	
  0x430d41		488b442428		MOVQ 0x28(SP), AX	
	a, y := x.prev, x.next
  0x430d46		488b4810		MOVQ 0x10(AX), CX	
	p := x.parent
  0x430d4a		488b5040		MOVQ 0x40(AX), DX	
  0x430d4e		488d5840		LEAQ 0x40(AX), BX	
	a, y := x.prev, x.next
  0x430d52		488b7018		MOVQ 0x18(AX), SI	
  0x430d56		488d7818		LEAQ 0x18(AX), DI	
  0x430d5a		4c8d4010		LEAQ 0x10(AX), R8	
	b, c := y.prev, y.next
  0x430d5e		4c8b4918		MOVQ 0x18(CX), R9	
  0x430d62		4c8d5118		LEAQ 0x18(CX), R10	
  0x430d66		4c8b5910		MOVQ 0x10(CX), R11	
  0x430d6a		4c8d6110		LEAQ 0x10(CX), R12	
	y.prev = x
  0x430d6e		448b2d9b2c0900		MOVL runtime.writeBarrier(SB), R13	
  0x430d75		4585ed			TESTL R13, R13				
  0x430d78		0f8587010000		JNE 0x430f05				
  0x430d7e		48894118		MOVQ AX, 0x18(CX)			
	x.parent = y
  0x430d82		48894840		MOVQ CX, 0x40(AX)	
	y.next = c
  0x430d86		4c895910		MOVQ R11, 0x10(CX)	
	if c != nil {
  0x430d8a		4d85db			TESTQ R11, R11		
  0x430d8d		7416			JE 0x430da5		
		c.parent = y
  0x430d8f		8b1d7b2c0900		MOVL runtime.writeBarrier(SB), BX	
  0x430d95		4d8d5340		LEAQ 0x40(R11), R10			
  0x430d99		85db			TESTL BX, BX				
  0x430d9b		0f8548010000		JNE 0x430ee9				
  0x430da1		49894b40		MOVQ CX, 0x40(R11)			
	x.prev = a
  0x430da5		8b1d652c0900		MOVL runtime.writeBarrier(SB), BX	
  0x430dab		85db			TESTL BX, BX				
  0x430dad		0f8523010000		JNE 0x430ed6				
  0x430db3		48897018		MOVQ SI, 0x18(AX)			
	if a != nil {
  0x430db7		4885f6			TESTQ SI, SI		
  0x430dba		7416			JE 0x430dd2		
		a.parent = x
  0x430dbc		8b1d4e2c0900		MOVL runtime.writeBarrier(SB), BX	
  0x430dc2		488d7e40		LEAQ 0x40(SI), DI			
  0x430dc6		85db			TESTL BX, BX				
  0x430dc8		0f85fe000000		JNE 0x430ecc				
  0x430dce		48894640		MOVQ AX, 0x40(SI)			
	x.next = b
  0x430dd2		8b1d382c0900		MOVL runtime.writeBarrier(SB), BX	
  0x430dd8		85db			TESTL BX, BX				
  0x430dda		0f85d6000000		JNE 0x430eb6				
  0x430de0		4c894810		MOVQ R9, 0x10(AX)			
	if b != nil {
  0x430de4		4d85c9			TESTQ R9, R9		
  0x430de7		7416			JE 0x430dff		
		b.parent = x
  0x430de9		8b1d212c0900		MOVL runtime.writeBarrier(SB), BX	
  0x430def		498d7940		LEAQ 0x40(R9), DI			
  0x430df3		85db			TESTL BX, BX				
  0x430df5		0f85b1000000		JNE 0x430eac				
  0x430dfb		49894140		MOVQ AX, 0x40(R9)			
	y.parent = p
  0x430dff		8b1d0b2c0900		MOVL runtime.writeBarrier(SB), BX	
  0x430e05		488d7940		LEAQ 0x40(CX), DI			
  0x430e09		85db			TESTL BX, BX				
  0x430e0b		0f8588000000		JNE 0x430e99				
  0x430e11		48895140		MOVQ DX, 0x40(CX)			
	if p == nil {
  0x430e15		4885d2			TESTQ DX, DX		
  0x430e18		745a			JE 0x430e74		
	} else if p.prev == x {
  0x430e1a		488b5a18		MOVQ 0x18(DX), BX	
  0x430e1e		488d7a18		LEAQ 0x18(DX), DI	
  0x430e22		4839c3			CMPQ AX, BX		
  0x430e25		7522			JNE 0x430e49		
		p.prev = y
  0x430e27		8b1de32b0900		MOVL runtime.writeBarrier(SB), BX	
  0x430e2d		85db			TESTL BX, BX				
  0x430e2f		750e			JNE 0x430e3f				
  0x430e31		48894a18		MOVQ CX, 0x18(DX)			
  0x430e35		488b6c2410		MOVQ 0x10(SP), BP			
  0x430e3a		4883c418		ADDQ $0x18, SP				
  0x430e3e		c3			RET					
  0x430e3f		4889c8			MOVQ CX, AX				
  0x430e42		e8595a0100		CALL runtime.gcWriteBarrier(SB)		
  0x430e47		ebec			JMP 0x430e35				
		if p.next != x {
  0x430e49		488b5a10		MOVQ 0x10(DX), BX	
  0x430e4d		488d7a10		LEAQ 0x10(DX), DI	
  0x430e51		4839c3			CMPQ AX, BX		
  0x430e54		0f85da000000		JNE 0x430f34		
		p.next = y
  0x430e5a		8b1db02b0900		MOVL runtime.writeBarrier(SB), BX	
  0x430e60		85db			TESTL BX, BX				
  0x430e62		7506			JNE 0x430e6a				
  0x430e64		48894a10		MOVQ CX, 0x10(DX)			
  0x430e68		ebcb			JMP 0x430e35				
  0x430e6a		4889c8			MOVQ CX, AX				
  0x430e6d		e82e5a0100		CALL runtime.gcWriteBarrier(SB)		
  0x430e72		ebc1			JMP 0x430e35				
  0x430e74		488b542420		MOVQ 0x20(SP), DX			
		root.treap = y
  0x430e79		8402			TESTB AL, 0(DX)				
  0x430e7b		8b1d8f2b0900		MOVL runtime.writeBarrier(SB), BX	
  0x430e81		488d7a08		LEAQ 0x8(DX), DI			
  0x430e85		85db			TESTL BX, BX				
  0x430e87		7506			JNE 0x430e8f				
  0x430e89		48894a08		MOVQ CX, 0x8(DX)			
  0x430e8d		eba6			JMP 0x430e35				
  0x430e8f		4889c8			MOVQ CX, AX				
  0x430e92		e8095a0100		CALL runtime.gcWriteBarrier(SB)		
  0x430e97		eb9c			JMP 0x430e35				
  0x430e99		4889c3			MOVQ AX, BX				
  0x430e9c		4889d0			MOVQ DX, AX				
	y.parent = p
  0x430e9f		e8fc590100		CALL runtime.gcWriteBarrier(SB)	
  0x430ea4		4889d8			MOVQ BX, AX			
  0x430ea7		e969ffffff		JMP 0x430e15			
		b.parent = x
  0x430eac		e8ef590100		CALL runtime.gcWriteBarrier(SB)	
  0x430eb1		e949ffffff		JMP 0x430dff			
  0x430eb6		4c89c7			MOVQ R8, DI			
  0x430eb9		4889c3			MOVQ AX, BX			
  0x430ebc		4c89c8			MOVQ R9, AX			
	x.next = b
  0x430ebf		e8dc590100		CALL runtime.gcWriteBarrier(SB)	
  0x430ec4		4889d8			MOVQ BX, AX			
  0x430ec7		e918ffffff		JMP 0x430de4			
		a.parent = x
  0x430ecc		e8cf590100		CALL runtime.gcWriteBarrier(SB)	
  0x430ed1		e9fcfeffff		JMP 0x430dd2			
  0x430ed6		4889c3			MOVQ AX, BX			
  0x430ed9		4889f0			MOVQ SI, AX			
	x.prev = a
  0x430edc		e8bf590100		CALL runtime.gcWriteBarrier(SB)	
  0x430ee1		4889d8			MOVQ BX, AX			
  0x430ee4		e9cefeffff		JMP 0x430db7			
  0x430ee9		4889fb			MOVQ DI, BX			
  0x430eec		4c89d7			MOVQ R10, DI			
  0x430eef		4989c3			MOVQ AX, R11			
  0x430ef2		4889c8			MOVQ CX, AX			
		c.parent = y
  0x430ef5		e8a6590100		CALL runtime.gcWriteBarrier(SB)	
  0x430efa		4c89d8			MOVQ R11, AX			
  0x430efd		4889df			MOVQ BX, DI			
  0x430f00		e9a0feffff		JMP 0x430da5			
  0x430f05		4989fd			MOVQ DI, R13			
  0x430f08		4c89d7			MOVQ R10, DI			
	y.prev = x
  0x430f0b		e890590100		CALL runtime.gcWriteBarrier(SB)	
  0x430f10		4889df			MOVQ BX, DI			
  0x430f13		4989c2			MOVQ AX, R10			
  0x430f16		4889c8			MOVQ CX, AX			
	x.parent = y
  0x430f19		e882590100		CALL runtime.gcWriteBarrier(SB)	
  0x430f1e		4c89e7			MOVQ R12, DI			
  0x430f21		4c89d8			MOVQ R11, AX			
	y.next = c
  0x430f24		e877590100		CALL runtime.gcWriteBarrier(SB)	
  0x430f29		4c89d0			MOVQ R10, AX			
  0x430f2c		4c89ef			MOVQ R13, DI			
	y.prev = x
  0x430f2f		e956feffff		JMP 0x430d8a		
			throw("semaRoot rotateLeft")
  0x430f34		488d0555a00300		LEAQ 0x3a055(IP), AX	
  0x430f3b		48890424		MOVQ AX, 0(SP)		
  0x430f3f		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x430f48		e88302ffff		CALL runtime.throw(SB)	
  0x430f4d		0f0b			UD2			
func (root *semaRoot) rotateLeft(x *sudog) {
  0x430f4f		e81c360100		CALL runtime.morestack_noctxt(SB)	
  0x430f54		e9c7fdffff		JMP runtime.(*semaRoot).rotateLeft(SB)	

TEXT runtime.(*semaRoot).rotateRight(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sema.go
func (root *semaRoot) rotateRight(y *sudog) {
  0x430f60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430f69		483b6110		CMPQ 0x10(CX), SP	
  0x430f6d		0f86fb010000		JBE 0x43116e		
  0x430f73		4883ec18		SUBQ $0x18, SP		
  0x430f77		48896c2410		MOVQ BP, 0x10(SP)	
  0x430f7c		488d6c2410		LEAQ 0x10(SP), BP	
  0x430f81		488b442428		MOVQ 0x28(SP), AX	
	x, c := y.prev, y.next
  0x430f86		488b4818		MOVQ 0x18(AX), CX	
	p := y.parent
  0x430f8a		488b5040		MOVQ 0x40(AX), DX	
  0x430f8e		488d5840		LEAQ 0x40(AX), BX	
	x, c := y.prev, y.next
  0x430f92		488d7018		LEAQ 0x18(AX), SI	
  0x430f96		4c8b4010		MOVQ 0x10(AX), R8	
  0x430f9a		488d7810		LEAQ 0x10(AX), DI	
	a, b := x.prev, x.next
  0x430f9e		4c8b4918		MOVQ 0x18(CX), R9	
  0x430fa2		4c8b5110		MOVQ 0x10(CX), R10	
  0x430fa6		4c8d5910		LEAQ 0x10(CX), R11	
	if a != nil {
  0x430faa		4d85c9			TESTQ R9, R9		
  0x430fad		7418			JE 0x430fc7		
		a.parent = x
  0x430faf		448b255a2a0900		MOVL runtime.writeBarrier(SB), R12	
  0x430fb6		4d8d6940		LEAQ 0x40(R9), R13			
  0x430fba		4585e4			TESTL R12, R12				
  0x430fbd		0f8574010000		JNE 0x431137				
  0x430fc3		49894940		MOVQ CX, 0x40(R9)			
	x.next = y
  0x430fc7		448b0d422a0900		MOVL runtime.writeBarrier(SB), R9	
  0x430fce		4585c9			TESTL R9, R9				
  0x430fd1		0f8531010000		JNE 0x431108				
  0x430fd7		48894110		MOVQ AX, 0x10(CX)			
	y.parent = x
  0x430fdb		48894840		MOVQ CX, 0x40(AX)	
	y.prev = b
  0x430fdf		4c895018		MOVQ R10, 0x18(AX)	
	if b != nil {
  0x430fe3		4d85d2			TESTQ R10, R10		
  0x430fe6		7416			JE 0x430ffe		
		b.parent = y
  0x430fe8		8b1d222a0900		MOVL runtime.writeBarrier(SB), BX	
  0x430fee		498d7240		LEAQ 0x40(R10), SI			
  0x430ff2		85db			TESTL BX, BX				
  0x430ff4		0f85fb000000		JNE 0x4310f5				
  0x430ffa		49894240		MOVQ AX, 0x40(R10)			
	y.next = c
  0x430ffe		8b1d0c2a0900		MOVL runtime.writeBarrier(SB), BX	
  0x431004		85db			TESTL BX, BX				
  0x431006		0f85d6000000		JNE 0x4310e2				
  0x43100c		4c894010		MOVQ R8, 0x10(AX)			
	if c != nil {
  0x431010		4d85c0			TESTQ R8, R8		
  0x431013		7416			JE 0x43102b		
		c.parent = y
  0x431015		8b1df5290900		MOVL runtime.writeBarrier(SB), BX	
  0x43101b		498d7840		LEAQ 0x40(R8), DI			
  0x43101f		85db			TESTL BX, BX				
  0x431021		0f85b1000000		JNE 0x4310d8				
  0x431027		49894040		MOVQ AX, 0x40(R8)			
	x.parent = p
  0x43102b		8b1ddf290900		MOVL runtime.writeBarrier(SB), BX	
  0x431031		488d7940		LEAQ 0x40(CX), DI			
  0x431035		85db			TESTL BX, BX				
  0x431037		0f8588000000		JNE 0x4310c5				
  0x43103d		48895140		MOVQ DX, 0x40(CX)			
	if p == nil {
  0x431041		4885d2			TESTQ DX, DX		
  0x431044		745a			JE 0x4310a0		
	} else if p.prev == y {
  0x431046		488b5a18		MOVQ 0x18(DX), BX	
  0x43104a		488d7a18		LEAQ 0x18(DX), DI	
  0x43104e		4839c3			CMPQ AX, BX		
  0x431051		7522			JNE 0x431075		
		p.prev = x
  0x431053		8b1db7290900		MOVL runtime.writeBarrier(SB), BX	
  0x431059		85db			TESTL BX, BX				
  0x43105b		750e			JNE 0x43106b				
  0x43105d		48894a18		MOVQ CX, 0x18(DX)			
  0x431061		488b6c2410		MOVQ 0x10(SP), BP			
  0x431066		4883c418		ADDQ $0x18, SP				
  0x43106a		c3			RET					
  0x43106b		4889c8			MOVQ CX, AX				
  0x43106e		e82d580100		CALL runtime.gcWriteBarrier(SB)		
  0x431073		ebec			JMP 0x431061				
		if p.next != y {
  0x431075		488b5a10		MOVQ 0x10(DX), BX	
  0x431079		488d7a10		LEAQ 0x10(DX), DI	
  0x43107d		4839c3			CMPQ AX, BX		
  0x431080		0f85cd000000		JNE 0x431153		
		p.next = x
  0x431086		8b1d84290900		MOVL runtime.writeBarrier(SB), BX	
  0x43108c		85db			TESTL BX, BX				
  0x43108e		7506			JNE 0x431096				
  0x431090		48894a10		MOVQ CX, 0x10(DX)			
  0x431094		ebcb			JMP 0x431061				
  0x431096		4889c8			MOVQ CX, AX				
  0x431099		e802580100		CALL runtime.gcWriteBarrier(SB)		
  0x43109e		ebc1			JMP 0x431061				
  0x4310a0		488b542420		MOVQ 0x20(SP), DX			
		root.treap = x
  0x4310a5		8402			TESTB AL, 0(DX)				
  0x4310a7		8b1d63290900		MOVL runtime.writeBarrier(SB), BX	
  0x4310ad		488d7a08		LEAQ 0x8(DX), DI			
  0x4310b1		85db			TESTL BX, BX				
  0x4310b3		7506			JNE 0x4310bb				
  0x4310b5		48894a08		MOVQ CX, 0x8(DX)			
  0x4310b9		eba6			JMP 0x431061				
  0x4310bb		4889c8			MOVQ CX, AX				
  0x4310be		e8dd570100		CALL runtime.gcWriteBarrier(SB)		
  0x4310c3		eb9c			JMP 0x431061				
  0x4310c5		4889c3			MOVQ AX, BX				
  0x4310c8		4889d0			MOVQ DX, AX				
	x.parent = p
  0x4310cb		e8d0570100		CALL runtime.gcWriteBarrier(SB)	
  0x4310d0		4889d8			MOVQ BX, AX			
  0x4310d3		e969ffffff		JMP 0x431041			
		c.parent = y
  0x4310d8		e8c3570100		CALL runtime.gcWriteBarrier(SB)	
  0x4310dd		e949ffffff		JMP 0x43102b			
  0x4310e2		4889c3			MOVQ AX, BX			
  0x4310e5		4c89c0			MOVQ R8, AX			
	y.next = c
  0x4310e8		e8b3570100		CALL runtime.gcWriteBarrier(SB)	
  0x4310ed		4889d8			MOVQ BX, AX			
  0x4310f0		e91bffffff		JMP 0x431010			
  0x4310f5		4889fb			MOVQ DI, BX			
  0x4310f8		4889f7			MOVQ SI, DI			
		b.parent = y
  0x4310fb		e8a0570100		CALL runtime.gcWriteBarrier(SB)	
  0x431100		4889df			MOVQ BX, DI			
  0x431103		e9f6feffff		JMP 0x430ffe			
  0x431108		4989f9			MOVQ DI, R9			
  0x43110b		4c89df			MOVQ R11, DI			
	x.next = y
  0x43110e		e88d570100		CALL runtime.gcWriteBarrier(SB)	
  0x431113		4889df			MOVQ BX, DI			
  0x431116		4989c3			MOVQ AX, R11			
  0x431119		4889c8			MOVQ CX, AX			
	y.parent = x
  0x43111c		e87f570100		CALL runtime.gcWriteBarrier(SB)	
  0x431121		4889f7			MOVQ SI, DI			
  0x431124		4c89d0			MOVQ R10, AX			
	y.prev = b
  0x431127		e874570100		CALL runtime.gcWriteBarrier(SB)	
  0x43112c		4c89d8			MOVQ R11, AX			
  0x43112f		4c89cf			MOVQ R9, DI			
	x.next = y
  0x431132		e9acfeffff		JMP 0x430fe3		
  0x431137		4989f9			MOVQ DI, R9		
  0x43113a		4c89ef			MOVQ R13, DI		
  0x43113d		4989c4			MOVQ AX, R12		
  0x431140		4889c8			MOVQ CX, AX		
		a.parent = x
  0x431143		e858570100		CALL runtime.gcWriteBarrier(SB)	
  0x431148		4c89e0			MOVQ R12, AX			
  0x43114b		4c89cf			MOVQ R9, DI			
  0x43114e		e974feffff		JMP 0x430fc7			
			throw("semaRoot rotateRight")
  0x431153		488d058ba00300		LEAQ 0x3a08b(IP), AX	
  0x43115a		48890424		MOVQ AX, 0(SP)		
  0x43115e		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x431167		e86400ffff		CALL runtime.throw(SB)	
  0x43116c		0f0b			UD2			
func (root *semaRoot) rotateRight(y *sudog) {
  0x43116e		e8fd330100		CALL runtime.morestack_noctxt(SB)	
  0x431173		e9e8fdffff		JMP runtime.(*semaRoot).rotateRight(SB)	

TEXT runtime.dumpregs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_amd64x.go
func dumpregs(c *sigctxt) {
  0x431180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x431189		488d4424d0		LEAQ -0x30(SP), AX	
  0x43118e		483b4110		CMPQ 0x10(CX), AX	
  0x431192		0f8616070000		JBE 0x4318ae		
  0x431198		4881ecb0000000		SUBQ $0xb0, SP		
  0x43119f		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x4311a7		488dac24a8000000	LEAQ 0xa8(SP), BP	
  0x4311af		488b8424b8000000	MOVQ 0xb8(SP), AX	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4311b7		488b4808		MOVQ 0x8(AX), CX	
  0x4311bb		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rax() uint64 { return c.regs().rax }
  0x4311bf		8402			TESTB AL, 0(DX)		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4311c1		8400			TESTB AL, 0(AX)		
func (c *sigctxt) rax() uint64 { return c.regs().rax }
  0x4311c3		488b8990000000		MOVQ 0x90(CX), CX	
  0x4311ca		48894c2460		MOVQ CX, 0x60(SP)	
	print("rax    ", hex(c.rax()), "\n")
  0x4311cf		e82c09ffff		CALL runtime.printlock(SB)	
  0x4311d4		488d05438d0300		LEAQ 0x38d43(IP), AX		
  0x4311db		48890424		MOVQ AX, 0(SP)			
  0x4311df		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4311e8		e85312ffff		CALL runtime.printstring(SB)	
  0x4311ed		488b442460		MOVQ 0x60(SP), AX		
  0x4311f2		48890424		MOVQ AX, 0(SP)			
  0x4311f6		e8f510ffff		CALL runtime.printhex(SB)	
  0x4311fb		e8900bffff		CALL runtime.printnl(SB)	
  0x431200		e87b09ffff		CALL runtime.printunlock(SB)	
  0x431205		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43120d		488b4808		MOVQ 0x8(AX), CX	
  0x431211		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rbx() uint64 { return c.regs().rbx }
  0x431215		8402			TESTB AL, 0(DX)		
  0x431217		488b8980000000		MOVQ 0x80(CX), CX	
  0x43121e		48894c2478		MOVQ CX, 0x78(SP)	
	print("rbx    ", hex(c.rbx()), "\n")
  0x431223		e8d808ffff		CALL runtime.printlock(SB)	
  0x431228		488d05fd8c0300		LEAQ 0x38cfd(IP), AX		
  0x43122f		48890424		MOVQ AX, 0(SP)			
  0x431233		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43123c		e8ff11ffff		CALL runtime.printstring(SB)	
  0x431241		488b442478		MOVQ 0x78(SP), AX		
  0x431246		48890424		MOVQ AX, 0(SP)			
  0x43124a		e8a110ffff		CALL runtime.printhex(SB)	
  0x43124f		e83c0bffff		CALL runtime.printnl(SB)	
  0x431254		e82709ffff		CALL runtime.printunlock(SB)	
  0x431259		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431261		488b4808		MOVQ 0x8(AX), CX	
  0x431265		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rcx() uint64 { return c.regs().rcx }
  0x431269		8402			TESTB AL, 0(DX)		
  0x43126b		488b8998000000		MOVQ 0x98(CX), CX	
  0x431272		48894c2458		MOVQ CX, 0x58(SP)	
	print("rcx    ", hex(c.rcx()), "\n")
  0x431277		e88408ffff		CALL runtime.printlock(SB)	
  0x43127c		488d05b08c0300		LEAQ 0x38cb0(IP), AX		
  0x431283		48890424		MOVQ AX, 0(SP)			
  0x431287		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431290		e8ab11ffff		CALL runtime.printstring(SB)	
  0x431295		488b442458		MOVQ 0x58(SP), AX		
  0x43129a		48890424		MOVQ AX, 0(SP)			
  0x43129e		e84d10ffff		CALL runtime.printhex(SB)	
  0x4312a3		e8e80affff		CALL runtime.printnl(SB)	
  0x4312a8		e8d308ffff		CALL runtime.printunlock(SB)	
  0x4312ad		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4312b5		488b4808		MOVQ 0x8(AX), CX	
  0x4312b9		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rdx() uint64 { return c.regs().rdx }
  0x4312bd		8402			TESTB AL, 0(DX)		
  0x4312bf		488b8988000000		MOVQ 0x88(CX), CX	
  0x4312c6		48894c2438		MOVQ CX, 0x38(SP)	
	print("rdx    ", hex(c.rdx()), "\n")
  0x4312cb		e83008ffff		CALL runtime.printlock(SB)	
  0x4312d0		488d056a8c0300		LEAQ 0x38c6a(IP), AX		
  0x4312d7		48890424		MOVQ AX, 0(SP)			
  0x4312db		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4312e4		e85711ffff		CALL runtime.printstring(SB)	
  0x4312e9		488b442438		MOVQ 0x38(SP), AX		
  0x4312ee		48890424		MOVQ AX, 0(SP)			
  0x4312f2		e8f90fffff		CALL runtime.printhex(SB)	
  0x4312f7		e8940affff		CALL runtime.printnl(SB)	
  0x4312fc		e87f08ffff		CALL runtime.printunlock(SB)	
  0x431301		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431309		488b4808		MOVQ 0x8(AX), CX	
  0x43130d		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rdi() uint64 { return c.regs().rdi }
  0x431311		8402			TESTB AL, 0(DX)		
  0x431313		488b4968		MOVQ 0x68(CX), CX	
  0x431317		48894c2440		MOVQ CX, 0x40(SP)	
	print("rdi    ", hex(c.rdi()), "\n")
  0x43131c		e8df07ffff		CALL runtime.printlock(SB)	
  0x431321		488d05128c0300		LEAQ 0x38c12(IP), AX		
  0x431328		48890424		MOVQ AX, 0(SP)			
  0x43132c		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431335		e80611ffff		CALL runtime.printstring(SB)	
  0x43133a		488b442440		MOVQ 0x40(SP), AX		
  0x43133f		48890424		MOVQ AX, 0(SP)			
  0x431343		e8a80fffff		CALL runtime.printhex(SB)	
  0x431348		e8430affff		CALL runtime.printnl(SB)	
  0x43134d		e82e08ffff		CALL runtime.printunlock(SB)	
  0x431352		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43135a		488b4808		MOVQ 0x8(AX), CX	
  0x43135e		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rsi() uint64 { return c.regs().rsi }
  0x431362		8402			TESTB AL, 0(DX)		
  0x431364		488b4970		MOVQ 0x70(CX), CX	
  0x431368		48894c2468		MOVQ CX, 0x68(SP)	
	print("rsi    ", hex(c.rsi()), "\n")
  0x43136d		e88e07ffff		CALL runtime.printlock(SB)	
  0x431372		488d05dd8b0300		LEAQ 0x38bdd(IP), AX		
  0x431379		48890424		MOVQ AX, 0(SP)			
  0x43137d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431386		e8b510ffff		CALL runtime.printstring(SB)	
  0x43138b		488b442468		MOVQ 0x68(SP), AX		
  0x431390		48890424		MOVQ AX, 0(SP)			
  0x431394		e8570fffff		CALL runtime.printhex(SB)	
  0x431399		e8f209ffff		CALL runtime.printnl(SB)	
  0x43139e		e8dd07ffff		CALL runtime.printunlock(SB)	
  0x4313a3		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4313ab		488b4808		MOVQ 0x8(AX), CX	
  0x4313af		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rbp() uint64 { return c.regs().rbp }
  0x4313b3		8402			TESTB AL, 0(DX)		
  0x4313b5		488b4978		MOVQ 0x78(CX), CX	
  0x4313b9		48898c2490000000	MOVQ CX, 0x90(SP)	
	print("rbp    ", hex(c.rbp()), "\n")
  0x4313c1		e83a07ffff		CALL runtime.printlock(SB)	
  0x4313c6		488d05588b0300		LEAQ 0x38b58(IP), AX		
  0x4313cd		48890424		MOVQ AX, 0(SP)			
  0x4313d1		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4313da		e86110ffff		CALL runtime.printstring(SB)	
  0x4313df		488b842490000000	MOVQ 0x90(SP), AX		
  0x4313e7		48890424		MOVQ AX, 0(SP)			
  0x4313eb		e8000fffff		CALL runtime.printhex(SB)	
  0x4313f0		e89b09ffff		CALL runtime.printnl(SB)	
  0x4313f5		e88607ffff		CALL runtime.printunlock(SB)	
  0x4313fa		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431402		488b4808		MOVQ 0x8(AX), CX	
  0x431406		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x43140a		8402			TESTB AL, 0(DX)		
  0x43140c		488b89a0000000		MOVQ 0xa0(CX), CX	
  0x431413		48894c2418		MOVQ CX, 0x18(SP)	
	print("rsp    ", hex(c.rsp()), "\n")
  0x431418		e8e306ffff		CALL runtime.printlock(SB)	
  0x43141d		488d05398b0300		LEAQ 0x38b39(IP), AX		
  0x431424		48890424		MOVQ AX, 0(SP)			
  0x431428		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431431		e80a10ffff		CALL runtime.printstring(SB)	
  0x431436		488b442418		MOVQ 0x18(SP), AX		
  0x43143b		48890424		MOVQ AX, 0(SP)			
  0x43143f		e8ac0effff		CALL runtime.printhex(SB)	
  0x431444		e84709ffff		CALL runtime.printnl(SB)	
  0x431449		e83207ffff		CALL runtime.printunlock(SB)	
  0x43144e		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431456		488b4808		MOVQ 0x8(AX), CX	
  0x43145a		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r8() uint64  { return c.regs().r8 }
  0x43145e		8402			TESTB AL, 0(DX)		
  0x431460		488b4928		MOVQ 0x28(CX), CX	
  0x431464		48894c2410		MOVQ CX, 0x10(SP)	
	print("r8     ", hex(c.r8()), "\n")
  0x431469		e89206ffff		CALL runtime.printlock(SB)	
  0x43146e		488d059b8a0300		LEAQ 0x38a9b(IP), AX		
  0x431475		48890424		MOVQ AX, 0(SP)			
  0x431479		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431482		e8b90fffff		CALL runtime.printstring(SB)	
  0x431487		488b442410		MOVQ 0x10(SP), AX		
  0x43148c		48890424		MOVQ AX, 0(SP)			
  0x431490		e85b0effff		CALL runtime.printhex(SB)	
  0x431495		e8f608ffff		CALL runtime.printnl(SB)	
  0x43149a		e8e106ffff		CALL runtime.printunlock(SB)	
  0x43149f		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4314a7		488b4808		MOVQ 0x8(AX), CX	
  0x4314ab		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r9() uint64  { return c.regs().r9 }
  0x4314af		8402			TESTB AL, 0(DX)		
  0x4314b1		488b4930		MOVQ 0x30(CX), CX	
  0x4314b5		48898c2488000000	MOVQ CX, 0x88(SP)	
	print("r9     ", hex(c.r9()), "\n")
  0x4314bd		e83e06ffff		CALL runtime.printlock(SB)	
  0x4314c2		488d054e8a0300		LEAQ 0x38a4e(IP), AX		
  0x4314c9		48890424		MOVQ AX, 0(SP)			
  0x4314cd		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4314d6		e8650fffff		CALL runtime.printstring(SB)	
  0x4314db		488b842488000000	MOVQ 0x88(SP), AX		
  0x4314e3		48890424		MOVQ AX, 0(SP)			
  0x4314e7		e8040effff		CALL runtime.printhex(SB)	
  0x4314ec		e89f08ffff		CALL runtime.printnl(SB)	
  0x4314f1		e88a06ffff		CALL runtime.printunlock(SB)	
  0x4314f6		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4314fe		488b4808		MOVQ 0x8(AX), CX	
  0x431502		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r10() uint64 { return c.regs().r10 }
  0x431506		8402			TESTB AL, 0(DX)		
  0x431508		488b4938		MOVQ 0x38(CX), CX	
  0x43150c		48898c2480000000	MOVQ CX, 0x80(SP)	
	print("r10    ", hex(c.r10()), "\n")
  0x431514		e8e705ffff		CALL runtime.printlock(SB)	
  0x431519		488d05c6890300		LEAQ 0x389c6(IP), AX		
  0x431520		48890424		MOVQ AX, 0(SP)			
  0x431524		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43152d		e80e0fffff		CALL runtime.printstring(SB)	
  0x431532		488b842480000000	MOVQ 0x80(SP), AX		
  0x43153a		48890424		MOVQ AX, 0(SP)			
  0x43153e		e8ad0dffff		CALL runtime.printhex(SB)	
  0x431543		e84808ffff		CALL runtime.printnl(SB)	
  0x431548		e83306ffff		CALL runtime.printunlock(SB)	
  0x43154d		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431555		488b4808		MOVQ 0x8(AX), CX	
  0x431559		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r11() uint64 { return c.regs().r11 }
  0x43155d		8402			TESTB AL, 0(DX)		
  0x43155f		488b4940		MOVQ 0x40(CX), CX	
  0x431563		48894c2470		MOVQ CX, 0x70(SP)	
	print("r11    ", hex(c.r11()), "\n")
  0x431568		e89305ffff		CALL runtime.printlock(SB)	
  0x43156d		488d0579890300		LEAQ 0x38979(IP), AX		
  0x431574		48890424		MOVQ AX, 0(SP)			
  0x431578		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431581		e8ba0effff		CALL runtime.printstring(SB)	
  0x431586		488b442470		MOVQ 0x70(SP), AX		
  0x43158b		48890424		MOVQ AX, 0(SP)			
  0x43158f		e85c0dffff		CALL runtime.printhex(SB)	
  0x431594		e8f707ffff		CALL runtime.printnl(SB)	
  0x431599		e8e205ffff		CALL runtime.printunlock(SB)	
  0x43159e		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4315a6		488b4808		MOVQ 0x8(AX), CX	
  0x4315aa		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r12() uint64 { return c.regs().r12 }
  0x4315ae		8402			TESTB AL, 0(DX)		
  0x4315b0		488b4948		MOVQ 0x48(CX), CX	
  0x4315b4		48898c2498000000	MOVQ CX, 0x98(SP)	
	print("r12    ", hex(c.r12()), "\n")
  0x4315bc		e83f05ffff		CALL runtime.printlock(SB)	
  0x4315c1		488d052c890300		LEAQ 0x3892c(IP), AX		
  0x4315c8		48890424		MOVQ AX, 0(SP)			
  0x4315cc		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4315d5		e8660effff		CALL runtime.printstring(SB)	
  0x4315da		488b842498000000	MOVQ 0x98(SP), AX		
  0x4315e2		48890424		MOVQ AX, 0(SP)			
  0x4315e6		e8050dffff		CALL runtime.printhex(SB)	
  0x4315eb		e8a007ffff		CALL runtime.printnl(SB)	
  0x4315f0		e88b05ffff		CALL runtime.printunlock(SB)	
  0x4315f5		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4315fd		488b4808		MOVQ 0x8(AX), CX	
  0x431601		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r13() uint64 { return c.regs().r13 }
  0x431605		8402			TESTB AL, 0(DX)		
  0x431607		488b4950		MOVQ 0x50(CX), CX	
  0x43160b		48894c2450		MOVQ CX, 0x50(SP)	
	print("r13    ", hex(c.r13()), "\n")
  0x431610		e8eb04ffff		CALL runtime.printlock(SB)	
  0x431615		488d05df880300		LEAQ 0x388df(IP), AX		
  0x43161c		48890424		MOVQ AX, 0(SP)			
  0x431620		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431629		e8120effff		CALL runtime.printstring(SB)	
  0x43162e		488b442450		MOVQ 0x50(SP), AX		
  0x431633		48890424		MOVQ AX, 0(SP)			
  0x431637		e8b40cffff		CALL runtime.printhex(SB)	
  0x43163c		e84f07ffff		CALL runtime.printnl(SB)	
  0x431641		e83a05ffff		CALL runtime.printunlock(SB)	
  0x431646		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43164e		488b4808		MOVQ 0x8(AX), CX	
  0x431652		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r14() uint64 { return c.regs().r14 }
  0x431656		8402			TESTB AL, 0(DX)		
  0x431658		488b4958		MOVQ 0x58(CX), CX	
  0x43165c		48894c2448		MOVQ CX, 0x48(SP)	
	print("r14    ", hex(c.r14()), "\n")
  0x431661		e89a04ffff		CALL runtime.printlock(SB)	
  0x431666		488d0595880300		LEAQ 0x38895(IP), AX		
  0x43166d		48890424		MOVQ AX, 0(SP)			
  0x431671		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43167a		e8c10dffff		CALL runtime.printstring(SB)	
  0x43167f		488b442448		MOVQ 0x48(SP), AX		
  0x431684		48890424		MOVQ AX, 0(SP)			
  0x431688		e8630cffff		CALL runtime.printhex(SB)	
  0x43168d		e8fe06ffff		CALL runtime.printnl(SB)	
  0x431692		e8e904ffff		CALL runtime.printunlock(SB)	
  0x431697		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43169f		488b4808		MOVQ 0x8(AX), CX	
  0x4316a3		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) r15() uint64 { return c.regs().r15 }
  0x4316a7		8402			TESTB AL, 0(DX)		
  0x4316a9		488b4960		MOVQ 0x60(CX), CX	
  0x4316ad		48894c2420		MOVQ CX, 0x20(SP)	
	print("r15    ", hex(c.r15()), "\n")
  0x4316b2		e84904ffff		CALL runtime.printlock(SB)	
  0x4316b7		488d054b880300		LEAQ 0x3884b(IP), AX		
  0x4316be		48890424		MOVQ AX, 0(SP)			
  0x4316c2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4316cb		e8700dffff		CALL runtime.printstring(SB)	
  0x4316d0		488b442420		MOVQ 0x20(SP), AX		
  0x4316d5		48890424		MOVQ AX, 0(SP)			
  0x4316d9		e8120cffff		CALL runtime.printhex(SB)	
  0x4316de		e8ad06ffff		CALL runtime.printnl(SB)	
  0x4316e3		e89804ffff		CALL runtime.printunlock(SB)	
  0x4316e8		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4316f0		488b4808		MOVQ 0x8(AX), CX	
  0x4316f4		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x4316f8		8402			TESTB AL, 0(DX)		
  0x4316fa		488b89a8000000		MOVQ 0xa8(CX), CX	
  0x431701		48894c2428		MOVQ CX, 0x28(SP)	
	print("rip    ", hex(c.rip()), "\n")
  0x431706		e8f503ffff		CALL runtime.printlock(SB)	
  0x43170b		488d053d880300		LEAQ 0x3883d(IP), AX		
  0x431712		48890424		MOVQ AX, 0(SP)			
  0x431716		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43171f		e81c0dffff		CALL runtime.printstring(SB)	
  0x431724		488b442428		MOVQ 0x28(SP), AX		
  0x431729		48890424		MOVQ AX, 0(SP)			
  0x43172d		e8be0bffff		CALL runtime.printhex(SB)	
  0x431732		e85906ffff		CALL runtime.printnl(SB)	
  0x431737		e84404ffff		CALL runtime.printunlock(SB)	
  0x43173c		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431744		488b4808		MOVQ 0x8(AX), CX	
  0x431748		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rflags() uint64  { return c.regs().eflags }
  0x43174c		8402			TESTB AL, 0(DX)		
  0x43174e		488b89b0000000		MOVQ 0xb0(CX), CX	
  0x431755		48894c2430		MOVQ CX, 0x30(SP)	
	print("rflags ", hex(c.rflags()), "\n")
  0x43175a		e8a103ffff		CALL runtime.printlock(SB)	
  0x43175f		488d05e2870300		LEAQ 0x387e2(IP), AX		
  0x431766		48890424		MOVQ AX, 0(SP)			
  0x43176a		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431773		e8c80cffff		CALL runtime.printstring(SB)	
  0x431778		488b442430		MOVQ 0x30(SP), AX		
  0x43177d		48890424		MOVQ AX, 0(SP)			
  0x431781		e86a0bffff		CALL runtime.printhex(SB)	
  0x431786		e80506ffff		CALL runtime.printnl(SB)	
  0x43178b		e8f003ffff		CALL runtime.printunlock(SB)	
  0x431790		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431798		488b4808		MOVQ 0x8(AX), CX	
  0x43179c		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) cs() uint64      { return uint64(c.regs().cs) }
  0x4317a0		8402			TESTB AL, 0(DX)		
  0x4317a2		0fb789b8000000		MOVZX 0xb8(CX), CX	
  0x4317a9		48898c24a0000000	MOVQ CX, 0xa0(SP)	
	print("cs     ", hex(c.cs()), "\n")
  0x4317b1		e84a03ffff		CALL runtime.printlock(SB)	
  0x4317b6		488d0506870300		LEAQ 0x38706(IP), AX		
  0x4317bd		48890424		MOVQ AX, 0(SP)			
  0x4317c1		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4317ca		e8710cffff		CALL runtime.printstring(SB)	
  0x4317cf		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x4317d7		48890424		MOVQ AX, 0(SP)			
  0x4317db		e8100bffff		CALL runtime.printhex(SB)	
  0x4317e0		e8ab05ffff		CALL runtime.printnl(SB)	
  0x4317e5		e89603ffff		CALL runtime.printunlock(SB)	
  0x4317ea		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4317f2		488b4808		MOVQ 0x8(AX), CX	
  0x4317f6		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) fs() uint64      { return uint64(c.regs().fs) }
  0x4317fa		8402			TESTB AL, 0(DX)		
  0x4317fc		0fb789bc000000		MOVZX 0xbc(CX), CX	
  0x431803		48898c24a0000000	MOVQ CX, 0xa0(SP)	
	print("fs     ", hex(c.fs()), "\n")
  0x43180b		e8f002ffff		CALL runtime.printlock(SB)	
  0x431810		488d05b3860300		LEAQ 0x386b3(IP), AX		
  0x431817		48890424		MOVQ AX, 0(SP)			
  0x43181b		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431824		e8170cffff		CALL runtime.printstring(SB)	
  0x431829		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x431831		48890424		MOVQ AX, 0(SP)			
  0x431835		e8b60affff		CALL runtime.printhex(SB)	
  0x43183a		e85105ffff		CALL runtime.printnl(SB)	
  0x43183f		e83c03ffff		CALL runtime.printunlock(SB)	
  0x431844		488b8424b8000000	MOVQ 0xb8(SP), AX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43184c		488b4008		MOVQ 0x8(AX), AX	
  0x431850		488d4828		LEAQ 0x28(AX), CX	
func (c *sigctxt) gs() uint64      { return uint64(c.regs().gs) }
  0x431854		8401			TESTB AL, 0(CX)		
  0x431856		0fb780ba000000		MOVZX 0xba(AX), AX	
  0x43185d		48898424a0000000	MOVQ AX, 0xa0(SP)	
	print("gs     ", hex(c.gs()), "\n")
  0x431865		e89602ffff		CALL runtime.printlock(SB)	
  0x43186a		488d0567860300		LEAQ 0x38667(IP), AX		
  0x431871		48890424		MOVQ AX, 0(SP)			
  0x431875		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43187e		e8bd0bffff		CALL runtime.printstring(SB)	
  0x431883		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x43188b		48890424		MOVQ AX, 0(SP)			
  0x43188f		e85c0affff		CALL runtime.printhex(SB)	
  0x431894		e8f704ffff		CALL runtime.printnl(SB)	
  0x431899		e8e202ffff		CALL runtime.printunlock(SB)	
}
  0x43189e		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x4318a6		4881c4b0000000		ADDQ $0xb0, SP		
  0x4318ad		c3			RET			
func dumpregs(c *sigctxt) {
  0x4318ae		e8bd2c0100		CALL runtime.morestack_noctxt(SB)	
  0x4318b3		e9c8f8ffff		JMP runtime.dumpregs(SB)		

TEXT runtime.(*sigctxt).preparePanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_amd64x.go
func (c *sigctxt) preparePanic(sig uint32, gp *g) {
  0x4318c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4318c9		483b6110		CMPQ 0x10(CX), SP	
  0x4318cd		0f860e010000		JBE 0x4319e1		
  0x4318d3		4883ec40		SUBQ $0x40, SP		
  0x4318d7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4318dc		488d6c2438		LEAQ 0x38(SP), BP	
  0x4318e1		488b442448		MOVQ 0x48(SP), AX	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4318e6		488b4808		MOVQ 0x8(AX), CX	
  0x4318ea		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x4318ee		8402			TESTB AL, 0(DX)		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4318f0		8400			TESTB AL, 0(AX)		
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x4318f2		488b91a8000000		MOVQ 0xa8(CX), DX	
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x4318f9		488b89a0000000		MOVQ 0xa0(CX), CX	
	if pc != 0 && !findfunc(pc).valid() && findfunc(*(*uintptr)(unsafe.Pointer(sp))).valid() {
  0x431900		4885d2			TESTQ DX, DX		
  0x431903		756b			JNE 0x431970		
	if pc != 0 {
  0x431905		4885d2			TESTQ DX, DX		
  0x431908		741b			JE 0x431925		
		sp -= sys.PtrSize
  0x43190a		4883c1f8		ADDQ $-0x8, CX		
  0x43190e		4889cb			MOVQ CX, BX		
		*(*uintptr)(unsafe.Pointer(sp)) = pc
  0x431911		488911			MOVQ DX, 0(CX)		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431914		488b4808		MOVQ 0x8(AX), CX	
  0x431918		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) set_rsp(x uint64)     { c.regs().rsp = x }
  0x43191c		8402			TESTB AL, 0(DX)		
  0x43191e		488999a0000000		MOVQ BX, 0xa0(CX)	
	c.set_rip(uint64(funcPC(sigpanic)))
  0x431925		488d0db44d0200		LEAQ 0x24db4(IP), CX	
  0x43192c		48894c2428		MOVQ CX, 0x28(SP)	
  0x431931		488d0da8c80300		LEAQ 0x3c8a8(IP), CX	
  0x431938		48894c2430		MOVQ CX, 0x30(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x43193d		b908000000		MOVL $0x8, CX		
  0x431942		488d542428		LEAQ 0x28(SP), DX	
  0x431947		488b0c0a		MOVQ 0(DX)(CX*1), CX	
  0x43194b		488d542430		LEAQ 0x30(SP), DX	
  0x431950		8402			TESTB AL, 0(DX)		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431952		488b4008		MOVQ 0x8(AX), AX	
  0x431956		488d5028		LEAQ 0x28(AX), DX	
func (c *sigctxt) set_rip(x uint64)     { c.regs().rip = x }
  0x43195a		8402			TESTB AL, 0(DX)		
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x43195c		488b09			MOVQ 0(CX), CX		
func (c *sigctxt) set_rip(x uint64)     { c.regs().rip = x }
  0x43195f		488988a8000000		MOVQ CX, 0xa8(AX)	
  0x431966		488b6c2438		MOVQ 0x38(SP), BP	
  0x43196b		4883c440		ADDQ $0x40, SP		
  0x43196f		c3			RET			
  0x431970		4889542420		MOVQ DX, 0x20(SP)	
  0x431975		48894c2418		MOVQ CX, 0x18(SP)	
	if pc != 0 && !findfunc(pc).valid() && findfunc(*(*uintptr)(unsafe.Pointer(sp))).valid() {
  0x43197a		48891424		MOVQ DX, 0(SP)			
  0x43197e		e84d680000		CALL runtime.findfunc(SB)	
  0x431983		488b442408		MOVQ 0x8(SP), AX		
	return f._func != nil
  0x431988		4885c0			TESTQ AX, AX		
	if pc != 0 && !findfunc(pc).valid() && findfunc(*(*uintptr)(unsafe.Pointer(sp))).valid() {
  0x43198b		7414			JE 0x4319a1			
  0x43198d		488b442448		MOVQ 0x48(SP), AX		
  0x431992		488b4c2418		MOVQ 0x18(SP), CX		
  0x431997		488b542420		MOVQ 0x20(SP), DX		
  0x43199c		e964ffffff		JMP 0x431905			
  0x4319a1		488b442418		MOVQ 0x18(SP), AX		
  0x4319a6		488b00			MOVQ 0(AX), AX			
  0x4319a9		48890424		MOVQ AX, 0(SP)			
  0x4319ad		e81e680000		CALL runtime.findfunc(SB)	
  0x4319b2		488b442408		MOVQ 0x8(SP), AX		
	return f._func != nil
  0x4319b7		4885c0			TESTQ AX, AX		
	if pc != 0 && !findfunc(pc).valid() && findfunc(*(*uintptr)(unsafe.Pointer(sp))).valid() {
  0x4319ba		7411			JE 0x4319cd		
  0x4319bc		488b442448		MOVQ 0x48(SP), AX	
  0x4319c1		488b4c2418		MOVQ 0x18(SP), CX	
  0x4319c6		31d2			XORL DX, DX		
	if pc != 0 {
  0x4319c8		e938ffffff		JMP 0x431905		
  0x4319cd		488b442448		MOVQ 0x48(SP), AX	
  0x4319d2		488b4c2418		MOVQ 0x18(SP), CX	
  0x4319d7		488b542420		MOVQ 0x20(SP), DX	
	if pc != 0 && !findfunc(pc).valid() && findfunc(*(*uintptr)(unsafe.Pointer(sp))).valid() {
  0x4319dc		e924ffffff		JMP 0x431905		
func (c *sigctxt) preparePanic(sig uint32, gp *g) {
  0x4319e1		e88a2b0100		CALL runtime.morestack_noctxt(SB)	
  0x4319e6		e9d5feffff		JMP runtime.(*sigctxt).preparePanic(SB)	

TEXT runtime.sighandler(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_sighandler.go
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
  0x4319f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4319f9		483b6110		CMPQ 0x10(CX), SP	
  0x4319fd		0f8684060000		JBE 0x432087		
  0x431a03		4883ec78		SUBQ $0x78, SP		
  0x431a07		48896c2470		MOVQ BP, 0x70(SP)	
  0x431a0c		488d6c2470		LEAQ 0x70(SP), BP	
	_g_ := getg()
  0x431a11		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
  0x431a1a		488b8c2488000000	MOVQ 0x88(SP), CX	
	c := &sigctxt{info, ctxt}
  0x431a22		48894c2460		MOVQ CX, 0x60(SP)	
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
  0x431a27		488b8c2490000000	MOVQ 0x90(SP), CX	
	c := &sigctxt{info, ctxt}
  0x431a2f		48894c2468		MOVQ CX, 0x68(SP)	
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
  0x431a34		8b942480000000		MOVL 0x80(SP), DX	
	if sig == _SIGPROF {
  0x431a3b		83fa1b			CMPL $0x1b, DX		
  0x431a3e		0f84e3050000		JE 0x432027		
	if sig < uint32(len(sigtable)) {
  0x431a44		83fa41			CMPL $0x41, DX		
  0x431a47		0f83c9050000		JAE 0x432016		
		flags = sigtable[sig].flags
  0x431a4d		4883fa41		CMPQ $0x41, DX			
  0x431a51		0f8329060000		JAE 0x432080			
  0x431a57		488d0c52		LEAQ 0(DX)(DX*2), CX		
  0x431a5b		488d1d1e450700		LEAQ runtime.sigtable(SB), BX	
  0x431a62		8b0ccb			MOVL 0(BX)(CX*8), CX		
	if flags&_SigPanic != 0 && gp.throwsplit {
  0x431a65		0fbae103		BTL $0x3, CX		
  0x431a69		0f839a050000		JAE 0x432009		
  0x431a6f		488bb42498000000	MOVQ 0x98(SP), SI	
  0x431a77		0fb6bec5000000		MOVZX 0xc5(SI), DI	
  0x431a7e		4084ff			TESTL DI, DI		
  0x431a81		7406			JE 0x431a89		
		flags = (flags &^ _SigPanic) | _SigThrow
  0x431a83		83e1f7			ANDL $-0x9, CX		
  0x431a86		83c904			ORL $0x4, CX		
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x431a89		488b7c2460		MOVQ 0x60(SP), DI	
  0x431a8e		48637f08		MOVSXD 0x8(DI), DI	
	if c.sigcode() != _SI_USER && flags&_SigPanic != 0 {
  0x431a92		4885ff			TESTQ DI, DI		
  0x431a95		740d			JE 0x431aa4		
  0x431a97		0fbae103		BTL $0x3, CX		
  0x431a9b		0f8208050000		JB 0x431fa9		
  0x431aa1		4885ff			TESTQ DI, DI		
  0x431aa4		4889442450		MOVQ AX, 0x50(SP)	
  0x431aa9		894c242c		MOVL CX, 0x2c(SP)	
	if c.sigcode() == _SI_USER || flags&_SigNotify != 0 {
  0x431aad		0f85e7040000		JNE 0x431f9a		
		if sigsend(sig) {
  0x431ab3		891424			MOVL DX, 0(SP)			
  0x431ab6		e8051b0000		CALL runtime.sigsend(SB)	
  0x431abb		0fb6442408		MOVZX 0x8(SP), AX		
  0x431ac0		84c0			TESTL AL, AL			
  0x431ac2		0f85c8040000		JNE 0x431f90			
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x431ac8		488b442460		MOVQ 0x60(SP), AX	
  0x431acd		48634008		MOVSXD 0x8(AX), AX	
	if c.sigcode() == _SI_USER && signal_ignored(sig) {
  0x431ad1		4885c0			TESTQ AX, AX		
  0x431ad4		0f85aa040000		JNE 0x431f84		
  0x431ada		8b842480000000		MOVL 0x80(SP), AX	
  0x431ae1		89c1			MOVL AX, CX		
	i := atomic.Load(&sig.ignored[s/32])
  0x431ae3		c1e805			SHRL $0x5, AX			
  0x431ae6		4883f803		CMPQ $0x3, AX			
  0x431aea		0f8389050000		JAE 0x432079			
  0x431af0		488d1549200900		LEAQ runtime.sig(SB), DX	
  0x431af7		488d448220		LEAQ 0x20(DX)(AX*4), AX		
  0x431afc		8b00			MOVL 0(AX), AX			
	return i&(1<<(s&31)) != 0
  0x431afe		0fa3c8			BTL CX, AX		
	if c.sigcode() == _SI_USER && signal_ignored(sig) {
  0x431b01		0f8273040000		JB 0x431f7a		
  0x431b07		8b44242c		MOVL 0x2c(SP), AX	
	if flags&_SigKill != 0 {
  0x431b0b		0fbae001		BTL $0x1, AX		
  0x431b0f		0f824d040000		JB 0x431f62		
	if flags&_SigThrow == 0 {
  0x431b15		0fbae002		BTL $0x2, AX		
  0x431b19		0f8339040000		JAE 0x431f58		
  0x431b1f		488b442450		MOVQ 0x50(SP), AX	
	_g_.m.throwing = 1
  0x431b24		488b5030		MOVQ 0x30(AX), DX	
  0x431b28		c782ec00000001000000	MOVL $0x1, 0xec(DX)	
	_g_.m.caughtsig.set(gp)
  0x431b32		488b5030		MOVQ 0x30(AX), DX	
  0x431b36		488d9ac8000000		LEAQ 0xc8(DX), BX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x431b3d		8403			TESTB AL, 0(BX)		
  0x431b3f		488b9c2498000000	MOVQ 0x98(SP), BX	
  0x431b47		4889de			MOVQ BX, SI		
  0x431b4a		48899ac8000000		MOVQ BX, 0xc8(DX)	
	if crashing == 0 {
  0x431b51		8b156d1d0900		MOVL runtime.crashing(SB), DX	
  0x431b57		85d2			TESTL DX, DX			
  0x431b59		0f84d8030000		JE 0x431f37			
	if sig < uint32(len(sigtable)) {
  0x431b5f		83f941			CMPL $0x41, CX		
	if sig < uint32(len(sigtable)) {
  0x431b62		0f8392030000		JAE 0x431efa		
		print(sigtable[sig].name, "\n")
  0x431b68		4883f941		CMPQ $0x41, CX			
  0x431b6c		0f8300050000		JAE 0x432072			
  0x431b72		488d0449		LEAQ 0(CX)(CX*2), AX		
  0x431b76		488d0d03440700		LEAQ runtime.sigtable(SB), CX	
  0x431b7d		488b54c110		MOVQ 0x10(CX)(AX*8), DX		
  0x431b82		4889542448		MOVQ DX, 0x48(SP)		
  0x431b87		488b44c108		MOVQ 0x8(CX)(AX*8), AX		
  0x431b8c		4889442458		MOVQ AX, 0x58(SP)		
  0x431b91		e86afffeff		CALL runtime.printlock(SB)	
  0x431b96		488b442458		MOVQ 0x58(SP), AX		
  0x431b9b		48890424		MOVQ AX, 0(SP)			
  0x431b9f		488b442448		MOVQ 0x48(SP), AX		
  0x431ba4		4889442408		MOVQ AX, 0x8(SP)		
  0x431ba9		e89208ffff		CALL runtime.printstring(SB)	
  0x431bae		e8dd01ffff		CALL runtime.printnl(SB)	
  0x431bb3		e8c8fffeff		CALL runtime.printunlock(SB)	
  0x431bb8		488b442450		MOVQ 0x50(SP), AX		
	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")
  0x431bbd		488b4830		MOVQ 0x30(AX), CX	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431bc1		488b542468		MOVQ 0x68(SP), DX	
  0x431bc6		488d5a28		LEAQ 0x28(DX), BX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x431bca		8403			TESTB AL, 0(BX)		
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x431bcc		488b5c2460		MOVQ 0x60(SP), BX	
	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")
  0x431bd1		488b89e0000000		MOVQ 0xe0(CX), CX	
  0x431bd8		48894c2440		MOVQ CX, 0x40(SP)	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x431bdd		488b92a8000000		MOVQ 0xa8(DX), DX	
  0x431be4		4889542430		MOVQ DX, 0x30(SP)	
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x431be9		48635b08		MOVSXD 0x8(BX), BX	
  0x431bed		48895c2438		MOVQ BX, 0x38(SP)	
	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")
  0x431bf2		e809fffeff		CALL runtime.printlock(SB)	
  0x431bf7		488d05a4800300		LEAQ 0x380a4(IP), AX		
  0x431bfe		48890424		MOVQ AX, 0(SP)			
  0x431c02		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x431c0b		e83008ffff		CALL runtime.printstring(SB)	
  0x431c10		488b442430		MOVQ 0x30(SP), AX		
  0x431c15		48890424		MOVQ AX, 0(SP)			
  0x431c19		e8d206ffff		CALL runtime.printhex(SB)	
  0x431c1e		488d0571800300		LEAQ 0x38071(IP), AX		
  0x431c25		48890424		MOVQ AX, 0(SP)			
  0x431c29		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x431c32		e80908ffff		CALL runtime.printstring(SB)	
  0x431c37		488b442440		MOVQ 0x40(SP), AX		
  0x431c3c		48890424		MOVQ AX, 0(SP)			
  0x431c40		e83b06ffff		CALL runtime.printint(SB)	
  0x431c45		488d055f840300		LEAQ 0x3845f(IP), AX		
  0x431c4c		48890424		MOVQ AX, 0(SP)			
  0x431c50		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x431c59		e8e207ffff		CALL runtime.printstring(SB)	
  0x431c5e		488b442438		MOVQ 0x38(SP), AX		
  0x431c63		48890424		MOVQ AX, 0(SP)			
  0x431c67		e80405ffff		CALL runtime.printuint(SB)	
  0x431c6c		e81f01ffff		CALL runtime.printnl(SB)	
  0x431c71		e80afffeff		CALL runtime.printunlock(SB)	
  0x431c76		488b442450		MOVQ 0x50(SP), AX		
	if _g_.m.lockedg != 0 && _g_.m.ncgo > 0 && gp == _g_.m.g0 {
  0x431c7b		488b4830		MOVQ 0x30(AX), CX	
  0x431c7f		488b9168010000		MOVQ 0x168(CX), DX	
  0x431c86		4885d2			TESTQ DX, DX		
  0x431c89		0f845e020000		JE 0x431eed		
  0x431c8f		8b9138010000		MOVL 0x138(CX), DX	
  0x431c95		85d2			TESTL DX, DX		
  0x431c97		0f8e43020000		JLE 0x431ee0		
  0x431c9d		488b09			MOVQ 0(CX), CX		
  0x431ca0		488b942498000000	MOVQ 0x98(SP), DX	
  0x431ca8		4839ca			CMPQ CX, DX		
  0x431cab		0f84f7010000		JE 0x431ea8		
  0x431cb1		4889942498000000	MOVQ DX, 0x98(SP)	
	print("\n")
  0x431cb9		e842fefeff		CALL runtime.printlock(SB)	
  0x431cbe		e8cd00ffff		CALL runtime.printnl(SB)	
  0x431cc3		e8b8fefeff		CALL runtime.printunlock(SB)	
	_g_ := getg()
  0x431cc8		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	t := atomic.Load(&traceback_cache)
  0x431cd1		8b0d31330700		MOVL runtime.traceback_cache(SB), CX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x431cd7		488b4030		MOVQ 0x30(AX), AX	
	if _g_.m.traceback != 0 {
  0x431cdb		0fb68029010000		MOVZX 0x129(AX), AX	
  0x431ce2		84c0			TESTL AL, AL		
  0x431ce4		0f84b4010000		JE 0x431e9e		
		level = int32(_g_.m.traceback)
  0x431cea		0fb6c0			MOVZX AL, AX		
	if level > 0 {
  0x431ced		85c0			TESTL AX, AX		
  0x431cef		0f8f84000000		JG 0x431d79		
	crash = t&tracebackCrash != 0
  0x431cf5		0fbae100		BTL $0x0, CX		
	if docrash {
  0x431cf9		732b			JAE 0x431d26		
		crashing++
  0x431cfb		8b05c31b0900		MOVL runtime.crashing(SB), AX	
  0x431d01		ffc0			INCL AX				
  0x431d03		8905bb1b0900		MOVL AX, runtime.crashing(SB)	
	return int32(sched.mnext - sched.nmfreed)
  0x431d09		488b0d385c0700		MOVQ runtime.sched+40(SB), CX	
  0x431d10		482b0d415c0700		SUBQ runtime.sched+56(SB), CX	
		if crashing < mcount()-int32(extraMCount) {
  0x431d17		2b0dab1b0900		SUBL runtime.extraMCount(SB), CX	
  0x431d1d		39c8			CMPL CX, AX				
  0x431d1f		7c1b			JL 0x431d3c				
		crash()
  0x431d21		e87a0f0000		CALL runtime.crash(SB)	
	exit(2)
  0x431d26		c7042402000000		MOVL $0x2, 0(SP)	
  0x431d2d		e89e5a0100		CALL runtime.exit(SB)	
}
  0x431d32		488b6c2470		MOVQ 0x70(SP), BP	
  0x431d37		4883c478		ADDQ $0x78, SP		
  0x431d3b		c3			RET			
			print("\n-----\n\n")
  0x431d3c		e8bffdfeff		CALL runtime.printlock(SB)	
  0x431d41		488d05b7820300		LEAQ 0x382b7(IP), AX		
  0x431d48		48890424		MOVQ AX, 0(SP)			
  0x431d4c		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x431d55		e8e606ffff		CALL runtime.printstring(SB)	
  0x431d5a		e821fefeff		CALL runtime.printunlock(SB)	
			raiseproc(_SIGQUIT)
  0x431d5f		c7042403000000		MOVL $0x3, 0(SP)		
  0x431d66		e8d55b0100		CALL runtime.raiseproc(SB)	
			usleep(5 * 1000 * 1000)
  0x431d6b		c70424404b4c00		MOVL $runtime.memstats+1088(SB), 0(SP)	
  0x431d72		e8395b0100		CALL runtime.usleep(SB)			
  0x431d77		eba8			JMP 0x431d21				
  0x431d79		894c2428		MOVL CX, 0x28(SP)			
  0x431d7d		488b842498000000	MOVQ 0x98(SP), AX			
		goroutineheader(gp)
  0x431d85		48890424		MOVQ AX, 0(SP)				
  0x431d89		e892bf0000		CALL runtime.goroutineheader(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431d8e		488b442468		MOVQ 0x68(SP), AX	
  0x431d93		488d4828		LEAQ 0x28(AX), CX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x431d97		8401			TESTB AL, 0(CX)		
  0x431d99		488b88a8000000		MOVQ 0xa8(AX), CX	
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x431da0		488b80a0000000		MOVQ 0xa0(AX), AX	
		tracebacktrap(c.sigpc(), c.sigsp(), c.siglr(), gp)
  0x431da7		48890c24		MOVQ CX, 0(SP)			
  0x431dab		4889442408		MOVQ AX, 0x8(SP)		
  0x431db0		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x431db9		488b842498000000	MOVQ 0x98(SP), AX		
  0x431dc1		4889442418		MOVQ AX, 0x18(SP)		
  0x431dc6		e865b80000		CALL runtime.tracebacktrap(SB)	
		if crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {
  0x431dcb		8b05f31a0900		MOVL runtime.crashing(SB), AX	
  0x431dd1		85c0			TESTL AX, AX			
  0x431dd3		0f8eb8000000		JLE 0x431e91			
  0x431dd9		488b442450		MOVQ 0x50(SP), AX		
  0x431dde		488b4830		MOVQ 0x30(AX), CX		
  0x431de2		488b89c0000000		MOVQ 0xc0(CX), CX		
  0x431de9		488b942498000000	MOVQ 0x98(SP), DX		
  0x431df1		4839ca			CMPQ CX, DX			
  0x431df4		7416			JE 0x431e0c			
  0x431df6		4885c9			TESTQ CX, CX			
  0x431df9		7411			JE 0x431e0c			
	return atomic.Load(&gp.atomicstatus)
  0x431dfb		8b8990000000		MOVL 0x90(CX), CX	
		if crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {
  0x431e01		81e1ffefffff		ANDL $-0x1001, CX	
  0x431e07		83f902			CMPL $0x2, CX		
  0x431e0a		743b			JE 0x431e47		
		} else if crashing == 0 {
  0x431e0c		8b05b21a0900		MOVL runtime.crashing(SB), AX	
  0x431e12		85c0			TESTL AX, AX			
  0x431e14		7417			JE 0x431e2d			
		dumpregs(c)
  0x431e16		488d442460		LEAQ 0x60(SP), AX		
  0x431e1b		48890424		MOVQ AX, 0(SP)			
  0x431e1f		e85cf3ffff		CALL runtime.dumpregs(SB)	
  0x431e24		8b4c2428		MOVL 0x28(SP), CX		
  0x431e28		e9c8feffff		JMP 0x431cf5			
			tracebackothers(gp)
  0x431e2d		48891424		MOVQ DX, 0(SP)				
  0x431e31		e88ac10000		CALL runtime.tracebackothers(SB)	
			print("\n")
  0x431e36		e8c5fcfeff		CALL runtime.printlock(SB)	
  0x431e3b		e850fffeff		CALL runtime.printnl(SB)	
  0x431e40		e83bfdfeff		CALL runtime.printunlock(SB)	
  0x431e45		ebcf			JMP 0x431e16			
			goroutineheader(_g_.m.curg)
  0x431e47		488b4830		MOVQ 0x30(AX), CX			
  0x431e4b		488b89c0000000		MOVQ 0xc0(CX), CX			
  0x431e52		48890c24		MOVQ CX, 0(SP)				
  0x431e56		e8c5be0000		CALL runtime.goroutineheader(SB)	
  0x431e5b		488b442450		MOVQ 0x50(SP), AX			
			traceback(^uintptr(0), ^uintptr(0), 0, _g_.m.curg)
  0x431e60		488b4030		MOVQ 0x30(AX), AX		
  0x431e64		488b80c0000000		MOVQ 0xc0(AX), AX		
  0x431e6b		4889442418		MOVQ AX, 0x18(SP)		
  0x431e70		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x431e78		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x431e81		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x431e8a		e831b70000		CALL runtime.traceback(SB)	
  0x431e8f		eb85			JMP 0x431e16			
  0x431e91		488b942498000000	MOVQ 0x98(SP), DX		
		if crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {
  0x431e99		e96effffff		JMP 0x431e0c		
  0x431e9e		89c8			MOVL CX, AX		
		level = int32(t >> tracebackShift)
  0x431ea0		c1e802			SHRL $0x2, AX		
  0x431ea3		e945feffff		JMP 0x431ced		
		print("signal arrived during cgo execution\n")
  0x431ea8		e853fcfeff		CALL runtime.printlock(SB)	
  0x431ead		488d054ab00300		LEAQ 0x3b04a(IP), AX		
  0x431eb4		48890424		MOVQ AX, 0(SP)			
  0x431eb8		48c744240824000000	MOVQ $0x24, 0x8(SP)		
  0x431ec1		e87a05ffff		CALL runtime.printstring(SB)	
  0x431ec6		e8b5fcfeff		CALL runtime.printunlock(SB)	
  0x431ecb		488b442450		MOVQ 0x50(SP), AX		
		gp = _g_.m.lockedg.ptr()
  0x431ed0		488b4830		MOVQ 0x30(AX), CX	
  0x431ed4		488b9168010000		MOVQ 0x168(CX), DX	
  0x431edb		e9d1fdffff		JMP 0x431cb1		
  0x431ee0		488b942498000000	MOVQ 0x98(SP), DX	
	if _g_.m.lockedg != 0 && _g_.m.ncgo > 0 && gp == _g_.m.g0 {
  0x431ee8		e9c4fdffff		JMP 0x431cb1		
  0x431eed		488b942498000000	MOVQ 0x98(SP), DX	
  0x431ef5		e9b7fdffff		JMP 0x431cb1		
		print("Signal ", sig, "\n")
  0x431efa		e801fcfeff		CALL runtime.printlock(SB)	
  0x431eff		488d05a17f0300		LEAQ 0x37fa1(IP), AX		
  0x431f06		48890424		MOVQ AX, 0(SP)			
  0x431f0a		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431f13		e82805ffff		CALL runtime.printstring(SB)	
  0x431f18		8b842480000000		MOVL 0x80(SP), AX		
  0x431f1f		48890424		MOVQ AX, 0(SP)			
  0x431f23		e84802ffff		CALL runtime.printuint(SB)	
  0x431f28		e863fefeff		CALL runtime.printnl(SB)	
  0x431f2d		e84efcfeff		CALL runtime.printunlock(SB)	
  0x431f32		e981fcffff		JMP 0x431bb8			
		startpanic()
  0x431f37		e804f2feff		CALL runtime.startpanic(SB)	
  0x431f3c		8b8c2480000000		MOVL 0x80(SP), CX		
	if sig < uint32(len(sigtable)) {
  0x431f43		83f941			CMPL $0x41, CX		
  0x431f46		488b442450		MOVQ 0x50(SP), AX	
  0x431f4b		488bb42498000000	MOVQ 0x98(SP), SI	
		startpanic()
  0x431f53		e90afcffff		JMP 0x431b62		
		return
  0x431f58		488b6c2470		MOVQ 0x70(SP), BP	
  0x431f5d		4883c478		ADDQ $0x78, SP		
  0x431f61		c3			RET			
		dieFromSignal(sig)
  0x431f62		890c24			MOVL CX, 0(SP)			
  0x431f65		e8560b0000		CALL runtime.dieFromSignal(SB)	
  0x431f6a		8b44242c		MOVL 0x2c(SP), AX		
  0x431f6e		8b8c2480000000		MOVL 0x80(SP), CX		
  0x431f75		e99bfbffff		JMP 0x431b15			
		return
  0x431f7a		488b6c2470		MOVQ 0x70(SP), BP	
  0x431f7f		4883c478		ADDQ $0x78, SP		
  0x431f83		c3			RET			
  0x431f84		8b8c2480000000		MOVL 0x80(SP), CX	
	if c.sigcode() == _SI_USER && signal_ignored(sig) {
  0x431f8b		e977fbffff		JMP 0x431b07		
			return
  0x431f90		488b6c2470		MOVQ 0x70(SP), BP	
  0x431f95		4883c478		ADDQ $0x78, SP		
  0x431f99		c3			RET			
	if c.sigcode() == _SI_USER || flags&_SigNotify != 0 {
  0x431f9a		0fbae100		BTL $0x0, CX		
  0x431f9e		0f820ffbffff		JB 0x431ab3		
  0x431fa4		e91ffbffff		JMP 0x431ac8		
		gp.sig = sig
  0x431fa9		8996e8000000		MOVL DX, 0xe8(SI)	
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x431faf		488b442460		MOVQ 0x60(SP), AX	
  0x431fb4		48634008		MOVSXD 0x8(AX), AX	
		gp.sigcode0 = uintptr(c.sigcode())
  0x431fb8		48898608010000		MOVQ AX, 0x108(SI)	
func (c *sigctxt) sigaddr() uint64 { return c.info.si_addr }
  0x431fbf		488b442460		MOVQ 0x60(SP), AX	
  0x431fc4		488b4010		MOVQ 0x10(AX), AX	
		gp.sigcode1 = uintptr(c.fault())
  0x431fc8		48898610010000		MOVQ AX, 0x110(SI)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x431fcf		488b442468		MOVQ 0x68(SP), AX	
  0x431fd4		488d4828		LEAQ 0x28(AX), CX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x431fd8		8401			TESTB AL, 0(CX)		
  0x431fda		488b80a8000000		MOVQ 0xa8(AX), AX	
		gp.sigpc = c.sigpc()
  0x431fe1		48898618010000		MOVQ AX, 0x118(SI)	
		c.preparePanic(sig, gp)
  0x431fe8		488d442460		LEAQ 0x60(SP), AX				
  0x431fed		48890424		MOVQ AX, 0(SP)					
  0x431ff1		89542408		MOVL DX, 0x8(SP)				
  0x431ff5		4889742410		MOVQ SI, 0x10(SP)				
  0x431ffa		e8c1f8ffff		CALL runtime.(*sigctxt).preparePanic(SB)	
		return
  0x431fff		488b6c2470		MOVQ 0x70(SP), BP	
  0x432004		4883c478		ADDQ $0x78, SP		
  0x432008		c3			RET			
  0x432009		488bb42498000000	MOVQ 0x98(SP), SI	
	if flags&_SigPanic != 0 && gp.throwsplit {
  0x432011		e973faffff		JMP 0x431a89			
  0x432016		488d1d633f0700		LEAQ runtime.sigtable(SB), BX	
  0x43201d		b904000000		MOVL $0x4, CX			
	if sig < uint32(len(sigtable)) {
  0x432022		e93efaffff		JMP 0x431a65		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x432027		488d5128		LEAQ 0x28(CX), DX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x43202b		8402			TESTB AL, 0(DX)		
		sigprof(c.sigpc(), c.sigsp(), c.siglr(), gp, _g_.m)
  0x43202d		488b4030		MOVQ 0x30(AX), AX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x432031		488b91a8000000		MOVQ 0xa8(CX), DX	
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x432038		488b89a0000000		MOVQ 0xa0(CX), CX	
		sigprof(c.sigpc(), c.sigsp(), c.siglr(), gp, _g_.m)
  0x43203f		4889442420		MOVQ AX, 0x20(SP)		
  0x432044		48891424		MOVQ DX, 0(SP)			
  0x432048		48894c2408		MOVQ CX, 0x8(SP)		
  0x43204d		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x432056		488b842498000000	MOVQ 0x98(SP), AX		
  0x43205e		4889442418		MOVQ AX, 0x18(SP)		
  0x432063		e8c88effff		CALL runtime.sigprof(SB)	
		return
  0x432068		488b6c2470		MOVQ 0x70(SP), BP	
  0x43206d		4883c478		ADDQ $0x78, SP		
  0x432071		c3			RET			
		print(sigtable[sig].name, "\n")
  0x432072		e8c9d9feff		CALL runtime.panicindex(SB)	
  0x432077		0f0b			UD2				
	i := atomic.Load(&sig.ignored[s/32])
  0x432079		e8c2d9feff		CALL runtime.panicindex(SB)	
  0x43207e		0f0b			UD2				
		flags = sigtable[sig].flags
  0x432080		e8bbd9feff		CALL runtime.panicindex(SB)	
  0x432085		0f0b			UD2				
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
  0x432087		e8e4240100		CALL runtime.morestack_noctxt(SB)	
  0x43208c		e95ff9ffff		JMP runtime.sighandler(SB)		

TEXT runtime.init.5(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func init() {
  0x4320a0		c3			RET			

TEXT runtime.initsig(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func initsig(preinit bool) {
  0x4320b0		4883ec38		SUBQ $0x38, SP		
  0x4320b4		48896c2430		MOVQ BP, 0x30(SP)	
  0x4320b9		488d6c2430		LEAQ 0x30(SP), BP	
  0x4320be		0f57c0			XORPS X0, X0		
  0x4320c1		0f11442420		MOVUPS X0, 0x20(SP)	
  0x4320c6		0fb6442440		MOVZX 0x40(SP), AX	
  0x4320cb		84c0			TESTL AL, AL		
	if !preinit {
  0x4320cd		0f849a010000		JE 0x43226d		
	if (isarchive || islibrary) && !preinit {
  0x4320d3		0fb60dd1170900		MOVZX runtime.isarchive(SB), CX	
  0x4320da		84c9			TESTL CL, CL			
  0x4320dc		0f8475010000		JE 0x432257			
func initsig(preinit bool) {
  0x4320e2		84c0			TESTL AL, AL		
	if (isarchive || islibrary) && !preinit {
  0x4320e4		0f8463010000		JE 0x43224d		
  0x4320ea		31c0			XORL AX, AX		
	for i := uint32(0); i < _NSIG; i++ {
  0x4320ec		eb02			JMP 0x4320f0		
  0x4320ee		ffc0			INCL AX			
  0x4320f0		83f841			CMPL $0x41, AX		
  0x4320f3		0f834a010000		JAE 0x432243		
		t := &sigtable[i]
  0x4320f9		4883f841		CMPQ $0x41, AX		
  0x4320fd		0f8376010000		JAE 0x432279		
  0x432103		488d0c40		LEAQ 0(AX)(AX*2), CX	
		if t.flags == 0 || t.flags&_SigDefault != 0 {
  0x432107		488d15723e0700		LEAQ runtime.sigtable(SB), DX	
  0x43210e		8b1cca			MOVL 0(DX)(CX*8), BX		
  0x432111		85db			TESTL BX, BX			
  0x432113		74d9			JE 0x4320ee			
  0x432115		0fbae304		BTL $0x4, BX			
  0x432119		72d3			JB 0x4320ee			
  0x43211b		89442414		MOVL AX, 0x14(SP)		
  0x43211f		48894c2418		MOVQ CX, 0x18(SP)		
		fwdSig[i] = getsig(i)
  0x432124		890424			MOVL AX, 0(SP)			
  0x432127		e8e4d7feff		CALL runtime.getsig(SB)		
  0x43212c		488b442408		MOVQ 0x8(SP), AX		
  0x432131		8b4c2414		MOVL 0x14(SP), CX		
  0x432135		488d15a41f0900		LEAQ runtime.fwdSig(SB), DX	
  0x43213c		488904ca		MOVQ AX, 0(DX)(CX*8)		
  0x432140		488d04ca		LEAQ 0(DX)(CX*8), AX		
	case _SIGHUP, _SIGINT:
  0x432144		8d59ff			LEAL -0x1(CX), BX	
  0x432147		83fb01			CMPL $0x1, BX		
  0x43214a		0f87a1000000		JA 0x4321f1		
		if atomic.Loaduintptr(&fwdSig[sig]) == _SIG_IGN {
  0x432150		488b00			MOVQ 0(AX), AX		
  0x432153		4883f801		CMPQ $0x1, AX		
  0x432157		0f8594000000		JNE 0x4321f1		
  0x43215d		31c0			XORL AX, AX		
		if !sigInstallGoHandler(i) {
  0x43215f		84c0			TESTL AL, AL		
  0x432161		7532			JNE 0x432195		
			if fwdSig[i] != _SIG_DFL && fwdSig[i] != _SIG_IGN {
  0x432163		488b04ca		MOVQ 0(DX)(CX*8), AX		
  0x432167		4885c0			TESTQ AX, AX			
  0x43216a		7406			JE 0x432172			
  0x43216c		4883f801		CMPQ $0x1, AX			
  0x432170		750e			JNE 0x432180			
  0x432172		89c8			MOVL CX, AX			
  0x432174		488d15053e0700		LEAQ runtime.sigtable(SB), DX	
			continue
  0x43217b		e96effffff		JMP 0x4320ee		
				setsigstack(i)
  0x432180		890c24			MOVL CX, 0(SP)			
  0x432183		e8e8d6feff		CALL runtime.setsigstack(SB)	
  0x432188		8b4c2414		MOVL 0x14(SP), CX		
  0x43218c		488d154d1f0900		LEAQ runtime.fwdSig(SB), DX	
  0x432193		ebdd			JMP 0x432172			
		handlingSig[i] = 1
  0x432195		488d05241c0900		LEAQ runtime.handlingSig(SB), AX	
  0x43219c		c7048801000000		MOVL $0x1, 0(AX)(CX*4)			
		setsig(i, funcPC(sighandler))
  0x4321a3		488d1576870200		LEAQ 0x28776(IP), DX	
  0x4321aa		4889542420		MOVQ DX, 0x20(SP)	
  0x4321af		488d1d22c00300		LEAQ 0x3c022(IP), BX	
  0x4321b6		48895c2428		MOVQ BX, 0x28(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x4321bb		be08000000		MOVL $0x8, SI		
  0x4321c0		488d7c2420		LEAQ 0x20(SP), DI	
  0x4321c5		488b3c37		MOVQ 0(DI)(SI*1), DI	
  0x4321c9		4c8d442428		LEAQ 0x28(SP), R8	
  0x4321ce		418400			TESTB AL, 0(R8)		
  0x4321d1		488b3f			MOVQ 0(DI), DI		
		setsig(i, funcPC(sighandler))
  0x4321d4		890c24			MOVL CX, 0(SP)			
  0x4321d7		48897c2408		MOVQ DI, 0x8(SP)		
  0x4321dc		e81fd5feff		CALL runtime.setsig(SB)		
  0x4321e1		8b442414		MOVL 0x14(SP), AX		
  0x4321e5		488d15943d0700		LEAQ runtime.sigtable(SB), DX	
  0x4321ec		e9fdfeffff		JMP 0x4320ee			
  0x4321f1		488b442418		MOVQ 0x18(SP), AX		
	if t.flags&_SigSetStack != 0 {
  0x4321f6		488d1d833d0700		LEAQ runtime.sigtable(SB), BX	
  0x4321fd		8b04c3			MOVL 0(BX)(AX*8), AX		
  0x432200		0fbae006		BTL $0x6, AX			
  0x432204		7307			JAE 0x43220d			
  0x432206		31c0			XORL AX, AX			
		if !sigInstallGoHandler(i) {
  0x432208		e952ffffff		JMP 0x43215f		
	if (isarchive || islibrary) && t.flags&_SigPanic == 0 && sig != _SIGPIPE {
  0x43220d		0fb63597160900		MOVZX runtime.isarchive(SB), SI	
  0x432214		4084f6			TESTL SI, SI			
  0x432217		741c			JE 0x432235			
  0x432219		0fbae003		BTL $0x3, AX			
  0x43221d		720c			JB 0x43222b			
  0x43221f		83f90d			CMPL $0xd, CX			
  0x432222		7407			JE 0x43222b			
  0x432224		31c0			XORL AX, AX			
		if !sigInstallGoHandler(i) {
  0x432226		e934ffffff		JMP 0x43215f		
  0x43222b		b801000000		MOVL $0x1, AX		
  0x432230		e92affffff		JMP 0x43215f		
	if (isarchive || islibrary) && t.flags&_SigPanic == 0 && sig != _SIGPIPE {
  0x432235		0fb63571160900		MOVZX runtime.islibrary(SB), SI	
  0x43223c		4084f6			TESTL SI, SI			
  0x43223f		75d8			JNE 0x432219			
  0x432241		ebe8			JMP 0x43222b			
  0x432243		488b6c2430		MOVQ 0x30(SP), BP		
  0x432248		4883c438		ADDQ $0x38, SP			
  0x43224c		c3			RET				
		return
  0x43224d		488b6c2430		MOVQ 0x30(SP), BP	
  0x432252		4883c438		ADDQ $0x38, SP		
  0x432256		c3			RET			
	if (isarchive || islibrary) && !preinit {
  0x432257		0fb60d4f160900		MOVZX runtime.islibrary(SB), CX	
  0x43225e		84c9			TESTL CL, CL			
  0x432260		0f8484feffff		JE 0x4320ea			
func initsig(preinit bool) {
  0x432266		84c0			TESTL AL, AL		
	if (isarchive || islibrary) && !preinit {
  0x432268		e977feffff		JMP 0x4320e4		
		signalsOK = true
  0x43226d		c6053c16090001		MOVB $0x1, runtime.signalsOK(SB)	
  0x432274		e95afeffff		JMP 0x4320d3				
		t := &sigtable[i]
  0x432279		e8c2d7feff		CALL runtime.panicindex(SB)	
  0x43227e		0f0b			UD2				

TEXT runtime.setThreadCPUProfiler(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func setThreadCPUProfiler(hz int32) {
  0x432280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432289		483b6110		CMPQ 0x10(CX), SP	
  0x43228d		0f86bf000000		JBE 0x432352		
  0x432293		4883ec40		SUBQ $0x40, SP		
  0x432297		48896c2438		MOVQ BP, 0x38(SP)	
  0x43229c		488d6c2438		LEAQ 0x38(SP), BP	
	var it itimerval
  0x4322a1		0f57c0			XORPS X0, X0		
  0x4322a4		0f11442418		MOVUPS X0, 0x18(SP)	
  0x4322a9		0f11442428		MOVUPS X0, 0x28(SP)	
func setThreadCPUProfiler(hz int32) {
  0x4322ae		8b4c2448		MOVL 0x48(SP), CX	
	if hz == 0 {
  0x4322b2		85c9			TESTL CX, CX		
  0x4322b4		7540			JNE 0x4322f6		
		setitimer(_ITIMER_PROF, &it, nil)
  0x4322b6		c7042402000000		MOVL $0x2, 0(SP)		
  0x4322bd		488d442418		LEAQ 0x18(SP), AX		
  0x4322c2		4889442408		MOVQ AX, 0x8(SP)		
  0x4322c7		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4322d0		e88b560100		CALL runtime.setitimer(SB)	
	_g_ := getg()
  0x4322d5		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.profilehz = hz
  0x4322de		488b4030		MOVQ 0x30(AX), AX	
  0x4322e2		8b4c2448		MOVL 0x48(SP), CX	
  0x4322e6		89880c010000		MOVL CX, 0x10c(AX)	
}
  0x4322ec		488b6c2438		MOVQ 0x38(SP), BP	
  0x4322f1		4883c440		ADDQ $0x40, SP		
  0x4322f5		c3			RET			
		it.it_interval.tv_sec = 0
  0x4322f6		48c744241800000000	MOVQ $0x0, 0x18(SP)	
	tv.tv_usec = int64(x)
  0x4322ff		488d542418		LEAQ 0x18(SP), DX	
  0x432304		8402			TESTB AL, 0(DX)		
		it.it_interval.set_usec(1000000 / hz)
  0x432306		b840420f00		MOVL $0xf4240, AX	
  0x43230b		83f9ff			CMPL $-0x1, CX		
  0x43230e		7405			JE 0x432315		
  0x432310		99			CDQ			
  0x432311		f7f9			IDIVL CX		
  0x432313		eb05			JMP 0x43231a		
  0x432315		48f7d8			NEGQ AX			
  0x432318		31d2			XORL DX, DX		
	tv.tv_usec = int64(x)
  0x43231a		4863d0			MOVSXD AX, DX		
  0x43231d		4889542420		MOVQ DX, 0x20(SP)	
		it.it_value = it.it_interval
  0x432322		488b5c2418		MOVQ 0x18(SP), BX	
  0x432327		48895c2428		MOVQ BX, 0x28(SP)	
  0x43232c		4889542430		MOVQ DX, 0x30(SP)	
		setitimer(_ITIMER_PROF, &it, nil)
  0x432331		c7042402000000		MOVL $0x2, 0(SP)		
  0x432338		488d542418		LEAQ 0x18(SP), DX		
  0x43233d		4889542408		MOVQ DX, 0x8(SP)		
  0x432342		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43234b		e810560100		CALL runtime.setitimer(SB)	
  0x432350		eb83			JMP 0x4322d5			
func setThreadCPUProfiler(hz int32) {
  0x432352		e819220100		CALL runtime.morestack_noctxt(SB)	
  0x432357		e924ffffff		JMP runtime.setThreadCPUProfiler(SB)	

TEXT runtime.sigtrampgo(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {
  0x432360		4881eca8000000		SUBQ $0xa8, SP		
  0x432367		4889ac24a0000000	MOVQ BP, 0xa0(SP)	
  0x43236f		488dac24a0000000	LEAQ 0xa0(SP), BP	
  0x432377		0f57c0			XORPS X0, X0		
  0x43237a		0f11442470		MOVUPS X0, 0x70(SP)	
  0x43237f		0f11842480000000	MOVUPS X0, 0x80(SP)	
  0x432387		0f11842490000000	MOVUPS X0, 0x90(SP)	
	if sigfwdgo(sig, info, ctx) {
  0x43238f		8b8424b0000000		MOVL 0xb0(SP), AX	
  0x432396		890424			MOVL AX, 0(SP)		
func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {
  0x432399		488b8424b8000000	MOVQ 0xb8(SP), AX	
	if sigfwdgo(sig, info, ctx) {
  0x4323a1		4889442408		MOVQ AX, 0x8(SP)	
func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {
  0x4323a6		488b8c24c0000000	MOVQ 0xc0(SP), CX	
	if sigfwdgo(sig, info, ctx) {
  0x4323ae		48894c2410		MOVQ CX, 0x10(SP)		
  0x4323b3		e8380b0000		CALL runtime.sigfwdgo(SB)	
  0x4323b8		0fb6442418		MOVZX 0x18(SP), AX		
  0x4323bd		84c0			TESTL AL, AL			
  0x4323bf		0f8543040000		JNE 0x432808			
	g := getg()
  0x4323c5		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if g == nil {
  0x4323ce		4885c0			TESTQ AX, AX		
  0x4323d1		0f84c2030000		JE 0x432799		
  0x4323d7		4889442458		MOVQ AX, 0x58(SP)	
	var gsignalStack gsignalStack
  0x4323dc		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x4323e5		0f57c0			XORPS X0, X0		
  0x4323e8		0f11442438		MOVUPS X0, 0x38(SP)	
  0x4323ed		0f11442448		MOVUPS X0, 0x48(SP)	
	if sp < g.m.gsignal.stack.lo || sp >= g.m.gsignal.stack.hi {
  0x4323f2		488b4830		MOVQ 0x30(AX), CX	
  0x4323f6		488b5150		MOVQ 0x50(CX), DX	
	sp := uintptr(unsafe.Pointer(&sig))
  0x4323fa		488d9c24b0000000	LEAQ 0xb0(SP), BX	
	if sp < g.m.gsignal.stack.lo || sp >= g.m.gsignal.stack.hi {
  0x432402		488b32			MOVQ 0(DX), SI		
  0x432405		4839f3			CMPQ SI, BX		
  0x432408		0f8377030000		JAE 0x432785		
  0x43240e		48895c2428		MOVQ BX, 0x28(SP)	
		if sp >= g.m.g0.stack.lo && sp < g.m.g0.stack.hi {
  0x432413		488b09			MOVQ 0(CX), CX		
  0x432416		488b11			MOVQ 0(CX), DX		
  0x432419		4839d3			CMPQ DX, BX		
  0x43241c		0f82da010000		JB 0x4325fc		
  0x432422		488b4908		MOVQ 0x8(CX), CX	
  0x432426		4839cb			CMPQ CX, BX		
  0x432429		0f83cd010000		JAE 0x4325fc		
			st := stackt{ss_size: g.m.g0.stack.hi - g.m.g0.stack.lo}
  0x43242f		48c744247000000000	MOVQ $0x0, 0x70(SP)	
  0x432438		0f11442478		MOVUPS X0, 0x78(SP)	
  0x43243d		488b4830		MOVQ 0x30(AX), CX	
  0x432441		488b09			MOVQ 0(CX), CX		
  0x432444		488b5108		MOVQ 0x8(CX), DX	
  0x432448		482b11			SUBQ 0(CX), DX		
  0x43244b		4889942480000000	MOVQ DX, 0x80(SP)	
			setSignalstackSP(&st, g.m.g0.stack.lo)
  0x432453		488b4830		MOVQ 0x30(AX), CX	
  0x432457		488b09			MOVQ 0(CX), CX		
	*(*uintptr)(unsafe.Pointer(&s.ss_sp)) = sp
  0x43245a		488d542470		LEAQ 0x70(SP), DX	
  0x43245f		8402			TESTB AL, 0(DX)		
			setSignalstackSP(&st, g.m.g0.stack.lo)
  0x432461		488b09			MOVQ 0(CX), CX		
	*(*uintptr)(unsafe.Pointer(&s.ss_sp)) = sp
  0x432464		48894c2470		MOVQ CX, 0x70(SP)	
	g := getg()
  0x432469		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
		old.stack = g.m.gsignal.stack
  0x432472		488b5130		MOVQ 0x30(CX), DX	
  0x432476		488b5250		MOVQ 0x50(DX), DX	
  0x43247a		488b1a			MOVQ 0(DX), BX		
  0x43247d		488b5208		MOVQ 0x8(DX), DX	
  0x432481		48895c2430		MOVQ BX, 0x30(SP)	
  0x432486		4889542438		MOVQ DX, 0x38(SP)	
		old.stackguard0 = g.m.gsignal.stackguard0
  0x43248b		488b5130		MOVQ 0x30(CX), DX	
  0x43248f		488b5250		MOVQ 0x50(DX), DX	
  0x432493		488b5210		MOVQ 0x10(DX), DX	
  0x432497		4889542440		MOVQ DX, 0x40(SP)	
		old.stackguard1 = g.m.gsignal.stackguard1
  0x43249c		488b5130		MOVQ 0x30(CX), DX	
  0x4324a0		488b5250		MOVQ 0x50(DX), DX	
  0x4324a4		488b5218		MOVQ 0x18(DX), DX	
  0x4324a8		4889542448		MOVQ DX, 0x48(SP)	
		old.stktopsp = g.m.gsignal.stktopsp
  0x4324ad		488b5130		MOVQ 0x30(CX), DX	
  0x4324b1		488b5250		MOVQ 0x50(DX), DX	
  0x4324b5		488b9280000000		MOVQ 0x80(DX), DX	
  0x4324bc		4889542450		MOVQ DX, 0x50(SP)	
	g.m.gsignal.stack.lo = stsp
  0x4324c1		488b5130		MOVQ 0x30(CX), DX	
  0x4324c5		488b5250		MOVQ 0x50(DX), DX	
	stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x4324c9		488b5c2470		MOVQ 0x70(SP), BX	
	g.m.gsignal.stack.lo = stsp
  0x4324ce		48891a			MOVQ BX, 0(DX)		
	g.m.gsignal.stack.hi = stsp + st.ss_size
  0x4324d1		488b5130		MOVQ 0x30(CX), DX	
  0x4324d5		488b5250		MOVQ 0x50(DX), DX	
  0x4324d9		488bb42480000000	MOVQ 0x80(SP), SI	
  0x4324e1		4801de			ADDQ BX, SI		
  0x4324e4		48897208		MOVQ SI, 0x8(DX)	
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x4324e8		488b5130		MOVQ 0x30(CX), DX	
  0x4324ec		488b5250		MOVQ 0x50(DX), DX	
  0x4324f0		4881c370030000		ADDQ $0x370, BX		
  0x4324f7		48895a10		MOVQ BX, 0x10(DX)	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x4324fb		488b4930		MOVQ 0x30(CX), CX	
  0x4324ff		488b4950		MOVQ 0x50(CX), CX	
  0x432503		48895918		MOVQ BX, 0x18(CX)	
			g.m.gsignal.stktopsp = getcallersp(unsafe.Pointer(&sig))
  0x432507		488b4830		MOVQ 0x30(AX), CX	
  0x43250b		488b4950		MOVQ 0x50(CX), CX	
  0x43250f		488d9424b0000000	LEAQ 0xb0(SP), DX	
  0x432517		48899180000000		MOVQ DX, 0x80(CX)	
			setStack = true
  0x43251e		b901000000		MOVL $0x1, CX		
	setg(g.m.gsignal)
  0x432523		884c2427		MOVB CL, 0x27(SP)	
  0x432527		488b5030		MOVQ 0x30(AX), DX	
  0x43252b		488b5250		MOVQ 0x50(DX), DX	
  0x43252f		48891424		MOVQ DX, 0(SP)		
  0x432533		e878370100		CALL runtime.setg(SB)	
  0x432538		488b442458		MOVQ 0x58(SP), AX	
	if g.stackguard0 == stackFork {
  0x43253d		488b4810		MOVQ 0x10(AX), CX	
  0x432541		4881f92efbffff		CMPQ $-0x4d2, CX	
  0x432548		0f8495000000		JE 0x4325e3		
	sighandler(sig, info, ctx, g)
  0x43254e		8b8c24b0000000		MOVL 0xb0(SP), CX		
  0x432555		890c24			MOVL CX, 0(SP)			
  0x432558		488b8c24b8000000	MOVQ 0xb8(SP), CX		
  0x432560		48894c2408		MOVQ CX, 0x8(SP)		
  0x432565		488b8c24c0000000	MOVQ 0xc0(SP), CX		
  0x43256d		48894c2410		MOVQ CX, 0x10(SP)		
  0x432572		4889442418		MOVQ AX, 0x18(SP)		
  0x432577		e874f4ffff		CALL runtime.sighandler(SB)	
  0x43257c		488b442458		MOVQ 0x58(SP), AX		
	setg(g)
  0x432581		48890424		MOVQ AX, 0(SP)		
  0x432585		e826370100		CALL runtime.setg(SB)	
  0x43258a		0fb6442427		MOVZX 0x27(SP), AX	
	if setStack {
  0x43258f		84c0			TESTL AL, AL		
  0x432591		7440			JE 0x4325d3		
	gp := getg().m.gsignal
  0x432593		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43259c		488b4030		MOVQ 0x30(AX), AX	
  0x4325a0		488b4050		MOVQ 0x50(AX), AX	
	gp.stack = st.stack
  0x4325a4		488b4c2438		MOVQ 0x38(SP), CX	
  0x4325a9		488b542430		MOVQ 0x30(SP), DX	
  0x4325ae		488910			MOVQ DX, 0(AX)		
  0x4325b1		48894808		MOVQ CX, 0x8(AX)	
	gp.stackguard0 = st.stackguard0
  0x4325b5		488b4c2440		MOVQ 0x40(SP), CX	
  0x4325ba		48894810		MOVQ CX, 0x10(AX)	
	gp.stackguard1 = st.stackguard1
  0x4325be		488b4c2448		MOVQ 0x48(SP), CX	
  0x4325c3		48894818		MOVQ CX, 0x18(AX)	
	gp.stktopsp = st.stktopsp
  0x4325c7		488b4c2450		MOVQ 0x50(SP), CX	
  0x4325cc		48898880000000		MOVQ CX, 0x80(AX)	
  0x4325d3		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x4325db		4881c4a8000000		ADDQ $0xa8, SP		
  0x4325e2		c3			RET			
		signalDuringFork(sig)
  0x4325e3		8b8424b0000000		MOVL 0xb0(SP), AX			
  0x4325ea		890424			MOVL AX, 0(SP)				
  0x4325ed		e80e080000		CALL runtime.signalDuringFork(SB)	
  0x4325f2		488b442458		MOVQ 0x58(SP), AX			
  0x4325f7		e952ffffff		JMP 0x43254e				
			var st stackt
  0x4325fc		48c784248800000000000000	MOVQ $0x0, 0x88(SP)	
  0x432608		0f11842490000000		MOVUPS X0, 0x90(SP)	
			sigaltstack(nil, &st)
  0x432610		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x432618		488d842488000000	LEAQ 0x88(SP), AX		
  0x432620		4889442408		MOVQ AX, 0x8(SP)		
  0x432625		e8a6580100		CALL runtime.sigaltstack(SB)	
			if st.ss_flags&_SS_DISABLE != 0 {
  0x43262a		8b842490000000		MOVL 0x90(SP), AX	
  0x432631		0fbae001		BTL $0x1, AX		
  0x432635		0f821b010000		JB 0x432756		
			stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x43263b		488b842488000000	MOVQ 0x88(SP), AX	
  0x432643		488b4c2428		MOVQ 0x28(SP), CX	
			if sp < stsp || sp >= stsp+st.ss_size {
  0x432648		4839c1			CMPQ AX, CX		
  0x43264b		0f83ec000000		JAE 0x43273d		
				setg(nil)
  0x432651		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x432659		e852360100		CALL runtime.setg(SB)	
				needm(0)
  0x43265e		c6042400		MOVB $0x0, 0(SP)	
  0x432662		e8693cffff		CALL runtime.needm(SB)	
				sigNotOnStack(sig)
  0x432667		8b8424b0000000		MOVL 0xb0(SP), AX		
  0x43266e		890424			MOVL AX, 0(SP)			
  0x432671		e8fa060000		CALL runtime.sigNotOnStack(SB)	
				dropm()
  0x432676		e81540ffff		CALL runtime.dropm(SB)	
	g := getg()
  0x43267b		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
		old.stack = g.m.gsignal.stack
  0x432684		488b5130		MOVQ 0x30(CX), DX	
  0x432688		488b5250		MOVQ 0x50(DX), DX	
  0x43268c		488b5a08		MOVQ 0x8(DX), BX	
  0x432690		488b12			MOVQ 0(DX), DX		
  0x432693		4889542430		MOVQ DX, 0x30(SP)	
  0x432698		48895c2438		MOVQ BX, 0x38(SP)	
		old.stackguard0 = g.m.gsignal.stackguard0
  0x43269d		488b5130		MOVQ 0x30(CX), DX	
  0x4326a1		488b5250		MOVQ 0x50(DX), DX	
  0x4326a5		488b5210		MOVQ 0x10(DX), DX	
  0x4326a9		4889542440		MOVQ DX, 0x40(SP)	
		old.stackguard1 = g.m.gsignal.stackguard1
  0x4326ae		488b5130		MOVQ 0x30(CX), DX	
  0x4326b2		488b5250		MOVQ 0x50(DX), DX	
  0x4326b6		488b5218		MOVQ 0x18(DX), DX	
  0x4326ba		4889542448		MOVQ DX, 0x48(SP)	
		old.stktopsp = g.m.gsignal.stktopsp
  0x4326bf		488b5130		MOVQ 0x30(CX), DX	
  0x4326c3		488b5250		MOVQ 0x50(DX), DX	
  0x4326c7		488b9280000000		MOVQ 0x80(DX), DX	
  0x4326ce		4889542450		MOVQ DX, 0x50(SP)	
	g.m.gsignal.stack.lo = stsp
  0x4326d3		488b5130		MOVQ 0x30(CX), DX	
  0x4326d7		488b5250		MOVQ 0x50(DX), DX	
	stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x4326db		488b9c2488000000	MOVQ 0x88(SP), BX	
	g.m.gsignal.stack.lo = stsp
  0x4326e3		48891a			MOVQ BX, 0(DX)		
	g.m.gsignal.stack.hi = stsp + st.ss_size
  0x4326e6		488b5130		MOVQ 0x30(CX), DX	
  0x4326ea		488b5250		MOVQ 0x50(DX), DX	
  0x4326ee		488bb42498000000	MOVQ 0x98(SP), SI	
  0x4326f6		4801de			ADDQ BX, SI		
  0x4326f9		48897208		MOVQ SI, 0x8(DX)	
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x4326fd		488b5130		MOVQ 0x30(CX), DX	
  0x432701		488b5250		MOVQ 0x50(DX), DX	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x432705		4881c370030000		ADDQ $0x370, BX		
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x43270c		48895a10		MOVQ BX, 0x10(DX)	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x432710		488b4930		MOVQ 0x30(CX), CX	
  0x432714		488b4950		MOVQ 0x50(CX), CX	
  0x432718		48895918		MOVQ BX, 0x18(CX)	
  0x43271c		488b442458		MOVQ 0x58(SP), AX	
			g.m.gsignal.stktopsp = getcallersp(unsafe.Pointer(&sig))
  0x432721		488b4830		MOVQ 0x30(AX), CX	
  0x432725		488b4950		MOVQ 0x50(CX), CX	
  0x432729		488d9424b0000000	LEAQ 0xb0(SP), DX	
  0x432731		48899180000000		MOVQ DX, 0x80(CX)	
			setStack = true
  0x432738		e9e1fdffff		JMP 0x43251e		
			if sp < stsp || sp >= stsp+st.ss_size {
  0x43273d		488b942498000000	MOVQ 0x98(SP), DX	
  0x432745		4801d0			ADDQ DX, AX		
  0x432748		4839c1			CMPQ AX, CX		
  0x43274b		0f8300ffffff		JAE 0x432651		
  0x432751		e925ffffff		JMP 0x43267b		
				setg(nil)
  0x432756		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x43275e		e84d350100		CALL runtime.setg(SB)	
				needm(0)
  0x432763		c6042400		MOVB $0x0, 0(SP)	
  0x432767		e8643bffff		CALL runtime.needm(SB)	
				noSignalStack(sig)
  0x43276c		8b8424b0000000		MOVL 0xb0(SP), AX		
  0x432773		890424			MOVL AX, 0(SP)			
  0x432776		e865050000		CALL runtime.noSignalStack(SB)	
				dropm()
  0x43277b		e8103fffff		CALL runtime.dropm(SB)	
  0x432780		e9b6feffff		JMP 0x43263b		
	if sp < g.m.gsignal.stack.lo || sp >= g.m.gsignal.stack.hi {
  0x432785		488b5208		MOVQ 0x8(DX), DX	
  0x432789		4839d3			CMPQ DX, BX		
  0x43278c		0f837cfcffff		JAE 0x43240e		
  0x432792		31c9			XORL CX, CX		
  0x432794		e98afdffff		JMP 0x432523		
		c := &sigctxt{info, ctx}
  0x432799		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4327a1		4889442460		MOVQ AX, 0x60(SP)	
  0x4327a6		488b8424c0000000	MOVQ 0xc0(SP), AX	
  0x4327ae		4889442468		MOVQ AX, 0x68(SP)	
		if sig == _SIGPROF {
  0x4327b3		8b8c24b0000000		MOVL 0xb0(SP), CX	
  0x4327ba		83f91b			CMPL $0x1b, CX		
  0x4327bd		7526			JNE 0x4327e5		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4327bf		488d4828		LEAQ 0x28(AX), CX	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x4327c3		8401			TESTB AL, 0(CX)		
  0x4327c5		488b80a8000000		MOVQ 0xa8(AX), AX	
			sigprofNonGoPC(c.sigpc())
  0x4327cc		48890424		MOVQ AX, 0(SP)			
  0x4327d0		e88b8cffff		CALL runtime.sigprofNonGoPC(SB)	
			return
  0x4327d5		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x4327dd		4881c4a8000000		ADDQ $0xa8, SP		
  0x4327e4		c3			RET			
		badsignal(uintptr(sig), c)
  0x4327e5		48890c24		MOVQ CX, 0(SP)			
  0x4327e9		488d442460		LEAQ 0x60(SP), AX		
  0x4327ee		4889442408		MOVQ AX, 0x8(SP)		
  0x4327f3		e898060000		CALL runtime.badsignal(SB)	
		return
  0x4327f8		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x432800		4881c4a8000000		ADDQ $0xa8, SP		
  0x432807		c3			RET			
		return
  0x432808		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x432810		4881c4a8000000		ADDQ $0xa8, SP		
  0x432817		c3			RET			

TEXT runtime.sigpanic(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func sigpanic() {
  0x432820		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432829		483b6110		CMPQ 0x10(CX), SP	
  0x43282d		0f867d020000		JBE 0x432ab0		
  0x432833		4883ec48		SUBQ $0x48, SP		
  0x432837		48896c2440		MOVQ BP, 0x40(SP)	
  0x43283c		488d6c2440		LEAQ 0x40(SP), BP	
	g := getg()
  0x432841		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43284a		4889442428		MOVQ AX, 0x28(SP)	
	if !canpanic(g) {
  0x43284f		48890424		MOVQ AX, 0(SP)			
  0x432853		e8f8f0feff		CALL runtime.canpanic(SB)	
  0x432858		0fb6442408		MOVZX 0x8(SP), AX		
  0x43285d		84c0			TESTL AL, AL			
  0x43285f		0f8430020000		JE 0x432a95			
  0x432865		488b442428		MOVQ 0x28(SP), AX		
	switch g.sig {
  0x43286a		8b88e8000000		MOVL 0xe8(AX), CX	
	case _SIGBUS:
  0x432870		83f907			CMPL $0x7, CX		
  0x432873		7542			JNE 0x4328b7		
		if g.sigcode0 == _BUS_ADRERR && g.sigcode1 < 0x1000 {
  0x432875		488b8808010000		MOVQ 0x108(AX), CX	
  0x43287c		4883f902		CMPQ $0x2, CX		
  0x432880		7510			JNE 0x432892		
  0x432882		488b8810010000		MOVQ 0x110(AX), CX	
  0x432889		4881f900100000		CMPQ $0x1000, CX	
  0x432890		7219			JB 0x4328ab		
		if g.paniconfault {
  0x432892		0fb688c1000000		MOVZX 0xc1(AX), CX	
  0x432899		84c9			TESTL CL, CL		
  0x43289b		0f8492010000		JE 0x432a33		
			panicmem()
  0x4328a1		e8cad3feff		CALL runtime.panicmem(SB)	
  0x4328a6		e988010000		JMP 0x432a33			
			panicmem()
  0x4328ab		e8c0d3feff		CALL runtime.panicmem(SB)	
  0x4328b0		488b442428		MOVQ 0x28(SP), AX		
  0x4328b5		ebdb			JMP 0x432892			
	case _SIGFPE:
  0x4328b7		83f908			CMPL $0x8, CX		
  0x4328ba		0f859e000000		JNE 0x43295e		
		switch g.sigcode0 {
  0x4328c0		488b8808010000		MOVQ 0x108(AX), CX	
		case _FPE_INTDIV:
  0x4328c7		4883f901		CMPQ $0x1, CX		
  0x4328cb		0f8483000000		JE 0x432954		
		case _FPE_INTOVF:
  0x4328d1		4883f902		CMPQ $0x2, CX		
  0x4328d5		7476			JE 0x43294d		
		panicfloat()
  0x4328d7		e824d3feff		CALL runtime.panicfloat(SB)	
	switch g.sig {
  0x4328dc		488b442428		MOVQ 0x28(SP), AX	
	if g.sig >= uint32(len(sigtable)) {
  0x4328e1		8b80e8000000		MOVL 0xe8(AX), AX	
  0x4328e7		83f841			CMPL $0x41, AX		
  0x4328ea		0f83c6000000		JAE 0x4329b6		
	panic(errorString(sigtable[g.sig].name))
  0x4328f0		4883f841		CMPQ $0x41, AX			
  0x4328f4		0f83b5000000		JAE 0x4329af			
  0x4328fa		488d0440		LEAQ 0(AX)(AX*2), AX		
  0x4328fe		488d0d7b360700		LEAQ runtime.sigtable(SB), CX	
  0x432905		488b54c108		MOVQ 0x8(CX)(AX*8), DX		
  0x43290a		488b44c110		MOVQ 0x10(CX)(AX*8), AX		
  0x43290f		4889542430		MOVQ DX, 0x30(SP)		
  0x432914		4889442438		MOVQ AX, 0x38(SP)		
  0x432919		488d05a0850200		LEAQ 0x285a0(IP), AX		
  0x432920		48890424		MOVQ AX, 0(SP)			
  0x432924		488d442430		LEAQ 0x30(SP), AX		
  0x432929		4889442408		MOVQ AX, 0x8(SP)		
  0x43292e		e86d68fdff		CALL runtime.convT2Estring(SB)	
  0x432933		488b442410		MOVQ 0x10(SP), AX		
  0x432938		488b4c2418		MOVQ 0x18(SP), CX		
  0x43293d		48890424		MOVQ AX, 0(SP)			
  0x432941		48894c2408		MOVQ CX, 0x8(SP)		
  0x432946		e8e5e0feff		CALL runtime.gopanic(SB)	
  0x43294b		0f0b			UD2				
			panicoverflow()
  0x43294d		e83ed2feff		CALL runtime.panicoverflow(SB)	
		switch g.sigcode0 {
  0x432952		eb83			JMP 0x4328d7		
			panicdivide()
  0x432954		e8c7d1feff		CALL runtime.panicdivide(SB)	
		switch g.sigcode0 {
  0x432959		e979ffffff		JMP 0x4328d7		
	case _SIGSEGV:
  0x43295e		83f90b			CMPL $0xb, CX		
  0x432961		0f8575ffffff		JNE 0x4328dc		
		if (g.sigcode0 == 0 || g.sigcode0 == _SEGV_MAPERR || g.sigcode0 == _SEGV_ACCERR) && g.sigcode1 < 0x1000 {
  0x432967		488b8808010000		MOVQ 0x108(AX), CX	
  0x43296e		4885c9			TESTQ CX, CX		
  0x432971		752e			JNE 0x4329a1		
  0x432973		488b8810010000		MOVQ 0x110(AX), CX	
  0x43297a		4881f900100000		CMPQ $0x1000, CX	
  0x432981		7212			JB 0x432995		
		if g.paniconfault {
  0x432983		0fb688c1000000		MOVZX 0xc1(AX), CX	
  0x43298a		84c9			TESTL CL, CL		
  0x43298c		7443			JE 0x4329d1		
			panicmem()
  0x43298e		e8ddd2feff		CALL runtime.panicmem(SB)	
  0x432993		eb3c			JMP 0x4329d1			
			panicmem()
  0x432995		e8d6d2feff		CALL runtime.panicmem(SB)	
  0x43299a		488b442428		MOVQ 0x28(SP), AX		
  0x43299f		ebe2			JMP 0x432983			
		if (g.sigcode0 == 0 || g.sigcode0 == _SEGV_MAPERR || g.sigcode0 == _SEGV_ACCERR) && g.sigcode1 < 0x1000 {
  0x4329a1		4883f901		CMPQ $0x1, CX		
  0x4329a5		74cc			JE 0x432973		
  0x4329a7		4883f902		CMPQ $0x2, CX		
  0x4329ab		74c6			JE 0x432973		
  0x4329ad		ebd4			JMP 0x432983		
	panic(errorString(sigtable[g.sig].name))
  0x4329af		e88cd0feff		CALL runtime.panicindex(SB)	
  0x4329b4		0f0b			UD2				
		throw("unexpected signal value")
  0x4329b6		488d05448e0300		LEAQ 0x38e44(IP), AX	
  0x4329bd		48890424		MOVQ AX, 0(SP)		
  0x4329c1		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4329ca		e801e8feff		CALL runtime.throw(SB)	
  0x4329cf		0f0b			UD2			
  0x4329d1		488b442428		MOVQ 0x28(SP), AX	
		print("unexpected fault address ", hex(g.sigcode1), "\n")
  0x4329d6		488b8010010000		MOVQ 0x110(AX), AX		
  0x4329dd		4889442420		MOVQ AX, 0x20(SP)		
  0x4329e2		e819f1feff		CALL runtime.printlock(SB)	
  0x4329e7		488d0585910300		LEAQ 0x39185(IP), AX		
  0x4329ee		48890424		MOVQ AX, 0(SP)			
  0x4329f2		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x4329fb		e840fafeff		CALL runtime.printstring(SB)	
  0x432a00		488b442420		MOVQ 0x20(SP), AX		
  0x432a05		48890424		MOVQ AX, 0(SP)			
  0x432a09		e8e2f8feff		CALL runtime.printhex(SB)	
  0x432a0e		e87df3feff		CALL runtime.printnl(SB)	
  0x432a13		e868f1feff		CALL runtime.printunlock(SB)	
		throw("fault")
  0x432a18		488d05ad730300		LEAQ 0x373ad(IP), AX	
  0x432a1f		48890424		MOVQ AX, 0(SP)		
  0x432a23		48c744240805000000	MOVQ $0x5, 0x8(SP)	
  0x432a2c		e89fe7feff		CALL runtime.throw(SB)	
  0x432a31		0f0b			UD2			
  0x432a33		488b442428		MOVQ 0x28(SP), AX	
		print("unexpected fault address ", hex(g.sigcode1), "\n")
  0x432a38		488b8010010000		MOVQ 0x110(AX), AX		
  0x432a3f		4889442420		MOVQ AX, 0x20(SP)		
  0x432a44		e8b7f0feff		CALL runtime.printlock(SB)	
  0x432a49		488d0523910300		LEAQ 0x39123(IP), AX		
  0x432a50		48890424		MOVQ AX, 0(SP)			
  0x432a54		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x432a5d		e8def9feff		CALL runtime.printstring(SB)	
  0x432a62		488b442420		MOVQ 0x20(SP), AX		
  0x432a67		48890424		MOVQ AX, 0(SP)			
  0x432a6b		e880f8feff		CALL runtime.printhex(SB)	
  0x432a70		e81bf3feff		CALL runtime.printnl(SB)	
  0x432a75		e806f1feff		CALL runtime.printunlock(SB)	
		throw("fault")
  0x432a7a		488d054b730300		LEAQ 0x3734b(IP), AX	
  0x432a81		48890424		MOVQ AX, 0(SP)		
  0x432a85		48c744240805000000	MOVQ $0x5, 0x8(SP)	
  0x432a8e		e83de7feff		CALL runtime.throw(SB)	
  0x432a93		0f0b			UD2			
		throw("unexpected signal during runtime execution")
  0x432a95		488d0559aa0300		LEAQ 0x3aa59(IP), AX	
  0x432a9c		48890424		MOVQ AX, 0(SP)		
  0x432aa0		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x432aa9		e822e7feff		CALL runtime.throw(SB)	
  0x432aae		0f0b			UD2			
func sigpanic() {
  0x432ab0		e8bb1a0100		CALL runtime.morestack_noctxt(SB)	
  0x432ab5		e966fdffff		JMP runtime.sigpanic(SB)		

TEXT runtime.dieFromSignal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func dieFromSignal(sig uint32) {
  0x432ac0		4883ec18		SUBQ $0x18, SP		
  0x432ac4		48896c2410		MOVQ BP, 0x10(SP)	
  0x432ac9		488d6c2410		LEAQ 0x10(SP), BP	
  0x432ace		8b442420		MOVL 0x20(SP), AX	
	unblocksig(sig)
  0x432ad2		890424			MOVL AX, 0(SP)			
  0x432ad5		e8a6060000		CALL runtime.unblocksig(SB)	
  0x432ada		8b442420		MOVL 0x20(SP), AX		
	atomic.Store(&handlingSig[sig], 0)
  0x432ade		4883f841		CMPQ $0x41, AX				
  0x432ae2		736c			JAE 0x432b50				
  0x432ae4		488d0dd5120900		LEAQ runtime.handlingSig(SB), CX	
  0x432aeb		488d0c81		LEAQ 0(CX)(AX*4), CX			
  0x432aef		31d2			XORL DX, DX				
  0x432af1		8711			XCHGL DX, 0(CX)				
	raise(sig)
  0x432af3		890424			MOVL AX, 0(SP)		
  0x432af6		e8254e0100		CALL runtime.raise(SB)	
	osyield()
  0x432afb		e850540100		CALL runtime.osyield(SB)	
	osyield()
  0x432b00		e84b540100		CALL runtime.osyield(SB)	
	osyield()
  0x432b05		e846540100		CALL runtime.osyield(SB)	
  0x432b0a		8b442420		MOVL 0x20(SP), AX		
	setsig(sig, _SIG_DFL)
  0x432b0e		890424			MOVL AX, 0(SP)		
  0x432b11		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x432b1a		e8e1cbfeff		CALL runtime.setsig(SB)	
  0x432b1f		8b442420		MOVL 0x20(SP), AX	
	raise(sig)
  0x432b23		890424			MOVL AX, 0(SP)		
  0x432b26		e8f54d0100		CALL runtime.raise(SB)	
	osyield()
  0x432b2b		e820540100		CALL runtime.osyield(SB)	
	osyield()
  0x432b30		e81b540100		CALL runtime.osyield(SB)	
	osyield()
  0x432b35		e816540100		CALL runtime.osyield(SB)	
	exit(2)
  0x432b3a		c7042402000000		MOVL $0x2, 0(SP)	
  0x432b41		e88a4c0100		CALL runtime.exit(SB)	
}
  0x432b46		488b6c2410		MOVQ 0x10(SP), BP	
  0x432b4b		4883c418		ADDQ $0x18, SP		
  0x432b4f		c3			RET			
	atomic.Store(&handlingSig[sig], 0)
  0x432b50		e8ebcefeff		CALL runtime.panicindex(SB)	
  0x432b55		0f0b			UD2				

TEXT runtime.raisebadsignal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func raisebadsignal(sig uint32, c *sigctxt) {
  0x432b60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432b69		483b6110		CMPQ 0x10(CX), SP	
  0x432b6d		0f8616010000		JBE 0x432c89		
  0x432b73		4883ec30		SUBQ $0x30, SP		
  0x432b77		48896c2428		MOVQ BP, 0x28(SP)	
  0x432b7c		488d6c2428		LEAQ 0x28(SP), BP	
  0x432b81		8b442438		MOVL 0x38(SP), AX	
	if sig == _SIGPROF {
  0x432b85		83f81b			CMPL $0x1b, AX		
  0x432b88		0f84ea000000		JE 0x432c78		
	if sig >= _NSIG {
  0x432b8e		83f841			CMPL $0x41, AX		
  0x432b91		0f82c5000000		JB 0x432c5c		
  0x432b97		31c9			XORL CX, CX		
	unblocksig(sig)
  0x432b99		48894c2410		MOVQ CX, 0x10(SP)		
  0x432b9e		890424			MOVL AX, 0(SP)			
  0x432ba1		e8da050000		CALL runtime.unblocksig(SB)	
  0x432ba6		8b442438		MOVL 0x38(SP), AX		
	setsig(sig, handler)
  0x432baa		890424			MOVL AX, 0(SP)		
  0x432bad		488b4c2410		MOVQ 0x10(SP), CX	
  0x432bb2		48894c2408		MOVQ CX, 0x8(SP)	
  0x432bb7		e844cbfeff		CALL runtime.setsig(SB)	
	if (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {
  0x432bbc		0fb605e80c0900		MOVZX runtime.isarchive(SB), AX	
  0x432bc3		84c0			TESTL AL, AL			
  0x432bc5		0f8480000000		JE 0x432c4b			
  0x432bcb		488b442410		MOVQ 0x10(SP), AX		
  0x432bd0		4885c0			TESTQ AX, AX			
  0x432bd3		7511			JNE 0x432be6			
  0x432bd5		488b442440		MOVQ 0x40(SP), AX		
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x432bda		488b00			MOVQ 0(AX), AX		
  0x432bdd		48634008		MOVSXD 0x8(AX), AX	
	if (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {
  0x432be1		4885c0			TESTQ AX, AX		
  0x432be4		755b			JNE 0x432c41		
  0x432be6		8b442438		MOVL 0x38(SP), AX	
	raise(sig)
  0x432bea		890424			MOVL AX, 0(SP)		
  0x432bed		e82e4d0100		CALL runtime.raise(SB)	
	usleep(1000)
  0x432bf2		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x432bf9		e8b24c0100		CALL runtime.usleep(SB)	
	setsig(sig, funcPC(sighandler))
  0x432bfe		488d051b7d0200		LEAQ 0x27d1b(IP), AX	
  0x432c05		4889442418		MOVQ AX, 0x18(SP)	
  0x432c0a		488d05c7b50300		LEAQ 0x3b5c7(IP), AX	
  0x432c11		4889442420		MOVQ AX, 0x20(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x432c16		8400			TESTB AL, 0(AX)		
  0x432c18		488d442420		LEAQ 0x20(SP), AX	
  0x432c1d		8400			TESTB AL, 0(AX)		
  0x432c1f		488b05b2b50300		MOVQ 0x3b5b2(IP), AX	
  0x432c26		8b4c2438		MOVL 0x38(SP), CX	
	setsig(sig, funcPC(sighandler))
  0x432c2a		890c24			MOVL CX, 0(SP)		
  0x432c2d		4889442408		MOVQ AX, 0x8(SP)	
  0x432c32		e8c9cafeff		CALL runtime.setsig(SB)	
}
  0x432c37		488b6c2428		MOVQ 0x28(SP), BP	
  0x432c3c		4883c430		ADDQ $0x30, SP		
  0x432c40		c3			RET			
		return
  0x432c41		488b6c2428		MOVQ 0x28(SP), BP	
  0x432c46		4883c430		ADDQ $0x30, SP		
  0x432c4a		c3			RET			
	if (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {
  0x432c4b		0fb6055b0c0900		MOVZX runtime.islibrary(SB), AX	
  0x432c52		84c0			TESTL AL, AL			
  0x432c54		0f8571ffffff		JNE 0x432bcb			
  0x432c5a		eb8a			JMP 0x432be6			
		handler = atomic.Loaduintptr(&fwdSig[sig])
  0x432c5c		4883f841		CMPQ $0x41, AX			
  0x432c60		7320			JAE 0x432c82			
  0x432c62		488d1577140900		LEAQ runtime.fwdSig(SB), DX	
  0x432c69		488d14c2		LEAQ 0(DX)(AX*8), DX		
  0x432c6d		488b12			MOVQ 0(DX), DX			
  0x432c70		4889d1			MOVQ DX, CX			
  0x432c73		e921ffffff		JMP 0x432b99			
		return
  0x432c78		488b6c2428		MOVQ 0x28(SP), BP	
  0x432c7d		4883c430		ADDQ $0x30, SP		
  0x432c81		c3			RET			
		handler = atomic.Loaduintptr(&fwdSig[sig])
  0x432c82		e8b9cdfeff		CALL runtime.panicindex(SB)	
  0x432c87		0f0b			UD2				
func raisebadsignal(sig uint32, c *sigctxt) {
  0x432c89		e8e2180100		CALL runtime.morestack_noctxt(SB)	
  0x432c8e		e9cdfeffff		JMP runtime.raisebadsignal(SB)		

TEXT runtime.crash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func crash() {
  0x432ca0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432ca9		483b6110		CMPQ 0x10(CX), SP	
  0x432cad		7624			JBE 0x432cd3		
  0x432caf		4883ec10		SUBQ $0x10, SP		
  0x432cb3		48896c2408		MOVQ BP, 0x8(SP)	
  0x432cb8		488d6c2408		LEAQ 0x8(SP), BP	
	dieFromSignal(_SIGABRT)
  0x432cbd		c7042406000000		MOVL $0x6, 0(SP)		
  0x432cc4		e8f7fdffff		CALL runtime.dieFromSignal(SB)	
}
  0x432cc9		488b6c2408		MOVQ 0x8(SP), BP	
  0x432cce		4883c410		ADDQ $0x10, SP		
  0x432cd2		c3			RET			
func crash() {
  0x432cd3		e898180100		CALL runtime.morestack_noctxt(SB)	
  0x432cd8		ebc6			JMP runtime.crash(SB)			

TEXT runtime.noSignalStack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func noSignalStack(sig uint32) {
  0x432ce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432ce9		483b6110		CMPQ 0x10(CX), SP	
  0x432ced		7672			JBE 0x432d61		
  0x432cef		4883ec18		SUBQ $0x18, SP		
  0x432cf3		48896c2410		MOVQ BP, 0x10(SP)	
  0x432cf8		488d6c2410		LEAQ 0x10(SP), BP	
	println("signal", sig, "received on thread with no signal stack")
  0x432cfd		e8feedfeff		CALL runtime.printlock(SB)	
  0x432d02		488d0562720300		LEAQ 0x37262(IP), AX		
  0x432d09		48890424		MOVQ AX, 0(SP)			
  0x432d0d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x432d16		e825f7feff		CALL runtime.printstring(SB)	
func noSignalStack(sig uint32) {
  0x432d1b		8b442420		MOVL 0x20(SP), AX	
	println("signal", sig, "received on thread with no signal stack")
  0x432d1f		48890424		MOVQ AX, 0(SP)			
  0x432d23		e848f4feff		CALL runtime.printuint(SB)	
  0x432d28		488d05ffa50300		LEAQ 0x3a5ff(IP), AX		
  0x432d2f		48890424		MOVQ AX, 0(SP)			
  0x432d33		48c744240829000000	MOVQ $0x29, 0x8(SP)		
  0x432d3c		e8fff6feff		CALL runtime.printstring(SB)	
  0x432d41		e83aeefeff		CALL runtime.printunlock(SB)	
	throw("non-Go code disabled sigaltstack")
  0x432d46		488d05b69a0300		LEAQ 0x39ab6(IP), AX	
  0x432d4d		48890424		MOVQ AX, 0(SP)		
  0x432d51		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x432d5a		e871e4feff		CALL runtime.throw(SB)	
  0x432d5f		0f0b			UD2			
func noSignalStack(sig uint32) {
  0x432d61		e80a180100		CALL runtime.morestack_noctxt(SB)	
  0x432d66		e975ffffff		JMP runtime.noSignalStack(SB)		

TEXT runtime.sigNotOnStack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func sigNotOnStack(sig uint32) {
  0x432d70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432d79		483b6110		CMPQ 0x10(CX), SP	
  0x432d7d		7672			JBE 0x432df1		
  0x432d7f		4883ec18		SUBQ $0x18, SP		
  0x432d83		48896c2410		MOVQ BP, 0x10(SP)	
  0x432d88		488d6c2410		LEAQ 0x10(SP), BP	
	println("signal", sig, "received but handler not on signal stack")
  0x432d8d		e86eedfeff		CALL runtime.printlock(SB)	
  0x432d92		488d05d2710300		LEAQ 0x371d2(IP), AX		
  0x432d99		48890424		MOVQ AX, 0(SP)			
  0x432d9d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x432da6		e895f6feff		CALL runtime.printstring(SB)	
func sigNotOnStack(sig uint32) {
  0x432dab		8b442420		MOVL 0x20(SP), AX	
	println("signal", sig, "received but handler not on signal stack")
  0x432daf		48890424		MOVQ AX, 0(SP)			
  0x432db3		e8b8f3feff		CALL runtime.printuint(SB)	
  0x432db8		488d058ea60300		LEAQ 0x3a68e(IP), AX		
  0x432dbf		48890424		MOVQ AX, 0(SP)			
  0x432dc3		48c74424082a000000	MOVQ $0x2a, 0x8(SP)		
  0x432dcc		e86ff6feff		CALL runtime.printstring(SB)	
  0x432dd1		e8aaedfeff		CALL runtime.printunlock(SB)	
	throw("non-Go code set up signal handler without SA_ONSTACK flag")
  0x432dd6		488d0533af0300		LEAQ 0x3af33(IP), AX	
  0x432ddd		48890424		MOVQ AX, 0(SP)		
  0x432de1		48c744240839000000	MOVQ $0x39, 0x8(SP)	
  0x432dea		e8e1e3feff		CALL runtime.throw(SB)	
  0x432def		0f0b			UD2			
func sigNotOnStack(sig uint32) {
  0x432df1		e87a170100		CALL runtime.morestack_noctxt(SB)	
  0x432df6		e975ffffff		JMP runtime.sigNotOnStack(SB)		

TEXT runtime.signalDuringFork(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func signalDuringFork(sig uint32) {
  0x432e00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432e09		483b6110		CMPQ 0x10(CX), SP	
  0x432e0d		7672			JBE 0x432e81		
  0x432e0f		4883ec18		SUBQ $0x18, SP		
  0x432e13		48896c2410		MOVQ BP, 0x10(SP)	
  0x432e18		488d6c2410		LEAQ 0x10(SP), BP	
	println("signal", sig, "received during fork")
  0x432e1d		e8deecfeff		CALL runtime.printlock(SB)	
  0x432e22		488d0542710300		LEAQ 0x37142(IP), AX		
  0x432e29		48890424		MOVQ AX, 0(SP)			
  0x432e2d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x432e36		e805f6feff		CALL runtime.printstring(SB)	
func signalDuringFork(sig uint32) {
  0x432e3b		8b442420		MOVL 0x20(SP), AX	
	println("signal", sig, "received during fork")
  0x432e3f		48890424		MOVQ AX, 0(SP)			
  0x432e43		e828f3feff		CALL runtime.printuint(SB)	
  0x432e48		488d054b850300		LEAQ 0x3854b(IP), AX		
  0x432e4f		48890424		MOVQ AX, 0(SP)			
  0x432e53		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x432e5c		e8dff5feff		CALL runtime.printstring(SB)	
  0x432e61		e81aedfeff		CALL runtime.printunlock(SB)	
	throw("signal received during fork")
  0x432e66		488d0573900300		LEAQ 0x39073(IP), AX	
  0x432e6d		48890424		MOVQ AX, 0(SP)		
  0x432e71		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x432e7a		e851e3feff		CALL runtime.throw(SB)	
  0x432e7f		0f0b			UD2			
func signalDuringFork(sig uint32) {
  0x432e81		e8ea160100		CALL runtime.morestack_noctxt(SB)	
  0x432e86		e975ffffff		JMP runtime.signalDuringFork(SB)	

TEXT runtime.badsignal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func badsignal(sig uintptr, c *sigctxt) {
  0x432e90		4883ec18		SUBQ $0x18, SP		
  0x432e94		48896c2410		MOVQ BP, 0x10(SP)	
  0x432e99		488d6c2410		LEAQ 0x10(SP), BP	
	needm(0)
  0x432e9e		c6042400		MOVB $0x0, 0(SP)	
  0x432ea2		e82934ffff		CALL runtime.needm(SB)	
func badsignal(sig uintptr, c *sigctxt) {
  0x432ea7		488b442420		MOVQ 0x20(SP), AX	
	if !sigsend(uint32(sig)) {
  0x432eac		890424			MOVL AX, 0(SP)			
  0x432eaf		e80c070000		CALL runtime.sigsend(SB)	
  0x432eb4		0fb6442408		MOVZX 0x8(SP), AX		
  0x432eb9		84c0			TESTL AL, AL			
  0x432ebb		740f			JE 0x432ecc			
	dropm()
  0x432ebd		e8ce37ffff		CALL runtime.dropm(SB)	
}
  0x432ec2		488b6c2410		MOVQ 0x10(SP), BP	
  0x432ec7		4883c418		ADDQ $0x18, SP		
  0x432ecb		c3			RET			
  0x432ecc		488b442420		MOVQ 0x20(SP), AX	
		raisebadsignal(uint32(sig), c)
  0x432ed1		890424			MOVL AX, 0(SP)			
  0x432ed4		488b442428		MOVQ 0x28(SP), AX		
  0x432ed9		4889442408		MOVQ AX, 0x8(SP)		
  0x432ede		e87dfcffff		CALL runtime.raisebadsignal(SB)	
  0x432ee3		ebd8			JMP 0x432ebd			

TEXT runtime.sigfwdgo(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool {
  0x432ef0		4883ec38		SUBQ $0x38, SP		
  0x432ef4		48896c2430		MOVQ BP, 0x30(SP)	
  0x432ef9		488d6c2430		LEAQ 0x30(SP), BP	
  0x432efe		8b442440		MOVL 0x40(SP), AX	
	if sig >= uint32(len(sigtable)) {
  0x432f02		83f841			CMPL $0x41, AX		
  0x432f05		0f8393010000		JAE 0x43309e		
	fwdFn := atomic.Loaduintptr(&fwdSig[sig])
  0x432f0b		4883f841		CMPQ $0x41, AX			
  0x432f0f		0f8398010000		JAE 0x4330ad			
  0x432f15		488d0dc4110900		LEAQ runtime.fwdSig(SB), CX	
  0x432f1c		488d0cc1		LEAQ 0(CX)(AX*8), CX		
  0x432f20		488b09			MOVQ 0(CX), CX			
	flags := sigtable[sig].flags
  0x432f23		488d1440		LEAQ 0(AX)(AX*2), DX		
  0x432f27		488d1d52300700		LEAQ runtime.sigtable(SB), BX	
  0x432f2e		8b14d3			MOVL 0(BX)(DX*8), DX		
	if atomic.Load(&handlingSig[sig]) == 0 || !signalsOK {
  0x432f31		488d1d880e0900		LEAQ runtime.handlingSig(SB), BX	
  0x432f38		488d1c83		LEAQ 0(BX)(AX*4), BX			
  0x432f3c		8b1b			MOVL 0(BX), BX				
  0x432f3e		85db			TESTL BX, BX				
  0x432f40		0f8581000000		JNE 0x432fc7				
		if fwdFn == _SIG_IGN || (fwdFn == _SIG_DFL && flags&_SigIgn != 0) {
  0x432f46		4883f901		CMPQ $0x1, CX		
  0x432f4a		750f			JNE 0x432f5b		
			return true
  0x432f4c		c644245801		MOVB $0x1, 0x58(SP)	
  0x432f51		488b6c2430		MOVQ 0x30(SP), BP	
  0x432f56		4883c438		ADDQ $0x38, SP		
  0x432f5a		c3			RET			
		if fwdFn == _SIG_IGN || (fwdFn == _SIG_DFL && flags&_SigIgn != 0) {
  0x432f5b		4885c9			TESTQ CX, CX		
  0x432f5e		7509			JNE 0x432f69		
  0x432f60		0fbae208		BTL $0x8, DX		
  0x432f64		72e6			JB 0x432f4c		
  0x432f66		4885c9			TESTQ CX, CX		
		if fwdFn == _SIG_DFL {
  0x432f69		752c			JNE 0x432f97		
			setsig(sig, _SIG_DFL)
  0x432f6b		890424			MOVL AX, 0(SP)		
  0x432f6e		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x432f77		e884c7feff		CALL runtime.setsig(SB)	
  0x432f7c		8b442440		MOVL 0x40(SP), AX	
			dieFromSignal(sig)
  0x432f80		890424			MOVL AX, 0(SP)			
  0x432f83		e838fbffff		CALL runtime.dieFromSignal(SB)	
			return false
  0x432f88		c644245800		MOVB $0x0, 0x58(SP)	
  0x432f8d		488b6c2430		MOVQ 0x30(SP), BP	
  0x432f92		4883c438		ADDQ $0x38, SP		
  0x432f96		c3			RET			
		sigfwd(fwdFn, sig, info, ctx)
  0x432f97		48890c24		MOVQ CX, 0(SP)		
  0x432f9b		89442408		MOVL AX, 0x8(SP)	
  0x432f9f		488b442448		MOVQ 0x48(SP), AX	
  0x432fa4		4889442410		MOVQ AX, 0x10(SP)	
  0x432fa9		488b442450		MOVQ 0x50(SP), AX	
  0x432fae		4889442418		MOVQ AX, 0x18(SP)	
  0x432fb3		e8a84b0100		CALL runtime.sigfwd(SB)	
		return true
  0x432fb8		c644245801		MOVB $0x1, 0x58(SP)	
  0x432fbd		488b6c2430		MOVQ 0x30(SP), BP	
  0x432fc2		4883c438		ADDQ $0x38, SP		
  0x432fc6		c3			RET			
	if atomic.Load(&handlingSig[sig]) == 0 || !signalsOK {
  0x432fc7		0fb61de2080900		MOVZX runtime.signalsOK(SB), BX	
  0x432fce		84db			TESTL BL, BL			
  0x432fd0		0f8470ffffff		JE 0x432f46			
	if fwdFn == _SIG_DFL {
  0x432fd6		4885c9			TESTQ CX, CX		
  0x432fd9		0f84b0000000		JE 0x43308f		
	c := &sigctxt{info, ctx}
  0x432fdf		488b5c2448		MOVQ 0x48(SP), BX	
  0x432fe4		48895c2420		MOVQ BX, 0x20(SP)	
  0x432fe9		488b742450		MOVQ 0x50(SP), SI	
  0x432fee		4889742428		MOVQ SI, 0x28(SP)	
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x432ff3		488b7c2420		MOVQ 0x20(SP), DI	
  0x432ff8		48637f08		MOVSXD 0x8(DI), DI	
	if (c.sigcode() == _SI_USER || flags&_SigPanic == 0) && sig != _SIGPIPE {
  0x432ffc		4885ff			TESTQ DI, DI		
  0x432fff		757f			JNE 0x433080		
  0x433001		83f80d			CMPL $0xd, AX		
  0x433004		756b			JNE 0x433071		
	g := getg()
  0x433006		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	if g != nil && g.m != nil && g.m.curg != nil && !g.m.incgo {
  0x43300f		4885d2			TESTQ DX, DX		
  0x433012		7420			JE 0x433034		
  0x433014		488b5230		MOVQ 0x30(DX), DX	
  0x433018		4885d2			TESTQ DX, DX		
  0x43301b		7417			JE 0x433034		
  0x43301d		488bbac0000000		MOVQ 0xc0(DX), DI	
  0x433024		4885ff			TESTQ DI, DI		
  0x433027		740b			JE 0x433034		
  0x433029		0fb69219010000		MOVZX 0x119(DX), DX	
  0x433030		84d2			TESTL DL, DL		
  0x433032		742e			JE 0x433062		
	if fwdFn != _SIG_IGN {
  0x433034		4883f901		CMPQ $0x1, CX		
  0x433038		750f			JNE 0x433049		
	return true
  0x43303a		c644245801		MOVB $0x1, 0x58(SP)	
  0x43303f		488b6c2430		MOVQ 0x30(SP), BP	
  0x433044		4883c438		ADDQ $0x38, SP		
  0x433048		c3			RET			
		sigfwd(fwdFn, sig, info, ctx)
  0x433049		48890c24		MOVQ CX, 0(SP)		
  0x43304d		89442408		MOVL AX, 0x8(SP)	
  0x433051		48895c2410		MOVQ BX, 0x10(SP)	
  0x433056		4889742418		MOVQ SI, 0x18(SP)	
  0x43305b		e8004b0100		CALL runtime.sigfwd(SB)	
  0x433060		ebd8			JMP 0x43303a		
		return false
  0x433062		c644245800		MOVB $0x0, 0x58(SP)	
  0x433067		488b6c2430		MOVQ 0x30(SP), BP	
  0x43306c		4883c438		ADDQ $0x38, SP		
  0x433070		c3			RET			
		return false
  0x433071		c644245800		MOVB $0x0, 0x58(SP)	
  0x433076		488b6c2430		MOVQ 0x30(SP), BP	
  0x43307b		4883c438		ADDQ $0x38, SP		
  0x43307f		c3			RET			
	if (c.sigcode() == _SI_USER || flags&_SigPanic == 0) && sig != _SIGPIPE {
  0x433080		0fbae203		BTL $0x3, DX		
  0x433084		0f8377ffffff		JAE 0x433001		
  0x43308a		e977ffffff		JMP 0x433006		
		return false
  0x43308f		c644245800		MOVB $0x0, 0x58(SP)	
  0x433094		488b6c2430		MOVQ 0x30(SP), BP	
  0x433099		4883c438		ADDQ $0x38, SP		
  0x43309d		c3			RET			
		return false
  0x43309e		c644245800		MOVB $0x0, 0x58(SP)	
  0x4330a3		488b6c2430		MOVQ 0x30(SP), BP	
  0x4330a8		4883c438		ADDQ $0x38, SP		
  0x4330ac		c3			RET			
	fwdFn := atomic.Loaduintptr(&fwdSig[sig])
  0x4330ad		e88ec9feff		CALL runtime.panicindex(SB)	
  0x4330b2		0f0b			UD2				

TEXT runtime.msigsave(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func msigsave(mp *m) {
  0x4330c0		4883ec20		SUBQ $0x20, SP		
  0x4330c4		48896c2418		MOVQ BP, 0x18(SP)	
  0x4330c9		488d6c2418		LEAQ 0x18(SP), BP	
  0x4330ce		488b442428		MOVQ 0x28(SP), AX	
	sigprocmask(_SIG_SETMASK, nil, &mp.sigmask)
  0x4330d3		8400			TESTB AL, 0(AX)			
  0x4330d5		480580000000		ADDQ $0x80, AX			
  0x4330db		4889442410		MOVQ AX, 0x10(SP)		
  0x4330e0		c7042402000000		MOVL $0x2, 0(SP)		
  0x4330e7		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4330f0		e8cbc5feff		CALL runtime.sigprocmask(SB)	
}
  0x4330f5		488b6c2418		MOVQ 0x18(SP), BP	
  0x4330fa		4883c420		ADDQ $0x20, SP		
  0x4330fe		c3			RET			

TEXT runtime.msigrestore(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func msigrestore(sigmask sigset) {
  0x433100		4883ec20		SUBQ $0x20, SP		
  0x433104		48896c2418		MOVQ BP, 0x18(SP)	
  0x433109		488d6c2418		LEAQ 0x18(SP), BP	
	sigprocmask(_SIG_SETMASK, &sigmask, nil)
  0x43310e		c7042402000000		MOVL $0x2, 0(SP)		
  0x433115		488d442428		LEAQ 0x28(SP), AX		
  0x43311a		4889442408		MOVQ AX, 0x8(SP)		
  0x43311f		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x433128		e893c5feff		CALL runtime.sigprocmask(SB)	
}
  0x43312d		488b6c2418		MOVQ 0x18(SP), BP	
  0x433132		4883c420		ADDQ $0x20, SP		
  0x433136		c3			RET			

TEXT runtime.sigblock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func sigblock() {
  0x433140		4883ec20		SUBQ $0x20, SP		
  0x433144		48896c2418		MOVQ BP, 0x18(SP)	
  0x433149		488d6c2418		LEAQ 0x18(SP), BP	
	sigprocmask(_SIG_SETMASK, &sigset_all, nil)
  0x43314e		c7042402000000		MOVL $0x2, 0(SP)		
  0x433155		488d05f41e0700		LEAQ runtime.sigset_all(SB), AX	
  0x43315c		4889442408		MOVQ AX, 0x8(SP)		
  0x433161		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43316a		e851c5feff		CALL runtime.sigprocmask(SB)	
}
  0x43316f		488b6c2418		MOVQ 0x18(SP), BP	
  0x433174		4883c420		ADDQ $0x20, SP		
  0x433178		c3			RET			

TEXT runtime.unblocksig(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func unblocksig(sig uint32) {
  0x433180		4883ec28		SUBQ $0x28, SP		
  0x433184		48896c2420		MOVQ BP, 0x20(SP)	
  0x433189		488d6c2420		LEAQ 0x20(SP), BP	
	var set sigset
  0x43318e		48c744241800000000	MOVQ $0x0, 0x18(SP)	
func unblocksig(sig uint32) {
  0x433197		8b442430		MOVL 0x30(SP), AX	
	(*mask)[(i-1)/32] |= 1 << ((uint32(i) - 1) & 31)
  0x43319b		488d50ff		LEAQ -0x1(AX), DX	
  0x43319f		48c1fa3f		SARQ $0x3f, DX		
  0x4331a3		48c1ea3b		SHRQ $0x3b, DX		
  0x4331a7		488d5402ff		LEAQ -0x1(DX)(AX*1), DX	
  0x4331ac		48c1fa05		SARQ $0x5, DX		
  0x4331b0		4883fa02		CMPQ $0x2, DX		
  0x4331b4		733c			JAE 0x4331f2		
  0x4331b6		8b5c9418		MOVL 0x18(SP)(DX*4), BX	
  0x4331ba		8d48ff			LEAL -0x1(AX), CX	
  0x4331bd		b801000000		MOVL $0x1, AX		
  0x4331c2		d3e0			SHLL CL, AX		
  0x4331c4		09c3			ORL AX, BX		
  0x4331c6		488d442418		LEAQ 0x18(SP), AX	
  0x4331cb		891c90			MOVL BX, 0(AX)(DX*4)	
	sigprocmask(_SIG_UNBLOCK, &set, nil)
  0x4331ce		c7042401000000		MOVL $0x1, 0(SP)		
  0x4331d5		4889442408		MOVQ AX, 0x8(SP)		
  0x4331da		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4331e3		e8d8c4feff		CALL runtime.sigprocmask(SB)	
}
  0x4331e8		488b6c2420		MOVQ 0x20(SP), BP	
  0x4331ed		4883c428		ADDQ $0x28, SP		
  0x4331f1		c3			RET			
	(*mask)[(i-1)/32] |= 1 << ((uint32(i) - 1) & 31)
  0x4331f2		e849c8feff		CALL runtime.panicindex(SB)	
  0x4331f7		0f0b			UD2				

TEXT runtime.minitSignals(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func minitSignals() {
  0x433200		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x433209		483b6110		CMPQ 0x10(CX), SP	
  0x43320d		761f			JBE 0x43322e		
  0x43320f		4883ec08		SUBQ $0x8, SP		
  0x433213		48892c24		MOVQ BP, 0(SP)		
  0x433217		488d2c24		LEAQ 0(SP), BP		
	minitSignalStack()
  0x43321b		e820000000		CALL runtime.minitSignalStack(SB)	
	minitSignalMask()
  0x433220		e87b010000		CALL runtime.minitSignalMask(SB)	
}
  0x433225		488b2c24		MOVQ 0(SP), BP		
  0x433229		4883c408		ADDQ $0x8, SP		
  0x43322d		c3			RET			
func minitSignals() {
  0x43322e		e83d130100		CALL runtime.morestack_noctxt(SB)	
  0x433233		ebcb			JMP runtime.minitSignals(SB)		

TEXT runtime.minitSignalStack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func minitSignalStack() {
  0x433240		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x433249		483b6110		CMPQ 0x10(CX), SP	
  0x43324d		0f8641010000		JBE 0x433394		
  0x433253		4883ec38		SUBQ $0x38, SP		
  0x433257		48896c2430		MOVQ BP, 0x30(SP)	
  0x43325c		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x433261		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43326a		4889442410		MOVQ AX, 0x10(SP)	
	var st stackt
  0x43326f		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x433278		0f57c0			XORPS X0, X0		
  0x43327b		0f11442420		MOVUPS X0, 0x20(SP)	
	sigaltstack(nil, &st)
  0x433280		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x433288		488d4c2418		LEAQ 0x18(SP), CX		
  0x43328d		48894c2408		MOVQ CX, 0x8(SP)		
  0x433292		e8394c0100		CALL runtime.sigaltstack(SB)	
	if st.ss_flags&_SS_DISABLE != 0 {
  0x433297		8b442420		MOVL 0x20(SP), AX	
  0x43329b		0fbae001		BTL $0x1, AX		
  0x43329f		0f82c1000000		JB 0x433366		
  0x4332a5		488b442410		MOVQ 0x10(SP), AX	
		setGsignalStack(&st, &_g_.m.goSigStack)
  0x4332aa		488b4830		MOVQ 0x30(AX), CX	
  0x4332ae		8401			TESTB AL, 0(CX)		
  0x4332b0		8400			TESTB AL, 0(AX)		
  0x4332b2		488d5158		LEAQ 0x58(CX), DX	
	g := getg()
  0x4332b6		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
	if old != nil {
  0x4332bf		4885d2			TESTQ DX, DX		
  0x4332c2		744a			JE 0x43330e		
		old.stack = g.m.gsignal.stack
  0x4332c4		488b5330		MOVQ 0x30(BX), DX	
  0x4332c8		488b5250		MOVQ 0x50(DX), DX	
  0x4332cc		488b32			MOVQ 0(DX), SI		
  0x4332cf		488b5208		MOVQ 0x8(DX), DX	
  0x4332d3		48897158		MOVQ SI, 0x58(CX)	
  0x4332d7		48895160		MOVQ DX, 0x60(CX)	
		old.stackguard0 = g.m.gsignal.stackguard0
  0x4332db		488b5330		MOVQ 0x30(BX), DX	
  0x4332df		488b5250		MOVQ 0x50(DX), DX	
  0x4332e3		488b5210		MOVQ 0x10(DX), DX	
  0x4332e7		48895168		MOVQ DX, 0x68(CX)	
		old.stackguard1 = g.m.gsignal.stackguard1
  0x4332eb		488b5330		MOVQ 0x30(BX), DX	
  0x4332ef		488b5250		MOVQ 0x50(DX), DX	
  0x4332f3		488b5218		MOVQ 0x18(DX), DX	
  0x4332f7		48895170		MOVQ DX, 0x70(CX)	
		old.stktopsp = g.m.gsignal.stktopsp
  0x4332fb		488b5330		MOVQ 0x30(BX), DX	
  0x4332ff		488b5250		MOVQ 0x50(DX), DX	
  0x433303		488b9280000000		MOVQ 0x80(DX), DX	
  0x43330a		48895178		MOVQ DX, 0x78(CX)	
	g.m.gsignal.stack.lo = stsp
  0x43330e		488b4b30		MOVQ 0x30(BX), CX	
  0x433312		488b4950		MOVQ 0x50(CX), CX	
	stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x433316		488b542418		MOVQ 0x18(SP), DX	
	g.m.gsignal.stack.lo = stsp
  0x43331b		488911			MOVQ DX, 0(CX)		
	g.m.gsignal.stack.hi = stsp + st.ss_size
  0x43331e		488b4b30		MOVQ 0x30(BX), CX	
  0x433322		488b4950		MOVQ 0x50(CX), CX	
  0x433326		488b742428		MOVQ 0x28(SP), SI	
  0x43332b		4801d6			ADDQ DX, SI		
  0x43332e		48897108		MOVQ SI, 0x8(CX)	
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x433332		488b4b30		MOVQ 0x30(BX), CX	
  0x433336		488b4950		MOVQ 0x50(CX), CX	
  0x43333a		4881c270030000		ADDQ $0x370, DX		
  0x433341		48895110		MOVQ DX, 0x10(CX)	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x433345		488b4b30		MOVQ 0x30(BX), CX	
  0x433349		488b4950		MOVQ 0x50(CX), CX	
  0x43334d		48895118		MOVQ DX, 0x18(CX)	
		_g_.m.newSigstack = false
  0x433351		488b4030		MOVQ 0x30(AX), AX	
  0x433355		c6801701000000		MOVB $0x0, 0x117(AX)	
  0x43335c		488b6c2430		MOVQ 0x30(SP), BP	
  0x433361		4883c438		ADDQ $0x38, SP		
  0x433365		c3			RET			
  0x433366		488b442410		MOVQ 0x10(SP), AX	
		signalstack(&_g_.m.gsignal.stack)
  0x43336b		488b4830		MOVQ 0x30(AX), CX		
  0x43336f		488b5150		MOVQ 0x50(CX), DX		
  0x433373		8402			TESTB AL, 0(DX)			
  0x433375		8400			TESTB AL, 0(AX)			
  0x433377		8401			TESTB AL, 0(CX)			
  0x433379		48891424		MOVQ DX, 0(SP)			
  0x43337d		e8de010000		CALL runtime.signalstack(SB)	
  0x433382		488b442410		MOVQ 0x10(SP), AX		
		_g_.m.newSigstack = true
  0x433387		488b4030		MOVQ 0x30(AX), AX	
  0x43338b		c6801701000001		MOVB $0x1, 0x117(AX)	
  0x433392		ebc8			JMP 0x43335c		
func minitSignalStack() {
  0x433394		e8d7110100		CALL runtime.morestack_noctxt(SB)	
  0x433399		e9a2feffff		JMP runtime.minitSignalStack(SB)	

TEXT runtime.minitSignalMask(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func minitSignalMask() {
  0x4333a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4333a9		483b6110		CMPQ 0x10(CX), SP	
  0x4333ad		0f86f7000000		JBE 0x4334aa		
  0x4333b3		4883ec28		SUBQ $0x28, SP		
  0x4333b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4333bc		488d6c2420		LEAQ 0x20(SP), BP	
	nmask := getg().m.sigmask
  0x4333c1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4333ca		488b4030		MOVQ 0x30(AX), AX	
  0x4333ce		488b8080000000		MOVQ 0x80(AX), AX	
  0x4333d5		4889442418		MOVQ AX, 0x18(SP)	
  0x4333da		31c0			XORL AX, AX		
	for i := range sigtable {
  0x4333dc		eb03			JMP 0x4333e1		
  0x4333de		48ffc0			INCQ AX			
  0x4333e1		4883f841		CMPQ $0x41, AX		
  0x4333e5		0f8d88000000		JGE 0x433473		
	flags := sigtable[sig].flags
  0x4333eb		89c2			MOVL AX, DX			
  0x4333ed		4883fa41		CMPQ $0x41, DX			
  0x4333f1		0f83ac000000		JAE 0x4334a3			
  0x4333f7		488d1452		LEAQ 0(DX)(DX*2), DX		
  0x4333fb		488d1d7e2b0700		LEAQ runtime.sigtable(SB), BX	
  0x433402		8b14d3			MOVL 0(BX)(DX*8), DX		
	if flags&_SigUnblock != 0 {
  0x433405		0fbae207		BTL $0x7, DX		
  0x433409		7337			JAE 0x433442		
	(*mask)[(i-1)/32] &^= 1 << ((uint32(i) - 1) & 31)
  0x43340b		488d50ff		LEAQ -0x1(AX), DX	
  0x43340f		48c1fa3f		SARQ $0x3f, DX		
  0x433413		48c1ea3b		SHRQ $0x3b, DX		
  0x433417		488d5402ff		LEAQ -0x1(DX)(AX*1), DX	
  0x43341c		48c1fa05		SARQ $0x5, DX		
  0x433420		4883fa02		CMPQ $0x2, DX		
  0x433424		7376			JAE 0x43349c		
  0x433426		8b749418		MOVL 0x18(SP)(DX*4), SI	
  0x43342a		8d48ff			LEAL -0x1(AX), CX	
  0x43342d		bf01000000		MOVL $0x1, DI		
  0x433432		d3e7			SHLL CL, DI		
  0x433434		f7d7			NOTL DI			
  0x433436		21f7			ANDL SI, DI		
  0x433438		488d742418		LEAQ 0x18(SP), SI	
  0x43343d		893c96			MOVL DI, 0(SI)(DX*4)	
	for i := range sigtable {
  0x433440		eb9c			JMP 0x4333de		
	if isarchive || islibrary {
  0x433442		0fb63562040900		MOVZX runtime.isarchive(SB), SI	
  0x433449		4084f6			TESTL SI, SI			
  0x43344c		7407			JE 0x433455			
  0x43344e		488d742418		LEAQ 0x18(SP), SI		
		if !blockableSig(uint32(i)) {
  0x433453		eb89			JMP 0x4333de		
	if isarchive || islibrary {
  0x433455		0fb63551040900		MOVZX runtime.islibrary(SB), SI	
  0x43345c		4084f6			TESTL SI, SI			
  0x43345f		75ed			JNE 0x43344e			
	return flags&(_SigKill|_SigThrow) == 0
  0x433461		f7c206000000		TESTL $0x6, DX		
		if !blockableSig(uint32(i)) {
  0x433467		75a2			JNE 0x43340b		
  0x433469		488d742418		LEAQ 0x18(SP), SI	
  0x43346e		e96bffffff		JMP 0x4333de		
	sigprocmask(_SIG_SETMASK, &nmask, nil)
  0x433473		c7042402000000		MOVL $0x2, 0(SP)		
  0x43347a		488d442418		LEAQ 0x18(SP), AX		
  0x43347f		4889442408		MOVQ AX, 0x8(SP)		
  0x433484		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43348d		e82ec2feff		CALL runtime.sigprocmask(SB)	
}
  0x433492		488b6c2420		MOVQ 0x20(SP), BP	
  0x433497		4883c428		ADDQ $0x28, SP		
  0x43349b		c3			RET			
	(*mask)[(i-1)/32] &^= 1 << ((uint32(i) - 1) & 31)
  0x43349c		e89fc5feff		CALL runtime.panicindex(SB)	
  0x4334a1		0f0b			UD2				
	flags := sigtable[sig].flags
  0x4334a3		e898c5feff		CALL runtime.panicindex(SB)	
  0x4334a8		0f0b			UD2				
func minitSignalMask() {
  0x4334aa		e8c1100100		CALL runtime.morestack_noctxt(SB)	
  0x4334af		e9ecfeffff		JMP runtime.minitSignalMask(SB)		

TEXT runtime.unminitSignals(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func unminitSignals() {
  0x4334c0		4883ec30		SUBQ $0x30, SP		
  0x4334c4		48896c2428		MOVQ BP, 0x28(SP)	
  0x4334c9		488d6c2428		LEAQ 0x28(SP), BP	
	if getg().m.newSigstack {
  0x4334ce		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4334d7		488b4030		MOVQ 0x30(AX), AX	
  0x4334db		0fb68817010000		MOVZX 0x117(AX), CX	
  0x4334e2		84c9			TESTL CL, CL		
  0x4334e4		753e			JNE 0x433524		
	gp := getg().m.gsignal
  0x4334e6		488b4850		MOVQ 0x50(AX), CX	
		restoreGsignalStack(&getg().m.goSigStack)
  0x4334ea		488d5058		LEAQ 0x58(AX), DX	
	gp.stack = st.stack
  0x4334ee		8402			TESTB AL, 0(DX)		
  0x4334f0		488b5060		MOVQ 0x60(AX), DX	
  0x4334f4		488b5858		MOVQ 0x58(AX), BX	
  0x4334f8		488919			MOVQ BX, 0(CX)		
  0x4334fb		48895108		MOVQ DX, 0x8(CX)	
	gp.stackguard0 = st.stackguard0
  0x4334ff		488b5068		MOVQ 0x68(AX), DX	
  0x433503		48895110		MOVQ DX, 0x10(CX)	
	gp.stackguard1 = st.stackguard1
  0x433507		488b5070		MOVQ 0x70(AX), DX	
  0x43350b		48895118		MOVQ DX, 0x18(CX)	
	gp.stktopsp = st.stktopsp
  0x43350f		488b4078		MOVQ 0x78(AX), AX	
  0x433513		48898180000000		MOVQ AX, 0x80(CX)	
  0x43351a		488b6c2428		MOVQ 0x28(SP), BP	
  0x43351f		4883c430		ADDQ $0x30, SP		
  0x433523		c3			RET			
		st := stackt{ss_flags: _SS_DISABLE}
  0x433524		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x43352d		0f57c0			XORPS X0, X0		
  0x433530		0f11442418		MOVUPS X0, 0x18(SP)	
  0x433535		c744241802000000	MOVL $0x2, 0x18(SP)	
		sigaltstack(&st, nil)
  0x43353d		488d442410		LEAQ 0x10(SP), AX		
  0x433542		48890424		MOVQ AX, 0(SP)			
  0x433546		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x43354f		e87c490100		CALL runtime.sigaltstack(SB)	
  0x433554		ebc4			JMP 0x43351a			

TEXT runtime.signalstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/signal_unix.go
func signalstack(s *stack) {
  0x433560		4883ec30		SUBQ $0x30, SP		
  0x433564		48896c2428		MOVQ BP, 0x28(SP)	
  0x433569		488d6c2428		LEAQ 0x28(SP), BP	
	st := stackt{ss_size: s.hi - s.lo}
  0x43356e		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x433577		0f57c0			XORPS X0, X0		
  0x43357a		0f11442418		MOVUPS X0, 0x18(SP)	
func signalstack(s *stack) {
  0x43357f		488b442438		MOVQ 0x38(SP), AX	
	st := stackt{ss_size: s.hi - s.lo}
  0x433584		488b4808		MOVQ 0x8(AX), CX	
  0x433588		482b08			SUBQ 0(AX), CX		
  0x43358b		48894c2420		MOVQ CX, 0x20(SP)	
	*(*uintptr)(unsafe.Pointer(&s.ss_sp)) = sp
  0x433590		488d4c2410		LEAQ 0x10(SP), CX	
  0x433595		8401			TESTB AL, 0(CX)		
	setSignalstackSP(&st, s.lo)
  0x433597		488b00			MOVQ 0(AX), AX		
	*(*uintptr)(unsafe.Pointer(&s.ss_sp)) = sp
  0x43359a		4889442410		MOVQ AX, 0x10(SP)	
	sigaltstack(&st, nil)
  0x43359f		488d442410		LEAQ 0x10(SP), AX		
  0x4335a4		48890424		MOVQ AX, 0(SP)			
  0x4335a8		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4335b1		e81a490100		CALL runtime.sigaltstack(SB)	
}
  0x4335b6		488b6c2428		MOVQ 0x28(SP), BP	
  0x4335bb		4883c430		ADDQ $0x30, SP		
  0x4335bf		c3			RET			

TEXT runtime.sigsend(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sigqueue.go
func sigsend(s uint32) bool {
  0x4335c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4335c9		483b6110		CMPQ 0x10(CX), SP	
  0x4335cd		0f867f010000		JBE 0x433752		
  0x4335d3		4883ec18		SUBQ $0x18, SP		
  0x4335d7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4335dc		488d6c2410		LEAQ 0x10(SP), BP	
	if !sig.inuse || s >= uint32(32*len(sig.wanted)) {
  0x4335e1		0fb61598050900		MOVZX runtime.sig+64(SB), DX	
  0x4335e8		84d2			TESTL DL, DL			
  0x4335ea		0f8431010000		JE 0x433721			
  0x4335f0		8b4c2420		MOVL 0x20(SP), CX		
  0x4335f4		83f960			CMPL $0x60, CX			
  0x4335f7		0f8324010000		JAE 0x433721			
	atomic.Xadd(&sig.delivering, 1)
  0x4335fd		ba01000000		MOVL $0x1, DX			
  0x433602		488d1d73050900		LEAQ runtime.sig+60(SB), BX	
  0x433609		f00fc113		LOCK XADDL DX, 0(BX)		
  0x43360d		89ca			MOVL CX, DX			
	if w := atomic.Load(&sig.wanted[s/32]); w&bit == 0 {
  0x43360f		c1e905			SHRL $0x5, CX			
  0x433612		4883f903		CMPQ $0x3, CX			
  0x433616		0f832f010000		JAE 0x43374b			
  0x43361c		488d351d050900		LEAQ runtime.sig(SB), SI	
  0x433623		488d7c8e14		LEAQ 0x14(SI)(CX*4), DI		
  0x433628		8b3f			MOVL 0(DI), DI			
  0x43362a		89c8			MOVL CX, AX			
  0x43362c		89d1			MOVL DX, CX			
	bit := uint32(1) << uint(s&31)
  0x43362e		41b801000000		MOVL $0x1, R8		
  0x433634		41d3e0			SHLL CL, R8		
	if w := atomic.Load(&sig.wanted[s/32]); w&bit == 0 {
  0x433637		0fa3cf			BTL CX, DI		
  0x43363a		0f83c9000000		JAE 0x433709		
  0x433640		eb03			JMP 0x433645		
  0x433642		4489d8			MOVL R11, AX		
		mask := sig.mask[s/32]
  0x433645		8b7c8608		MOVL 0x8(SI)(AX*4), DI	
  0x433649		4c8d4c8608		LEAQ 0x8(SI)(AX*4), R9	
		if mask&bit != 0 {
  0x43364e		0fa3cf			BTL CX, DI		
  0x433651		0f829a000000		JB 0x4336f1		
  0x433657		4189fa			MOVL DI, R10		
		if atomic.Cas(&sig.mask[s/32], mask, mask|bit) {
  0x43365a		4409c7			ORL R8, DI		
  0x43365d		4189c3			MOVL AX, R11		
  0x433660		4489d0			MOVL R10, AX		
  0x433663		f0410fb139		LOCK CMPXCHGL DI, 0(R9)	
  0x433668		400f94c7		SETE DI			
  0x43366c		4084ff			TESTL DI, DI		
  0x43366f		74d1			JE 0x433642		
		switch atomic.Load(&sig.state) {
  0x433671		8b0d01050900		MOVL runtime.sig+56(SB), CX	
		case sigIdle:
  0x433677		85c9			TESTL CX, CX		
  0x433679		7531			JNE 0x4336ac		
			if atomic.Cas(&sig.state, sigIdle, sigSending) {
  0x43367b		31c0			XORL AX, AX			
  0x43367d		488d0df4040900		LEAQ runtime.sig+56(SB), CX	
  0x433684		ba02000000		MOVL $0x2, DX			
  0x433689		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x43368d		0f94c1			SETE CL				
  0x433690		84c9			TESTL CL, CL			
  0x433692		74dd			JE 0x433671			
	atomic.Xadd(&sig.delivering, -1)
  0x433694		b8ffffffff		MOVL $-0x1, AX		
  0x433699		f00fc103		LOCK XADDL AX, 0(BX)	
	return true
  0x43369d		c644242801		MOVB $0x1, 0x28(SP)	
  0x4336a2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4336a7		4883c418		ADDQ $0x18, SP		
  0x4336ab		c3			RET			
		case sigReceiving:
  0x4336ac		83f901			CMPL $0x1, CX		
  0x4336af		7539			JNE 0x4336ea		
			if atomic.Cas(&sig.state, sigReceiving, sigIdle) {
  0x4336b1		b801000000		MOVL $0x1, AX			
  0x4336b6		488d0dbb040900		LEAQ runtime.sig+56(SB), CX	
  0x4336bd		31d2			XORL DX, DX			
  0x4336bf		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x4336c3		0f94c1			SETE CL				
  0x4336c6		84c9			TESTL CL, CL			
  0x4336c8		7507			JNE 0x4336d1			
  0x4336ca		ba02000000		MOVL $0x2, DX			
		switch atomic.Load(&sig.state) {
  0x4336cf		eba0			JMP 0x433671		
				notewakeup(&sig.note)
  0x4336d1		488d0568040900		LEAQ runtime.sig(SB), AX	
  0x4336d8		48890424		MOVQ AX, 0(SP)			
  0x4336dc		e8af60fdff		CALL runtime.notewakeup(SB)	
  0x4336e1		488d1d94040900		LEAQ runtime.sig+60(SB), BX	
				break Send
  0x4336e8		ebaa			JMP 0x433694		
		case sigSending:
  0x4336ea		83f902			CMPL $0x2, CX		
  0x4336ed		74a5			JE 0x433694		
  0x4336ef		eb3f			JMP 0x433730		
			atomic.Xadd(&sig.delivering, -1)
  0x4336f1		b8ffffffff		MOVL $-0x1, AX		
  0x4336f6		f00fc103		LOCK XADDL AX, 0(BX)	
			return true // signal already in queue
  0x4336fa		c644242801		MOVB $0x1, 0x28(SP)	
  0x4336ff		488b6c2410		MOVQ 0x10(SP), BP	
  0x433704		4883c418		ADDQ $0x18, SP		
  0x433708		c3			RET			
		atomic.Xadd(&sig.delivering, -1)
  0x433709		b8ffffffff		MOVL $-0x1, AX		
  0x43370e		f00fc103		LOCK XADDL AX, 0(BX)	
		return false
  0x433712		c644242800		MOVB $0x0, 0x28(SP)	
  0x433717		488b6c2410		MOVQ 0x10(SP), BP	
  0x43371c		4883c418		ADDQ $0x18, SP		
  0x433720		c3			RET			
		return false
  0x433721		c644242800		MOVB $0x0, 0x28(SP)	
  0x433726		488b6c2410		MOVQ 0x10(SP), BP	
  0x43372b		4883c418		ADDQ $0x18, SP		
  0x43372f		c3			RET			
			throw("sigsend: inconsistent state")
  0x433730		488d05c4870300		LEAQ 0x387c4(IP), AX	
  0x433737		48890424		MOVQ AX, 0(SP)		
  0x43373b		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x433744		e887dafeff		CALL runtime.throw(SB)	
  0x433749		0f0b			UD2			
	if w := atomic.Load(&sig.wanted[s/32]); w&bit == 0 {
  0x43374b		e8f0c2feff		CALL runtime.panicindex(SB)	
  0x433750		0f0b			UD2				
func sigsend(s uint32) bool {
  0x433752		e8190e0100		CALL runtime.morestack_noctxt(SB)	
  0x433757		e964feffff		JMP runtime.sigsend(SB)			

TEXT runtime.makeslice(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/slice.go
func makeslice(et *_type, len, cap int) slice {
  0x433760		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x433769		483b6110		CMPQ 0x10(CX), SP	
  0x43376d		0f86df000000		JBE 0x433852		
  0x433773		4883ec28		SUBQ $0x28, SP		
  0x433777		48896c2420		MOVQ BP, 0x20(SP)	
  0x43377c		488d6c2420		LEAQ 0x20(SP), BP	
  0x433781		488b4c2430		MOVQ 0x30(SP), CX	
	maxElements := maxSliceCap(et.size)
  0x433786		488b11			MOVQ 0(CX), DX		
	if elemsize < uintptr(len(maxElems)) {
  0x433789		4883fa21		CMPQ $0x21, DX		
  0x43378d		7370			JAE 0x4337ff		
		return maxElems[elemsize]
  0x43378f		488d05ea1d0700		LEAQ runtime.maxElems(SB), AX	
  0x433796		488b04d0		MOVQ 0(AX)(DX*8), AX		
	maxElements := maxSliceCap(et.size)
  0x43379a		488b5c2438		MOVQ 0x38(SP), BX	
	if len < 0 || uintptr(len) > maxElements {
  0x43379f		4885db			TESTQ BX, BX		
  0x4337a2		0f8c8c000000		JL 0x433834		
  0x4337a8		4839c3			CMPQ AX, BX		
  0x4337ab		0f8783000000		JA 0x433834		
  0x4337b1		488b742440		MOVQ 0x40(SP), SI	
	if cap < len || uintptr(cap) > maxElements {
  0x4337b6		4839de			CMPQ BX, SI		
  0x4337b9		7c5b			JL 0x433816		
  0x4337bb		4839c6			CMPQ AX, SI		
  0x4337be		7756			JA 0x433816		
	p := mallocgc(et.size*uintptr(cap), et, true)
  0x4337c0		480fafd6		IMULQ SI, DX			
  0x4337c4		48891424		MOVQ DX, 0(SP)			
  0x4337c8		48894c2408		MOVQ CX, 0x8(SP)		
  0x4337cd		c644241001		MOVB $0x1, 0x10(SP)		
  0x4337d2		e8396efdff		CALL runtime.mallocgc(SB)	
  0x4337d7		488b442418		MOVQ 0x18(SP), AX		
	return slice{p, len, cap}
  0x4337dc		4889442448		MOVQ AX, 0x48(SP)	
  0x4337e1		488b442438		MOVQ 0x38(SP), AX	
  0x4337e6		4889442450		MOVQ AX, 0x50(SP)	
  0x4337eb		488b442440		MOVQ 0x40(SP), AX	
  0x4337f0		4889442458		MOVQ AX, 0x58(SP)	
  0x4337f5		488b6c2420		MOVQ 0x20(SP), BP	
  0x4337fa		4883c428		ADDQ $0x28, SP		
  0x4337fe		c3			RET			
	return _MaxMem / elemsize
  0x4337ff		48b8ffffffff7f000000	MOVQ $0x7fffffffff, AX	
  0x433809		4889d3			MOVQ DX, BX		
  0x43380c		31d2			XORL DX, DX		
  0x43380e		48f7f3			DIVQ BX			
  0x433811		4889da			MOVQ BX, DX		
	maxElements := maxSliceCap(et.size)
  0x433814		eb84			JMP 0x43379a		
		panic(errorString("makeslice: cap out of range"))
  0x433816		488d05a3760200		LEAQ 0x276a3(IP), AX			
  0x43381d		48890424		MOVQ AX, 0(SP)				
  0x433821		488d0598150400		LEAQ runtime.statictmp_27(SB), AX	
  0x433828		4889442408		MOVQ AX, 0x8(SP)			
  0x43382d		e8fed1feff		CALL runtime.gopanic(SB)		
  0x433832		0f0b			UD2					
		panic(errorString("makeslice: len out of range"))
  0x433834		488d0585760200		LEAQ 0x27685(IP), AX			
  0x43383b		48890424		MOVQ AX, 0(SP)				
  0x43383f		488d056a150400		LEAQ runtime.statictmp_26(SB), AX	
  0x433846		4889442408		MOVQ AX, 0x8(SP)			
  0x43384b		e8e0d1feff		CALL runtime.gopanic(SB)		
  0x433850		0f0b			UD2					
func makeslice(et *_type, len, cap int) slice {
  0x433852		e8190d0100		CALL runtime.morestack_noctxt(SB)	
  0x433857		e904ffffff		JMP runtime.makeslice(SB)		

TEXT runtime.growslice(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/slice.go
func growslice(et *_type, old slice, cap int) slice {
  0x433860		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x433869		483b6110		CMPQ 0x10(CX), SP	
  0x43386d		0f86c0050000		JBE 0x433e33		
  0x433873		4883ec60		SUBQ $0x60, SP		
  0x433877		48896c2458		MOVQ BP, 0x58(SP)	
  0x43387c		488d6c2458		LEAQ 0x58(SP), BP	
  0x433881		488b4c2468		MOVQ 0x68(SP), CX	
	if et.size == 0 {
  0x433886		488b11			MOVQ 0(CX), DX		
  0x433889		4885d2			TESTQ DX, DX		
  0x43388c		0f84f8040000		JE 0x433d8a		
  0x433892		488b9c2480000000	MOVQ 0x80(SP), BX	
	doublecap := newcap + newcap
  0x43389a		488d341b		LEAQ 0(BX)(BX*1), SI	
  0x43389e		488bbc2488000000	MOVQ 0x88(SP), DI	
	if cap > doublecap {
  0x4338a6		4839f7			CMPQ SI, DI		
  0x4338a9		0f8fcb040000		JG 0x433d7a		
  0x4338af		4c8b442478		MOVQ 0x78(SP), R8	
		if old.len < 1024 {
  0x4338b4		4981f800040000		CMPQ $0x400, R8		
  0x4338bb		0f8cab040000		JL 0x433d6c		
  0x4338c1		4889d8			MOVQ BX, AX		
			for 0 < newcap && newcap < cap {
  0x4338c4		eb17			JMP 0x4338dd		
  0x4338c6		4889de			MOVQ BX, SI		
				newcap += newcap / 4
  0x4338c9		48c1fb3f		SARQ $0x3f, BX		
  0x4338cd		48c1eb3e		SHRQ $0x3e, BX		
  0x4338d1		4c8d0c33		LEAQ 0(BX)(SI*1), R9	
  0x4338d5		49c1f902		SARQ $0x2, R9		
  0x4338d9		498d1c31		LEAQ 0(R9)(SI*1), BX	
			for 0 < newcap && newcap < cap {
  0x4338dd		4885db			TESTQ BX, BX		
  0x4338e0		7e08			JLE 0x4338ea		
  0x4338e2		4839fb			CMPQ DI, BX		
  0x4338e5		7cdf			JL 0x4338c6		
  0x4338e7		4885db			TESTQ BX, BX		
			if newcap <= 0 {
  0x4338ea		0f8f6c040000		JG 0x433d5c		
  0x4338f0		4889fb			MOVQ DI, BX		
	case 1:
  0x4338f3		4883fa01		CMPQ $0x1, DX		
  0x4338f7		0f8539020000		JNE 0x433b36		
	if size < _MaxSmallSize {
  0x4338fd		4881ff00800000		CMPQ $0x8000, DI	
  0x433904		0f8305020000		JAE 0x433b0f		
		if size <= smallSizeMax-8 {
  0x43390a		4881fff8030000		CMPQ $0x3f8, DI		
  0x433911		0f87bb010000		JA 0x433ad2		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x433917		488d5707		LEAQ 0x7(DI), DX			
  0x43391b		48c1ea03		SHRQ $0x3, DX				
  0x43391f		4881fa81000000		CMPQ $0x81, DX				
  0x433926		0f83e2040000		JAE 0x433e0e				
  0x43392c		488d35ed170700		LEAQ runtime.size_to_class8(SB), SI	
  0x433933		0fb61432		MOVZX 0(DX)(SI*1), DX			
  0x433937		4883fa43		CMPQ $0x43, DX				
  0x43393b		0f83cd040000		JAE 0x433e0e				
  0x433941		488d3578180700		LEAQ runtime.class_to_size(SB), SI	
  0x433948		0fb71456		MOVZX 0(SI)(DX*2), DX			
		overflow = uintptr(newcap) > _MaxMem
  0x43394c		48beffffffff7f000000	MOVQ $0x7fffffffff, SI	
  0x433956		4839f7			CMPQ SI, DI		
  0x433959		400f97c7		SETA DI			
  0x43395d		4989d9			MOVQ BX, R9		
  0x433960		4d89c2			MOVQ R8, R10		
  0x433963		4989d3			MOVQ DX, R11		
	if cap < old.cap || overflow || capmem > _MaxMem {
  0x433966		4939c1			CMPQ AX, R9		
  0x433969		0f8c5e040000		JL 0x433dcd		
  0x43396f		4084ff			TESTL DI, DI		
  0x433972		0f8555040000		JNE 0x433dcd		
  0x433978		4839f2			CMPQ SI, DX		
  0x43397b		0f874c040000		JA 0x433dcd		
  0x433981		4c89442438		MOVQ R8, 0x38(SP)	
  0x433986		4c895c2430		MOVQ R11, 0x30(SP)	
	if et.kind&kindNoPointers != 0 {
  0x43398b		0fb64117		MOVZX 0x17(CX), AX	
  0x43398f		a880			TESTL $0x80, AL		
  0x433991		0f85c5000000		JNE 0x433a5c		
		p = mallocgc(capmem, et, true)
  0x433997		48891424		MOVQ DX, 0(SP)			
  0x43399b		48894c2408		MOVQ CX, 0x8(SP)		
  0x4339a0		c644241001		MOVB $0x1, 0x10(SP)		
  0x4339a5		e8666cfdff		CALL runtime.mallocgc(SB)	
  0x4339aa		488b442418		MOVQ 0x18(SP), AX		
  0x4339af		4889442448		MOVQ AX, 0x48(SP)		
		if !writeBarrier.enabled {
  0x4339b4		0fb60d55000900		MOVZX runtime.writeBarrier(SB), CX	
  0x4339bb		84c9			TESTL CL, CL				
  0x4339bd		7479			JE 0x433a38				
  0x4339bf		31c9			XORL CX, CX				
			for i := uintptr(0); i < lenmem; i += et.size {
  0x4339c1		eb3f			JMP 0x433a02		
  0x4339c3		48894c2420		MOVQ CX, 0x20(SP)	
  0x4339c8		488b542468		MOVQ 0x68(SP), DX	
				typedmemmove(et, add(p, i), add(old.array, i))
  0x4339cd		48891424		MOVQ DX, 0(SP)		
	return unsafe.Pointer(uintptr(p) + x)
  0x4339d1		488d1c01		LEAQ 0(CX)(AX*1), BX	
				typedmemmove(et, add(p, i), add(old.array, i))
  0x4339d5		48895c2408		MOVQ BX, 0x8(SP)	
  0x4339da		488b5c2470		MOVQ 0x70(SP), BX	
	return unsafe.Pointer(uintptr(p) + x)
  0x4339df		488d3419		LEAQ 0(CX)(BX*1), SI	
				typedmemmove(et, add(p, i), add(old.array, i))
  0x4339e3		4889742410		MOVQ SI, 0x10(SP)		
  0x4339e8		e8a380fdff		CALL runtime.typedmemmove(SB)	
  0x4339ed		488b442468		MOVQ 0x68(SP), AX		
			for i := uintptr(0); i < lenmem; i += et.size {
  0x4339f2		488b08			MOVQ 0(AX), CX		
  0x4339f5		488b542420		MOVQ 0x20(SP), DX	
  0x4339fa		4801d1			ADDQ DX, CX		
  0x4339fd		488b442448		MOVQ 0x48(SP), AX	
  0x433a02		488b542438		MOVQ 0x38(SP), DX	
  0x433a07		4839d1			CMPQ DX, CX		
  0x433a0a		72b7			JB 0x4339c3		
	return slice{p, old.len, newcap}
  0x433a0c		4889842490000000	MOVQ AX, 0x90(SP)	
  0x433a14		488b442478		MOVQ 0x78(SP), AX	
  0x433a19		4889842498000000	MOVQ AX, 0x98(SP)	
  0x433a21		488b442430		MOVQ 0x30(SP), AX	
  0x433a26		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x433a2e		488b6c2458		MOVQ 0x58(SP), BP	
  0x433a33		4883c460		ADDQ $0x60, SP		
  0x433a37		c3			RET			
			memmove(p, old.array, lenmem)
  0x433a38		48890424		MOVQ AX, 0(SP)			
  0x433a3c		488b4c2470		MOVQ 0x70(SP), CX		
  0x433a41		48894c2408		MOVQ CX, 0x8(SP)		
  0x433a46		488b4c2438		MOVQ 0x38(SP), CX		
  0x433a4b		48894c2410		MOVQ CX, 0x10(SP)		
  0x433a50		e8ab360100		CALL runtime.memmove(SB)	
  0x433a55		488b442448		MOVQ 0x48(SP), AX		
  0x433a5a		ebb0			JMP 0x433a0c			
  0x433a5c		48895c2428		MOVQ BX, 0x28(SP)		
  0x433a61		4889542440		MOVQ DX, 0x40(SP)		
		p = mallocgc(capmem, nil, false)
  0x433a66		48891424		MOVQ DX, 0(SP)			
  0x433a6a		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x433a73		c644241000		MOVB $0x0, 0x10(SP)		
  0x433a78		e8936bfdff		CALL runtime.mallocgc(SB)	
  0x433a7d		488b442418		MOVQ 0x18(SP), AX		
  0x433a82		4889442450		MOVQ AX, 0x50(SP)		
		memmove(p, old.array, lenmem)
  0x433a87		48890424		MOVQ AX, 0(SP)			
  0x433a8b		488b4c2470		MOVQ 0x70(SP), CX		
  0x433a90		48894c2408		MOVQ CX, 0x8(SP)		
  0x433a95		488b4c2438		MOVQ 0x38(SP), CX		
  0x433a9a		48894c2410		MOVQ CX, 0x10(SP)		
  0x433a9f		e85c360100		CALL runtime.memmove(SB)	
  0x433aa4		488b442450		MOVQ 0x50(SP), AX		
  0x433aa9		488b4c2428		MOVQ 0x28(SP), CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x433aae		488d1401		LEAQ 0(CX)(AX*1), DX	
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
  0x433ab2		48891424		MOVQ DX, 0(SP)				
  0x433ab6		488b542440		MOVQ 0x40(SP), DX			
  0x433abb		4829ca			SUBQ CX, DX				
  0x433abe		4889542408		MOVQ DX, 0x8(SP)			
  0x433ac3		e8a8330100		CALL runtime.memclrNoHeapPointers(SB)	
  0x433ac8		488b442450		MOVQ 0x50(SP), AX			
  0x433acd		e93affffff		JMP 0x433a0c				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x433ad2		488d977ffcffff		LEAQ 0xfffffc7f(DI), DX			
  0x433ad9		48c1ea07		SHRQ $0x7, DX				
  0x433add		4881faf9000000		CMPQ $0xf9, DX				
  0x433ae4		0f831d030000		JAE 0x433e07				
  0x433aea		488d356f170700		LEAQ runtime.size_to_class128(SB), SI	
  0x433af1		0fb61432		MOVZX 0(DX)(SI*1), DX			
  0x433af5		4883fa43		CMPQ $0x43, DX				
  0x433af9		0f8308030000		JAE 0x433e07				
  0x433aff		488d35ba160700		LEAQ runtime.class_to_size(SB), SI	
  0x433b06		0fb71456		MOVZX 0(SI)(DX*2), DX			
		capmem = roundupsize(uintptr(newcap))
  0x433b0a		e93dfeffff		JMP 0x43394c		
	if size+_PageSize < size {
  0x433b0f		488d9700200000		LEAQ 0x2000(DI), DX	
  0x433b16		4839fa			CMPQ DI, DX		
  0x433b19		7308			JAE 0x433b23		
  0x433b1b		4889fa			MOVQ DI, DX		
		capmem = roundupsize(uintptr(newcap))
  0x433b1e		e929feffff		JMP 0x43394c		
	return (n + a - 1) &^ (a - 1)
  0x433b23		488d97ff1f0000		LEAQ 0x1fff(DI), DX	
  0x433b2a		4881e200e0ffff		ANDQ $-0x2000, DX	
		capmem = roundupsize(uintptr(newcap))
  0x433b31		e916feffff		JMP 0x43394c		
	case ptrSize:
  0x433b36		4883fa08		CMPQ $0x8, DX		
  0x433b3a		0f85eb000000		JNE 0x433c2b		
  0x433b40		4889fa			MOVQ DI, DX		
		capmem = roundupsize(uintptr(newcap) * ptrSize)
  0x433b43		48c1e703		SHLQ $0x3, DI		
	if size < _MaxSmallSize {
  0x433b47		4881ff00800000		CMPQ $0x8000, DI	
  0x433b4e		0f83b0000000		JAE 0x433c04		
		if size <= smallSizeMax-8 {
  0x433b54		4881fff8030000		CMPQ $0x3f8, DI		
  0x433b5b		776d			JA 0x433bca		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x433b5d		488d7707		LEAQ 0x7(DI), SI			
  0x433b61		48c1ee03		SHRQ $0x3, SI				
  0x433b65		4881fe81000000		CMPQ $0x81, SI				
  0x433b6c		0f838e020000		JAE 0x433e00				
  0x433b72		488d3da7150700		LEAQ runtime.size_to_class8(SB), DI	
  0x433b79		0fb6343e		MOVZX 0(SI)(DI*1), SI			
  0x433b7d		4883fe43		CMPQ $0x43, SI				
  0x433b81		0f8379020000		JAE 0x433e00				
  0x433b87		488d3d32160700		LEAQ runtime.class_to_size(SB), DI	
  0x433b8e		0fb73477		MOVZX 0(DI)(SI*2), SI			
		capmem = roundupsize(uintptr(newcap) * ptrSize)
  0x433b92		4d89c2			MOVQ R8, R10		
		lenmem = uintptr(old.len) * ptrSize
  0x433b95		49c1e003		SHLQ $0x3, R8		
  0x433b99		4989d9			MOVQ BX, R9		
		newlenmem = uintptr(cap) * ptrSize
  0x433b9c		48c1e303		SHLQ $0x3, BX		
		overflow = uintptr(newcap) > _MaxMem/ptrSize
  0x433ba0		49bcffffffff0f000000	MOVQ $0xfffffffff, R12	
  0x433baa		4c39e2			CMPQ R12, DX		
  0x433bad		400f97c7		SETA DI			
  0x433bb1		4989f3			MOVQ SI, R11		
		newcap = int(capmem / ptrSize)
  0x433bb4		49c1eb03		SHRQ $0x3, R11		
  0x433bb8		4889f2			MOVQ SI, DX		
  0x433bbb		48beffffffff7f000000	MOVQ $0x7fffffffff, SI	
	switch et.size {
  0x433bc5		e99cfdffff		JMP 0x433966		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x433bca		488db77ffcffff		LEAQ 0xfffffc7f(DI), SI			
  0x433bd1		48c1ee07		SHRQ $0x7, SI				
  0x433bd5		4881fef9000000		CMPQ $0xf9, SI				
  0x433bdc		0f8317020000		JAE 0x433df9				
  0x433be2		488d3d77160700		LEAQ runtime.size_to_class128(SB), DI	
  0x433be9		0fb6343e		MOVZX 0(SI)(DI*1), SI			
  0x433bed		4883fe43		CMPQ $0x43, SI				
  0x433bf1		0f8302020000		JAE 0x433df9				
  0x433bf7		488d3dc2150700		LEAQ runtime.class_to_size(SB), DI	
  0x433bfe		0fb73477		MOVZX 0(DI)(SI*2), SI			
		capmem = roundupsize(uintptr(newcap) * ptrSize)
  0x433c02		eb8e			JMP 0x433b92		
	if size+_PageSize < size {
  0x433c04		488db700200000		LEAQ 0x2000(DI), SI	
  0x433c0b		4839fe			CMPQ DI, SI		
  0x433c0e		7308			JAE 0x433c18		
  0x433c10		4889fe			MOVQ DI, SI		
		capmem = roundupsize(uintptr(newcap) * ptrSize)
  0x433c13		e97affffff		JMP 0x433b92		
	return (n + a - 1) &^ (a - 1)
  0x433c18		488db7ff1f0000		LEAQ 0x1fff(DI), SI	
  0x433c1f		4881e600e0ffff		ANDQ $-0x2000, SI	
		capmem = roundupsize(uintptr(newcap) * ptrSize)
  0x433c26		e967ffffff		JMP 0x433b92		
  0x433c2b		4c89c6			MOVQ R8, SI		
		lenmem = uintptr(old.len) * et.size
  0x433c2e		4c0fafc2		IMULQ DX, R8		
  0x433c32		4989d9			MOVQ BX, R9		
		newlenmem = uintptr(cap) * et.size
  0x433c35		480fafda		IMULQ DX, BX		
  0x433c39		4989fa			MOVQ DI, R10		
		capmem = roundupsize(uintptr(newcap) * et.size)
  0x433c3c		480faffa		IMULQ DX, DI		
	if size < _MaxSmallSize {
  0x433c40		4881ff00800000		CMPQ $0x8000, DI	
  0x433c47		0f83ec000000		JAE 0x433d39		
		if size <= smallSizeMax-8 {
  0x433c4d		4881fff8030000		CMPQ $0x3f8, DI		
  0x433c54		0f87a0000000		JA 0x433cfa		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x433c5a		4883c707		ADDQ $0x7, DI				
  0x433c5e		48c1ef03		SHRQ $0x3, DI				
  0x433c62		4881ff81000000		CMPQ $0x81, DI				
  0x433c69		0f8383010000		JAE 0x433df2				
  0x433c6f		4c8d1daa140700		LEAQ runtime.size_to_class8(SB), R11	
  0x433c76		420fb63c1f		MOVZX 0(DI)(R11*1), DI			
  0x433c7b		4883ff43		CMPQ $0x43, DI				
  0x433c7f		0f836d010000		JAE 0x433df2				
  0x433c85		4c8d1d34150700		LEAQ runtime.class_to_size(SB), R11	
  0x433c8c		410fb73c7b		MOVZX 0(R11)(DI*2), DI			
	if elemsize < uintptr(len(maxElems)) {
  0x433c91		4883fa21		CMPQ $0x21, DX		
  0x433c95		7340			JAE 0x433cd7		
		return maxElems[elemsize]
  0x433c97		4c8d1de2180700		LEAQ runtime.maxElems(SB), R11	
  0x433c9e		4d8b1cd3		MOVQ 0(R11)(DX*8), R11		
		overflow = uintptr(newcap) > maxSliceCap(et.size)
  0x433ca2		4989c4			MOVQ AX, R12		
  0x433ca5		4889f8			MOVQ DI, AX		
  0x433ca8		4989d5			MOVQ DX, R13		
		newcap = int(capmem / et.size)
  0x433cab		31d2			XORL DX, DX		
  0x433cad		49f7f5			DIVQ R13		
		overflow = uintptr(newcap) > maxSliceCap(et.size)
  0x433cb0		4d39da			CMPQ R11, R10		
  0x433cb3		410f97c5		SETA R13		
  0x433cb7		48beffffffff7f000000	MOVQ $0x7fffffffff, SI	
  0x433cc1		4c8b542478		MOVQ 0x78(SP), R10	
  0x433cc6		4889fa			MOVQ DI, DX		
  0x433cc9		4989c3			MOVQ AX, R11		
  0x433ccc		4c89e0			MOVQ R12, AX		
  0x433ccf		4489ef			MOVL R13, DI		
	switch et.size {
  0x433cd2		e98ffcffff		JMP 0x433966		
  0x433cd7		4989c3			MOVQ AX, R11		
	return _MaxMem / elemsize
  0x433cda		48b8ffffffff7f000000	MOVQ $0x7fffffffff, AX	
  0x433ce4		4989d4			MOVQ DX, R12		
  0x433ce7		31d2			XORL DX, DX		
  0x433ce9		49f7f4			DIVQ R12		
  0x433cec		4c89e2			MOVQ R12, DX		
  0x433cef		4989c5			MOVQ AX, R13		
  0x433cf2		4c89d8			MOVQ R11, AX		
  0x433cf5		4d89eb			MOVQ R13, R11		
		overflow = uintptr(newcap) > maxSliceCap(et.size)
  0x433cf8		eba8			JMP 0x433ca2		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x433cfa		4881c77ffcffff		ADDQ $-0x381, DI			
  0x433d01		48c1ef07		SHRQ $0x7, DI				
  0x433d05		4881fff9000000		CMPQ $0xf9, DI				
  0x433d0c		0f83d9000000		JAE 0x433deb				
  0x433d12		4c8d1d47150700		LEAQ runtime.size_to_class128(SB), R11	
  0x433d19		420fb63c1f		MOVZX 0(DI)(R11*1), DI			
  0x433d1e		4883ff43		CMPQ $0x43, DI				
  0x433d22		0f83c3000000		JAE 0x433deb				
  0x433d28		4c8d1d91140700		LEAQ runtime.class_to_size(SB), R11	
  0x433d2f		410fb73c7b		MOVZX 0(R11)(DI*2), DI			
		capmem = roundupsize(uintptr(newcap) * et.size)
  0x433d34		e958ffffff		JMP 0x433c91		
	if size+_PageSize < size {
  0x433d39		4c8d9f00200000		LEAQ 0x2000(DI), R11	
  0x433d40		4939fb			CMPQ DI, R11		
  0x433d43		0f8248ffffff		JB 0x433c91		
	return (n + a - 1) &^ (a - 1)
  0x433d49		4881c7ff1f0000		ADDQ $0x1fff, DI	
  0x433d50		4881e700e0ffff		ANDQ $-0x2000, DI	
		capmem = roundupsize(uintptr(newcap) * et.size)
  0x433d57		e935ffffff		JMP 0x433c91		
  0x433d5c		4889df			MOVQ BX, DI		
  0x433d5f		488b9c2488000000	MOVQ 0x88(SP), BX	
			if newcap <= 0 {
  0x433d67		e987fbffff		JMP 0x4338f3		
  0x433d6c		4889d8			MOVQ BX, AX		
  0x433d6f		4889fb			MOVQ DI, BX		
  0x433d72		4889f7			MOVQ SI, DI		
			newcap = doublecap
  0x433d75		e979fbffff		JMP 0x4338f3		
  0x433d7a		4889d8			MOVQ BX, AX		
  0x433d7d		4889fb			MOVQ DI, BX		
  0x433d80		4c8b442478		MOVQ 0x78(SP), R8	
		newcap = cap
  0x433d85		e969fbffff		JMP 0x4338f3		
  0x433d8a		488b842488000000	MOVQ 0x88(SP), AX	
  0x433d92		488b8c2480000000	MOVQ 0x80(SP), CX	
		if cap < old.cap {
  0x433d9a		4839c8			CMPQ CX, AX		
  0x433d9d		7c76			JL 0x433e15		
		return slice{unsafe.Pointer(&zerobase), old.len, cap}
  0x433d9f		488d0d5afc0800		LEAQ runtime.zerobase(SB), CX	
  0x433da6		48898c2490000000	MOVQ CX, 0x90(SP)		
  0x433dae		488b4c2478		MOVQ 0x78(SP), CX		
  0x433db3		48898c2498000000	MOVQ CX, 0x98(SP)		
  0x433dbb		48898424a0000000	MOVQ AX, 0xa0(SP)		
  0x433dc3		488b6c2458		MOVQ 0x58(SP), BP		
  0x433dc8		4883c460		ADDQ $0x60, SP			
  0x433dcc		c3			RET				
		panic(errorString("growslice: cap out of range"))
  0x433dcd		488d05ec700200		LEAQ 0x270ec(IP), AX			
  0x433dd4		48890424		MOVQ AX, 0(SP)				
  0x433dd8		488d0511100400		LEAQ runtime.statictmp_31(SB), AX	
  0x433ddf		4889442408		MOVQ AX, 0x8(SP)			
  0x433de4		e847ccfeff		CALL runtime.gopanic(SB)		
  0x433de9		0f0b			UD2					
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x433deb		e850bcfeff		CALL runtime.panicindex(SB)	
  0x433df0		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x433df2		e849bcfeff		CALL runtime.panicindex(SB)	
  0x433df7		0f0b			UD2				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x433df9		e842bcfeff		CALL runtime.panicindex(SB)	
  0x433dfe		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x433e00		e83bbcfeff		CALL runtime.panicindex(SB)	
  0x433e05		0f0b			UD2				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x433e07		e834bcfeff		CALL runtime.panicindex(SB)	
  0x433e0c		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x433e0e		e82dbcfeff		CALL runtime.panicindex(SB)	
  0x433e13		0f0b			UD2				
			panic(errorString("growslice: cap out of range"))
  0x433e15		488d05a4700200		LEAQ 0x270a4(IP), AX			
  0x433e1c		48890424		MOVQ AX, 0(SP)				
  0x433e20		488d05b90f0400		LEAQ runtime.statictmp_30(SB), AX	
  0x433e27		4889442408		MOVQ AX, 0x8(SP)			
  0x433e2c		e8ffcbfeff		CALL runtime.gopanic(SB)		
  0x433e31		0f0b			UD2					
func growslice(et *_type, old slice, cap int) slice {
  0x433e33		e838070100		CALL runtime.morestack_noctxt(SB)	
  0x433e38		e923faffff		JMP runtime.growslice(SB)		

TEXT runtime.stackinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackinit() {
  0x433e40		31c0			XORL AX, AX		
	for i := range stackpool {
  0x433e42		eb23			JMP 0x433e67		
  0x433e44		4889c1			MOVQ AX, CX		
		stackpool[i].init()
  0x433e47		48c1e004		SHLQ $0x4, AX		
	list.first = nil
  0x433e4b		488d15ee390700		LEAQ runtime.stackpool(SB), DX	
  0x433e52		48c7040200000000	MOVQ $0x0, 0(DX)(AX*1)		
	list.last = nil
  0x433e5a		48c744020800000000	MOVQ $0x0, 0x8(DX)(AX*1)	
	for i := range stackpool {
  0x433e63		488d4101		LEAQ 0x1(CX), AX	
  0x433e67		4883f804		CMPQ $0x4, AX		
  0x433e6b		7cd7			JL 0x433e44		
  0x433e6d		31c0			XORL AX, AX		
	for i := range stackLarge.free {
  0x433e6f		eb24			JMP 0x433e95		
  0x433e71		4889c1			MOVQ AX, CX		
		stackLarge.free[i].init()
  0x433e74		48c1e004		SHLQ $0x4, AX		
	list.first = nil
  0x433e78		488d15613d0700		LEAQ runtime.stackLarge(SB), DX	
  0x433e7f		48c744020800000000	MOVQ $0x0, 0x8(DX)(AX*1)	
	list.last = nil
  0x433e88		48c744021000000000	MOVQ $0x0, 0x10(DX)(AX*1)	
	for i := range stackLarge.free {
  0x433e91		488d4101		LEAQ 0x1(CX), AX	
  0x433e95		4883f81a		CMPQ $0x1a, AX		
  0x433e99		7cd6			JL 0x433e71		
  0x433e9b		c3			RET			

TEXT runtime.stacklog2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stacklog2(n uintptr) int {
  0x433ea0		488b442408		MOVQ 0x8(SP), AX	
  0x433ea5		31c9			XORL CX, CX		
	for n > 1 {
  0x433ea7		eb06			JMP 0x433eaf		
		n >>= 1
  0x433ea9		48d1e8			SHRQ $0x1, AX		
		log2++
  0x433eac		48ffc1			INCQ CX			
	for n > 1 {
  0x433eaf		4883f801		CMPQ $0x1, AX		
  0x433eb3		77f4			JA 0x433ea9		
	return log2
  0x433eb5		48894c2410		MOVQ CX, 0x10(SP)	
  0x433eba		c3			RET			

TEXT runtime.stackpoolalloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackpoolalloc(order uint8) gclinkptr {
  0x433ec0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x433ec9		483b6110		CMPQ 0x10(CX), SP	
  0x433ecd		0f86ba010000		JBE 0x43408d		
  0x433ed3		4883ec40		SUBQ $0x40, SP		
  0x433ed7		48896c2438		MOVQ BP, 0x38(SP)	
  0x433edc		488d6c2438		LEAQ 0x38(SP), BP	
  0x433ee1		0fb6442448		MOVZX 0x48(SP), AX	
	list := &stackpool[order]
  0x433ee6		0fb6c8			MOVZX AL, CX			
  0x433ee9		4883f904		CMPQ $0x4, CX			
  0x433eed		0f8393010000		JAE 0x434086			
  0x433ef3		48c1e104		SHLQ $0x4, CX			
  0x433ef7		488d1542390700		LEAQ runtime.stackpool(SB), DX	
  0x433efe		488d1c0a		LEAQ 0(DX)(CX*1), BX		
  0x433f02		48895c2430		MOVQ BX, 0x30(SP)		
	s := list.first
  0x433f07		488b0c0a		MOVQ 0(DX)(CX*1), CX	
	if s == nil {
  0x433f0b		4885c9			TESTQ CX, CX		
  0x433f0e		0f8501010000		JNE 0x434015		
		s = mheap_.allocManual(_StackCacheSize>>_PageShift, &memstats.stacks_inuse)
  0x433f14		488d0585830700		LEAQ runtime.mheap_(SB), AX		
  0x433f1b		48890424		MOVQ AX, 0(SP)				
  0x433f1f		48c744240804000000	MOVQ $0x4, 0x8(SP)			
  0x433f28		488d0531080900		LEAQ runtime.memstats+96(SB), AX	
  0x433f2f		4889442410		MOVQ AX, 0x10(SP)			
  0x433f34		e8c76dfeff		CALL runtime.(*mheap).allocManual(SB)	
  0x433f39		488b442418		MOVQ 0x18(SP), AX			
		if s == nil {
  0x433f3e		4885c0			TESTQ AX, AX		
  0x433f41		0f8424010000		JE 0x43406b		
		if s.allocCount != 0 {
  0x433f47		0fb75060		MOVZX 0x60(AX), DX	
  0x433f4b		6685d2			TESTW DX, DX		
  0x433f4e		0f85fc000000		JNE 0x434050		
		if s.manualFreeList.ptr() != nil {
  0x433f54		488b5028		MOVQ 0x28(AX), DX	
  0x433f58		4885d2			TESTQ DX, DX		
  0x433f5b		0f85d4000000		JNE 0x434035		
  0x433f61		0fb64c2448		MOVZX 0x48(SP), CX	
		s.elemsize = _FixedStack << order
  0x433f66		ba00080000		MOVL $0x800, DX		
  0x433f6b		48d3e2			SHLQ CL, DX		
  0x433f6e		80f940			CMPL $0x40, CL		
  0x433f71		4819db			SBBQ BX, BX		
  0x433f74		4821da			ANDQ BX, DX		
  0x433f77		48895068		MOVQ DX, 0x68(AX)	
  0x433f7b		31c9			XORL CX, CX		
		for i := uintptr(0); i < _StackCacheSize; i += s.elemsize {
  0x433f7d		eb1c			JMP 0x433f9b		
	return s.startAddr
  0x433f7f		488b5018		MOVQ 0x18(AX), DX	
			x := gclinkptr(s.base() + i)
  0x433f83		4801ca			ADDQ CX, DX		
  0x433f86		4889d3			MOVQ DX, BX		
			x.ptr().next = s.manualFreeList
  0x433f89		488b7028		MOVQ 0x28(AX), SI	
  0x433f8d		488932			MOVQ SI, 0(DX)		
			s.manualFreeList = x
  0x433f90		48895828		MOVQ BX, 0x28(AX)	
		for i := uintptr(0); i < _StackCacheSize; i += s.elemsize {
  0x433f94		488b5068		MOVQ 0x68(AX), DX	
  0x433f98		4801d1			ADDQ DX, CX		
  0x433f9b		4881f900800000		CMPQ $0x8000, CX	
  0x433fa2		72db			JB 0x433f7f		
  0x433fa4		4889442428		MOVQ AX, 0x28(SP)	
  0x433fa9		488b4c2430		MOVQ 0x30(SP), CX	
		list.insert(s)
  0x433fae		48890c24		MOVQ CX, 0(SP)				
  0x433fb2		4889442408		MOVQ AX, 0x8(SP)			
  0x433fb7		e89482feff		CALL runtime.(*mSpanList).insert(SB)	
  0x433fbc		488b442428		MOVQ 0x28(SP), AX			
	x := s.manualFreeList
  0x433fc1		488b4828		MOVQ 0x28(AX), CX	
  0x433fc5		4889ca			MOVQ CX, DX		
	if x.ptr() == nil {
  0x433fc8		4885c9			TESTQ CX, CX		
  0x433fcb		744d			JE 0x43401a		
	s.manualFreeList = x.ptr().next
  0x433fcd		488b09			MOVQ 0(CX), CX		
  0x433fd0		48894828		MOVQ CX, 0x28(AX)	
	s.allocCount++
  0x433fd4		0fb74860		MOVZX 0x60(AX), CX	
  0x433fd8		ffc1			INCL CX			
  0x433fda		66894860		MOVW CX, 0x60(AX)	
	if s.manualFreeList.ptr() == nil {
  0x433fde		488b4828		MOVQ 0x28(AX), CX	
  0x433fe2		4885c9			TESTQ CX, CX		
  0x433fe5		740f			JE 0x433ff6		
	return x
  0x433fe7		4889542450		MOVQ DX, 0x50(SP)	
  0x433fec		488b6c2438		MOVQ 0x38(SP), BP	
  0x433ff1		4883c440		ADDQ $0x40, SP		
  0x433ff5		c3			RET			
  0x433ff6		4889542420		MOVQ DX, 0x20(SP)	
  0x433ffb		488b4c2430		MOVQ 0x30(SP), CX	
		list.remove(s)
  0x434000		48890c24		MOVQ CX, 0(SP)				
  0x434004		4889442408		MOVQ AX, 0x8(SP)			
  0x434009		e8a280feff		CALL runtime.(*mSpanList).remove(SB)	
  0x43400e		488b542420		MOVQ 0x20(SP), DX			
  0x434013		ebd2			JMP 0x433fe7				
  0x434015		4889c8			MOVQ CX, AX				
	if s == nil {
  0x434018		eba7			JMP 0x433fc1		
		throw("span has no free stacks")
  0x43401a		488d05b2770300		LEAQ 0x377b2(IP), AX	
  0x434021		48890424		MOVQ AX, 0(SP)		
  0x434025		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x43402e		e89dd1feff		CALL runtime.throw(SB)	
  0x434033		0f0b			UD2			
			throw("bad manualFreeList")
  0x434035		488d05456d0300		LEAQ 0x36d45(IP), AX	
  0x43403c		48890424		MOVQ AX, 0(SP)		
  0x434040		48c744240812000000	MOVQ $0x12, 0x8(SP)	
  0x434049		e882d1feff		CALL runtime.throw(SB)	
  0x43404e		0f0b			UD2			
			throw("bad allocCount")
  0x434050		488d0513680300		LEAQ 0x36813(IP), AX	
  0x434057		48890424		MOVQ AX, 0(SP)		
  0x43405b		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x434064		e867d1feff		CALL runtime.throw(SB)	
  0x434069		0f0b			UD2			
			throw("out of memory")
  0x43406b		488d0503670300		LEAQ 0x36703(IP), AX	
  0x434072		48890424		MOVQ AX, 0(SP)		
  0x434076		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x43407f		e84cd1feff		CALL runtime.throw(SB)	
  0x434084		0f0b			UD2			
	list := &stackpool[order]
  0x434086		e8b5b9feff		CALL runtime.panicindex(SB)	
  0x43408b		0f0b			UD2				
func stackpoolalloc(order uint8) gclinkptr {
  0x43408d		e8de040100		CALL runtime.morestack_noctxt(SB)	
  0x434092		e929feffff		JMP runtime.stackpoolalloc(SB)		

TEXT runtime.stackpoolfree(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackpoolfree(x gclinkptr, order uint8) {
  0x4340a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4340a9		483b6110		CMPQ 0x10(CX), SP	
  0x4340ad		0f8657010000		JBE 0x43420a		
  0x4340b3		4883ec28		SUBQ $0x28, SP		
  0x4340b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4340bc		488d6c2420		LEAQ 0x20(SP), BP	
	p -= h.arena_start
  0x4340c1		488b0500950700		MOVQ runtime.mheap_+4904(SB), AX	
  0x4340c8		488b4c2430		MOVQ 0x30(SP), CX			
  0x4340cd		4889ca			MOVQ CX, DX				
  0x4340d0		4829c1			SUBQ AX, CX				
	return h.spans[p>>_PageShift]
  0x4340d3		488b0516920700		MOVQ runtime.mheap_+4176(SB), AX	
  0x4340da		488b1d07920700		MOVQ runtime.mheap_+4168(SB), BX	
  0x4340e1		48c1e90d		SHRQ $0xd, CX				
  0x4340e5		4839c1			CMPQ AX, CX				
  0x4340e8		0f8315010000		JAE 0x434203				
  0x4340ee		488b04cb		MOVQ 0(BX)(CX*8), AX			
	if s.state != _MSpanManual {
  0x4340f2		0fb64864		MOVZX 0x64(AX), CX	
  0x4340f6		80f902			CMPL $0x2, CL		
  0x4340f9		0f85e9000000		JNE 0x4341e8		
  0x4340ff		4889442418		MOVQ AX, 0x18(SP)	
	if s.manualFreeList.ptr() == nil {
  0x434104		488b4828		MOVQ 0x28(AX), CX	
  0x434108		4885c9			TESTQ CX, CX		
  0x43410b		0f848f000000		JE 0x4341a0		
  0x434111		4889d1			MOVQ DX, CX		
	x.ptr().next = s.manualFreeList
  0x434114		488b5828		MOVQ 0x28(AX), BX	
  0x434118		48891a			MOVQ BX, 0(DX)		
	s.manualFreeList = x
  0x43411b		48894828		MOVQ CX, 0x28(AX)	
	s.allocCount--
  0x43411f		0fb74860		MOVZX 0x60(AX), CX	
  0x434123		8d51ff			LEAL -0x1(CX), DX	
  0x434126		66895060		MOVW DX, 0x60(AX)	
	if gcphase == _GCoff && s.allocCount == 0 {
  0x43412a		8b15acf70800		MOVL runtime.gcphase(SB), DX	
  0x434130		85d2			TESTL DX, DX			
  0x434132		7562			JNE 0x434196			
  0x434134		6683f901		CMPW $0x1, CX			
  0x434138		755c			JNE 0x434196			
  0x43413a		0fb64c2438		MOVZX 0x38(SP), CX		
		stackpool[order].remove(s)
  0x43413f		0fb6c9			MOVZX CL, CX				
  0x434142		4883f904		CMPQ $0x4, CX				
  0x434146		0f838e000000		JAE 0x4341da				
  0x43414c		48c1e104		SHLQ $0x4, CX				
  0x434150		488d15e9360700		LEAQ runtime.stackpool(SB), DX		
  0x434157		4801d1			ADDQ DX, CX				
  0x43415a		48890c24		MOVQ CX, 0(SP)				
  0x43415e		4889442408		MOVQ AX, 0x8(SP)			
  0x434163		e8487ffeff		CALL runtime.(*mSpanList).remove(SB)	
  0x434168		488b442418		MOVQ 0x18(SP), AX			
		s.manualFreeList = 0
  0x43416d		48c7402800000000	MOVQ $0x0, 0x28(AX)	
		mheap_.freeManual(s, &memstats.stacks_inuse)
  0x434175		488d0d24810700		LEAQ runtime.mheap_(SB), CX		
  0x43417c		48890c24		MOVQ CX, 0(SP)				
  0x434180		4889442408		MOVQ AX, 0x8(SP)			
  0x434185		488d05d4050900		LEAQ runtime.memstats+96(SB), AX	
  0x43418c		4889442410		MOVQ AX, 0x10(SP)			
  0x434191		e86a73feff		CALL runtime.(*mheap).freeManual(SB)	
  0x434196		488b6c2420		MOVQ 0x20(SP), BP			
  0x43419b		4883c428		ADDQ $0x28, SP				
  0x43419f		c3			RET					
  0x4341a0		0fb64c2438		MOVZX 0x38(SP), CX			
		stackpool[order].insert(s)
  0x4341a5		0fb6d9			MOVZX CL, BX				
  0x4341a8		4883fb04		CMPQ $0x4, BX				
  0x4341ac		7333			JAE 0x4341e1				
  0x4341ae		48c1e304		SHLQ $0x4, BX				
  0x4341b2		488d0d87360700		LEAQ runtime.stackpool(SB), CX		
  0x4341b9		488d1419		LEAQ 0(CX)(BX*1), DX			
  0x4341bd		48891424		MOVQ DX, 0(SP)				
  0x4341c1		4889442408		MOVQ AX, 0x8(SP)			
  0x4341c6		e88580feff		CALL runtime.(*mSpanList).insert(SB)	
  0x4341cb		488b442418		MOVQ 0x18(SP), AX			
  0x4341d0		488b542430		MOVQ 0x30(SP), DX			
  0x4341d5		e937ffffff		JMP 0x434111				
		stackpool[order].remove(s)
  0x4341da		e861b8feff		CALL runtime.panicindex(SB)	
  0x4341df		0f0b			UD2				
		stackpool[order].insert(s)
  0x4341e1		e85ab8feff		CALL runtime.panicindex(SB)	
  0x4341e6		0f0b			UD2				
		throw("freeing stack not in a stack span")
  0x4341e8		488d0519880300		LEAQ 0x38819(IP), AX	
  0x4341ef		48890424		MOVQ AX, 0(SP)		
  0x4341f3		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x4341fc		e8cfcffeff		CALL runtime.throw(SB)	
  0x434201		0f0b			UD2			
	return h.spans[p>>_PageShift]
  0x434203		e838b8feff		CALL runtime.panicindex(SB)	
  0x434208		0f0b			UD2				
func stackpoolfree(x gclinkptr, order uint8) {
  0x43420a		e861030100		CALL runtime.morestack_noctxt(SB)	
  0x43420f		e98cfeffff		JMP runtime.stackpoolfree(SB)		

TEXT runtime.stackcacherefill(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackcacherefill(c *mcache, order uint8) {
  0x434220		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434229		483b6118		CMPQ 0x18(CX), SP	
  0x43422d		0f86ce000000		JBE 0x434301		
  0x434233		4883ec28		SUBQ $0x28, SP		
  0x434237		48896c2420		MOVQ BP, 0x20(SP)	
  0x43423c		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&stackpoolmu)
  0x434241		488d0588f70800		LEAQ runtime.stackpoolmu(SB), AX	
  0x434248		48890424		MOVQ AX, 0(SP)				
  0x43424c		e8cf52fdff		CALL runtime.lock(SB)			
func stackcacherefill(c *mcache, order uint8) {
  0x434251		31c0			XORL AX, AX		
  0x434253		31c9			XORL CX, CX		
	for size < _StackCacheSize/2 {
  0x434255		eb44			JMP 0x43429b		
  0x434257		0fb6442438		MOVZX 0x38(SP), AX	
		x := stackpoolalloc(order)
  0x43425c		880424			MOVB AL, 0(SP)			
  0x43425f		e85cfcffff		CALL runtime.stackpoolalloc(SB)	
  0x434264		488b442408		MOVQ 0x8(SP), AX		
  0x434269		4889c1			MOVQ AX, CX			
	return (*gclink)(unsafe.Pointer(p))
  0x43426c		488b542418		MOVQ 0x18(SP), DX	
		x.ptr().next = list
  0x434271		488910			MOVQ DX, 0(AX)		
  0x434274		4889c8			MOVQ CX, AX		
  0x434277		0fb64c2438		MOVZX 0x38(SP), CX	
		size += _FixedStack << order
  0x43427c		ba00080000		MOVL $0x800, DX		
  0x434281		48d3e2			SHLQ CL, DX		
  0x434284		80f940			CMPL $0x40, CL		
  0x434287		4819db			SBBQ BX, BX		
  0x43428a		4821da			ANDQ BX, DX		
  0x43428d		488b5c2410		MOVQ 0x10(SP), BX	
  0x434292		4801da			ADDQ BX, DX		
  0x434295		4889c1			MOVQ AX, CX		
  0x434298		4889d0			MOVQ DX, AX		
	for size < _StackCacheSize/2 {
  0x43429b		4889442410		MOVQ AX, 0x10(SP)	
  0x4342a0		48894c2418		MOVQ CX, 0x18(SP)	
  0x4342a5		483d00400000		CMPQ $0x4000, AX	
  0x4342ab		72aa			JB 0x434257		
	unlock(&stackpoolmu)
  0x4342ad		488d051cf70800		LEAQ runtime.stackpoolmu(SB), AX	
  0x4342b4		48890424		MOVQ AX, 0(SP)				
  0x4342b8		e80354fdff		CALL runtime.unlock(SB)			
  0x4342bd		488b442430		MOVQ 0x30(SP), AX			
	c.stackcache[order].list = list
  0x4342c2		8400			TESTB AL, 0(AX)			
  0x4342c4		0fb64c2438		MOVZX 0x38(SP), CX		
  0x4342c9		0fb6c9			MOVZX CL, CX			
  0x4342cc		4883f904		CMPQ $0x4, CX			
  0x4342d0		7328			JAE 0x4342fa			
  0x4342d2		48c1e104		SHLQ $0x4, CX			
  0x4342d6		488b542418		MOVQ 0x18(SP), DX		
  0x4342db		4889940858040000	MOVQ DX, 0x458(AX)(CX*1)	
  0x4342e3		488b542410		MOVQ 0x10(SP), DX		
	c.stackcache[order].size = size
  0x4342e8		4889940860040000	MOVQ DX, 0x460(AX)(CX*1)	
}
  0x4342f0		488b6c2420		MOVQ 0x20(SP), BP	
  0x4342f5		4883c428		ADDQ $0x28, SP		
  0x4342f9		c3			RET			
	c.stackcache[order].list = list
  0x4342fa		e841b7feff		CALL runtime.panicindex(SB)	
  0x4342ff		0f0b			UD2				
func stackcacherefill(c *mcache, order uint8) {
  0x434301		e8fa290000		CALL runtime.morestackc(SB)		
  0x434306		e915ffffff		JMP runtime.stackcacherefill(SB)	

TEXT runtime.stackcacherelease(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackcacherelease(c *mcache, order uint8) {
  0x434310		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434319		483b6118		CMPQ 0x18(CX), SP	
  0x43431d		0f8600010000		JBE 0x434423		
  0x434323		4883ec48		SUBQ $0x48, SP		
  0x434327		48896c2440		MOVQ BP, 0x40(SP)	
  0x43432c		488d6c2440		LEAQ 0x40(SP), BP	
  0x434331		488b442450		MOVQ 0x50(SP), AX	
	x := c.stackcache[order].list
  0x434336		8400			TESTB AL, 0(AX)		
func stackcacherelease(c *mcache, order uint8) {
  0x434338		0fb64c2458		MOVZX 0x58(SP), CX	
	x := c.stackcache[order].list
  0x43433d		0fb6d1			MOVZX CL, DX			
  0x434340		4883fa04		CMPQ $0x4, DX			
  0x434344		0f83d2000000		JAE 0x43441c			
  0x43434a		48c1e204		SHLQ $0x4, DX			
  0x43434e		4889542428		MOVQ DX, 0x28(SP)		
  0x434353		488b8c1058040000	MOVQ 0x458(AX)(DX*1), CX	
  0x43435b		48894c2438		MOVQ CX, 0x38(SP)		
	size := c.stackcache[order].size
  0x434360		488b9c1060040000	MOVQ 0x460(AX)(DX*1), BX	
  0x434368		48895c2430		MOVQ BX, 0x30(SP)		
	lock(&stackpoolmu)
  0x43436d		488d355cf60800		LEAQ runtime.stackpoolmu(SB), SI	
  0x434374		48893424		MOVQ SI, 0(SP)				
  0x434378		e8a351fdff		CALL runtime.lock(SB)			
  0x43437d		488b442430		MOVQ 0x30(SP), AX			
  0x434382		488b4c2438		MOVQ 0x38(SP), CX			
	for size > _StackCacheSize/2 {
  0x434387		eb43			JMP 0x4343cc		
  0x434389		4889c8			MOVQ CX, AX		
		y := x.ptr().next
  0x43438c		488b09			MOVQ 0(CX), CX		
  0x43438f		48894c2410		MOVQ CX, 0x10(SP)	
		stackpoolfree(x, order)
  0x434394		48890424		MOVQ AX, 0(SP)			
  0x434398		0fb6442458		MOVZX 0x58(SP), AX		
  0x43439d		88442408		MOVB AL, 0x8(SP)		
  0x4343a1		e8fafcffff		CALL runtime.stackpoolfree(SB)	
  0x4343a6		0fb64c2458		MOVZX 0x58(SP), CX		
		size -= _FixedStack << order
  0x4343ab		b800080000		MOVL $0x800, AX		
  0x4343b0		48d3e0			SHLQ CL, AX		
  0x4343b3		80f940			CMPL $0x40, CL		
  0x4343b6		4819d2			SBBQ DX, DX		
  0x4343b9		4821d0			ANDQ DX, AX		
  0x4343bc		488b542418		MOVQ 0x18(SP), DX	
  0x4343c1		4829c2			SUBQ AX, DX		
  0x4343c4		4889d0			MOVQ DX, AX		
  0x4343c7		488b4c2410		MOVQ 0x10(SP), CX	
	for size > _StackCacheSize/2 {
  0x4343cc		4889442418		MOVQ AX, 0x18(SP)	
  0x4343d1		483d00400000		CMPQ $0x4000, AX	
  0x4343d7		77b0			JA 0x434389		
  0x4343d9		48894c2420		MOVQ CX, 0x20(SP)	
	unlock(&stackpoolmu)
  0x4343de		488d05ebf50800		LEAQ runtime.stackpoolmu(SB), AX	
  0x4343e5		48890424		MOVQ AX, 0(SP)				
  0x4343e9		e8d252fdff		CALL runtime.unlock(SB)			
  0x4343ee		488b442428		MOVQ 0x28(SP), AX			
  0x4343f3		488b4c2420		MOVQ 0x20(SP), CX			
  0x4343f8		488b542450		MOVQ 0x50(SP), DX			
	c.stackcache[order].list = x
  0x4343fd		48898c0258040000	MOVQ CX, 0x458(DX)(AX*1)	
  0x434405		488b4c2418		MOVQ 0x18(SP), CX		
	c.stackcache[order].size = size
  0x43440a		48898c0260040000	MOVQ CX, 0x460(DX)(AX*1)	
}
  0x434412		488b6c2440		MOVQ 0x40(SP), BP	
  0x434417		4883c448		ADDQ $0x48, SP		
  0x43441b		c3			RET			
	x := c.stackcache[order].list
  0x43441c		e81fb6feff		CALL runtime.panicindex(SB)	
  0x434421		0f0b			UD2				
func stackcacherelease(c *mcache, order uint8) {
  0x434423		e8d8280000		CALL runtime.morestackc(SB)		
  0x434428		e9e3feffff		JMP runtime.stackcacherelease(SB)	

TEXT runtime.stackcache_clear(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackcache_clear(c *mcache) {
  0x434430		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434439		483b6118		CMPQ 0x18(CX), SP	
  0x43443d		0f86b9000000		JBE 0x4344fc		
  0x434443		4883ec30		SUBQ $0x30, SP		
  0x434447		48896c2428		MOVQ BP, 0x28(SP)	
  0x43444c		488d6c2428		LEAQ 0x28(SP), BP	
	lock(&stackpoolmu)
  0x434451		488d0578f50800		LEAQ runtime.stackpoolmu(SB), AX	
  0x434458		48890424		MOVQ AX, 0(SP)				
  0x43445c		e8bf50fdff		CALL runtime.lock(SB)			
func stackcache_clear(c *mcache) {
  0x434461		31c0			XORL AX, AX		
	for order := uint8(0); order < _NumStackOrders; order++ {
  0x434463		eb4b			JMP 0x4344b0		
			y := x.ptr().next
  0x434465		488b0b			MOVQ 0(BX), CX		
  0x434468		48894c2418		MOVQ CX, 0x18(SP)	
			stackpoolfree(x, order)
  0x43446d		48893424		MOVQ SI, 0(SP)			
  0x434471		88442408		MOVB AL, 0x8(SP)		
  0x434475		e826fcffff		CALL runtime.stackpoolfree(SB)	
  0x43447a		0fb6442417		MOVZX 0x17(SP), AX		
  0x43447f		488b4c2438		MOVQ 0x38(SP), CX		
  0x434484		488b542420		MOVQ 0x20(SP), DX		
  0x434489		488b5c2418		MOVQ 0x18(SP), BX		
		for x.ptr() != nil {
  0x43448e		4889de			MOVQ BX, SI		
  0x434491		4885db			TESTQ BX, BX		
  0x434494		75cf			JNE 0x434465		
		c.stackcache[order].list = 0
  0x434496		48c784115804000000000000	MOVQ $0x0, 0x458(CX)(DX*1)	
		c.stackcache[order].size = 0
  0x4344a2		48c784116004000000000000	MOVQ $0x0, 0x460(CX)(DX*1)	
	for order := uint8(0); order < _NumStackOrders; order++ {
  0x4344ae		ffc0			INCL AX			
  0x4344b0		3c04			CMPL $0x4, AL		
  0x4344b2		7327			JAE 0x4344db		
  0x4344b4		488b4c2438		MOVQ 0x38(SP), CX	
		x := c.stackcache[order].list
  0x4344b9		8401			TESTB AL, 0(CX)			
  0x4344bb		0fb6d0			MOVZX AL, DX			
  0x4344be		4883fa04		CMPQ $0x4, DX			
  0x4344c2		7331			JAE 0x4344f5			
  0x4344c4		88442417		MOVB AL, 0x17(SP)		
  0x4344c8		48c1e204		SHLQ $0x4, DX			
  0x4344cc		4889542420		MOVQ DX, 0x20(SP)		
  0x4344d1		488b9c1158040000	MOVQ 0x458(CX)(DX*1), BX	
		for x.ptr() != nil {
  0x4344d9		ebb3			JMP 0x43448e		
	unlock(&stackpoolmu)
  0x4344db		488d05eef40800		LEAQ runtime.stackpoolmu(SB), AX	
  0x4344e2		48890424		MOVQ AX, 0(SP)				
  0x4344e6		e8d551fdff		CALL runtime.unlock(SB)			
}
  0x4344eb		488b6c2428		MOVQ 0x28(SP), BP	
  0x4344f0		4883c430		ADDQ $0x30, SP		
  0x4344f4		c3			RET			
		x := c.stackcache[order].list
  0x4344f5		e846b5feff		CALL runtime.panicindex(SB)	
  0x4344fa		0f0b			UD2				
func stackcache_clear(c *mcache) {
  0x4344fc		e8ff270000		CALL runtime.morestackc(SB)		
  0x434501		e92affffff		JMP runtime.stackcache_clear(SB)	

TEXT runtime.stackalloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackalloc(n uint32) stack {
  0x434510		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434519		483b6118		CMPQ 0x18(CX), SP	
  0x43451d		0f86fd020000		JBE 0x434820		
  0x434523		4883ec68		SUBQ $0x68, SP		
  0x434527		48896c2460		MOVQ BP, 0x60(SP)	
  0x43452c		488d6c2460		LEAQ 0x60(SP), BP	
	thisg := getg()
  0x434531		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if thisg != thisg.m.g0 {
  0x43453a		488b4830		MOVQ 0x30(AX), CX	
  0x43453e		488b11			MOVQ 0(CX), DX		
  0x434541		4839d0			CMPQ DX, AX		
  0x434544		0f85bb020000		JNE 0x434805		
  0x43454a		8b442470		MOVL 0x70(SP), AX	
	if n&(n-1) != 0 {
  0x43454e		8d50ff			LEAL -0x1(AX), DX	
  0x434551		85d0			TESTL DX, AX		
  0x434553		0f8591020000		JNE 0x4347ea		
	if debug.efence != 0 || stackFromSystem != 0 {
  0x434559		8b1569f50800		MOVL runtime.debug+8(SB), DX	
  0x43455f		85d2			TESTL DX, DX			
  0x434561		0f85e5010000		JNE 0x43474c			
	if n < _FixedStack<<_NumStackOrders && n < _StackCacheSize {
  0x434567		3d00800000		CMPL $0x8000, AX	
  0x43456c		0f8307010000		JAE 0x434679		
  0x434572		89c2			MOVL AX, DX		
  0x434574		31db			XORL BX, BX		
		for n2 > _FixedStack {
  0x434576		eb04			JMP 0x43457c		
			order++
  0x434578		ffc3			INCL BX			
			n2 >>= 1
  0x43457a		d1e8			SHRL $0x1, AX		
		for n2 > _FixedStack {
  0x43457c		3d00080000		CMPL $0x800, AX		
  0x434581		77f5			JA 0x434578		
  0x434583		885c2427		MOVB BL, 0x27(SP)	
		c := thisg.m.mcache
  0x434587		488b8160010000		MOVQ 0x160(CX), AX	
		if stackNoCache != 0 || c == nil || thisg.m.preemptoff != "" || thisg.m.helpgc != 0 {
  0x43458e		4885c0			TESTQ AX, AX		
  0x434591		740c			JE 0x43459f		
  0x434593		488bb1f8000000		MOVQ 0xf8(CX), SI	
  0x43459a		4885f6			TESTQ SI, SI		
  0x43459d		745a			JE 0x4345f9		
			lock(&stackpoolmu)
  0x43459f		488d052af40800		LEAQ runtime.stackpoolmu(SB), AX	
  0x4345a6		48890424		MOVQ AX, 0(SP)				
  0x4345aa		e8714ffdff		CALL runtime.lock(SB)			
  0x4345af		0fb6442427		MOVZX 0x27(SP), AX			
			x = stackpoolalloc(order)
  0x4345b4		880424			MOVB AL, 0(SP)			
  0x4345b7		e804f9ffff		CALL runtime.stackpoolalloc(SB)	
  0x4345bc		488b442408		MOVQ 0x8(SP), AX		
  0x4345c1		4889442428		MOVQ AX, 0x28(SP)		
			unlock(&stackpoolmu)
  0x4345c6		488d0d03f40800		LEAQ runtime.stackpoolmu(SB), CX	
  0x4345cd		48890c24		MOVQ CX, 0(SP)				
  0x4345d1		e8ea50fdff		CALL runtime.unlock(SB)			
  0x4345d6		488b442428		MOVQ 0x28(SP), AX			
	return stack{uintptr(v), uintptr(v) + uintptr(n)}
  0x4345db		4889442478		MOVQ AX, 0x78(SP)	
  0x4345e0		8b4c2470		MOVL 0x70(SP), CX	
  0x4345e4		4801c8			ADDQ CX, AX		
  0x4345e7		4889842480000000	MOVQ AX, 0x80(SP)	
  0x4345ef		488b6c2460		MOVQ 0x60(SP), BP	
  0x4345f4		4883c468		ADDQ $0x68, SP		
  0x4345f8		c3			RET			
		if stackNoCache != 0 || c == nil || thisg.m.preemptoff != "" || thisg.m.helpgc != 0 {
  0x4345f9		8b8910010000		MOVL 0x110(CX), CX	
  0x4345ff		85c9			TESTL CX, CX		
  0x434601		759c			JNE 0x43459f		
			x = c.stackcache[order].list
  0x434603		0fb6cb			MOVZX BL, CX			
  0x434606		4883f904		CMPQ $0x4, CX			
  0x43460a		0f83b8010000		JAE 0x4347c8			
  0x434610		48c1e104		SHLQ $0x4, CX			
  0x434614		488bb40858040000	MOVQ 0x458(AX)(CX*1), SI	
  0x43461c		4889f7			MOVQ SI, DI			
			if x.ptr() == nil {
  0x43461f		4885f6			TESTQ SI, SI		
  0x434622		7426			JE 0x43464a		
  0x434624		4889fb			MOVQ DI, BX		
			c.stackcache[order].list = x.ptr().next
  0x434627		488b37			MOVQ 0(DI), SI			
  0x43462a		4889b40858040000	MOVQ SI, 0x458(AX)(CX*1)	
			c.stackcache[order].size -= uintptr(n)
  0x434632		488bb40860040000	MOVQ 0x460(AX)(CX*1), SI	
  0x43463a		4829d6			SUBQ DX, SI			
  0x43463d		4889b40860040000	MOVQ SI, 0x460(AX)(CX*1)	
  0x434645		4889d8			MOVQ BX, AX			
  0x434648		eb91			JMP 0x4345db			
  0x43464a		4889442450		MOVQ AX, 0x50(SP)		
  0x43464f		48894c2440		MOVQ CX, 0x40(SP)		
				stackcacherefill(c, order)
  0x434654		48890424		MOVQ AX, 0(SP)				
  0x434658		885c2408		MOVB BL, 0x8(SP)			
  0x43465c		e8bffbffff		CALL runtime.stackcacherefill(SB)	
  0x434661		488b4c2440		MOVQ 0x40(SP), CX			
  0x434666		488b442450		MOVQ 0x50(SP), AX			
				x = c.stackcache[order].list
  0x43466b		488bbc0858040000	MOVQ 0x458(AX)(CX*1), DI	
  0x434673		8b542470		MOVL 0x70(SP), DX		
  0x434677		ebab			JMP 0x434624			
		npage := uintptr(n) >> _PageShift
  0x434679		48c1e80d		SHRQ $0xd, AX		
  0x43467d		4889442438		MOVQ AX, 0x38(SP)	
		log2npage := stacklog2(npage)
  0x434682		48890424		MOVQ AX, 0(SP)			
  0x434686		e815f8ffff		CALL runtime.stacklog2(SB)	
  0x43468b		488b442408		MOVQ 0x8(SP), AX		
  0x434690		4889442430		MOVQ AX, 0x30(SP)		
		lock(&stackLarge.lock)
  0x434695		488d0d44350700		LEAQ runtime.stackLarge(SB), CX	
  0x43469c		48890c24		MOVQ CX, 0(SP)			
  0x4346a0		e87b4efdff		CALL runtime.lock(SB)		
  0x4346a5		488b442430		MOVQ 0x30(SP), AX		
		if !stackLarge.free[log2npage].isEmpty() {
  0x4346aa		4883f81a		CMPQ $0x1a, AX			
  0x4346ae		0f830d010000		JAE 0x4347c1			
  0x4346b4		48c1e004		SHLQ $0x4, AX			
  0x4346b8		488d0d21350700		LEAQ runtime.stackLarge(SB), CX	
  0x4346bf		488d540108		LEAQ 0x8(CX)(AX*1), DX		
	return list.first == nil
  0x4346c4		488b440108		MOVQ 0x8(CX)(AX*1), AX	
  0x4346c9		4885c0			TESTQ AX, AX		
		if !stackLarge.free[log2npage].isEmpty() {
  0x4346cc		7564			JNE 0x434732		
  0x4346ce		31c0			XORL AX, AX		
  0x4346d0		4889442448		MOVQ AX, 0x48(SP)	
		unlock(&stackLarge.lock)
  0x4346d5		488d0d04350700		LEAQ runtime.stackLarge(SB), CX	
  0x4346dc		48890c24		MOVQ CX, 0(SP)			
  0x4346e0		e8db4ffdff		CALL runtime.unlock(SB)		
  0x4346e5		488b442448		MOVQ 0x48(SP), AX		
		if s == nil {
  0x4346ea		4885c0			TESTQ AX, AX		
  0x4346ed		7409			JE 0x4346f8		
	return s.startAddr
  0x4346ef		488b4018		MOVQ 0x18(AX), AX	
		v = unsafe.Pointer(s.base())
  0x4346f3		e9e3feffff		JMP 0x4345db		
			s = mheap_.allocManual(npage, &memstats.stacks_inuse)
  0x4346f8		488d05a17b0700		LEAQ runtime.mheap_(SB), AX		
  0x4346ff		48890424		MOVQ AX, 0(SP)				
  0x434703		488b442438		MOVQ 0x38(SP), AX			
  0x434708		4889442408		MOVQ AX, 0x8(SP)			
  0x43470d		488d054c000900		LEAQ runtime.memstats+96(SB), AX	
  0x434714		4889442410		MOVQ AX, 0x10(SP)			
  0x434719		e8e265feff		CALL runtime.(*mheap).allocManual(SB)	
  0x43471e		488b442418		MOVQ 0x18(SP), AX			
			if s == nil {
  0x434723		4885c0			TESTQ AX, AX		
  0x434726		747e			JE 0x4347a6		
  0x434728		8b4c2470		MOVL 0x70(SP), CX	
			s.elemsize = uintptr(n)
  0x43472c		48894868		MOVQ CX, 0x68(AX)	
  0x434730		ebbd			JMP 0x4346ef		
  0x434732		4889442458		MOVQ AX, 0x58(SP)	
			stackLarge.free[log2npage].remove(s)
  0x434737		48891424		MOVQ DX, 0(SP)				
  0x43473b		4889442408		MOVQ AX, 0x8(SP)			
  0x434740		e86b79feff		CALL runtime.(*mSpanList).remove(SB)	
  0x434745		488b442458		MOVQ 0x58(SP), AX			
  0x43474a		eb84			JMP 0x4346d0				
		n = uint32(round(uintptr(n), physPageSize))
  0x43474c		488b0d4df20800		MOVQ runtime.physPageSize(SB), CX	
	return (n + a - 1) &^ (a - 1)
  0x434753		488d4401ff		LEAQ -0x1(CX)(AX*1), AX	
  0x434758		48ffc9			DECQ CX			
  0x43475b		48f7d1			NOTQ CX			
  0x43475e		4821c8			ANDQ CX, AX		
		v := sysAlloc(uintptr(n), &memstats.stacks_sys)
  0x434761		89c0			MOVL AX, AX				
  0x434763		4889442438		MOVQ AX, 0x38(SP)			
  0x434768		48890424		MOVQ AX, 0(SP)				
  0x43476c		488d0df5ff0800		LEAQ runtime.memstats+104(SB), CX	
  0x434773		48894c2408		MOVQ CX, 0x8(SP)			
  0x434778		e8a3a8fdff		CALL runtime.sysAlloc(SB)		
  0x43477d		488b442410		MOVQ 0x10(SP), AX			
		if v == nil {
  0x434782		4885c0			TESTQ AX, AX		
  0x434785		7448			JE 0x4347cf		
		return stack{uintptr(v), uintptr(v) + uintptr(n)}
  0x434787		4889442478		MOVQ AX, 0x78(SP)	
  0x43478c		488b4c2438		MOVQ 0x38(SP), CX	
  0x434791		4801c8			ADDQ CX, AX		
  0x434794		4889842480000000	MOVQ AX, 0x80(SP)	
  0x43479c		488b6c2460		MOVQ 0x60(SP), BP	
  0x4347a1		4883c468		ADDQ $0x68, SP		
  0x4347a5		c3			RET			
				throw("out of memory")
  0x4347a6		488d05c85f0300		LEAQ 0x35fc8(IP), AX	
  0x4347ad		48890424		MOVQ AX, 0(SP)		
  0x4347b1		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x4347ba		e811cafeff		CALL runtime.throw(SB)	
  0x4347bf		0f0b			UD2			
		if !stackLarge.free[log2npage].isEmpty() {
  0x4347c1		e87ab2feff		CALL runtime.panicindex(SB)	
  0x4347c6		0f0b			UD2				
			x = c.stackcache[order].list
  0x4347c8		e873b2feff		CALL runtime.panicindex(SB)	
  0x4347cd		0f0b			UD2				
			throw("out of memory (stackalloc)")
  0x4347cf		488d0586740300		LEAQ 0x37486(IP), AX	
  0x4347d6		48890424		MOVQ AX, 0(SP)		
  0x4347da		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x4347e3		e8e8c9feff		CALL runtime.throw(SB)	
  0x4347e8		0f0b			UD2			
		throw("stack size not a power of 2")
  0x4347ea		488d0525770300		LEAQ 0x37725(IP), AX	
  0x4347f1		48890424		MOVQ AX, 0(SP)		
  0x4347f5		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x4347fe		e8cdc9feff		CALL runtime.throw(SB)	
  0x434803		0f0b			UD2			
		throw("stackalloc not on scheduler stack")
  0x434805		488d0504830300		LEAQ 0x38304(IP), AX	
  0x43480c		48890424		MOVQ AX, 0(SP)		
  0x434810		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x434819		e8b2c9feff		CALL runtime.throw(SB)	
  0x43481e		0f0b			UD2			
func stackalloc(n uint32) stack {
  0x434820		e8db240000		CALL runtime.morestackc(SB)	
  0x434825		e9e6fcffff		JMP runtime.stackalloc(SB)	

TEXT runtime.stackfree(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func stackfree(stk stack) {
  0x434830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434839		483b6118		CMPQ 0x18(CX), SP	
  0x43483d		0f86f2020000		JBE 0x434b35		
  0x434843		4883ec60		SUBQ $0x60, SP		
  0x434847		48896c2458		MOVQ BP, 0x58(SP)	
  0x43484c		488d6c2458		LEAQ 0x58(SP), BP	
	gp := getg()
  0x434851		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43485a		488b4c2468		MOVQ 0x68(SP), CX	
  0x43485f		4889ca			MOVQ CX, DX		
	v := unsafe.Pointer(stk.lo)
  0x434862		488b5c2470		MOVQ 0x70(SP), BX	
  0x434867		4889de			MOVQ BX, SI		
	n := stk.hi - stk.lo
  0x43486a		4829d3			SUBQ DX, BX		
	if n&(n-1) != 0 {
  0x43486d		488d7bff		LEAQ -0x1(BX), DI	
  0x434871		4885fb			TESTQ DI, BX		
  0x434874		0f85a0020000		JNE 0x434b1a		
	if stk.lo+n < stk.hi {
  0x43487a		488d3c1a		LEAQ 0(DX)(BX*1), DI	
  0x43487e		4839f7			CMPQ SI, DI		
  0x434881		0f8278020000		JB 0x434aff		
	if debug.efence != 0 || stackFromSystem != 0 {
  0x434887		8b353bf20800		MOVL runtime.debug+8(SB), SI	
  0x43488d		85f6			TESTL SI, SI			
  0x43488f		0f85e4010000		JNE 0x434a79			
	if n < _FixedStack<<_NumStackOrders && n < _StackCacheSize {
  0x434895		4881fb00800000		CMPQ $0x8000, BX	
  0x43489c		0f8302010000		JAE 0x4349a4		
  0x4348a2		4889d9			MOVQ BX, CX		
  0x4348a5		31f6			XORL SI, SI		
		for n2 > _FixedStack {
  0x4348a7		eb05			JMP 0x4348ae		
			order++
  0x4348a9		ffc6			INCL SI			
			n2 >>= 1
  0x4348ab		48d1eb			SHRQ $0x1, BX		
		for n2 > _FixedStack {
  0x4348ae		4881fb00080000		CMPQ $0x800, BX		
  0x4348b5		77f2			JA 0x4348a9		
  0x4348b7		408874241f		MOVB SI, 0x1f(SP)	
		c := gp.m.mcache
  0x4348bc		488b4030		MOVQ 0x30(AX), AX	
  0x4348c0		488b9860010000		MOVQ 0x160(AX), BX	
		if stackNoCache != 0 || c == nil || gp.m.preemptoff != "" || gp.m.helpgc != 0 {
  0x4348c7		4885db			TESTQ BX, BX		
  0x4348ca		740c			JE 0x4348d8		
  0x4348cc		488bb8f8000000		MOVQ 0xf8(AX), DI	
  0x4348d3		4885ff			TESTQ DI, DI		
  0x4348d6		7441			JE 0x434919		
			lock(&stackpoolmu)
  0x4348d8		488d05f1f00800		LEAQ runtime.stackpoolmu(SB), AX	
  0x4348df		48890424		MOVQ AX, 0(SP)				
  0x4348e3		e8384cfdff		CALL runtime.lock(SB)			
  0x4348e8		488b442468		MOVQ 0x68(SP), AX			
			stackpoolfree(x, order)
  0x4348ed		48890424		MOVQ AX, 0(SP)			
  0x4348f1		0fb644241f		MOVZX 0x1f(SP), AX		
  0x4348f6		88442408		MOVB AL, 0x8(SP)		
  0x4348fa		e8a1f7ffff		CALL runtime.stackpoolfree(SB)	
			unlock(&stackpoolmu)
  0x4348ff		488d05caf00800		LEAQ runtime.stackpoolmu(SB), AX	
  0x434906		48890424		MOVQ AX, 0(SP)				
  0x43490a		e8b14dfdff		CALL runtime.unlock(SB)			
  0x43490f		488b6c2458		MOVQ 0x58(SP), BP			
  0x434914		4883c460		ADDQ $0x60, SP				
  0x434918		c3			RET					
		if stackNoCache != 0 || c == nil || gp.m.preemptoff != "" || gp.m.helpgc != 0 {
  0x434919		8b8010010000		MOVL 0x110(AX), AX	
  0x43491f		85c0			TESTL AX, AX		
  0x434921		75b5			JNE 0x4348d8		
			if c.stackcache[order].size >= _StackCacheSize {
  0x434923		400fb6c6		MOVZX SI, AX			
  0x434927		4883f804		CMPQ $0x4, AX			
  0x43492b		0f83c7010000		JAE 0x434af8			
  0x434931		48c1e004		SHLQ $0x4, AX			
  0x434935		488bbc0360040000	MOVQ 0x460(BX)(AX*1), DI	
  0x43493d		4881ff00800000		CMPQ $0x8000, DI		
  0x434944		732b			JAE 0x434971			
  0x434946		4889d6			MOVQ DX, SI			
			x.ptr().next = c.stackcache[order].list
  0x434949		488bbc0358040000	MOVQ 0x458(BX)(AX*1), DI	
  0x434951		48893a			MOVQ DI, 0(DX)			
			c.stackcache[order].list = x
  0x434954		4889b40358040000	MOVQ SI, 0x458(BX)(AX*1)	
			c.stackcache[order].size += n
  0x43495c		488b940360040000	MOVQ 0x460(BX)(AX*1), DX	
  0x434964		4801d1			ADDQ DX, CX			
  0x434967		48898c0360040000	MOVQ CX, 0x460(BX)(AX*1)	
  0x43496f		eb9e			JMP 0x43490f			
  0x434971		48894c2438		MOVQ CX, 0x38(SP)		
  0x434976		48895c2450		MOVQ BX, 0x50(SP)		
  0x43497b		4889442430		MOVQ AX, 0x30(SP)		
				stackcacherelease(c, order)
  0x434980		48891c24		MOVQ BX, 0(SP)				
  0x434984		4088742408		MOVB SI, 0x8(SP)			
  0x434989		e882f9ffff		CALL runtime.stackcacherelease(SB)	
  0x43498e		488b442430		MOVQ 0x30(SP), AX			
  0x434993		488b4c2438		MOVQ 0x38(SP), CX			
  0x434998		488b542468		MOVQ 0x68(SP), DX			
  0x43499d		488b5c2450		MOVQ 0x50(SP), BX			
  0x4349a2		eba2			JMP 0x434946				
	p -= h.arena_start
  0x4349a4		488b051d8c0700		MOVQ runtime.mheap_+4904(SB), AX	
  0x4349ab		4829c2			SUBQ AX, DX				
	return h.spans[p>>_PageShift]
  0x4349ae		488b053b890700		MOVQ runtime.mheap_+4176(SB), AX	
  0x4349b5		488b1d2c890700		MOVQ runtime.mheap_+4168(SB), BX	
  0x4349bc		48c1ea0d		SHRQ $0xd, DX				
  0x4349c0		4839c2			CMPQ AX, DX				
  0x4349c3		0f8328010000		JAE 0x434af1				
  0x4349c9		488b04d3		MOVQ 0(BX)(DX*8), AX			
		if s.state != _MSpanManual {
  0x4349cd		0fb65064		MOVZX 0x64(AX), DX	
  0x4349d1		80fa02			CMPL $0x2, DL		
  0x4349d4		0f85be000000		JNE 0x434a98		
		if gcphase == _GCoff {
  0x4349da		8b0dfcee0800		MOVL runtime.gcphase(SB), CX	
  0x4349e0		85c9			TESTL CX, CX			
  0x4349e2		7526			JNE 0x434a0a			
			mheap_.freeManual(s, &memstats.stacks_inuse)
  0x4349e4		488d0db5780700		LEAQ runtime.mheap_(SB), CX		
  0x4349eb		48890c24		MOVQ CX, 0(SP)				
  0x4349ef		4889442408		MOVQ AX, 0x8(SP)			
  0x4349f4		488d0565fd0800		LEAQ runtime.memstats+96(SB), AX	
  0x4349fb		4889442410		MOVQ AX, 0x10(SP)			
  0x434a00		e8fb6afeff		CALL runtime.(*mheap).freeManual(SB)	
  0x434a05		e905ffffff		JMP 0x43490f				
  0x434a0a		4889442448		MOVQ AX, 0x48(SP)			
			log2npage := stacklog2(s.npages)
  0x434a0f		488b4820		MOVQ 0x20(AX), CX		
  0x434a13		48890c24		MOVQ CX, 0(SP)			
  0x434a17		e884f4ffff		CALL runtime.stacklog2(SB)	
  0x434a1c		488b442408		MOVQ 0x8(SP), AX		
  0x434a21		4889442428		MOVQ AX, 0x28(SP)		
			lock(&stackLarge.lock)
  0x434a26		488d0db3310700		LEAQ runtime.stackLarge(SB), CX	
  0x434a2d		48890c24		MOVQ CX, 0(SP)			
  0x434a31		e8ea4afdff		CALL runtime.lock(SB)		
  0x434a36		488b442428		MOVQ 0x28(SP), AX		
			stackLarge.free[log2npage].insert(s)
  0x434a3b		4883f81a		CMPQ $0x1a, AX				
  0x434a3f		7350			JAE 0x434a91				
  0x434a41		48c1e004		SHLQ $0x4, AX				
  0x434a45		488d0d94310700		LEAQ runtime.stackLarge(SB), CX		
  0x434a4c		488d440108		LEAQ 0x8(CX)(AX*1), AX			
  0x434a51		48890424		MOVQ AX, 0(SP)				
  0x434a55		488b442448		MOVQ 0x48(SP), AX			
  0x434a5a		4889442408		MOVQ AX, 0x8(SP)			
  0x434a5f		e8ec77feff		CALL runtime.(*mSpanList).insert(SB)	
			unlock(&stackLarge.lock)
  0x434a64		488d0575310700		LEAQ runtime.stackLarge(SB), AX	
  0x434a6b		48890424		MOVQ AX, 0(SP)			
  0x434a6f		e84c4cfdff		CALL runtime.unlock(SB)		
  0x434a74		e996feffff		JMP 0x43490f			
			sysFault(v, n)
  0x434a79		48890c24		MOVQ CX, 0(SP)			
  0x434a7d		48895c2408		MOVQ BX, 0x8(SP)		
  0x434a82		e809a9fdff		CALL runtime.sysFault(SB)	
		return
  0x434a87		488b6c2458		MOVQ 0x58(SP), BP	
  0x434a8c		4883c460		ADDQ $0x60, SP		
  0x434a90		c3			RET			
			stackLarge.free[log2npage].insert(s)
  0x434a91		e8aaaffeff		CALL runtime.panicindex(SB)	
  0x434a96		0f0b			UD2				
  0x434a98		48894c2440		MOVQ CX, 0x40(SP)		
	return s.startAddr
  0x434a9d		488b4018		MOVQ 0x18(AX), AX	
  0x434aa1		4889442420		MOVQ AX, 0x20(SP)	
			println(hex(s.base()), v)
  0x434aa6		e855d0feff		CALL runtime.printlock(SB)	
  0x434aab		488b442420		MOVQ 0x20(SP), AX		
  0x434ab0		48890424		MOVQ AX, 0(SP)			
  0x434ab4		e837d8feff		CALL runtime.printhex(SB)	
  0x434ab9		e882d2feff		CALL runtime.printsp(SB)	
  0x434abe		488b442440		MOVQ 0x40(SP), AX		
  0x434ac3		48890424		MOVQ AX, 0(SP)			
  0x434ac7		e834d9feff		CALL runtime.printpointer(SB)	
  0x434acc		e8bfd2feff		CALL runtime.printnl(SB)	
  0x434ad1		e8aad0feff		CALL runtime.printunlock(SB)	
			throw("bad span state")
  0x434ad6		488d059b5d0300		LEAQ 0x35d9b(IP), AX	
  0x434add		48890424		MOVQ AX, 0(SP)		
  0x434ae1		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x434aea		e8e1c6feff		CALL runtime.throw(SB)	
  0x434aef		0f0b			UD2			
	return h.spans[p>>_PageShift]
  0x434af1		e84aaffeff		CALL runtime.panicindex(SB)	
  0x434af6		0f0b			UD2				
			if c.stackcache[order].size >= _StackCacheSize {
  0x434af8		e843affeff		CALL runtime.panicindex(SB)	
  0x434afd		0f0b			UD2				
		throw("bad stack size")
  0x434aff		488d05805d0300		LEAQ 0x35d80(IP), AX	
  0x434b06		48890424		MOVQ AX, 0(SP)		
  0x434b0a		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x434b13		e8b8c6feff		CALL runtime.throw(SB)	
  0x434b18		0f0b			UD2			
		throw("stack not a power of 2")
  0x434b1a		488d05476a0300		LEAQ 0x36a47(IP), AX	
  0x434b21		48890424		MOVQ AX, 0(SP)		
  0x434b25		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x434b2e		e89dc6feff		CALL runtime.throw(SB)	
  0x434b33		0f0b			UD2			
func stackfree(stk stack) {
  0x434b35		e8c6210000		CALL runtime.morestackc(SB)	
  0x434b3a		e9f1fcffff		JMP runtime.stackfree(SB)	

TEXT runtime.adjustpointers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func adjustpointers(scanp unsafe.Pointer, cbv *bitvector, adjinfo *adjustinfo, f funcInfo) {
  0x434b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434b49		483b6110		CMPQ 0x10(CX), SP	
  0x434b4d		0f8637020000		JBE 0x434d8a		
  0x434b53		4883ec68		SUBQ $0x68, SP		
  0x434b57		48896c2460		MOVQ BP, 0x60(SP)	
  0x434b5c		488d6c2460		LEAQ 0x60(SP), BP	
  0x434b61		488b542478		MOVQ 0x78(SP), DX	
	bv := gobv(*cbv)
  0x434b66		488b5a08		MOVQ 0x8(DX), BX	
		(*[1 << 30]byte)(unsafe.Pointer(bv.bytedata))[:(bv.n+7)/8],
  0x434b6a		8403			TESTB AL, 0(BX)		
	bv := gobv(*cbv)
  0x434b6c		8b12			MOVL 0(DX), DX		
		(*[1 << 30]byte)(unsafe.Pointer(bv.bytedata))[:(bv.n+7)/8],
  0x434b6e		8d7207			LEAL 0x7(DX), SI	
  0x434b71		c1fe1f			SARL $0x1f, SI		
  0x434b74		c1ee1d			SHRL $0x1d, SI		
  0x434b77		01d6			ADDL DX, SI		
  0x434b79		83c607			ADDL $0x7, SI		
  0x434b7c		c1fe03			SARL $0x3, SI		
  0x434b7f		4863f6			MOVSXD SI, SI		
  0x434b82		4881fe00000040		CMPQ $0x40000000, SI	
  0x434b89		0f87f4010000		JA 0x434d83		
		uintptr(bv.n),
  0x434b8f		4863d2			MOVSXD DX, DX		
	bv := gobv(*cbv)
  0x434b92		4889542440		MOVQ DX, 0x40(SP)		
  0x434b97		48895c2448		MOVQ BX, 0x48(SP)		
  0x434b9c		4889742450		MOVQ SI, 0x50(SP)		
  0x434ba1		48c744245800000040	MOVQ $0x40000000, 0x58(SP)	
  0x434baa		488b942480000000	MOVQ 0x80(SP), DX		
	minp := adjinfo.old.lo
  0x434bb2		488b1a			MOVQ 0(DX), BX		
	maxp := adjinfo.old.hi
  0x434bb5		488b7208		MOVQ 0x8(DX), SI	
	delta := adjinfo.delta
  0x434bb9		488b7a10		MOVQ 0x10(DX), DI	
	num := bv.n
  0x434bbd		4c8b442440		MOVQ 0x40(SP), R8	
  0x434bc2		4c8b4c2470		MOVQ 0x70(SP), R9	
  0x434bc7		4d89ca			MOVQ R9, R10		
	useCAS := uintptr(scanp) < adjinfo.sghi
  0x434bca		488b9218010000		MOVQ 0x118(DX), DX	
  0x434bd1		4939d1			CMPQ DX, R9		
  0x434bd4		4c8b9c2488000000	MOVQ 0x88(SP), R11	
  0x434bdc		31c0			XORL AX, AX		
	for i := uintptr(0); i < num; i++ {
  0x434bde		eb04			JMP 0x434be4		
  0x434be0		498d4501		LEAQ 0x1(R13), AX	
  0x434be4		4c39c0			CMPQ R8, AX		
  0x434be7		0f8394000000		JAE 0x434c81		
	return (bv.bytedata[i/8] >> (i % 8)) & 1
  0x434bed		4c8b642448		MOVQ 0x48(SP), R12	
  0x434bf2		4c8b6c2450		MOVQ 0x50(SP), R13	
  0x434bf7		4889c1			MOVQ AX, CX		
  0x434bfa		48c1e803		SHRQ $0x3, AX		
  0x434bfe		4c39e8			CMPQ R13, AX		
  0x434c01		0f8375010000		JAE 0x434d7c		
  0x434c07		450fb62404		MOVZX 0(R12)(AX*1), R12	
  0x434c0c		4989cd			MOVQ CX, R13		
  0x434c0f		4883e107		ANDQ $0x7, CX		
  0x434c13		41d2ec			SHRL CL, R12		
  0x434c16		4183e401		ANDL $0x1, R12		
		if ptrbit(&bv, i) != 1 {
  0x434c1a		4180fc01		CMPL $0x1, R12		
  0x434c1e		75c0			JNE 0x434be0		
	return unsafe.Pointer(uintptr(p) + x)
  0x434c20		4f8d24ea		LEAQ 0(R10)(R13*8), R12	
		p := *pp
  0x434c24		41840424		TESTB AL, 0(R12)	
  0x434c28		4b8b04ea		MOVQ 0(R10)(R13*8), AX	
	return f._func != nil
  0x434c2c		4d85db			TESTQ R11, R11		
		if f.valid() && 0 < p && p < minLegalPointer && debug.invalidptr != 0 {
  0x434c2f		7419			JE 0x434c4a			
  0x434c31		4885c0			TESTQ AX, AX			
  0x434c34		7614			JBE 0x434c4a			
  0x434c36		483d00100000		CMPQ $0x1000, AX		
  0x434c3c		730c			JAE 0x434c4a			
  0x434c3e		448b359fee0800		MOVL runtime.debug+36(SB), R14	
  0x434c45		4585f6			TESTL R14, R14			
  0x434c48		7541			JNE 0x434c8b			
		if minp <= p && p < maxp {
  0x434c4a		4839c3			CMPQ AX, BX		
  0x434c4d		7791			JA 0x434be0		
  0x434c4f		4839f0			CMPQ SI, AX		
  0x434c52		738c			JAE 0x434be0		
	useCAS := uintptr(scanp) < adjinfo.sghi
  0x434c54		4939d1			CMPQ DX, R9		
			if useCAS {
  0x434c57		731b			JAE 0x434c74		
  0x434c59		4989c6			MOVQ AX, R14		
				if !atomic.Casp1(ppu, unsafe.Pointer(p), unsafe.Pointer(p+delta)) {
  0x434c5c		4901fe			ADDQ DI, R14			
  0x434c5f		f04d0fb13424		LOCK CMPXCHGQ R14, 0(R12)	
  0x434c65		410f94c6		SETE R14			
  0x434c69		4584f6			TESTL R14, R14			
  0x434c6c		0f856effffff		JNE 0x434be0			
  0x434c72		ebb0			JMP 0x434c24			
				*pp = p + delta
  0x434c74		4c8d2438		LEAQ 0(AX)(DI*1), R12	
  0x434c78		4f8924ea		MOVQ R12, 0(R10)(R13*8)	
  0x434c7c		e95fffffff		JMP 0x434be0		
  0x434c81		488b6c2460		MOVQ 0x60(SP), BP	
  0x434c86		4883c468		ADDQ $0x68, SP		
  0x434c8a		c3			RET			
  0x434c8b		4c89642438		MOVQ R12, 0x38(SP)	
  0x434c90		4889442420		MOVQ AX, 0x20(SP)	
			getg().m.traceback = 2
  0x434c95		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x434c9e		488b4030		MOVQ 0x30(AX), AX	
  0x434ca2		c6802901000002		MOVB $0x2, 0x129(AX)	
			print("runtime: bad pointer in frame ", funcname(f), " at ", pp, ": ", hex(p), "\n")
  0x434ca9		4c891c24		MOVQ R11, 0(SP)			
  0x434cad		488b842490000000	MOVQ 0x90(SP), AX		
  0x434cb5		4889442408		MOVQ AX, 0x8(SP)		
  0x434cba		e8413c0000		CALL runtime.funcname(SB)	
  0x434cbf		488b442410		MOVQ 0x10(SP), AX		
  0x434cc4		4889442430		MOVQ AX, 0x30(SP)		
  0x434cc9		488b4c2418		MOVQ 0x18(SP), CX		
  0x434cce		48894c2428		MOVQ CX, 0x28(SP)		
  0x434cd3		e828cefeff		CALL runtime.printlock(SB)	
  0x434cd8		488d05b8780300		LEAQ 0x378b8(IP), AX		
  0x434cdf		48890424		MOVQ AX, 0(SP)			
  0x434ce3		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x434cec		e84fd7feff		CALL runtime.printstring(SB)	
  0x434cf1		488b442430		MOVQ 0x30(SP), AX		
  0x434cf6		48890424		MOVQ AX, 0(SP)			
  0x434cfa		488b442428		MOVQ 0x28(SP), AX		
  0x434cff		4889442408		MOVQ AX, 0x8(SP)		
  0x434d04		e837d7feff		CALL runtime.printstring(SB)	
  0x434d09		488d05ae4f0300		LEAQ 0x34fae(IP), AX		
  0x434d10		48890424		MOVQ AX, 0(SP)			
  0x434d14		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x434d1d		e81ed7feff		CALL runtime.printstring(SB)	
  0x434d22		488b442438		MOVQ 0x38(SP), AX		
  0x434d27		48890424		MOVQ AX, 0(SP)			
  0x434d2b		e8d0d6feff		CALL runtime.printpointer(SB)	
  0x434d30		488d05394f0300		LEAQ 0x34f39(IP), AX		
  0x434d37		48890424		MOVQ AX, 0(SP)			
  0x434d3b		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x434d44		e8f7d6feff		CALL runtime.printstring(SB)	
  0x434d49		488b442420		MOVQ 0x20(SP), AX		
  0x434d4e		48890424		MOVQ AX, 0(SP)			
  0x434d52		e899d5feff		CALL runtime.printhex(SB)	
  0x434d57		e834d0feff		CALL runtime.printnl(SB)	
  0x434d5c		e81fcefeff		CALL runtime.printunlock(SB)	
			throw("invalid pointer found on stack")
  0x434d61		488d05f3770300		LEAQ 0x377f3(IP), AX	
  0x434d68		48890424		MOVQ AX, 0(SP)		
  0x434d6c		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x434d75		e856c4feff		CALL runtime.throw(SB)	
  0x434d7a		0f0b			UD2			
	return (bv.bytedata[i/8] >> (i % 8)) & 1
  0x434d7c		e8bfacfeff		CALL runtime.panicindex(SB)	
  0x434d81		0f0b			UD2				
		(*[1 << 30]byte)(unsafe.Pointer(bv.bytedata))[:(bv.n+7)/8],
  0x434d83		e828adfeff		CALL runtime.panicslice(SB)	
  0x434d88		0f0b			UD2				
func adjustpointers(scanp unsafe.Pointer, cbv *bitvector, adjinfo *adjustinfo, f funcInfo) {
  0x434d8a		e8e1f70000		CALL runtime.morestack_noctxt(SB)	
  0x434d8f		e9acfdffff		JMP runtime.adjustpointers(SB)		

TEXT runtime.adjustframe(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func adjustframe(frame *stkframe, arg unsafe.Pointer) bool {
  0x434da0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434da9		488d4424d0		LEAQ -0x30(SP), AX	
  0x434dae		483b4110		CMPQ 0x10(CX), AX	
  0x434db2		0f8626080000		JBE 0x4355de		
  0x434db8		4881ecb0000000		SUBQ $0xb0, SP		
  0x434dbf		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x434dc7		488dac24a8000000	LEAQ 0xa8(SP), BP	
  0x434dcf		0f57c0			XORPS X0, X0		
  0x434dd2		0f11842488000000	MOVUPS X0, 0x88(SP)	
  0x434dda		488b8424b8000000	MOVQ 0xb8(SP), AX	
	targetpc := frame.continpc
  0x434de2		488b4818		MOVQ 0x18(AX), CX	
	if targetpc == 0 {
  0x434de6		4885c9			TESTQ CX, CX		
  0x434de9		0f84fb020000		JE 0x4350ea		
	f := frame.fn
  0x434def		488b10			MOVQ 0(AX), DX		
  0x434df2		488b5808		MOVQ 0x8(AX), BX	
	if f.funcID == funcID_systemstack_switch {
  0x434df6		8b7210			MOVL 0x10(DX), SI	
  0x434df9		83fe0e			CMPL $0xe, SI		
  0x434dfc		0f84d0020000		JE 0x4350d2		
	if targetpc != f.entry {
  0x434e02		488b32			MOVQ 0(DX), SI		
  0x434e05		4839f1			CMPQ SI, CX		
  0x434e08		7403			JE 0x434e0d		
		targetpc--
  0x434e0a		48ffc9			DECQ CX			
  0x434e0d		48894c2438		MOVQ CX, 0x38(SP)	
  0x434e12		48899c2480000000	MOVQ BX, 0x80(SP)	
  0x434e1a		4889542478		MOVQ DX, 0x78(SP)	
  0x434e1f		488b8424c0000000	MOVQ 0xc0(SP), AX	
	pcdata := pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, &adjinfo.cache)
  0x434e27		8400			TESTB AL, 0(AX)			
  0x434e29		488d7018		LEAQ 0x18(AX), SI		
  0x434e2d		4889742420		MOVQ SI, 0x20(SP)		
  0x434e32		48891424		MOVQ DX, 0(SP)			
  0x434e36		48895c2408		MOVQ BX, 0x8(SP)		
  0x434e3b		c744241000000000	MOVL $0x0, 0x10(SP)		
  0x434e43		48894c2418		MOVQ CX, 0x18(SP)		
  0x434e48		e8f33f0000		CALL runtime.pcdatavalue(SB)	
  0x434e4d		8b442428		MOVL 0x28(SP), AX		
	if pcdata == -1 {
  0x434e51		83f8ff			CMPL $-0x1, AX		
  0x434e54		7502			JNE 0x434e58		
  0x434e56		31c0			XORL AX, AX		
	size := frame.varp - frame.sp
  0x434e58		89442434		MOVL AX, 0x34(SP)	
  0x434e5c		488b8c24b8000000	MOVQ 0xb8(SP), CX	
  0x434e64		488b5138		MOVQ 0x38(CX), DX	
  0x434e68		482b5128		SUBQ 0x28(CX), DX	
	if size > minsize {
  0x434e6c		4885d2			TESTQ DX, DX		
  0x434e6f		0f8762010000		JA 0x434fd7		
	if sys.ArchFamily == sys.AMD64 && frame.argp-frame.varp == 2*sys.RegSize {
  0x434e75		488b5140		MOVQ 0x40(CX), DX	
  0x434e79		488b5938		MOVQ 0x38(CX), BX	
  0x434e7d		4829da			SUBQ BX, DX		
  0x434e80		4883fa10		CMPQ $0x10, DX		
  0x434e84		0f8540010000		JNE 0x434fca		
		if !framepointer_enabled {
  0x434e8a		0fb61506fc0300		MOVZX 0x3fc06(IP), DX	
  0x434e91		84d2			TESTL DL, DL		
  0x434e93		0f847d040000		JE 0x435316		
	p := *pp
  0x434e99		488b13			MOVQ 0(BX), DX		
  0x434e9c		488bb424c0000000	MOVQ 0xc0(SP), SI	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x434ea4		488b3e			MOVQ 0(SI), DI		
  0x434ea7		4839d7			CMPQ DX, DI		
  0x434eaa		7713			JA 0x434ebf		
  0x434eac		488b7e08		MOVQ 0x8(SI), DI	
  0x434eb0		4839fa			CMPQ DI, DX		
  0x434eb3		730a			JAE 0x434ebf		
		*pp = p + adjinfo.delta
  0x434eb5		488b7e10		MOVQ 0x10(SI), DI	
  0x434eb9		4801fa			ADDQ DI, DX		
  0x434ebc		488913			MOVQ DX, 0(BX)		
	if frame.arglen > 0 {
  0x434ebf		488b5148		MOVQ 0x48(CX), DX	
  0x434ec3		4885d2			TESTQ DX, DX		
  0x434ec6		765c			JBE 0x434f24		
		var bv bitvector
  0x434ec8		c784249800000000000000		MOVL $0x0, 0x98(SP)	
  0x434ed3		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)	
		if frame.argmap != nil {
  0x434edf		488b5150		MOVQ 0x50(CX), DX	
  0x434ee3		4885d2			TESTQ DX, DX		
  0x434ee6		7454			JE 0x434f3c		
			bv = *frame.argmap
  0x434ee8		488b4208		MOVQ 0x8(DX), AX	
  0x434eec		8b12			MOVL 0(DX), DX		
  0x434eee		89942498000000		MOVL DX, 0x98(SP)	
  0x434ef5		48898424a0000000	MOVQ AX, 0xa0(SP)	
		adjustpointers(unsafe.Pointer(frame.argp), &bv, adjinfo, funcInfo{})
  0x434efd		488b4140		MOVQ 0x40(CX), AX		
  0x434f01		48890424		MOVQ AX, 0(SP)			
  0x434f05		488d842498000000	LEAQ 0x98(SP), AX		
  0x434f0d		4889442408		MOVQ AX, 0x8(SP)		
  0x434f12		4889742410		MOVQ SI, 0x10(SP)		
  0x434f17		0f57c0			XORPS X0, X0			
  0x434f1a		0f11442418		MOVUPS X0, 0x18(SP)		
  0x434f1f		e81cfcffff		CALL runtime.adjustpointers(SB)	
	return true
  0x434f24		c68424c800000001	MOVB $0x1, 0xc8(SP)	
  0x434f2c		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x434f34		4881c4b0000000		ADDQ $0xb0, SP		
  0x434f3b		c3			RET			
  0x434f3c		488b442478		MOVQ 0x78(SP), AX	
			stackmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
  0x434f41		48890424		MOVQ AX, 0(SP)			
  0x434f45		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x434f4d		48894c2408		MOVQ CX, 0x8(SP)		
  0x434f52		c744241000000000	MOVL $0x0, 0x10(SP)		
  0x434f5a		e8913f0000		CALL runtime.funcdata(SB)	
  0x434f5f		488b442418		MOVQ 0x18(SP), AX		
			if stackmap == nil || stackmap.n <= 0 {
  0x434f64		4885c0			TESTQ AX, AX		
  0x434f67		0f84b7020000		JE 0x435224		
  0x434f6d		8b08			MOVL 0(AX), CX		
  0x434f6f		85c9			TESTL CX, CX		
  0x434f71		0f8ead020000		JLE 0x435224		
  0x434f77		4889442470		MOVQ AX, 0x70(SP)	
  0x434f7c		8b542434		MOVL 0x34(SP), DX	
			if pcdata < 0 || pcdata >= stackmap.n {
  0x434f80		85d2			TESTL DX, DX		
  0x434f82		0f8c7a010000		JL 0x435102		
  0x434f88		39ca			CMPL CX, DX		
  0x434f8a		0f8d72010000		JGE 0x435102		
			bv = stackmapdata(stackmap, pcdata)
  0x434f90		48890424		MOVQ AX, 0(SP)			
  0x434f94		89542408		MOVL DX, 0x8(SP)		
  0x434f98		e853420000		CALL runtime.stackmapdata(SB)	
  0x434f9d		488b442418		MOVQ 0x18(SP), AX		
  0x434fa2		8b4c2410		MOVL 0x10(SP), CX		
  0x434fa6		898c2498000000		MOVL CX, 0x98(SP)		
  0x434fad		48898424a0000000	MOVQ AX, 0xa0(SP)		
  0x434fb5		488b8c24b8000000	MOVQ 0xb8(SP), CX		
  0x434fbd		488bb424c0000000	MOVQ 0xc0(SP), SI		
  0x434fc5		e933ffffff		JMP 0x434efd			
  0x434fca		488bb424c0000000	MOVQ 0xc0(SP), SI		
	if sys.ArchFamily == sys.AMD64 && frame.argp-frame.varp == 2*sys.RegSize {
  0x434fd2		e9e8feffff		JMP 0x434ebf		
  0x434fd7		4889542440		MOVQ DX, 0x40(SP)	
		var bv bitvector
  0x434fdc		c784248800000000000000		MOVL $0x0, 0x88(SP)	
  0x434fe7		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x434ff3		488b442478			MOVQ 0x78(SP), AX	
		stackmap := (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps))
  0x434ff8		48890424		MOVQ AX, 0(SP)			
  0x434ffc		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x435004		48894c2408		MOVQ CX, 0x8(SP)		
  0x435009		c744241001000000	MOVL $0x1, 0x10(SP)		
  0x435011		e8da3e0000		CALL runtime.funcdata(SB)	
  0x435016		488b442418		MOVQ 0x18(SP), AX		
		if stackmap == nil || stackmap.n <= 0 {
  0x43501b		4885c0			TESTQ AX, AX		
  0x43501e		0f84c9040000		JE 0x4354ed		
  0x435024		8b08			MOVL 0(AX), CX		
  0x435026		85c9			TESTL CX, CX		
  0x435028		0f8ebf040000		JLE 0x4354ed		
  0x43502e		4889442470		MOVQ AX, 0x70(SP)	
  0x435033		8b542434		MOVL 0x34(SP), DX	
		if pcdata < 0 || pcdata >= stackmap.n {
  0x435037		85d2			TESTL DX, DX		
  0x435039		0f8c8c030000		JL 0x4353cb		
  0x43503f		39ca			CMPL CX, DX		
  0x435041		0f8d84030000		JGE 0x4353cb		
		bv = stackmapdata(stackmap, pcdata)
  0x435047		48890424		MOVQ AX, 0(SP)			
  0x43504b		89542408		MOVL DX, 0x8(SP)		
  0x43504f		e89c410000		CALL runtime.stackmapdata(SB)	
  0x435054		488b442418		MOVQ 0x18(SP), AX		
  0x435059		8b4c2410		MOVL 0x10(SP), CX		
  0x43505d		898c2488000000		MOVL CX, 0x88(SP)		
  0x435064		4889842490000000	MOVQ AX, 0x90(SP)		
		size = uintptr(bv.n) * sys.PtrSize
  0x43506c		4863842488000000	MOVSXD 0x88(SP), AX	
  0x435074		48c1e003		SHLQ $0x3, AX		
  0x435078		488b8c24b8000000	MOVQ 0xb8(SP), CX	
		adjustpointers(unsafe.Pointer(frame.varp-size), &bv, adjinfo, f)
  0x435080		488b5138		MOVQ 0x38(CX), DX		
  0x435084		4829c2			SUBQ AX, DX			
  0x435087		48891424		MOVQ DX, 0(SP)			
  0x43508b		488d842488000000	LEAQ 0x88(SP), AX		
  0x435093		4889442408		MOVQ AX, 0x8(SP)		
  0x435098		488b8424c0000000	MOVQ 0xc0(SP), AX		
  0x4350a0		4889442410		MOVQ AX, 0x10(SP)		
  0x4350a5		488b542478		MOVQ 0x78(SP), DX		
  0x4350aa		4889542418		MOVQ DX, 0x18(SP)		
  0x4350af		488b9c2480000000	MOVQ 0x80(SP), BX		
  0x4350b7		48895c2420		MOVQ BX, 0x20(SP)		
  0x4350bc		e87ffaffff		CALL runtime.adjustpointers(SB)	
  0x4350c1		8b442434		MOVL 0x34(SP), AX		
  0x4350c5		488b8c24b8000000	MOVQ 0xb8(SP), CX		
  0x4350cd		e9a3fdffff		JMP 0x434e75			
		return true
  0x4350d2		c68424c800000001	MOVB $0x1, 0xc8(SP)	
  0x4350da		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x4350e2		4881c4b0000000		ADDQ $0xb0, SP		
  0x4350e9		c3			RET			
		return true
  0x4350ea		c68424c800000001	MOVB $0x1, 0xc8(SP)	
  0x4350f2		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x4350fa		4881c4b0000000		ADDQ $0xb0, SP		
  0x435101		c3			RET			
  0x435102		488b442478		MOVQ 0x78(SP), AX	
				print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " args stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
  0x435107		48890424		MOVQ AX, 0(SP)			
  0x43510b		488b842480000000	MOVQ 0x80(SP), AX		
  0x435113		4889442408		MOVQ AX, 0x8(SP)		
  0x435118		e8e3370000		CALL runtime.funcname(SB)	
  0x43511d		488b442470		MOVQ 0x70(SP), AX		
  0x435122		486300			MOVSXD 0(AX), AX		
  0x435125		4889442460		MOVQ AX, 0x60(SP)		
  0x43512a		488b4c2410		MOVQ 0x10(SP), CX		
  0x43512f		48894c2468		MOVQ CX, 0x68(SP)		
  0x435134		488b542418		MOVQ 0x18(SP), DX		
  0x435139		4889542458		MOVQ DX, 0x58(SP)		
  0x43513e		e8bdc9feff		CALL runtime.printlock(SB)	
  0x435143		488d05205e0300		LEAQ 0x35e20(IP), AX		
  0x43514a		48890424		MOVQ AX, 0(SP)			
  0x43514e		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x435157		e8e4d2feff		CALL runtime.printstring(SB)	
  0x43515c		8b442434		MOVL 0x34(SP), AX		
  0x435160		4863c0			MOVSXD AX, AX			
  0x435163		48890424		MOVQ AX, 0(SP)			
  0x435167		e814d1feff		CALL runtime.printint(SB)	
  0x43516c		488d05e14b0300		LEAQ 0x34be1(IP), AX		
  0x435173		48890424		MOVQ AX, 0(SP)			
  0x435177		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x435180		e8bbd2feff		CALL runtime.printstring(SB)	
  0x435185		488b442460		MOVQ 0x60(SP), AX		
  0x43518a		48890424		MOVQ AX, 0(SP)			
  0x43518e		e8edd0feff		CALL runtime.printint(SB)	
  0x435193		488d05e86d0300		LEAQ 0x36de8(IP), AX		
  0x43519a		48890424		MOVQ AX, 0(SP)			
  0x43519e		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x4351a7		e894d2feff		CALL runtime.printstring(SB)	
  0x4351ac		488b442468		MOVQ 0x68(SP), AX		
  0x4351b1		48890424		MOVQ AX, 0(SP)			
  0x4351b5		488b442458		MOVQ 0x58(SP), AX		
  0x4351ba		4889442408		MOVQ AX, 0x8(SP)		
  0x4351bf		e87cd2feff		CALL runtime.printstring(SB)	
  0x4351c4		488d05d8510300		LEAQ 0x351d8(IP), AX		
  0x4351cb		48890424		MOVQ AX, 0(SP)			
  0x4351cf		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x4351d8		e863d2feff		CALL runtime.printstring(SB)	
  0x4351dd		488b442438		MOVQ 0x38(SP), AX		
  0x4351e2		48890424		MOVQ AX, 0(SP)			
  0x4351e6		e885cffeff		CALL runtime.printuint(SB)	
  0x4351eb		488d05784a0300		LEAQ 0x34a78(IP), AX		
  0x4351f2		48890424		MOVQ AX, 0(SP)			
  0x4351f6		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4351ff		e83cd2feff		CALL runtime.printstring(SB)	
  0x435204		e877c9feff		CALL runtime.printunlock(SB)	
				throw("bad symbol table")
  0x435209		488d05a2580300		LEAQ 0x358a2(IP), AX	
  0x435210		48890424		MOVQ AX, 0(SP)		
  0x435214		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x43521d		e8aebffeff		CALL runtime.throw(SB)	
  0x435222		0f0b			UD2			
  0x435224		488b442478		MOVQ 0x78(SP), AX	
				print("runtime: frame ", funcname(f), " untyped args ", frame.argp, "+", frame.arglen, "\n")
  0x435229		48890424		MOVQ AX, 0(SP)			
  0x43522d		488b842480000000	MOVQ 0x80(SP), AX		
  0x435235		4889442408		MOVQ AX, 0x8(SP)		
  0x43523a		e8c1360000		CALL runtime.funcname(SB)	
  0x43523f		488b442418		MOVQ 0x18(SP), AX		
  0x435244		4889442458		MOVQ AX, 0x58(SP)		
  0x435249		488b4c2410		MOVQ 0x10(SP), CX		
  0x43524e		48894c2468		MOVQ CX, 0x68(SP)		
  0x435253		488b9424b8000000	MOVQ 0xb8(SP), DX		
  0x43525b		488b5a40		MOVQ 0x40(DX), BX		
  0x43525f		48895c2450		MOVQ BX, 0x50(SP)		
  0x435264		488b5248		MOVQ 0x48(DX), DX		
  0x435268		4889542448		MOVQ DX, 0x48(SP)		
  0x43526d		e88ec8feff		CALL runtime.printlock(SB)	
  0x435272		488d053d570300		LEAQ 0x3573d(IP), AX		
  0x435279		48890424		MOVQ AX, 0(SP)			
  0x43527d		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x435286		e8b5d1feff		CALL runtime.printstring(SB)	
  0x43528b		488b442468		MOVQ 0x68(SP), AX		
  0x435290		48890424		MOVQ AX, 0(SP)			
  0x435294		488b442458		MOVQ 0x58(SP), AX		
  0x435299		4889442408		MOVQ AX, 0x8(SP)		
  0x43529e		e89dd1feff		CALL runtime.printstring(SB)	
  0x4352a3		488d055e550300		LEAQ 0x3555e(IP), AX		
  0x4352aa		48890424		MOVQ AX, 0(SP)			
  0x4352ae		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x4352b7		e884d1feff		CALL runtime.printstring(SB)	
  0x4352bc		488b442450		MOVQ 0x50(SP), AX		
  0x4352c1		48890424		MOVQ AX, 0(SP)			
  0x4352c5		e8a6cefeff		CALL runtime.printuint(SB)	
  0x4352ca		488d0582490300		LEAQ 0x34982(IP), AX		
  0x4352d1		48890424		MOVQ AX, 0(SP)			
  0x4352d5		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4352de		e85dd1feff		CALL runtime.printstring(SB)	
  0x4352e3		488b442448		MOVQ 0x48(SP), AX		
  0x4352e8		48890424		MOVQ AX, 0(SP)			
  0x4352ec		e87fcefeff		CALL runtime.printuint(SB)	
  0x4352f1		e89acafeff		CALL runtime.printnl(SB)	
  0x4352f6		e885c8feff		CALL runtime.printunlock(SB)	
				throw("missing stackmap")
  0x4352fb		488d0510580300		LEAQ 0x35810(IP), AX	
  0x435302		48890424		MOVQ AX, 0(SP)		
  0x435306		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x43530f		e8bcbefeff		CALL runtime.throw(SB)	
  0x435314		0f0b			UD2			
			print("runtime: found space for saved base pointer, but no framepointer experiment\n")
  0x435316		e8e5c7feff		CALL runtime.printlock(SB)	
  0x43531b		488d05988b0300		LEAQ 0x38b98(IP), AX		
  0x435322		48890424		MOVQ AX, 0(SP)			
  0x435326		48c74424084c000000	MOVQ $0x4c, 0x8(SP)		
  0x43532f		e80cd1feff		CALL runtime.printstring(SB)	
  0x435334		e847c8feff		CALL runtime.printunlock(SB)	
  0x435339		488b8424b8000000	MOVQ 0xb8(SP), AX		
			print("argp=", hex(frame.argp), " varp=", hex(frame.varp), "\n")
  0x435341		488b4840		MOVQ 0x40(AX), CX		
  0x435345		48894c2450		MOVQ CX, 0x50(SP)		
  0x43534a		488b4038		MOVQ 0x38(AX), AX		
  0x43534e		4889442448		MOVQ AX, 0x48(SP)		
  0x435353		e8a8c7feff		CALL runtime.printlock(SB)	
  0x435358		488d05404a0300		LEAQ 0x34a40(IP), AX		
  0x43535f		48890424		MOVQ AX, 0(SP)			
  0x435363		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43536c		e8cfd0feff		CALL runtime.printstring(SB)	
  0x435371		488b442450		MOVQ 0x50(SP), AX		
  0x435376		48890424		MOVQ AX, 0(SP)			
  0x43537a		e871cffeff		CALL runtime.printhex(SB)	
  0x43537f		488d05a34a0300		LEAQ 0x34aa3(IP), AX		
  0x435386		48890424		MOVQ AX, 0(SP)			
  0x43538a		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x435393		e8a8d0feff		CALL runtime.printstring(SB)	
  0x435398		488b442448		MOVQ 0x48(SP), AX		
  0x43539d		48890424		MOVQ AX, 0(SP)			
  0x4353a1		e84acffeff		CALL runtime.printhex(SB)	
  0x4353a6		e8e5c9feff		CALL runtime.printnl(SB)	
  0x4353ab		e8d0c7feff		CALL runtime.printunlock(SB)	
			throw("bad frame layout")
  0x4353b0		488d05db560300		LEAQ 0x356db(IP), AX	
  0x4353b7		48890424		MOVQ AX, 0(SP)		
  0x4353bb		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x4353c4		e807befeff		CALL runtime.throw(SB)	
  0x4353c9		0f0b			UD2			
  0x4353cb		488b442478		MOVQ 0x78(SP), AX	
			print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " locals stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
  0x4353d0		48890424		MOVQ AX, 0(SP)			
  0x4353d4		488b842480000000	MOVQ 0x80(SP), AX		
  0x4353dc		4889442408		MOVQ AX, 0x8(SP)		
  0x4353e1		e81a350000		CALL runtime.funcname(SB)	
  0x4353e6		488b442470		MOVQ 0x70(SP), AX		
  0x4353eb		486300			MOVSXD 0(AX), AX		
  0x4353ee		4889442460		MOVQ AX, 0x60(SP)		
  0x4353f3		488b4c2418		MOVQ 0x18(SP), CX		
  0x4353f8		48894c2458		MOVQ CX, 0x58(SP)		
  0x4353fd		488b542410		MOVQ 0x10(SP), DX		
  0x435402		4889542468		MOVQ DX, 0x68(SP)		
  0x435407		e8f4c6feff		CALL runtime.printlock(SB)	
  0x43540c		488d05575b0300		LEAQ 0x35b57(IP), AX		
  0x435413		48890424		MOVQ AX, 0(SP)			
  0x435417		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x435420		e81bd0feff		CALL runtime.printstring(SB)	
  0x435425		8b442434		MOVL 0x34(SP), AX		
  0x435429		4863c0			MOVSXD AX, AX			
  0x43542c		48890424		MOVQ AX, 0(SP)			
  0x435430		e84bcefeff		CALL runtime.printint(SB)	
  0x435435		488d0518490300		LEAQ 0x34918(IP), AX		
  0x43543c		48890424		MOVQ AX, 0(SP)			
  0x435440		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x435449		e8f2cffeff		CALL runtime.printstring(SB)	
  0x43544e		488b442460		MOVQ 0x60(SP), AX		
  0x435453		48890424		MOVQ AX, 0(SP)			
  0x435457		e824cefeff		CALL runtime.printint(SB)	
  0x43545c		488d05906f0300		LEAQ 0x36f90(IP), AX		
  0x435463		48890424		MOVQ AX, 0(SP)			
  0x435467		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x435470		e8cbcffeff		CALL runtime.printstring(SB)	
  0x435475		488b442468		MOVQ 0x68(SP), AX		
  0x43547a		48890424		MOVQ AX, 0(SP)			
  0x43547e		488b442458		MOVQ 0x58(SP), AX		
  0x435483		4889442408		MOVQ AX, 0x8(SP)		
  0x435488		e8b3cffeff		CALL runtime.printstring(SB)	
  0x43548d		488d050f4f0300		LEAQ 0x34f0f(IP), AX		
  0x435494		48890424		MOVQ AX, 0(SP)			
  0x435498		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x4354a1		e89acffeff		CALL runtime.printstring(SB)	
  0x4354a6		488b442438		MOVQ 0x38(SP), AX		
  0x4354ab		48890424		MOVQ AX, 0(SP)			
  0x4354af		e8bcccfeff		CALL runtime.printuint(SB)	
  0x4354b4		488d05af470300		LEAQ 0x347af(IP), AX		
  0x4354bb		48890424		MOVQ AX, 0(SP)			
  0x4354bf		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4354c8		e873cffeff		CALL runtime.printstring(SB)	
  0x4354cd		e8aec6feff		CALL runtime.printunlock(SB)	
			throw("bad symbol table")
  0x4354d2		488d05d9550300		LEAQ 0x355d9(IP), AX	
  0x4354d9		48890424		MOVQ AX, 0(SP)		
  0x4354dd		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x4354e6		e8e5bcfeff		CALL runtime.throw(SB)	
  0x4354eb		0f0b			UD2			
  0x4354ed		488b442478		MOVQ 0x78(SP), AX	
			print("runtime: frame ", funcname(f), " untyped locals ", hex(frame.varp-size), "+", hex(size), "\n")
  0x4354f2		48890424		MOVQ AX, 0(SP)			
  0x4354f6		488b842480000000	MOVQ 0x80(SP), AX		
  0x4354fe		4889442408		MOVQ AX, 0x8(SP)		
  0x435503		e8f8330000		CALL runtime.funcname(SB)	
  0x435508		488b442410		MOVQ 0x10(SP), AX		
  0x43550d		4889442468		MOVQ AX, 0x68(SP)		
  0x435512		488b4c2418		MOVQ 0x18(SP), CX		
  0x435517		48894c2458		MOVQ CX, 0x58(SP)		
  0x43551c		488b9424b8000000	MOVQ 0xb8(SP), DX		
  0x435524		488b5238		MOVQ 0x38(DX), DX		
  0x435528		4889542450		MOVQ DX, 0x50(SP)		
  0x43552d		e8cec5feff		CALL runtime.printlock(SB)	
  0x435532		488d057d540300		LEAQ 0x3547d(IP), AX		
  0x435539		48890424		MOVQ AX, 0(SP)			
  0x43553d		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x435546		e8f5cefeff		CALL runtime.printstring(SB)	
  0x43554b		488b442468		MOVQ 0x68(SP), AX		
  0x435550		48890424		MOVQ AX, 0(SP)			
  0x435554		488b442458		MOVQ 0x58(SP), AX		
  0x435559		4889442408		MOVQ AX, 0x8(SP)		
  0x43555e		e8ddcefeff		CALL runtime.printstring(SB)	
  0x435563		488d05b8540300		LEAQ 0x354b8(IP), AX		
  0x43556a		48890424		MOVQ AX, 0(SP)			
  0x43556e		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x435577		e8c4cefeff		CALL runtime.printstring(SB)	
  0x43557c		488b442450		MOVQ 0x50(SP), AX		
  0x435581		488b4c2440		MOVQ 0x40(SP), CX		
  0x435586		4829c8			SUBQ CX, AX			
  0x435589		48890424		MOVQ AX, 0(SP)			
  0x43558d		e85ecdfeff		CALL runtime.printhex(SB)	
  0x435592		488d05ba460300		LEAQ 0x346ba(IP), AX		
  0x435599		48890424		MOVQ AX, 0(SP)			
  0x43559d		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4355a6		e895cefeff		CALL runtime.printstring(SB)	
  0x4355ab		488b442440		MOVQ 0x40(SP), AX		
  0x4355b0		48890424		MOVQ AX, 0(SP)			
  0x4355b4		e837cdfeff		CALL runtime.printhex(SB)	
  0x4355b9		e8d2c7feff		CALL runtime.printnl(SB)	
  0x4355be		e8bdc5feff		CALL runtime.printunlock(SB)	
			throw("missing stackmap")
  0x4355c3		488d0548550300		LEAQ 0x35548(IP), AX	
  0x4355ca		48890424		MOVQ AX, 0(SP)		
  0x4355ce		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x4355d7		e8f4bbfeff		CALL runtime.throw(SB)	
  0x4355dc		0f0b			UD2			
func adjustframe(frame *stkframe, arg unsafe.Pointer) bool {
  0x4355de		e88def0000		CALL runtime.morestack_noctxt(SB)	
  0x4355e3		e9b8f7ffff		JMP runtime.adjustframe(SB)		

TEXT runtime.adjustctxt(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func adjustctxt(gp *g, adjinfo *adjustinfo) {
  0x4355f0		488b442408		MOVQ 0x8(SP), AX	
	adjustpointer(adjinfo, unsafe.Pointer(&gp.sched.ctxt))
  0x4355f5		488d4850		LEAQ 0x50(AX), CX	
	p := *pp
  0x4355f9		8401			TESTB AL, 0(CX)		
  0x4355fb		488b4850		MOVQ 0x50(AX), CX	
  0x4355ff		488b542410		MOVQ 0x10(SP), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x435604		488b1a			MOVQ 0(DX), BX		
  0x435607		4839cb			CMPQ CX, BX		
  0x43560a		7714			JA 0x435620		
  0x43560c		488b5a08		MOVQ 0x8(DX), BX	
  0x435610		4839d9			CMPQ BX, CX		
  0x435613		730b			JAE 0x435620		
		*pp = p + adjinfo.delta
  0x435615		488b5a10		MOVQ 0x10(DX), BX	
  0x435619		4801d9			ADDQ BX, CX		
  0x43561c		48894850		MOVQ CX, 0x50(AX)	
	if !framepointer_enabled {
  0x435620		0fb60d70f40300		MOVZX 0x3f470(IP), CX	
  0x435627		84c9			TESTL CL, CL		
  0x435629		7427			JE 0x435652		
	adjustpointer(adjinfo, unsafe.Pointer(&gp.sched.bp))
  0x43562b		488d4868		LEAQ 0x68(AX), CX	
	p := *pp
  0x43562f		8401			TESTB AL, 0(CX)		
  0x435631		488b4868		MOVQ 0x68(AX), CX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x435635		488b1a			MOVQ 0(DX), BX		
  0x435638		4839cb			CMPQ CX, BX		
  0x43563b		7714			JA 0x435651		
  0x43563d		488b5a08		MOVQ 0x8(DX), BX	
  0x435641		4839d9			CMPQ BX, CX		
  0x435644		730b			JAE 0x435651		
		*pp = p + adjinfo.delta
  0x435646		488b5210		MOVQ 0x10(DX), DX	
  0x43564a		4801d1			ADDQ DX, CX		
  0x43564d		48894868		MOVQ CX, 0x68(AX)	
  0x435651		c3			RET			
		return
  0x435652		c3			RET			

TEXT runtime.adjustdefers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func adjustdefers(gp *g, adjinfo *adjustinfo) {
  0x435660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435669		483b6110		CMPQ 0x10(CX), SP	
  0x43566d		0f86c9000000		JBE 0x43573c		
  0x435673		4883ec20		SUBQ $0x20, SP		
  0x435677		48896c2418		MOVQ BP, 0x18(SP)	
  0x43567c		488d6c2418		LEAQ 0x18(SP), BP	
  0x435681		488b442428		MOVQ 0x28(SP), AX	
	tracebackdefers(gp, adjustframe, noescape(unsafe.Pointer(adjinfo)))
  0x435686		48890424		MOVQ AX, 0(SP)		
  0x43568a		488d0def880300		LEAQ 0x388ef(IP), CX	
  0x435691		48894c2408		MOVQ CX, 0x8(SP)	
func adjustdefers(gp *g, adjinfo *adjustinfo) {
  0x435696		488b4c2430		MOVQ 0x30(SP), CX	
	tracebackdefers(gp, adjustframe, noescape(unsafe.Pointer(adjinfo)))
  0x43569b		48894c2410		MOVQ CX, 0x10(SP)			
  0x4356a0		e88b5a0000		CALL runtime.tracebackdefers(SB)	
  0x4356a5		488b442428		MOVQ 0x28(SP), AX			
	for d := gp._defer; d != nil; d = d.link {
  0x4356aa		488b4028		MOVQ 0x28(AX), AX	
  0x4356ae		488b4c2430		MOVQ 0x30(SP), CX	
  0x4356b3		eb04			JMP 0x4356b9		
  0x4356b5		488b4028		MOVQ 0x28(AX), AX	
  0x4356b9		4885c0			TESTQ AX, AX		
  0x4356bc		7474			JE 0x435732		
		adjustpointer(adjinfo, unsafe.Pointer(&d.fn))
  0x4356be		488d5018		LEAQ 0x18(AX), DX	
	p := *pp
  0x4356c2		8402			TESTB AL, 0(DX)		
  0x4356c4		488b5018		MOVQ 0x18(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x4356c8		488b19			MOVQ 0(CX), BX		
  0x4356cb		4839d3			CMPQ DX, BX		
  0x4356ce		7714			JA 0x4356e4		
  0x4356d0		488b5908		MOVQ 0x8(CX), BX	
  0x4356d4		4839da			CMPQ BX, DX		
  0x4356d7		730b			JAE 0x4356e4		
		*pp = p + adjinfo.delta
  0x4356d9		488b5910		MOVQ 0x10(CX), BX	
  0x4356dd		4801da			ADDQ BX, DX		
  0x4356e0		48895018		MOVQ DX, 0x18(AX)	
		adjustpointer(adjinfo, unsafe.Pointer(&d.sp))
  0x4356e4		488d5008		LEAQ 0x8(AX), DX	
	p := *pp
  0x4356e8		8402			TESTB AL, 0(DX)		
  0x4356ea		488b5008		MOVQ 0x8(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x4356ee		488b19			MOVQ 0(CX), BX		
  0x4356f1		4839d3			CMPQ DX, BX		
  0x4356f4		7714			JA 0x43570a		
  0x4356f6		488b5908		MOVQ 0x8(CX), BX	
  0x4356fa		4839da			CMPQ BX, DX		
  0x4356fd		730b			JAE 0x43570a		
		*pp = p + adjinfo.delta
  0x4356ff		488b5910		MOVQ 0x10(CX), BX	
  0x435703		4801da			ADDQ BX, DX		
  0x435706		48895008		MOVQ DX, 0x8(AX)	
		adjustpointer(adjinfo, unsafe.Pointer(&d._panic))
  0x43570a		488d5020		LEAQ 0x20(AX), DX	
	p := *pp
  0x43570e		8402			TESTB AL, 0(DX)		
  0x435710		488b5020		MOVQ 0x20(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x435714		488b19			MOVQ 0(CX), BX		
  0x435717		4839d3			CMPQ DX, BX		
  0x43571a		7799			JA 0x4356b5		
  0x43571c		488b5908		MOVQ 0x8(CX), BX	
  0x435720		4839da			CMPQ BX, DX		
  0x435723		7390			JAE 0x4356b5		
		*pp = p + adjinfo.delta
  0x435725		488b5910		MOVQ 0x10(CX), BX	
  0x435729		4801da			ADDQ BX, DX		
  0x43572c		48895020		MOVQ DX, 0x20(AX)	
	for d := gp._defer; d != nil; d = d.link {
  0x435730		eb83			JMP 0x4356b5		
  0x435732		488b6c2418		MOVQ 0x18(SP), BP	
  0x435737		4883c420		ADDQ $0x20, SP		
  0x43573b		c3			RET			
func adjustdefers(gp *g, adjinfo *adjustinfo) {
  0x43573c		e82fee0000		CALL runtime.morestack_noctxt(SB)	
  0x435741		e91affffff		JMP runtime.adjustdefers(SB)		

TEXT runtime.adjustsudogs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func adjustsudogs(gp *g, adjinfo *adjustinfo) {
  0x435750		488b442408		MOVQ 0x8(SP), AX	
	for s := gp.waiting; s != nil; s = s.waitlink {
  0x435755		488b8038010000		MOVQ 0x138(AX), AX	
  0x43575c		488b4c2410		MOVQ 0x10(SP), CX	
  0x435761		eb04			JMP 0x435767		
  0x435763		488b4048		MOVQ 0x48(AX), AX	
  0x435767		4885c0			TESTQ AX, AX		
  0x43576a		7428			JE 0x435794		
		adjustpointer(adjinfo, unsafe.Pointer(&s.elem))
  0x43576c		488d5020		LEAQ 0x20(AX), DX	
	p := *pp
  0x435770		8402			TESTB AL, 0(DX)		
  0x435772		488b5020		MOVQ 0x20(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x435776		488b19			MOVQ 0(CX), BX		
  0x435779		4839d3			CMPQ DX, BX		
  0x43577c		77e5			JA 0x435763		
  0x43577e		488b5908		MOVQ 0x8(CX), BX	
  0x435782		4839da			CMPQ BX, DX		
  0x435785		73dc			JAE 0x435763		
		*pp = p + adjinfo.delta
  0x435787		488b5910		MOVQ 0x10(CX), BX	
  0x43578b		4801da			ADDQ BX, DX		
  0x43578e		48895020		MOVQ DX, 0x20(AX)	
	for s := gp.waiting; s != nil; s = s.waitlink {
  0x435792		ebcf			JMP 0x435763		
  0x435794		c3			RET			

TEXT runtime.findsghi(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func findsghi(gp *g, stk stack) uintptr {
  0x4357a0		488b442408		MOVQ 0x8(SP), AX	
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x4357a5		488b8038010000		MOVQ 0x138(AX), AX	
  0x4357ac		488b4c2418		MOVQ 0x18(SP), CX	
  0x4357b1		488b542410		MOVQ 0x10(SP), DX	
  0x4357b6		31db			XORL BX, BX		
  0x4357b8		eb07			JMP 0x4357c1		
  0x4357ba		488b4048		MOVQ 0x48(AX), AX	
  0x4357be		4889f3			MOVQ SI, BX		
  0x4357c1		4885c0			TESTQ AX, AX		
  0x4357c4		7423			JE 0x4357e9		
		p := uintptr(sg.elem) + uintptr(sg.c.elemsize)
  0x4357c6		488b7058		MOVQ 0x58(AX), SI	
  0x4357ca		488b7820		MOVQ 0x20(AX), DI	
  0x4357ce		0fb77618		MOVZX 0x18(SI), SI	
  0x4357d2		4801fe			ADDQ DI, SI		
		if stk.lo <= p && p < stk.hi && p > sghi {
  0x4357d5		4839f2			CMPQ SI, DX		
  0x4357d8		770a			JA 0x4357e4		
  0x4357da		4839ce			CMPQ CX, SI		
  0x4357dd		7305			JAE 0x4357e4		
  0x4357df		4839de			CMPQ BX, SI		
  0x4357e2		77d6			JA 0x4357ba		
  0x4357e4		4889de			MOVQ BX, SI		
  0x4357e7		ebd1			JMP 0x4357ba		
	return sghi
  0x4357e9		48895c2420		MOVQ BX, 0x20(SP)	
  0x4357ee		c3			RET			

TEXT runtime.syncadjustsudogs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func syncadjustsudogs(gp *g, used uintptr, adjinfo *adjustinfo) uintptr {
  0x4357f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4357f9		483b6110		CMPQ 0x10(CX), SP	
  0x4357fd		0f8631010000		JBE 0x435934		
  0x435803		4883ec38		SUBQ $0x38, SP		
  0x435807		48896c2430		MOVQ BP, 0x30(SP)	
  0x43580c		488d6c2430		LEAQ 0x30(SP), BP	
  0x435811		488b442440		MOVQ 0x40(SP), AX	
	if gp.waiting == nil {
  0x435816		488b8838010000		MOVQ 0x138(AX), CX	
  0x43581d		4885c9			TESTQ CX, CX		
  0x435820		0f84fb000000		JE 0x435921		
  0x435826		31d2			XORL DX, DX		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x435828		eb0b			JMP 0x435835		
  0x43582a		488b5948		MOVQ 0x48(CX), BX	
		lastc = sg.c
  0x43582e		488b5158		MOVQ 0x58(CX), DX	
  0x435832		4889d9			MOVQ BX, CX		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x435835		4885c9			TESTQ CX, CX		
  0x435838		7429			JE 0x435863		
		if sg.c != lastc {
  0x43583a		488b5958		MOVQ 0x58(CX), BX	
  0x43583e		4839da			CMPQ BX, DX		
  0x435841		74e7			JE 0x43582a		
  0x435843		48894c2428		MOVQ CX, 0x28(SP)	
			lock(&sg.c.lock)
  0x435848		8403			TESTB AL, 0(BX)		
  0x43584a		488d4358		LEAQ 0x58(BX), AX	
  0x43584e		48890424		MOVQ AX, 0(SP)		
  0x435852		e8c93cfdff		CALL runtime.lock(SB)	
  0x435857		488b442440		MOVQ 0x40(SP), AX	
  0x43585c		488b4c2428		MOVQ 0x28(SP), CX	
  0x435861		ebc7			JMP 0x43582a		
	adjustsudogs(gp, adjinfo)
  0x435863		48890424		MOVQ AX, 0(SP)			
  0x435867		488b4c2450		MOVQ 0x50(SP), CX		
  0x43586c		48894c2408		MOVQ CX, 0x8(SP)		
  0x435871		e8dafeffff		CALL runtime.adjustsudogs(SB)	
  0x435876		488b442450		MOVQ 0x50(SP), AX		
	if adjinfo.sghi != 0 {
  0x43587b		488b8818010000		MOVQ 0x118(AX), CX	
  0x435882		4885c9			TESTQ CX, CX		
  0x435885		755f			JNE 0x4358e6		
  0x435887		31c0			XORL AX, AX		
  0x435889		4889442418		MOVQ AX, 0x18(SP)	
  0x43588e		488b4c2440		MOVQ 0x40(SP), CX	
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x435893		488b8938010000		MOVQ 0x138(CX), CX	
  0x43589a		31d2			XORL DX, DX		
  0x43589c		eb0b			JMP 0x4358a9		
  0x43589e		488b5948		MOVQ 0x48(CX), BX	
		lastc = sg.c
  0x4358a2		488b5158		MOVQ 0x58(CX), DX	
  0x4358a6		4889d9			MOVQ BX, CX		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x4358a9		4885c9			TESTQ CX, CX		
  0x4358ac		7429			JE 0x4358d7		
		if sg.c != lastc {
  0x4358ae		488b5958		MOVQ 0x58(CX), BX	
  0x4358b2		4839da			CMPQ BX, DX		
  0x4358b5		74e7			JE 0x43589e		
  0x4358b7		48894c2420		MOVQ CX, 0x20(SP)	
			unlock(&sg.c.lock)
  0x4358bc		8403			TESTB AL, 0(BX)		
  0x4358be		488d4358		LEAQ 0x58(BX), AX	
  0x4358c2		48890424		MOVQ AX, 0(SP)		
  0x4358c6		e8f53dfdff		CALL runtime.unlock(SB)	
  0x4358cb		488b442418		MOVQ 0x18(SP), AX	
  0x4358d0		488b4c2420		MOVQ 0x20(SP), CX	
  0x4358d5		ebc7			JMP 0x43589e		
	return sgsize
  0x4358d7		4889442458		MOVQ AX, 0x58(SP)	
  0x4358dc		488b6c2430		MOVQ 0x30(SP), BP	
  0x4358e1		4883c438		ADDQ $0x38, SP		
  0x4358e5		c3			RET			
		oldBot := adjinfo.old.hi - used
  0x4358e6		488b5008		MOVQ 0x8(AX), DX	
  0x4358ea		488b5c2448		MOVQ 0x48(SP), BX	
  0x4358ef		4829da			SUBQ BX, DX		
		newBot := oldBot + adjinfo.delta
  0x4358f2		488b4010		MOVQ 0x10(AX), AX	
  0x4358f6		4801d0			ADDQ DX, AX		
		memmove(unsafe.Pointer(newBot), unsafe.Pointer(oldBot), sgsize)
  0x4358f9		48890424		MOVQ AX, 0(SP)		
  0x4358fd		4889d0			MOVQ DX, AX		
  0x435900		4889542408		MOVQ DX, 0x8(SP)	
		sgsize = adjinfo.sghi - oldBot
  0x435905		4829c1			SUBQ AX, CX		
  0x435908		48894c2418		MOVQ CX, 0x18(SP)	
		memmove(unsafe.Pointer(newBot), unsafe.Pointer(oldBot), sgsize)
  0x43590d		48894c2410		MOVQ CX, 0x10(SP)		
  0x435912		e8e9170100		CALL runtime.memmove(SB)	
  0x435917		488b442418		MOVQ 0x18(SP), AX		
  0x43591c		e968ffffff		JMP 0x435889			
		return 0
  0x435921		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x43592a		488b6c2430		MOVQ 0x30(SP), BP	
  0x43592f		4883c438		ADDQ $0x38, SP		
  0x435933		c3			RET			
func syncadjustsudogs(gp *g, used uintptr, adjinfo *adjustinfo) uintptr {
  0x435934		e837ec0000		CALL runtime.morestack_noctxt(SB)	
  0x435939		e9b2feffff		JMP runtime.syncadjustsudogs(SB)	

TEXT runtime.copystack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func copystack(gp *g, newsize uintptr, sync bool) {
  0x435940		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435949		488d8424d0feffff	LEAQ 0xfffffed0(SP), AX	
  0x435951		483b4110		CMPQ 0x10(CX), AX	
  0x435955		0f861b030000		JBE 0x435c76		
  0x43595b		4881ecb0010000		SUBQ $0x1b0, SP		
  0x435962		4889ac24a8010000	MOVQ BP, 0x1a8(SP)	
  0x43596a		488dac24a8010000	LEAQ 0x1a8(SP), BP	
  0x435972		488b8424b8010000	MOVQ 0x1b8(SP), AX	
	if gp.syscallsp != 0 {
  0x43597a		488b4870		MOVQ 0x70(AX), CX	
  0x43597e		4885c9			TESTQ CX, CX		
  0x435981		0f85d4020000		JNE 0x435c5b		
	old := gp.stack
  0x435987		488b4808		MOVQ 0x8(AX), CX	
  0x43598b		488b10			MOVQ 0(AX), DX		
	if old.lo == 0 {
  0x43598e		4885d2			TESTQ DX, DX		
  0x435991		0f84a9020000		JE 0x435c40		
  0x435997		48898c2480000000	MOVQ CX, 0x80(SP)	
  0x43599f		4889542478		MOVQ DX, 0x78(SP)	
	used := old.hi - gp.sched.sp
  0x4359a4		488b4838		MOVQ 0x38(AX), CX	
  0x4359a8		48894c2470		MOVQ CX, 0x70(SP)	
  0x4359ad		488b9424c0010000	MOVQ 0x1c0(SP), DX	
	new := stackalloc(uint32(newsize))
  0x4359b5		891424			MOVL DX, 0(SP)			
  0x4359b8		e853ebffff		CALL runtime.stackalloc(SB)	
  0x4359bd		488b442410		MOVQ 0x10(SP), AX		
  0x4359c2		4889442468		MOVQ AX, 0x68(SP)		
  0x4359c7		488b4c2408		MOVQ 0x8(SP), CX		
  0x4359cc		48894c2460		MOVQ CX, 0x60(SP)		
	var adjinfo adjustinfo
  0x4359d1		488dbc2488000000	LEAQ 0x88(SP), DI	
  0x4359d9		0f57c0			XORPS X0, X0		
  0x4359dc		488d7fe0		LEAQ -0x20(DI), DI	
  0x4359e0		48896c24f0		MOVQ BP, -0x10(SP)	
  0x4359e5		488d6c24f0		LEAQ -0x10(SP), BP	
  0x4359ea		e889100100		CALL 0x446a78		
  0x4359ef		488b6d00		MOVQ 0(BP), BP		
  0x4359f3		488b542478		MOVQ 0x78(SP), DX	
	adjinfo.old = old
  0x4359f8		4889942488000000	MOVQ DX, 0x88(SP)	
  0x435a00		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x435a08		48899c2490000000	MOVQ BX, 0x90(SP)	
	adjinfo.delta = new.hi - old.hi
  0x435a10		4829d8			SUBQ BX, AX		
  0x435a13		4889842498000000	MOVQ AX, 0x98(SP)	
  0x435a1b		488b442470		MOVQ 0x70(SP), AX	
  0x435a20		4889df			MOVQ BX, DI		
	used := old.hi - gp.sched.sp
  0x435a23		4829c3			SUBQ AX, BX		
  0x435a26		48895c2458		MOVQ BX, 0x58(SP)	
  0x435a2b		0fb68424c8010000	MOVZX 0x1c8(SP), AX	
func copystack(gp *g, newsize uintptr, sync bool) {
  0x435a33		84c0			TESTL AL, AL		
	if sync {
  0x435a35		0f84a0010000		JE 0x435bdb		
  0x435a3b		488b8424b8010000	MOVQ 0x1b8(SP), AX	
		adjustsudogs(gp, &adjinfo)
  0x435a43		48890424		MOVQ AX, 0(SP)			
  0x435a47		488d8c2488000000	LEAQ 0x88(SP), CX		
  0x435a4f		48894c2408		MOVQ CX, 0x8(SP)		
  0x435a54		e8f7fcffff		CALL runtime.adjustsudogs(SB)	
  0x435a59		488b442458		MOVQ 0x58(SP), AX		
  0x435a5e		488b4c2468		MOVQ 0x68(SP), CX		
	memmove(unsafe.Pointer(new.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)
  0x435a63		4829c1			SUBQ AX, CX			
  0x435a66		48890c24		MOVQ CX, 0(SP)			
  0x435a6a		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x435a72		4829c1			SUBQ AX, CX			
  0x435a75		48894c2408		MOVQ CX, 0x8(SP)		
  0x435a7a		4889442410		MOVQ AX, 0x10(SP)		
  0x435a7f		e87c160100		CALL runtime.memmove(SB)	
  0x435a84		488b8424b8010000	MOVQ 0x1b8(SP), AX		
	adjustctxt(gp, &adjinfo)
  0x435a8c		48890424		MOVQ AX, 0(SP)			
  0x435a90		488d8c2488000000	LEAQ 0x88(SP), CX		
  0x435a98		48894c2408		MOVQ CX, 0x8(SP)		
  0x435a9d		e84efbffff		CALL runtime.adjustctxt(SB)	
  0x435aa2		488b8424b8010000	MOVQ 0x1b8(SP), AX		
	adjustdefers(gp, &adjinfo)
  0x435aaa		48890424		MOVQ AX, 0(SP)			
  0x435aae		488d8c2488000000	LEAQ 0x88(SP), CX		
  0x435ab6		48894c2408		MOVQ CX, 0x8(SP)		
  0x435abb		e8a0fbffff		CALL runtime.adjustdefers(SB)	
  0x435ac0		488b8424b8010000	MOVQ 0x1b8(SP), AX		
	adjustpointer(adjinfo, unsafe.Pointer(&gp._panic))
  0x435ac8		488d4820		LEAQ 0x20(AX), CX	
	p := *pp
  0x435acc		8401			TESTB AL, 0(CX)		
  0x435ace		488b4820		MOVQ 0x20(AX), CX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x435ad2		488b942488000000	MOVQ 0x88(SP), DX	
  0x435ada		4839ca			CMPQ CX, DX		
  0x435add		771c			JA 0x435afb		
  0x435adf		488b942490000000	MOVQ 0x90(SP), DX	
  0x435ae7		4839d1			CMPQ DX, CX		
  0x435aea		730f			JAE 0x435afb		
		*pp = p + adjinfo.delta
  0x435aec		488b942498000000	MOVQ 0x98(SP), DX	
  0x435af4		4801d1			ADDQ DX, CX		
  0x435af7		48894820		MOVQ CX, 0x20(AX)	
	if adjinfo.sghi != 0 {
  0x435afb		488b8c24a0010000	MOVQ 0x1a0(SP), CX	
  0x435b03		4885c9			TESTQ CX, CX		
  0x435b06		7413			JE 0x435b1b		
		adjinfo.sghi += adjinfo.delta
  0x435b08		488b942498000000	MOVQ 0x98(SP), DX	
  0x435b10		4801d1			ADDQ DX, CX		
  0x435b13		48898c24a0010000	MOVQ CX, 0x1a0(SP)	
  0x435b1b		488b4c2460		MOVQ 0x60(SP), CX	
	gp.stack = new
  0x435b20		488908			MOVQ CX, 0(AX)		
  0x435b23		488b542468		MOVQ 0x68(SP), DX	
  0x435b28		48895008		MOVQ DX, 0x8(AX)	
	gp.stackguard0 = new.lo + _StackGuard // NOTE: might clobber a preempt request
  0x435b2c		4881c170030000		ADDQ $0x370, CX		
  0x435b33		48894810		MOVQ CX, 0x10(AX)	
  0x435b37		488b4c2458		MOVQ 0x58(SP), CX	
	gp.sched.sp = new.hi - used
  0x435b3c		4829ca			SUBQ CX, DX		
  0x435b3f		48895038		MOVQ DX, 0x38(AX)	
	gp.stktopsp += adjinfo.delta
  0x435b43		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x435b4b		48038880000000		ADDQ 0x80(AX), CX	
  0x435b52		48898880000000		MOVQ CX, 0x80(AX)	
	gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, adjustframe, noescape(unsafe.Pointer(&adjinfo)), 0)
  0x435b59		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x435b61		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x435b6a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x435b73		4889442418		MOVQ AX, 0x18(SP)		
  0x435b78		0f57c0			XORPS X0, X0			
  0x435b7b		0f11442420		MOVUPS X0, 0x20(SP)		
  0x435b80		48c7442430ffffff7f	MOVQ $0x7fffffff, 0x30(SP)	
  0x435b89		488d05f0830300		LEAQ 0x383f0(IP), AX		
  0x435b90		4889442438		MOVQ AX, 0x38(SP)		
  0x435b95		488d842488000000	LEAQ 0x88(SP), AX		
  0x435b9d		4889442440		MOVQ AX, 0x40(SP)		
  0x435ba2		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x435bab		e880570000		CALL runtime.gentraceback(SB)	
  0x435bb0		488b442478		MOVQ 0x78(SP), AX		
	stackfree(old)
  0x435bb5		48890424		MOVQ AX, 0(SP)			
  0x435bb9		488b842480000000	MOVQ 0x80(SP), AX		
  0x435bc1		4889442408		MOVQ AX, 0x8(SP)		
  0x435bc6		e865ecffff		CALL runtime.stackfree(SB)	
}
  0x435bcb		488bac24a8010000	MOVQ 0x1a8(SP), BP	
  0x435bd3		4881c4b0010000		ADDQ $0x1b0, SP		
  0x435bda		c3			RET			
  0x435bdb		488b8424b8010000	MOVQ 0x1b8(SP), AX	
		adjinfo.sghi = findsghi(gp, old)
  0x435be3		48890424		MOVQ AX, 0(SP)			
  0x435be7		4889542408		MOVQ DX, 0x8(SP)		
  0x435bec		48897c2410		MOVQ DI, 0x10(SP)		
  0x435bf1		e8aafbffff		CALL runtime.findsghi(SB)	
  0x435bf6		488b442418		MOVQ 0x18(SP), AX		
  0x435bfb		48898424a0010000	MOVQ AX, 0x1a0(SP)		
  0x435c03		488b8424b8010000	MOVQ 0x1b8(SP), AX		
		ncopy -= syncadjustsudogs(gp, used, &adjinfo)
  0x435c0b		48890424		MOVQ AX, 0(SP)				
  0x435c0f		488b4c2458		MOVQ 0x58(SP), CX			
  0x435c14		48894c2408		MOVQ CX, 0x8(SP)			
  0x435c19		488d942488000000	LEAQ 0x88(SP), DX			
  0x435c21		4889542410		MOVQ DX, 0x10(SP)			
  0x435c26		e8c5fbffff		CALL runtime.syncadjustsudogs(SB)	
  0x435c2b		488b442418		MOVQ 0x18(SP), AX			
  0x435c30		488b4c2458		MOVQ 0x58(SP), CX			
  0x435c35		4829c1			SUBQ AX, CX				
  0x435c38		4889c8			MOVQ CX, AX				
  0x435c3b		e91efeffff		JMP 0x435a5e				
		throw("nil stackbase")
  0x435c40		488d05214b0300		LEAQ 0x34b21(IP), AX	
  0x435c47		48890424		MOVQ AX, 0(SP)		
  0x435c4b		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x435c54		e877b5feff		CALL runtime.throw(SB)	
  0x435c59		0f0b			UD2			
		throw("stack growth not allowed in system call")
  0x435c5b		488d05b5750300		LEAQ 0x375b5(IP), AX	
  0x435c62		48890424		MOVQ AX, 0(SP)		
  0x435c66		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x435c6f		e85cb5feff		CALL runtime.throw(SB)	
  0x435c74		0f0b			UD2			
func copystack(gp *g, newsize uintptr, sync bool) {
  0x435c76		e8f5e80000		CALL runtime.morestack_noctxt(SB)	
  0x435c7b		e9c0fcffff		JMP runtime.copystack(SB)		

TEXT runtime.round2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func round2(x int32) int32 {
  0x435c80		8b442408		MOVL 0x8(SP), AX	
  0x435c84		31c9			XORL CX, CX		
	for 1<<s < x {
  0x435c86		eb03			JMP 0x435c8b		
		s++
  0x435c88		48ffc1			INCQ CX			
	for 1<<s < x {
  0x435c8b		ba01000000		MOVL $0x1, DX		
  0x435c90		d3e2			SHLL CL, DX		
  0x435c92		4883f920		CMPQ $0x20, CX		
  0x435c96		19db			SBBL BX, BX		
  0x435c98		21da			ANDL BX, DX		
  0x435c9a		39c2			CMPL AX, DX		
  0x435c9c		7cea			JL 0x435c88		
	return 1 << s
  0x435c9e		89542410		MOVL DX, 0x10(SP)	
  0x435ca2		c3			RET			

TEXT runtime.newstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func newstack() {
  0x435cb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435cb9		488d8424f8feffff	LEAQ 0xfffffef8(SP), AX	
  0x435cc1		483b4110		CMPQ 0x10(CX), AX	
  0x435cc5		0f86f10c0000		JBE 0x4369bc		
  0x435ccb		4881ec88010000		SUBQ $0x188, SP		
  0x435cd2		4889ac2480010000	MOVQ BP, 0x180(SP)	
  0x435cda		488dac2480010000	LEAQ 0x180(SP), BP	
	thisg := getg()
  0x435ce2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if thisg.m.morebuf.g.ptr().stackguard0 == stackFork {
  0x435ceb		488b4830		MOVQ 0x30(AX), CX	
  0x435cef		488b5118		MOVQ 0x18(CX), DX	
  0x435cf3		4889d3			MOVQ DX, BX		
  0x435cf6		4c8b4210		MOVQ 0x10(DX), R8	
  0x435cfa		4981f82efbffff		CMPQ $-0x4d2, R8	
  0x435d01		0f849a0c0000		JE 0x4369a1		
  0x435d07		4889842490000000	MOVQ AX, 0x90(SP)	
	if thisg.m.morebuf.g.ptr() != thisg.m.curg {
  0x435d0f		4c8b81c0000000		MOVQ 0xc0(CX), R8	
  0x435d16		4c898424d0000000	MOVQ R8, 0xd0(SP)	
  0x435d1e		4c39c2			CMPQ R8, DX		
  0x435d21		0f85ec0a0000		JNE 0x436813		
	if thisg.m.curg.throwsplit {
  0x435d27		410fb690c5000000	MOVZX 0xc5(R8), DX	
  0x435d2f		84d2			TESTL DL, DL		
  0x435d31		0f857d050000		JNE 0x4362b4		
	morebuf := thisg.m.morebuf
  0x435d37		488b5108		MOVQ 0x8(CX), DX	
  0x435d3b		48899424d8000000	MOVQ DX, 0xd8(SP)	
  0x435d43		488d7110		LEAQ 0x10(CX), SI	
  0x435d47		488dbc24e0000000	LEAQ 0xe0(SP), DI	
  0x435d4f		48896c24f0		MOVQ BP, -0x10(SP)	
  0x435d54		488d6c24f0		LEAQ -0x10(SP), BP	
  0x435d59		e8d8100100		CALL 0x446e36		
  0x435d5e		488b6d00		MOVQ 0(BP), BP		
	thisg.m.morebuf.pc = 0
  0x435d62		488b4830		MOVQ 0x30(AX), CX	
  0x435d66		48c7411000000000	MOVQ $0x0, 0x10(CX)	
	thisg.m.morebuf.lr = 0
  0x435d6e		488b4830		MOVQ 0x30(AX), CX	
  0x435d72		48c7413000000000	MOVQ $0x0, 0x30(CX)	
	thisg.m.morebuf.sp = 0
  0x435d7a		488b4830		MOVQ 0x30(AX), CX	
  0x435d7e		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	thisg.m.morebuf.g = 0
  0x435d86		488b4830		MOVQ 0x30(AX), CX	
  0x435d8a		48c7411800000000	MOVQ $0x0, 0x18(CX)	
	preempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt
  0x435d92		498b4810		MOVQ 0x10(R8), CX	
  0x435d96		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x435d9e		4881f9defaffff		CMPQ $-0x522, CX	
	if preempt {
  0x435da5		752c			JNE 0x435dd3		
		if thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != "" || thisg.m.p.ptr().status != _Prunning {
  0x435da7		488b5030		MOVQ 0x30(AX), DX	
  0x435dab		8b9a00010000		MOVL 0x100(DX), BX	
  0x435db1		85db			TESTL BX, BX		
  0x435db3		0f84c5040000		JE 0x43627e		
			gp.stackguard0 = gp.stack.lo + _StackGuard
  0x435db9		498b00			MOVQ 0(R8), AX		
  0x435dbc		480570030000		ADDQ $0x370, AX		
  0x435dc2		49894010		MOVQ AX, 0x10(R8)	
			gogo(&gp.sched) // never return
  0x435dc6		498d4038		LEAQ 0x38(R8), AX	
  0x435dca		48890424		MOVQ AX, 0(SP)		
  0x435dce		e86de50000		CALL runtime.gogo(SB)	
  0x435dd3		488b8424d0000000	MOVQ 0xd0(SP), AX	
	if gp.stack.lo == 0 {
  0x435ddb		488b08			MOVQ 0(AX), CX		
  0x435dde		4885c9			TESTQ CX, CX		
  0x435de1		0f842d070000		JE 0x436514		
	sp := gp.sched.sp
  0x435de7		488b5038		MOVQ 0x38(AX), DX	
		sp -= sys.PtrSize
  0x435deb		488d5af8		LEAQ -0x8(DX), BX	
  0x435def		48895c2428		MOVQ BX, 0x28(SP)	
	if stackDebug >= 1 || sp < gp.stack.lo {
  0x435df4		4839cb			CMPQ CX, BX		
  0x435df7		0f8265020000		JB 0x436062		
	if sp < gp.stack.lo {
  0x435dfd		488b08			MOVQ 0(AX), CX		
  0x435e00		4839cb			CMPQ CX, BX		
  0x435e03		0f82fe050000		JB 0x436407		
  0x435e09		488b8c2488000000	MOVQ 0x88(SP), CX	
	preempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt
  0x435e11		4881f9defaffff		CMPQ $-0x522, CX	
	if preempt {
  0x435e18		0f853c010000		JNE 0x435f5a		
  0x435e1e		488b8c2490000000	MOVQ 0x90(SP), CX	
		if gp == thisg.m.g0 {
  0x435e26		488b4930		MOVQ 0x30(CX), CX	
  0x435e2a		488b11			MOVQ 0(CX), DX		
  0x435e2d		4839d0			CMPQ DX, AX		
  0x435e30		0f84b6050000		JE 0x4363ec		
		if thisg.m.p == 0 && thisg.m.locks == 0 {
  0x435e36		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x435e3d		4885d2			TESTQ DX, DX		
  0x435e40		750e			JNE 0x435e50		
  0x435e42		8b8900010000		MOVL 0x100(CX), CX	
  0x435e48		85c9			TESTL CX, CX		
  0x435e4a		0f8481050000		JE 0x4363d1		
		casgstatus(gp, _Grunning, _Gwaiting)
  0x435e50		48890424		MOVQ AX, 0(SP)			
  0x435e54		48b90200000004000000	MOVQ $0x400000002, CX		
  0x435e5e		48894c2408		MOVQ CX, 0x8(SP)		
  0x435e63		e818ecfeff		CALL runtime.casgstatus(SB)	
  0x435e68		488b8424d0000000	MOVQ 0xd0(SP), AX		
		if gp.preemptscan {
  0x435e70		0fb688c2000000		MOVZX 0xc2(AX), CX	
  0x435e77		84c9			TESTL CL, CL		
  0x435e79		750d			JNE 0x435e88		
  0x435e7b		e9a9000000		JMP 0x435f29		
  0x435e80		488b8424d0000000	MOVQ 0xd0(SP), AX	
			for !castogscanstatus(gp, _Gwaiting, _Gscanwaiting) {
  0x435e88		48890424		MOVQ AX, 0(SP)				
  0x435e8c		48b90400000004100000	MOVQ $0x100400000004, CX		
  0x435e96		48894c2408		MOVQ CX, 0x8(SP)			
  0x435e9b		e800ebfeff		CALL runtime.castogscanstatus(SB)	
  0x435ea0		0fb6442410		MOVZX 0x10(SP), AX			
  0x435ea5		84c0			TESTL AL, AL				
  0x435ea7		74d7			JE 0x435e80				
  0x435ea9		488b8424d0000000	MOVQ 0xd0(SP), AX			
			if !gp.gcscandone {
  0x435eb1		0fb688c3000000		MOVZX 0xc3(AX), CX	
  0x435eb8		84c9			TESTL CL, CL		
  0x435eba		0f8444010000		JE 0x436004		
			gp.preemptscan = false
  0x435ec0		c680c200000000		MOVB $0x0, 0xc2(AX)	
			gp.preempt = false
  0x435ec7		c680c000000000		MOVB $0x0, 0xc0(AX)	
			casfrom_Gscanstatus(gp, _Gscanwaiting, _Gwaiting)
  0x435ece		48890424		MOVQ AX, 0(SP)				
  0x435ed2		48b90410000004000000	MOVQ $0x400001004, CX			
  0x435edc		48894c2408		MOVQ CX, 0x8(SP)			
  0x435ee1		e86ae6feff		CALL runtime.casfrom_Gscanstatus(SB)	
  0x435ee6		488b8424d0000000	MOVQ 0xd0(SP), AX			
			casgstatus(gp, _Gwaiting, _Grunning)
  0x435eee		48890424		MOVQ AX, 0(SP)			
  0x435ef2		48b90400000002000000	MOVQ $0x200000004, CX		
  0x435efc		48894c2408		MOVQ CX, 0x8(SP)		
  0x435f01		e87aebfeff		CALL runtime.casgstatus(SB)	
  0x435f06		488b8424d0000000	MOVQ 0xd0(SP), AX		
			gp.stackguard0 = gp.stack.lo + _StackGuard
  0x435f0e		488b08			MOVQ 0(AX), CX		
  0x435f11		4881c170030000		ADDQ $0x370, CX		
  0x435f18		48894810		MOVQ CX, 0x10(AX)	
			gogo(&gp.sched) // never return
  0x435f1c		488d4838		LEAQ 0x38(AX), CX	
  0x435f20		48890c24		MOVQ CX, 0(SP)		
  0x435f24		e817e40000		CALL runtime.gogo(SB)	
  0x435f29		488b8424d0000000	MOVQ 0xd0(SP), AX	
		casgstatus(gp, _Gwaiting, _Grunning)
  0x435f31		48890424		MOVQ AX, 0(SP)			
  0x435f35		48b90400000002000000	MOVQ $0x200000004, CX		
  0x435f3f		48894c2408		MOVQ CX, 0x8(SP)		
  0x435f44		e837ebfeff		CALL runtime.casgstatus(SB)	
  0x435f49		488b8424d0000000	MOVQ 0xd0(SP), AX		
		gopreempt_m(gp) // never return
  0x435f51		48890424		MOVQ AX, 0(SP)			
  0x435f55		e81632ffff		CALL runtime.gopreempt_m(SB)	
  0x435f5a		488b8424d0000000	MOVQ 0xd0(SP), AX		
	oldsize := gp.stack.hi - gp.stack.lo
  0x435f62		488b4808		MOVQ 0x8(AX), CX	
  0x435f66		482b08			SUBQ 0(AX), CX		
	newsize := oldsize * 2
  0x435f69		48d1e1			SHLQ $0x1, CX		
	if newsize > maxstacksize {
  0x435f6c		488b15d5f00600		MOVQ runtime.maxstacksize(SB), DX	
  0x435f73		4839d1			CMPQ DX, CX				
  0x435f76		0f87ee030000		JA 0x43636a				
  0x435f7c		48898c2480000000	MOVQ CX, 0x80(SP)			
	casgstatus(gp, _Grunning, _Gcopystack)
  0x435f84		48890424		MOVQ AX, 0(SP)			
  0x435f88		48b90200000008000000	MOVQ $0x800000002, CX		
  0x435f92		48894c2408		MOVQ CX, 0x8(SP)		
  0x435f97		e8e4eafeff		CALL runtime.casgstatus(SB)	
  0x435f9c		488b8424d0000000	MOVQ 0xd0(SP), AX		
	copystack(gp, newsize, true)
  0x435fa4		48890424		MOVQ AX, 0(SP)			
  0x435fa8		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x435fb0		48894c2408		MOVQ CX, 0x8(SP)		
  0x435fb5		c644241001		MOVB $0x1, 0x10(SP)		
  0x435fba		e881f9ffff		CALL runtime.copystack(SB)	
  0x435fbf		488b8424d0000000	MOVQ 0xd0(SP), AX		
	casgstatus(gp, _Gcopystack, _Grunning)
  0x435fc7		48890424		MOVQ AX, 0(SP)			
  0x435fcb		48b90800000002000000	MOVQ $0x200000008, CX		
  0x435fd5		48894c2408		MOVQ CX, 0x8(SP)		
  0x435fda		e8a1eafeff		CALL runtime.casgstatus(SB)	
  0x435fdf		488b8424d0000000	MOVQ 0xd0(SP), AX		
	gogo(&gp.sched)
  0x435fe7		4883c038		ADDQ $0x38, AX		
  0x435feb		48890424		MOVQ AX, 0(SP)		
  0x435fef		e84ce30000		CALL runtime.gogo(SB)	
}
  0x435ff4		488bac2480010000	MOVQ 0x180(SP), BP	
  0x435ffc		4881c488010000		ADDQ $0x188, SP		
  0x436003		c3			RET			
				gcw := &gp.m.p.ptr().gcw
  0x436004		488b4830		MOVQ 0x30(AX), CX	
  0x436008		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x43600f		8402			TESTB AL, 0(DX)		
  0x436011		8401			TESTB AL, 0(CX)		
				scanstack(gp, gcw)
  0x436013		48890424		MOVQ AX, 0(SP)		
				gcw := &gp.m.p.ptr().gcw
  0x436017		488d8a70120000		LEAQ 0x1270(DX), CX	
  0x43601e		48898c24a0000000	MOVQ CX, 0xa0(SP)	
				scanstack(gp, gcw)
  0x436026		48894c2408		MOVQ CX, 0x8(SP)		
  0x43602b		e870f3fdff		CALL runtime.scanstack(SB)	
				if gcBlackenPromptly {
  0x436030		0fb60570d80800		MOVZX runtime.gcBlackenPromptly(SB), AX	
  0x436037		84c0			TESTL AL, AL				
  0x436039		7514			JNE 0x43604f				
  0x43603b		488b8424d0000000	MOVQ 0xd0(SP), AX			
				gp.gcscandone = true
  0x436043		c680c300000001		MOVB $0x1, 0xc3(AX)	
  0x43604a		e971feffff		JMP 0x435ec0		
  0x43604f		488b8424a0000000	MOVQ 0xa0(SP), AX	
					gcw.dispose()
  0x436057		48890424		MOVQ AX, 0(SP)				
  0x43605b		e82032feff		CALL runtime.(*gcWork).dispose(SB)	
  0x436060		ebd9			JMP 0x43603b				
  0x436062		48898c2480000000	MOVQ CX, 0x80(SP)			
  0x43606a		4889542478		MOVQ DX, 0x78(SP)			
		print("runtime: newstack sp=", hex(sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x43606f		488b4808		MOVQ 0x8(AX), CX	
  0x436073		48894c2470		MOVQ CX, 0x70(SP)	
			"\tmorebuf={pc:", hex(morebuf.pc), " sp:", hex(morebuf.sp), " lr:", hex(morebuf.lr), "}\n",
  0x436078		488b9424e0000000	MOVQ 0xe0(SP), DX	
  0x436080		4889542468		MOVQ DX, 0x68(SP)	
  0x436085		488b9c24d8000000	MOVQ 0xd8(SP), BX	
  0x43608d		48895c2460		MOVQ BX, 0x60(SP)	
  0x436092		488bb42400010000	MOVQ 0x100(SP), SI	
  0x43609a		4889742458		MOVQ SI, 0x58(SP)	
			"\tsched={pc:", hex(gp.sched.pc), " sp:", hex(gp.sched.sp), " lr:", hex(gp.sched.lr), " ctxt:", gp.sched.ctxt, "}\n")
  0x43609f		488b7840		MOVQ 0x40(AX), DI	
  0x4360a3		48897c2450		MOVQ DI, 0x50(SP)	
  0x4360a8		4c8b4060		MOVQ 0x60(AX), R8	
  0x4360ac		4c89442448		MOVQ R8, 0x48(SP)	
  0x4360b1		4c8b4850		MOVQ 0x50(AX), R9	
  0x4360b5		4c898c24c8000000	MOVQ R9, 0xc8(SP)	
		print("runtime: newstack sp=", hex(sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x4360bd		e83ebafeff		CALL runtime.printlock(SB)	
  0x4360c2		488d0568520300		LEAQ 0x35268(IP), AX		
  0x4360c9		48890424		MOVQ AX, 0(SP)			
  0x4360cd		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4360d6		e865c3feff		CALL runtime.printstring(SB)	
  0x4360db		488b442428		MOVQ 0x28(SP), AX		
  0x4360e0		48890424		MOVQ AX, 0(SP)			
  0x4360e4		e807c2feff		CALL runtime.printhex(SB)	
  0x4360e9		488d05ef3e0300		LEAQ 0x33eef(IP), AX		
  0x4360f0		48890424		MOVQ AX, 0(SP)			
  0x4360f4		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4360fd		e83ec3feff		CALL runtime.printstring(SB)	
  0x436102		488b842480000000	MOVQ 0x80(SP), AX		
  0x43610a		48890424		MOVQ AX, 0(SP)			
  0x43610e		e8ddc1feff		CALL runtime.printhex(SB)	
  0x436113		488d05523b0300		LEAQ 0x33b52(IP), AX		
  0x43611a		48890424		MOVQ AX, 0(SP)			
  0x43611e		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x436127		e814c3feff		CALL runtime.printstring(SB)	
  0x43612c		488b442470		MOVQ 0x70(SP), AX		
  0x436131		48890424		MOVQ AX, 0(SP)			
  0x436135		e8b6c1feff		CALL runtime.printhex(SB)	
  0x43613a		488d05fd470300		LEAQ 0x347fd(IP), AX		
  0x436141		48890424		MOVQ AX, 0(SP)			
  0x436145		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x43614e		e8edc2feff		CALL runtime.printstring(SB)	
  0x436153		488b442468		MOVQ 0x68(SP), AX		
  0x436158		48890424		MOVQ AX, 0(SP)			
  0x43615c		e88fc1feff		CALL runtime.printhex(SB)	
  0x436161		488d056e3b0300		LEAQ 0x33b6e(IP), AX		
  0x436168		48890424		MOVQ AX, 0(SP)			
  0x43616c		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x436175		e8c6c2feff		CALL runtime.printstring(SB)	
  0x43617a		488b442460		MOVQ 0x60(SP), AX		
  0x43617f		48890424		MOVQ AX, 0(SP)			
  0x436183		e868c1feff		CALL runtime.printhex(SB)	
  0x436188		488d053b3b0300		LEAQ 0x33b3b(IP), AX		
  0x43618f		48890424		MOVQ AX, 0(SP)			
  0x436193		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43619c		e89fc2feff		CALL runtime.printstring(SB)	
  0x4361a1		488b442458		MOVQ 0x58(SP), AX		
  0x4361a6		48890424		MOVQ AX, 0(SP)			
  0x4361aa		e841c1feff		CALL runtime.printhex(SB)	
  0x4361af		488d050d460300		LEAQ 0x3460d(IP), AX		
  0x4361b6		48890424		MOVQ AX, 0(SP)			
  0x4361ba		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4361c3		e878c2feff		CALL runtime.printstring(SB)	
  0x4361c8		488b442450		MOVQ 0x50(SP), AX		
  0x4361cd		48890424		MOVQ AX, 0(SP)			
  0x4361d1		e81ac1feff		CALL runtime.printhex(SB)	
  0x4361d6		488d05f93a0300		LEAQ 0x33af9(IP), AX		
  0x4361dd		48890424		MOVQ AX, 0(SP)			
  0x4361e1		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4361ea		e851c2feff		CALL runtime.printstring(SB)	
  0x4361ef		488b442478		MOVQ 0x78(SP), AX		
  0x4361f4		48890424		MOVQ AX, 0(SP)			
  0x4361f8		e8f3c0feff		CALL runtime.printhex(SB)	
  0x4361fd		488d05c63a0300		LEAQ 0x33ac6(IP), AX		
  0x436204		48890424		MOVQ AX, 0(SP)			
  0x436208		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x436211		e82ac2feff		CALL runtime.printstring(SB)	
  0x436216		488b442448		MOVQ 0x48(SP), AX		
  0x43621b		48890424		MOVQ AX, 0(SP)			
  0x43621f		e8ccc0feff		CALL runtime.printhex(SB)	
  0x436224		488d05ce3b0300		LEAQ 0x33bce(IP), AX		
  0x43622b		48890424		MOVQ AX, 0(SP)			
  0x43622f		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x436238		e803c2feff		CALL runtime.printstring(SB)	
  0x43623d		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x436245		48890424		MOVQ AX, 0(SP)			
  0x436249		e8b2c1feff		CALL runtime.printpointer(SB)	
  0x43624e		488d05273a0300		LEAQ 0x33a27(IP), AX		
  0x436255		48890424		MOVQ AX, 0(SP)			
  0x436259		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x436262		e8d9c1feff		CALL runtime.printstring(SB)	
  0x436267		e814b9feff		CALL runtime.printunlock(SB)	
  0x43626c		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x436274		488b5c2428		MOVQ 0x28(SP), BX		
  0x436279		e97ffbffff		JMP 0x435dfd			
		if thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != "" || thisg.m.p.ptr().status != _Prunning {
  0x43627e		8b9ae8000000		MOVL 0xe8(DX), BX	
  0x436284		85db			TESTL BX, BX		
  0x436286		0f852dfbffff		JNE 0x435db9		
  0x43628c		488b9af8000000		MOVQ 0xf8(DX), BX	
  0x436293		4885db			TESTQ BX, BX		
  0x436296		0f851dfbffff		JNE 0x435db9		
  0x43629c		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x4362a3		8b520c			MOVL 0xc(DX), DX	
  0x4362a6		83fa01			CMPL $0x1, DX		
  0x4362a9		0f850afbffff		JNE 0x435db9		
  0x4362af		e91ffbffff		JMP 0x435dd3		
		morebuf := thisg.m.morebuf
  0x4362b4		488b4108		MOVQ 0x8(CX), AX	
  0x4362b8		4889842410010000	MOVQ AX, 0x110(SP)	
  0x4362c0		488d7110		LEAQ 0x10(CX), SI	
  0x4362c4		488dbc2418010000	LEAQ 0x118(SP), DI	
  0x4362cc		48896c24f0		MOVQ BP, -0x10(SP)	
  0x4362d1		488d6c24f0		LEAQ -0x10(SP), BP	
  0x4362d6		e85b0b0100		CALL 0x446e36		
  0x4362db		488b6d00		MOVQ 0(BP), BP		
		gp.syscallsp = morebuf.sp
  0x4362df		488b842410010000	MOVQ 0x110(SP), AX	
  0x4362e7		49894070		MOVQ AX, 0x70(R8)	
		gp.syscallpc = morebuf.pc
  0x4362eb		488b842418010000	MOVQ 0x118(SP), AX	
  0x4362f3		49894078		MOVQ AX, 0x78(R8)	
		f := findfunc(gp.sched.pc)
  0x4362f7		498b4040		MOVQ 0x40(R8), AX		
  0x4362fb		48890424		MOVQ AX, 0(SP)			
  0x4362ff		e8cc1e0000		CALL runtime.findfunc(SB)	
  0x436304		488b442410		MOVQ 0x10(SP), AX		
  0x436309		488b4c2408		MOVQ 0x8(SP), CX		
	return f._func != nil
  0x43630e		4885c9			TESTQ CX, CX		
		if f.valid() {
  0x436311		751b			JNE 0x43632e		
  0x436313		488b9424d0000000	MOVQ 0xd0(SP), DX	
  0x43631b		b809000000		MOVL $0x9, AX		
  0x436320		488d0d9f3d0300		LEAQ 0x33d9f(IP), CX	
  0x436327		31db			XORL BX, BX		
  0x436329		e901020000		JMP 0x43652f		
  0x43632e		48898c24c0000000	MOVQ CX, 0xc0(SP)	
			pcname = funcname(f)
  0x436336		48890c24		MOVQ CX, 0(SP)			
  0x43633a		4889442408		MOVQ AX, 0x8(SP)		
  0x43633f		e8bc250000		CALL runtime.funcname(SB)	
  0x436344		488b442418		MOVQ 0x18(SP), AX		
  0x436349		488b4c2410		MOVQ 0x10(SP), CX		
  0x43634e		488b9424d0000000	MOVQ 0xd0(SP), DX		
			pcoff = gp.sched.pc - f.entry
  0x436356		488b5a40		MOVQ 0x40(DX), BX	
  0x43635a		488bb424c0000000	MOVQ 0xc0(SP), SI	
  0x436362		482b1e			SUBQ 0(SI), BX		
  0x436365		e9c5010000		JMP 0x43652f		
		print("runtime: goroutine stack exceeds ", maxstacksize, "-byte limit\n")
  0x43636a		e891b7feff		CALL runtime.printlock(SB)		
  0x43636f		488d0516670300		LEAQ 0x36716(IP), AX			
  0x436376		48890424		MOVQ AX, 0(SP)				
  0x43637a		48c744240821000000	MOVQ $0x21, 0x8(SP)			
  0x436383		e8b8c0feff		CALL runtime.printstring(SB)		
  0x436388		488b05b9ec0600		MOVQ runtime.maxstacksize(SB), AX	
  0x43638f		48890424		MOVQ AX, 0(SP)				
  0x436393		e8d8bdfeff		CALL runtime.printuint(SB)		
  0x436398		488d0503420300		LEAQ 0x34203(IP), AX			
  0x43639f		48890424		MOVQ AX, 0(SP)				
  0x4363a3		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x4363ac		e88fc0feff		CALL runtime.printstring(SB)		
  0x4363b1		e8cab7feff		CALL runtime.printunlock(SB)		
		throw("stack overflow")
  0x4363b6		488d052b450300		LEAQ 0x3452b(IP), AX	
  0x4363bd		48890424		MOVQ AX, 0(SP)		
  0x4363c1		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4363ca		e801aefeff		CALL runtime.throw(SB)	
  0x4363cf		0f0b			UD2			
			throw("runtime: g is running but p is not")
  0x4363d1		488d0566680300		LEAQ 0x36866(IP), AX	
  0x4363d8		48890424		MOVQ AX, 0(SP)		
  0x4363dc		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x4363e5		e8e6adfeff		CALL runtime.throw(SB)	
  0x4363ea		0f0b			UD2			
			throw("runtime: preempt g0")
  0x4363ec		488d058a4b0300		LEAQ 0x34b8a(IP), AX	
  0x4363f3		48890424		MOVQ AX, 0(SP)		
  0x4363f7		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x436400		e8cbadfeff		CALL runtime.throw(SB)	
  0x436405		0f0b			UD2			
	return atomic.Load(&gp.atomicstatus)
  0x436407		8b8890000000		MOVL 0x90(AX), CX	
  0x43640d		894c2424		MOVL CX, 0x24(SP)	
		print("runtime: gp=", gp, ", gp->status=", hex(readgstatus(gp)), "\n ")
  0x436411		e8eab6feff		CALL runtime.printlock(SB)	
  0x436416		488d0521420300		LEAQ 0x34221(IP), AX		
  0x43641d		48890424		MOVQ AX, 0(SP)			
  0x436421		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x43642a		e811c0feff		CALL runtime.printstring(SB)	
  0x43642f		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x436437		48890424		MOVQ AX, 0(SP)			
  0x43643b		e8c0bffeff		CALL runtime.printpointer(SB)	
  0x436440		488d05ac420300		LEAQ 0x342ac(IP), AX		
  0x436447		48890424		MOVQ AX, 0(SP)			
  0x43644b		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x436454		e8e7bffeff		CALL runtime.printstring(SB)	
  0x436459		8b442424		MOVL 0x24(SP), AX		
  0x43645d		89c0			MOVL AX, AX			
  0x43645f		48890424		MOVQ AX, 0(SP)			
  0x436463		e888befeff		CALL runtime.printhex(SB)	
  0x436468		488d0505380300		LEAQ 0x33805(IP), AX		
  0x43646f		48890424		MOVQ AX, 0(SP)			
  0x436473		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43647c		e8bfbffeff		CALL runtime.printstring(SB)	
  0x436481		e8fab6feff		CALL runtime.printunlock(SB)	
  0x436486		488b8424d0000000	MOVQ 0xd0(SP), AX		
		print("runtime: split stack overflow: ", hex(sp), " < ", hex(gp.stack.lo), "\n")
  0x43648e		488b00			MOVQ 0(AX), AX			
  0x436491		4889842480000000	MOVQ AX, 0x80(SP)		
  0x436499		e862b6feff		CALL runtime.printlock(SB)	
  0x43649e		488d05df620300		LEAQ 0x362df(IP), AX		
  0x4364a5		48890424		MOVQ AX, 0(SP)			
  0x4364a9		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x4364b2		e889bffeff		CALL runtime.printstring(SB)	
  0x4364b7		488b442428		MOVQ 0x28(SP), AX		
  0x4364bc		48890424		MOVQ AX, 0(SP)			
  0x4364c0		e82bbefeff		CALL runtime.printhex(SB)	
  0x4364c5		488d05c1370300		LEAQ 0x337c1(IP), AX		
  0x4364cc		48890424		MOVQ AX, 0(SP)			
  0x4364d0		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4364d9		e862bffeff		CALL runtime.printstring(SB)	
  0x4364de		488b842480000000	MOVQ 0x80(SP), AX		
  0x4364e6		48890424		MOVQ AX, 0(SP)			
  0x4364ea		e801befeff		CALL runtime.printhex(SB)	
  0x4364ef		e89cb8feff		CALL runtime.printnl(SB)	
  0x4364f4		e887b6feff		CALL runtime.printunlock(SB)	
		throw("runtime: split stack overflow")
  0x4364f9		488d05285e0300		LEAQ 0x35e28(IP), AX	
  0x436500		48890424		MOVQ AX, 0(SP)		
  0x436504		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x43650d		e8beacfeff		CALL runtime.throw(SB)	
  0x436512		0f0b			UD2			
		throw("missing stack in newstack")
  0x436514		488d052c550300		LEAQ 0x3552c(IP), AX	
  0x43651b		48890424		MOVQ AX, 0(SP)		
  0x43651f		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x436528		e8a3acfeff		CALL runtime.throw(SB)	
  0x43652d		0f0b			UD2			
  0x43652f		48895c2430		MOVQ BX, 0x30(SP)	
  0x436534		4889442438		MOVQ AX, 0x38(SP)	
  0x436539		48898c2498000000	MOVQ CX, 0x98(SP)	
			" sp=", hex(gp.sched.sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x436541		488b32			MOVQ 0(DX), SI		
  0x436544		4889b42480000000	MOVQ SI, 0x80(SP)	
  0x43654c		488b7a08		MOVQ 0x8(DX), DI	
  0x436550		48897c2478		MOVQ DI, 0x78(SP)	
			"\tmorebuf={pc:", hex(morebuf.pc), " sp:", hex(morebuf.sp), " lr:", hex(morebuf.lr), "}\n",
  0x436555		4c8b842418010000	MOVQ 0x118(SP), R8	
  0x43655d		4c89442470		MOVQ R8, 0x70(SP)	
  0x436562		4c8b8c2410010000	MOVQ 0x110(SP), R9	
  0x43656a		4c894c2468		MOVQ R9, 0x68(SP)	
  0x43656f		4c8b942438010000	MOVQ 0x138(SP), R10	
  0x436577		4c89542460		MOVQ R10, 0x60(SP)	
			"\tsched={pc:", hex(gp.sched.pc), " sp:", hex(gp.sched.sp), " lr:", hex(gp.sched.lr), " ctxt:", gp.sched.ctxt, "}\n")
  0x43657c		4c8b5a40		MOVQ 0x40(DX), R11	
  0x436580		4c895c2458		MOVQ R11, 0x58(SP)	
  0x436585		4c8b6238		MOVQ 0x38(DX), R12	
  0x436589		4c89642450		MOVQ R12, 0x50(SP)	
  0x43658e		4c8b6a60		MOVQ 0x60(DX), R13	
  0x436592		4c896c2448		MOVQ R13, 0x48(SP)	
  0x436597		4c8b7250		MOVQ 0x50(DX), R14	
  0x43659b		4c89b424c8000000	MOVQ R14, 0xc8(SP)	
		print("runtime: newstack at ", pcname, "+", hex(pcoff),
  0x4365a3		e858b5feff		CALL runtime.printlock(SB)	
  0x4365a8		488d056d4d0300		LEAQ 0x34d6d(IP), AX		
  0x4365af		48890424		MOVQ AX, 0(SP)			
  0x4365b3		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4365bc		e87fbefeff		CALL runtime.printstring(SB)	
  0x4365c1		488b842498000000	MOVQ 0x98(SP), AX		
  0x4365c9		48890424		MOVQ AX, 0(SP)			
  0x4365cd		488b442438		MOVQ 0x38(SP), AX		
  0x4365d2		4889442408		MOVQ AX, 0x8(SP)		
  0x4365d7		e864befeff		CALL runtime.printstring(SB)	
  0x4365dc		488d0570360300		LEAQ 0x33670(IP), AX		
  0x4365e3		48890424		MOVQ AX, 0(SP)			
  0x4365e7		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4365f0		e84bbefeff		CALL runtime.printstring(SB)	
  0x4365f5		488b442430		MOVQ 0x30(SP), AX		
  0x4365fa		48890424		MOVQ AX, 0(SP)			
  0x4365fe		e8edbcfeff		CALL runtime.printhex(SB)	
  0x436603		488d05d0360300		LEAQ 0x336d0(IP), AX		
  0x43660a		48890424		MOVQ AX, 0(SP)			
  0x43660e		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x436617		e824befeff		CALL runtime.printstring(SB)	
  0x43661c		488b442450		MOVQ 0x50(SP), AX		
  0x436621		48890424		MOVQ AX, 0(SP)			
  0x436625		e8c6bcfeff		CALL runtime.printhex(SB)	
  0x43662a		488d05ae390300		LEAQ 0x339ae(IP), AX		
  0x436631		48890424		MOVQ AX, 0(SP)			
  0x436635		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43663e		e8fdbdfeff		CALL runtime.printstring(SB)	
  0x436643		488b842480000000	MOVQ 0x80(SP), AX		
  0x43664b		48890424		MOVQ AX, 0(SP)			
  0x43664f		e89cbcfeff		CALL runtime.printhex(SB)	
  0x436654		488d0511360300		LEAQ 0x33611(IP), AX		
  0x43665b		48890424		MOVQ AX, 0(SP)			
  0x43665f		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x436668		e8d3bdfeff		CALL runtime.printstring(SB)	
  0x43666d		488b442478		MOVQ 0x78(SP), AX		
  0x436672		48890424		MOVQ AX, 0(SP)			
  0x436676		e875bcfeff		CALL runtime.printhex(SB)	
  0x43667b		488d05bc420300		LEAQ 0x342bc(IP), AX		
  0x436682		48890424		MOVQ AX, 0(SP)			
  0x436686		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x43668f		e8acbdfeff		CALL runtime.printstring(SB)	
  0x436694		488b442470		MOVQ 0x70(SP), AX		
  0x436699		48890424		MOVQ AX, 0(SP)			
  0x43669d		e84ebcfeff		CALL runtime.printhex(SB)	
  0x4366a2		488d052d360300		LEAQ 0x3362d(IP), AX		
  0x4366a9		48890424		MOVQ AX, 0(SP)			
  0x4366ad		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4366b6		e885bdfeff		CALL runtime.printstring(SB)	
  0x4366bb		488b442468		MOVQ 0x68(SP), AX		
  0x4366c0		48890424		MOVQ AX, 0(SP)			
  0x4366c4		e827bcfeff		CALL runtime.printhex(SB)	
  0x4366c9		488d05fa350300		LEAQ 0x335fa(IP), AX		
  0x4366d0		48890424		MOVQ AX, 0(SP)			
  0x4366d4		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4366dd		e85ebdfeff		CALL runtime.printstring(SB)	
  0x4366e2		488b442460		MOVQ 0x60(SP), AX		
  0x4366e7		48890424		MOVQ AX, 0(SP)			
  0x4366eb		e800bcfeff		CALL runtime.printhex(SB)	
  0x4366f0		488d05cc400300		LEAQ 0x340cc(IP), AX		
  0x4366f7		48890424		MOVQ AX, 0(SP)			
  0x4366fb		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x436704		e837bdfeff		CALL runtime.printstring(SB)	
  0x436709		488b442458		MOVQ 0x58(SP), AX		
  0x43670e		48890424		MOVQ AX, 0(SP)			
  0x436712		e8d9bbfeff		CALL runtime.printhex(SB)	
  0x436717		488d05b8350300		LEAQ 0x335b8(IP), AX		
  0x43671e		48890424		MOVQ AX, 0(SP)			
  0x436722		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43672b		e810bdfeff		CALL runtime.printstring(SB)	
  0x436730		488b442450		MOVQ 0x50(SP), AX		
  0x436735		48890424		MOVQ AX, 0(SP)			
  0x436739		e8b2bbfeff		CALL runtime.printhex(SB)	
  0x43673e		488d0585350300		LEAQ 0x33585(IP), AX		
  0x436745		48890424		MOVQ AX, 0(SP)			
  0x436749		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x436752		e8e9bcfeff		CALL runtime.printstring(SB)	
  0x436757		488b442448		MOVQ 0x48(SP), AX		
  0x43675c		48890424		MOVQ AX, 0(SP)			
  0x436760		e88bbbfeff		CALL runtime.printhex(SB)	
  0x436765		488d058d360300		LEAQ 0x3368d(IP), AX		
  0x43676c		48890424		MOVQ AX, 0(SP)			
  0x436770		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x436779		e8c2bcfeff		CALL runtime.printstring(SB)	
  0x43677e		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x436786		48890424		MOVQ AX, 0(SP)			
  0x43678a		e871bcfeff		CALL runtime.printpointer(SB)	
  0x43678f		488d05e6340300		LEAQ 0x334e6(IP), AX		
  0x436796		48890424		MOVQ AX, 0(SP)			
  0x43679a		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4367a3		e898bcfeff		CALL runtime.printstring(SB)	
  0x4367a8		e8d3b3feff		CALL runtime.printunlock(SB)	
  0x4367ad		488b842490000000	MOVQ 0x90(SP), AX		
		thisg.m.traceback = 2 // Include runtime frames
  0x4367b5		488b4030		MOVQ 0x30(AX), AX	
  0x4367b9		c6802901000002		MOVB $0x2, 0x129(AX)	
		traceback(morebuf.pc, morebuf.sp, morebuf.lr, gp)
  0x4367c0		488b842418010000	MOVQ 0x118(SP), AX		
  0x4367c8		48890424		MOVQ AX, 0(SP)			
  0x4367cc		488b842410010000	MOVQ 0x110(SP), AX		
  0x4367d4		4889442408		MOVQ AX, 0x8(SP)		
  0x4367d9		488b842438010000	MOVQ 0x138(SP), AX		
  0x4367e1		4889442410		MOVQ AX, 0x10(SP)		
  0x4367e6		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x4367ee		4889442418		MOVQ AX, 0x18(SP)		
  0x4367f3		e8c86d0000		CALL runtime.traceback(SB)	
		throw("runtime: stack split at bad time")
  0x4367f8		488d0584600300		LEAQ 0x36084(IP), AX	
  0x4367ff		48890424		MOVQ AX, 0(SP)		
  0x436803		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x43680c		e8bfa9feff		CALL runtime.throw(SB)	
  0x436811		0f0b			UD2			
  0x436813		48898c24b8000000	MOVQ CX, 0xb8(SP)	
  0x43681b		48895c2440		MOVQ BX, 0x40(SP)	
		print("runtime: newstack called from g=", hex(thisg.m.morebuf.g), "\n"+"\tm=", thisg.m, " m->curg=", thisg.m.curg, " m->g0=", thisg.m.g0, " m->gsignal=", thisg.m.gsignal, "\n")
  0x436820		488b01			MOVQ 0(CX), AX			
  0x436823		48898424b0000000	MOVQ AX, 0xb0(SP)		
  0x43682b		488b5150		MOVQ 0x50(CX), DX		
  0x43682f		48899424a8000000	MOVQ DX, 0xa8(SP)		
  0x436837		e8c4b2feff		CALL runtime.printlock(SB)	
  0x43683c		488d0520600300		LEAQ 0x36020(IP), AX		
  0x436843		48890424		MOVQ AX, 0(SP)			
  0x436847		48c744240820000000	MOVQ $0x20, 0x8(SP)		
  0x436850		e8ebbbfeff		CALL runtime.printstring(SB)	
  0x436855		488b442440		MOVQ 0x40(SP), AX		
  0x43685a		48890424		MOVQ AX, 0(SP)			
  0x43685e		e88dbafeff		CALL runtime.printhex(SB)	
  0x436863		488d0590340300		LEAQ 0x33490(IP), AX		
  0x43686a		48890424		MOVQ AX, 0(SP)			
  0x43686e		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x436877		e8c4bbfeff		CALL runtime.printstring(SB)	
  0x43687c		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x436884		48890424		MOVQ AX, 0(SP)			
  0x436888		e873bbfeff		CALL runtime.printpointer(SB)	
  0x43688d		488d05ea370300		LEAQ 0x337ea(IP), AX		
  0x436894		48890424		MOVQ AX, 0(SP)			
  0x436898		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4368a1		e89abbfeff		CALL runtime.printstring(SB)	
  0x4368a6		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x4368ae		48890424		MOVQ AX, 0(SP)			
  0x4368b2		e849bbfeff		CALL runtime.printpointer(SB)	
  0x4368b7		488d05b8350300		LEAQ 0x335b8(IP), AX		
  0x4368be		48890424		MOVQ AX, 0(SP)			
  0x4368c2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4368cb		e870bbfeff		CALL runtime.printstring(SB)	
  0x4368d0		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x4368d8		48890424		MOVQ AX, 0(SP)			
  0x4368dc		e81fbbfeff		CALL runtime.printpointer(SB)	
  0x4368e1		488d052a3c0300		LEAQ 0x33c2a(IP), AX		
  0x4368e8		48890424		MOVQ AX, 0(SP)			
  0x4368ec		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x4368f5		e846bbfeff		CALL runtime.printstring(SB)	
  0x4368fa		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x436902		48890424		MOVQ AX, 0(SP)			
  0x436906		e8f5bafeff		CALL runtime.printpointer(SB)	
  0x43690b		e880b4feff		CALL runtime.printnl(SB)	
  0x436910		e86bb2feff		CALL runtime.printunlock(SB)	
  0x436915		488b842490000000	MOVQ 0x90(SP), AX		
		morebuf := thisg.m.morebuf
  0x43691d		488b4830		MOVQ 0x30(AX), CX	
  0x436921		8400			TESTB AL, 0(AX)		
  0x436923		488b4108		MOVQ 0x8(CX), AX	
  0x436927		4889842448010000	MOVQ AX, 0x148(SP)	
  0x43692f		488d7110		LEAQ 0x10(CX), SI	
  0x436933		488dbc2450010000	LEAQ 0x150(SP), DI	
  0x43693b		48896c24f0		MOVQ BP, -0x10(SP)	
  0x436940		488d6c24f0		LEAQ -0x10(SP), BP	
  0x436945		e8ec040100		CALL 0x446e36		
  0x43694a		488b6d00		MOVQ 0(BP), BP		
		traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr())
  0x43694e		488b842450010000	MOVQ 0x150(SP), AX		
  0x436956		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x43695e		48890424		MOVQ AX, 0(SP)			
  0x436962		488b842448010000	MOVQ 0x148(SP), AX		
  0x43696a		4889442408		MOVQ AX, 0x8(SP)		
  0x43696f		488b842470010000	MOVQ 0x170(SP), AX		
  0x436977		4889442410		MOVQ AX, 0x10(SP)		
  0x43697c		48894c2418		MOVQ CX, 0x18(SP)		
  0x436981		e83a6c0000		CALL runtime.traceback(SB)	
		throw("runtime: wrong goroutine in newstack")
  0x436986		488d054d650300		LEAQ 0x3654d(IP), AX	
  0x43698d		48890424		MOVQ AX, 0(SP)		
  0x436991		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x43699a		e831a8feff		CALL runtime.throw(SB)	
  0x43699f		0f0b			UD2			
		throw("stack growth after fork")
  0x4369a1		488d05424e0300		LEAQ 0x34e42(IP), AX	
  0x4369a8		48890424		MOVQ AX, 0(SP)		
  0x4369ac		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4369b5		e816a8feff		CALL runtime.throw(SB)	
  0x4369ba		0f0b			UD2			
func newstack() {
  0x4369bc		e8afdb0000		CALL runtime.morestack_noctxt(SB)	
  0x4369c1		e9eaf2ffff		JMP runtime.newstack(SB)		

TEXT runtime.shrinkstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func shrinkstack(gp *g) {
  0x4369d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4369d9		483b6110		CMPQ 0x10(CX), SP	
  0x4369dd		0f8663010000		JBE 0x436b46		
  0x4369e3		4883ec20		SUBQ $0x20, SP		
  0x4369e7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4369ec		488d6c2418		LEAQ 0x18(SP), BP	
  0x4369f1		488b442428		MOVQ 0x28(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x4369f6		8b8890000000		MOVL 0x90(AX), CX	
  0x4369fc		89ca			MOVL CX, DX		
	if gstatus&^_Gscan == _Gdead {
  0x4369fe		81e1ffefffff		ANDL $-0x1001, CX	
  0x436a04		83f906			CMPL $0x6, CX		
  0x436a07		7531			JNE 0x436a3a		
		if gp.stack.lo != 0 {
  0x436a09		488b08			MOVQ 0(AX), CX		
  0x436a0c		4885c9			TESTQ CX, CX		
  0x436a0f		750a			JNE 0x436a1b		
		return
  0x436a11		488b6c2418		MOVQ 0x18(SP), BP	
  0x436a16		4883c420		ADDQ $0x20, SP		
  0x436a1a		c3			RET			
			stackfree(gp.stack)
  0x436a1b		488b5008		MOVQ 0x8(AX), DX		
  0x436a1f		48890c24		MOVQ CX, 0(SP)			
  0x436a23		4889542408		MOVQ DX, 0x8(SP)		
  0x436a28		e803deffff		CALL runtime.stackfree(SB)	
			gp.stack.hi = 0
  0x436a2d		0f57c0			XORPS X0, X0		
  0x436a30		488b442428		MOVQ 0x28(SP), AX	
  0x436a35		0f1100			MOVUPS X0, 0(AX)	
  0x436a38		ebd7			JMP 0x436a11		
	if gp.stack.lo == 0 {
  0x436a3a		488b08			MOVQ 0(AX), CX		
  0x436a3d		4885c9			TESTQ CX, CX		
  0x436a40		0f84e5000000		JE 0x436b2b		
	if gstatus&_Gscan == 0 {
  0x436a46		0fbae20c		BTL $0xc, DX		
  0x436a4a		0f83c0000000		JAE 0x436b10		
	if debug.gcshrinkstackoff > 0 {
  0x436a50		8b0d7ed00800		MOVL runtime.debug+20(SB), CX	
  0x436a56		85c9			TESTL CX, CX			
  0x436a58		0f8fa8000000		JG 0x436b06			
	f := findfunc(gp.startpc)
  0x436a5e		488b8828010000		MOVQ 0x128(AX), CX		
  0x436a65		48890c24		MOVQ CX, 0(SP)			
  0x436a69		e862170000		CALL runtime.findfunc(SB)	
  0x436a6e		488b442408		MOVQ 0x8(SP), AX		
	return f._func != nil
  0x436a73		4885c0			TESTQ AX, AX		
	if f.valid() && f.funcID == funcID_gcBgMarkWorker {
  0x436a76		7408			JE 0x436a80		
  0x436a78		8b4010			MOVL 0x10(AX), AX	
  0x436a7b		83f80d			CMPL $0xd, AX		
  0x436a7e		747c			JE 0x436afc		
  0x436a80		488b442428		MOVQ 0x28(SP), AX	
	oldsize := gp.stack.hi - gp.stack.lo
  0x436a85		488b4808		MOVQ 0x8(AX), CX	
  0x436a89		488b10			MOVQ 0(AX), DX		
  0x436a8c		4889cb			MOVQ CX, BX		
  0x436a8f		4829d1			SUBQ DX, CX		
  0x436a92		4889ca			MOVQ CX, DX		
	newsize := oldsize / 2
  0x436a95		48d1e9			SHRQ $0x1, CX		
	if newsize < _FixedStack {
  0x436a98		4881f900080000		CMPQ $0x800, CX		
  0x436a9f		7251			JB 0x436af2		
	if used := gp.stack.hi - gp.sched.sp + _StackLimit; used >= avail/4 {
  0x436aa1		488b7038		MOVQ 0x38(AX), SI	
  0x436aa5		4829f3			SUBQ SI, BX		
  0x436aa8		4881c3f0020000		ADDQ $0x2f0, BX		
  0x436aaf		48c1ea02		SHRQ $0x2, DX		
  0x436ab3		4839d3			CMPQ DX, BX		
  0x436ab6		7330			JAE 0x436ae8		
	if gp.syscallsp != 0 {
  0x436ab8		488b5070		MOVQ 0x70(AX), DX	
  0x436abc		4885d2			TESTQ DX, DX		
  0x436abf		740a			JE 0x436acb		
		return
  0x436ac1		488b6c2418		MOVQ 0x18(SP), BP	
  0x436ac6		4883c420		ADDQ $0x20, SP		
  0x436aca		c3			RET			
	copystack(gp, newsize, false)
  0x436acb		48890424		MOVQ AX, 0(SP)			
  0x436acf		48894c2408		MOVQ CX, 0x8(SP)		
  0x436ad4		c644241000		MOVB $0x0, 0x10(SP)		
  0x436ad9		e862eeffff		CALL runtime.copystack(SB)	
}
  0x436ade		488b6c2418		MOVQ 0x18(SP), BP	
  0x436ae3		4883c420		ADDQ $0x20, SP		
  0x436ae7		c3			RET			
		return
  0x436ae8		488b6c2418		MOVQ 0x18(SP), BP	
  0x436aed		4883c420		ADDQ $0x20, SP		
  0x436af1		c3			RET			
		return
  0x436af2		488b6c2418		MOVQ 0x18(SP), BP	
  0x436af7		4883c420		ADDQ $0x20, SP		
  0x436afb		c3			RET			
		return
  0x436afc		488b6c2418		MOVQ 0x18(SP), BP	
  0x436b01		4883c420		ADDQ $0x20, SP		
  0x436b05		c3			RET			
		return
  0x436b06		488b6c2418		MOVQ 0x18(SP), BP	
  0x436b0b		4883c420		ADDQ $0x20, SP		
  0x436b0f		c3			RET			
		throw("bad status in shrinkstack")
  0x436b10		488d05b34e0300		LEAQ 0x34eb3(IP), AX	
  0x436b17		48890424		MOVQ AX, 0(SP)		
  0x436b1b		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x436b24		e8a7a6feff		CALL runtime.throw(SB)	
  0x436b29		0f0b			UD2			
		throw("missing stack in shrinkstack")
  0x436b2b		488d0510560300		LEAQ 0x35610(IP), AX	
  0x436b32		48890424		MOVQ AX, 0(SP)		
  0x436b36		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x436b3f		e88ca6feff		CALL runtime.throw(SB)	
  0x436b44		0f0b			UD2			
func shrinkstack(gp *g) {
  0x436b46		e825da0000		CALL runtime.morestack_noctxt(SB)	
  0x436b4b		e980feffff		JMP runtime.shrinkstack(SB)		

TEXT runtime.freeStackSpans(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func freeStackSpans() {
  0x436b50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x436b59		483b6110		CMPQ 0x10(CX), SP	
  0x436b5d		0f868b010000		JBE 0x436cee		
  0x436b63		4883ec60		SUBQ $0x60, SP		
  0x436b67		48896c2458		MOVQ BP, 0x58(SP)	
  0x436b6c		488d6c2458		LEAQ 0x58(SP), BP	
	lock(&stackpoolmu)
  0x436b71		488d0558ce0800		LEAQ runtime.stackpoolmu(SB), AX	
  0x436b78		48890424		MOVQ AX, 0(SP)				
  0x436b7c		e89f29fdff		CALL runtime.lock(SB)			
  0x436b81		31c0			XORL AX, AX				
	for order := range stackpool {
  0x436b83		eb76			JMP 0x436bfb		
  0x436b85		4889f0			MOVQ SI, AX		
		for s := list.first; s != nil; {
  0x436b88		4885c0			TESTQ AX, AX		
  0x436b8b		746a			JE 0x436bf7		
			next := s.next
  0x436b8d		488b30			MOVQ 0(AX), SI		
			if s.allocCount == 0 {
  0x436b90		0fb77860		MOVZX 0x60(AX), DI	
  0x436b94		6685ff			TESTW DI, DI		
  0x436b97		75ec			JNE 0x436b85		
  0x436b99		4889442430		MOVQ AX, 0x30(SP)	
  0x436b9e		4889742438		MOVQ SI, 0x38(SP)	
				list.remove(s)
  0x436ba3		48891c24		MOVQ BX, 0(SP)				
  0x436ba7		4889442408		MOVQ AX, 0x8(SP)			
  0x436bac		e8ff54feff		CALL runtime.(*mSpanList).remove(SB)	
  0x436bb1		488b442430		MOVQ 0x30(SP), AX			
				s.manualFreeList = 0
  0x436bb6		48c7402800000000	MOVQ $0x0, 0x28(AX)	
				mheap_.freeManual(s, &memstats.stacks_inuse)
  0x436bbe		488d0ddb560700		LEAQ runtime.mheap_(SB), CX		
  0x436bc5		48890c24		MOVQ CX, 0(SP)				
  0x436bc9		4889442408		MOVQ AX, 0x8(SP)			
  0x436bce		488d058bdb0800		LEAQ runtime.memstats+96(SB), AX	
  0x436bd5		4889442410		MOVQ AX, 0x10(SP)			
  0x436bda		e82149feff		CALL runtime.(*mheap).freeManual(SB)	
  0x436bdf		488b4c2418		MOVQ 0x18(SP), CX			
  0x436be4		488d15550c0700		LEAQ runtime.stackpool(SB), DX		
  0x436beb		488b5c2448		MOVQ 0x48(SP), BX			
  0x436bf0		488b742438		MOVQ 0x38(SP), SI			
  0x436bf5		eb8e			JMP 0x436b85				
	for order := range stackpool {
  0x436bf7		488d4101		LEAQ 0x1(CX), AX	
  0x436bfb		4883f804		CMPQ $0x4, AX		
  0x436bff		7d25			JGE 0x436c26		
  0x436c01		4889442418		MOVQ AX, 0x18(SP)	
  0x436c06		4889c1			MOVQ AX, CX		
		list := &stackpool[order]
  0x436c09		48c1e004		SHLQ $0x4, AX			
  0x436c0d		488d152c0c0700		LEAQ runtime.stackpool(SB), DX	
  0x436c14		488d1c02		LEAQ 0(DX)(AX*1), BX		
  0x436c18		48895c2448		MOVQ BX, 0x48(SP)		
		for s := list.first; s != nil; {
  0x436c1d		488b0402		MOVQ 0(DX)(AX*1), AX	
  0x436c21		e962ffffff		JMP 0x436b88		
	unlock(&stackpoolmu)
  0x436c26		488d05a3cd0800		LEAQ runtime.stackpoolmu(SB), AX	
  0x436c2d		48890424		MOVQ AX, 0(SP)				
  0x436c31		e88a2afdff		CALL runtime.unlock(SB)			
	lock(&stackLarge.lock)
  0x436c36		488d05a30f0700		LEAQ runtime.stackLarge(SB), AX	
  0x436c3d		48890424		MOVQ AX, 0(SP)			
  0x436c41		e8da28fdff		CALL runtime.lock(SB)		
  0x436c46		31c0			XORL AX, AX			
	for i := range stackLarge.free {
  0x436c48		eb60			JMP 0x436caa		
  0x436c4a		48895c2428		MOVQ BX, 0x28(SP)	
			next := s.next
  0x436c4f		488b0b			MOVQ 0(BX), CX		
  0x436c52		48894c2440		MOVQ CX, 0x40(SP)	
			stackLarge.free[i].remove(s)
  0x436c57		48890424		MOVQ AX, 0(SP)				
  0x436c5b		48895c2408		MOVQ BX, 0x8(SP)			
  0x436c60		e84b54feff		CALL runtime.(*mSpanList).remove(SB)	
			mheap_.freeManual(s, &memstats.stacks_inuse)
  0x436c65		488d0534560700		LEAQ runtime.mheap_(SB), AX		
  0x436c6c		48890424		MOVQ AX, 0(SP)				
  0x436c70		488b4c2428		MOVQ 0x28(SP), CX			
  0x436c75		48894c2408		MOVQ CX, 0x8(SP)			
  0x436c7a		488d0ddfda0800		LEAQ runtime.memstats+96(SB), CX	
  0x436c81		48894c2410		MOVQ CX, 0x10(SP)			
  0x436c86		e87548feff		CALL runtime.(*mheap).freeManual(SB)	
  0x436c8b		488b442450		MOVQ 0x50(SP), AX			
  0x436c90		488b4c2420		MOVQ 0x20(SP), CX			
  0x436c95		488d15440f0700		LEAQ runtime.stackLarge(SB), DX		
  0x436c9c		488b5c2440		MOVQ 0x40(SP), BX			
		for s := stackLarge.free[i].first; s != nil; {
  0x436ca1		4885db			TESTQ BX, BX		
  0x436ca4		75a4			JNE 0x436c4a		
	for i := range stackLarge.free {
  0x436ca6		488d4101		LEAQ 0x1(CX), AX	
  0x436caa		4883f81a		CMPQ $0x1a, AX		
  0x436cae		7d24			JGE 0x436cd4		
  0x436cb0		4889442420		MOVQ AX, 0x20(SP)	
  0x436cb5		4889c1			MOVQ AX, CX		
		for s := stackLarge.free[i].first; s != nil; {
  0x436cb8		48c1e004		SHLQ $0x4, AX			
  0x436cbc		488d151d0f0700		LEAQ runtime.stackLarge(SB), DX	
  0x436cc3		488b5c0208		MOVQ 0x8(DX)(AX*1), BX		
  0x436cc8		488d440208		LEAQ 0x8(DX)(AX*1), AX		
  0x436ccd		4889442450		MOVQ AX, 0x50(SP)		
  0x436cd2		ebcd			JMP 0x436ca1			
	unlock(&stackLarge.lock)
  0x436cd4		488d05050f0700		LEAQ runtime.stackLarge(SB), AX	
  0x436cdb		48890424		MOVQ AX, 0(SP)			
  0x436cdf		e8dc29fdff		CALL runtime.unlock(SB)		
}
  0x436ce4		488b6c2458		MOVQ 0x58(SP), BP	
  0x436ce9		4883c460		ADDQ $0x60, SP		
  0x436ced		c3			RET			
func freeStackSpans() {
  0x436cee		e87dd80000		CALL runtime.morestack_noctxt(SB)	
  0x436cf3		e958feffff		JMP runtime.freeStackSpans(SB)		

TEXT runtime.morestackc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
func morestackc() {
  0x436d00		4883ec10		SUBQ $0x10, SP		
  0x436d04		48896c2408		MOVQ BP, 0x8(SP)	
  0x436d09		488d6c2408		LEAQ 0x8(SP), BP	
	systemstack(func() {
  0x436d0e		488d0553740300		LEAQ 0x37453(IP), AX		
  0x436d15		48890424		MOVQ AX, 0(SP)			
  0x436d19		e802d70000		CALL runtime.systemstack(SB)	
}
  0x436d1e		488b6c2408		MOVQ 0x8(SP), BP	
  0x436d23		4883c410		ADDQ $0x10, SP		
  0x436d27		c3			RET			

TEXT runtime.concatstrings(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func concatstrings(buf *tmpBuf, a []string) string {
  0x436d30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x436d39		488d4424f0		LEAQ -0x10(SP), AX	
  0x436d3e		483b4110		CMPQ 0x10(CX), AX	
  0x436d42		0f8681020000		JBE 0x436fc9		
  0x436d48		4881ec90000000		SUBQ $0x90, SP		
  0x436d4f		4889ac2488000000	MOVQ BP, 0x88(SP)	
  0x436d57		488dac2488000000	LEAQ 0x88(SP), BP	
  0x436d5f		0f57c0			XORPS X0, X0		
  0x436d62		0f11442478		MOVUPS X0, 0x78(SP)	
  0x436d67		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x436d6f		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x436d77		4889c2			MOVQ AX, DX		
  0x436d7a		31db			XORL BX, BX		
  0x436d7c		4889de			MOVQ BX, SI		
  0x436d7f		4889f7			MOVQ SI, DI		
  0x436d82		4989f8			MOVQ DI, R8		
	for i, x := range a {
  0x436d85		eb07			JMP 0x436d8e		
  0x436d87		4883c010		ADDQ $0x10, AX		
  0x436d8b		48ffc3			INCQ BX			
  0x436d8e		4839cb			CMPQ CX, BX		
  0x436d91		7d21			JGE 0x436db4		
  0x436d93		4c8b4808		MOVQ 0x8(AX), R9	
		if n == 0 {
  0x436d97		4d85c9			TESTQ R9, R9		
  0x436d9a		74eb			JE 0x436d87		
		if l+n < l {
  0x436d9c		4b8d3c08		LEAQ 0(R8)(R9*1), DI	
  0x436da0		4c39c7			CMPQ R8, DI		
  0x436da3		0f8c05020000		JL 0x436fae		
		count++
  0x436da9		48ffc6			INCQ SI			
  0x436dac		4989f8			MOVQ DI, R8		
  0x436daf		4889df			MOVQ BX, DI		
		idx = i
  0x436db2		ebd3			JMP 0x436d87		
	if count == 0 {
  0x436db4		4885f6			TESTQ SI, SI		
  0x436db7		0f84c1010000		JE 0x436f7e		
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x436dbd		4883fe01		CMPQ $0x1, SI		
  0x436dc1		0f85aa010000		JNE 0x436f71		
  0x436dc7		488b842498000000	MOVQ 0x98(SP), AX	
  0x436dcf		4885c0			TESTQ AX, AX		
  0x436dd2		0f8594010000		JNE 0x436f6c		
  0x436dd8		4839cf			CMPQ CX, DI		
  0x436ddb		0f83c6010000		JAE 0x436fa7		
  0x436de1		4889fb			MOVQ DI, BX		
  0x436de4		48c1e704		SHLQ $0x4, DI		
  0x436de8		488b743a08		MOVQ 0x8(DX)(DI*1), SI	
  0x436ded		488b3c3a		MOVQ 0(DX)(DI*1), DI	
  0x436df1		48897c2478		MOVQ DI, 0x78(SP)	
  0x436df6		4889b42480000000	MOVQ SI, 0x80(SP)	
	ptr := uintptr(stringStructOf(&s).str)
  0x436dfe		488b742478		MOVQ 0x78(SP), SI	
	stk := getg().stack
  0x436e03		64488b3c25f8ffffff	MOVQ FS:0xfffffff8, DI	
  0x436e0c		4c8b4f08		MOVQ 0x8(DI), R9	
  0x436e10		488b3f			MOVQ 0(DI), DI		
	return stk.lo <= ptr && ptr < stk.hi
  0x436e13		4839f7			CMPQ SI, DI		
  0x436e16		0f8749010000		JA 0x436f65		
  0x436e1c		4c39ce			CMPQ R9, SI		
  0x436e1f		400f92c6		SETB SI			
  0x436e23		4084f6			TESTL SI, SI		
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x436e26		0f8407010000		JE 0x436f33		
	s, b := rawstringtmp(buf, l)
  0x436e2c		48890424		MOVQ AX, 0(SP)			
  0x436e30		4c89442408		MOVQ R8, 0x8(SP)		
  0x436e35		e846030000		CALL runtime.rawstringtmp(SB)	
  0x436e3a		488b442428		MOVQ 0x28(SP), AX		
  0x436e3f		488b4c2418		MOVQ 0x18(SP), CX		
  0x436e44		48894c2440		MOVQ CX, 0x40(SP)		
  0x436e49		488b542430		MOVQ 0x30(SP), DX		
  0x436e4e		488b5c2420		MOVQ 0x20(SP), BX		
  0x436e53		488b742410		MOVQ 0x10(SP), SI		
  0x436e58		4889742460		MOVQ SI, 0x60(SP)		
  0x436e5d		31ff			XORL DI, DI			
  0x436e5f		4c8b8424a0000000	MOVQ 0xa0(SP), R8		
	for _, x := range a {
  0x436e67		eb43			JMP 0x436eac		
  0x436e69		4c8b4c2470		MOVQ 0x70(SP), R9	
  0x436e6e		4d8d4110		LEAQ 0x10(R9), R8	
  0x436e72		4c8b4c2458		MOVQ 0x58(SP), R9	
  0x436e77		498d7901		LEAQ 0x1(R9), DI	
		b = b[len(x):]
  0x436e7b		4829c1			SUBQ AX, CX		
  0x436e7e		488b542450		MOVQ 0x50(SP), DX	
  0x436e83		4829c2			SUBQ AX, DX		
  0x436e86		4989d1			MOVQ DX, R9		
  0x436e89		48f7da			NEGQ DX			
  0x436e8c		48c1fa3f		SARQ $0x3f, DX		
  0x436e90		4821d0			ANDQ DX, AX		
  0x436e93		4c8b542468		MOVQ 0x68(SP), R10	
  0x436e98		498d1c02		LEAQ 0(R10)(AX*1), BX	
  0x436e9c		488b742460		MOVQ 0x60(SP), SI	
  0x436ea1		4889c8			MOVQ CX, AX		
  0x436ea4		4c89ca			MOVQ R9, DX		
  0x436ea7		488b4c2440		MOVQ 0x40(SP), CX	
	for _, x := range a {
  0x436eac		4c8b8c24a8000000	MOVQ 0xa8(SP), R9	
  0x436eb4		4c39cf			CMPQ R9, DI		
  0x436eb7		7d5a			JGE 0x436f13		
  0x436eb9		4889442448		MOVQ AX, 0x48(SP)	
  0x436ebe		48897c2458		MOVQ DI, 0x58(SP)	
  0x436ec3		4889542450		MOVQ DX, 0x50(SP)	
  0x436ec8		4c89442470		MOVQ R8, 0x70(SP)	
  0x436ecd		4d8b10			MOVQ 0(R8), R10		
  0x436ed0		4d8b5808		MOVQ 0x8(R8), R11	
  0x436ed4		4c895c2438		MOVQ R11, 0x38(SP)	
		copy(b, x)
  0x436ed9		4c39d8			CMPQ R11, AX			
  0x436edc		7e30			JLE 0x436f0e			
  0x436ede		48895c2468		MOVQ BX, 0x68(SP)		
  0x436ee3		48891c24		MOVQ BX, 0(SP)			
  0x436ee7		4c89542408		MOVQ R10, 0x8(SP)		
  0x436eec		4c895c2410		MOVQ R11, 0x10(SP)		
  0x436ef1		e80a020100		CALL runtime.memmove(SB)	
  0x436ef6		488b442438		MOVQ 0x38(SP), AX		
  0x436efb		488b4c2448		MOVQ 0x48(SP), CX		
		b = b[len(x):]
  0x436f00		4839c8			CMPQ CX, AX		
  0x436f03		0f8660ffffff		JBE 0x436e69		
  0x436f09		e98b000000		JMP 0x436f99		
  0x436f0e		4989c3			MOVQ AX, R11		
		copy(b, x)
  0x436f11		ebcb			JMP 0x436ede		
	return s
  0x436f13		4889b424b8000000	MOVQ SI, 0xb8(SP)	
  0x436f1b		48898c24c0000000	MOVQ CX, 0xc0(SP)	
  0x436f23		488bac2488000000	MOVQ 0x88(SP), BP	
  0x436f2b		4881c490000000		ADDQ $0x90, SP		
  0x436f32		c3			RET			
		return a[idx]
  0x436f33		4839cb			CMPQ CX, BX		
  0x436f36		7368			JAE 0x436fa0		
  0x436f38		48c1e304		SHLQ $0x4, BX		
  0x436f3c		488b441a08		MOVQ 0x8(DX)(BX*1), AX	
  0x436f41		488b0c1a		MOVQ 0(DX)(BX*1), CX	
  0x436f45		48898c24b8000000	MOVQ CX, 0xb8(SP)	
  0x436f4d		48898424c0000000	MOVQ AX, 0xc0(SP)	
  0x436f55		488bac2488000000	MOVQ 0x88(SP), BP	
  0x436f5d		4881c490000000		ADDQ $0x90, SP		
  0x436f64		c3			RET			
  0x436f65		31f6			XORL SI, SI		
	return stk.lo <= ptr && ptr < stk.hi
  0x436f67		e9b7feffff		JMP 0x436e23		
  0x436f6c		4889fb			MOVQ DI, BX		
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x436f6f		ebc2			JMP 0x436f33		
  0x436f71		488b842498000000	MOVQ 0x98(SP), AX	
  0x436f79		e9aefeffff		JMP 0x436e2c		
		return ""
  0x436f7e		0f57c0			XORPS X0, X0		
  0x436f81		0f118424b8000000	MOVUPS X0, 0xb8(SP)	
  0x436f89		488bac2488000000	MOVQ 0x88(SP), BP	
  0x436f91		4881c490000000		ADDQ $0x90, SP		
  0x436f98		c3			RET			
		b = b[len(x):]
  0x436f99		e8128bfeff		CALL runtime.panicslice(SB)	
  0x436f9e		0f0b			UD2				
		return a[idx]
  0x436fa0		e89b8afeff		CALL runtime.panicindex(SB)	
  0x436fa5		0f0b			UD2				
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x436fa7		e8948afeff		CALL runtime.panicindex(SB)	
  0x436fac		0f0b			UD2				
			throw("string concatenation too long")
  0x436fae		488d0504540300		LEAQ 0x35404(IP), AX	
  0x436fb5		48890424		MOVQ AX, 0(SP)		
  0x436fb9		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x436fc2		e809a2feff		CALL runtime.throw(SB)	
  0x436fc7		0f0b			UD2			
func concatstrings(buf *tmpBuf, a []string) string {
  0x436fc9		e8a2d50000		CALL runtime.morestack_noctxt(SB)	
  0x436fce		e95dfdffff		JMP runtime.concatstrings(SB)		

TEXT runtime.concatstring2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func concatstring2(buf *tmpBuf, a [2]string) string {
  0x436fe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x436fe9		483b6110		CMPQ 0x10(CX), SP	
  0x436fed		7656			JBE 0x437045		
  0x436fef		4883ec38		SUBQ $0x38, SP		
  0x436ff3		48896c2430		MOVQ BP, 0x30(SP)	
  0x436ff8		488d6c2430		LEAQ 0x30(SP), BP	
  0x436ffd		488b442440		MOVQ 0x40(SP), AX	
	return concatstrings(buf, a[:])
  0x437002		48890424		MOVQ AX, 0(SP)			
  0x437006		488d442448		LEAQ 0x48(SP), AX		
  0x43700b		4889442408		MOVQ AX, 0x8(SP)		
  0x437010		48c744241002000000	MOVQ $0x2, 0x10(SP)		
  0x437019		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x437022		e809fdffff		CALL runtime.concatstrings(SB)	
  0x437027		488b442420		MOVQ 0x20(SP), AX		
  0x43702c		488b4c2428		MOVQ 0x28(SP), CX		
  0x437031		4889442468		MOVQ AX, 0x68(SP)		
  0x437036		48894c2470		MOVQ CX, 0x70(SP)		
  0x43703b		488b6c2430		MOVQ 0x30(SP), BP		
  0x437040		4883c438		ADDQ $0x38, SP			
  0x437044		c3			RET				
func concatstring2(buf *tmpBuf, a [2]string) string {
  0x437045		e826d50000		CALL runtime.morestack_noctxt(SB)	
  0x43704a		eb94			JMP runtime.concatstring2(SB)		

TEXT runtime.concatstring4(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func concatstring4(buf *tmpBuf, a [4]string) string {
  0x437050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437059		483b6110		CMPQ 0x10(CX), SP	
  0x43705d		765c			JBE 0x4370bb		
  0x43705f		4883ec38		SUBQ $0x38, SP		
  0x437063		48896c2430		MOVQ BP, 0x30(SP)	
  0x437068		488d6c2430		LEAQ 0x30(SP), BP	
  0x43706d		488b442440		MOVQ 0x40(SP), AX	
	return concatstrings(buf, a[:])
  0x437072		48890424		MOVQ AX, 0(SP)			
  0x437076		488d442448		LEAQ 0x48(SP), AX		
  0x43707b		4889442408		MOVQ AX, 0x8(SP)		
  0x437080		48c744241004000000	MOVQ $0x4, 0x10(SP)		
  0x437089		48c744241804000000	MOVQ $0x4, 0x18(SP)		
  0x437092		e899fcffff		CALL runtime.concatstrings(SB)	
  0x437097		488b442420		MOVQ 0x20(SP), AX		
  0x43709c		488b4c2428		MOVQ 0x28(SP), CX		
  0x4370a1		4889842488000000	MOVQ AX, 0x88(SP)		
  0x4370a9		48898c2490000000	MOVQ CX, 0x90(SP)		
  0x4370b1		488b6c2430		MOVQ 0x30(SP), BP		
  0x4370b6		4883c438		ADDQ $0x38, SP			
  0x4370ba		c3			RET				
func concatstring4(buf *tmpBuf, a [4]string) string {
  0x4370bb		e8b0d40000		CALL runtime.morestack_noctxt(SB)	
  0x4370c0		eb8e			JMP runtime.concatstring4(SB)		

TEXT runtime.slicebytetostring(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func slicebytetostring(buf *tmpBuf, b []byte) (str string) {
  0x4370d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4370d9		483b6110		CMPQ 0x10(CX), SP	
  0x4370dd		0f8693000000		JBE 0x437176		
  0x4370e3		4883ec28		SUBQ $0x28, SP		
  0x4370e7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4370ec		488d6c2420		LEAQ 0x20(SP), BP	
  0x4370f1		0f57c0			XORPS X0, X0		
  0x4370f4		0f11442450		MOVUPS X0, 0x50(SP)	
	l := len(b)
  0x4370f9		488b442440		MOVQ 0x40(SP), AX	
	if l == 0 {
  0x4370fe		4885c0			TESTQ AX, AX		
  0x437101		7464			JE 0x437167		
  0x437103		488b4c2430		MOVQ 0x30(SP), CX	
	if buf != nil && len(b) <= len(buf) {
  0x437108		4885c9			TESTQ CX, CX		
  0x43710b		743c			JE 0x437149		
  0x43710d		4883f820		CMPQ $0x20, AX		
  0x437111		7f36			JG 0x437149		
	stringStructOf(&str).str = p
  0x437113		48894c2450		MOVQ CX, 0x50(SP)	
	stringStructOf(&str).len = len(b)
  0x437118		488b442440		MOVQ 0x40(SP), AX	
  0x43711d		4889442458		MOVQ AX, 0x58(SP)	
	memmove(p, (*(*slice)(unsafe.Pointer(&b))).array, uintptr(len(b)))
  0x437122		488b442438		MOVQ 0x38(SP), AX		
  0x437127		488b542440		MOVQ 0x40(SP), DX		
  0x43712c		4889442408		MOVQ AX, 0x8(SP)		
  0x437131		48890c24		MOVQ CX, 0(SP)			
  0x437135		4889542410		MOVQ DX, 0x10(SP)		
  0x43713a		e8c1ff0000		CALL runtime.memmove(SB)	
	return
  0x43713f		488b6c2420		MOVQ 0x20(SP), BP	
  0x437144		4883c428		ADDQ $0x28, SP		
  0x437148		c3			RET			
		p = mallocgc(uintptr(len(b)), nil, false)
  0x437149		48890424		MOVQ AX, 0(SP)			
  0x43714d		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x437156		c644241000		MOVB $0x0, 0x10(SP)		
  0x43715b		e8b034fdff		CALL runtime.mallocgc(SB)	
  0x437160		488b4c2418		MOVQ 0x18(SP), CX		
  0x437165		ebac			JMP 0x437113			
		return ""
  0x437167		0f11442450		MOVUPS X0, 0x50(SP)	
  0x43716c		488b6c2420		MOVQ 0x20(SP), BP	
  0x437171		4883c428		ADDQ $0x28, SP		
  0x437175		c3			RET			
func slicebytetostring(buf *tmpBuf, b []byte) (str string) {
  0x437176		e8f5d30000		CALL runtime.morestack_noctxt(SB)	
  0x43717b		e950ffffff		JMP runtime.slicebytetostring(SB)	

TEXT runtime.rawstringtmp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {
  0x437180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437189		483b6110		CMPQ 0x10(CX), SP	
  0x43718d		0f8685000000		JBE 0x437218		
  0x437193		4883ec38		SUBQ $0x38, SP		
  0x437197		48896c2430		MOVQ BP, 0x30(SP)	
  0x43719c		488d6c2430		LEAQ 0x30(SP), BP	
  0x4371a1		488b442440		MOVQ 0x40(SP), AX	
	if buf != nil && l <= len(buf) {
  0x4371a6		4885c0			TESTQ AX, AX		
  0x4371a9		745f			JE 0x43720a		
  0x4371ab		488b4c2448		MOVQ 0x48(SP), CX	
  0x4371b0		4883f920		CMPQ $0x20, CX		
  0x4371b4		7f30			JG 0x4371e6		
		b = buf[:l]
  0x4371b6		7759			JA 0x437211		
  0x4371b8		4889ca			MOVQ CX, DX		
  0x4371bb		4889c3			MOVQ AX, BX		
  0x4371be		be20000000		MOVL $0x20, SI		
	return
  0x4371c3		4889442450		MOVQ AX, 0x50(SP)	
  0x4371c8		4889542458		MOVQ DX, 0x58(SP)	
  0x4371cd		48895c2460		MOVQ BX, 0x60(SP)	
  0x4371d2		48894c2468		MOVQ CX, 0x68(SP)	
  0x4371d7		4889742470		MOVQ SI, 0x70(SP)	
  0x4371dc		488b6c2430		MOVQ 0x30(SP), BP	
  0x4371e1		4883c438		ADDQ $0x38, SP		
  0x4371e5		c3			RET			
		s, b = rawstring(l)
  0x4371e6		48890c24		MOVQ CX, 0(SP)			
  0x4371ea		e841000000		CALL runtime.rawstring(SB)	
  0x4371ef		488b442408		MOVQ 0x8(SP), AX		
  0x4371f4		488b542410		MOVQ 0x10(SP), DX		
  0x4371f9		488b5c2418		MOVQ 0x18(SP), BX		
  0x4371fe		488b4c2420		MOVQ 0x20(SP), CX		
  0x437203		488b742428		MOVQ 0x28(SP), SI		
  0x437208		ebb9			JMP 0x4371c3			
  0x43720a		488b4c2448		MOVQ 0x48(SP), CX		
	if buf != nil && l <= len(buf) {
  0x43720f		ebd5			JMP 0x4371e6		
		b = buf[:l]
  0x437211		e89a88feff		CALL runtime.panicslice(SB)	
  0x437216		0f0b			UD2				
func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {
  0x437218		e853d30000		CALL runtime.morestack_noctxt(SB)	
  0x43721d		e95effffff		JMP runtime.rawstringtmp(SB)		

TEXT runtime.rawstring(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func rawstring(size int) (s string, b []byte) {
  0x437230		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437239		483b6110		CMPQ 0x10(CX), SP	
  0x43723d		766d			JBE 0x4372ac		
  0x43723f		4883ec28		SUBQ $0x28, SP		
  0x437243		48896c2420		MOVQ BP, 0x20(SP)	
  0x437248		488d6c2420		LEAQ 0x20(SP), BP	
  0x43724d		0f57c0			XORPS X0, X0		
  0x437250		0f11442438		MOVUPS X0, 0x38(SP)	
  0x437255		48c744244800000000	MOVQ $0x0, 0x48(SP)	
  0x43725e		0f11442450		MOVUPS X0, 0x50(SP)	
  0x437263		488b442430		MOVQ 0x30(SP), AX	
	p := mallocgc(uintptr(size), nil, false)
  0x437268		48890424		MOVQ AX, 0(SP)			
  0x43726c		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x437275		c644241000		MOVB $0x0, 0x10(SP)		
  0x43727a		e89133fdff		CALL runtime.mallocgc(SB)	
  0x43727f		488b442418		MOVQ 0x18(SP), AX		
	stringStructOf(&s).str = p
  0x437284		4889442438		MOVQ AX, 0x38(SP)	
  0x437289		488b4c2430		MOVQ 0x30(SP), CX	
	stringStructOf(&s).len = size
  0x43728e		48894c2440		MOVQ CX, 0x40(SP)	
	*(*slice)(unsafe.Pointer(&b)) = slice{p, size, size}
  0x437293		4889442448		MOVQ AX, 0x48(SP)	
  0x437298		48894c2450		MOVQ CX, 0x50(SP)	
  0x43729d		48894c2458		MOVQ CX, 0x58(SP)	
	return
  0x4372a2		488b6c2420		MOVQ 0x20(SP), BP	
  0x4372a7		4883c428		ADDQ $0x28, SP		
  0x4372ab		c3			RET			
func rawstring(size int) (s string, b []byte) {
  0x4372ac		e8bfd20000		CALL runtime.morestack_noctxt(SB)	
  0x4372b1		e97affffff		JMP runtime.rawstring(SB)		

TEXT runtime.gostring(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func gostring(p *byte) string {
  0x4372c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4372c9		483b6110		CMPQ 0x10(CX), SP	
  0x4372cd		0f86ab000000		JBE 0x43737e		
  0x4372d3		4883ec50		SUBQ $0x50, SP		
  0x4372d7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4372dc		488d6c2448		LEAQ 0x48(SP), BP	
  0x4372e1		488b442458		MOVQ 0x58(SP), AX	
	l := findnull(p)
  0x4372e6		48890424		MOVQ AX, 0(SP)			
  0x4372ea		e8c1030000		CALL runtime.findnull(SB)	
  0x4372ef		488b442408		MOVQ 0x8(SP), AX		
	if l == 0 {
  0x4372f4		4885c0			TESTQ AX, AX		
  0x4372f7		746c			JE 0x437365		
  0x4372f9		4889442438		MOVQ AX, 0x38(SP)	
	s, b := rawstring(l)
  0x4372fe		48890424		MOVQ AX, 0(SP)			
  0x437302		e829ffffff		CALL runtime.rawstring(SB)	
  0x437307		488b442410		MOVQ 0x10(SP), AX		
  0x43730c		488b4c2420		MOVQ 0x20(SP), CX		
  0x437311		488b542418		MOVQ 0x18(SP), DX		
  0x437316		488b5c2408		MOVQ 0x8(SP), BX		
	memmove(unsafe.Pointer(&b[0]), unsafe.Pointer(p), uintptr(l))
  0x43731b		4885c9			TESTQ CX, CX			
  0x43731e		7657			JBE 0x437377			
  0x437320		4889442430		MOVQ AX, 0x30(SP)		
  0x437325		48895c2440		MOVQ BX, 0x40(SP)		
  0x43732a		48891424		MOVQ DX, 0(SP)			
  0x43732e		488b442458		MOVQ 0x58(SP), AX		
  0x437333		4889442408		MOVQ AX, 0x8(SP)		
  0x437338		488b442438		MOVQ 0x38(SP), AX		
  0x43733d		4889442410		MOVQ AX, 0x10(SP)		
  0x437342		e8b9fd0000		CALL runtime.memmove(SB)	
	return s
  0x437347		488b442440		MOVQ 0x40(SP), AX	
  0x43734c		4889442460		MOVQ AX, 0x60(SP)	
  0x437351		488b442430		MOVQ 0x30(SP), AX	
  0x437356		4889442468		MOVQ AX, 0x68(SP)	
  0x43735b		488b6c2448		MOVQ 0x48(SP), BP	
  0x437360		4883c450		ADDQ $0x50, SP		
  0x437364		c3			RET			
		return ""
  0x437365		0f57c0			XORPS X0, X0		
  0x437368		0f11442460		MOVUPS X0, 0x60(SP)	
  0x43736d		488b6c2448		MOVQ 0x48(SP), BP	
  0x437372		4883c450		ADDQ $0x50, SP		
  0x437376		c3			RET			
	memmove(unsafe.Pointer(&b[0]), unsafe.Pointer(p), uintptr(l))
  0x437377		e8c486feff		CALL runtime.panicindex(SB)	
  0x43737c		0f0b			UD2				
func gostring(p *byte) string {
  0x43737e		e8edd10000		CALL runtime.morestack_noctxt(SB)	
  0x437383		e938ffffff		JMP runtime.gostring(SB)		

TEXT runtime.index(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func index(s, t string) int {
  0x437390		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437399		483b6110		CMPQ 0x10(CX), SP	
  0x43739d		0f86de000000		JBE 0x437481		
  0x4373a3		4883ec30		SUBQ $0x30, SP		
  0x4373a7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4373ac		488d6c2428		LEAQ 0x28(SP), BP	
  0x4373b1		488b442450		MOVQ 0x50(SP), AX	
	if len(t) == 0 {
  0x4373b6		4885c0			TESTQ AX, AX		
  0x4373b9		0f84af000000		JE 0x43746e		
  0x4373bf		31c9			XORL CX, CX		
	for i := 0; i < len(s); i++ {
  0x4373c1		eb03			JMP 0x4373c6		
  0x4373c3		48ffc1			INCQ CX			
  0x4373c6		488b542440		MOVQ 0x40(SP), DX	
  0x4373cb		4839d1			CMPQ DX, CX		
  0x4373ce		0f8d87000000		JGE 0x43745b		
  0x4373d4		488b5c2438		MOVQ 0x38(SP), BX	
		if s[i] == t[0] && hasprefix(s[i:], t) {
  0x4373d9		0fb6340b		MOVZX 0(BX)(CX*1), SI	
  0x4373dd		488b7c2448		MOVQ 0x48(SP), DI	
  0x4373e2		440fb607		MOVZX 0(DI), R8		
  0x4373e6		4438c6			CMPL R8, SI		
  0x4373e9		7568			JNE 0x437453		
  0x4373eb		4889d6			MOVQ DX, SI		
  0x4373ee		4829ca			SUBQ CX, DX		
  0x4373f1		4989d0			MOVQ DX, R8		
  0x4373f4		48f7da			NEGQ DX			
  0x4373f7		48c1fa3f		SARQ $0x3f, DX		
  0x4373fb		4821ca			ANDQ CX, DX		
  0x4373fe		4801da			ADDQ BX, DX		
	return len(s) >= len(t) && s[:len(t)] == t
  0x437401		4939c0			CMPQ AX, R8		
  0x437404		7d15			JGE 0x43741b		
  0x437406		31d2			XORL DX, DX		
  0x437408		84d2			TESTL DL, DL		
		if s[i] == t[0] && hasprefix(s[i:], t) {
  0x43740a		74b7			JE 0x4373c3		
			return i
  0x43740c		48894c2458		MOVQ CX, 0x58(SP)	
  0x437411		488b6c2428		MOVQ 0x28(SP), BP	
  0x437416		4883c430		ADDQ $0x30, SP		
  0x43741a		c3			RET			
  0x43741b		48894c2420		MOVQ CX, 0x20(SP)	
	return len(s) >= len(t) && s[:len(t)] == t
  0x437420		48891424		MOVQ DX, 0(SP)			
  0x437424		48897c2408		MOVQ DI, 0x8(SP)		
  0x437429		4889442410		MOVQ AX, 0x10(SP)		
  0x43742e		e80def0000		CALL runtime.memequal(SB)	
  0x437433		0fb6542418		MOVZX 0x18(SP), DX		
  0x437438		488b442450		MOVQ 0x50(SP), AX		
  0x43743d		488b4c2420		MOVQ 0x20(SP), CX		
  0x437442		488b5c2438		MOVQ 0x38(SP), BX		
  0x437447		488b742440		MOVQ 0x40(SP), SI		
  0x43744c		488b7c2448		MOVQ 0x48(SP), DI		
  0x437451		ebb5			JMP 0x437408			
  0x437453		4889d6			MOVQ DX, SI			
		if s[i] == t[0] && hasprefix(s[i:], t) {
  0x437456		e968ffffff		JMP 0x4373c3		
	return -1
  0x43745b		48c7442458ffffffff	MOVQ $-0x1, 0x58(SP)	
  0x437464		488b6c2428		MOVQ 0x28(SP), BP	
  0x437469		4883c430		ADDQ $0x30, SP		
  0x43746d		c3			RET			
		return 0
  0x43746e		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x437477		488b6c2428		MOVQ 0x28(SP), BP	
  0x43747c		4883c430		ADDQ $0x30, SP		
  0x437480		c3			RET			
func index(s, t string) int {
  0x437481		e8ead00000		CALL runtime.morestack_noctxt(SB)	
  0x437486		e905ffffff		JMP runtime.index(SB)			

TEXT runtime.contains(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func contains(s, t string) bool {
  0x437490		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437499		483b6110		CMPQ 0x10(CX), SP	
  0x43749d		7654			JBE 0x4374f3		
  0x43749f		4883ec30		SUBQ $0x30, SP		
  0x4374a3		48896c2428		MOVQ BP, 0x28(SP)	
  0x4374a8		488d6c2428		LEAQ 0x28(SP), BP	
  0x4374ad		488b442438		MOVQ 0x38(SP), AX	
	return index(s, t) >= 0
  0x4374b2		48890424		MOVQ AX, 0(SP)		
func contains(s, t string) bool {
  0x4374b6		488b442440		MOVQ 0x40(SP), AX	
	return index(s, t) >= 0
  0x4374bb		4889442408		MOVQ AX, 0x8(SP)	
func contains(s, t string) bool {
  0x4374c0		488b442448		MOVQ 0x48(SP), AX	
	return index(s, t) >= 0
  0x4374c5		4889442410		MOVQ AX, 0x10(SP)	
func contains(s, t string) bool {
  0x4374ca		488b442450		MOVQ 0x50(SP), AX	
	return index(s, t) >= 0
  0x4374cf		4889442418		MOVQ AX, 0x18(SP)	
  0x4374d4		e8b7feffff		CALL runtime.index(SB)	
  0x4374d9		488b442420		MOVQ 0x20(SP), AX	
  0x4374de		4885c0			TESTQ AX, AX		
  0x4374e1		488d442458		LEAQ 0x58(SP), AX	
  0x4374e6		0f9d00			SETGE 0(AX)		
  0x4374e9		488b6c2428		MOVQ 0x28(SP), BP	
  0x4374ee		4883c430		ADDQ $0x30, SP		
  0x4374f2		c3			RET			
func contains(s, t string) bool {
  0x4374f3		e878d00000		CALL runtime.morestack_noctxt(SB)	
  0x4374f8		eb96			JMP runtime.contains(SB)		

TEXT runtime.atoi(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func atoi(s string) (int, bool) {
  0x437500		488b442410		MOVQ 0x10(SP), AX	
	if s == "" {
  0x437505		4885c0			TESTQ AX, AX		
  0x437508		0f8404010000		JE 0x437612		
  0x43750e		488b4c2408		MOVQ 0x8(SP), CX	
	if s[0] == '-' {
  0x437513		0fb611			MOVZX 0(CX), DX		
  0x437516		80fa2d			CMPL $0x2d, DL		
  0x437519		0f85e4000000		JNE 0x437603		
		s = s[1:]
  0x43751f		48ffc8			DECQ AX			
  0x437522		4889c2			MOVQ AX, DX		
  0x437525		48f7d8			NEGQ AX			
  0x437528		48c1f83f		SARQ $0x3f, AX		
  0x43752c		4883e001		ANDQ $0x1, AX		
  0x437530		4801c8			ADDQ CX, AX		
  0x437533		b901000000		MOVL $0x1, CX		
  0x437538		31db			XORL BX, BX		
  0x43753a		31f6			XORL SI, SI		
	for i := 0; i < len(s); i++ {
  0x43753c		eb06			JMP 0x437544		
  0x43753e		48ffc3			INCQ BX			
  0x437541		4889fe			MOVQ DI, SI		
  0x437544		4839d3			CMPQ DX, BX		
  0x437547		7d62			JGE 0x4375ab		
		c := s[i]
  0x437549		0fb63c18		MOVZX 0(AX)(BX*1), DI	
		if c < '0' || c > '9' {
  0x43754d		448d47d0		LEAL -0x30(DI), R8	
  0x437551		4180f809		CMPL $0x9, R8		
  0x437555		7745			JA 0x43759c		
		if un > maxUint/10 {
  0x437557		49b89999999999999919	MOVQ $0x1999999999999999, R8	
  0x437561		4c39c6			CMPQ R8, SI			
  0x437564		7727			JA 0x43758d			
		un *= 10
  0x437566		488d34b6		LEAQ 0(SI)(SI*4), SI	
  0x43756a		4989f1			MOVQ SI, R9		
  0x43756d		48d1e6			SHLQ $0x1, SI		
		un1 := un + uint(c) - '0'
  0x437570		400fb6ff		MOVZX DI, DI			
  0x437574		4a8d7c4fd0		LEAQ -0x30(DI)(R9*2), DI	
		if un1 < un {
  0x437579		4839f7			CMPQ SI, DI		
  0x43757c		73c0			JAE 0x43753e		
			return 0, false
  0x43757e		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x437587		c644242000		MOVB $0x0, 0x20(SP)	
  0x43758c		c3			RET			
			return 0, false
  0x43758d		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x437596		c644242000		MOVB $0x0, 0x20(SP)	
  0x43759b		c3			RET			
			return 0, false
  0x43759c		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x4375a5		c644242000		MOVB $0x0, 0x20(SP)	
  0x4375aa		c3			RET			
	if !neg && un > uint(maxInt) {
  0x4375ab		84c9			TESTL CL, CL		
  0x4375ad		7432			JE 0x4375e1		
	if neg && un > uint(maxInt)+1 {
  0x4375af		7411			JE 0x4375c2			
  0x4375b1		48b80000000000000080	MOVQ $0x8000000000000000, AX	
  0x4375bb		4839c6			CMPQ AX, SI			
  0x4375be		7712			JA 0x4375d2			
	if !neg && un > uint(maxInt) {
  0x4375c0		84c9			TESTL CL, CL		
	if neg {
  0x4375c2		7403			JE 0x4375c7		
		n = -n
  0x4375c4		48f7de			NEGQ SI			
	return n, true
  0x4375c7		4889742418		MOVQ SI, 0x18(SP)	
  0x4375cc		c644242001		MOVB $0x1, 0x20(SP)	
  0x4375d1		c3			RET			
		return 0, false
  0x4375d2		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x4375db		c644242000		MOVB $0x0, 0x20(SP)	
  0x4375e0		c3			RET			
	if !neg && un > uint(maxInt) {
  0x4375e1		48b8ffffffffffffff7f	MOVQ $0x7fffffffffffffff, AX	
  0x4375eb		4839c6			CMPQ AX, SI			
  0x4375ee		7704			JA 0x4375f4			
  0x4375f0		84c9			TESTL CL, CL			
  0x4375f2		ebbb			JMP 0x4375af			
		return 0, false
  0x4375f4		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x4375fd		c644242000		MOVB $0x0, 0x20(SP)	
  0x437602		c3			RET			
  0x437603		4889c8			MOVQ CX, AX		
  0x437606		488b542410		MOVQ 0x10(SP), DX	
  0x43760b		31c9			XORL CX, CX		
	if s[0] == '-' {
  0x43760d		e926ffffff		JMP 0x437538		
		return 0, false
  0x437612		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x43761b		c644242000		MOVB $0x0, 0x20(SP)	
  0x437620		c3			RET			

TEXT runtime.atoi32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func atoi32(s string) (int32, bool) {
  0x437630		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437639		483b6110		CMPQ 0x10(CX), SP	
  0x43763d		7661			JBE 0x4376a0		
  0x43763f		4883ec28		SUBQ $0x28, SP		
  0x437643		48896c2420		MOVQ BP, 0x20(SP)	
  0x437648		488d6c2420		LEAQ 0x20(SP), BP	
  0x43764d		488b442430		MOVQ 0x30(SP), AX	
	if n, ok := atoi(s); n == int(int32(n)) {
  0x437652		48890424		MOVQ AX, 0(SP)		
func atoi32(s string) (int32, bool) {
  0x437656		488b442438		MOVQ 0x38(SP), AX	
	if n, ok := atoi(s); n == int(int32(n)) {
  0x43765b		4889442408		MOVQ AX, 0x8(SP)	
  0x437660		e89bfeffff		CALL runtime.atoi(SB)	
  0x437665		488b442410		MOVQ 0x10(SP), AX	
  0x43766a		0fb64c2418		MOVZX 0x18(SP), CX	
  0x43766f		4863d0			MOVSXD AX, DX		
  0x437672		4839d0			CMPQ DX, AX		
  0x437675		7512			JNE 0x437689		
		return int32(n), ok
  0x437677		89442440		MOVL AX, 0x40(SP)	
  0x43767b		884c2444		MOVB CL, 0x44(SP)	
  0x43767f		488b6c2420		MOVQ 0x20(SP), BP	
  0x437684		4883c428		ADDQ $0x28, SP		
  0x437688		c3			RET			
	return 0, false
  0x437689		c744244000000000	MOVL $0x0, 0x40(SP)	
  0x437691		c644244400		MOVB $0x0, 0x44(SP)	
  0x437696		488b6c2420		MOVQ 0x20(SP), BP	
  0x43769b		4883c428		ADDQ $0x28, SP		
  0x43769f		c3			RET			
func atoi32(s string) (int32, bool) {
  0x4376a0		e8cbce0000		CALL runtime.morestack_noctxt(SB)	
  0x4376a5		eb89			JMP runtime.atoi32(SB)			

TEXT runtime.findnull(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func findnull(s *byte) int {
  0x4376b0		488b442408		MOVQ 0x8(SP), AX	
	if s == nil {
  0x4376b5		4885c0			TESTQ AX, AX		
  0x4376b8		7424			JE 0x4376de		
  0x4376ba		31c9			XORL CX, CX		
	for p[l] != 0 {
  0x4376bc		eb03			JMP 0x4376c1		
		l++
  0x4376be		48ffc1			INCQ CX			
	for p[l] != 0 {
  0x4376c1		48bafeffffff3f000000	MOVQ $0x3ffffffffe, DX	
  0x4376cb		4839d1			CMPQ DX, CX		
  0x4376ce		7318			JAE 0x4376e8		
  0x4376d0		0fb61c08		MOVZX 0(AX)(CX*1), BX	
  0x4376d4		84db			TESTL BL, BL		
  0x4376d6		75e6			JNE 0x4376be		
	return l
  0x4376d8		48894c2410		MOVQ CX, 0x10(SP)	
  0x4376dd		c3			RET			
		return 0
  0x4376de		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x4376e7		c3			RET			
	for p[l] != 0 {
  0x4376e8		e85383feff		CALL runtime.panicindex(SB)	
  0x4376ed		0f0b			UD2				

TEXT runtime.gostringnocopy(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/string.go
func gostringnocopy(str *byte) string {
  0x4376f0		4883ec28		SUBQ $0x28, SP		
  0x4376f4		48896c2420		MOVQ BP, 0x20(SP)	
  0x4376f9		488d6c2420		LEAQ 0x20(SP), BP	
  0x4376fe		488b442430		MOVQ 0x30(SP), AX	
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x437703		48890424		MOVQ AX, 0(SP)			
  0x437707		e8a4ffffff		CALL runtime.findnull(SB)	
  0x43770c		488b442408		MOVQ 0x8(SP), AX		
  0x437711		488b4c2430		MOVQ 0x30(SP), CX		
  0x437716		48894c2410		MOVQ CX, 0x10(SP)		
  0x43771b		4889442418		MOVQ AX, 0x18(SP)		
	s := *(*string)(unsafe.Pointer(&ss))
  0x437720		488b4c2410		MOVQ 0x10(SP), CX	
	return s
  0x437725		48894c2438		MOVQ CX, 0x38(SP)	
  0x43772a		4889442440		MOVQ AX, 0x40(SP)	
  0x43772f		488b6c2420		MOVQ 0x20(SP), BP	
  0x437734		4883c428		ADDQ $0x28, SP		
  0x437738		c3			RET			

TEXT runtime.badsystemstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stubs.go
func badsystemstack() {
  0x437740		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437749		483b6110		CMPQ 0x10(CX), SP	
  0x43774d		7629			JBE 0x437778		
  0x43774f		4883ec18		SUBQ $0x18, SP		
  0x437753		48896c2410		MOVQ BP, 0x10(SP)	
  0x437758		488d6c2410		LEAQ 0x10(SP), BP	
	throw("systemstack called from unexpected goroutine")
  0x43775d		488d05155f0300		LEAQ 0x35f15(IP), AX	
  0x437764		48890424		MOVQ AX, 0(SP)		
  0x437768		48c74424082c000000	MOVQ $0x2c, 0x8(SP)	
  0x437771		e85a9afeff		CALL runtime.throw(SB)	
  0x437776		0f0b			UD2			
func badsystemstack() {
  0x437778		e8f3cd0000		CALL runtime.morestack_noctxt(SB)	
  0x43777d		ebc1			JMP runtime.badsystemstack(SB)		

TEXT runtime.fastrand(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stubs.go
	mp := getg().m
  0x437780		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x437789		488b4030		MOVQ 0x30(AX), AX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x43778d		8b8820010000		MOVL 0x120(AX), CX	
  0x437793		8b9024010000		MOVL 0x124(AX), DX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x437799		899020010000		MOVL DX, 0x120(AX)	
  0x43779f		89cb			MOVL CX, BX		
	s1 ^= s1 << 17
  0x4377a1		c1e111			SHLL $0x11, CX		
  0x4377a4		31d9			XORL BX, CX		
  0x4377a6		89d3			MOVL DX, BX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x4377a8		31ca			XORL CX, DX		
  0x4377aa		c1e907			SHRL $0x7, CX		
  0x4377ad		31d1			XORL DX, CX		
  0x4377af		89da			MOVL BX, DX		
  0x4377b1		c1eb10			SHRL $0x10, BX		
  0x4377b4		31cb			XORL CX, BX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x4377b6		899824010000		MOVL BX, 0x124(AX)	
	return s0 + s1
  0x4377bc		8d041a			LEAL 0(DX)(BX*1), AX	
  0x4377bf		89442408		MOVL AX, 0x8(SP)	
  0x4377c3		c3			RET			

TEXT runtime.modulesinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func modulesinit() {
  0x4377d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4377d9		483b6110		CMPQ 0x10(CX), SP	
  0x4377dd		0f8684020000		JBE 0x437a67		
  0x4377e3		4883ec60		SUBQ $0x60, SP		
  0x4377e7		48896c2458		MOVQ BP, 0x58(SP)	
  0x4377ec		488d6c2458		LEAQ 0x58(SP), BP	
	modules := new([]*moduledata)
  0x4377f1		488d05a8e20100		LEAQ 0x1e2a8(IP), AX			
  0x4377f8		48890424		MOVQ AX, 0(SP)				
  0x4377fc		e81f39fdff		CALL runtime.newobject(SB)		
  0x437801		488b442408		MOVQ 0x8(SP), AX			
  0x437806		4889442440		MOVQ AX, 0x40(SP)			
  0x43780b		488d0d2ee00600		LEAQ runtime.firstmoduledata(SB), CX	
	for md := &firstmoduledata; md != nil; md = md.next {
  0x437812		eb07			JMP 0x43781b		
  0x437814		488b89c0010000		MOVQ 0x1c0(CX), CX	
  0x43781b		4885c9			TESTQ CX, CX		
  0x43781e		0f8498010000		JE 0x4379bc		
		if md.bad {
  0x437824		0fb691b8010000		MOVZX 0x1b8(CX), DX	
  0x43782b		84d2			TESTL DL, DL		
  0x43782d		75e5			JNE 0x437814		
  0x43782f		48894c2448		MOVQ CX, 0x48(SP)	
		*modules = append(*modules, md)
  0x437834		488b5010		MOVQ 0x10(AX), DX			
  0x437838		488b5808		MOVQ 0x8(AX), BX			
  0x43783c		488b30			MOVQ 0(AX), SI				
  0x43783f		4c8d4301		LEAQ 0x1(BX), R8			
  0x437843		4939d0			CMPQ DX, R8				
  0x437846		0f8f0d010000		JG 0x437959				
  0x43784c		488d5301		LEAQ 0x1(BX), DX			
  0x437850		48895008		MOVQ DX, 0x8(AX)			
  0x437854		488d3cde		LEAQ 0(SI)(BX*8), DI			
  0x437858		8b15b2c10800		MOVL runtime.writeBarrier(SB), DX	
  0x43785e		85d2			TESTL DX, DX				
  0x437860		0f85e0000000		JNE 0x437946				
  0x437866		48890cde		MOVQ CX, 0(SI)(BX*8)			
		if md.gcdatamask == (bitvector{}) {
  0x43786a		8b9190010000		MOVL 0x190(CX), DX	
  0x437870		85d2			TESTL DX, DX		
  0x437872		75a0			JNE 0x437814		
  0x437874		488b9198010000		MOVQ 0x198(CX), DX	
  0x43787b		488d9998010000		LEAQ 0x198(CX), BX	
  0x437882		4885d2			TESTQ DX, DX		
  0x437885		758d			JNE 0x437814		
  0x437887		48895c2450		MOVQ BX, 0x50(SP)	
			md.gcdatamask = progToPointerMask((*byte)(unsafe.Pointer(md.gcdata)), md.edata-md.data)
  0x43788c		488b81b8000000		MOVQ 0xb8(CX), AX			
  0x437893		488b9188000000		MOVQ 0x88(CX), DX			
  0x43789a		482b9180000000		SUBQ 0x80(CX), DX			
  0x4378a1		4889542408		MOVQ DX, 0x8(SP)			
  0x4378a6		48890424		MOVQ AX, 0(SP)				
  0x4378aa		e8c162fdff		CALL runtime.progToPointerMask(SB)	
  0x4378af		8b442410		MOVL 0x10(SP), AX			
  0x4378b3		488b4c2418		MOVQ 0x18(SP), CX			
  0x4378b8		488b542448		MOVQ 0x48(SP), DX			
  0x4378bd		898290010000		MOVL AX, 0x190(DX)			
  0x4378c3		8b0547c10800		MOVL runtime.writeBarrier(SB), AX	
  0x4378c9		85c0			TESTL AX, AX				
  0x4378cb		756a			JNE 0x437937				
  0x4378cd		48898a98010000		MOVQ CX, 0x198(DX)			
			md.gcbssmask = progToPointerMask((*byte)(unsafe.Pointer(md.gcbss)), md.ebss-md.bss)
  0x4378d4		488b82c0000000		MOVQ 0xc0(DX), AX			
  0x4378db		488b8a98000000		MOVQ 0x98(DX), CX			
  0x4378e2		482b8a90000000		SUBQ 0x90(DX), CX			
  0x4378e9		48894c2408		MOVQ CX, 0x8(SP)			
  0x4378ee		48890424		MOVQ AX, 0(SP)				
  0x4378f2		e87962fdff		CALL runtime.progToPointerMask(SB)	
  0x4378f7		488b442418		MOVQ 0x18(SP), AX			
  0x4378fc		8b4c2410		MOVL 0x10(SP), CX			
  0x437900		488b542448		MOVQ 0x48(SP), DX			
  0x437905		898aa0010000		MOVL CX, 0x1a0(DX)			
  0x43790b		8b0dffc00800		MOVL runtime.writeBarrier(SB), CX	
  0x437911		488dbaa8010000		LEAQ 0x1a8(DX), DI			
  0x437918		85c9			TESTL CX, CX				
  0x43791a		7514			JNE 0x437930				
  0x43791c		488982a8010000		MOVQ AX, 0x1a8(DX)			
  0x437923		488b442440		MOVQ 0x40(SP), AX			
  0x437928		4889d1			MOVQ DX, CX				
  0x43792b		e9e4feffff		JMP 0x437814				
  0x437930		e86bef0000		CALL runtime.gcWriteBarrier(SB)		
  0x437935		ebec			JMP 0x437923				
  0x437937		488b7c2450		MOVQ 0x50(SP), DI			
  0x43793c		4889c8			MOVQ CX, AX				
			md.gcdatamask = progToPointerMask((*byte)(unsafe.Pointer(md.gcdata)), md.edata-md.data)
  0x43793f		e85cef0000		CALL runtime.gcWriteBarrier(SB)	
  0x437944		eb8e			JMP 0x4378d4			
  0x437946		4889c2			MOVQ AX, DX			
  0x437949		4889c8			MOVQ CX, AX			
		*modules = append(*modules, md)
  0x43794c		e84fef0000		CALL runtime.gcWriteBarrier(SB)		
  0x437951		4889d0			MOVQ DX, AX				
  0x437954		e911ffffff		JMP 0x43786a				
  0x437959		488d0560ce0100		LEAQ 0x1ce60(IP), AX			
  0x437960		48890424		MOVQ AX, 0(SP)				
  0x437964		4889742408		MOVQ SI, 0x8(SP)			
  0x437969		48895c2410		MOVQ BX, 0x10(SP)			
  0x43796e		4889542418		MOVQ DX, 0x18(SP)			
  0x437973		4c89442420		MOVQ R8, 0x20(SP)			
  0x437978		e8e3beffff		CALL runtime.growslice(SB)		
  0x43797d		488b442428		MOVQ 0x28(SP), AX			
  0x437982		488b4c2430		MOVQ 0x30(SP), CX			
  0x437987		488b542438		MOVQ 0x38(SP), DX			
  0x43798c		488b7c2440		MOVQ 0x40(SP), DI			
  0x437991		48895710		MOVQ DX, 0x10(DI)			
  0x437995		8b1575c00800		MOVL runtime.writeBarrier(SB), DX	
  0x43799b		85d2			TESTL DX, DX				
  0x43799d		7516			JNE 0x4379b5				
  0x43799f		488907			MOVQ AX, 0(DI)				
  0x4379a2		4889cb			MOVQ CX, BX				
  0x4379a5		4889c6			MOVQ AX, SI				
  0x4379a8		4889f8			MOVQ DI, AX				
  0x4379ab		488b4c2448		MOVQ 0x48(SP), CX			
  0x4379b0		e997feffff		JMP 0x43784c				
  0x4379b5		e8e6ee0000		CALL runtime.gcWriteBarrier(SB)		
  0x4379ba		ebe6			JMP 0x4379a2				
	for i, md := range *modules {
  0x4379bc		488b4808		MOVQ 0x8(AX), CX	
  0x4379c0		488b38			MOVQ 0(AX), DI		
  0x4379c3		31d2			XORL DX, DX		
  0x4379c5		eb03			JMP 0x4379ca		
  0x4379c7		48ffc2			INCQ DX			
  0x4379ca		4839ca			CMPQ CX, DX		
  0x4379cd		7d47			JGE 0x437a16		
  0x4379cf		488b1cd7		MOVQ 0(DI)(DX*8), BX	
		if md.hasmain != 0 {
  0x4379d3		0fb6b388010000		MOVZX 0x188(BX), SI	
  0x4379da		4084f6			TESTL SI, SI		
  0x4379dd		74e8			JE 0x4379c7		
			(*modules)[0] = md
  0x4379df		4885c9			TESTQ CX, CX				
  0x4379e2		767c			JBE 0x437a60				
  0x4379e4		8b0d26c00800		MOVL runtime.writeBarrier(SB), CX	
  0x4379ea		85c9			TESTL CX, CX				
  0x4379ec		755b			JNE 0x437a49				
  0x4379ee		48891f			MOVQ BX, 0(DI)				
			(*modules)[i] = &firstmoduledata
  0x4379f1		488b08			MOVQ 0(AX), CX				
  0x4379f4		488b5808		MOVQ 0x8(AX), BX			
  0x4379f8		4839da			CMPQ BX, DX				
  0x4379fb		735c			JAE 0x437a59				
  0x4379fd		8b1d0dc00800		MOVL runtime.writeBarrier(SB), BX	
  0x437a03		488d3cd1		LEAQ 0(CX)(DX*8), DI			
  0x437a07		85db			TESTL BX, BX				
  0x437a09		752a			JNE 0x437a35				
  0x437a0b		488d1d2ede0600		LEAQ runtime.firstmoduledata(SB), BX	
  0x437a12		48891cd1		MOVQ BX, 0(CX)(DX*8)			
	atomicstorep(unsafe.Pointer(&modulesSlice), unsafe.Pointer(modules))
  0x437a16		488d0d5bfc0600		LEAQ runtime.modulesSlice(SB), CX	
  0x437a1d		48890c24		MOVQ CX, 0(SP)				
  0x437a21		4889442408		MOVQ AX, 0x8(SP)			
  0x437a26		e8b5a4fcff		CALL runtime.atomicstorep(SB)		
}
  0x437a2b		488b6c2458		MOVQ 0x58(SP), BP	
  0x437a30		4883c460		ADDQ $0x60, SP		
  0x437a34		c3			RET			
  0x437a35		4889c1			MOVQ AX, CX		
			(*modules)[i] = &firstmoduledata
  0x437a38		488d0501de0600		LEAQ runtime.firstmoduledata(SB), AX	
  0x437a3f		e85cee0000		CALL runtime.gcWriteBarrier(SB)		
  0x437a44		4889c8			MOVQ CX, AX				
  0x437a47		ebcd			JMP 0x437a16				
  0x437a49		4889c1			MOVQ AX, CX				
  0x437a4c		4889d8			MOVQ BX, AX				
			(*modules)[0] = md
  0x437a4f		e84cee0000		CALL runtime.gcWriteBarrier(SB)	
  0x437a54		4889c8			MOVQ CX, AX			
  0x437a57		eb98			JMP 0x4379f1			
			(*modules)[i] = &firstmoduledata
  0x437a59		e8e27ffeff		CALL runtime.panicindex(SB)	
  0x437a5e		0f0b			UD2				
			(*modules)[0] = md
  0x437a60		e8db7ffeff		CALL runtime.panicindex(SB)	
  0x437a65		0f0b			UD2				
func modulesinit() {
  0x437a67		e804cb0000		CALL runtime.morestack_noctxt(SB)	
  0x437a6c		e95ffdffff		JMP runtime.modulesinit(SB)		

TEXT runtime.moduledataverify(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func moduledataverify() {
  0x437a80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x437a89		483b6110		CMPQ 0x10(CX), SP			
  0x437a8d		7640			JBE 0x437acf				
  0x437a8f		4883ec18		SUBQ $0x18, SP				
  0x437a93		48896c2410		MOVQ BP, 0x10(SP)			
  0x437a98		488d6c2410		LEAQ 0x10(SP), BP			
  0x437a9d		488d059cdd0600		LEAQ runtime.firstmoduledata(SB), AX	
	for datap := &firstmoduledata; datap != nil; datap = datap.next {
  0x437aa4		eb1a			JMP 0x437ac0		
  0x437aa6		4889442408		MOVQ AX, 0x8(SP)	
		moduledataverify1(datap)
  0x437aab		48890424		MOVQ AX, 0(SP)				
  0x437aaf		e82c000000		CALL runtime.moduledataverify1(SB)	
  0x437ab4		488b442408		MOVQ 0x8(SP), AX			
	for datap := &firstmoduledata; datap != nil; datap = datap.next {
  0x437ab9		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x437ac0		4885c0			TESTQ AX, AX		
  0x437ac3		75e1			JNE 0x437aa6		
  0x437ac5		488b6c2410		MOVQ 0x10(SP), BP	
  0x437aca		4883c418		ADDQ $0x18, SP		
  0x437ace		c3			RET			
func moduledataverify() {
  0x437acf		e89cca0000		CALL runtime.morestack_noctxt(SB)	
  0x437ad4		ebaa			JMP runtime.moduledataverify(SB)	

TEXT runtime.moduledataverify1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func moduledataverify1(datap *moduledata) {
  0x437ae0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437ae9		488d442480		LEAQ -0x80(SP), AX	
  0x437aee		483b4110		CMPQ 0x10(CX), AX	
  0x437af2		0f8684060000		JBE 0x43817c		
  0x437af8		4881ec00010000		SUBQ $0x100, SP		
  0x437aff		4889ac24f8000000	MOVQ BP, 0xf8(SP)	
  0x437b07		488dac24f8000000	LEAQ 0xf8(SP), BP	
  0x437b0f		488b842408010000	MOVQ 0x108(SP), AX	
	pcln32 := *(**[2]uint32)(unsafe.Pointer(&datap.pclntable))
  0x437b17		488b08			MOVQ 0(AX), CX		
	pcln := *(**[8]byte)(unsafe.Pointer(&datap.pclntable))
  0x437b1a		488b10			MOVQ 0(AX), DX		
	if pcln32[0] != 0xfffffffb || pcln[4] != 0 || pcln[5] != 0 || pcln[6] != sys.PCQuantum || pcln[7] != sys.PtrSize {
  0x437b1d		8b09			MOVL 0(CX), CX		
  0x437b1f		894c2424		MOVL CX, 0x24(SP)	
  0x437b23		83f9fb			CMPL $-0x5, CX		
  0x437b26		0f8590050000		JNE 0x4380bc		
  0x437b2c		0fb65a04		MOVZX 0x4(DX), BX	
  0x437b30		84db			TESTL BL, BL		
  0x437b32		0f8584050000		JNE 0x4380bc		
  0x437b38		0fb65a05		MOVZX 0x5(DX), BX	
  0x437b3c		84db			TESTL BL, BL		
  0x437b3e		0f8578050000		JNE 0x4380bc		
  0x437b44		0fb65a06		MOVZX 0x6(DX), BX	
  0x437b48		80fb01			CMPL $0x1, BL		
  0x437b4b		0f856b050000		JNE 0x4380bc		
  0x437b51		0fb65a07		MOVZX 0x7(DX), BX	
  0x437b55		80fb08			CMPL $0x8, BL		
  0x437b58		0f855e050000		JNE 0x4380bc		
	nftab := len(datap.ftab) - 1
  0x437b5e		488b4820		MOVQ 0x20(AX), CX	
  0x437b62		488b5018		MOVQ 0x18(AX), DX	
  0x437b66		488d59ff		LEAQ -0x1(CX), BX	
  0x437b6a		31f6			XORL SI, SI		
	for i := 0; i < nftab; i++ {
  0x437b6c		eb03			JMP 0x437b71		
  0x437b6e		4c89de			MOVQ R11, SI		
  0x437b71		4839de			CMPQ BX, SI		
  0x437b74		0f8dd0020000		JGE 0x437e4a		
  0x437b7a		4989f0			MOVQ SI, R8		
		if datap.ftab[i].entry > datap.ftab[i+1].entry {
  0x437b7d		48c1e604		SHLQ $0x4, SI		
  0x437b81		4c8b0c16		MOVQ 0(SI)(DX*1), R9	
  0x437b85		4d8d5001		LEAQ 0x1(R8), R10	
  0x437b89		4939ca			CMPQ CX, R10		
  0x437b8c		0f8323050000		JAE 0x4380b5		
  0x437b92		4d89d3			MOVQ R10, R11		
  0x437b95		49c1e204		SHLQ $0x4, R10		
  0x437b99		4e8b2412		MOVQ 0(DX)(R10*1), R12	
  0x437b9d		4d39e1			CMPQ R12, R9		
  0x437ba0		76cc			JBE 0x437b6e		
			f1 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i].funcoff])), datap}
  0x437ba2		488b4808		MOVQ 0x8(AX), CX	
  0x437ba6		488b38			MOVQ 0(AX), DI		
  0x437ba9		4c8b4c1608		MOVQ 0x8(SI)(DX*1), R9	
  0x437bae		4939c9			CMPQ CX, R9		
  0x437bb1		0f83f7040000		JAE 0x4380ae		
  0x437bb7		4901f9			ADDQ DI, R9		
			f2 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i+1].funcoff])), datap}
  0x437bba		4a8b541208		MOVQ 0x8(DX)(R10*1), DX	
  0x437bbf		4839ca			CMPQ CX, DX		
  0x437bc2		0f83df040000		JAE 0x4380a7		
  0x437bc8		4c89542478		MOVQ R10, 0x78(SP)	
  0x437bcd		4c89442470		MOVQ R8, 0x70(SP)	
  0x437bd2		4c895c2468		MOVQ R11, 0x68(SP)	
  0x437bd7		4889742460		MOVQ SI, 0x60(SP)	
  0x437bdc		488d0c3a		LEAQ 0(DX)(DI*1), CX	
			if i+1 < nftab {
  0x437be0		4939db			CMPQ BX, R11		
  0x437be3		0f8c2c020000		JL 0x437e15		
  0x437be9		b903000000		MOVL $0x3, CX		
  0x437bee		488d15b3200300		LEAQ 0x320b3(IP), DX	
  0x437bf5		48894c2428		MOVQ CX, 0x28(SP)	
  0x437bfa		4889942480000000	MOVQ DX, 0x80(SP)	
			println("function symbol table not sorted by program counter:", hex(datap.ftab[i].entry), funcname(f1), ">", hex(datap.ftab[i+1].entry), f2name)
  0x437c02		4c890c24		MOVQ R9, 0(SP)			
  0x437c06		4889442408		MOVQ AX, 0x8(SP)		
  0x437c0b		e8f00c0000		CALL runtime.funcname(SB)	
  0x437c10		488b842408010000	MOVQ 0x108(SP), AX		
  0x437c18		488b4818		MOVQ 0x18(AX), CX		
  0x437c1c		488b5020		MOVQ 0x20(AX), DX		
  0x437c20		488b5c2410		MOVQ 0x10(SP), BX		
  0x437c25		488b742418		MOVQ 0x18(SP), SI		
  0x437c2a		488b7c2470		MOVQ 0x70(SP), DI		
  0x437c2f		4839d7			CMPQ DX, DI			
  0x437c32		0f8368040000		JAE 0x4380a0			
  0x437c38		4c8b442460		MOVQ 0x60(SP), R8		
  0x437c3d		4d8b0408		MOVQ 0(R8)(CX*1), R8		
  0x437c41		4c8b4c2468		MOVQ 0x68(SP), R9		
  0x437c46		4939d1			CMPQ DX, R9			
  0x437c49		0f8351040000		JAE 0x4380a0			
  0x437c4f		48899c24a0000000	MOVQ BX, 0xa0(SP)		
  0x437c57		4889742468		MOVQ SI, 0x68(SP)		
  0x437c5c		4c89442458		MOVQ R8, 0x58(SP)		
  0x437c61		488b442478		MOVQ 0x78(SP), AX		
  0x437c66		488b0401		MOVQ 0(CX)(AX*1), AX		
  0x437c6a		4889442450		MOVQ AX, 0x50(SP)		
  0x437c6f		e88c9efeff		CALL runtime.printlock(SB)	
  0x437c74		488d05a85e0300		LEAQ 0x35ea8(IP), AX		
  0x437c7b		48890424		MOVQ AX, 0(SP)			
  0x437c7f		48c744240835000000	MOVQ $0x35, 0x8(SP)		
  0x437c88		e8b3a7feff		CALL runtime.printstring(SB)	
  0x437c8d		488b442458		MOVQ 0x58(SP), AX		
  0x437c92		48890424		MOVQ AX, 0(SP)			
  0x437c96		e855a6feff		CALL runtime.printhex(SB)	
  0x437c9b		e8a0a0feff		CALL runtime.printsp(SB)	
  0x437ca0		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x437ca8		48890424		MOVQ AX, 0(SP)			
  0x437cac		488b442468		MOVQ 0x68(SP), AX		
  0x437cb1		4889442408		MOVQ AX, 0x8(SP)		
  0x437cb6		e885a7feff		CALL runtime.printstring(SB)	
  0x437cbb		488d05ce1f0300		LEAQ 0x31fce(IP), AX		
  0x437cc2		48890424		MOVQ AX, 0(SP)			
  0x437cc6		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x437ccf		e86ca7feff		CALL runtime.printstring(SB)	
  0x437cd4		488b442450		MOVQ 0x50(SP), AX		
  0x437cd9		48890424		MOVQ AX, 0(SP)			
  0x437cdd		e80ea6feff		CALL runtime.printhex(SB)	
  0x437ce2		e859a0feff		CALL runtime.printsp(SB)	
  0x437ce7		488b842480000000	MOVQ 0x80(SP), AX		
  0x437cef		48890424		MOVQ AX, 0(SP)			
  0x437cf3		488b442428		MOVQ 0x28(SP), AX		
  0x437cf8		4889442408		MOVQ AX, 0x8(SP)		
  0x437cfd		e83ea7feff		CALL runtime.printstring(SB)	
  0x437d02		e889a0feff		CALL runtime.printnl(SB)	
  0x437d07		e8749efeff		CALL runtime.printunlock(SB)	
  0x437d0c		31c0			XORL AX, AX			
			for j := 0; j <= i; j++ {
  0x437d0e		eb79			JMP 0x437d89		
  0x437d10		48899c24a0000000	MOVQ BX, 0xa0(SP)	
  0x437d18		4889742460		MOVQ SI, 0x60(SP)	
  0x437d1d		488b442478		MOVQ 0x78(SP), AX	
				print("\t", hex(datap.ftab[j].entry), " ", funcname(funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])), datap}), "\n")
  0x437d22		488b0401		MOVQ 0(CX)(AX*1), AX		
  0x437d26		4889442458		MOVQ AX, 0x58(SP)		
  0x437d2b		e8d09dfeff		CALL runtime.printlock(SB)	
  0x437d30		488d05271f0300		LEAQ 0x31f27(IP), AX		
  0x437d37		48890424		MOVQ AX, 0(SP)			
  0x437d3b		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x437d44		e8f7a6feff		CALL runtime.printstring(SB)	
  0x437d49		488b442458		MOVQ 0x58(SP), AX		
  0x437d4e		48890424		MOVQ AX, 0(SP)			
  0x437d52		e899a5feff		CALL runtime.printhex(SB)	
  0x437d57		e8e49ffeff		CALL runtime.printsp(SB)	
  0x437d5c		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x437d64		48890424		MOVQ AX, 0(SP)			
  0x437d68		488b442460		MOVQ 0x60(SP), AX		
  0x437d6d		4889442408		MOVQ AX, 0x8(SP)		
  0x437d72		e8c9a6feff		CALL runtime.printstring(SB)	
  0x437d77		e814a0feff		CALL runtime.printnl(SB)	
  0x437d7c		e8ff9dfeff		CALL runtime.printunlock(SB)	
  0x437d81		488b442468		MOVQ 0x68(SP), AX		
			for j := 0; j <= i; j++ {
  0x437d86		48ffc0			INCQ AX			
  0x437d89		488b4c2470		MOVQ 0x70(SP), CX	
  0x437d8e		4839c8			CMPQ CX, AX		
  0x437d91		0f8fee020000		JG 0x438085		
  0x437d97		488b942408010000	MOVQ 0x108(SP), DX	
				print("\t", hex(datap.ftab[j].entry), " ", funcname(funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])), datap}), "\n")
  0x437d9f		488b1a			MOVQ 0(DX), BX			
  0x437da2		488b7208		MOVQ 0x8(DX), SI		
  0x437da6		488b7a18		MOVQ 0x18(DX), DI		
  0x437daa		4c8b4220		MOVQ 0x20(DX), R8		
  0x437dae		4c39c0			CMPQ R8, AX			
  0x437db1		0f83c7020000		JAE 0x43807e			
  0x437db7		4989c0			MOVQ AX, R8			
  0x437dba		48c1e004		SHLQ $0x4, AX			
  0x437dbe		488b7c3808		MOVQ 0x8(AX)(DI*1), DI		
  0x437dc3		4839f7			CMPQ SI, DI			
  0x437dc6		0f83b2020000		JAE 0x43807e			
  0x437dcc		4889442478		MOVQ AX, 0x78(SP)		
  0x437dd1		4c89442468		MOVQ R8, 0x68(SP)		
  0x437dd6		488d043b		LEAQ 0(BX)(DI*1), AX		
  0x437dda		48890424		MOVQ AX, 0(SP)			
  0x437dde		4889542408		MOVQ DX, 0x8(SP)		
  0x437de3		e8180b0000		CALL runtime.funcname(SB)	
  0x437de8		488b842408010000	MOVQ 0x108(SP), AX		
  0x437df0		488b4818		MOVQ 0x18(AX), CX		
  0x437df4		488b5020		MOVQ 0x20(AX), DX		
  0x437df8		488b5c2410		MOVQ 0x10(SP), BX		
  0x437dfd		488b742418		MOVQ 0x18(SP), SI		
  0x437e02		488b7c2468		MOVQ 0x68(SP), DI		
  0x437e07		4839d7			CMPQ DX, DI			
  0x437e0a		0f8200ffffff		JB 0x437d10			
  0x437e10		e969020000		JMP 0x43807e			
  0x437e15		4c898c2498000000	MOVQ R9, 0x98(SP)		
				f2name = funcname(f2)
  0x437e1d		48890c24		MOVQ CX, 0(SP)			
  0x437e21		4889442408		MOVQ AX, 0x8(SP)		
  0x437e26		e8d50a0000		CALL runtime.funcname(SB)	
  0x437e2b		488b542410		MOVQ 0x10(SP), DX		
  0x437e30		488b4c2418		MOVQ 0x18(SP), CX		
  0x437e35		488b842408010000	MOVQ 0x108(SP), AX		
  0x437e3d		4c8b8c2498000000	MOVQ 0x98(SP), R9		
  0x437e45		e9abfdffff		JMP 0x437bf5			
	if datap.minpc != datap.ftab[0].entry ||
  0x437e4a		4c8b4050		MOVQ 0x50(AX), R8	
  0x437e4e		4885c9			TESTQ CX, CX		
  0x437e51		0f8605020000		JBE 0x43805c		
  0x437e57		4c8b0a			MOVQ 0(DX), R9		
  0x437e5a		4d39c8			CMPQ R9, R8		
  0x437e5d		0f8500020000		JNE 0x438063		
		datap.maxpc != datap.ftab[nftab].entry {
  0x437e63		4c8b4058		MOVQ 0x58(AX), R8	
  0x437e67		4839cb			CMPQ CX, BX		
  0x437e6a		0f83e5010000		JAE 0x438055		
  0x437e70		48c1e304		SHLQ $0x4, BX		
  0x437e74		488b0c13		MOVQ 0(BX)(DX*1), CX	
  0x437e78		4939c8			CMPQ CX, R8		
  0x437e7b		0f85e2010000		JNE 0x438063		
	for _, modulehash := range datap.modulehashes {
  0x437e81		488b8870010000		MOVQ 0x170(AX), CX	
  0x437e88		488b9078010000		MOVQ 0x178(AX), DX	
  0x437e8f		4889542478		MOVQ DX, 0x78(SP)	
  0x437e94		31db			XORL BX, BX		
  0x437e96		eb22			JMP 0x437eba		
  0x437e98		4c8b842490000000	MOVQ 0x90(SP), R8	
  0x437ea0		498d4828		LEAQ 0x28(R8), CX	
  0x437ea4		4c8b442470		MOVQ 0x70(SP), R8	
  0x437ea9		498d5801		LEAQ 0x1(R8), BX	
  0x437ead		488b842408010000	MOVQ 0x108(SP), AX	
  0x437eb5		488b542478		MOVQ 0x78(SP), DX	
  0x437eba		4839d3			CMPQ DX, BX		
  0x437ebd		0f8db8000000		JGE 0x437f7b		
  0x437ec3		4c8b01			MOVQ 0(CX), R8		
  0x437ec6		4c898424d0000000	MOVQ R8, 0xd0(SP)	
  0x437ece		488d7108		LEAQ 0x8(CX), SI	
  0x437ed2		488dbc24d8000000	LEAQ 0xd8(SP), DI	
  0x437eda		48896c24f0		MOVQ BP, -0x10(SP)	
  0x437edf		488d6c24f0		LEAQ -0x10(SP), BP	
  0x437ee4		e85bef0000		CALL 0x446e44		
  0x437ee9		488b6d00		MOVQ 0(BP), BP		
  0x437eed		4c8b8424d0000000	MOVQ 0xd0(SP), R8	
  0x437ef5		4c898424a8000000	MOVQ R8, 0xa8(SP)	
  0x437efd		488dbc24b0000000	LEAQ 0xb0(SP), DI	
  0x437f05		488db424d8000000	LEAQ 0xd8(SP), SI	
  0x437f0d		48896c24f0		MOVQ BP, -0x10(SP)	
  0x437f12		488d6c24f0		LEAQ -0x10(SP), BP	
  0x437f17		e828ef0000		CALL 0x446e44		
  0x437f1c		488b6d00		MOVQ 0(BP), BP		
		if modulehash.linktimehash != *modulehash.runtimehash {
  0x437f20		4c8b8424c8000000	MOVQ 0xc8(SP), R8		
  0x437f28		4c8b8c24b8000000	MOVQ 0xb8(SP), R9		
  0x437f30		4c8b9424c0000000	MOVQ 0xc0(SP), R10		
  0x437f38		4d8b5808		MOVQ 0x8(R8), R11		
  0x437f3c		4d8b00			MOVQ 0(R8), R8			
  0x437f3f		4d39da			CMPQ R11, R10			
  0x437f42		7547			JNE 0x437f8b			
  0x437f44		48895c2470		MOVQ BX, 0x70(SP)		
  0x437f49		48898c2490000000	MOVQ CX, 0x90(SP)		
  0x437f51		4c890c24		MOVQ R9, 0(SP)			
  0x437f55		4c89442408		MOVQ R8, 0x8(SP)		
  0x437f5a		4c89542410		MOVQ R10, 0x10(SP)		
  0x437f5f		e8dce30000		CALL runtime.memequal(SB)	
  0x437f64		0fb6442418		MOVZX 0x18(SP), AX		
  0x437f69		84c0			TESTL AL, AL			
  0x437f6b		0f8527ffffff		JNE 0x437e98			
  0x437f71		488b842408010000	MOVQ 0x108(SP), AX		
  0x437f79		eb10			JMP 0x437f8b			
  0x437f7b		488bac24f8000000	MOVQ 0xf8(SP), BP		
  0x437f83		4881c400010000		ADDQ $0x100, SP			
  0x437f8a		c3			RET				
			println("abi mismatch detected between", datap.modulename, "and", modulehash.modulename)
  0x437f8b		488b8860010000		MOVQ 0x160(AX), CX		
  0x437f92		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x437f9a		488b8068010000		MOVQ 0x168(AX), AX		
  0x437fa1		4889442478		MOVQ AX, 0x78(SP)		
  0x437fa6		488b9424b0000000	MOVQ 0xb0(SP), DX		
  0x437fae		4889542470		MOVQ DX, 0x70(SP)		
  0x437fb3		488b9c24a8000000	MOVQ 0xa8(SP), BX		
  0x437fbb		48899c2488000000	MOVQ BX, 0x88(SP)		
  0x437fc3		e8389bfeff		CALL runtime.printlock(SB)	
  0x437fc8		488d05d8440300		LEAQ 0x344d8(IP), AX		
  0x437fcf		48890424		MOVQ AX, 0(SP)			
  0x437fd3		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x437fdc		e85fa4feff		CALL runtime.printstring(SB)	
  0x437fe1		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x437fe9		48890424		MOVQ AX, 0(SP)			
  0x437fed		488b442478		MOVQ 0x78(SP), AX		
  0x437ff2		4889442408		MOVQ AX, 0x8(SP)		
  0x437ff7		e844a4feff		CALL runtime.printstring(SB)	
  0x437ffc		488d05511d0300		LEAQ 0x31d51(IP), AX		
  0x438003		48890424		MOVQ AX, 0(SP)			
  0x438007		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x438010		e82ba4feff		CALL runtime.printstring(SB)	
  0x438015		488b842488000000	MOVQ 0x88(SP), AX		
  0x43801d		48890424		MOVQ AX, 0(SP)			
  0x438021		488b442470		MOVQ 0x70(SP), AX		
  0x438026		4889442408		MOVQ AX, 0x8(SP)		
  0x43802b		e810a4feff		CALL runtime.printstring(SB)	
  0x438030		e85b9dfeff		CALL runtime.printnl(SB)	
  0x438035		e8469bfeff		CALL runtime.printunlock(SB)	
			throw("abi mismatch")
  0x43803a		488d0579250300		LEAQ 0x32579(IP), AX	
  0x438041		48890424		MOVQ AX, 0(SP)		
  0x438045		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x43804e		e87d91feff		CALL runtime.throw(SB)	
  0x438053		0f0b			UD2			
		datap.maxpc != datap.ftab[nftab].entry {
  0x438055		e8e679feff		CALL runtime.panicindex(SB)	
  0x43805a		0f0b			UD2				
	if datap.minpc != datap.ftab[0].entry ||
  0x43805c		e8df79feff		CALL runtime.panicindex(SB)	
  0x438061		0f0b			UD2				
		throw("minpc or maxpc invalid")
  0x438063		488d05f6330300		LEAQ 0x333f6(IP), AX	
  0x43806a		48890424		MOVQ AX, 0(SP)		
  0x43806e		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x438077		e85491feff		CALL runtime.throw(SB)	
  0x43807c		0f0b			UD2			
				print("\t", hex(datap.ftab[j].entry), " ", funcname(funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])), datap}), "\n")
  0x43807e		e8bd79feff		CALL runtime.panicindex(SB)	
  0x438083		0f0b			UD2				
			throw("invalid runtime symbol table")
  0x438085		488d057e400300		LEAQ 0x3407e(IP), AX	
  0x43808c		48890424		MOVQ AX, 0(SP)		
  0x438090		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x438099		e83291feff		CALL runtime.throw(SB)	
  0x43809e		0f0b			UD2			
			println("function symbol table not sorted by program counter:", hex(datap.ftab[i].entry), funcname(f1), ">", hex(datap.ftab[i+1].entry), f2name)
  0x4380a0		e89b79feff		CALL runtime.panicindex(SB)	
  0x4380a5		0f0b			UD2				
			f2 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i+1].funcoff])), datap}
  0x4380a7		e89479feff		CALL runtime.panicindex(SB)	
  0x4380ac		0f0b			UD2				
			f1 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i].funcoff])), datap}
  0x4380ae		e88d79feff		CALL runtime.panicindex(SB)	
  0x4380b3		0f0b			UD2				
		if datap.ftab[i].entry > datap.ftab[i+1].entry {
  0x4380b5		e88679feff		CALL runtime.panicindex(SB)	
  0x4380ba		0f0b			UD2				
		println("runtime: function symbol table header:", hex(pcln32[0]), hex(pcln[4]), hex(pcln[5]), hex(pcln[6]), hex(pcln[7]))
  0x4380bc		0fb64204		MOVZX 0x4(DX), AX		
  0x4380c0		4889442448		MOVQ AX, 0x48(SP)		
  0x4380c5		0fb64a05		MOVZX 0x5(DX), CX		
  0x4380c9		48894c2440		MOVQ CX, 0x40(SP)		
  0x4380ce		0fb65a06		MOVZX 0x6(DX), BX		
  0x4380d2		48895c2438		MOVQ BX, 0x38(SP)		
  0x4380d7		0fb65207		MOVZX 0x7(DX), DX		
  0x4380db		4889542430		MOVQ DX, 0x30(SP)		
  0x4380e0		e81b9afeff		CALL runtime.printlock(SB)	
  0x4380e5		488d05dd500300		LEAQ 0x350dd(IP), AX		
  0x4380ec		48890424		MOVQ AX, 0(SP)			
  0x4380f0		48c744240827000000	MOVQ $0x27, 0x8(SP)		
  0x4380f9		e842a3feff		CALL runtime.printstring(SB)	
  0x4380fe		8b442424		MOVL 0x24(SP), AX		
  0x438102		48890424		MOVQ AX, 0(SP)			
  0x438106		e8e5a1feff		CALL runtime.printhex(SB)	
  0x43810b		e8309cfeff		CALL runtime.printsp(SB)	
  0x438110		488b442448		MOVQ 0x48(SP), AX		
  0x438115		48890424		MOVQ AX, 0(SP)			
  0x438119		e8d2a1feff		CALL runtime.printhex(SB)	
  0x43811e		e81d9cfeff		CALL runtime.printsp(SB)	
  0x438123		488b442440		MOVQ 0x40(SP), AX		
  0x438128		48890424		MOVQ AX, 0(SP)			
  0x43812c		e8bfa1feff		CALL runtime.printhex(SB)	
  0x438131		e80a9cfeff		CALL runtime.printsp(SB)	
  0x438136		488b442438		MOVQ 0x38(SP), AX		
  0x43813b		48890424		MOVQ AX, 0(SP)			
  0x43813f		e8aca1feff		CALL runtime.printhex(SB)	
  0x438144		e8f79bfeff		CALL runtime.printsp(SB)	
  0x438149		488b442430		MOVQ 0x30(SP), AX		
  0x43814e		48890424		MOVQ AX, 0(SP)			
  0x438152		e899a1feff		CALL runtime.printhex(SB)	
  0x438157		e8349cfeff		CALL runtime.printnl(SB)	
  0x43815c		e81f9afeff		CALL runtime.printunlock(SB)	
		throw("invalid function symbol table\n")
  0x438161		488d05d5430300		LEAQ 0x343d5(IP), AX	
  0x438168		48890424		MOVQ AX, 0(SP)		
  0x43816c		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x438175		e85690feff		CALL runtime.throw(SB)	
  0x43817a		0f0b			UD2			
func moduledataverify1(datap *moduledata) {
  0x43817c		e8efc30000		CALL runtime.morestack_noctxt(SB)	
  0x438181		e95af9ffff		JMP runtime.moduledataverify1(SB)	

TEXT runtime.findmoduledatap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func findmoduledatap(pc uintptr) *moduledata {
  0x438190		488b442408		MOVQ 0x8(SP), AX			
  0x438195		488d0da4d60600		LEAQ runtime.firstmoduledata(SB), CX	
	for datap := &firstmoduledata; datap != nil; datap = datap.next {
  0x43819c		eb07			JMP 0x4381a5		
  0x43819e		488b89c0010000		MOVQ 0x1c0(CX), CX	
  0x4381a5		4885c9			TESTQ CX, CX		
  0x4381a8		7418			JE 0x4381c2		
		if datap.minpc <= pc && pc < datap.maxpc {
  0x4381aa		488b5150		MOVQ 0x50(CX), DX	
  0x4381ae		4839c2			CMPQ AX, DX		
  0x4381b1		77eb			JA 0x43819e		
  0x4381b3		488b5158		MOVQ 0x58(CX), DX	
  0x4381b7		4839d0			CMPQ DX, AX		
  0x4381ba		73e2			JAE 0x43819e		
			return datap
  0x4381bc		48894c2410		MOVQ CX, 0x10(SP)	
  0x4381c1		c3			RET			
	return nil
  0x4381c2		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x4381cb		c3			RET			

TEXT runtime.findfunc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func findfunc(pc uintptr) funcInfo {
  0x4381d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4381d9		483b6110		CMPQ 0x10(CX), SP	
  0x4381dd		0f8656010000		JBE 0x438339		
  0x4381e3		4883ec18		SUBQ $0x18, SP		
  0x4381e7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4381ec		488d6c2410		LEAQ 0x10(SP), BP	
  0x4381f1		488b442420		MOVQ 0x20(SP), AX	
	datap := findmoduledatap(pc)
  0x4381f6		48890424		MOVQ AX, 0(SP)				
  0x4381fa		e891ffffff		CALL runtime.findmoduledatap(SB)	
  0x4381ff		488b442408		MOVQ 0x8(SP), AX			
	if datap == nil {
  0x438204		4885c0			TESTQ AX, AX		
  0x438207		0f84dc000000		JE 0x4382e9		
	x := pc - datap.minpc
  0x43820d		488b4850		MOVQ 0x50(AX), CX	
  0x438211		488b542420		MOVQ 0x20(SP), DX	
  0x438216		4889d3			MOVQ DX, BX		
  0x438219		4829ca			SUBQ CX, DX		
  0x43821c		4889d1			MOVQ DX, CX		
	b := x / pcbucketsize
  0x43821f		48c1ea0c		SHRQ $0xc, DX		
	ffb := (*findfuncbucket)(add(unsafe.Pointer(datap.findfunctab), b*unsafe.Sizeof(findfuncbucket{})))
  0x438223		488d1492		LEAQ 0(DX)(DX*4), DX	
  0x438227		48c1e202		SHLQ $0x2, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x43822b		48035048		ADDQ 0x48(AX), DX	
	i := x % pcbucketsize / (pcbucketsize / nsub)
  0x43822f		4881e1ff0f0000		ANDQ $0xfff, CX		
  0x438236		48c1e908		SHRQ $0x8, CX		
	idx := ffb.idx + uint32(ffb.subbuckets[i])
  0x43823a		8b32			MOVL 0(DX), SI		
  0x43823c		4883f910		CMPQ $0x10, CX		
  0x438240		0f83ec000000		JAE 0x438332		
  0x438246		0fb64c0a04		MOVZX 0x4(DX)(CX*1), CX	
  0x43824b		01f1			ADDL SI, CX		
	if idx >= uint32(len(datap.ftab)) {
  0x43824d		488b5018		MOVQ 0x18(AX), DX	
  0x438251		488b7020		MOVQ 0x20(AX), SI	
  0x438255		39f1			CMPL SI, CX		
  0x438257		7204			JB 0x43825d		
		idx = uint32(len(datap.ftab) - 1)
  0x438259		488d4eff		LEAQ -0x1(SI), CX	
	if pc < datap.ftab[idx].entry {
  0x43825d		89cf			MOVL CX, DI		
  0x43825f		4839f7			CMPQ SI, DI		
  0x438262		0f83c3000000		JAE 0x43832b		
  0x438268		48c1e704		SHLQ $0x4, DI		
  0x43826c		488b3c3a		MOVQ 0(DX)(DI*1), DI	
  0x438270		4839fb			CMPQ DI, BX		
  0x438273		7204			JB 0x438279		
  0x438275		eb58			JMP 0x4382cf		
			idx--
  0x438277		ffc9			DECL CX			
		for datap.ftab[idx].entry > pc && idx > 0 {
  0x438279		89cf			MOVL CX, DI		
  0x43827b		4839f7			CMPQ SI, DI		
  0x43827e		0f83a0000000		JAE 0x438324		
  0x438284		48c1e704		SHLQ $0x4, DI		
  0x438288		488b3c17		MOVQ 0(DI)(DX*1), DI	
  0x43828c		4839df			CMPQ BX, DI		
  0x43828f		7604			JBE 0x438295		
  0x438291		85c9			TESTL CX, CX		
  0x438293		77e2			JA 0x438277		
		if idx == 0 {
  0x438295		85c9			TESTL CX, CX		
  0x438297		7470			JE 0x438309		
	return funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[idx].funcoff])), datap}
  0x438299		488b18			MOVQ 0(AX), BX		
  0x43829c		488b7808		MOVQ 0x8(AX), DI	
  0x4382a0		89c9			MOVL CX, CX		
  0x4382a2		4839f1			CMPQ SI, CX		
  0x4382a5		7354			JAE 0x4382fb		
  0x4382a7		48c1e104		SHLQ $0x4, CX		
  0x4382ab		488b4c0a08		MOVQ 0x8(DX)(CX*1), CX	
  0x4382b0		4839f9			CMPQ DI, CX		
  0x4382b3		7346			JAE 0x4382fb		
  0x4382b5		4801d9			ADDQ BX, CX		
  0x4382b8		48894c2428		MOVQ CX, 0x28(SP)	
  0x4382bd		4889442430		MOVQ AX, 0x30(SP)	
  0x4382c2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4382c7		4883c418		ADDQ $0x18, SP		
  0x4382cb		c3			RET			
  0x4382cc		4489c1			MOVL R8, CX		
		for datap.ftab[idx+1].entry <= pc {
  0x4382cf		8d7901			LEAL 0x1(CX), DI	
  0x4382d2		4839f7			CMPQ SI, DI		
  0x4382d5		732b			JAE 0x438302		
  0x4382d7		4189f8			MOVL DI, R8		
  0x4382da		48c1e704		SHLQ $0x4, DI		
  0x4382de		488b3c3a		MOVQ 0(DX)(DI*1), DI	
  0x4382e2		4839df			CMPQ BX, DI		
  0x4382e5		76e5			JBE 0x4382cc		
  0x4382e7		ebb0			JMP 0x438299		
		return funcInfo{}
  0x4382e9		0f57c0			XORPS X0, X0		
  0x4382ec		0f11442428		MOVUPS X0, 0x28(SP)	
  0x4382f1		488b6c2410		MOVQ 0x10(SP), BP	
  0x4382f6		4883c418		ADDQ $0x18, SP		
  0x4382fa		c3			RET			
	return funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[idx].funcoff])), datap}
  0x4382fb		e84077feff		CALL runtime.panicindex(SB)	
  0x438300		0f0b			UD2				
		for datap.ftab[idx+1].entry <= pc {
  0x438302		e83977feff		CALL runtime.panicindex(SB)	
  0x438307		0f0b			UD2				
			throw("findfunc: bad findfunctab entry idx")
  0x438309		488d05d9490300		LEAQ 0x349d9(IP), AX	
  0x438310		48890424		MOVQ AX, 0(SP)		
  0x438314		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x43831d		e8ae8efeff		CALL runtime.throw(SB)	
  0x438322		0f0b			UD2			
		for datap.ftab[idx].entry > pc && idx > 0 {
  0x438324		e81777feff		CALL runtime.panicindex(SB)	
  0x438329		0f0b			UD2				
	if pc < datap.ftab[idx].entry {
  0x43832b		e81077feff		CALL runtime.panicindex(SB)	
  0x438330		0f0b			UD2				
	idx := ffb.idx + uint32(ffb.subbuckets[i])
  0x438332		e80977feff		CALL runtime.panicindex(SB)	
  0x438337		0f0b			UD2				
func findfunc(pc uintptr) funcInfo {
  0x438339		e832c20000		CALL runtime.morestack_noctxt(SB)	
  0x43833e		e98dfeffff		JMP runtime.findfunc(SB)		

TEXT runtime.pcvalue(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x438350		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438359		488d4424d8		LEAQ -0x28(SP), AX	
  0x43835e		483b4110		CMPQ 0x10(CX), AX	
  0x438362		0f8681050000		JBE 0x4388e9		
  0x438368		4881eca8000000		SUBQ $0xa8, SP		
  0x43836f		4889ac24a0000000	MOVQ BP, 0xa0(SP)	
  0x438377		488dac24a0000000	LEAQ 0xa0(SP), BP	
  0x43837f		8b8424c0000000		MOVL 0xc0(SP), AX	
	if off == 0 {
  0x438386		85c0			TESTL AX, AX		
  0x438388		0f84b7040000		JE 0x438845		
  0x43838e		488b8c24d0000000	MOVQ 0xd0(SP), CX	
	if cache != nil {
  0x438396		4885c9			TESTQ CX, CX		
  0x438399		0f8499040000		JE 0x438838		
  0x43839f		488b9424c8000000	MOVQ 0xc8(SP), DX	
  0x4383a7		31db			XORL BX, BX		
		for i := range cache.entries {
  0x4383a9		eb04			JMP 0x4383af		
  0x4383ab		488d5e01		LEAQ 0x1(SI), BX	
  0x4383af		4883fb10		CMPQ $0x10, BX		
  0x4383b3		7d33			JGE 0x4383e8		
  0x4383b5		4889de			MOVQ BX, SI		
			ent := &cache.entries[i]
  0x4383b8		48c1e304		SHLQ $0x4, BX		
			if ent.off == off && ent.targetpc == targetpc {
  0x4383bc		8b7c1908		MOVL 0x8(CX)(BX*1), DI	
  0x4383c0		39f8			CMPL DI, AX		
  0x4383c2		75e7			JNE 0x4383ab		
  0x4383c4		488b3c19		MOVQ 0(CX)(BX*1), DI	
  0x4383c8		4839fa			CMPQ DI, DX		
  0x4383cb		75de			JNE 0x4383ab		
				return ent.val
  0x4383cd		8b44190c		MOVL 0xc(CX)(BX*1), AX	
  0x4383d1		898424e0000000		MOVL AX, 0xe0(SP)	
  0x4383d8		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x4383e0		4881c4a8000000		ADDQ $0xa8, SP		
  0x4383e7		c3			RET			
  0x4383e8		488b9c24b0000000	MOVQ 0xb0(SP), BX	
	return f._func != nil
  0x4383f0		4885db			TESTQ BX, BX		
	if !f.valid() {
  0x4383f3		0f840e040000		JE 0x438807		
  0x4383f9		488bb424b8000000	MOVQ 0xb8(SP), SI	
	p := datap.pclntable[off:]
  0x438401		488b7e10		MOVQ 0x10(SI), DI	
  0x438405		4c8b4608		MOVQ 0x8(SI), R8	
  0x438409		4c8b0e			MOVQ 0(SI), R9		
  0x43840c		4c63d0			MOVSXD AX, R10		
  0x43840f		4d39c2			CMPQ R8, R10		
  0x438412		0f8771040000		JA 0x438889		
  0x438418		4c89942480000000	MOVQ R10, 0x80(SP)	
	pc := f.entry
  0x438420		4c8b1b			MOVQ 0(BX), R11		
  0x438423		4c895c2458		MOVQ R11, 0x58(SP)	
	val := int32(-1)
  0x438428		c7442454ffffffff	MOVL $-0x1, 0x54(SP)	
  0x438430		4c8d5c2428		LEAQ 0x28(SP), R11	
  0x438435		4c899c2498000000	MOVQ R11, 0x98(SP)	
	p := datap.pclntable[off:]
  0x43843d		4d29d0			SUBQ R10, R8		
  0x438440		4c29d7			SUBQ R10, DI		
  0x438443		4989fc			MOVQ DI, R12		
  0x438446		48f7df			NEGQ DI			
  0x438449		48c1ff3f		SARQ $0x3f, DI		
  0x43844d		4c21d7			ANDQ R10, DI		
  0x438450		4c01cf			ADDQ R9, DI		
	for {
  0x438453		eb19			JMP 0x43846e		
  0x438455		4c8b9c2498000000	MOVQ 0x98(SP), R11	
  0x43845d		4989cc			MOVQ CX, R12		
  0x438460		4989d0			MOVQ DX, R8		
  0x438463		4889df			MOVQ BX, DI		
  0x438466		488b9c24b0000000	MOVQ 0xb0(SP), BX	
		p, ok = step(p, &pc, &val, pc == f.entry)
  0x43846e		488b442458		MOVQ 0x58(SP), AX	
  0x438473		488b0b			MOVQ 0(BX), CX		
  0x438476		4839c1			CMPQ AX, CX		
  0x438479		410f9403		SETE 0(R11)		
  0x43847d		48893c24		MOVQ DI, 0(SP)		
  0x438481		4c89442408		MOVQ R8, 0x8(SP)	
  0x438486		4c89642410		MOVQ R12, 0x10(SP)	
  0x43848b		488d442458		LEAQ 0x58(SP), AX	
  0x438490		4889442418		MOVQ AX, 0x18(SP)	
  0x438495		488d4c2454		LEAQ 0x54(SP), CX	
  0x43849a		48894c2420		MOVQ CX, 0x20(SP)	
  0x43849f		e82c0b0000		CALL runtime.step(SB)	
  0x4384a4		0fb6442448		MOVZX 0x48(SP), AX	
  0x4384a9		488b4c2440		MOVQ 0x40(SP), CX	
  0x4384ae		488b542438		MOVQ 0x38(SP), DX	
  0x4384b3		488b5c2430		MOVQ 0x30(SP), BX	
  0x4384b8		84c0			TESTL AL, AL		
		if !ok {
  0x4384ba		0f84a6000000		JE 0x438566		
		if targetpc < pc {
  0x4384c0		488b442458		MOVQ 0x58(SP), AX	
  0x4384c5		488bb424c8000000	MOVQ 0xc8(SP), SI	
  0x4384cd		4839c6			CMPQ AX, SI		
  0x4384d0		7383			JAE 0x438455		
  0x4384d2		488b8424d0000000	MOVQ 0xd0(SP), AX	
	if cache != nil {
  0x4384da		4885c0			TESTQ AX, AX		
			if cache != nil {
  0x4384dd		746c			JE 0x43854b		
	mp := getg().m
  0x4384df		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4384e8		488b4930		MOVQ 0x30(CX), CX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x4384ec		8b9120010000		MOVL 0x120(CX), DX	
  0x4384f2		8b9924010000		MOVL 0x124(CX), BX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x4384f8		899920010000		MOVL BX, 0x120(CX)	
  0x4384fe		89d7			MOVL DX, DI		
	s1 ^= s1 << 17
  0x438500		c1e211			SHLL $0x11, DX		
  0x438503		31fa			XORL DI, DX		
  0x438505		89df			MOVL BX, DI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x438507		31d3			XORL DX, BX		
  0x438509		c1ea07			SHRL $0x7, DX		
  0x43850c		31da			XORL BX, DX		
  0x43850e		89fb			MOVL DI, BX		
  0x438510		c1ef10			SHRL $0x10, DI		
  0x438513		31d7			XORL DX, DI		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x438515		89b924010000		MOVL DI, 0x124(CX)	
				cache.entries[ci] = pcvalueCacheEnt{
  0x43851b		8b4c2454		MOVL 0x54(SP), CX	
	return s0 + s1
  0x43851f		8d143b			LEAL 0(BX)(DI*1), DX	
	return uint32(uint64(fastrand()) * uint64(n) >> 32)
  0x438522		48c1e204		SHLQ $0x4, DX		
  0x438526		48c1ea20		SHRQ $0x20, DX		
				cache.entries[ci] = pcvalueCacheEnt{
  0x43852a		4883fa10		CMPQ $0x10, DX		
  0x43852e		0f834e030000		JAE 0x438882		
  0x438534		48c1e204		SHLQ $0x4, DX		
  0x438538		48893410		MOVQ SI, 0(AX)(DX*1)	
  0x43853c		8b9c24c0000000		MOVL 0xc0(SP), BX	
  0x438543		895c1008		MOVL BX, 0x8(AX)(DX*1)	
  0x438547		894c100c		MOVL CX, 0xc(AX)(DX*1)	
			return val
  0x43854b		8b442454		MOVL 0x54(SP), AX	
  0x43854f		898424e0000000		MOVL AX, 0xe0(SP)	
  0x438556		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x43855e		4881c4a8000000		ADDQ $0xa8, SP		
  0x438565		c3			RET			
	if panicking != 0 || !strict {
  0x438566		8b0588b30800		MOVL runtime.panicking(SB), AX	
  0x43856c		85c0			TESTL AX, AX			
  0x43856e		0f8578020000		JNE 0x4387ec			
  0x438574		0fb68424d8000000	MOVZX 0xd8(SP), AX		
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x43857c		84c0			TESTL AL, AL		
	if panicking != 0 || !strict {
  0x43857e		0f8468020000		JE 0x4387ec		
  0x438584		48894c2468		MOVQ CX, 0x68(SP)	
  0x438589		4889542460		MOVQ DX, 0x60(SP)	
  0x43858e		48899c2488000000	MOVQ BX, 0x88(SP)	
  0x438596		488b8424b0000000	MOVQ 0xb0(SP), AX	
	print("runtime: invalid pc-encoded table f=", funcname(f), " pc=", hex(pc), " targetpc=", hex(targetpc), " tab=", p, "\n")
  0x43859e		48890424		MOVQ AX, 0(SP)			
  0x4385a2		488b8c24b8000000	MOVQ 0xb8(SP), CX		
  0x4385aa		48894c2408		MOVQ CX, 0x8(SP)		
  0x4385af		e84c030000		CALL runtime.funcname(SB)	
  0x4385b4		488b442418		MOVQ 0x18(SP), AX		
  0x4385b9		4889442478		MOVQ AX, 0x78(SP)		
  0x4385be		488b4c2410		MOVQ 0x10(SP), CX		
  0x4385c3		48898c2490000000	MOVQ CX, 0x90(SP)		
  0x4385cb		488b542458		MOVQ 0x58(SP), DX		
  0x4385d0		4889542470		MOVQ DX, 0x70(SP)		
  0x4385d5		e82695feff		CALL runtime.printlock(SB)	
  0x4385da		488d0569480300		LEAQ 0x34869(IP), AX		
  0x4385e1		48890424		MOVQ AX, 0(SP)			
  0x4385e5		48c744240824000000	MOVQ $0x24, 0x8(SP)		
  0x4385ee		e84d9efeff		CALL runtime.printstring(SB)	
  0x4385f3		488b842490000000	MOVQ 0x90(SP), AX		
  0x4385fb		48890424		MOVQ AX, 0(SP)			
  0x4385ff		488b442478		MOVQ 0x78(SP), AX		
  0x438604		4889442408		MOVQ AX, 0x8(SP)		
  0x438609		e8329efeff		CALL runtime.printstring(SB)	
  0x43860e		488d05bd160300		LEAQ 0x316bd(IP), AX		
  0x438615		48890424		MOVQ AX, 0(SP)			
  0x438619		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x438622		e8199efeff		CALL runtime.printstring(SB)	
  0x438627		488b442470		MOVQ 0x70(SP), AX		
  0x43862c		48890424		MOVQ AX, 0(SP)			
  0x438630		e8bb9cfeff		CALL runtime.printhex(SB)	
  0x438635		488d05b21c0300		LEAQ 0x31cb2(IP), AX		
  0x43863c		48890424		MOVQ AX, 0(SP)			
  0x438640		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x438649		e8f29dfeff		CALL runtime.printstring(SB)	
  0x43864e		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x438656		48890424		MOVQ AX, 0(SP)			
  0x43865a		e8919cfeff		CALL runtime.printhex(SB)	
  0x43865f		488d051b170300		LEAQ 0x3171b(IP), AX		
  0x438666		48890424		MOVQ AX, 0(SP)			
  0x43866a		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x438673		e8c89dfeff		CALL runtime.printstring(SB)	
  0x438678		488b842488000000	MOVQ 0x88(SP), AX		
  0x438680		48890424		MOVQ AX, 0(SP)			
  0x438684		488b442460		MOVQ 0x60(SP), AX		
  0x438689		4889442408		MOVQ AX, 0x8(SP)		
  0x43868e		488b442468		MOVQ 0x68(SP), AX		
  0x438693		4889442410		MOVQ AX, 0x10(SP)		
  0x438698		e8439efeff		CALL runtime.printslice(SB)	
  0x43869d		e8ee96feff		CALL runtime.printnl(SB)	
  0x4386a2		e8d994feff		CALL runtime.printunlock(SB)	
  0x4386a7		488b8424b8000000	MOVQ 0xb8(SP), AX		
	p = datap.pclntable[off:]
  0x4386af		488b4810		MOVQ 0x10(AX), CX	
  0x4386b3		488b5008		MOVQ 0x8(AX), DX	
  0x4386b7		488b00			MOVQ 0(AX), AX		
  0x4386ba		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x4386c2		4839d3			CMPQ DX, BX		
  0x4386c5		0f87b0010000		JA 0x43887b		
  0x4386cb		488bb424b0000000	MOVQ 0xb0(SP), SI	
	pc = f.entry
  0x4386d3		488b3e			MOVQ 0(SI), DI		
  0x4386d6		48897c2458		MOVQ DI, 0x58(SP)	
	val = -1
  0x4386db		c7442454ffffffff	MOVL $-0x1, 0x54(SP)	
	p = datap.pclntable[off:]
  0x4386e3		4829da			SUBQ BX, DX		
  0x4386e6		4829d9			SUBQ BX, CX		
  0x4386e9		4889cf			MOVQ CX, DI		
  0x4386ec		48f7d9			NEGQ CX			
  0x4386ef		48c1f93f		SARQ $0x3f, CX		
  0x4386f3		4821d9			ANDQ BX, CX		
  0x4386f6		4801c8			ADDQ CX, AX		
	for {
  0x4386f9		e993000000		JMP 0x438791		
  0x4386fe		4889442468		MOVQ AX, 0x68(SP)	
  0x438703		48894c2460		MOVQ CX, 0x60(SP)	
  0x438708		4889942488000000	MOVQ DX, 0x88(SP)	
		print("\tvalue=", val, " until pc=", hex(pc), "\n")
  0x438710		488b442458		MOVQ 0x58(SP), AX		
  0x438715		4889442470		MOVQ AX, 0x70(SP)		
  0x43871a		e8e193feff		CALL runtime.printlock(SB)	
  0x43871f		488d0596170300		LEAQ 0x31796(IP), AX		
  0x438726		48890424		MOVQ AX, 0(SP)			
  0x43872a		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x438733		e8089dfeff		CALL runtime.printstring(SB)	
  0x438738		4863442454		MOVSXD 0x54(SP), AX		
  0x43873d		48890424		MOVQ AX, 0(SP)			
  0x438741		e83a9bfeff		CALL runtime.printint(SB)	
  0x438746		488d05b51b0300		LEAQ 0x31bb5(IP), AX		
  0x43874d		48890424		MOVQ AX, 0(SP)			
  0x438751		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43875a		e8e19cfeff		CALL runtime.printstring(SB)	
  0x43875f		488b442470		MOVQ 0x70(SP), AX		
  0x438764		48890424		MOVQ AX, 0(SP)			
  0x438768		e8839bfeff		CALL runtime.printhex(SB)	
  0x43876d		e81e96feff		CALL runtime.printnl(SB)	
  0x438772		e80994feff		CALL runtime.printunlock(SB)	
  0x438777		488bb424b0000000	MOVQ 0xb0(SP), SI		
  0x43877f		488b7c2468		MOVQ 0x68(SP), DI		
  0x438784		488b542460		MOVQ 0x60(SP), DX		
  0x438789		488b842488000000	MOVQ 0x88(SP), AX		
		p, ok = step(p, &pc, &val, pc == f.entry)
  0x438791		488b4c2458		MOVQ 0x58(SP), CX	
  0x438796		488b1e			MOVQ 0(SI), BX		
  0x438799		4839cb			CMPQ CX, BX		
  0x43879c		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x4387a4		0f9401			SETE 0(CX)		
  0x4387a7		48890424		MOVQ AX, 0(SP)		
  0x4387ab		4889542408		MOVQ DX, 0x8(SP)	
  0x4387b0		48897c2410		MOVQ DI, 0x10(SP)	
  0x4387b5		488d442458		LEAQ 0x58(SP), AX	
  0x4387ba		4889442418		MOVQ AX, 0x18(SP)	
  0x4387bf		488d542454		LEAQ 0x54(SP), DX	
  0x4387c4		4889542420		MOVQ DX, 0x20(SP)	
  0x4387c9		e802080000		CALL runtime.step(SB)	
  0x4387ce		488b442440		MOVQ 0x40(SP), AX	
  0x4387d3		488b4c2438		MOVQ 0x38(SP), CX	
  0x4387d8		488b542430		MOVQ 0x30(SP), DX	
  0x4387dd		0fb65c2448		MOVZX 0x48(SP), BX	
  0x4387e2		84db			TESTL BL, BL		
		if !ok {
  0x4387e4		0f8514ffffff		JNE 0x4386fe		
  0x4387ea		eb74			JMP 0x438860		
		return -1
  0x4387ec		c78424e0000000ffffffff	MOVL $-0x1, 0xe0(SP)	
  0x4387f7		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x4387ff		4881c4a8000000		ADDQ $0xa8, SP		
  0x438806		c3			RET			
  0x438807		0fb68424d8000000	MOVZX 0xd8(SP), AX	
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x43880f		84c0			TESTL AL, AL		
		if strict && panicking == 0 {
  0x438811		740a			JE 0x43881d			
  0x438813		8b05dbb00800		MOVL runtime.panicking(SB), AX	
  0x438819		85c0			TESTL AX, AX			
  0x43881b		7473			JE 0x438890			
		return -1
  0x43881d		c78424e0000000ffffffff	MOVL $-0x1, 0xe0(SP)	
  0x438828		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x438830		4881c4a8000000		ADDQ $0xa8, SP		
  0x438837		c3			RET			
  0x438838		488b9424c8000000	MOVQ 0xc8(SP), DX	
	if cache != nil {
  0x438840		e9a3fbffff		JMP 0x4383e8		
		return -1
  0x438845		c78424e0000000ffffffff	MOVL $-0x1, 0xe0(SP)	
  0x438850		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x438858		4881c4a8000000		ADDQ $0xa8, SP		
  0x43885f		c3			RET			
	throw("invalid runtime symbol table")
  0x438860		488d05a3380300		LEAQ 0x338a3(IP), AX	
  0x438867		48890424		MOVQ AX, 0(SP)		
  0x43886b		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x438874		e85789feff		CALL runtime.throw(SB)	
  0x438879		0f0b			UD2			
	p = datap.pclntable[off:]
  0x43887b		e83072feff		CALL runtime.panicslice(SB)	
  0x438880		0f0b			UD2				
				cache.entries[ci] = pcvalueCacheEnt{
  0x438882		e8b971feff		CALL runtime.panicindex(SB)	
  0x438887		0f0b			UD2				
	p := datap.pclntable[off:]
  0x438889		e82272feff		CALL runtime.panicslice(SB)	
  0x43888e		0f0b			UD2				
			print("runtime: no module data for ", hex(f.entry), "\n")
  0x438890		488b03			MOVQ 0(BX), AX			
  0x438893		4889442470		MOVQ AX, 0x70(SP)		
  0x438898		e86392feff		CALL runtime.printlock(SB)	
  0x43889d		488d052a390300		LEAQ 0x3392a(IP), AX		
  0x4388a4		48890424		MOVQ AX, 0(SP)			
  0x4388a8		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x4388b1		e88a9bfeff		CALL runtime.printstring(SB)	
  0x4388b6		488b442470		MOVQ 0x70(SP), AX		
  0x4388bb		48890424		MOVQ AX, 0(SP)			
  0x4388bf		e82c9afeff		CALL runtime.printhex(SB)	
  0x4388c4		e8c794feff		CALL runtime.printnl(SB)	
  0x4388c9		e8b292feff		CALL runtime.printunlock(SB)	
			throw("no module data")
  0x4388ce		488d05db1f0300		LEAQ 0x31fdb(IP), AX	
  0x4388d5		48890424		MOVQ AX, 0(SP)		
  0x4388d9		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4388e2		e8e988feff		CALL runtime.throw(SB)	
  0x4388e7		0f0b			UD2			
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x4388e9		e882bc0000		CALL runtime.morestack_noctxt(SB)	
  0x4388ee		e95dfaffff		JMP runtime.pcvalue(SB)			

TEXT runtime.funcname(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func funcname(f funcInfo) string {
  0x438900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438909		483b6110		CMPQ 0x10(CX), SP	
  0x43890d		7668			JBE 0x438977		
  0x43890f		4883ec20		SUBQ $0x20, SP		
  0x438913		48896c2418		MOVQ BP, 0x18(SP)	
  0x438918		488d6c2418		LEAQ 0x18(SP), BP	
  0x43891d		488b442428		MOVQ 0x28(SP), AX	
	return f._func != nil
  0x438922		4885c0			TESTQ AX, AX		
	if !f.valid() || f.nameoff == 0 {
  0x438925		7407			JE 0x43892e		
  0x438927		8b4008			MOVL 0x8(AX), AX	
  0x43892a		85c0			TESTL AX, AX		
  0x43892c		7529			JNE 0x438957		
  0x43892e		31c0			XORL AX, AX		
	return gostringnocopy(cfuncname(f))
  0x438930		48890424		MOVQ AX, 0(SP)			
  0x438934		e8b7edffff		CALL runtime.gostringnocopy(SB)	
  0x438939		488b442410		MOVQ 0x10(SP), AX		
  0x43893e		488b4c2408		MOVQ 0x8(SP), CX		
  0x438943		48894c2438		MOVQ CX, 0x38(SP)		
  0x438948		4889442440		MOVQ AX, 0x40(SP)		
  0x43894d		488b6c2418		MOVQ 0x18(SP), BP		
  0x438952		4883c420		ADDQ $0x20, SP			
  0x438956		c3			RET				
	return &f.datap.pclntable[f.nameoff]
  0x438957		4863c0			MOVSXD AX, AX		
  0x43895a		488b4c2430		MOVQ 0x30(SP), CX	
  0x43895f		488b5108		MOVQ 0x8(CX), DX	
  0x438963		488b09			MOVQ 0(CX), CX		
  0x438966		4839d0			CMPQ DX, AX		
  0x438969		7305			JAE 0x438970		
  0x43896b		4801c8			ADDQ CX, AX		
	return gostringnocopy(cfuncname(f))
  0x43896e		ebc0			JMP 0x438930		
	return &f.datap.pclntable[f.nameoff]
  0x438970		e8cb70feff		CALL runtime.panicindex(SB)	
  0x438975		0f0b			UD2				
func funcname(f funcInfo) string {
  0x438977		e8f4bb0000		CALL runtime.morestack_noctxt(SB)	
  0x43897c		eb82			JMP runtime.funcname(SB)		

TEXT runtime.funcnameFromNameoff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func funcnameFromNameoff(f funcInfo, nameoff int32) string {
  0x438980		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438989		483b6110		CMPQ 0x10(CX), SP	
  0x43898d		7673			JBE 0x438a02		
  0x43898f		4883ec20		SUBQ $0x20, SP		
  0x438993		48896c2418		MOVQ BP, 0x18(SP)	
  0x438998		488d6c2418		LEAQ 0x18(SP), BP	
  0x43899d		488b442428		MOVQ 0x28(SP), AX	
	return f._func != nil
  0x4389a2		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x4389a5		7442			JE 0x4389e9		
  0x4389a7		8b442438		MOVL 0x38(SP), AX	
	cstr := &datap.pclntable[nameoff]
  0x4389ab		4863c0			MOVSXD AX, AX		
  0x4389ae		488b4c2430		MOVQ 0x30(SP), CX	
  0x4389b3		488b11			MOVQ 0(CX), DX		
  0x4389b6		488b4908		MOVQ 0x8(CX), CX	
  0x4389ba		4839c8			CMPQ CX, AX		
  0x4389bd		733c			JAE 0x4389fb		
  0x4389bf		4801d0			ADDQ DX, AX		
	return gostringnocopy(cstr)
  0x4389c2		48890424		MOVQ AX, 0(SP)			
  0x4389c6		e825edffff		CALL runtime.gostringnocopy(SB)	
  0x4389cb		488b442410		MOVQ 0x10(SP), AX		
  0x4389d0		488b4c2408		MOVQ 0x8(SP), CX		
  0x4389d5		48894c2440		MOVQ CX, 0x40(SP)		
  0x4389da		4889442448		MOVQ AX, 0x48(SP)		
  0x4389df		488b6c2418		MOVQ 0x18(SP), BP		
  0x4389e4		4883c420		ADDQ $0x20, SP			
  0x4389e8		c3			RET				
		return ""
  0x4389e9		0f57c0			XORPS X0, X0		
  0x4389ec		0f11442440		MOVUPS X0, 0x40(SP)	
  0x4389f1		488b6c2418		MOVQ 0x18(SP), BP	
  0x4389f6		4883c420		ADDQ $0x20, SP		
  0x4389fa		c3			RET			
	cstr := &datap.pclntable[nameoff]
  0x4389fb		e84070feff		CALL runtime.panicindex(SB)	
  0x438a00		0f0b			UD2				
func funcnameFromNameoff(f funcInfo, nameoff int32) string {
  0x438a02		e869bb0000		CALL runtime.morestack_noctxt(SB)	
  0x438a07		e974ffffff		JMP runtime.funcnameFromNameoff(SB)	

TEXT runtime.funcfile(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func funcfile(f funcInfo, fileno int32) string {
  0x438a10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438a19		483b6110		CMPQ 0x10(CX), SP	
  0x438a1d		0f8690000000		JBE 0x438ab3		
  0x438a23		4883ec20		SUBQ $0x20, SP		
  0x438a27		48896c2418		MOVQ BP, 0x18(SP)	
  0x438a2c		488d6c2418		LEAQ 0x18(SP), BP	
  0x438a31		488b442428		MOVQ 0x28(SP), AX	
	return f._func != nil
  0x438a36		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x438a39		7452			JE 0x438a8d		
  0x438a3b		488b442430		MOVQ 0x30(SP), AX	
	return gostringnocopy(&datap.pclntable[datap.filetab[fileno]])
  0x438a40		488b4808		MOVQ 0x8(AX), CX		
  0x438a44		488b10			MOVQ 0(AX), DX			
  0x438a47		488b5838		MOVQ 0x38(AX), BX		
  0x438a4b		488b4030		MOVQ 0x30(AX), AX		
  0x438a4f		8b742438		MOVL 0x38(SP), SI		
  0x438a53		4863f6			MOVSXD SI, SI			
  0x438a56		4839de			CMPQ BX, SI			
  0x438a59		7351			JAE 0x438aac			
  0x438a5b		8b04b0			MOVL 0(AX)(SI*4), AX		
  0x438a5e		4839c8			CMPQ CX, AX			
  0x438a61		7349			JAE 0x438aac			
  0x438a63		4801d0			ADDQ DX, AX			
  0x438a66		48890424		MOVQ AX, 0(SP)			
  0x438a6a		e881ecffff		CALL runtime.gostringnocopy(SB)	
  0x438a6f		488b442408		MOVQ 0x8(SP), AX		
  0x438a74		488b4c2410		MOVQ 0x10(SP), CX		
  0x438a79		4889442440		MOVQ AX, 0x40(SP)		
  0x438a7e		48894c2448		MOVQ CX, 0x48(SP)		
  0x438a83		488b6c2418		MOVQ 0x18(SP), BP		
  0x438a88		4883c420		ADDQ $0x20, SP			
  0x438a8c		c3			RET				
		return "?"
  0x438a8d		488d05c7110300		LEAQ 0x311c7(IP), AX	
  0x438a94		4889442440		MOVQ AX, 0x40(SP)	
  0x438a99		48c744244801000000	MOVQ $0x1, 0x48(SP)	
  0x438aa2		488b6c2418		MOVQ 0x18(SP), BP	
  0x438aa7		4883c420		ADDQ $0x20, SP		
  0x438aab		c3			RET			
	return gostringnocopy(&datap.pclntable[datap.filetab[fileno]])
  0x438aac		e88f6ffeff		CALL runtime.panicindex(SB)	
  0x438ab1		0f0b			UD2				
func funcfile(f funcInfo, fileno int32) string {
  0x438ab3		e8b8ba0000		CALL runtime.morestack_noctxt(SB)	
  0x438ab8		e953ffffff		JMP runtime.funcfile(SB)		

TEXT runtime.funcline1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func funcline1(f funcInfo, targetpc uintptr, strict bool) (file string, line int32) {
  0x438ac0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438ac9		483b6110		CMPQ 0x10(CX), SP	
  0x438acd		0f866c010000		JBE 0x438c3f		
  0x438ad3		4883ec50		SUBQ $0x50, SP		
  0x438ad7		48896c2448		MOVQ BP, 0x48(SP)	
  0x438adc		488d6c2448		LEAQ 0x48(SP), BP	
  0x438ae1		488b442458		MOVQ 0x58(SP), AX	
	return f._func != nil
  0x438ae6		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x438ae9		0f841c010000		JE 0x438c0b		
	fileno := int(pcvalue(f, f.pcfile, targetpc, nil, strict))
  0x438aef		8b4818			MOVL 0x18(AX), CX		
  0x438af2		894c2410		MOVL CX, 0x10(SP)		
  0x438af6		48890424		MOVQ AX, 0(SP)			
  0x438afa		488b4c2460		MOVQ 0x60(SP), CX		
  0x438aff		48894c2408		MOVQ CX, 0x8(SP)		
  0x438b04		488b542468		MOVQ 0x68(SP), DX		
  0x438b09		4889542418		MOVQ DX, 0x18(SP)		
  0x438b0e		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x438b17		0fb65c2470		MOVZX 0x70(SP), BX		
  0x438b1c		885c2428		MOVB BL, 0x28(SP)		
  0x438b20		e82bf8ffff		CALL runtime.pcvalue(SB)	
  0x438b25		4863442430		MOVSXD 0x30(SP), AX		
  0x438b2a		4889442440		MOVQ AX, 0x40(SP)		
  0x438b2f		488b4c2458		MOVQ 0x58(SP), CX		
	line = pcvalue(f, f.pcln, targetpc, nil, strict)
  0x438b34		8b511c			MOVL 0x1c(CX), DX		
  0x438b37		89542410		MOVL DX, 0x10(SP)		
  0x438b3b		48890c24		MOVQ CX, 0(SP)			
  0x438b3f		488b4c2460		MOVQ 0x60(SP), CX		
  0x438b44		48894c2408		MOVQ CX, 0x8(SP)		
  0x438b49		488b542468		MOVQ 0x68(SP), DX		
  0x438b4e		4889542418		MOVQ DX, 0x18(SP)		
  0x438b53		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x438b5c		0fb6542470		MOVZX 0x70(SP), DX		
  0x438b61		88542428		MOVB DL, 0x28(SP)		
  0x438b65		e8e6f7ffff		CALL runtime.pcvalue(SB)	
  0x438b6a		8b442430		MOVL 0x30(SP), AX		
  0x438b6e		488b4c2440		MOVQ 0x40(SP), CX		
	if fileno == -1 || line == -1 || fileno >= len(datap.filetab) {
  0x438b73		4883f9ff		CMPQ $-0x1, CX		
  0x438b77		752d			JNE 0x438ba6		
		return "?", 0
  0x438b79		488d05db100300			LEAQ 0x310db(IP), AX	
  0x438b80		4889442478			MOVQ AX, 0x78(SP)	
  0x438b85		48c784248000000001000000	MOVQ $0x1, 0x80(SP)	
  0x438b91		c784248800000000000000		MOVL $0x0, 0x88(SP)	
  0x438b9c		488b6c2448			MOVQ 0x48(SP), BP	
  0x438ba1		4883c450			ADDQ $0x50, SP		
  0x438ba5		c3				RET			
	if fileno == -1 || line == -1 || fileno >= len(datap.filetab) {
  0x438ba6		83f8ff			CMPL $-0x1, AX		
  0x438ba9		74ce			JE 0x438b79		
  0x438bab		488b542460		MOVQ 0x60(SP), DX	
  0x438bb0		488b5a38		MOVQ 0x38(DX), BX	
  0x438bb4		488b7230		MOVQ 0x30(DX), SI	
  0x438bb8		4839d9			CMPQ BX, CX		
  0x438bbb		7dbc			JGE 0x438b79		
	file = gostringnocopy(&datap.pclntable[datap.filetab[fileno]])
  0x438bbd		488b1a			MOVQ 0(DX), BX			
  0x438bc0		488b5208		MOVQ 0x8(DX), DX		
  0x438bc4		7372			JAE 0x438c38			
  0x438bc6		8b0c8e			MOVL 0(SI)(CX*4), CX		
  0x438bc9		4839d1			CMPQ DX, CX			
  0x438bcc		736a			JAE 0x438c38			
  0x438bce		8944243c		MOVL AX, 0x3c(SP)		
  0x438bd2		488d040b		LEAQ 0(BX)(CX*1), AX		
  0x438bd6		48890424		MOVQ AX, 0(SP)			
  0x438bda		e811ebffff		CALL runtime.gostringnocopy(SB)	
  0x438bdf		488b442410		MOVQ 0x10(SP), AX		
  0x438be4		488b4c2408		MOVQ 0x8(SP), CX		
	return
  0x438be9		48894c2478		MOVQ CX, 0x78(SP)	
  0x438bee		4889842480000000	MOVQ AX, 0x80(SP)	
  0x438bf6		8b44243c		MOVL 0x3c(SP), AX	
  0x438bfa		89842488000000		MOVL AX, 0x88(SP)	
  0x438c01		488b6c2448		MOVQ 0x48(SP), BP	
  0x438c06		4883c450		ADDQ $0x50, SP		
  0x438c0a		c3			RET			
		return "?", 0
  0x438c0b		488d0549100300			LEAQ 0x31049(IP), AX	
  0x438c12		4889442478			MOVQ AX, 0x78(SP)	
  0x438c17		48c784248000000001000000	MOVQ $0x1, 0x80(SP)	
  0x438c23		c784248800000000000000		MOVL $0x0, 0x88(SP)	
  0x438c2e		488b6c2448			MOVQ 0x48(SP), BP	
  0x438c33		4883c450			ADDQ $0x50, SP		
  0x438c37		c3				RET			
	file = gostringnocopy(&datap.pclntable[datap.filetab[fileno]])
  0x438c38		e8036efeff		CALL runtime.panicindex(SB)	
  0x438c3d		0f0b			UD2				
func funcline1(f funcInfo, targetpc uintptr, strict bool) (file string, line int32) {
  0x438c3f		e82cb90000		CALL runtime.morestack_noctxt(SB)	
  0x438c44		e977feffff		JMP runtime.funcline1(SB)		

TEXT runtime.funcline(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {
  0x438c50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438c59		483b6110		CMPQ 0x10(CX), SP	
  0x438c5d		765b			JBE 0x438cba		
  0x438c5f		4883ec40		SUBQ $0x40, SP		
  0x438c63		48896c2438		MOVQ BP, 0x38(SP)	
  0x438c68		488d6c2438		LEAQ 0x38(SP), BP	
  0x438c6d		488b442448		MOVQ 0x48(SP), AX	
	return funcline1(f, targetpc, true)
  0x438c72		48890424		MOVQ AX, 0(SP)		
func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {
  0x438c76		488b442450		MOVQ 0x50(SP), AX	
	return funcline1(f, targetpc, true)
  0x438c7b		4889442408		MOVQ AX, 0x8(SP)	
func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {
  0x438c80		488b442458		MOVQ 0x58(SP), AX	
	return funcline1(f, targetpc, true)
  0x438c85		4889442410		MOVQ AX, 0x10(SP)		
  0x438c8a		c644241801		MOVB $0x1, 0x18(SP)		
  0x438c8f		e82cfeffff		CALL runtime.funcline1(SB)	
  0x438c94		488b442428		MOVQ 0x28(SP), AX		
  0x438c99		488b4c2420		MOVQ 0x20(SP), CX		
  0x438c9e		8b542430		MOVL 0x30(SP), DX		
  0x438ca2		48894c2460		MOVQ CX, 0x60(SP)		
  0x438ca7		4889442468		MOVQ AX, 0x68(SP)		
  0x438cac		89542470		MOVL DX, 0x70(SP)		
  0x438cb0		488b6c2438		MOVQ 0x38(SP), BP		
  0x438cb5		4883c440		ADDQ $0x40, SP			
  0x438cb9		c3			RET				
func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {
  0x438cba		e8b1b80000		CALL runtime.morestack_noctxt(SB)	
  0x438cbf		eb8f			JMP runtime.funcline(SB)		

TEXT runtime.funcspdelta(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
  0x438cd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438cd9		483b6110		CMPQ 0x10(CX), SP	
  0x438cdd		0f8648010000		JBE 0x438e2b		
  0x438ce3		4883ec68		SUBQ $0x68, SP		
  0x438ce7		48896c2460		MOVQ BP, 0x60(SP)	
  0x438cec		488d6c2460		LEAQ 0x60(SP), BP	
  0x438cf1		488b442470		MOVQ 0x70(SP), AX	
	x := pcvalue(f, f.pcsp, targetpc, cache, true)
  0x438cf6		8b4814			MOVL 0x14(AX), CX	
  0x438cf9		894c2410		MOVL CX, 0x10(SP)	
  0x438cfd		48890424		MOVQ AX, 0(SP)		
func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
  0x438d01		488b4c2478		MOVQ 0x78(SP), CX	
	x := pcvalue(f, f.pcsp, targetpc, cache, true)
  0x438d06		48894c2408		MOVQ CX, 0x8(SP)	
func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
  0x438d0b		488b942480000000	MOVQ 0x80(SP), DX	
	x := pcvalue(f, f.pcsp, targetpc, cache, true)
  0x438d13		4889542418		MOVQ DX, 0x18(SP)	
func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
  0x438d18		488b9c2488000000	MOVQ 0x88(SP), BX	
	x := pcvalue(f, f.pcsp, targetpc, cache, true)
  0x438d20		48895c2420		MOVQ BX, 0x20(SP)		
  0x438d25		c644242801		MOVB $0x1, 0x28(SP)		
  0x438d2a		e821f6ffff		CALL runtime.pcvalue(SB)	
  0x438d2f		8b442430		MOVL 0x30(SP), AX		
	if x&(sys.PtrSize-1) != 0 {
  0x438d33		a907000000		TESTL $0x7, AX		
  0x438d38		7511			JNE 0x438d4b		
	return x
  0x438d3a		89842490000000		MOVL AX, 0x90(SP)	
  0x438d41		488b6c2460		MOVQ 0x60(SP), BP	
  0x438d46		4883c468		ADDQ $0x68, SP		
  0x438d4a		c3			RET			
  0x438d4b		8944243c		MOVL AX, 0x3c(SP)	
  0x438d4f		488b442470		MOVQ 0x70(SP), AX	
		print("invalid spdelta ", funcname(f), " ", hex(f.entry), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n")
  0x438d54		48890424		MOVQ AX, 0(SP)			
  0x438d58		488b4c2478		MOVQ 0x78(SP), CX		
  0x438d5d		48894c2408		MOVQ CX, 0x8(SP)		
  0x438d62		e899fbffff		CALL runtime.funcname(SB)	
  0x438d67		488b442418		MOVQ 0x18(SP), AX		
  0x438d6c		4889442440		MOVQ AX, 0x40(SP)		
  0x438d71		488b4c2410		MOVQ 0x10(SP), CX		
  0x438d76		48894c2458		MOVQ CX, 0x58(SP)		
  0x438d7b		488b542470		MOVQ 0x70(SP), DX		
  0x438d80		488b1a			MOVQ 0(DX), BX			
  0x438d83		48895c2450		MOVQ BX, 0x50(SP)		
  0x438d88		48635214		MOVSXD 0x14(DX), DX		
  0x438d8c		4889542448		MOVQ DX, 0x48(SP)		
  0x438d91		e86a8dfeff		CALL runtime.printlock(SB)	
  0x438d96		488d05651d0300		LEAQ 0x31d65(IP), AX		
  0x438d9d		48890424		MOVQ AX, 0(SP)			
  0x438da1		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x438daa		e89196feff		CALL runtime.printstring(SB)	
  0x438daf		488b442458		MOVQ 0x58(SP), AX		
  0x438db4		48890424		MOVQ AX, 0(SP)			
  0x438db8		488b442440		MOVQ 0x40(SP), AX		
  0x438dbd		4889442408		MOVQ AX, 0x8(SP)		
  0x438dc2		e87996feff		CALL runtime.printstring(SB)	
  0x438dc7		e8748ffeff		CALL runtime.printsp(SB)	
  0x438dcc		488b442450		MOVQ 0x50(SP), AX		
  0x438dd1		48890424		MOVQ AX, 0(SP)			
  0x438dd5		e81695feff		CALL runtime.printhex(SB)	
  0x438dda		e8618ffeff		CALL runtime.printsp(SB)	
  0x438ddf		488b842480000000	MOVQ 0x80(SP), AX		
  0x438de7		48890424		MOVQ AX, 0(SP)			
  0x438deb		e80095feff		CALL runtime.printhex(SB)	
  0x438df0		e84b8ffeff		CALL runtime.printsp(SB)	
  0x438df5		488b442448		MOVQ 0x48(SP), AX		
  0x438dfa		48890424		MOVQ AX, 0(SP)			
  0x438dfe		e8ed94feff		CALL runtime.printhex(SB)	
  0x438e03		e8388ffeff		CALL runtime.printsp(SB)	
  0x438e08		8b44243c		MOVL 0x3c(SP), AX		
  0x438e0c		4863c8			MOVSXD AX, CX			
  0x438e0f		48890c24		MOVQ CX, 0(SP)			
  0x438e13		e86894feff		CALL runtime.printint(SB)	
  0x438e18		e8738ffeff		CALL runtime.printnl(SB)	
  0x438e1d		e85e8dfeff		CALL runtime.printunlock(SB)	
  0x438e22		8b44243c		MOVL 0x3c(SP), AX		
  0x438e26		e90fffffff		JMP 0x438d3a			
func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
  0x438e2b		e840b70000		CALL runtime.morestack_noctxt(SB)	
  0x438e30		e99bfeffff		JMP runtime.funcspdelta(SB)		

TEXT runtime.pcdatavalue(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func pcdatavalue(f funcInfo, table int32, targetpc uintptr, cache *pcvalueCache) int32 {
  0x438e40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438e49		483b6110		CMPQ 0x10(CX), SP	
  0x438e4d		0f8684000000		JBE 0x438ed7		
  0x438e53		4883ec40		SUBQ $0x40, SP		
  0x438e57		48896c2438		MOVQ BP, 0x38(SP)	
  0x438e5c		488d6c2438		LEAQ 0x38(SP), BP	
  0x438e61		8b442458		MOVL 0x58(SP), AX	
	if table < 0 || table >= f.npcdata {
  0x438e65		85c0			TESTL AX, AX		
  0x438e67		7d12			JGE 0x438e7b		
		return -1
  0x438e69		c7442470ffffffff	MOVL $-0x1, 0x70(SP)	
  0x438e71		488b6c2438		MOVQ 0x38(SP), BP	
  0x438e76		4883c440		ADDQ $0x40, SP		
  0x438e7a		c3			RET			
  0x438e7b		488b4c2448		MOVQ 0x48(SP), CX	
	if table < 0 || table >= f.npcdata {
  0x438e80		8b5120			MOVL 0x20(CX), DX	
  0x438e83		39d0			CMPL DX, AX		
  0x438e85		7de2			JGE 0x438e69		
	off := *(*int32)(add(unsafe.Pointer(&f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(table)*4))
  0x438e87		488d5124		LEAQ 0x24(CX), DX	
  0x438e8b		4863c0			MOVSXD AX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x438e8e		488d448204		LEAQ 0x4(DX)(AX*4), AX	
	off := *(*int32)(add(unsafe.Pointer(&f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(table)*4))
  0x438e93		8b00			MOVL 0(AX), AX		
	return pcvalue(f, off, targetpc, cache, true)
  0x438e95		48890c24		MOVQ CX, 0(SP)			
  0x438e99		488b4c2450		MOVQ 0x50(SP), CX		
  0x438e9e		48894c2408		MOVQ CX, 0x8(SP)		
  0x438ea3		89442410		MOVL AX, 0x10(SP)		
  0x438ea7		488b442460		MOVQ 0x60(SP), AX		
  0x438eac		4889442418		MOVQ AX, 0x18(SP)		
  0x438eb1		488b442468		MOVQ 0x68(SP), AX		
  0x438eb6		4889442420		MOVQ AX, 0x20(SP)		
  0x438ebb		c644242801		MOVB $0x1, 0x28(SP)		
  0x438ec0		e88bf4ffff		CALL runtime.pcvalue(SB)	
  0x438ec5		8b442430		MOVL 0x30(SP), AX		
  0x438ec9		89442470		MOVL AX, 0x70(SP)		
  0x438ecd		488b6c2438		MOVQ 0x38(SP), BP		
  0x438ed2		4883c440		ADDQ $0x40, SP			
  0x438ed6		c3			RET				
func pcdatavalue(f funcInfo, table int32, targetpc uintptr, cache *pcvalueCache) int32 {
  0x438ed7		e894b60000		CALL runtime.morestack_noctxt(SB)	
  0x438edc		e95fffffff		JMP runtime.pcdatavalue(SB)		

TEXT runtime.funcdata(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func funcdata(f funcInfo, i int32) unsafe.Pointer {
  0x438ef0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438ef9		483b6110		CMPQ 0x10(CX), SP	
  0x438efd		0f86bc000000		JBE 0x438fbf		
  0x438f03		4883ec20		SUBQ $0x20, SP		
  0x438f07		48896c2418		MOVQ BP, 0x18(SP)	
  0x438f0c		488d6c2418		LEAQ 0x18(SP), BP	
  0x438f11		8b442438		MOVL 0x38(SP), AX	
	if i < 0 || i >= f.nfuncdata {
  0x438f15		85c0			TESTL AX, AX		
  0x438f17		7d13			JGE 0x438f2c		
		return nil
  0x438f19		48c744244000000000	MOVQ $0x0, 0x40(SP)	
  0x438f22		488b6c2418		MOVQ 0x18(SP), BP	
  0x438f27		4883c420		ADDQ $0x20, SP		
  0x438f2b		c3			RET			
  0x438f2c		488b4c2428		MOVQ 0x28(SP), CX	
	if i < 0 || i >= f.nfuncdata {
  0x438f31		8b5124			MOVL 0x24(CX), DX	
  0x438f34		488d5924		LEAQ 0x24(CX), BX	
  0x438f38		39d0			CMPL DX, AX		
  0x438f3a		7ddd			JGE 0x438f19		
	p := add(unsafe.Pointer(&f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(f.npcdata)*4)
  0x438f3c		48635120		MOVSXD 0x20(CX), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x438f40		488d549304		LEAQ 0x4(BX)(DX*4), DX	
  0x438f45		4889d3			MOVQ DX, BX		
	if sys.PtrSize == 8 && uintptr(p)&4 != 0 {
  0x438f48		0fbae302		BTL $0x2, BX		
  0x438f4c		736c			JAE 0x438fba		
		if uintptr(unsafe.Pointer(f._func))&4 != 0 {
  0x438f4e		0fbae102		BTL $0x2, CX		
  0x438f52		7220			JB 0x438f74		
	return unsafe.Pointer(uintptr(p) + x)
  0x438f54		488d4a04		LEAQ 0x4(DX), CX	
	return *(*unsafe.Pointer)(add(p, uintptr(i)*sys.PtrSize))
  0x438f58		4863c0			MOVSXD AX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x438f5b		488d14c1		LEAQ 0(CX)(AX*8), DX	
	return *(*unsafe.Pointer)(add(p, uintptr(i)*sys.PtrSize))
  0x438f5f		8402			TESTB AL, 0(DX)		
  0x438f61		488b04c1		MOVQ 0(CX)(AX*8), AX	
  0x438f65		4889442440		MOVQ AX, 0x40(SP)	
  0x438f6a		488b6c2418		MOVQ 0x18(SP), BP	
  0x438f6f		4883c420		ADDQ $0x20, SP		
  0x438f73		c3			RET			
  0x438f74		4889542410		MOVQ DX, 0x10(SP)	
			println("runtime: misaligned func", f._func)
  0x438f79		e8828bfeff		CALL runtime.printlock(SB)	
  0x438f7e		488d05582b0300		LEAQ 0x32b58(IP), AX		
  0x438f85		48890424		MOVQ AX, 0(SP)			
  0x438f89		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x438f92		e8a994feff		CALL runtime.printstring(SB)	
  0x438f97		488b442428		MOVQ 0x28(SP), AX		
  0x438f9c		48890424		MOVQ AX, 0(SP)			
  0x438fa0		e85b94feff		CALL runtime.printpointer(SB)	
  0x438fa5		e8e68dfeff		CALL runtime.printnl(SB)	
  0x438faa		e8d18bfeff		CALL runtime.printunlock(SB)	
  0x438faf		8b442438		MOVL 0x38(SP), AX		
  0x438fb3		488b542410		MOVQ 0x10(SP), DX		
  0x438fb8		eb9a			JMP 0x438f54			
  0x438fba		4889d1			MOVQ DX, CX			
	if sys.PtrSize == 8 && uintptr(p)&4 != 0 {
  0x438fbd		eb99			JMP 0x438f58		
func funcdata(f funcInfo, i int32) unsafe.Pointer {
  0x438fbf		e8acb50000		CALL runtime.morestack_noctxt(SB)	
  0x438fc4		e927ffffff		JMP runtime.funcdata(SB)		

TEXT runtime.step(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {
  0x438fd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438fd9		483b6110		CMPQ 0x10(CX), SP	
  0x438fdd		0f86a2010000		JBE 0x439185		
  0x438fe3		4883ec38		SUBQ $0x38, SP		
  0x438fe7		48896c2430		MOVQ BP, 0x30(SP)	
  0x438fec		488d6c2430		LEAQ 0x30(SP), BP	
  0x438ff1		488b442448		MOVQ 0x48(SP), AX	
	uvdelta := uint32(p[0])
  0x438ff6		4885c0			TESTQ AX, AX		
  0x438ff9		0f867f010000		JBE 0x43917e		
  0x438fff		488b4c2440		MOVQ 0x40(SP), CX	
  0x439004		0fb611			MOVZX 0(CX), DX		
	if uvdelta == 0 && !first {
  0x439007		85d2			TESTL DX, DX		
  0x439009		750d			JNE 0x439018		
  0x43900b		0fb65c2468		MOVZX 0x68(SP), BX	
func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {
  0x439010		84db			TESTL BL, BL		
	if uvdelta == 0 && !first {
  0x439012		0f842e010000		JE 0x439146		
	if uvdelta&0x80 != 0 {
  0x439018		0fbae207		BTL $0x7, DX		
  0x43901c		0f82f5000000		JB 0x439117		
  0x439022		bb01000000		MOVL $0x1, BX		
	p = p[n:]
  0x439027		4839c3			CMPQ AX, BX		
  0x43902a		0f8747010000		JA 0x439177		
  0x439030		4829d8			SUBQ BX, AX		
  0x439033		488b742450		MOVQ 0x50(SP), SI	
  0x439038		4829de			SUBQ BX, SI		
  0x43903b		4889f7			MOVQ SI, DI		
  0x43903e		48f7de			NEGQ SI			
  0x439041		48c1fe3f		SARQ $0x3f, SI		
  0x439045		4821f3			ANDQ SI, BX		
  0x439048		488d3419		LEAQ 0(CX)(BX*1), SI	
	if uvdelta&1 != 0 {
  0x43904c		0fbae200		BTL $0x0, DX		
  0x439050		0f83ba000000		JAE 0x439110		
		uvdelta = ^(uvdelta >> 1)
  0x439056		d1ea			SHRL $0x1, DX		
  0x439058		f7d2			NOTL DX			
	pcdelta := uint32(p[0])
  0x43905a		4885c0			TESTQ AX, AX		
  0x43905d		0f860d010000		JBE 0x439170		
  0x439063		0fb60c19		MOVZX 0(CX)(BX*1), CX	
	if pcdelta&0x80 != 0 {
  0x439067		0fbae107		BTL $0x7, CX		
  0x43906b		725d			JB 0x4390ca		
  0x43906d		bb01000000		MOVL $0x1, BX		
	p = p[n:]
  0x439072		4839c3			CMPQ AX, BX		
  0x439075		0f87ee000000		JA 0x439169		
  0x43907b		4c8b442458		MOVQ 0x58(SP), R8	
	*pc += uintptr(pcdelta * sys.PCQuantum)
  0x439080		490308			ADDQ 0(R8), CX		
  0x439083		498908			MOVQ CX, 0(R8)		
  0x439086		488b4c2460		MOVQ 0x60(SP), CX	
	*val += vdelta
  0x43908b		0311			ADDL 0(CX), DX		
  0x43908d		8911			MOVL DX, 0(CX)		
	p = p[n:]
  0x43908f		4829df			SUBQ BX, DI		
  0x439092		4889f9			MOVQ DI, CX		
  0x439095		48f7df			NEGQ DI			
  0x439098		48c1ff3f		SARQ $0x3f, DI		
  0x43909c		4821df			ANDQ BX, DI		
  0x43909f		488d143e		LEAQ 0(SI)(DI*1), DX	
	return p, true
  0x4390a3		4889542470		MOVQ DX, 0x70(SP)	
	p = p[n:]
  0x4390a8		4829d8			SUBQ BX, AX		
	return p, true
  0x4390ab		4889442478		MOVQ AX, 0x78(SP)	
  0x4390b0		48898c2480000000	MOVQ CX, 0x80(SP)	
  0x4390b8		c684248800000001	MOVB $0x1, 0x88(SP)	
  0x4390c0		488b6c2430		MOVQ 0x30(SP), BP	
  0x4390c5		4883c438		ADDQ $0x38, SP		
  0x4390c9		c3			RET			
  0x4390ca		4889442448		MOVQ AX, 0x48(SP)	
  0x4390cf		48897c2428		MOVQ DI, 0x28(SP)	
  0x4390d4		4889742440		MOVQ SI, 0x40(SP)	
  0x4390d9		89542424		MOVL DX, 0x24(SP)	
		n, pcdelta = readvarint(p)
  0x4390dd		48893424		MOVQ SI, 0(SP)			
  0x4390e1		4889442408		MOVQ AX, 0x8(SP)		
  0x4390e6		48897c2410		MOVQ DI, 0x10(SP)		
  0x4390eb		e8a0000000		CALL runtime.readvarint(SB)	
  0x4390f0		8b5c2418		MOVL 0x18(SP), BX		
  0x4390f4		8b4c241c		MOVL 0x1c(SP), CX		
  0x4390f8		488b442448		MOVQ 0x48(SP), AX		
  0x4390fd		8b542424		MOVL 0x24(SP), DX		
  0x439101		488b742440		MOVQ 0x40(SP), SI		
  0x439106		488b7c2428		MOVQ 0x28(SP), DI		
  0x43910b		e962ffffff		JMP 0x439072			
		uvdelta >>= 1
  0x439110		d1ea			SHRL $0x1, DX		
  0x439112		e943ffffff		JMP 0x43905a		
		n, uvdelta = readvarint(p)
  0x439117		48890c24		MOVQ CX, 0(SP)			
  0x43911b		4889442408		MOVQ AX, 0x8(SP)		
  0x439120		488b542450		MOVQ 0x50(SP), DX		
  0x439125		4889542410		MOVQ DX, 0x10(SP)		
  0x43912a		e861000000		CALL runtime.readvarint(SB)	
  0x43912f		8b5c2418		MOVL 0x18(SP), BX		
  0x439133		8b54241c		MOVL 0x1c(SP), DX		
  0x439137		488b442448		MOVQ 0x48(SP), AX		
  0x43913c		488b4c2440		MOVQ 0x40(SP), CX		
  0x439141		e9e1feffff		JMP 0x439027			
		return nil, false
  0x439146		48c744247000000000	MOVQ $0x0, 0x70(SP)	
  0x43914f		0f57c0			XORPS X0, X0		
  0x439152		0f11442478		MOVUPS X0, 0x78(SP)	
  0x439157		c684248800000000	MOVB $0x0, 0x88(SP)	
  0x43915f		488b6c2430		MOVQ 0x30(SP), BP	
  0x439164		4883c438		ADDQ $0x38, SP		
  0x439168		c3			RET			
	p = p[n:]
  0x439169		e84269feff		CALL runtime.panicslice(SB)	
  0x43916e		0f0b			UD2				
	pcdelta := uint32(p[0])
  0x439170		e8cb68feff		CALL runtime.panicindex(SB)	
  0x439175		0f0b			UD2				
	p = p[n:]
  0x439177		e83469feff		CALL runtime.panicslice(SB)	
  0x43917c		0f0b			UD2				
	uvdelta := uint32(p[0])
  0x43917e		e8bd68feff		CALL runtime.panicindex(SB)	
  0x439183		0f0b			UD2				
func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {
  0x439185		e8e6b30000		CALL runtime.morestack_noctxt(SB)	
  0x43918a		e941feffff		JMP runtime.step(SB)			

TEXT runtime.readvarint(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func readvarint(p []byte) (read uint32, val uint32) {
  0x439190		4883ec08		SUBQ $0x8, SP		
  0x439194		48892c24		MOVQ BP, 0(SP)		
  0x439198		488d2c24		LEAQ 0(SP), BP		
  0x43919c		488b442410		MOVQ 0x10(SP), AX	
  0x4391a1		488b542418		MOVQ 0x18(SP), DX	
  0x4391a6		31c9			XORL CX, CX		
  0x4391a8		89cb			MOVL CX, BX		
  0x4391aa		89de			MOVL BX, SI		
	for {
  0x4391ac		eb06			JMP 0x4391b4		
		shift += 7
  0x4391ae		8d7107			LEAL 0x7(CX), SI	
  0x4391b1		4489c1			MOVL R8, CX		
		b := p[n]
  0x4391b4		4839d1			CMPQ DX, CX		
  0x4391b7		732c			JAE 0x4391e5		
  0x4391b9		0fb63c08		MOVZX 0(AX)(CX*1), DI	
		n++
  0x4391bd		448d4101		LEAL 0x1(CX), R8	
  0x4391c1		4189f9			MOVL DI, R9		
		v |= uint32(b&0x7F) << (shift & 31)
  0x4391c4		83e77f			ANDL $0x7f, DI		
  0x4391c7		89f1			MOVL SI, CX		
  0x4391c9		d3e7			SHLL CL, DI		
  0x4391cb		09fb			ORL DI, BX		
		if b&0x80 == 0 {
  0x4391cd		41f6c180		TESTL $0x80, R9		
  0x4391d1		75db			JNE 0x4391ae		
	return n, v
  0x4391d3		4489442428		MOVL R8, 0x28(SP)	
  0x4391d8		895c242c		MOVL BX, 0x2c(SP)	
  0x4391dc		488b2c24		MOVQ 0(SP), BP		
  0x4391e0		4883c408		ADDQ $0x8, SP		
  0x4391e4		c3			RET			
		b := p[n]
  0x4391e5		e85668feff		CALL runtime.panicindex(SB)	
  0x4391ea		0f0b			UD2				

TEXT runtime.stackmapdata(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/symtab.go
func stackmapdata(stkmap *stackmap, n int32) bitvector {
  0x4391f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4391f9		483b6110		CMPQ 0x10(CX), SP	
  0x4391fd		7663			JBE 0x439262		
  0x4391ff		4883ec18		SUBQ $0x18, SP		
  0x439203		48896c2410		MOVQ BP, 0x10(SP)	
  0x439208		488d6c2410		LEAQ 0x10(SP), BP	
  0x43920d		8b442428		MOVL 0x28(SP), AX	
	if n < 0 || n >= stkmap.n {
  0x439211		85c0			TESTL AX, AX		
  0x439213		7c32			JL 0x439247		
  0x439215		488b4c2420		MOVQ 0x20(SP), CX	
  0x43921a		8b11			MOVL 0(CX), DX		
  0x43921c		39d0			CMPL DX, AX		
  0x43921e		7d27			JGE 0x439247		
	return bitvector{stkmap.nbit, (*byte)(add(unsafe.Pointer(&stkmap.bytedata), uintptr(n*((stkmap.nbit+7)>>3))))}
  0x439220		8b5104			MOVL 0x4(CX), DX	
  0x439223		89542430		MOVL DX, 0x30(SP)	
  0x439227		83c207			ADDL $0x7, DX		
  0x43922a		c1fa03			SARL $0x3, DX		
  0x43922d		0fafc2			IMULL DX, AX		
  0x439230		4863c0			MOVSXD AX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x439233		488d440108		LEAQ 0x8(CX)(AX*1), AX	
	return bitvector{stkmap.nbit, (*byte)(add(unsafe.Pointer(&stkmap.bytedata), uintptr(n*((stkmap.nbit+7)>>3))))}
  0x439238		4889442438		MOVQ AX, 0x38(SP)	
  0x43923d		488b6c2410		MOVQ 0x10(SP), BP	
  0x439242		4883c418		ADDQ $0x18, SP		
  0x439246		c3			RET			
		throw("stackmapdata: index out of range")
  0x439247		488d05d5360300		LEAQ 0x336d5(IP), AX	
  0x43924e		48890424		MOVQ AX, 0(SP)		
  0x439252		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x43925b		e8707ffeff		CALL runtime.throw(SB)	
  0x439260		0f0b			UD2			
func stackmapdata(stkmap *stackmap, n int32) bitvector {
  0x439262		e809b30000		CALL runtime.morestack_noctxt(SB)	
  0x439267		eb87			JMP runtime.stackmapdata(SB)		

TEXT runtime.timejump(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/time.go
func timejump() *g {
  0x439270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439279		483b6110		CMPQ 0x10(CX), SP	
  0x43927d		0f86b2000000		JBE 0x439335		
  0x439283		4883ec28		SUBQ $0x28, SP		
  0x439287		48896c2420		MOVQ BP, 0x20(SP)	
  0x43928c		488d6c2420		LEAQ 0x20(SP), BP	
	if faketime == 0 {
  0x439291		488b05c8a60800		MOVQ runtime.faketime(SB), AX	
  0x439298		4885c0			TESTQ AX, AX			
  0x43929b		0f8481000000		JE 0x439322			
  0x4392a1		31c0			XORL AX, AX			
	for i := range timers {
  0x4392a3		eb25			JMP 0x4392ca		
  0x4392a5		4889442410		MOVQ AX, 0x10(SP)	
		lock(&timers[i].lock)
  0x4392aa		48c1e007		SHLQ $0x7, AX			
  0x4392ae		488d15eb0f0700		LEAQ runtime.timers(SB), DX	
  0x4392b5		488d0410		LEAQ 0(AX)(DX*1), AX		
  0x4392b9		48890424		MOVQ AX, 0(SP)			
  0x4392bd		e85e02fdff		CALL runtime.lock(SB)		
  0x4392c2		488b442410		MOVQ 0x10(SP), AX		
	for i := range timers {
  0x4392c7		48ffc0			INCQ AX			
  0x4392ca		4883f840		CMPQ $0x40, AX		
  0x4392ce		7cd5			JL 0x4392a5		
	gp := timejumpLocked()
  0x4392d0		e86b000000		CALL runtime.timejumpLocked(SB)	
  0x4392d5		488b0424		MOVQ 0(SP), AX			
  0x4392d9		4889442418		MOVQ AX, 0x18(SP)		
  0x4392de		31c9			XORL CX, CX			
	for i := range timers {
  0x4392e0		eb2b			JMP 0x43930d		
  0x4392e2		48894c2408		MOVQ CX, 0x8(SP)	
		unlock(&timers[i].lock)
  0x4392e7		48c1e107		SHLQ $0x7, CX			
  0x4392eb		488d15ae0f0700		LEAQ runtime.timers(SB), DX	
  0x4392f2		488d0c11		LEAQ 0(CX)(DX*1), CX		
  0x4392f6		48890c24		MOVQ CX, 0(SP)			
  0x4392fa		e8c103fdff		CALL runtime.unlock(SB)		
  0x4392ff		488b442408		MOVQ 0x8(SP), AX		
	for i := range timers {
  0x439304		488d4801		LEAQ 0x1(AX), CX	
  0x439308		488b442418		MOVQ 0x18(SP), AX	
  0x43930d		4883f940		CMPQ $0x40, CX		
  0x439311		7ccf			JL 0x4392e2		
	return gp
  0x439313		4889442430		MOVQ AX, 0x30(SP)	
  0x439318		488b6c2420		MOVQ 0x20(SP), BP	
  0x43931d		4883c428		ADDQ $0x28, SP		
  0x439321		c3			RET			
		return nil
  0x439322		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x43932b		488b6c2420		MOVQ 0x20(SP), BP	
  0x439330		4883c428		ADDQ $0x28, SP		
  0x439334		c3			RET			
func timejump() *g {
  0x439335		e836b20000		CALL runtime.morestack_noctxt(SB)	
  0x43933a		e931ffffff		JMP runtime.timejump(SB)		

TEXT runtime.timejumpLocked(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/time.go
func timejumpLocked() *g {
  0x439340		31c0			XORL AX, AX		
  0x439342		31c9			XORL CX, CX		
	for i := range timers {
  0x439344		eb04			JMP 0x43934a		
  0x439346		488d4201		LEAQ 0x1(DX), AX	
  0x43934a		4883f840		CMPQ $0x40, AX		
  0x43934e		7d46			JGE 0x439396		
  0x439350		4889c2			MOVQ AX, DX		
		tb := &timers[i]
  0x439353		48c1e007		SHLQ $0x7, AX		
		if !tb.created || len(tb.t) == 0 {
  0x439357		488d1d420f0700		LEAQ runtime.timers(SB), BX	
  0x43935e		0fb6740310		MOVZX 0x10(BX)(AX*1), SI	
  0x439363		4084f6			TESTL SI, SI			
  0x439366		74de			JE 0x439346			
  0x439368		488b740330		MOVQ 0x30(BX)(AX*1), SI		
  0x43936d		488b440328		MOVQ 0x28(BX)(AX*1), AX		
  0x439372		4885f6			TESTQ SI, SI			
  0x439375		74cf			JE 0x439346			
		t := tb.t[0]
  0x439377		488b00			MOVQ 0(AX), AX		
		if minT == nil || t.when < minT.when {
  0x43937a		4885c9			TESTQ CX, CX		
  0x43937d		740d			JE 0x43938c		
  0x43937f		488b7010		MOVQ 0x10(AX), SI	
  0x439383		488b7910		MOVQ 0x10(CX), DI	
  0x439387		4839fe			CMPQ DI, SI		
  0x43938a		7d05			JGE 0x439391		
  0x43938c		4889c1			MOVQ AX, CX		
	for i := range timers {
  0x43938f		ebb5			JMP 0x439346		
  0x439391		4889c8			MOVQ CX, AX		
		if minT == nil || t.when < minT.when {
  0x439394		ebf6			JMP 0x43938c		
	if minT == nil || minT.when <= faketime {
  0x439396		4885c9			TESTQ CX, CX			
  0x439399		7410			JE 0x4393ab			
  0x43939b		488b4110		MOVQ 0x10(CX), AX		
  0x43939f		488b15baa50800		MOVQ runtime.faketime(SB), DX	
  0x4393a6		4839d0			CMPQ DX, AX			
  0x4393a9		7f0a			JG 0x4393b5			
		return nil
  0x4393ab		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x4393b4		c3			RET			
	faketime = minT.when
  0x4393b5		488905a4a50800		MOVQ AX, runtime.faketime(SB)	
	tb := minT.tb
  0x4393bc		488b01			MOVQ 0(CX), AX		
	if !tb.rescheduling {
  0x4393bf		0fb64812		MOVZX 0x12(AX), CX	
  0x4393c3		84c9			TESTL CL, CL		
  0x4393c5		740e			JE 0x4393d5		
	tb.rescheduling = false
  0x4393c7		c6401200		MOVB $0x0, 0x12(AX)	
	return tb.gp
  0x4393cb		488b4008		MOVQ 0x8(AX), AX	
  0x4393cf		4889442408		MOVQ AX, 0x8(SP)	
  0x4393d4		c3			RET			
		return nil
  0x4393d5		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x4393de		c3			RET			

TEXT time.now(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/timestub.go
func time_now() (sec int64, nsec int32, mono int64) {
  0x4393e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4393e9		483b6110		CMPQ 0x10(CX), SP	
  0x4393ed		7655			JBE 0x439444		
  0x4393ef		4883ec28		SUBQ $0x28, SP		
  0x4393f3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4393f8		488d6c2420		LEAQ 0x20(SP), BP	
	sec, nsec = walltime()
  0x4393fd		e89ee50000		CALL runtime.walltime(SB)	
  0x439402		488b0424		MOVQ 0(SP), AX			
  0x439406		4889442418		MOVQ AX, 0x18(SP)		
  0x43940b		8b4c2408		MOVL 0x8(SP), CX		
  0x43940f		894c2414		MOVL CX, 0x14(SP)		
	return sec, nsec, nanotime() - startNano
  0x439413		e818e60000		CALL runtime.nanotime(SB)	
  0x439418		488b0424		MOVQ 0(SP), AX			
  0x43941c		482b05b5a50800		SUBQ runtime.startNano(SB), AX	
  0x439423		488b4c2418		MOVQ 0x18(SP), CX		
  0x439428		48894c2430		MOVQ CX, 0x30(SP)		
  0x43942d		8b4c2414		MOVL 0x14(SP), CX		
  0x439431		894c2438		MOVL CX, 0x38(SP)		
  0x439435		4889442440		MOVQ AX, 0x40(SP)		
  0x43943a		488b6c2420		MOVQ 0x20(SP), BP		
  0x43943f		4883c428		ADDQ $0x28, SP			
  0x439443		c3			RET				
func time_now() (sec int64, nsec int32, mono int64) {
  0x439444		e827b10000		CALL runtime.morestack_noctxt(SB)	
  0x439449		eb95			JMP time.now(SB)			

TEXT runtime.traceReader(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceReader() *g {
  0x439450		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439459		483b6110		CMPQ 0x10(CX), SP	
  0x43945d		0f86d5000000		JBE 0x439538		
  0x439463		4883ec18		SUBQ $0x18, SP		
  0x439467		48896c2410		MOVQ BP, 0x10(SP)	
  0x43946c		488d6c2410		LEAQ 0x10(SP), BP	
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x439471		488b05b0a30700		MOVQ runtime.trace+104(SB), AX	
  0x439478		4885c0			TESTQ AX, AX			
  0x43947b		7513			JNE 0x439490			
		return nil
  0x43947d		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x439486		488b6c2410		MOVQ 0x10(SP), BP	
  0x43948b		4883c418		ADDQ $0x18, SP		
  0x43948f		c3			RET			
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x439490		488b0581a30700		MOVQ runtime.trace+88(SB), AX	
  0x439497		4885c0			TESTQ AX, AX			
  0x43949a		750b			JNE 0x4394a7			
  0x43949c		0fb6052ea30700		MOVZX runtime.trace+17(SB), AX	
  0x4394a3		84c0			TESTL AL, AL			
  0x4394a5		74d6			JE 0x43947d			
	lock(&trace.lock)
  0x4394a7		488d0512a30700		LEAQ runtime.trace(SB), AX	
  0x4394ae		48890424		MOVQ AX, 0(SP)			
  0x4394b2		e86900fdff		CALL runtime.lock(SB)		
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x4394b7		488b056aa30700		MOVQ runtime.trace+104(SB), AX	
  0x4394be		4885c0			TESTQ AX, AX			
  0x4394c1		7523			JNE 0x4394e6			
		unlock(&trace.lock)
  0x4394c3		488d05f6a20700		LEAQ runtime.trace(SB), AX	
  0x4394ca		48890424		MOVQ AX, 0(SP)			
  0x4394ce		e8ed01fdff		CALL runtime.unlock(SB)		
		return nil
  0x4394d3		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x4394dc		488b6c2410		MOVQ 0x10(SP), BP	
  0x4394e1		4883c418		ADDQ $0x18, SP		
  0x4394e5		c3			RET			
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x4394e6		488b0d2ba30700		MOVQ runtime.trace+88(SB), CX	
  0x4394ed		4885c9			TESTQ CX, CX			
  0x4394f0		750b			JNE 0x4394fd			
  0x4394f2		0fb60dd8a20700		MOVZX runtime.trace+17(SB), CX	
  0x4394f9		84c9			TESTL CL, CL			
  0x4394fb		74c6			JE 0x4394c3			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4394fd		488d0d24a30700		LEAQ runtime.trace+104(SB), CX	
  0x439504		8401			TESTB AL, 0(CX)			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x439506		4889442408		MOVQ AX, 0x8(SP)	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x43950b		31c9			XORL CX, CX			
  0x43950d		48890d14a30700		MOVQ CX, runtime.trace+104(SB)	
	unlock(&trace.lock)
  0x439514		488d0da5a20700		LEAQ runtime.trace(SB), CX	
  0x43951b		48890c24		MOVQ CX, 0(SP)			
  0x43951f		e89c01fdff		CALL runtime.unlock(SB)		
	return gp
  0x439524		488b442408		MOVQ 0x8(SP), AX	
  0x439529		4889442420		MOVQ AX, 0x20(SP)	
  0x43952e		488b6c2410		MOVQ 0x10(SP), BP	
  0x439533		4883c418		ADDQ $0x18, SP		
  0x439537		c3			RET			
func traceReader() *g {
  0x439538		e833b00000		CALL runtime.morestack_noctxt(SB)	
  0x43953d		e90effffff		JMP runtime.traceReader(SB)		

TEXT runtime.traceProcFree(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceProcFree(pp *p) {
  0x439550		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439559		483b6110		CMPQ 0x10(CX), SP	
  0x43955d		0f869a000000		JBE 0x4395fd		
  0x439563		4883ec18		SUBQ $0x18, SP		
  0x439567		48896c2410		MOVQ BP, 0x10(SP)	
  0x43956c		488d6c2410		LEAQ 0x10(SP), BP	
  0x439571		488b442420		MOVQ 0x20(SP), AX	
	buf := pp.tracebuf
  0x439576		8400			TESTB AL, 0(AX)		
  0x439578		488b8818120000		MOVQ 0x1218(AX), CX	
	pp.tracebuf = 0
  0x43957f		48c7801812000000000000	MOVQ $0x0, 0x1218(AX)	
	if buf == 0 {
  0x43958a		4885c9			TESTQ CX, CX		
  0x43958d		7464			JE 0x4395f3		
  0x43958f		48894c2408		MOVQ CX, 0x8(SP)	
	lock(&trace.lock)
  0x439594		488d0525a20700		LEAQ runtime.trace(SB), AX	
  0x43959b		48890424		MOVQ AX, 0(SP)			
  0x43959f		e87cfffcff		CALL runtime.lock(SB)		
  0x4395a4		488b442408		MOVQ 0x8(SP), AX		
  0x4395a9		4889c1			MOVQ AX, CX			
	buf.ptr().link = 0
  0x4395ac		48c70000000000		MOVQ $0x0, 0(AX)	
	if trace.fullHead == 0 {
  0x4395b3		488b055ea20700		MOVQ runtime.trace+88(SB), AX	
  0x4395ba		4885c0			TESTQ AX, AX			
  0x4395bd		7528			JNE 0x4395e7			
		trace.fullHead = buf
  0x4395bf		48890d52a20700		MOVQ CX, runtime.trace+88(SB)	
	trace.fullTail = buf
  0x4395c6		48890d53a20700		MOVQ CX, runtime.trace+96(SB)	
	unlock(&trace.lock)
  0x4395cd		488d05eca10700		LEAQ runtime.trace(SB), AX	
  0x4395d4		48890424		MOVQ AX, 0(SP)			
  0x4395d8		e8e300fdff		CALL runtime.unlock(SB)		
}
  0x4395dd		488b6c2410		MOVQ 0x10(SP), BP	
  0x4395e2		4883c418		ADDQ $0x18, SP		
  0x4395e6		c3			RET			
		trace.fullTail.ptr().link = buf
  0x4395e7		488b0532a20700		MOVQ runtime.trace+96(SB), AX	
  0x4395ee		488908			MOVQ CX, 0(AX)			
  0x4395f1		ebd3			JMP 0x4395c6			
		return
  0x4395f3		488b6c2410		MOVQ 0x10(SP), BP	
  0x4395f8		4883c418		ADDQ $0x18, SP		
  0x4395fc		c3			RET			
func traceProcFree(pp *p) {
  0x4395fd		e86eaf0000		CALL runtime.morestack_noctxt(SB)	
  0x439602		e949ffffff		JMP runtime.traceProcFree(SB)		

TEXT runtime.traceEvent(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceEvent(ev byte, skip int, args ...uint64) {
  0x439610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439619		483b6110		CMPQ 0x10(CX), SP	
  0x43961d		0f86ba020000		JBE 0x4398dd		
  0x439623		4883ec78		SUBQ $0x78, SP		
  0x439627		48896c2470		MOVQ BP, 0x70(SP)	
  0x43962c		488d6c2470		LEAQ 0x70(SP), BP	
	mp, pid, bufp := traceAcquireBuffer()
  0x439631		e8fa030000		CALL runtime.traceAcquireBuffer(SB)	
  0x439636		488b0424		MOVQ 0(SP), AX				
  0x43963a		8b4c2408		MOVL 0x8(SP), CX			
  0x43963e		488b542410		MOVQ 0x10(SP), DX			
	if !trace.enabled && !mp.startingtrace {
  0x439643		0fb61d86a10700		MOVZX runtime.trace+16(SB), BX	
  0x43964a		84db			TESTL BL, BL			
  0x43964c		0f8441020000		JE 0x439893			
  0x439652		4889442458		MOVQ AX, 0x58(SP)		
  0x439657		894c2434		MOVL CX, 0x34(SP)		
  0x43965b		4889542450		MOVQ DX, 0x50(SP)		
	buf := (*bufp).ptr()
  0x439660		488b1a			MOVQ 0(DX), BX		
  0x439663		4889de			MOVQ BX, SI		
	if buf == nil || len(buf.arr)-buf.pos < maxSize {
  0x439666		4885db			TESTQ BX, BX		
  0x439669		7418			JE 0x439683		
  0x43966b		488b7b10		MOVQ 0x10(BX), DI	
  0x43966f		4881c71804ffff		ADDQ $-0xfbe8, DI	
  0x439676		48f7df			NEGQ DI			
  0x439679		4883ff34		CMPQ $0x34, DI		
  0x43967d		0f8d08020000		JGE 0x43988b		
		buf = traceFlush(traceBufPtrOf(buf), pid).ptr()
  0x439683		48893424		MOVQ SI, 0(SP)			
  0x439687		e8d4040000		CALL runtime.traceFlush(SB)	
  0x43968c		488b442410		MOVQ 0x10(SP), AX		
  0x439691		4889c1			MOVQ AX, CX			
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x439694		488b542450		MOVQ 0x50(SP), DX	
func (tp *traceBufPtr) set(b *traceBuf) { *tp = traceBufPtr(unsafe.Pointer(b)) }
  0x439699		48890a			MOVQ CX, 0(DX)		
	ticks := uint64(cputicks()) / traceTickDiv
  0x43969c		4889442468		MOVQ AX, 0x68(SP)		
  0x4396a1		e84ac60000		CALL runtime.cputicks(SB)	
  0x4396a6		488b0424		MOVQ 0(SP), AX			
  0x4396aa		48c1e806		SHRQ $0x6, AX			
  0x4396ae		488b4c2468		MOVQ 0x68(SP), CX		
	tickDiff := ticks - buf.lastTicks
  0x4396b3		488b5108		MOVQ 0x8(CX), DX	
	buf.lastTicks = ticks
  0x4396b7		48894108		MOVQ AX, 0x8(CX)	
	tickDiff := ticks - buf.lastTicks
  0x4396bb		4829d0			SUBQ DX, AX		
  0x4396be		488b942488000000	MOVQ 0x88(SP), DX	
	if skip >= 0 {
  0x4396c6		4885d2			TESTQ DX, DX		
  0x4396c9		0f8cac010000		JL 0x43987b		
  0x4396cf		488b9c2498000000	MOVQ 0x98(SP), BX	
		narg++
  0x4396d7		8d7301			LEAL 0x1(BX), SI	
	if narg > 3 {
  0x4396da		4080fe03		CMPL $0x3, SI		
  0x4396de		7605			JBE 0x4396e5		
  0x4396e0		be03000000		MOVL $0x3, SI		
	startPos := buf.pos
  0x4396e5		488b7910		MOVQ 0x10(CX), DI	
  0x4396e9		4189f0			MOVL SI, R8		
	buf.byte(ev | narg<<traceArgCountShift)
  0x4396ec		c1e606			SHLL $0x6, SI		
  0x4396ef		440fb68c2480000000	MOVZX 0x80(SP), R9	
  0x4396f8		4109f1			ORL SI, R9		
	buf.arr[buf.pos] = v
  0x4396fb		4881ffe8fb0000		CMPQ $0xfbe8, DI		
  0x439702		0f83ce010000		JAE 0x4398d6			
  0x439708		48897c2440		MOVQ DI, 0x40(SP)		
  0x43970d		44888c3918040000	MOVB R9, 0x418(CX)(DI*1)	
	buf.pos++
  0x439715		48ff4110		INCQ 0x10(CX)		
	if narg == 3 {
  0x439719		4180f803		CMPL $0x3, R8		
  0x43971d		0f8414010000		JE 0x439837		
  0x439723		31f6			XORL SI, SI		
  0x439725		4889742460		MOVQ SI, 0x60(SP)	
	buf.varint(tickDiff)
  0x43972a		48890c24		MOVQ CX, 0(SP)				
  0x43972e		4889442408		MOVQ AX, 0x8(SP)			
  0x439733		e808060000		CALL runtime.(*traceBuf).varint(SB)	
  0x439738		31c0			XORL AX, AX				
	for _, a := range args {
  0x43973a		eb2c			JMP 0x439768		
  0x43973c		4889442448		MOVQ AX, 0x48(SP)	
  0x439741		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x439749		488b14c1		MOVQ 0(CX)(AX*8), DX	
  0x43974d		488b5c2468		MOVQ 0x68(SP), BX	
		buf.varint(a)
  0x439752		48891c24		MOVQ BX, 0(SP)				
  0x439756		4889542408		MOVQ DX, 0x8(SP)			
  0x43975b		e8e0050000		CALL runtime.(*traceBuf).varint(SB)	
  0x439760		488b442448		MOVQ 0x48(SP), AX			
	for _, a := range args {
  0x439765		48ffc0			INCQ AX			
  0x439768		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x439770		4839c8			CMPQ CX, AX		
  0x439773		7cc7			JL 0x43973c		
  0x439775		488b842488000000	MOVQ 0x88(SP), AX	
	if skip >= 0 {
  0x43977d		4885c0			TESTQ AX, AX		
	if skip == 0 {
  0x439780		0f8495000000		JE 0x43981b		
	} else if skip > 0 {
  0x439786		7f41			JG 0x4397c9		
  0x439788		488b442468		MOVQ 0x68(SP), AX	
	evSize := buf.pos - startPos
  0x43978d		488b4010		MOVQ 0x10(AX), AX	
  0x439791		488b4c2440		MOVQ 0x40(SP), CX	
  0x439796		4829c8			SUBQ CX, AX		
	if evSize > maxSize {
  0x439799		4883f834		CMPQ $0x34, AX		
  0x43979d		0f8f11010000		JG 0x4398b4		
  0x4397a3		488b4c2460		MOVQ 0x60(SP), CX	
	if lenp != nil {
  0x4397a8		4885c9			TESTQ CX, CX		
  0x4397ab		7406			JE 0x4397b3		
		*lenp = byte(evSize - 2)
  0x4397ad		4883c0fe		ADDQ $-0x2, AX		
  0x4397b1		8801			MOVB AL, 0(CX)		
  0x4397b3		8b442434		MOVL 0x34(SP), AX	
	traceReleaseBuffer(pid)
  0x4397b7		890424			MOVL AX, 0(SP)				
  0x4397ba		e821030000		CALL runtime.traceReleaseBuffer(SB)	
}
  0x4397bf		488b6c2470		MOVQ 0x70(SP), BP	
  0x4397c4		4883c478		ADDQ $0x78, SP		
  0x4397c8		c3			RET			
  0x4397c9		488b4c2468		MOVQ 0x68(SP), CX	
		buf.varint(traceStackID(mp, buf.stk[:], skip))
  0x4397ce		488d5118		LEAQ 0x18(CX), DX			
  0x4397d2		8402			TESTB AL, 0(DX)				
  0x4397d4		488b5c2458		MOVQ 0x58(SP), BX			
  0x4397d9		48891c24		MOVQ BX, 0(SP)				
  0x4397dd		4889542408		MOVQ DX, 0x8(SP)			
  0x4397e2		48c744241080000000	MOVQ $0x80, 0x10(SP)			
  0x4397eb		48c744241880000000	MOVQ $0x80, 0x18(SP)			
  0x4397f4		4889442420		MOVQ AX, 0x20(SP)			
  0x4397f9		e8f2000000		CALL runtime.traceStackID(SB)		
  0x4397fe		488b442428		MOVQ 0x28(SP), AX			
  0x439803		488b4c2468		MOVQ 0x68(SP), CX			
  0x439808		48890c24		MOVQ CX, 0(SP)				
  0x43980c		4889442408		MOVQ AX, 0x8(SP)			
  0x439811		e82a050000		CALL runtime.(*traceBuf).varint(SB)	
  0x439816		e96dffffff		JMP 0x439788				
  0x43981b		488b442468		MOVQ 0x68(SP), AX			
		buf.varint(0)
  0x439820		48890424		MOVQ AX, 0(SP)				
  0x439824		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x43982d		e80e050000		CALL runtime.(*traceBuf).varint(SB)	
  0x439832		e951ffffff		JMP 0x439788				
  0x439837		4889442438		MOVQ AX, 0x38(SP)			
		buf.varint(0)
  0x43983c		48890c24		MOVQ CX, 0(SP)				
  0x439840		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x439849		e8f2040000		CALL runtime.(*traceBuf).varint(SB)	
  0x43984e		488b442468		MOVQ 0x68(SP), AX			
		lenp = &buf.arr[buf.pos-1]
  0x439853		488b4810		MOVQ 0x10(AX), CX		
  0x439857		488d51ff		LEAQ -0x1(CX), DX		
  0x43985b		4881fae8fb0000		CMPQ $0xfbe8, DX		
  0x439862		736b			JAE 0x4398cf			
  0x439864		488db40117040000	LEAQ 0x417(CX)(AX*1), SI	
  0x43986c		488b442438		MOVQ 0x38(SP), AX		
  0x439871		488b4c2468		MOVQ 0x68(SP), CX		
  0x439876		e9aafeffff		JMP 0x439725			
  0x43987b		488b9c2498000000	MOVQ 0x98(SP), BX		
  0x439883		4889de			MOVQ BX, SI			
	if skip >= 0 {
  0x439886		e94ffeffff		JMP 0x4396da		
  0x43988b		4889d8			MOVQ BX, AX		
	if buf == nil || len(buf.arr)-buf.pos < maxSize {
  0x43988e		e909feffff		JMP 0x43969c		
	if !trace.enabled && !mp.startingtrace {
  0x439893		0fb69828030000		MOVZX 0x328(AX), BX	
  0x43989a		84db			TESTL BL, BL		
  0x43989c		0f85b0fdffff		JNE 0x439652		
		traceReleaseBuffer(pid)
  0x4398a2		890c24			MOVL CX, 0(SP)				
  0x4398a5		e836020000		CALL runtime.traceReleaseBuffer(SB)	
		return
  0x4398aa		488b6c2470		MOVQ 0x70(SP), BP	
  0x4398af		4883c478		ADDQ $0x78, SP		
  0x4398b3		c3			RET			
		throw("invalid length of trace event")
  0x4398b4		488d05dc290300		LEAQ 0x329dc(IP), AX	
  0x4398bb		48890424		MOVQ AX, 0(SP)		
  0x4398bf		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x4398c8		e80379feff		CALL runtime.throw(SB)	
  0x4398cd		0f0b			UD2			
		lenp = &buf.arr[buf.pos-1]
  0x4398cf		e86c61feff		CALL runtime.panicindex(SB)	
  0x4398d4		0f0b			UD2				
	buf.arr[buf.pos] = v
  0x4398d6		e86561feff		CALL runtime.panicindex(SB)	
  0x4398db		0f0b			UD2				
func traceEvent(ev byte, skip int, args ...uint64) {
  0x4398dd		e88eac0000		CALL runtime.morestack_noctxt(SB)	
  0x4398e2		e929fdffff		JMP runtime.traceEvent(SB)		

TEXT runtime.traceStackID(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceStackID(mp *m, buf []uintptr, skip int) uint64 {
  0x4398f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4398f9		483b6110		CMPQ 0x10(CX), SP	
  0x4398fd		0f861f010000		JBE 0x439a22		
  0x439903		4883ec40		SUBQ $0x40, SP		
  0x439907		48896c2438		MOVQ BP, 0x38(SP)	
  0x43990c		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x439911		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43991a		488b4c2448		MOVQ 0x48(SP), CX	
	gp := mp.curg
  0x43991f		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x439926		48894c2430		MOVQ CX, 0x30(SP)	
	if gp == _g_ {
  0x43992b		4839c1			CMPQ AX, CX		
  0x43992e		0f84a9000000		JE 0x4399dd		
	} else if gp != nil {
  0x439934		4885c9			TESTQ CX, CX		
  0x439937		7564			JNE 0x43999d		
  0x439939		31c0			XORL AX, AX		
	if nstk > 0 {
  0x43993b		4885c0			TESTQ AX, AX		
  0x43993e		7e03			JLE 0x439943		
		nstk-- // skip runtime.goexit
  0x439940		48ffc8			DECQ AX			
	if nstk > 0 && gp.goid == 1 {
  0x439943		4885c0			TESTQ AX, AX		
  0x439946		7e10			JLE 0x439958		
  0x439948		488b8998000000		MOVQ 0x98(CX), CX	
  0x43994f		4883f901		CMPQ $0x1, CX		
  0x439953		7503			JNE 0x439958		
		nstk-- // skip runtime.main
  0x439955		48ffc8			DECQ AX			
  0x439958		488b4c2460		MOVQ 0x60(SP), CX	
	id := trace.stackTab.put(buf[:nstk])
  0x43995d		4839c8			CMPQ CX, AX				
  0x439960		0f87b5000000		JA 0x439a1b				
  0x439966		488d15c39e0700		LEAQ runtime.trace+112(SB), DX		
  0x43996d		48891424		MOVQ DX, 0(SP)				
  0x439971		488b542450		MOVQ 0x50(SP), DX			
  0x439976		4889542408		MOVQ DX, 0x8(SP)			
  0x43997b		4889442410		MOVQ AX, 0x10(SP)			
  0x439980		48894c2418		MOVQ CX, 0x18(SP)			
  0x439985		e836040000		CALL runtime.(*traceStackTable).put(SB)	
	return uint64(id)
  0x43998a		8b442420		MOVL 0x20(SP), AX	
  0x43998e		4889442470		MOVQ AX, 0x70(SP)	
  0x439993		488b6c2438		MOVQ 0x38(SP), BP	
  0x439998		4883c440		ADDQ $0x40, SP		
  0x43999c		c3			RET			
		nstk = gcallers(gp, skip, buf[:])
  0x43999d		48890c24		MOVQ CX, 0(SP)			
  0x4399a1		488b442468		MOVQ 0x68(SP), AX		
  0x4399a6		4889442408		MOVQ AX, 0x8(SP)		
  0x4399ab		488b442450		MOVQ 0x50(SP), AX		
  0x4399b0		4889442410		MOVQ AX, 0x10(SP)		
  0x4399b5		488b542458		MOVQ 0x58(SP), DX		
  0x4399ba		4889542418		MOVQ DX, 0x18(SP)		
  0x4399bf		488b542460		MOVQ 0x60(SP), DX		
  0x4399c4		4889542420		MOVQ DX, 0x20(SP)		
  0x4399c9		e812400000		CALL runtime.gcallers(SB)	
  0x4399ce		488b442428		MOVQ 0x28(SP), AX		
  0x4399d3		488b4c2430		MOVQ 0x30(SP), CX		
  0x4399d8		e95effffff		JMP 0x43993b			
  0x4399dd		488b442468		MOVQ 0x68(SP), AX		
		nstk = callers(skip+1, buf[:])
  0x4399e2		48ffc0			INCQ AX				
  0x4399e5		48890424		MOVQ AX, 0(SP)			
  0x4399e9		488b442450		MOVQ 0x50(SP), AX		
  0x4399ee		4889442408		MOVQ AX, 0x8(SP)		
  0x4399f3		488b4c2458		MOVQ 0x58(SP), CX		
  0x4399f8		48894c2410		MOVQ CX, 0x10(SP)		
  0x4399fd		488b4c2460		MOVQ 0x60(SP), CX		
  0x439a02		48894c2418		MOVQ CX, 0x18(SP)		
  0x439a07		e8f43e0000		CALL runtime.callers(SB)	
  0x439a0c		488b442420		MOVQ 0x20(SP), AX		
  0x439a11		488b4c2430		MOVQ 0x30(SP), CX		
  0x439a16		e920ffffff		JMP 0x43993b			
	id := trace.stackTab.put(buf[:nstk])
  0x439a1b		e89060feff		CALL runtime.panicslice(SB)	
  0x439a20		0f0b			UD2				
func traceStackID(mp *m, buf []uintptr, skip int) uint64 {
  0x439a22		e849ab0000		CALL runtime.morestack_noctxt(SB)	
  0x439a27		e9c4feffff		JMP runtime.traceStackID(SB)		

TEXT runtime.traceAcquireBuffer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr) {
  0x439a30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439a39		483b6110		CMPQ 0x10(CX), SP	
  0x439a3d		0f8691000000		JBE 0x439ad4		
  0x439a43		4883ec18		SUBQ $0x18, SP		
  0x439a47		48896c2410		MOVQ BP, 0x10(SP)	
  0x439a4c		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x439a51		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x439a5a		488b4830		MOVQ 0x30(AX), CX	
  0x439a5e		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x439a64		488b4830		MOVQ 0x30(AX), CX	
  0x439a68		8400			TESTB AL, 0(AX)		
	if p := mp.p.ptr(); p != nil {
  0x439a6a		488b81d0000000		MOVQ 0xd0(CX), AX	
  0x439a71		4885c0			TESTQ AX, AX		
  0x439a74		7421			JE 0x439a97		
		return mp, p.id, &p.tracebuf
  0x439a76		8b5008			MOVL 0x8(AX), DX	
  0x439a79		48894c2420		MOVQ CX, 0x20(SP)	
  0x439a7e		89542428		MOVL DX, 0x28(SP)	
  0x439a82		480518120000		ADDQ $0x1218, AX	
  0x439a88		4889442430		MOVQ AX, 0x30(SP)	
  0x439a8d		488b6c2410		MOVQ 0x10(SP), BP	
  0x439a92		4883c418		ADDQ $0x18, SP		
  0x439a96		c3			RET			
  0x439a97		48894c2408		MOVQ CX, 0x8(SP)	
	lock(&trace.bufLock)
  0x439a9c		488d05d59d0800		LEAQ runtime.trace+65720(SB), AX	
  0x439aa3		48890424		MOVQ AX, 0(SP)				
  0x439aa7		e874fafcff		CALL runtime.lock(SB)			
	return mp, traceGlobProc, &trace.buf
  0x439aac		488b442408		MOVQ 0x8(SP), AX			
  0x439ab1		4889442420		MOVQ AX, 0x20(SP)			
  0x439ab6		c7442428ffffffff	MOVL $-0x1, 0x28(SP)			
  0x439abe		488d05bb9d0800		LEAQ runtime.trace+65728(SB), AX	
  0x439ac5		4889442430		MOVQ AX, 0x30(SP)			
  0x439aca		488b6c2410		MOVQ 0x10(SP), BP			
  0x439acf		4883c418		ADDQ $0x18, SP				
  0x439ad3		c3			RET					
func traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr) {
  0x439ad4		e897aa0000		CALL runtime.morestack_noctxt(SB)	
  0x439ad9		e952ffffff		JMP runtime.traceAcquireBuffer(SB)	

TEXT runtime.traceReleaseBuffer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceReleaseBuffer(pid int32) {
  0x439ae0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439ae9		483b6110		CMPQ 0x10(CX), SP	
  0x439aed		7667			JBE 0x439b56		
  0x439aef		4883ec10		SUBQ $0x10, SP		
  0x439af3		48896c2408		MOVQ BP, 0x8(SP)	
  0x439af8		488d6c2408		LEAQ 0x8(SP), BP	
  0x439afd		8b442418		MOVL 0x18(SP), AX	
	if pid == traceGlobProc {
  0x439b01		83f8ff			CMPL $-0x1, AX		
  0x439b04		743e			JE 0x439b44		
	releasem(getg().m)
  0x439b06		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x439b0f		488b4830		MOVQ 0x30(AX), CX	
	mp.locks--
  0x439b13		8b9100010000		MOVL 0x100(CX), DX	
  0x439b19		8d5aff			LEAL -0x1(DX), BX	
  0x439b1c		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x439b22		83fa01			CMPL $0x1, DX		
  0x439b25		7513			JNE 0x439b3a		
  0x439b27		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x439b2e		84c9			TESTL CL, CL		
  0x439b30		7408			JE 0x439b3a		
		_g_.stackguard0 = stackPreempt
  0x439b32		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x439b3a		488b6c2408		MOVQ 0x8(SP), BP	
  0x439b3f		4883c410		ADDQ $0x10, SP		
  0x439b43		c3			RET			
		unlock(&trace.bufLock)
  0x439b44		488d052d9d0800		LEAQ runtime.trace+65720(SB), AX	
  0x439b4b		48890424		MOVQ AX, 0(SP)				
  0x439b4f		e86cfbfcff		CALL runtime.unlock(SB)			
  0x439b54		ebb0			JMP 0x439b06				
func traceReleaseBuffer(pid int32) {
  0x439b56		e815aa0000		CALL runtime.morestack_noctxt(SB)	
  0x439b5b		eb83			JMP runtime.traceReleaseBuffer(SB)	

TEXT runtime.traceFlush(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceFlush(buf traceBufPtr, pid int32) traceBufPtr {
  0x439b60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439b69		483b6110		CMPQ 0x10(CX), SP	
  0x439b6d		0f86be010000		JBE 0x439d31		
  0x439b73		4883ec40		SUBQ $0x40, SP		
  0x439b77		48896c2438		MOVQ BP, 0x38(SP)	
  0x439b7c		488d6c2438		LEAQ 0x38(SP), BP	
	owner := trace.lockOwner
  0x439b81		488b05409c0700		MOVQ runtime.trace+8(SB), AX	
	dolock := owner == nil || owner != getg().m.curg
  0x439b88		4885c0			TESTQ AX, AX		
  0x439b8b		0f8474010000		JE 0x439d05		
  0x439b91		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439b9a		488b4930		MOVQ 0x30(CX), CX	
  0x439b9e		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x439ba5		4839c8			CMPQ CX, AX		
  0x439ba8		0f95c0			SETNE AL		
  0x439bab		8844241f		MOVB AL, 0x1f(SP)	
  0x439baf		84c0			TESTL AL, AL		
	if dolock {
  0x439bb1		0f8534010000		JNE 0x439ceb		
  0x439bb7		488b4c2448		MOVQ 0x48(SP), CX	
	if buf != 0 {
  0x439bbc		4885c9			TESTQ CX, CX		
  0x439bbf		7428			JE 0x439be9		
  0x439bc1		4889ca			MOVQ CX, DX		
	buf.ptr().link = 0
  0x439bc4		48c70100000000		MOVQ $0x0, 0(CX)	
	if trace.fullHead == 0 {
  0x439bcb		488b0d469c0700		MOVQ runtime.trace+88(SB), CX	
  0x439bd2		4885c9			TESTQ CX, CX			
  0x439bd5		0f8501010000		JNE 0x439cdc			
		trace.fullHead = buf
  0x439bdb		488915369c0700		MOVQ DX, runtime.trace+88(SB)	
	trace.fullTail = buf
  0x439be2		488915379c0700		MOVQ DX, runtime.trace+96(SB)	
	if trace.empty != 0 {
  0x439be9		488b0d209c0700		MOVQ runtime.trace+80(SB), CX	
  0x439bf0		4885c9			TESTQ CX, CX			
  0x439bf3		0f84b8000000		JE 0x439cb1			
  0x439bf9		4889ca			MOVQ CX, DX			
		trace.empty = buf.ptr().link
  0x439bfc		488b09			MOVQ 0(CX), CX			
  0x439bff		48890d0a9c0700		MOVQ CX, runtime.trace+80(SB)	
  0x439c06		4889542420		MOVQ DX, 0x20(SP)		
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x439c0b		4889542430		MOVQ DX, 0x30(SP)	
func (tp *traceBufPtr) set(b *traceBuf) { *tp = traceBufPtr(unsafe.Pointer(b)) }
  0x439c10		31c9			XORL CX, CX		
  0x439c12		48890a			MOVQ CX, 0(DX)		
	bufp.pos = 0
  0x439c15		48c7421000000000	MOVQ $0x0, 0x10(DX)	
	ticks := uint64(cputicks()) / traceTickDiv
  0x439c1d		e8cec00000		CALL runtime.cputicks(SB)	
  0x439c22		488b0424		MOVQ 0(SP), AX			
  0x439c26		48c1e806		SHRQ $0x6, AX			
  0x439c2a		488b4c2430		MOVQ 0x30(SP), CX		
	bufp.lastTicks = ticks
  0x439c2f		48894108		MOVQ AX, 0x8(CX)	
	buf.arr[buf.pos] = v
  0x439c33		488b5110		MOVQ 0x10(CX), DX		
  0x439c37		4881fae8fb0000		CMPQ $0xfbe8, DX		
  0x439c3e		0f83cb000000		JAE 0x439d0f			
  0x439c44		4889442428		MOVQ AX, 0x28(SP)		
  0x439c49		c684111804000041	MOVB $0x41, 0x418(CX)(DX*1)	
	buf.pos++
  0x439c51		48ff4110		INCQ 0x10(CX)		
	bufp.varint(uint64(pid))
  0x439c55		48890c24		MOVQ CX, 0(SP)				
  0x439c59		8b442450		MOVL 0x50(SP), AX			
  0x439c5d		4863c0			MOVSXD AX, AX				
  0x439c60		4889442408		MOVQ AX, 0x8(SP)			
  0x439c65		e8d6000000		CALL runtime.(*traceBuf).varint(SB)	
  0x439c6a		488b442430		MOVQ 0x30(SP), AX			
	bufp.varint(ticks)
  0x439c6f		48890424		MOVQ AX, 0(SP)				
  0x439c73		488b442428		MOVQ 0x28(SP), AX			
  0x439c78		4889442408		MOVQ AX, 0x8(SP)			
  0x439c7d		e8be000000		CALL runtime.(*traceBuf).varint(SB)	
  0x439c82		0fb644241f		MOVZX 0x1f(SP), AX			
	dolock := owner == nil || owner != getg().m.curg
  0x439c87		84c0			TESTL AL, AL		
	if dolock {
  0x439c89		7514			JNE 0x439c9f		
	return buf
  0x439c8b		488b442420		MOVQ 0x20(SP), AX	
  0x439c90		4889442458		MOVQ AX, 0x58(SP)	
  0x439c95		488b6c2438		MOVQ 0x38(SP), BP	
  0x439c9a		4883c440		ADDQ $0x40, SP		
  0x439c9e		c3			RET			
		unlock(&trace.lock)
  0x439c9f		488d051a9b0700		LEAQ runtime.trace(SB), AX	
  0x439ca6		48890424		MOVQ AX, 0(SP)			
  0x439caa		e811fafcff		CALL runtime.unlock(SB)		
  0x439caf		ebda			JMP 0x439c8b			
		buf = traceBufPtr(sysAlloc(unsafe.Sizeof(traceBuf{}), &memstats.other_sys))
  0x439cb1		48c7042400000100	MOVQ $0x10000, 0(SP)			
  0x439cb9		488d05e0aa0800		LEAQ runtime.memstats+160(SB), AX	
  0x439cc0		4889442408		MOVQ AX, 0x8(SP)			
  0x439cc5		e85653fdff		CALL runtime.sysAlloc(SB)		
  0x439cca		488b442410		MOVQ 0x10(SP), AX			
		if buf == 0 {
  0x439ccf		4885c0			TESTQ AX, AX		
  0x439cd2		7442			JE 0x439d16		
  0x439cd4		4889c2			MOVQ AX, DX		
	bufp := buf.ptr()
  0x439cd7		e92affffff		JMP 0x439c06		
		trace.fullTail.ptr().link = buf
  0x439cdc		488b0d3d9b0700		MOVQ runtime.trace+96(SB), CX	
  0x439ce3		488911			MOVQ DX, 0(CX)			
  0x439ce6		e9f7feffff		JMP 0x439be2			
		lock(&trace.lock)
  0x439ceb		488d05ce9a0700		LEAQ runtime.trace(SB), AX	
  0x439cf2		48890424		MOVQ AX, 0(SP)			
  0x439cf6		e825f8fcff		CALL runtime.lock(SB)		
  0x439cfb		0fb644241f		MOVZX 0x1f(SP), AX		
  0x439d00		e9b2feffff		JMP 0x439bb7			
  0x439d05		b801000000		MOVL $0x1, AX			
	dolock := owner == nil || owner != getg().m.curg
  0x439d0a		e99cfeffff		JMP 0x439bab		
	buf.arr[buf.pos] = v
  0x439d0f		e82c5dfeff		CALL runtime.panicindex(SB)	
  0x439d14		0f0b			UD2				
			throw("trace: out of memory")
  0x439d16		488d05dc140300		LEAQ 0x314dc(IP), AX	
  0x439d1d		48890424		MOVQ AX, 0(SP)		
  0x439d21		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x439d2a		e8a174feff		CALL runtime.throw(SB)	
  0x439d2f		0f0b			UD2			
func traceFlush(buf traceBufPtr, pid int32) traceBufPtr {
  0x439d31		e83aa80000		CALL runtime.morestack_noctxt(SB)	
  0x439d36		e925feffff		JMP runtime.traceFlush(SB)		

TEXT runtime.(*traceBuf).varint(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func (buf *traceBuf) varint(v uint64) {
  0x439d40		4883ec08		SUBQ $0x8, SP		
  0x439d44		48892c24		MOVQ BP, 0(SP)		
  0x439d48		488d2c24		LEAQ 0(SP), BP		
  0x439d4c		488b442410		MOVQ 0x10(SP), AX	
	pos := buf.pos
  0x439d51		488b4810		MOVQ 0x10(AX), CX	
  0x439d55		488b542418		MOVQ 0x18(SP), DX	
	for ; v >= 0x80; v >>= 7 {
  0x439d5a		eb17			JMP 0x439d73		
  0x439d5c		4889d3			MOVQ DX, BX		
		buf.arr[pos] = 0x80 | byte(v)
  0x439d5f		83ca80			ORL $-0x80, DX			
  0x439d62		88940818040000		MOVB DL, 0x418(AX)(CX*1)	
	for ; v >= 0x80; v >>= 7 {
  0x439d69		48c1eb07		SHRQ $0x7, BX		
		pos++
  0x439d6d		48ffc1			INCQ CX			
  0x439d70		4889da			MOVQ BX, DX		
	for ; v >= 0x80; v >>= 7 {
  0x439d73		4881fa80000000		CMPQ $0x80, DX		
  0x439d7a		720b			JB 0x439d87		
		buf.arr[pos] = 0x80 | byte(v)
  0x439d7c		4881f9e8fb0000		CMPQ $0xfbe8, CX	
  0x439d83		72d7			JB 0x439d5c		
  0x439d85		eb27			JMP 0x439dae		
	buf.arr[pos] = byte(v)
  0x439d87		4881f9e8fb0000		CMPQ $0xfbe8, CX		
  0x439d8e		7317			JAE 0x439da7			
  0x439d90		88940818040000		MOVB DL, 0x418(AX)(CX*1)	
	pos++
  0x439d97		48ffc1			INCQ CX			
	buf.pos = pos
  0x439d9a		48894810		MOVQ CX, 0x10(AX)	
}
  0x439d9e		488b2c24		MOVQ 0(SP), BP		
  0x439da2		4883c408		ADDQ $0x8, SP		
  0x439da6		c3			RET			
	buf.arr[pos] = byte(v)
  0x439da7		e8945cfeff		CALL runtime.panicindex(SB)	
  0x439dac		0f0b			UD2				
		buf.arr[pos] = 0x80 | byte(v)
  0x439dae		e88d5cfeff		CALL runtime.panicindex(SB)	
  0x439db3		0f0b			UD2				

TEXT runtime.(*traceStackTable).put(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func (tab *traceStackTable) put(pcs []uintptr) uint32 {
  0x439dc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439dc9		483b6110		CMPQ 0x10(CX), SP	
  0x439dcd		0f86d5010000		JBE 0x439fa8		
  0x439dd3		4883ec50		SUBQ $0x50, SP		
  0x439dd7		48896c2448		MOVQ BP, 0x48(SP)	
  0x439ddc		488d6c2448		LEAQ 0x48(SP), BP	
  0x439de1		488b442468		MOVQ 0x68(SP), AX	
	if len(pcs) == 0 {
  0x439de6		4885c0			TESTQ AX, AX		
  0x439de9		0f84a0010000		JE 0x439f8f		
  0x439def		488b4c2460		MOVQ 0x60(SP), CX	
	hash := memhash(unsafe.Pointer(&pcs[0]), 0, uintptr(len(pcs))*unsafe.Sizeof(pcs[0]))
  0x439df4		48890c24		MOVQ CX, 0(SP)			
  0x439df8		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x439e01		48c1e003		SHLQ $0x3, AX			
  0x439e05		4889442410		MOVQ AX, 0x10(SP)		
  0x439e0a		e801bdfcff		CALL runtime.memhash(SB)	
  0x439e0f		488b442418		MOVQ 0x18(SP), AX		
  0x439e14		4889442438		MOVQ AX, 0x38(SP)		
  0x439e19		488b4c2458		MOVQ 0x58(SP), CX		
	if id := tab.find(pcs, hash); id != 0 {
  0x439e1e		48890c24		MOVQ CX, 0(SP)					
  0x439e22		488b542460		MOVQ 0x60(SP), DX				
  0x439e27		4889542408		MOVQ DX, 0x8(SP)				
  0x439e2c		488b5c2468		MOVQ 0x68(SP), BX				
  0x439e31		48895c2410		MOVQ BX, 0x10(SP)				
  0x439e36		488b742470		MOVQ 0x70(SP), SI				
  0x439e3b		4889742418		MOVQ SI, 0x18(SP)				
  0x439e40		4889442420		MOVQ AX, 0x20(SP)				
  0x439e45		e876010000		CALL runtime.(*traceStackTable).find(SB)	
  0x439e4a		8b442428		MOVL 0x28(SP), AX				
  0x439e4e		85c0			TESTL AX, AX					
  0x439e50		0f852b010000		JNE 0x439f81					
  0x439e56		488b442458		MOVQ 0x58(SP), AX				
	lock(&tab.lock)
  0x439e5b		8400			TESTB AL, 0(AX)		
  0x439e5d		48890424		MOVQ AX, 0(SP)		
  0x439e61		e8baf6fcff		CALL runtime.lock(SB)	
  0x439e66		488b442458		MOVQ 0x58(SP), AX	
	if id := tab.find(pcs, hash); id != 0 {
  0x439e6b		48890424		MOVQ AX, 0(SP)					
  0x439e6f		488b4c2460		MOVQ 0x60(SP), CX				
  0x439e74		48894c2408		MOVQ CX, 0x8(SP)				
  0x439e79		488b542468		MOVQ 0x68(SP), DX				
  0x439e7e		4889542410		MOVQ DX, 0x10(SP)				
  0x439e83		488b5c2470		MOVQ 0x70(SP), BX				
  0x439e88		48895c2418		MOVQ BX, 0x18(SP)				
  0x439e8d		488b5c2438		MOVQ 0x38(SP), BX				
  0x439e92		48895c2420		MOVQ BX, 0x20(SP)				
  0x439e97		e824010000		CALL runtime.(*traceStackTable).find(SB)	
  0x439e9c		8b442428		MOVL 0x28(SP), AX				
  0x439ea0		85c0			TESTL AX, AX					
  0x439ea2		0f85b5000000		JNE 0x439f5d					
  0x439ea8		488b442458		MOVQ 0x58(SP), AX				
	tab.seq++
  0x439ead		ff4008			INCL 0x8(AX)		
	stk := tab.newStack(len(pcs))
  0x439eb0		48890424		MOVQ AX, 0(SP)					
  0x439eb4		488b4c2468		MOVQ 0x68(SP), CX				
  0x439eb9		48894c2408		MOVQ CX, 0x8(SP)				
  0x439ebe		e8ad010000		CALL runtime.(*traceStackTable).newStack(SB)	
  0x439ec3		488b442410		MOVQ 0x10(SP), AX				
  0x439ec8		488b4c2438		MOVQ 0x38(SP), CX				
	stk.hash = hash
  0x439ecd		48894808		MOVQ CX, 0x8(AX)	
  0x439ed1		488b542458		MOVQ 0x58(SP), DX	
	stk.id = tab.seq
  0x439ed6		8b5a08			MOVL 0x8(DX), BX	
  0x439ed9		895810			MOVL BX, 0x10(AX)	
  0x439edc		488b5c2468		MOVQ 0x68(SP), BX	
	stk.n = len(pcs)
  0x439ee1		48895818		MOVQ BX, 0x18(AX)	
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x439ee5		488d7020		LEAQ 0x20(AX), SI	
  0x439ee9		8406			TESTB AL, 0(SI)		
  0x439eeb		4881fb80000000		CMPQ $0x80, BX		
  0x439ef2		0f87a9000000		JA 0x439fa1		
  0x439ef8		488b742460		MOVQ 0x60(SP), SI	
  0x439efd		31ff			XORL DI, DI		
	for i, pc := range pcs {
  0x439eff		eb0c			JMP 0x439f0d		
  0x439f01		4c8b04fe		MOVQ 0(SI)(DI*8), R8	
		stkpc[i] = pc
  0x439f05		4c8944f820		MOVQ R8, 0x20(AX)(DI*8)	
	for i, pc := range pcs {
  0x439f0a		48ffc7			INCQ DI			
  0x439f0d		4839df			CMPQ BX, DI		
  0x439f10		7cef			JL 0x439f01		
  0x439f12		4889442440		MOVQ AX, 0x40(SP)	
	part := int(hash % uintptr(len(tab.tab)))
  0x439f17		4881e1ff1f0000		ANDQ $0x1fff, CX	
	stk.link = tab.tab[part]
  0x439f1e		488b5cca20		MOVQ 0x20(DX)(CX*8), BX	
  0x439f23		488918			MOVQ BX, 0(AX)		
  0x439f26		488d4cca20		LEAQ 0x20(DX)(CX*8), CX	
	atomicstorep(unsafe.Pointer(&tab.tab[part]), unsafe.Pointer(stk))
  0x439f2b		48890c24		MOVQ CX, 0(SP)			
  0x439f2f		4889442408		MOVQ AX, 0x8(SP)		
  0x439f34		e8a77ffcff		CALL runtime.atomicstorep(SB)	
  0x439f39		488b442458		MOVQ 0x58(SP), AX		
	unlock(&tab.lock)
  0x439f3e		48890424		MOVQ AX, 0(SP)		
  0x439f42		e879f7fcff		CALL runtime.unlock(SB)	
  0x439f47		488b442440		MOVQ 0x40(SP), AX	
	return stk.id
  0x439f4c		8b4010			MOVL 0x10(AX), AX	
  0x439f4f		89442478		MOVL AX, 0x78(SP)	
  0x439f53		488b6c2448		MOVQ 0x48(SP), BP	
  0x439f58		4883c450		ADDQ $0x50, SP		
  0x439f5c		c3			RET			
  0x439f5d		89442434		MOVL AX, 0x34(SP)	
  0x439f61		488b442458		MOVQ 0x58(SP), AX	
		unlock(&tab.lock)
  0x439f66		48890424		MOVQ AX, 0(SP)		
  0x439f6a		e851f7fcff		CALL runtime.unlock(SB)	
		return id
  0x439f6f		8b442434		MOVL 0x34(SP), AX	
  0x439f73		89442478		MOVL AX, 0x78(SP)	
  0x439f77		488b6c2448		MOVQ 0x48(SP), BP	
  0x439f7c		4883c450		ADDQ $0x50, SP		
  0x439f80		c3			RET			
		return id
  0x439f81		89442478		MOVL AX, 0x78(SP)	
  0x439f85		488b6c2448		MOVQ 0x48(SP), BP	
  0x439f8a		4883c450		ADDQ $0x50, SP		
  0x439f8e		c3			RET			
		return 0
  0x439f8f		c744247800000000	MOVL $0x0, 0x78(SP)	
  0x439f97		488b6c2448		MOVQ 0x48(SP), BP	
  0x439f9c		4883c450		ADDQ $0x50, SP		
  0x439fa0		c3			RET			
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x439fa1		e80a5bfeff		CALL runtime.panicslice(SB)	
  0x439fa6		0f0b			UD2				
func (tab *traceStackTable) put(pcs []uintptr) uint32 {
  0x439fa8		e8c3a50000		CALL runtime.morestack_noctxt(SB)	
  0x439fad		e90efeffff		JMP runtime.(*traceStackTable).put(SB)	

TEXT runtime.(*traceStackTable).find(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func (tab *traceStackTable) find(pcs []uintptr, hash uintptr) uint32 {
  0x439fc0		4883ec08		SUBQ $0x8, SP		
  0x439fc4		48892c24		MOVQ BP, 0(SP)		
  0x439fc8		488d2c24		LEAQ 0(SP), BP		
  0x439fcc		488b442410		MOVQ 0x10(SP), AX	
	for stk := tab.tab[part].ptr(); stk != nil; stk = stk.link.ptr() {
  0x439fd1		8400			TESTB AL, 0(AX)		
func (tab *traceStackTable) find(pcs []uintptr, hash uintptr) uint32 {
  0x439fd3		488b4c2430		MOVQ 0x30(SP), CX	
  0x439fd8		4889ca			MOVQ CX, DX		
	part := int(hash % uintptr(len(tab.tab)))
  0x439fdb		4881e1ff1f0000		ANDQ $0x1fff, CX	
	for stk := tab.tab[part].ptr(); stk != nil; stk = stk.link.ptr() {
  0x439fe2		488b44c820		MOVQ 0x20(AX)(CX*8), AX	
func (tp traceStackPtr) ptr() *traceStack { return (*traceStack)(unsafe.Pointer(tp)) }
  0x439fe7		488b4c2420		MOVQ 0x20(SP), CX	
  0x439fec		488b5c2418		MOVQ 0x18(SP), BX	
	for stk := tab.tab[part].ptr(); stk != nil; stk = stk.link.ptr() {
  0x439ff1		eb1e			JMP 0x43a011		
			for i, stkpc := range stk.stack() {
  0x439ff3		48ffc7			INCQ DI			
  0x439ff6		4839f7			CMPQ SI, DI		
  0x439ff9		7d40			JGE 0x43a03b		
  0x439ffb		4c8b44f820		MOVQ 0x20(AX)(DI*8), R8	
				if stkpc != pcs[i] {
  0x43a000		4839cf			CMPQ CX, DI		
  0x43a003		7357			JAE 0x43a05c		
  0x43a005		4c8b0cfb		MOVQ 0(BX)(DI*8), R9	
  0x43a009		4d39c8			CMPQ R9, R8		
  0x43a00c		74e5			JE 0x439ff3		
	for stk := tab.tab[part].ptr(); stk != nil; stk = stk.link.ptr() {
  0x43a00e		488b00			MOVQ 0(AX), AX		
  0x43a011		4885c0			TESTQ AX, AX		
  0x43a014		7435			JE 0x43a04b		
		if stk.hash == hash && stk.n == len(pcs) {
  0x43a016		488b7008		MOVQ 0x8(AX), SI	
  0x43a01a		4839f2			CMPQ SI, DX		
  0x43a01d		75ef			JNE 0x43a00e		
  0x43a01f		488b7018		MOVQ 0x18(AX), SI	
  0x43a023		4839ce			CMPQ CX, SI		
  0x43a026		75e6			JNE 0x43a00e		
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x43a028		488d7820		LEAQ 0x20(AX), DI	
  0x43a02c		8407			TESTB AL, 0(DI)		
  0x43a02e		4881fe80000000		CMPQ $0x80, SI		
  0x43a035		772c			JA 0x43a063		
  0x43a037		31ff			XORL DI, DI		
			for i, stkpc := range stk.stack() {
  0x43a039		ebbb			JMP 0x439ff6		
			return stk.id
  0x43a03b		8b4010			MOVL 0x10(AX), AX	
  0x43a03e		89442438		MOVL AX, 0x38(SP)	
  0x43a042		488b2c24		MOVQ 0(SP), BP		
  0x43a046		4883c408		ADDQ $0x8, SP		
  0x43a04a		c3			RET			
	return 0
  0x43a04b		c744243800000000	MOVL $0x0, 0x38(SP)	
  0x43a053		488b2c24		MOVQ 0(SP), BP		
  0x43a057		4883c408		ADDQ $0x8, SP		
  0x43a05b		c3			RET			
				if stkpc != pcs[i] {
  0x43a05c		e8df59feff		CALL runtime.panicindex(SB)	
  0x43a061		0f0b			UD2				
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x43a063		e8485afeff		CALL runtime.panicslice(SB)	
  0x43a068		0f0b			UD2				

TEXT runtime.(*traceStackTable).newStack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func (tab *traceStackTable) newStack(n int) *traceStack {
  0x43a070		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a079		483b6110		CMPQ 0x10(CX), SP	
  0x43a07d		7648			JBE 0x43a0c7		
  0x43a07f		4883ec20		SUBQ $0x20, SP		
  0x43a083		48896c2418		MOVQ BP, 0x18(SP)	
  0x43a088		488d6c2418		LEAQ 0x18(SP), BP	
  0x43a08d		488b442428		MOVQ 0x28(SP), AX	
	return (*traceStack)(tab.mem.alloc(unsafe.Sizeof(traceStack{}) + uintptr(n)*sys.PtrSize))
  0x43a092		8400			TESTB AL, 0(AX)		
  0x43a094		4883c010		ADDQ $0x10, AX		
  0x43a098		48890424		MOVQ AX, 0(SP)		
func (tab *traceStackTable) newStack(n int) *traceStack {
  0x43a09c		488b442430		MOVQ 0x30(SP), AX	
	return (*traceStack)(tab.mem.alloc(unsafe.Sizeof(traceStack{}) + uintptr(n)*sys.PtrSize))
  0x43a0a1		48c1e003		SHLQ $0x3, AX				
  0x43a0a5		4883c028		ADDQ $0x28, AX				
  0x43a0a9		4889442408		MOVQ AX, 0x8(SP)			
  0x43a0ae		e81d000000		CALL runtime.(*traceAlloc).alloc(SB)	
  0x43a0b3		488b442410		MOVQ 0x10(SP), AX			
  0x43a0b8		4889442438		MOVQ AX, 0x38(SP)			
  0x43a0bd		488b6c2418		MOVQ 0x18(SP), BP			
  0x43a0c2		4883c420		ADDQ $0x20, SP				
  0x43a0c6		c3			RET					
func (tab *traceStackTable) newStack(n int) *traceStack {
  0x43a0c7		e8a4a40000		CALL runtime.morestack_noctxt(SB)		
  0x43a0cc		eba2			JMP runtime.(*traceStackTable).newStack(SB)	

TEXT runtime.(*traceAlloc).alloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func (a *traceAlloc) alloc(n uintptr) unsafe.Pointer {
  0x43a0d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a0d9		483b6110		CMPQ 0x10(CX), SP	
  0x43a0dd		0f86fb000000		JBE 0x43a1de		
  0x43a0e3		4883ec20		SUBQ $0x20, SP		
  0x43a0e7		48896c2418		MOVQ BP, 0x18(SP)	
  0x43a0ec		488d6c2418		LEAQ 0x18(SP), BP	
  0x43a0f1		488b442428		MOVQ 0x28(SP), AX	
	if a.head == 0 || a.off+n > uintptr(len(a.head.ptr().data)) {
  0x43a0f6		488b08			MOVQ 0(AX), CX		
  0x43a0f9		488b542430		MOVQ 0x30(SP), DX	
	return (n + a - 1) &^ (a - 1)
  0x43a0fe		4883c207		ADDQ $0x7, DX		
  0x43a102		4883e2f8		ANDQ $-0x8, DX		
  0x43a106		4889542430		MOVQ DX, 0x30(SP)	
	if a.head == 0 || a.off+n > uintptr(len(a.head.ptr().data)) {
  0x43a10b		4885c9			TESTQ CX, CX		
  0x43a10e		7578			JNE 0x43a188		
		if n > uintptr(len(a.head.ptr().data)) {
  0x43a110		4881faf8ff0000		CMPQ $0xfff8, DX	
  0x43a117		0f87a6000000		JA 0x43a1c3		
		block := (*traceAllocBlock)(sysAlloc(unsafe.Sizeof(traceAllocBlock{}), &memstats.other_sys))
  0x43a11d		48c7042400000100	MOVQ $0x10000, 0(SP)			
  0x43a125		488d0574a60800		LEAQ runtime.memstats+160(SB), AX	
  0x43a12c		4889442408		MOVQ AX, 0x8(SP)			
  0x43a131		e8ea4efdff		CALL runtime.sysAlloc(SB)		
  0x43a136		488b442410		MOVQ 0x10(SP), AX			
		if block == nil {
  0x43a13b		4885c0			TESTQ AX, AX		
  0x43a13e		7468			JE 0x43a1a8		
  0x43a140		488b4c2428		MOVQ 0x28(SP), CX	
		block.next.set(a.head.ptr())
  0x43a145		488b11			MOVQ 0(CX), DX		
func (p *traceAllocBlockPtr) set(x *traceAllocBlock) { *p = traceAllocBlockPtr(unsafe.Pointer(x)) }
  0x43a148		488910			MOVQ DX, 0(AX)		
  0x43a14b		488901			MOVQ AX, 0(CX)		
		a.off = 0
  0x43a14e		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	p := &a.head.ptr().data[a.off]
  0x43a156		488b01			MOVQ 0(CX), AX		
  0x43a159		8400			TESTB AL, 0(AX)		
  0x43a15b		488b5108		MOVQ 0x8(CX), DX	
  0x43a15f		4881faf8ff0000		CMPQ $0xfff8, DX	
  0x43a166		7339			JAE 0x43a1a1		
  0x43a168		488b5c2430		MOVQ 0x30(SP), BX	
	a.off += n
  0x43a16d		4801d3			ADDQ DX, BX		
  0x43a170		48895908		MOVQ BX, 0x8(CX)	
	p := &a.head.ptr().data[a.off]
  0x43a174		488d441008		LEAQ 0x8(AX)(DX*1), AX	
	return unsafe.Pointer(p)
  0x43a179		4889442438		MOVQ AX, 0x38(SP)	
  0x43a17e		488b6c2418		MOVQ 0x18(SP), BP	
  0x43a183		4883c420		ADDQ $0x20, SP		
  0x43a187		c3			RET			
	if a.head == 0 || a.off+n > uintptr(len(a.head.ptr().data)) {
  0x43a188		488b4808		MOVQ 0x8(AX), CX	
  0x43a18c		4801d1			ADDQ DX, CX		
  0x43a18f		4881f9f8ff0000		CMPQ $0xfff8, CX	
  0x43a196		0f8774ffffff		JA 0x43a110		
  0x43a19c		4889c1			MOVQ AX, CX		
	p := &a.head.ptr().data[a.off]
  0x43a19f		ebb5			JMP 0x43a156			
  0x43a1a1		e89a58feff		CALL runtime.panicindex(SB)	
  0x43a1a6		0f0b			UD2				
			throw("trace: out of memory")
  0x43a1a8		488d054a100300		LEAQ 0x3104a(IP), AX	
  0x43a1af		48890424		MOVQ AX, 0(SP)		
  0x43a1b3		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x43a1bc		e80f70feff		CALL runtime.throw(SB)	
  0x43a1c1		0f0b			UD2			
			throw("trace: alloc too large")
  0x43a1c3		488d05b4130300		LEAQ 0x313b4(IP), AX	
  0x43a1ca		48890424		MOVQ AX, 0(SP)		
  0x43a1ce		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x43a1d7		e8f46ffeff		CALL runtime.throw(SB)	
  0x43a1dc		0f0b			UD2			
func (a *traceAlloc) alloc(n uintptr) unsafe.Pointer {
  0x43a1de		e88da30000		CALL runtime.morestack_noctxt(SB)	
  0x43a1e3		e9e8feffff		JMP runtime.(*traceAlloc).alloc(SB)	

TEXT runtime.traceGomaxprocs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGomaxprocs(procs int32) {
  0x43a1f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a1f9		483b6110		CMPQ 0x10(CX), SP	
  0x43a1fd		765b			JBE 0x43a25a		
  0x43a1ff		4883ec38		SUBQ $0x38, SP		
  0x43a203		48896c2430		MOVQ BP, 0x30(SP)	
  0x43a208		488d6c2430		LEAQ 0x30(SP), BP	
	traceEvent(traceEvGomaxprocs, 1, uint64(procs))
  0x43a20d		48c744242800000000	MOVQ $0x0, 0x28(SP)	
func traceGomaxprocs(procs int32) {
  0x43a216		8b442440		MOVL 0x40(SP), AX	
	traceEvent(traceEvGomaxprocs, 1, uint64(procs))
  0x43a21a		4863c0			MOVSXD AX, AX			
  0x43a21d		4889442428		MOVQ AX, 0x28(SP)		
  0x43a222		c6042404		MOVB $0x4, 0(SP)		
  0x43a226		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43a22f		488d442428		LEAQ 0x28(SP), AX		
  0x43a234		4889442410		MOVQ AX, 0x10(SP)		
  0x43a239		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43a242		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43a24b		e8c0f3ffff		CALL runtime.traceEvent(SB)	
}
  0x43a250		488b6c2430		MOVQ 0x30(SP), BP	
  0x43a255		4883c438		ADDQ $0x38, SP		
  0x43a259		c3			RET			
func traceGomaxprocs(procs int32) {
  0x43a25a		e811a30000		CALL runtime.morestack_noctxt(SB)	
  0x43a25f		eb8f			JMP runtime.traceGomaxprocs(SB)		

TEXT runtime.traceProcStart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceProcStart() {
  0x43a270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a279		483b6110		CMPQ 0x10(CX), SP	
  0x43a27d		7668			JBE 0x43a2e7		
  0x43a27f		4883ec38		SUBQ $0x38, SP		
  0x43a283		48896c2430		MOVQ BP, 0x30(SP)	
  0x43a288		488d6c2430		LEAQ 0x30(SP), BP	
	traceEvent(traceEvProcStart, -1, uint64(getg().m.id))
  0x43a28d		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43a296		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX		
  0x43a29f		488b4030		MOVQ 0x30(AX), AX		
  0x43a2a3		488b80e0000000		MOVQ 0xe0(AX), AX		
  0x43a2aa		4889442428		MOVQ AX, 0x28(SP)		
  0x43a2af		c6042405		MOVB $0x5, 0(SP)		
  0x43a2b3		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43a2bc		488d442428		LEAQ 0x28(SP), AX		
  0x43a2c1		4889442410		MOVQ AX, 0x10(SP)		
  0x43a2c6		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43a2cf		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43a2d8		e833f3ffff		CALL runtime.traceEvent(SB)	
}
  0x43a2dd		488b6c2430		MOVQ 0x30(SP), BP	
  0x43a2e2		4883c438		ADDQ $0x38, SP		
  0x43a2e6		c3			RET			
func traceProcStart() {
  0x43a2e7		e884a20000		CALL runtime.morestack_noctxt(SB)	
  0x43a2ec		eb82			JMP runtime.traceProcStart(SB)		

TEXT runtime.traceProcStop(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceProcStop(pp *p) {
  0x43a2f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a2f9		483b6110		CMPQ 0x10(CX), SP	
  0x43a2fd		0f86bb000000		JBE 0x43a3be		
  0x43a303		4883ec40		SUBQ $0x40, SP		
  0x43a307		48896c2438		MOVQ BP, 0x38(SP)	
  0x43a30c		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x43a311		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x43a31a		488b4830		MOVQ 0x30(AX), CX	
  0x43a31e		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x43a324		488b4830		MOVQ 0x30(AX), CX	
  0x43a328		48894c2430		MOVQ CX, 0x30(SP)	
  0x43a32d		8400			TESTB AL, 0(AX)		
	oldp := mp.p
  0x43a32f		488d81d0000000		LEAQ 0xd0(CX), AX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x43a336		8400			TESTB AL, 0(AX)		
	oldp := mp.p
  0x43a338		488b81d0000000		MOVQ 0xd0(CX), AX	
  0x43a33f		4889442428		MOVQ AX, 0x28(SP)	
  0x43a344		488b542448		MOVQ 0x48(SP), DX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x43a349		488991d0000000		MOVQ DX, 0xd0(CX)	
	traceEvent(traceEvProcStop, -1)
  0x43a350		c6042406		MOVB $0x6, 0(SP)		
  0x43a354		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43a35d		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43a366		0f57c0			XORPS X0, X0			
  0x43a369		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43a36e		e89df2ffff		CALL runtime.traceEvent(SB)	
  0x43a373		488b442428		MOVQ 0x28(SP), AX		
  0x43a378		488b4c2430		MOVQ 0x30(SP), CX		
	mp.p = oldp
  0x43a37d		488981d0000000		MOVQ AX, 0xd0(CX)	
	_g_ := getg()
  0x43a384		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x43a38d		8b9100010000		MOVL 0x100(CX), DX	
  0x43a393		8d5aff			LEAL -0x1(DX), BX	
  0x43a396		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x43a39c		83fa01			CMPL $0x1, DX		
  0x43a39f		7513			JNE 0x43a3b4		
  0x43a3a1		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x43a3a8		84c9			TESTL CL, CL		
  0x43a3aa		7408			JE 0x43a3b4		
		_g_.stackguard0 = stackPreempt
  0x43a3ac		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x43a3b4		488b6c2438		MOVQ 0x38(SP), BP	
  0x43a3b9		4883c440		ADDQ $0x40, SP		
  0x43a3bd		c3			RET			
func traceProcStop(pp *p) {
  0x43a3be		e8ada10000		CALL runtime.morestack_noctxt(SB)	
  0x43a3c3		e928ffffff		JMP runtime.traceProcStop(SB)		

TEXT runtime.traceGCStart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCStart() {
  0x43a3d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a3d9		483b6110		CMPQ 0x10(CX), SP	
  0x43a3dd		7662			JBE 0x43a441		
  0x43a3df		4883ec38		SUBQ $0x38, SP		
  0x43a3e3		48896c2430		MOVQ BP, 0x30(SP)	
  0x43a3e8		488d6c2430		LEAQ 0x30(SP), BP	
	traceEvent(traceEvGCStart, 3, trace.seqGC)
  0x43a3ed		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43a3f6		488b0503940700		MOVQ runtime.trace+64(SB), AX	
  0x43a3fd		4889442428		MOVQ AX, 0x28(SP)		
  0x43a402		c6042407		MOVB $0x7, 0(SP)		
  0x43a406		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43a40f		488d442428		LEAQ 0x28(SP), AX		
  0x43a414		4889442410		MOVQ AX, 0x10(SP)		
  0x43a419		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43a422		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43a42b		e8e0f1ffff		CALL runtime.traceEvent(SB)	
	trace.seqGC++
  0x43a430		48ff05c9930700		INCQ runtime.trace+64(SB)	
}
  0x43a437		488b6c2430		MOVQ 0x30(SP), BP	
  0x43a43c		4883c438		ADDQ $0x38, SP		
  0x43a440		c3			RET			
func traceGCStart() {
  0x43a441		e82aa10000		CALL runtime.morestack_noctxt(SB)	
  0x43a446		eb88			JMP runtime.traceGCStart(SB)		

TEXT runtime.traceGCDone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCDone() {
  0x43a450		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a459		483b6110		CMPQ 0x10(CX), SP	
  0x43a45d		763b			JBE 0x43a49a		
  0x43a45f		4883ec30		SUBQ $0x30, SP		
  0x43a463		48896c2428		MOVQ BP, 0x28(SP)	
  0x43a468		488d6c2428		LEAQ 0x28(SP), BP	
	traceEvent(traceEvGCDone, -1)
  0x43a46d		c6042408		MOVB $0x8, 0(SP)		
  0x43a471		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43a47a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43a483		0f57c0			XORPS X0, X0			
  0x43a486		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43a48b		e880f1ffff		CALL runtime.traceEvent(SB)	
}
  0x43a490		488b6c2428		MOVQ 0x28(SP), BP	
  0x43a495		4883c430		ADDQ $0x30, SP		
  0x43a499		c3			RET			
func traceGCDone() {
  0x43a49a		e8d1a00000		CALL runtime.morestack_noctxt(SB)	
  0x43a49f		ebaf			JMP runtime.traceGCDone(SB)		

TEXT runtime.traceGCSTWStart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCSTWStart(kind int) {
  0x43a4b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a4b9		483b6110		CMPQ 0x10(CX), SP	
  0x43a4bd		7659			JBE 0x43a518		
  0x43a4bf		4883ec38		SUBQ $0x38, SP		
  0x43a4c3		48896c2430		MOVQ BP, 0x30(SP)	
  0x43a4c8		488d6c2430		LEAQ 0x30(SP), BP	
	traceEvent(traceEvGCSTWStart, -1, uint64(kind))
  0x43a4cd		48c744242800000000	MOVQ $0x0, 0x28(SP)	
func traceGCSTWStart(kind int) {
  0x43a4d6		488b442440		MOVQ 0x40(SP), AX	
	traceEvent(traceEvGCSTWStart, -1, uint64(kind))
  0x43a4db		4889442428		MOVQ AX, 0x28(SP)		
  0x43a4e0		c6042409		MOVB $0x9, 0(SP)		
  0x43a4e4		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43a4ed		488d442428		LEAQ 0x28(SP), AX		
  0x43a4f2		4889442410		MOVQ AX, 0x10(SP)		
  0x43a4f7		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43a500		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43a509		e802f1ffff		CALL runtime.traceEvent(SB)	
}
  0x43a50e		488b6c2430		MOVQ 0x30(SP), BP	
  0x43a513		4883c438		ADDQ $0x38, SP		
  0x43a517		c3			RET			
func traceGCSTWStart(kind int) {
  0x43a518		e853a00000		CALL runtime.morestack_noctxt(SB)	
  0x43a51d		eb91			JMP runtime.traceGCSTWStart(SB)		

TEXT runtime.traceGCSTWDone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCSTWDone() {
  0x43a520		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a529		483b6110		CMPQ 0x10(CX), SP	
  0x43a52d		763b			JBE 0x43a56a		
  0x43a52f		4883ec30		SUBQ $0x30, SP		
  0x43a533		48896c2428		MOVQ BP, 0x28(SP)	
  0x43a538		488d6c2428		LEAQ 0x28(SP), BP	
	traceEvent(traceEvGCSTWDone, -1)
  0x43a53d		c604240a		MOVB $0xa, 0(SP)		
  0x43a541		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43a54a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43a553		0f57c0			XORPS X0, X0			
  0x43a556		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43a55b		e8b0f0ffff		CALL runtime.traceEvent(SB)	
}
  0x43a560		488b6c2428		MOVQ 0x28(SP), BP	
  0x43a565		4883c430		ADDQ $0x30, SP		
  0x43a569		c3			RET			
func traceGCSTWDone() {
  0x43a56a		e801a00000		CALL runtime.morestack_noctxt(SB)	
  0x43a56f		ebaf			JMP runtime.traceGCSTWDone(SB)		

TEXT runtime.traceGCSweepStart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCSweepStart() {
  0x43a580		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a589		483b6110		CMPQ 0x10(CX), SP	
  0x43a58d		7665			JBE 0x43a5f4		
  0x43a58f		4883ec18		SUBQ $0x18, SP		
  0x43a593		48896c2410		MOVQ BP, 0x10(SP)	
  0x43a598		488d6c2410		LEAQ 0x10(SP), BP	
	_p_ := getg().m.p.ptr()
  0x43a59d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43a5a6		488b4030		MOVQ 0x30(AX), AX	
  0x43a5aa		488b80d0000000		MOVQ 0xd0(AX), AX	
	if _p_.traceSweep {
  0x43a5b1		8400			TESTB AL, 0(AX)		
  0x43a5b3		0fb68820120000		MOVZX 0x1220(AX), CX	
  0x43a5ba		84c9			TESTL CL, CL		
  0x43a5bc		751b			JNE 0x43a5d9		
	_p_.traceSweep, _p_.traceSwept, _p_.traceReclaimed = true, 0, 0
  0x43a5be		c6802012000001		MOVB $0x1, 0x1220(AX)	
  0x43a5c5		0f57c0			XORPS X0, X0		
  0x43a5c8		0f118028120000		MOVUPS X0, 0x1228(AX)	
}
  0x43a5cf		488b6c2410		MOVQ 0x10(SP), BP	
  0x43a5d4		4883c418		ADDQ $0x18, SP		
  0x43a5d8		c3			RET			
		throw("double traceGCSweepStart")
  0x43a5d9		488d05c6120300		LEAQ 0x312c6(IP), AX	
  0x43a5e0		48890424		MOVQ AX, 0(SP)		
  0x43a5e4		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x43a5ed		e8de6bfeff		CALL runtime.throw(SB)	
  0x43a5f2		0f0b			UD2			
func traceGCSweepStart() {
  0x43a5f4		e8779f0000		CALL runtime.morestack_noctxt(SB)	
  0x43a5f9		eb85			JMP runtime.traceGCSweepStart(SB)	

TEXT runtime.traceGCSweepSpan(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCSweepSpan(bytesSwept uintptr) {
  0x43a600		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a609		483b6110		CMPQ 0x10(CX), SP	
  0x43a60d		0f8687000000		JBE 0x43a69a		
  0x43a613		4883ec38		SUBQ $0x38, SP		
  0x43a617		48896c2430		MOVQ BP, 0x30(SP)	
  0x43a61c		488d6c2430		LEAQ 0x30(SP), BP	
	_p_ := getg().m.p.ptr()
  0x43a621		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43a62a		488b4030		MOVQ 0x30(AX), AX	
  0x43a62e		488b80d0000000		MOVQ 0xd0(AX), AX	
	if _p_.traceSweep {
  0x43a635		8400			TESTB AL, 0(AX)		
  0x43a637		0fb68820120000		MOVZX 0x1220(AX), CX	
  0x43a63e		84c9			TESTL CL, CL		
  0x43a640		741f			JE 0x43a661		
		if _p_.traceSwept == 0 {
  0x43a642		488b8828120000		MOVQ 0x1228(AX), CX	
  0x43a649		4885c9			TESTQ CX, CX		
  0x43a64c		741d			JE 0x43a66b		
  0x43a64e		488b4c2440		MOVQ 0x40(SP), CX	
		_p_.traceSwept += bytesSwept
  0x43a653		48038828120000		ADDQ 0x1228(AX), CX	
  0x43a65a		48898828120000		MOVQ CX, 0x1228(AX)	
  0x43a661		488b6c2430		MOVQ 0x30(SP), BP	
  0x43a666		4883c438		ADDQ $0x38, SP		
  0x43a66a		c3			RET			
  0x43a66b		4889442428		MOVQ AX, 0x28(SP)	
			traceEvent(traceEvGCSweepStart, 1)
  0x43a670		c604240b		MOVB $0xb, 0(SP)		
  0x43a674		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43a67d		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43a686		0f57c0			XORPS X0, X0			
  0x43a689		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43a68e		e87defffff		CALL runtime.traceEvent(SB)	
  0x43a693		488b442428		MOVQ 0x28(SP), AX		
  0x43a698		ebb4			JMP 0x43a64e			
func traceGCSweepSpan(bytesSwept uintptr) {
  0x43a69a		e8d19e0000		CALL runtime.morestack_noctxt(SB)	
  0x43a69f		e95cffffff		JMP runtime.traceGCSweepSpan(SB)	

TEXT runtime.traceGCSweepDone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCSweepDone() {
  0x43a6b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a6b9		483b6110		CMPQ 0x10(CX), SP	
  0x43a6bd		0f86c1000000		JBE 0x43a784		
  0x43a6c3		4883ec48		SUBQ $0x48, SP		
  0x43a6c7		48896c2440		MOVQ BP, 0x40(SP)	
  0x43a6cc		488d6c2440		LEAQ 0x40(SP), BP	
	_p_ := getg().m.p.ptr()
  0x43a6d1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43a6da		488b4030		MOVQ 0x30(AX), AX	
  0x43a6de		488b80d0000000		MOVQ 0xd0(AX), AX	
	if !_p_.traceSweep {
  0x43a6e5		8400			TESTB AL, 0(AX)		
  0x43a6e7		0fb68820120000		MOVZX 0x1220(AX), CX	
  0x43a6ee		84c9			TESTL CL, CL		
  0x43a6f0		7477			JE 0x43a769		
	if _p_.traceSwept != 0 {
  0x43a6f2		488b8828120000		MOVQ 0x1228(AX), CX	
  0x43a6f9		4885c9			TESTQ CX, CX		
  0x43a6fc		7511			JNE 0x43a70f		
	_p_.traceSweep = false
  0x43a6fe		c6802012000000		MOVB $0x0, 0x1220(AX)	
}
  0x43a705		488b6c2440		MOVQ 0x40(SP), BP	
  0x43a70a		4883c448		ADDQ $0x48, SP		
  0x43a70e		c3			RET			
  0x43a70f		4889442438		MOVQ AX, 0x38(SP)	
		traceEvent(traceEvGCSweepDone, -1, uint64(_p_.traceSwept), uint64(_p_.traceReclaimed))
  0x43a714		0f57c0			XORPS X0, X0			
  0x43a717		0f11442428		MOVUPS X0, 0x28(SP)		
  0x43a71c		488b8828120000		MOVQ 0x1228(AX), CX		
  0x43a723		48894c2428		MOVQ CX, 0x28(SP)		
  0x43a728		488b8830120000		MOVQ 0x1230(AX), CX		
  0x43a72f		48894c2430		MOVQ CX, 0x30(SP)		
  0x43a734		c604240c		MOVB $0xc, 0(SP)		
  0x43a738		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43a741		488d4c2428		LEAQ 0x28(SP), CX		
  0x43a746		48894c2410		MOVQ CX, 0x10(SP)		
  0x43a74b		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43a754		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43a75d		e8aeeeffff		CALL runtime.traceEvent(SB)	
	if _p_.traceSwept != 0 {
  0x43a762		488b442438		MOVQ 0x38(SP), AX	
		traceEvent(traceEvGCSweepDone, -1, uint64(_p_.traceSwept), uint64(_p_.traceReclaimed))
  0x43a767		eb95			JMP 0x43a6fe		
		throw("missing traceGCSweepStart")
  0x43a769		488d05f0120300		LEAQ 0x312f0(IP), AX	
  0x43a770		48890424		MOVQ AX, 0(SP)		
  0x43a774		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x43a77d		e84e6afeff		CALL runtime.throw(SB)	
  0x43a782		0f0b			UD2			
func traceGCSweepDone() {
  0x43a784		e8e79d0000		CALL runtime.morestack_noctxt(SB)	
  0x43a789		e922ffffff		JMP runtime.traceGCSweepDone(SB)	

TEXT runtime.traceGCMarkAssistStart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCMarkAssistStart() {
  0x43a790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a799		483b6110		CMPQ 0x10(CX), SP	
  0x43a79d		763b			JBE 0x43a7da		
  0x43a79f		4883ec30		SUBQ $0x30, SP		
  0x43a7a3		48896c2428		MOVQ BP, 0x28(SP)	
  0x43a7a8		488d6c2428		LEAQ 0x28(SP), BP	
	traceEvent(traceEvGCMarkAssistStart, 1)
  0x43a7ad		c604242b		MOVB $0x2b, 0(SP)		
  0x43a7b1		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43a7ba		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43a7c3		0f57c0			XORPS X0, X0			
  0x43a7c6		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43a7cb		e840eeffff		CALL runtime.traceEvent(SB)	
}
  0x43a7d0		488b6c2428		MOVQ 0x28(SP), BP	
  0x43a7d5		4883c430		ADDQ $0x30, SP		
  0x43a7d9		c3			RET			
func traceGCMarkAssistStart() {
  0x43a7da		e8919d0000		CALL runtime.morestack_noctxt(SB)	
  0x43a7df		ebaf			JMP runtime.traceGCMarkAssistStart(SB)	

TEXT runtime.traceGCMarkAssistDone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGCMarkAssistDone() {
  0x43a7f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a7f9		483b6110		CMPQ 0x10(CX), SP	
  0x43a7fd		763b			JBE 0x43a83a		
  0x43a7ff		4883ec30		SUBQ $0x30, SP		
  0x43a803		48896c2428		MOVQ BP, 0x28(SP)	
  0x43a808		488d6c2428		LEAQ 0x28(SP), BP	
	traceEvent(traceEvGCMarkAssistDone, -1)
  0x43a80d		c604242c		MOVB $0x2c, 0(SP)		
  0x43a811		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43a81a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43a823		0f57c0			XORPS X0, X0			
  0x43a826		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43a82b		e8e0edffff		CALL runtime.traceEvent(SB)	
}
  0x43a830		488b6c2428		MOVQ 0x28(SP), BP	
  0x43a835		4883c430		ADDQ $0x30, SP		
  0x43a839		c3			RET			
func traceGCMarkAssistDone() {
  0x43a83a		e8319d0000		CALL runtime.morestack_noctxt(SB)	
  0x43a83f		ebaf			JMP runtime.traceGCMarkAssistDone(SB)	

TEXT runtime.traceGoCreate(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoCreate(newg *g, pc uintptr) {
  0x43a850		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a859		483b6110		CMPQ 0x10(CX), SP	
  0x43a85d		0f86da000000		JBE 0x43a93d		
  0x43a863		4883ec40		SUBQ $0x40, SP		
  0x43a867		48896c2438		MOVQ BP, 0x38(SP)	
  0x43a86c		488d6c2438		LEAQ 0x38(SP), BP	
  0x43a871		488b442448		MOVQ 0x48(SP), AX	
	newg.traceseq = 0
  0x43a876		48c780d000000000000000	MOVQ $0x0, 0xd0(AX)	
	newg.tracelastp = getg().m.p
  0x43a881		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a88a		488b4930		MOVQ 0x30(CX), CX	
  0x43a88e		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x43a895		488988d8000000		MOVQ CX, 0xd8(AX)	
	id := trace.stackTab.put([]uintptr{pc + sys.PCQuantum})
  0x43a89c		488d0d5dd70100		LEAQ 0x1d75d(IP), CX			
  0x43a8a3		48890c24		MOVQ CX, 0(SP)				
  0x43a8a7		e87408fdff		CALL runtime.newobject(SB)		
  0x43a8ac		488b442408		MOVQ 0x8(SP), AX			
  0x43a8b1		488b4c2450		MOVQ 0x50(SP), CX			
  0x43a8b6		48ffc1			INCQ CX					
  0x43a8b9		488908			MOVQ CX, 0(AX)				
  0x43a8bc		488d0d6d8f0700		LEAQ runtime.trace+112(SB), CX		
  0x43a8c3		48890c24		MOVQ CX, 0(SP)				
  0x43a8c7		4889442408		MOVQ AX, 0x8(SP)			
  0x43a8cc		48c744241001000000	MOVQ $0x1, 0x10(SP)			
  0x43a8d5		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x43a8de		e8ddf4ffff		CALL runtime.(*traceStackTable).put(SB)	
	traceEvent(traceEvGoCreate, 2, uint64(newg.goid), uint64(id))
  0x43a8e3		8b442420		MOVL 0x20(SP), AX		
  0x43a8e7		0f57c0			XORPS X0, X0			
  0x43a8ea		0f11442428		MOVUPS X0, 0x28(SP)		
  0x43a8ef		488b4c2448		MOVQ 0x48(SP), CX		
  0x43a8f4		488b8998000000		MOVQ 0x98(CX), CX		
  0x43a8fb		48894c2428		MOVQ CX, 0x28(SP)		
  0x43a900		4889442430		MOVQ AX, 0x30(SP)		
  0x43a905		c604240d		MOVB $0xd, 0(SP)		
  0x43a909		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43a912		488d442428		LEAQ 0x28(SP), AX		
  0x43a917		4889442410		MOVQ AX, 0x10(SP)		
  0x43a91c		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43a925		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43a92e		e8ddecffff		CALL runtime.traceEvent(SB)	
}
  0x43a933		488b6c2438		MOVQ 0x38(SP), BP	
  0x43a938		4883c440		ADDQ $0x40, SP		
  0x43a93c		c3			RET			
func traceGoCreate(newg *g, pc uintptr) {
  0x43a93d		e82e9c0000		CALL runtime.morestack_noctxt(SB)	
  0x43a942		e909ffffff		JMP runtime.traceGoCreate(SB)		

TEXT runtime.traceGoStart(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoStart() {
  0x43a950		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a959		483b6110		CMPQ 0x10(CX), SP	
  0x43a95d		0f8681010000		JBE 0x43aae4		
  0x43a963		4883ec60		SUBQ $0x60, SP		
  0x43a967		48896c2458		MOVQ BP, 0x58(SP)	
  0x43a96c		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg().m.curg
  0x43a971		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43a97a		488b4030		MOVQ 0x30(AX), AX	
  0x43a97e		488b80c0000000		MOVQ 0xc0(AX), AX	
	_p_ := _g_.m.p
  0x43a985		488b4830		MOVQ 0x30(AX), CX	
  0x43a989		488b89d0000000		MOVQ 0xd0(CX), CX	
	_g_.traceseq++
  0x43a990		48ff80d0000000		INCQ 0xd0(AX)		
  0x43a997		4889ca			MOVQ CX, DX		
	if _g_ == _p_.ptr().gcBgMarkWorker.ptr() {
  0x43a99a		8401			TESTB AL, 0(CX)		
  0x43a99c		488b9958120000		MOVQ 0x1258(CX), BX	
  0x43a9a3		4839d8			CMPQ BX, AX		
  0x43a9a6		0f8586000000		JNE 0x43aa32		
		traceEvent(traceEvGoStartLabel, -1, uint64(_g_.goid), _g_.traceseq, trace.markWorkerLabels[_p_.ptr().gcMarkWorkerMode])
  0x43a9ac		48c744244000000000	MOVQ $0x0, 0x40(SP)		
  0x43a9b5		0f57c0			XORPS X0, X0			
  0x43a9b8		0f11442448		MOVUPS X0, 0x48(SP)		
  0x43a9bd		488b9098000000		MOVQ 0x98(AX), DX		
  0x43a9c4		4889542440		MOVQ DX, 0x40(SP)		
  0x43a9c9		488b80d0000000		MOVQ 0xd0(AX), AX		
  0x43a9d0		4889442448		MOVQ AX, 0x48(SP)		
  0x43a9d5		488b8160120000		MOVQ 0x1260(CX), AX		
  0x43a9dc		4883f803		CMPQ $0x3, AX			
  0x43a9e0		0f83f7000000		JAE 0x43aadd			
  0x43a9e6		488d0dd38d0700		LEAQ runtime.trace(SB), CX	
  0x43a9ed		488b84c1a0000100	MOVQ 0x100a0(CX)(AX*8), AX	
  0x43a9f5		4889442450		MOVQ AX, 0x50(SP)		
  0x43a9fa		c6042429		MOVB $0x29, 0(SP)		
  0x43a9fe		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43aa07		488d442440		LEAQ 0x40(SP), AX		
  0x43aa0c		4889442410		MOVQ AX, 0x10(SP)		
  0x43aa11		48c744241803000000	MOVQ $0x3, 0x18(SP)		
  0x43aa1a		48c744242003000000	MOVQ $0x3, 0x20(SP)		
  0x43aa23		e8e8ebffff		CALL runtime.traceEvent(SB)	
  0x43aa28		488b6c2458		MOVQ 0x58(SP), BP		
  0x43aa2d		4883c460		ADDQ $0x60, SP			
  0x43aa31		c3			RET				
	} else if _g_.tracelastp == _p_ {
  0x43aa32		488b88d8000000		MOVQ 0xd8(AX), CX	
  0x43aa39		4839d1			CMPQ DX, CX		
  0x43aa3c		7545			JNE 0x43aa83		
		traceEvent(traceEvGoStartLocal, -1, uint64(_g_.goid))
  0x43aa3e		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43aa47		488b8098000000		MOVQ 0x98(AX), AX		
  0x43aa4e		4889442428		MOVQ AX, 0x28(SP)		
  0x43aa53		c6042426		MOVB $0x26, 0(SP)		
  0x43aa57		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43aa60		488d442428		LEAQ 0x28(SP), AX		
  0x43aa65		4889442410		MOVQ AX, 0x10(SP)		
  0x43aa6a		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43aa73		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43aa7c		e88febffff		CALL runtime.traceEvent(SB)	
  0x43aa81		eba5			JMP 0x43aa28			
		_g_.tracelastp = _p_
  0x43aa83		488990d8000000		MOVQ DX, 0xd8(AX)	
		traceEvent(traceEvGoStart, -1, uint64(_g_.goid), _g_.traceseq)
  0x43aa8a		0f57c0			XORPS X0, X0			
  0x43aa8d		0f11442430		MOVUPS X0, 0x30(SP)		
  0x43aa92		488b8898000000		MOVQ 0x98(AX), CX		
  0x43aa99		48894c2430		MOVQ CX, 0x30(SP)		
  0x43aa9e		488b80d0000000		MOVQ 0xd0(AX), AX		
  0x43aaa5		4889442438		MOVQ AX, 0x38(SP)		
  0x43aaaa		c604240e		MOVB $0xe, 0(SP)		
  0x43aaae		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43aab7		488d442430		LEAQ 0x30(SP), AX		
  0x43aabc		4889442410		MOVQ AX, 0x10(SP)		
  0x43aac1		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43aaca		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43aad3		e838ebffff		CALL runtime.traceEvent(SB)	
  0x43aad8		e94bffffff		JMP 0x43aa28			
		traceEvent(traceEvGoStartLabel, -1, uint64(_g_.goid), _g_.traceseq, trace.markWorkerLabels[_p_.ptr().gcMarkWorkerMode])
  0x43aadd		e85e4ffeff		CALL runtime.panicindex(SB)	
  0x43aae2		0f0b			UD2				
func traceGoStart() {
  0x43aae4		e8879a0000		CALL runtime.morestack_noctxt(SB)	
  0x43aae9		e962feffff		JMP runtime.traceGoStart(SB)		

TEXT runtime.traceGoEnd(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoEnd() {
  0x43aaf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43aaf9		483b6110		CMPQ 0x10(CX), SP	
  0x43aafd		763b			JBE 0x43ab3a		
  0x43aaff		4883ec30		SUBQ $0x30, SP		
  0x43ab03		48896c2428		MOVQ BP, 0x28(SP)	
  0x43ab08		488d6c2428		LEAQ 0x28(SP), BP	
	traceEvent(traceEvGoEnd, -1)
  0x43ab0d		c604240f		MOVB $0xf, 0(SP)		
  0x43ab11		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43ab1a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43ab23		0f57c0			XORPS X0, X0			
  0x43ab26		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43ab2b		e8e0eaffff		CALL runtime.traceEvent(SB)	
}
  0x43ab30		488b6c2428		MOVQ 0x28(SP), BP	
  0x43ab35		4883c430		ADDQ $0x30, SP		
  0x43ab39		c3			RET			
func traceGoEnd() {
  0x43ab3a		e8319a0000		CALL runtime.morestack_noctxt(SB)	
  0x43ab3f		ebaf			JMP runtime.traceGoEnd(SB)		

TEXT runtime.traceGoSched(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoSched() {
  0x43ab50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ab59		483b6110		CMPQ 0x10(CX), SP	
  0x43ab5d		7656			JBE 0x43abb5		
  0x43ab5f		4883ec30		SUBQ $0x30, SP		
  0x43ab63		48896c2428		MOVQ BP, 0x28(SP)	
  0x43ab68		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x43ab6d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.tracelastp = _g_.m.p
  0x43ab76		488b4830		MOVQ 0x30(AX), CX	
  0x43ab7a		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x43ab81		488988d8000000		MOVQ CX, 0xd8(AX)	
	traceEvent(traceEvGoSched, 1)
  0x43ab88		c6042411		MOVB $0x11, 0(SP)		
  0x43ab8c		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43ab95		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43ab9e		0f57c0			XORPS X0, X0			
  0x43aba1		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43aba6		e865eaffff		CALL runtime.traceEvent(SB)	
}
  0x43abab		488b6c2428		MOVQ 0x28(SP), BP	
  0x43abb0		4883c430		ADDQ $0x30, SP		
  0x43abb4		c3			RET			
func traceGoSched() {
  0x43abb5		e8b6990000		CALL runtime.morestack_noctxt(SB)	
  0x43abba		eb94			JMP runtime.traceGoSched(SB)		

TEXT runtime.traceGoPreempt(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoPreempt() {
  0x43abc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43abc9		483b6110		CMPQ 0x10(CX), SP	
  0x43abcd		7656			JBE 0x43ac25		
  0x43abcf		4883ec30		SUBQ $0x30, SP		
  0x43abd3		48896c2428		MOVQ BP, 0x28(SP)	
  0x43abd8		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x43abdd		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.tracelastp = _g_.m.p
  0x43abe6		488b4830		MOVQ 0x30(AX), CX	
  0x43abea		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x43abf1		488988d8000000		MOVQ CX, 0xd8(AX)	
	traceEvent(traceEvGoPreempt, 1)
  0x43abf8		c6042412		MOVB $0x12, 0(SP)		
  0x43abfc		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43ac05		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43ac0e		0f57c0			XORPS X0, X0			
  0x43ac11		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43ac16		e8f5e9ffff		CALL runtime.traceEvent(SB)	
}
  0x43ac1b		488b6c2428		MOVQ 0x28(SP), BP	
  0x43ac20		4883c430		ADDQ $0x30, SP		
  0x43ac24		c3			RET			
func traceGoPreempt() {
  0x43ac25		e846990000		CALL runtime.morestack_noctxt(SB)	
  0x43ac2a		eb94			JMP runtime.traceGoPreempt(SB)		

TEXT runtime.traceGoPark(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoPark(traceEv byte, skip int) {
  0x43ac30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ac39		483b6110		CMPQ 0x10(CX), SP	
  0x43ac3d		7671			JBE 0x43acb0		
  0x43ac3f		4883ec30		SUBQ $0x30, SP		
  0x43ac43		48896c2428		MOVQ BP, 0x28(SP)	
  0x43ac48		488d6c2428		LEAQ 0x28(SP), BP	
  0x43ac4d		0fb6442438		MOVZX 0x38(SP), AX	
	if traceEv&traceFutileWakeup != 0 {
  0x43ac52		a880			TESTL $0x80, AL		
  0x43ac54		7530			JNE 0x43ac86		
	traceEvent(traceEv & ^traceFutileWakeup, skip)
  0x43ac56		83e07f			ANDL $0x7f, AX			
  0x43ac59		880424			MOVB AL, 0(SP)			
  0x43ac5c		488b442440		MOVQ 0x40(SP), AX		
  0x43ac61		4889442408		MOVQ AX, 0x8(SP)		
  0x43ac66		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43ac6f		0f57c0			XORPS X0, X0			
  0x43ac72		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43ac77		e894e9ffff		CALL runtime.traceEvent(SB)	
}
  0x43ac7c		488b6c2428		MOVQ 0x28(SP), BP	
  0x43ac81		4883c430		ADDQ $0x30, SP		
  0x43ac85		c3			RET			
		traceEvent(traceEvFutileWakeup, -1)
  0x43ac86		c6042424		MOVB $0x24, 0(SP)		
  0x43ac8a		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43ac93		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43ac9c		0f57c0			XORPS X0, X0			
  0x43ac9f		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43aca4		e867e9ffff		CALL runtime.traceEvent(SB)	
  0x43aca9		0fb6442438		MOVZX 0x38(SP), AX		
  0x43acae		eba6			JMP 0x43ac56			
func traceGoPark(traceEv byte, skip int) {
  0x43acb0		e8bb980000		CALL runtime.morestack_noctxt(SB)	
  0x43acb5		e976ffffff		JMP runtime.traceGoPark(SB)		

TEXT runtime.traceGoUnpark(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoUnpark(gp *g, skip int) {
  0x43acc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43acc9		483b6110		CMPQ 0x10(CX), SP	
  0x43accd		0f86e0000000		JBE 0x43adb3		
  0x43acd3		4883ec48		SUBQ $0x48, SP		
  0x43acd7		48896c2440		MOVQ BP, 0x40(SP)	
  0x43acdc		488d6c2440		LEAQ 0x40(SP), BP	
	_p_ := getg().m.p
  0x43ace1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43acea		488b4030		MOVQ 0x30(AX), AX	
  0x43acee		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x43acf5		488b4c2450		MOVQ 0x50(SP), CX	
	gp.traceseq++
  0x43acfa		48ff81d0000000		INCQ 0xd0(CX)		
	if gp.tracelastp == _p_ {
  0x43ad01		488b91d8000000		MOVQ 0xd8(CX), DX	
  0x43ad08		4839c2			CMPQ AX, DX		
  0x43ad0b		754e			JNE 0x43ad5b		
		traceEvent(traceEvGoUnblockLocal, skip, uint64(gp.goid))
  0x43ad0d		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43ad16		488b8198000000		MOVQ 0x98(CX), AX		
  0x43ad1d		4889442428		MOVQ AX, 0x28(SP)		
  0x43ad22		c6042427		MOVB $0x27, 0(SP)		
  0x43ad26		488b442458		MOVQ 0x58(SP), AX		
  0x43ad2b		4889442408		MOVQ AX, 0x8(SP)		
  0x43ad30		488d442428		LEAQ 0x28(SP), AX		
  0x43ad35		4889442410		MOVQ AX, 0x10(SP)		
  0x43ad3a		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43ad43		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43ad4c		e8bfe8ffff		CALL runtime.traceEvent(SB)	
  0x43ad51		488b6c2440		MOVQ 0x40(SP), BP		
  0x43ad56		4883c448		ADDQ $0x48, SP			
  0x43ad5a		c3			RET				
		gp.tracelastp = _p_
  0x43ad5b		488981d8000000		MOVQ AX, 0xd8(CX)	
		traceEvent(traceEvGoUnblock, skip, uint64(gp.goid), gp.traceseq)
  0x43ad62		0f57c0			XORPS X0, X0			
  0x43ad65		0f11442430		MOVUPS X0, 0x30(SP)		
  0x43ad6a		488b8198000000		MOVQ 0x98(CX), AX		
  0x43ad71		4889442430		MOVQ AX, 0x30(SP)		
  0x43ad76		488b81d0000000		MOVQ 0xd0(CX), AX		
  0x43ad7d		4889442438		MOVQ AX, 0x38(SP)		
  0x43ad82		c6042415		MOVB $0x15, 0(SP)		
  0x43ad86		488b442458		MOVQ 0x58(SP), AX		
  0x43ad8b		4889442408		MOVQ AX, 0x8(SP)		
  0x43ad90		488d442430		LEAQ 0x30(SP), AX		
  0x43ad95		4889442410		MOVQ AX, 0x10(SP)		
  0x43ad9a		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43ada3		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43adac		e85fe8ffff		CALL runtime.traceEvent(SB)	
  0x43adb1		eb9e			JMP 0x43ad51			
func traceGoUnpark(gp *g, skip int) {
  0x43adb3		e8b8970000		CALL runtime.morestack_noctxt(SB)	
  0x43adb8		e903ffffff		JMP runtime.traceGoUnpark(SB)		

TEXT runtime.traceGoSysCall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoSysCall() {
  0x43adc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43adc9		483b6110		CMPQ 0x10(CX), SP	
  0x43adcd		763b			JBE 0x43ae0a		
  0x43adcf		4883ec30		SUBQ $0x30, SP		
  0x43add3		48896c2428		MOVQ BP, 0x28(SP)	
  0x43add8		488d6c2428		LEAQ 0x28(SP), BP	
	traceEvent(traceEvGoSysCall, 1)
  0x43addd		c604241c		MOVB $0x1c, 0(SP)		
  0x43ade1		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43adea		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43adf3		0f57c0			XORPS X0, X0			
  0x43adf6		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43adfb		e810e8ffff		CALL runtime.traceEvent(SB)	
}
  0x43ae00		488b6c2428		MOVQ 0x28(SP), BP	
  0x43ae05		4883c430		ADDQ $0x30, SP		
  0x43ae09		c3			RET			
func traceGoSysCall() {
  0x43ae0a		e861970000		CALL runtime.morestack_noctxt(SB)	
  0x43ae0f		ebaf			JMP runtime.traceGoSysCall(SB)		

TEXT runtime.traceGoSysExit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoSysExit(ts int64) {
  0x43ae20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ae29		483b6110		CMPQ 0x10(CX), SP	
  0x43ae2d		0f86bd000000		JBE 0x43aef0		
  0x43ae33		4883ec48		SUBQ $0x48, SP		
  0x43ae37		48896c2440		MOVQ BP, 0x40(SP)	
  0x43ae3c		488d6c2440		LEAQ 0x40(SP), BP	
  0x43ae41		488b442450		MOVQ 0x50(SP), AX	
	if ts != 0 && ts < trace.ticksStart {
  0x43ae46		4885c0			TESTQ AX, AX			
  0x43ae49		740e			JE 0x43ae59			
  0x43ae4b		488b0d8e890700		MOVQ runtime.trace+32(SB), CX	
  0x43ae52		4839c8			CMPQ CX, AX			
  0x43ae55		7d02			JGE 0x43ae59			
  0x43ae57		31c0			XORL AX, AX			
	_g_ := getg().m.curg
  0x43ae59		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ae62		488b4930		MOVQ 0x30(CX), CX	
  0x43ae66		488b89c0000000		MOVQ 0xc0(CX), CX	
	_g_.traceseq++
  0x43ae6d		48ff81d0000000		INCQ 0xd0(CX)		
	_g_.tracelastp = _g_.m.p
  0x43ae74		488b5130		MOVQ 0x30(CX), DX	
  0x43ae78		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x43ae7f		488991d8000000		MOVQ DX, 0xd8(CX)	
	traceEvent(traceEvGoSysExit, -1, uint64(_g_.goid), _g_.traceseq, uint64(ts)/traceTickDiv)
  0x43ae86		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43ae8f		0f57c0			XORPS X0, X0			
  0x43ae92		0f11442430		MOVUPS X0, 0x30(SP)		
  0x43ae97		488b9198000000		MOVQ 0x98(CX), DX		
  0x43ae9e		4889542428		MOVQ DX, 0x28(SP)		
  0x43aea3		488b89d0000000		MOVQ 0xd0(CX), CX		
  0x43aeaa		48894c2430		MOVQ CX, 0x30(SP)		
  0x43aeaf		48c1e806		SHRQ $0x6, AX			
  0x43aeb3		4889442438		MOVQ AX, 0x38(SP)		
  0x43aeb8		c604241d		MOVB $0x1d, 0(SP)		
  0x43aebc		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43aec5		488d442428		LEAQ 0x28(SP), AX		
  0x43aeca		4889442410		MOVQ AX, 0x10(SP)		
  0x43aecf		48c744241803000000	MOVQ $0x3, 0x18(SP)		
  0x43aed8		48c744242003000000	MOVQ $0x3, 0x20(SP)		
  0x43aee1		e82ae7ffff		CALL runtime.traceEvent(SB)	
}
  0x43aee6		488b6c2440		MOVQ 0x40(SP), BP	
  0x43aeeb		4883c448		ADDQ $0x48, SP		
  0x43aeef		c3			RET			
func traceGoSysExit(ts int64) {
  0x43aef0		e87b960000		CALL runtime.morestack_noctxt(SB)	
  0x43aef5		e926ffffff		JMP runtime.traceGoSysExit(SB)		

TEXT runtime.traceGoSysBlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceGoSysBlock(pp *p) {
  0x43af00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43af09		483b6110		CMPQ 0x10(CX), SP	
  0x43af0d		0f86bb000000		JBE 0x43afce		
  0x43af13		4883ec40		SUBQ $0x40, SP		
  0x43af17		48896c2438		MOVQ BP, 0x38(SP)	
  0x43af1c		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x43af21		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x43af2a		488b4830		MOVQ 0x30(AX), CX	
  0x43af2e		ff8100010000		INCL 0x100(CX)		
	return _g_.m
  0x43af34		488b4830		MOVQ 0x30(AX), CX	
  0x43af38		48894c2430		MOVQ CX, 0x30(SP)	
  0x43af3d		8400			TESTB AL, 0(AX)		
	oldp := mp.p
  0x43af3f		488d81d0000000		LEAQ 0xd0(CX), AX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x43af46		8400			TESTB AL, 0(AX)		
	oldp := mp.p
  0x43af48		488b81d0000000		MOVQ 0xd0(CX), AX	
  0x43af4f		4889442428		MOVQ AX, 0x28(SP)	
  0x43af54		488b542448		MOVQ 0x48(SP), DX	
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x43af59		488991d0000000		MOVQ DX, 0xd0(CX)	
	traceEvent(traceEvGoSysBlock, -1)
  0x43af60		c604241e		MOVB $0x1e, 0(SP)		
  0x43af64		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43af6d		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43af76		0f57c0			XORPS X0, X0			
  0x43af79		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43af7e		e88de6ffff		CALL runtime.traceEvent(SB)	
  0x43af83		488b442428		MOVQ 0x28(SP), AX		
  0x43af88		488b4c2430		MOVQ 0x30(SP), CX		
	mp.p = oldp
  0x43af8d		488981d0000000		MOVQ AX, 0xd0(CX)	
	_g_ := getg()
  0x43af94		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x43af9d		8b9100010000		MOVL 0x100(CX), DX	
  0x43afa3		8d5aff			LEAL -0x1(DX), BX	
  0x43afa6		899900010000		MOVL BX, 0x100(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x43afac		83fa01			CMPL $0x1, DX		
  0x43afaf		7513			JNE 0x43afc4		
  0x43afb1		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x43afb8		84c9			TESTL CL, CL		
  0x43afba		7408			JE 0x43afc4		
		_g_.stackguard0 = stackPreempt
  0x43afbc		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x43afc4		488b6c2438		MOVQ 0x38(SP), BP	
  0x43afc9		4883c440		ADDQ $0x40, SP		
  0x43afcd		c3			RET			
func traceGoSysBlock(pp *p) {
  0x43afce		e89d950000		CALL runtime.morestack_noctxt(SB)	
  0x43afd3		e928ffffff		JMP runtime.traceGoSysBlock(SB)		

TEXT runtime.traceHeapAlloc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceHeapAlloc() {
  0x43afe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43afe9		483b6110		CMPQ 0x10(CX), SP	
  0x43afed		765b			JBE 0x43b04a		
  0x43afef		4883ec38		SUBQ $0x38, SP		
  0x43aff3		48896c2430		MOVQ BP, 0x30(SP)	
  0x43aff8		488d6c2430		LEAQ 0x30(SP), BP	
	traceEvent(traceEvHeapAlloc, -1, memstats.heap_live)
  0x43affd		48c744242800000000	MOVQ $0x0, 0x28(SP)			
  0x43b006		488b0533ae0800		MOVQ runtime.memstats+5952(SB), AX	
  0x43b00d		4889442428		MOVQ AX, 0x28(SP)			
  0x43b012		c6042421		MOVB $0x21, 0(SP)			
  0x43b016		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x43b01f		488d442428		LEAQ 0x28(SP), AX			
  0x43b024		4889442410		MOVQ AX, 0x10(SP)			
  0x43b029		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x43b032		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x43b03b		e8d0e5ffff		CALL runtime.traceEvent(SB)		
}
  0x43b040		488b6c2430		MOVQ 0x30(SP), BP	
  0x43b045		4883c438		ADDQ $0x38, SP		
  0x43b049		c3			RET			
func traceHeapAlloc() {
  0x43b04a		e821950000		CALL runtime.morestack_noctxt(SB)	
  0x43b04f		eb8f			JMP runtime.traceHeapAlloc(SB)		

TEXT runtime.traceNextGC(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/trace.go
func traceNextGC() {
  0x43b060		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b069		483b6110		CMPQ 0x10(CX), SP	
  0x43b06d		0f86a4000000		JBE 0x43b117		
  0x43b073		4883ec40		SUBQ $0x40, SP		
  0x43b077		48896c2438		MOVQ BP, 0x38(SP)	
  0x43b07c		488d6c2438		LEAQ 0x38(SP), BP	
	if memstats.next_gc == ^uint64(0) {
  0x43b081		488b0520970800		MOVQ runtime.memstats+168(SB), AX	
  0x43b088		4883f8ff		CMPQ $-0x1, AX				
  0x43b08c		7544			JNE 0x43b0d2				
		traceEvent(traceEvNextGC, -1, 0)
  0x43b08e		488b05d39a0300		MOVQ runtime.statictmp_39(SB), AX	
  0x43b095		4889442430		MOVQ AX, 0x30(SP)			
  0x43b09a		c6042422		MOVB $0x22, 0(SP)			
  0x43b09e		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x43b0a7		488d442430		LEAQ 0x30(SP), AX			
  0x43b0ac		4889442410		MOVQ AX, 0x10(SP)			
  0x43b0b1		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x43b0ba		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x43b0c3		e848e5ffff		CALL runtime.traceEvent(SB)		
  0x43b0c8		488b6c2438		MOVQ 0x38(SP), BP			
  0x43b0cd		4883c440		ADDQ $0x40, SP				
  0x43b0d1		c3			RET					
		traceEvent(traceEvNextGC, -1, memstats.next_gc)
  0x43b0d2		48c744242800000000	MOVQ $0x0, 0x28(SP)			
  0x43b0db		488b05c6960800		MOVQ runtime.memstats+168(SB), AX	
  0x43b0e2		4889442428		MOVQ AX, 0x28(SP)			
  0x43b0e7		c6042422		MOVB $0x22, 0(SP)			
  0x43b0eb		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x43b0f4		488d442428		LEAQ 0x28(SP), AX			
  0x43b0f9		4889442410		MOVQ AX, 0x10(SP)			
  0x43b0fe		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x43b107		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x43b110		e8fbe4ffff		CALL runtime.traceEvent(SB)		
  0x43b115		ebb1			JMP 0x43b0c8				
func traceNextGC() {
  0x43b117		e854940000		CALL runtime.morestack_noctxt(SB)	
  0x43b11c		e93fffffff		JMP runtime.traceNextGC(SB)		

TEXT runtime.tracebackdefers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer) {
  0x43b130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b139		488d4424d0		LEAQ -0x30(SP), AX	
  0x43b13e		483b4110		CMPQ 0x10(CX), AX	
  0x43b142		0f86d3010000		JBE 0x43b31b		
  0x43b148		4881ecb0000000		SUBQ $0xb0, SP		
  0x43b14f		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x43b157		488dac24a8000000	LEAQ 0xa8(SP), BP	
	var frame stkframe
  0x43b15f		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x43b168		488d7c2458		LEAQ 0x58(SP), DI	
  0x43b16d		0f57c0			XORPS X0, X0		
  0x43b170		488d7fd0		LEAQ -0x30(DI), DI	
  0x43b174		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43b179		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43b17e		e832b90000		CALL 0x446ab5		
  0x43b183		488b6d00		MOVQ 0(BP), BP		
func tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer) {
  0x43b187		488b8424b8000000	MOVQ 0xb8(SP), AX	
	for d := gp._defer; d != nil; d = d.link {
  0x43b18f		488b4028		MOVQ 0x28(AX), AX	
  0x43b193		eb0c			JMP 0x43b1a1		
  0x43b195		488b4c2448		MOVQ 0x48(SP), CX	
  0x43b19a		488b4128		MOVQ 0x28(CX), AX	
  0x43b19e		0f57c0			XORPS X0, X0		
  0x43b1a1		4885c0			TESTQ AX, AX		
  0x43b1a4		0f8406010000		JE 0x43b2b0		
  0x43b1aa		4889442448		MOVQ AX, 0x48(SP)	
		fn := d.fn
  0x43b1af		488b4818		MOVQ 0x18(AX), CX	
		if fn == nil {
  0x43b1b3		4885c9			TESTQ CX, CX		
  0x43b1b6		7568			JNE 0x43b220		
			frame.pc = 0
  0x43b1b8		48c744246000000000	MOVQ $0x0, 0x60(SP)	
			frame.fn = funcInfo{}
  0x43b1c1		0f11442450		MOVUPS X0, 0x50(SP)	
			frame.arglen = 0
  0x43b1c6		0f11842490000000	MOVUPS X0, 0x90(SP)	
			frame.argmap = nil
  0x43b1ce		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)	
		frame.continpc = frame.pc
  0x43b1da		488b442460		MOVQ 0x60(SP), AX	
  0x43b1df		4889442468		MOVQ AX, 0x68(SP)	
		if !callback((*stkframe)(noescape(unsafe.Pointer(&frame))), v) {
  0x43b1e4		488d442450		LEAQ 0x50(SP), AX	
  0x43b1e9		48890424		MOVQ AX, 0(SP)		
  0x43b1ed		488b8c24c8000000	MOVQ 0xc8(SP), CX	
  0x43b1f5		48894c2408		MOVQ CX, 0x8(SP)	
  0x43b1fa		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x43b202		488b1a			MOVQ 0(DX), BX		
  0x43b205		ffd3			CALL BX			
  0x43b207		0fb6442410		MOVZX 0x10(SP), AX	
  0x43b20c		84c0			TESTL AL, AL		
  0x43b20e		7585			JNE 0x43b195		
			return
  0x43b210		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x43b218		4881c4b0000000		ADDQ $0xb0, SP		
  0x43b21f		c3			RET			
  0x43b220		48894c2440		MOVQ CX, 0x40(SP)	
			frame.pc = fn.fn
  0x43b225		488b01			MOVQ 0(CX), AX		
  0x43b228		4889442460		MOVQ AX, 0x60(SP)	
			f := findfunc(frame.pc)
  0x43b22d		48890424		MOVQ AX, 0(SP)			
  0x43b231		e89acfffff		CALL runtime.findfunc(SB)	
  0x43b236		488b442410		MOVQ 0x10(SP), AX		
  0x43b23b		488b4c2408		MOVQ 0x8(SP), CX		
	return f._func != nil
  0x43b240		4885c9			TESTQ CX, CX		
			if !f.valid() {
  0x43b243		747b			JE 0x43b2c0		
			frame.fn = f
  0x43b245		48894c2450		MOVQ CX, 0x50(SP)	
  0x43b24a		4889442458		MOVQ AX, 0x58(SP)	
  0x43b24f		488b542448		MOVQ 0x48(SP), DX	
	if d.siz == 0 {
  0x43b254		8b1a			MOVL 0(DX), BX		
  0x43b256		85db			TESTL BX, BX		
  0x43b258		7550			JNE 0x43b2aa		
  0x43b25a		31db			XORL BX, BX		
			frame.argp = uintptr(deferArgs(d))
  0x43b25c		48899c2490000000	MOVQ BX, 0x90(SP)	
			frame.arglen, frame.argmap = getArgInfo(&frame, f, true, fn)
  0x43b264		488d542450		LEAQ 0x50(SP), DX		
  0x43b269		48891424		MOVQ DX, 0(SP)			
  0x43b26d		48894c2408		MOVQ CX, 0x8(SP)		
  0x43b272		4889442410		MOVQ AX, 0x10(SP)		
  0x43b277		c644241801		MOVB $0x1, 0x18(SP)		
  0x43b27c		488b442440		MOVQ 0x40(SP), AX		
  0x43b281		4889442420		MOVQ AX, 0x20(SP)		
  0x43b286		e8e51c0000		CALL runtime.getArgInfo(SB)	
  0x43b28b		488b442428		MOVQ 0x28(SP), AX		
  0x43b290		488b4c2430		MOVQ 0x30(SP), CX		
  0x43b295		4889842498000000	MOVQ AX, 0x98(SP)		
  0x43b29d		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x43b2a5		e930ffffff		JMP 0x43b1da			
	return unsafe.Pointer(uintptr(p) + x)
  0x43b2aa		488d5a30		LEAQ 0x30(DX), BX	
			frame.argp = uintptr(deferArgs(d))
  0x43b2ae		ebac			JMP 0x43b25c		
  0x43b2b0		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x43b2b8		4881c4b0000000		ADDQ $0xb0, SP		
  0x43b2bf		c3			RET			
				print("runtime: unknown pc in defer ", hex(frame.pc), "\n")
  0x43b2c0		488b442460		MOVQ 0x60(SP), AX		
  0x43b2c5		4889442438		MOVQ AX, 0x38(SP)		
  0x43b2ca		e83168feff		CALL runtime.printlock(SB)	
  0x43b2cf		488d05a9100300		LEAQ 0x310a9(IP), AX		
  0x43b2d6		48890424		MOVQ AX, 0(SP)			
  0x43b2da		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x43b2e3		e85871feff		CALL runtime.printstring(SB)	
  0x43b2e8		488b442438		MOVQ 0x38(SP), AX		
  0x43b2ed		48890424		MOVQ AX, 0(SP)			
  0x43b2f1		e8fa6ffeff		CALL runtime.printhex(SB)	
  0x43b2f6		e8956afeff		CALL runtime.printnl(SB)	
  0x43b2fb		e88068feff		CALL runtime.printunlock(SB)	
				throw("unknown pc")
  0x43b300		488d0587f00200		LEAQ 0x2f087(IP), AX	
  0x43b307		48890424		MOVQ AX, 0(SP)		
  0x43b30b		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x43b314		e8b75efeff		CALL runtime.throw(SB)	
  0x43b319		0f0b			UD2			
func tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer) {
  0x43b31b		e850920000		CALL runtime.morestack_noctxt(SB)	
  0x43b320		e90bfeffff		JMP runtime.tracebackdefers(SB)		

TEXT runtime.gentraceback(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func gentraceback(pc0, sp0, lr0 uintptr, gp *g, skip int, pcbuf *uintptr, max int, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer, flags uint) int {
  0x43b330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b339		488d842480fdffff	LEAQ 0xfffffd80(SP), AX	
  0x43b341		483b4110		CMPQ 0x10(CX), AX	
  0x43b345		0f86131c0000		JBE 0x43cf5e		
  0x43b34b		4881ec00030000		SUBQ $0x300, SP		
  0x43b352		4889ac24f8020000	MOVQ BP, 0x2f8(SP)	
  0x43b35a		488dac24f8020000	LEAQ 0x2f8(SP), BP	
  0x43b362		488b842428030000	MOVQ 0x328(SP), AX	
	if skip > 0 && callback != nil {
  0x43b36a		4885c0			TESTQ AX, AX		
  0x43b36d		0f8e88190000		JLE 0x43ccfb		
  0x43b373		488b8c2440030000	MOVQ 0x340(SP), CX	
  0x43b37b		4885c9			TESTQ CX, CX		
  0x43b37e		0f85bf1b0000		JNE 0x43cf43		
	g := getg()
  0x43b384		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x43b38d		488b9c2420030000	MOVQ 0x320(SP), BX	
	if g == gp && g == g.m.curg {
  0x43b395		4839d3			CMPQ DX, BX		
  0x43b398		7514			JNE 0x43b3ae		
  0x43b39a		488b7230		MOVQ 0x30(DX), SI	
  0x43b39e		488bb6c0000000		MOVQ 0xc0(SI), SI	
  0x43b3a5		4839d6			CMPQ DX, SI		
  0x43b3a8		0f847a1b0000		JE 0x43cf28		
	t := atomic.Load(&traceback_cache)
  0x43b3ae		8b35549c0600		MOVL runtime.traceback_cache(SB), SI	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x43b3b4		4c8b4230		MOVQ 0x30(DX), R8	
	if _g_.m.traceback != 0 {
  0x43b3b8		450fb68029010000	MOVZX 0x129(R8), R8	
  0x43b3c0		4584c0			TESTL R8, R8		
  0x43b3c3		0f842a190000		JE 0x43ccf3		
		level = int32(_g_.m.traceback)
  0x43b3c9		410fb6f0		MOVZX R8, SI		
  0x43b3cd		4c8b842408030000	MOVQ 0x308(SP), R8	
	if pc0 == ^uintptr(0) && sp0 == ^uintptr(0) { // Signal to fetch saved values from gp.
  0x43b3d5		4983f8ff		CMPQ $-0x1, R8		
  0x43b3d9		0f8504190000		JNE 0x43cce3		
  0x43b3df		4c8b8c2410030000	MOVQ 0x310(SP), R9	
  0x43b3e7		4983f9ff		CMPQ $-0x1, R9		
  0x43b3eb		0f85e2180000		JNE 0x43ccd3		
		if gp.syscallsp != 0 {
  0x43b3f1		4c8b4370		MOVQ 0x70(BX), R8	
  0x43b3f5		4d85c0			TESTQ R8, R8		
  0x43b3f8		0f84c8180000		JE 0x43ccc6		
			pc0 = gp.syscallpc
  0x43b3fe		4c8b4b78		MOVQ 0x78(BX), R9	
	var frame stkframe
  0x43b402		48c78424a002000000000000	MOVQ $0x0, 0x2a0(SP)	
  0x43b40e		488dbc24a8020000		LEAQ 0x2a8(SP), DI	
  0x43b416		0f57c0				XORPS X0, X0		
  0x43b419		488d7fd0			LEAQ -0x30(DI), DI	
  0x43b41d		48896c24f0			MOVQ BP, -0x10(SP)	
  0x43b422		488d6c24f0			LEAQ -0x10(SP), BP	
  0x43b427		e889b60000			CALL 0x446ab5		
  0x43b42c		488b6d00			MOVQ 0(BP), BP		
	frame.pc = pc0
  0x43b430		4c898c24b0020000	MOVQ R9, 0x2b0(SP)	
	frame.sp = sp0
  0x43b438		4c898424c8020000	MOVQ R8, 0x2c8(SP)	
	cgoCtxt := gp.cgoCtxt
  0x43b440		4c8b8b48010000		MOVQ 0x148(BX), R9	
  0x43b447		4c8b9340010000		MOVQ 0x140(BX), R10	
  0x43b44e		4c8b9c2430030000	MOVQ 0x330(SP), R11	
	printing := pcbuf == nil && callback == nil
  0x43b456		4d85db			TESTQ R11, R11		
  0x43b459		0f845b180000		JE 0x43ccba		
  0x43b45f		31ff			XORL DI, DI		
	_defer := gp._defer
  0x43b461		4c8b6328		MOVQ 0x28(BX), R12	
	for _defer != nil && _defer.sp == _NoArgs {
  0x43b465		eb05			JMP 0x43b46c		
		_defer = _defer.link
  0x43b467		4d8b642428		MOVQ 0x28(R12), R12	
	for _defer != nil && _defer.sp == _NoArgs {
  0x43b46c		4d85e4			TESTQ R12, R12		
  0x43b46f		740b			JE 0x43b47c		
  0x43b471		4d8b6c2408		MOVQ 0x8(R12), R13	
  0x43b476		4983fdff		CMPQ $-0x1, R13		
  0x43b47a		74eb			JE 0x43b467		
  0x43b47c		4889942420020000	MOVQ DX, 0x220(SP)	
  0x43b484		40887c2441		MOVB DI, 0x41(SP)	
  0x43b489		4c89a42458020000	MOVQ R12, 0x258(SP)	
  0x43b491		4c898c24a8000000	MOVQ R9, 0xa8(SP)	
  0x43b499		4c89942450020000	MOVQ R10, 0x250(SP)	
  0x43b4a1		89742448		MOVL SI, 0x48(SP)	
	if frame.pc == 0 {
  0x43b4a5		4c8bac24b0020000	MOVQ 0x2b0(SP), R13	
  0x43b4ad		4d85ed			TESTQ R13, R13		
  0x43b4b0		7514			JNE 0x43b4c6		
			frame.pc = uintptr(*(*sys.Uintreg)(unsafe.Pointer(frame.sp)))
  0x43b4b2		4d8b00			MOVQ 0(R8), R8		
  0x43b4b5		4c898424b0020000	MOVQ R8, 0x2b0(SP)	
			frame.sp += sys.RegSize
  0x43b4bd		48838424c802000008	ADDQ $0x8, 0x2c8(SP)	
	f := findfunc(frame.pc)
  0x43b4c6		488b8424b0020000	MOVQ 0x2b0(SP), AX		
  0x43b4ce		48890424		MOVQ AX, 0(SP)			
  0x43b4d2		e8f9ccffff		CALL runtime.findfunc(SB)	
  0x43b4d7		488b442410		MOVQ 0x10(SP), AX		
  0x43b4dc		488b4c2408		MOVQ 0x8(SP), CX		
	return f._func != nil
  0x43b4e1		4885c9			TESTQ CX, CX		
	if !f.valid() {
  0x43b4e4		0f8404170000		JE 0x43cbee		
	frame.fn = f
  0x43b4ea		48898c24a0020000	MOVQ CX, 0x2a0(SP)	
  0x43b4f2		48898424a8020000	MOVQ AX, 0x2a8(SP)	
	var cache pcvalueCache
  0x43b4fa		488dbc2408010000	LEAQ 0x108(SP), DI	
  0x43b502		0f57c0			XORPS X0, X0		
  0x43b505		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43b50a		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43b50f		e870b50000		CALL 0x446a84		
  0x43b514		488b6d00		MOVQ 0(BP), BP		
  0x43b518		488d442418		LEAQ 0x18(SP), AX	
  0x43b51d		4889842498020000	MOVQ AX, 0x298(SP)	
  0x43b525		31c9			XORL CX, CX		
  0x43b527		31d2			XORL DX, DX		
  0x43b529		31db			XORL BX, BX		
  0x43b52b		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43b533		488bbc2450020000	MOVQ 0x250(SP), DI	
  0x43b53b		4c8b842428030000	MOVQ 0x328(SP), R8	
  0x43b543		4531c9			XORL R9, R9		
  0x43b546		4c8b942458020000	MOVQ 0x258(SP), R10	
	for n < max {
  0x43b54e		e923010000		JMP 0x43b676		
			_defer = _defer.link
  0x43b553		4d8b5228		MOVQ 0x28(R10), R10	
		for _defer != nil && (_defer.sp == frame.sp || _defer.sp == _NoArgs) {
  0x43b557		4d85d2			TESTQ R10, R10		
  0x43b55a		0f844c110000		JE 0x43c6ac		
  0x43b560		4d8b5a08		MOVQ 0x8(R10), R11	
  0x43b564		4c8bac24c8020000	MOVQ 0x2c8(SP), R13	
  0x43b56c		4d39dd			CMPQ R11, R13		
  0x43b56f		74e2			JE 0x43b553		
  0x43b571		4983fbff		CMPQ $-0x1, R11		
  0x43b575		74dc			JE 0x43b553		
		if callback != nil || printing {
  0x43b577		4885c0			TESTQ AX, AX		
		for _defer != nil && (_defer.sp == frame.sp || _defer.sp == _NoArgs) {
  0x43b57a		4c89942458020000	MOVQ R10, 0x258(SP)	
		if callback != nil {
  0x43b582		0f8575100000		JNE 0x43c5fd		
  0x43b588		4c8b9c2430030000	MOVQ 0x330(SP), R11	
	printing := pcbuf == nil && callback == nil
  0x43b590		4d85db			TESTQ R11, R11		
		if pcbuf != nil {
  0x43b593		7422			JE 0x43b5b7		
			if skip == 0 {
  0x43b595		4d85c0			TESTQ R8, R8		
  0x43b598		0f85f60d0000		JNE 0x43c394		
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = frame.pc
  0x43b59e		4c8bac24b0020000	MOVQ 0x2b0(SP), R13	
  0x43b5a6		4881f900001000		CMPQ $0x100000, CX	
  0x43b5ad		0f8338190000		JAE 0x43ceeb		
  0x43b5b3		4d892ccb		MOVQ R13, 0(R11)(CX*8)	
	printing := pcbuf == nil && callback == nil
  0x43b5b7		4584f6			TESTL R14, R14		
		if printing {
  0x43b5ba		0f85f8040000		JNE 0x43bab8		
		n++
  0x43b5c0		48ffc1			INCQ CX			
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43b5c3		458b6c2410		MOVL 0x10(R12), R13	
  0x43b5c8		4183fd10		CMPL $0x10, R13		
  0x43b5cc		0f85de040000		JNE 0x43bab0		
  0x43b5d2		4885f6			TESTQ SI, SI		
  0x43b5d5		0f8ed5040000		JLE 0x43bab0		
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43b5db		4c8d6eff		LEAQ -0x1(SI), R13	
  0x43b5df		4939f5			CMPQ SI, R13		
  0x43b5e2		0f83e0180000		JAE 0x43cec8		
  0x43b5e8		488b74f7f8		MOVQ -0x8(DI)(SI*8), SI	
			if skip == 0 && callback == nil {
  0x43b5ed		4d85c0			TESTQ R8, R8		
  0x43b5f0		7509			JNE 0x43b5fb		
		if callback != nil || printing {
  0x43b5f2		4885c0			TESTQ AX, AX		
			if skip == 0 && callback == nil {
  0x43b5f5		0f8417040000		JE 0x43ba12		
		waspanic = f.funcID == funcID_sigpanic
  0x43b5fb		418b742410		MOVL 0x10(R12), SI	
	return f._func != nil
  0x43b600		4d85ff			TESTQ R15, R15		
		if !flr.valid() {
  0x43b603		0f84f0010000		JE 0x43b7f9		
		frame.fn = flr
  0x43b609		4c89bc24a0020000	MOVQ R15, 0x2a0(SP)	
  0x43b611		4c8ba42440020000	MOVQ 0x240(SP), R12	
  0x43b619		4c89a424a8020000	MOVQ R12, 0x2a8(SP)	
		frame.pc = frame.lr
  0x43b621		4c8ba424c0020000	MOVQ 0x2c0(SP), R12	
  0x43b629		4c89a424b0020000	MOVQ R12, 0x2b0(SP)	
		frame.lr = 0
  0x43b631		48c78424c002000000000000	MOVQ $0x0, 0x2c0(SP)	
		frame.sp = frame.fp
  0x43b63d		4c8ba424d0020000	MOVQ 0x2d0(SP), R12	
  0x43b645		4c89a424c8020000	MOVQ R12, 0x2c8(SP)	
		frame.fp = 0
  0x43b64d		48c78424d002000000000000	MOVQ $0x0, 0x2d0(SP)	
		frame.argmap = nil
  0x43b659		48c78424f002000000000000	MOVQ $0x0, 0x2f0(SP)	
		waspanic = f.funcID == funcID_sigpanic
  0x43b665		83fe08			CMPL $0x8, SI		
  0x43b668		0f94c2			SETE DL			
  0x43b66b		488b842498020000	MOVQ 0x298(SP), AX	
  0x43b673		4c89ee			MOVQ R13, SI		
	for n < max {
  0x43b676		4c8b9c2438030000	MOVQ 0x338(SP), R11	
  0x43b67e		4c39d9			CMPQ R11, CX		
  0x43b681		0f8d54150000		JGE 0x43cbdb		
		f = frame.fn
  0x43b687		4c8ba424a0020000	MOVQ 0x2a0(SP), R12	
  0x43b68f		4c8bac24a8020000	MOVQ 0x2a8(SP), R13	
		if f.pcsp == 0 {
  0x43b697		458b742414		MOVL 0x14(R12), R14	
  0x43b69c		4585f6			TESTL R14, R14		
  0x43b69f		0f8423150000		JE 0x43cbc8		
  0x43b6a5		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x43b6ad		4c89942490020000	MOVQ R10, 0x290(SP)	
  0x43b6b5		4c894c2468		MOVQ R9, 0x68(SP)	
  0x43b6ba		4c89ac2488020000	MOVQ R13, 0x288(SP)	
  0x43b6c2		4c89842428030000	MOVQ R8, 0x328(SP)	
  0x43b6ca		4c89a42480020000	MOVQ R12, 0x280(SP)	
  0x43b6d2		885c2440		MOVB BL, 0x40(SP)	
  0x43b6d6		8854243f		MOVB DL, 0x3f(SP)	
		if frame.fp == 0 {
  0x43b6da		4c8bb424d0020000	MOVQ 0x2d0(SP), R14	
  0x43b6e2		4d85f6			TESTQ R14, R14		
  0x43b6e5		0f8467130000		JE 0x43ca52		
  0x43b6eb		4c8bb42420030000	MOVQ 0x320(SP), R14	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43b6f3		4d8b7e30		MOVQ 0x30(R14), R15	
  0x43b6f7		4d85ff			TESTQ R15, R15		
  0x43b6fa		0f844a130000		JE 0x43ca4a		
  0x43b700		4d8b3f			MOVQ 0(R15), R15	
  0x43b703		4d39f7			CMPQ R14, R15		
  0x43b706		410f94c7		SETE R15		
	return f.funcID == funcID_goexit ||
  0x43b70a		418b442410		MOVL 0x10(R12), AX	
  0x43b70f		83f801			CMPL $0x1, AX		
  0x43b712		0f85d0120000		JNE 0x43c9e8		
  0x43b718		b801000000		MOVL $0x1, AX		
  0x43b71d		4889b424a8000000	MOVQ SI, 0xa8(SP)	
  0x43b725		4889bc2478020000	MOVQ DI, 0x278(SP)	
		f.funcID == funcID_externalthreadhandler ||
  0x43b72d		84c0			TESTL AL, AL		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43b72f		0f8445100000		JE 0x43c77a		
			frame.lr = 0
  0x43b735		48c78424c002000000000000	MOVQ $0x0, 0x2c0(SP)	
  0x43b741		31c0				XORL AX, AX		
  0x43b743		4531ff				XORL R15, R15		
			flr = funcInfo{}
  0x43b746		4889842440020000	MOVQ AX, 0x240(SP)	
		frame.varp = frame.fp
  0x43b74e		4c8bb424d0020000	MOVQ 0x2d0(SP), R14	
			frame.varp -= sys.RegSize
  0x43b756		4d8d5ef8		LEAQ -0x8(R14), R11	
  0x43b75a		4c899c24d8020000	MOVQ R11, 0x2d8(SP)	
		if framepointer_enabled && GOARCH == "amd64" && frame.varp > frame.sp {
  0x43b762		0fb6052e930300		MOVZX 0x3932e(IP), AX	
  0x43b769		84c0			TESTL AL, AL		
  0x43b76b		7419			JE 0x43b786		
  0x43b76d		488b8424c8020000	MOVQ 0x2c8(SP), AX	
  0x43b775		4939c3			CMPQ AX, R11		
  0x43b778		760c			JBE 0x43b786		
			frame.varp -= sys.RegSize
  0x43b77a		498d46f0		LEAQ -0x10(R14), AX	
  0x43b77e		48898424d8020000	MOVQ AX, 0x2d8(SP)	
  0x43b786		4c89bc2448020000	MOVQ R15, 0x248(SP)	
  0x43b78e		488b842440030000	MOVQ 0x340(SP), AX	
		if callback != nil || printing {
  0x43b796		4885c0			TESTQ AX, AX		
  0x43b799		410f95c3		SETNE R11		
  0x43b79d		0f85220f0000		JNE 0x43c6c5		
  0x43b7a3		440fb6742441		MOVZX 0x41(SP), R14	
	printing := pcbuf == nil && callback == nil
  0x43b7a9		4584f6			TESTL R14, R14		
		if callback != nil || printing {
  0x43b7ac		0f85130f0000		JNE 0x43c6c5		
		frame.continpc = frame.pc
  0x43b7b2		4c8b9c24b0020000	MOVQ 0x2b0(SP), R11	
  0x43b7ba		4c899c24b8020000	MOVQ R11, 0x2b8(SP)	
		if waspanic {
  0x43b7c2		84d2			TESTL DL, DL		
  0x43b7c4		0f848dfdffff		JE 0x43b557		
			if _defer != nil && _defer.sp == frame.sp {
  0x43b7ca		4d85d2			TESTQ R10, R10		
  0x43b7cd		0f84e10e0000		JE 0x43c6b4		
  0x43b7d3		4d8b5a08		MOVQ 0x8(R10), R11	
  0x43b7d7		4c8bac24c8020000	MOVQ 0x2c8(SP), R13	
  0x43b7df		4d39dd			CMPQ R11, R13		
  0x43b7e2		0f85cc0e0000		JNE 0x43c6b4		
				frame.continpc = _defer.pc
  0x43b7e8		4d8b5a10		MOVQ 0x10(R10), R11	
  0x43b7ec		4c899c24b8020000	MOVQ R11, 0x2b8(SP)	
  0x43b7f4		e95efdffff		JMP 0x43b557		
	printing := pcbuf == nil && callback == nil
  0x43b7f9		4584f6			TESTL R14, R14		
	if printing {
  0x43b7fc		0f8408020000		JE 0x43ba0a		
	if callback != nil && n < max && _defer != nil {
  0x43b802		4885c0			TESTQ AX, AX		
  0x43b805		0f84f5010000		JE 0x43ba00		
  0x43b80b		488b8c2438030000	MOVQ 0x338(SP), CX	
  0x43b813		4939c9			CMPQ CX, R9		
  0x43b816		0f8ddf010000		JGE 0x43b9fb		
  0x43b81c		4d85d2			TESTQ R10, R10		
  0x43b81f		0f8494010000		JE 0x43b9b9		
  0x43b825		488b842420030000	MOVQ 0x320(SP), AX	
			print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43b82d		488b8898000000		MOVQ 0x98(AX), CX		
  0x43b834		48898c2400010000	MOVQ CX, 0x100(SP)		
  0x43b83c		498b5208		MOVQ 0x8(R10), DX		
  0x43b840		48899424f8000000	MOVQ DX, 0xf8(SP)		
  0x43b848		498b5a10		MOVQ 0x10(R10), BX		
  0x43b84c		48899c24f0000000	MOVQ BX, 0xf0(SP)		
  0x43b854		e8a762feff		CALL runtime.printlock(SB)	
  0x43b859		488d05fcea0200		LEAQ 0x2eafc(IP), AX		
  0x43b860		48890424		MOVQ AX, 0(SP)			
  0x43b864		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43b86d		e8ce6bfeff		CALL runtime.printstring(SB)	
  0x43b872		488b842400010000	MOVQ 0x100(SP), AX		
  0x43b87a		48890424		MOVQ AX, 0(SP)			
  0x43b87e		e8fd69feff		CALL runtime.printint(SB)	
  0x43b883		488d057bf70200		LEAQ 0x2f77b(IP), AX		
  0x43b88a		48890424		MOVQ AX, 0(SP)			
  0x43b88e		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x43b897		e8a46bfeff		CALL runtime.printstring(SB)	
  0x43b89c		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43b8a4		48890424		MOVQ AX, 0(SP)			
  0x43b8a8		e8436afeff		CALL runtime.printhex(SB)	
  0x43b8ad		488d051ee40200		LEAQ 0x2e41e(IP), AX		
  0x43b8b4		48890424		MOVQ AX, 0(SP)			
  0x43b8b8		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43b8c1		e87a6bfeff		CALL runtime.printstring(SB)	
  0x43b8c6		488b8424f0000000	MOVQ 0xf0(SP), AX		
  0x43b8ce		48890424		MOVQ AX, 0(SP)			
  0x43b8d2		e8196afeff		CALL runtime.printhex(SB)	
  0x43b8d7		e8b464feff		CALL runtime.printnl(SB)	
  0x43b8dc		e89f62feff		CALL runtime.printunlock(SB)	
  0x43b8e1		488b842420030000	MOVQ 0x320(SP), AX		
		for _defer = gp._defer; _defer != nil; _defer = _defer.link {
  0x43b8e9		488b4028		MOVQ 0x28(AX), AX	
  0x43b8ed		e9b9000000		JMP 0x43b9ab		
  0x43b8f2		4889842458020000	MOVQ AX, 0x258(SP)	
			print("\tdefer ", _defer, " sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43b8fa		488b4808		MOVQ 0x8(AX), CX		
  0x43b8fe		48898c24f8000000	MOVQ CX, 0xf8(SP)		
  0x43b906		488b5010		MOVQ 0x10(AX), DX		
  0x43b90a		48899424f0000000	MOVQ DX, 0xf0(SP)		
  0x43b912		e8e961feff		CALL runtime.printlock(SB)	
  0x43b917		488d0590e50200		LEAQ 0x2e590(IP), AX		
  0x43b91e		48890424		MOVQ AX, 0(SP)			
  0x43b922		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43b92b		e8106bfeff		CALL runtime.printstring(SB)	
  0x43b930		488b842458020000	MOVQ 0x258(SP), AX		
  0x43b938		48890424		MOVQ AX, 0(SP)			
  0x43b93c		e8bf6afeff		CALL runtime.printpointer(SB)	
  0x43b941		488d0592e30200		LEAQ 0x2e392(IP), AX		
  0x43b948		48890424		MOVQ AX, 0(SP)			
  0x43b94c		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43b955		e8e66afeff		CALL runtime.printstring(SB)	
  0x43b95a		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43b962		48890424		MOVQ AX, 0(SP)			
  0x43b966		e88569feff		CALL runtime.printhex(SB)	
  0x43b96b		488d0560e30200		LEAQ 0x2e360(IP), AX		
  0x43b972		48890424		MOVQ AX, 0(SP)			
  0x43b976		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43b97f		e8bc6afeff		CALL runtime.printstring(SB)	
  0x43b984		488b8424f0000000	MOVQ 0xf0(SP), AX		
  0x43b98c		48890424		MOVQ AX, 0(SP)			
  0x43b990		e85b69feff		CALL runtime.printhex(SB)	
  0x43b995		e8f663feff		CALL runtime.printnl(SB)	
  0x43b99a		e8e161feff		CALL runtime.printunlock(SB)	
  0x43b99f		488b842458020000	MOVQ 0x258(SP), AX		
		for _defer = gp._defer; _defer != nil; _defer = _defer.link {
  0x43b9a7		488b4028		MOVQ 0x28(AX), AX	
  0x43b9ab		4885c0			TESTQ AX, AX		
  0x43b9ae		0f853effffff		JNE 0x43b8f2		
  0x43b9b4		e9f4140000		JMP 0x43cead		
	if callback != nil && n < max && _defer != nil {
  0x43b9b9		4885c0			TESTQ AX, AX		
	if callback != nil && n < max && frame.sp != gp.stktopsp {
  0x43b9bc		7425			JE 0x43b9e3		
  0x43b9be		4939c9			CMPQ CX, R9		
  0x43b9c1		7d20			JGE 0x43b9e3		
  0x43b9c3		488b8424c8020000	MOVQ 0x2c8(SP), AX	
  0x43b9cb		488b942420030000	MOVQ 0x320(SP), DX	
  0x43b9d3		488b9a80000000		MOVQ 0x80(DX), BX	
  0x43b9da		4839d8			CMPQ BX, AX		
  0x43b9dd		0f8525130000		JNE 0x43cd08		
	return n
  0x43b9e3		4c898c2458030000	MOVQ R9, 0x358(SP)	
  0x43b9eb		488bac24f8020000	MOVQ 0x2f8(SP), BP	
  0x43b9f3		4881c400030000		ADDQ $0x300, SP		
  0x43b9fa		c3			RET			
	if callback != nil && n < max && _defer != nil {
  0x43b9fb		4885c0			TESTQ AX, AX		
  0x43b9fe		ebbc			JMP 0x43b9bc		
  0x43ba00		488b8c2438030000	MOVQ 0x338(SP), CX	
  0x43ba08		ebb2			JMP 0x43b9bc		
  0x43ba0a		4989c9			MOVQ CX, R9		
	if printing {
  0x43ba0d		e9f0fdffff		JMP 0x43b802		
  0x43ba12		4c89ac24e8000000	MOVQ R13, 0xe8(SP)	
  0x43ba1a		4c898c24e0000000	MOVQ R9, 0xe0(SP)	
  0x43ba22		4c898424d8000000	MOVQ R8, 0xd8(SP)	
  0x43ba2a		885c2443		MOVB BL, 0x43(SP)	
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43ba2e		4c891c24		MOVQ R11, 0(SP)				
  0x43ba32		4488742408		MOVB R14, 0x8(SP)			
  0x43ba37		4889742410		MOVQ SI, 0x10(SP)			
  0x43ba3c		48894c2418		MOVQ CX, 0x18(SP)			
  0x43ba41		488b842438030000	MOVQ 0x338(SP), AX			
  0x43ba49		4889442420		MOVQ AX, 0x20(SP)			
  0x43ba4e		e8dd160000		CALL runtime.tracebackCgoContext(SB)	
  0x43ba53		488b4c2428		MOVQ 0x28(SP), CX			
  0x43ba58		488b842440030000	MOVQ 0x340(SP), AX			
  0x43ba60		0fb65c2443		MOVZX 0x43(SP), BX			
  0x43ba65		488bbc2478020000	MOVQ 0x278(SP), DI			
  0x43ba6d		4c8b8424d8000000	MOVQ 0xd8(SP), R8			
  0x43ba75		4c8b8c24e0000000	MOVQ 0xe0(SP), R9			
  0x43ba7d		4c8b942458020000	MOVQ 0x258(SP), R10			
  0x43ba85		4c8b9c2430030000	MOVQ 0x330(SP), R11			
  0x43ba8d		4c8ba42480020000	MOVQ 0x280(SP), R12			
  0x43ba95		4c8bac24e8000000	MOVQ 0xe8(SP), R13			
  0x43ba9d		440fb6742441		MOVZX 0x41(SP), R14			
  0x43baa3		4c8bbc2448020000	MOVQ 0x248(SP), R15			
  0x43baab		e94bfbffff		JMP 0x43b5fb				
  0x43bab0		4989f5			MOVQ SI, R13				
		waspanic = f.funcID == funcID_sigpanic
  0x43bab3		e943fbffff		JMP 0x43b5fb		
  0x43bab8		4c898424d0000000	MOVQ R8, 0xd0(SP)	
  0x43bac0		48898c24c8000000	MOVQ CX, 0xc8(SP)	
			name := funcname(f)
  0x43bac8		4c892424		MOVQ R12, 0(SP)			
  0x43bacc		488b842488020000	MOVQ 0x288(SP), AX		
  0x43bad4		4889442408		MOVQ AX, 0x8(SP)		
  0x43bad9		e822ceffff		CALL runtime.funcname(SB)	
  0x43bade		488b442410		MOVQ 0x10(SP), AX		
  0x43bae3		4889842408020000	MOVQ AX, 0x208(SP)		
  0x43baeb		488b4c2418		MOVQ 0x18(SP), CX		
  0x43baf0		48894c2478		MOVQ CX, 0x78(SP)		
	return !(name == "runtime.gopanic" || name == "runtime.sigpanic" || name == "runtime.panicwrap")
  0x43baf5		4883f90f		CMPQ $0xf, CX			
  0x43baf9		0f8586080000		JNE 0x43c385			
  0x43baff		488b10			MOVQ 0(AX), DX			
  0x43bb02		48bb72756e74696d652e	MOVQ $0x2e656d69746e7572, BX	
  0x43bb0c		4839d3			CMPQ DX, BX			
  0x43bb0f		0f85ce070000		JNE 0x43c2e3			
  0x43bb15		8b5008			MOVL 0x8(AX), DX		
  0x43bb18		81fa676f7061		CMPL $0x61706f67, DX		
  0x43bb1e		0f85bf070000		JNE 0x43c2e3			
  0x43bb24		0fb7500c		MOVZX 0xc(AX), DX		
  0x43bb28		6681fa6e69		CMPW $0x696e, DX		
  0x43bb2d		0f85b0070000		JNE 0x43c2e3			
  0x43bb33		0fb6500e		MOVZX 0xe(AX), DX		
  0x43bb37		80fa63			CMPL $0x63, DL			
  0x43bb3a		0f85a3070000		JNE 0x43c2e3			
  0x43bb40		ba01000000		MOVL $0x1, DX			
  0x43bb45		88542442		MOVB DL, 0x42(SP)		
  0x43bb49		488bb42450030000	MOVQ 0x350(SP), SI		
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, elideWrapper && nprint != 0) {
  0x43bb51		0fbae600		BTL $0x0, SI		
  0x43bb55		0f83f1060000		JAE 0x43c24c		
				tracepc := frame.pc // back up to CALL instruction for funcline.
  0x43bb5b		488bbc24b0020000	MOVQ 0x2b0(SP), DI	
  0x43bb63		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
				if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43bb6b		4d85c0			TESTQ R8, R8		
  0x43bb6e		0f8ec1060000		JLE 0x43c235		
  0x43bb74		4c8b8c2480020000	MOVQ 0x280(SP), R9	
  0x43bb7c		4d8b11			MOVQ 0(R9), R10		
  0x43bb7f		4c39d7			CMPQ R10, DI		
  0x43bb82		760f			JBE 0x43bb93		
  0x43bb84		440fb654243f		MOVZX 0x3f(SP), R10	
		if waspanic {
  0x43bb8a		4584d2			TESTL R10, R10		
				if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43bb8d		0f849a060000		JE 0x43c22d		
  0x43bb93		48897c2450		MOVQ DI, 0x50(SP)	
				file, line := funcline(f, tracepc)
  0x43bb98		4c890c24		MOVQ R9, 0(SP)			
  0x43bb9c		488b842488020000	MOVQ 0x288(SP), AX		
  0x43bba4		4889442408		MOVQ AX, 0x8(SP)		
  0x43bba9		48897c2410		MOVQ DI, 0x10(SP)		
  0x43bbae		e89dd0ffff		CALL runtime.funcline(SB)	
  0x43bbb3		8b442428		MOVL 0x28(SP), AX		
  0x43bbb7		89442444		MOVL AX, 0x44(SP)		
  0x43bbbb		488b4c2420		MOVQ 0x20(SP), CX		
  0x43bbc0		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x43bbc8		488b542418		MOVQ 0x18(SP), DX		
  0x43bbcd		4889942438020000	MOVQ DX, 0x238(SP)		
  0x43bbd5		488b9c2480020000	MOVQ 0x280(SP), BX		
				inldata := funcdata(f, _FUNCDATA_InlTree)
  0x43bbdd		48891c24		MOVQ BX, 0(SP)			
  0x43bbe1		488bb42488020000	MOVQ 0x288(SP), SI		
  0x43bbe9		4889742408		MOVQ SI, 0x8(SP)		
  0x43bbee		c744241002000000	MOVL $0x2, 0x10(SP)		
  0x43bbf6		e8f5d2ffff		CALL runtime.funcdata(SB)	
  0x43bbfb		488b442418		MOVQ 0x18(SP), AX		
				if inldata != nil {
  0x43bc00		4885c0			TESTQ AX, AX		
  0x43bc03		0f8525040000		JNE 0x43c02e		
  0x43bc09		488b442478		MOVQ 0x78(SP), AX	
	return !(name == "runtime.gopanic" || name == "runtime.sigpanic" || name == "runtime.panicwrap")
  0x43bc0e		4883f80f		CMPQ $0xf, AX		
  0x43bc12		488b8c2438020000	MOVQ 0x238(SP), CX	
  0x43bc1a		488b9424a0000000	MOVQ 0xa0(SP), DX	
  0x43bc22		8b5c2444		MOVL 0x44(SP), BX	
				if inldata != nil {
  0x43bc26		48898c2438020000	MOVQ CX, 0x238(SP)	
  0x43bc2e		48899424a0000000	MOVQ DX, 0xa0(SP)	
  0x43bc36		895c2444		MOVL BX, 0x44(SP)	
				if name == "runtime.gopanic" {
  0x43bc3a		0f85e1030000		JNE 0x43c021			
  0x43bc40		488bb42408020000	MOVQ 0x208(SP), SI		
  0x43bc48		488b3e			MOVQ 0(SI), DI			
  0x43bc4b		49b872756e74696d652e	MOVQ $0x2e656d69746e7572, R8	
  0x43bc55		4c39c7			CMPQ R8, DI			
  0x43bc58		752c			JNE 0x43bc86			
  0x43bc5a		8b7e08			MOVL 0x8(SI), DI		
  0x43bc5d		81ff676f7061		CMPL $0x61706f67, DI		
  0x43bc63		7521			JNE 0x43bc86			
  0x43bc65		0fb77e0c		MOVZX 0xc(SI), DI		
  0x43bc69		6681ff6e69		CMPW $0x696e, DI		
  0x43bc6e		7516			JNE 0x43bc86			
  0x43bc70		0fb67e0e		MOVZX 0xe(SI), DI		
  0x43bc74		4080ff63		CMPL $0x63, DI			
  0x43bc78		750c			JNE 0x43bc86			
  0x43bc7a		b805000000		MOVL $0x5, AX			
  0x43bc7f		488d3550e10200		LEAQ 0x2e150(IP), SI		
				print(name, "(")
  0x43bc86		4889442470		MOVQ AX, 0x70(SP)		
  0x43bc8b		4889b42418020000	MOVQ SI, 0x218(SP)		
  0x43bc93		e8685efeff		CALL runtime.printlock(SB)	
  0x43bc98		488b842418020000	MOVQ 0x218(SP), AX		
  0x43bca0		48890424		MOVQ AX, 0(SP)			
  0x43bca4		488b442470		MOVQ 0x70(SP), AX		
  0x43bca9		4889442408		MOVQ AX, 0x8(SP)		
  0x43bcae		e88d67feff		CALL runtime.printstring(SB)	
  0x43bcb3		488d0597df0200		LEAQ 0x2df97(IP), AX		
  0x43bcba		48890424		MOVQ AX, 0(SP)			
  0x43bcbe		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43bcc7		e87467feff		CALL runtime.printstring(SB)	
  0x43bccc		e8af5efeff		CALL runtime.printunlock(SB)	
				argp := (*[100]uintptr)(unsafe.Pointer(frame.argp))
  0x43bcd1		488b8424e0020000	MOVQ 0x2e0(SP), AX	
  0x43bcd9		4889842470020000	MOVQ AX, 0x270(SP)	
  0x43bce1		31c9			XORL CX, CX		
				for i := uintptr(0); i < frame.arglen/sys.PtrSize; i++ {
  0x43bce3		eb3d			JMP 0x43bd22		
					print(hex(argp[i]))
  0x43bce5		8400			TESTB AL, 0(AX)			
  0x43bce7		488b14c8		MOVQ 0(AX)(CX*8), DX		
  0x43bceb		48899424f8000000	MOVQ DX, 0xf8(SP)		
  0x43bcf3		e8085efeff		CALL runtime.printlock(SB)	
  0x43bcf8		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43bd00		48890424		MOVQ AX, 0(SP)			
  0x43bd04		e8e765feff		CALL runtime.printhex(SB)	
  0x43bd09		e8725efeff		CALL runtime.printunlock(SB)	
  0x43bd0e		488b842498000000	MOVQ 0x98(SP), AX		
				for i := uintptr(0); i < frame.arglen/sys.PtrSize; i++ {
  0x43bd16		488d4801		LEAQ 0x1(AX), CX	
  0x43bd1a		488b842470020000	MOVQ 0x270(SP), AX	
  0x43bd22		488b9424e8020000	MOVQ 0x2e8(SP), DX	
  0x43bd2a		48c1ea03		SHRQ $0x3, DX		
  0x43bd2e		4839d1			CMPQ DX, CX		
  0x43bd31		736e			JAE 0x43bda1		
					if i >= 10 {
  0x43bd33		4883f90a		CMPQ $0xa, CX		
  0x43bd37		7345			JAE 0x43bd7e		
  0x43bd39		48898c2498000000	MOVQ CX, 0x98(SP)	
					if i != 0 {
  0x43bd41		4885c9			TESTQ CX, CX		
  0x43bd44		749f			JE 0x43bce5		
						print(", ")
  0x43bd46		e8b55dfeff		CALL runtime.printlock(SB)	
  0x43bd4b		488d051adf0200		LEAQ 0x2df1a(IP), AX		
  0x43bd52		48890424		MOVQ AX, 0(SP)			
  0x43bd56		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43bd5f		e8dc66feff		CALL runtime.printstring(SB)	
  0x43bd64		e8175efeff		CALL runtime.printunlock(SB)	
  0x43bd69		488b842470020000	MOVQ 0x270(SP), AX		
  0x43bd71		488b8c2498000000	MOVQ 0x98(SP), CX		
  0x43bd79		e967ffffff		JMP 0x43bce5			
						print(", ...")
  0x43bd7e		e87d5dfeff		CALL runtime.printlock(SB)	
  0x43bd83		488d050be00200		LEAQ 0x2e00b(IP), AX		
  0x43bd8a		48890424		MOVQ AX, 0(SP)			
  0x43bd8e		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43bd97		e8a466feff		CALL runtime.printstring(SB)	
  0x43bd9c		e8df5dfeff		CALL runtime.printunlock(SB)	
				print(")\n")
  0x43bda1		e85a5dfeff		CALL runtime.printlock(SB)	
  0x43bda6		488d05bdde0200		LEAQ 0x2debd(IP), AX		
  0x43bdad		48890424		MOVQ AX, 0(SP)			
  0x43bdb1		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43bdba		e88166feff		CALL runtime.printstring(SB)	
  0x43bdbf		e8bc5dfeff		CALL runtime.printunlock(SB)	
				print("\t", file, ":", line)
  0x43bdc4		e8375dfeff		CALL runtime.printlock(SB)	
  0x43bdc9		488d058ede0200		LEAQ 0x2de8e(IP), AX		
  0x43bdd0		48890424		MOVQ AX, 0(SP)			
  0x43bdd4		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43bddd		e85e66feff		CALL runtime.printstring(SB)	
  0x43bde2		488b842438020000	MOVQ 0x238(SP), AX		
  0x43bdea		48890424		MOVQ AX, 0(SP)			
  0x43bdee		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x43bdf6		4889442408		MOVQ AX, 0x8(SP)		
  0x43bdfb		e84066feff		CALL runtime.printstring(SB)	
  0x43be00		488d0551de0200		LEAQ 0x2de51(IP), AX		
  0x43be07		48890424		MOVQ AX, 0(SP)			
  0x43be0b		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43be14		e82766feff		CALL runtime.printstring(SB)	
  0x43be19		8b442444		MOVL 0x44(SP), AX		
  0x43be1d		4863c0			MOVSXD AX, AX			
  0x43be20		48890424		MOVQ AX, 0(SP)			
  0x43be24		e85764feff		CALL runtime.printint(SB)	
  0x43be29		e8525dfeff		CALL runtime.printunlock(SB)	
				if frame.pc > f.entry {
  0x43be2e		488b8424b0020000	MOVQ 0x2b0(SP), AX	
  0x43be36		488b8c2480020000	MOVQ 0x280(SP), CX	
  0x43be3e		488b11			MOVQ 0(CX), DX		
  0x43be41		4839d0			CMPQ DX, AX		
  0x43be44		0f877b010000		JA 0x43bfc5		
  0x43be4a		488b842420020000	MOVQ 0x220(SP), AX	
				if g.m.throwing > 0 && gp == g.m.curg || level >= 2 {
  0x43be52		488b5030		MOVQ 0x30(AX), DX	
  0x43be56		8b9aec000000		MOVL 0xec(DX), BX	
  0x43be5c		85db			TESTL BX, BX		
  0x43be5e		0f8e57010000		JLE 0x43bfbb		
  0x43be64		488b92c0000000		MOVQ 0xc0(DX), DX	
  0x43be6b		488b9c2420030000	MOVQ 0x320(SP), BX	
  0x43be73		4839da			CMPQ BX, DX		
  0x43be76		0f852d010000		JNE 0x43bfa9		
					print(" fp=", hex(frame.fp), " sp=", hex(frame.sp), " pc=", hex(frame.pc))
  0x43be7c		488b8424d0020000	MOVQ 0x2d0(SP), AX		
  0x43be84		48898424f8000000	MOVQ AX, 0xf8(SP)		
  0x43be8c		488b8c24c8020000	MOVQ 0x2c8(SP), CX		
  0x43be94		48898c24f0000000	MOVQ CX, 0xf0(SP)		
  0x43be9c		488b9424b0020000	MOVQ 0x2b0(SP), DX		
  0x43bea4		48899424c0000000	MOVQ DX, 0xc0(SP)		
  0x43beac		e84f5cfeff		CALL runtime.printlock(SB)	
  0x43beb1		488d050ade0200		LEAQ 0x2de0a(IP), AX		
  0x43beb8		48890424		MOVQ AX, 0(SP)			
  0x43bebc		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43bec5		e87665feff		CALL runtime.printstring(SB)	
  0x43beca		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43bed2		48890424		MOVQ AX, 0(SP)			
  0x43bed6		e81564feff		CALL runtime.printhex(SB)	
  0x43bedb		488d05f8dd0200		LEAQ 0x2ddf8(IP), AX		
  0x43bee2		48890424		MOVQ AX, 0(SP)			
  0x43bee6		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43beef		e84c65feff		CALL runtime.printstring(SB)	
  0x43bef4		488b8424f0000000	MOVQ 0xf0(SP), AX		
  0x43befc		48890424		MOVQ AX, 0(SP)			
  0x43bf00		e8eb63feff		CALL runtime.printhex(SB)	
  0x43bf05		488d05c6dd0200		LEAQ 0x2ddc6(IP), AX		
  0x43bf0c		48890424		MOVQ AX, 0(SP)			
  0x43bf10		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43bf19		e82265feff		CALL runtime.printstring(SB)	
  0x43bf1e		488b8424c0000000	MOVQ 0xc0(SP), AX		
  0x43bf26		48890424		MOVQ AX, 0(SP)			
  0x43bf2a		e8c163feff		CALL runtime.printhex(SB)	
  0x43bf2f		e84c5cfeff		CALL runtime.printunlock(SB)	
				print("\n")
  0x43bf34		e8c75bfeff		CALL runtime.printlock(SB)	
  0x43bf39		e8525efeff		CALL runtime.printnl(SB)	
  0x43bf3e		e83d5cfeff		CALL runtime.printunlock(SB)	
  0x43bf43		488b442468		MOVQ 0x68(SP), AX		
				nprint++
  0x43bf48		48ffc0			INCQ AX			
  0x43bf4b		0fb65c2442		MOVZX 0x42(SP), BX	
	return !(name == "runtime.gopanic" || name == "runtime.sigpanic" || name == "runtime.panicwrap")
  0x43bf50		83f301			XORL $0x1, BX		
  0x43bf53		488b8c24c8000000	MOVQ 0xc8(SP), CX	
  0x43bf5b		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43bf63		488bbc2478020000	MOVQ 0x278(SP), DI	
  0x43bf6b		4c8b8424d0000000	MOVQ 0xd0(SP), R8	
  0x43bf73		4c8b942458020000	MOVQ 0x258(SP), R10	
  0x43bf7b		4c8b9c2430030000	MOVQ 0x330(SP), R11	
  0x43bf83		4c8ba42480020000	MOVQ 0x280(SP), R12	
  0x43bf8b		440fb6742441		MOVZX 0x41(SP), R14	
  0x43bf91		4c8bbc2448020000	MOVQ 0x248(SP), R15	
  0x43bf99		4989c1			MOVQ AX, R9		
  0x43bf9c		488b842440030000	MOVQ 0x340(SP), AX	
			elideWrapper = nextElideWrapper
  0x43bfa4		e917f6ffff		JMP 0x43b5c0		
  0x43bfa9		8b542448		MOVL 0x48(SP), DX	
				if g.m.throwing > 0 && gp == g.m.curg || level >= 2 {
  0x43bfad		83fa02			CMPL $0x2, DX		
  0x43bfb0		0f8dc6feffff		JGE 0x43be7c		
  0x43bfb6		e979ffffff		JMP 0x43bf34		
  0x43bfbb		488b9c2420030000	MOVQ 0x320(SP), BX	
  0x43bfc3		ebe4			JMP 0x43bfa9		
  0x43bfc5		48898424f8000000	MOVQ AX, 0xf8(SP)	
  0x43bfcd		48899424f0000000	MOVQ DX, 0xf0(SP)	
					print(" +", hex(frame.pc-f.entry))
  0x43bfd5		e8265bfeff		CALL runtime.printlock(SB)	
  0x43bfda		488d057fdc0200		LEAQ 0x2dc7f(IP), AX		
  0x43bfe1		48890424		MOVQ AX, 0(SP)			
  0x43bfe5		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43bfee		e84d64feff		CALL runtime.printstring(SB)	
  0x43bff3		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43bffb		488b8c24f0000000	MOVQ 0xf0(SP), CX		
  0x43c003		4829c8			SUBQ CX, AX			
  0x43c006		48890424		MOVQ AX, 0(SP)			
  0x43c00a		e8e162feff		CALL runtime.printhex(SB)	
  0x43c00f		e86c5bfeff		CALL runtime.printunlock(SB)	
  0x43c014		488b8c2480020000	MOVQ 0x280(SP), CX		
  0x43c01c		e929feffff		JMP 0x43be4a			
  0x43c021		488bb42408020000	MOVQ 0x208(SP), SI		
				if name == "runtime.gopanic" {
  0x43c029		e958fcffff		JMP 0x43bc86		
  0x43c02e		4889842470020000	MOVQ AX, 0x270(SP)	
  0x43c036		488b842480020000	MOVQ 0x280(SP), AX	
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, nil)
  0x43c03e		48890424		MOVQ AX, 0(SP)			
  0x43c042		488b8c2488020000	MOVQ 0x288(SP), CX		
  0x43c04a		48894c2408		MOVQ CX, 0x8(SP)		
  0x43c04f		c744241001000000	MOVL $0x1, 0x10(SP)		
  0x43c057		488b542450		MOVQ 0x50(SP), DX		
  0x43c05c		4889542418		MOVQ DX, 0x18(SP)		
  0x43c061		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43c06a		e8d1cdffff		CALL runtime.pcdatavalue(SB)	
  0x43c06f		8b442428		MOVL 0x28(SP), AX		
  0x43c073		488b8c24a0000000	MOVQ 0xa0(SP), CX		
  0x43c07b		488b942438020000	MOVQ 0x238(SP), DX		
  0x43c083		8b5c2444		MOVL 0x44(SP), BX		
					for ix != -1 {
  0x43c087		e971010000		JMP 0x43c1fd		
  0x43c08c		48898c24b8000000	MOVQ CX, 0xb8(SP)	
  0x43c094		4889942468020000	MOVQ DX, 0x268(SP)	
  0x43c09c		895c244c		MOVL BX, 0x4c(SP)	
						name := funcnameFromNameoff(f, inltree[ix].func_)
  0x43c0a0		48c1e004		SHLQ $0x4, AX				
  0x43c0a4		48898424b0000000	MOVQ AX, 0xb0(SP)			
  0x43c0ac		488b8c2470020000	MOVQ 0x270(SP), CX			
  0x43c0b4		8b54010c		MOVL 0xc(CX)(AX*1), DX			
  0x43c0b8		89542410		MOVL DX, 0x10(SP)			
  0x43c0bc		488b942480020000	MOVQ 0x280(SP), DX			
  0x43c0c4		48891424		MOVQ DX, 0(SP)				
  0x43c0c8		488b9c2488020000	MOVQ 0x288(SP), BX			
  0x43c0d0		48895c2408		MOVQ BX, 0x8(SP)			
  0x43c0d5		e8a6c8ffff		CALL runtime.funcnameFromNameoff(SB)	
  0x43c0da		488b442420		MOVQ 0x20(SP), AX			
  0x43c0df		4889842480000000	MOVQ AX, 0x80(SP)			
  0x43c0e7		488b4c2418		MOVQ 0x18(SP), CX			
  0x43c0ec		48898c2410020000	MOVQ CX, 0x210(SP)			
						print(name, "(...)\n")
  0x43c0f4		e8075afeff		CALL runtime.printlock(SB)	
  0x43c0f9		488b842410020000	MOVQ 0x210(SP), AX		
  0x43c101		48890424		MOVQ AX, 0(SP)			
  0x43c105		488b842480000000	MOVQ 0x80(SP), AX		
  0x43c10d		4889442408		MOVQ AX, 0x8(SP)		
  0x43c112		e82963feff		CALL runtime.printstring(SB)	
  0x43c117		488d0511dd0200		LEAQ 0x2dd11(IP), AX		
  0x43c11e		48890424		MOVQ AX, 0(SP)			
  0x43c122		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x43c12b		e81063feff		CALL runtime.printstring(SB)	
  0x43c130		e84b5afeff		CALL runtime.printunlock(SB)	
						print("\t", file, ":", line, "\n")
  0x43c135		e8c659feff		CALL runtime.printlock(SB)	
  0x43c13a		488d051ddb0200		LEAQ 0x2db1d(IP), AX		
  0x43c141		48890424		MOVQ AX, 0(SP)			
  0x43c145		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43c14e		e8ed62feff		CALL runtime.printstring(SB)	
  0x43c153		488b842468020000	MOVQ 0x268(SP), AX		
  0x43c15b		48890424		MOVQ AX, 0(SP)			
  0x43c15f		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x43c167		4889442408		MOVQ AX, 0x8(SP)		
  0x43c16c		e8cf62feff		CALL runtime.printstring(SB)	
  0x43c171		488d05e0da0200		LEAQ 0x2dae0(IP), AX		
  0x43c178		48890424		MOVQ AX, 0(SP)			
  0x43c17c		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43c185		e8b662feff		CALL runtime.printstring(SB)	
  0x43c18a		8b44244c		MOVL 0x4c(SP), AX		
  0x43c18e		4863c0			MOVSXD AX, AX			
  0x43c191		48890424		MOVQ AX, 0(SP)			
  0x43c195		e8e660feff		CALL runtime.printint(SB)	
  0x43c19a		e8f15bfeff		CALL runtime.printnl(SB)	
  0x43c19f		e8dc59feff		CALL runtime.printunlock(SB)	
  0x43c1a4		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x43c1ac		488b8c2470020000	MOVQ 0x270(SP), CX		
						file = funcfile(f, inltree[ix].file)
  0x43c1b4		8b540104		MOVL 0x4(CX)(AX*1), DX		
  0x43c1b8		89542410		MOVL DX, 0x10(SP)		
  0x43c1bc		488b942480020000	MOVQ 0x280(SP), DX		
  0x43c1c4		48891424		MOVQ DX, 0(SP)			
  0x43c1c8		488b9c2488020000	MOVQ 0x288(SP), BX		
  0x43c1d0		48895c2408		MOVQ BX, 0x8(SP)		
  0x43c1d5		e836c8ffff		CALL runtime.funcfile(SB)	
  0x43c1da		488b4c2420		MOVQ 0x20(SP), CX		
  0x43c1df		488b542418		MOVQ 0x18(SP), DX		
  0x43c1e4		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x43c1ec		488b9c2470020000	MOVQ 0x270(SP), BX		
						line = inltree[ix].line
  0x43c1f4		8b740308		MOVL 0x8(BX)(AX*1), SI	
						ix = inltree[ix].parent
  0x43c1f8		8b0403			MOVL 0(BX)(AX*1), AX	
  0x43c1fb		89f3			MOVL SI, BX		
					for ix != -1 {
  0x43c1fd		83f8ff			CMPL $-0x1, AX		
  0x43c200		7414			JE 0x43c216		
						name := funcnameFromNameoff(f, inltree[ix].func_)
  0x43c202		4863c0			MOVSXD AX, AX		
  0x43c205		483d00001000		CMPQ $0x100000, AX	
  0x43c20b		0f827bfeffff		JB 0x43c08c		
  0x43c211		e9b90c0000		JMP 0x43cecf		
  0x43c216		488b442478		MOVQ 0x78(SP), AX	
	return !(name == "runtime.gopanic" || name == "runtime.sigpanic" || name == "runtime.panicwrap")
  0x43c21b		4883f80f		CMPQ $0xf, AX		
  0x43c21f		4889ce			MOVQ CX, SI		
  0x43c222		4889d1			MOVQ DX, CX		
  0x43c225		4889f2			MOVQ SI, DX		
				if name == "runtime.gopanic" {
  0x43c228		e9f9f9ffff		JMP 0x43bc26		
					tracepc--
  0x43c22d		48ffcf			DECQ DI			
  0x43c230		e95ef9ffff		JMP 0x43bb93		
				if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43c235		0fbae601		BTL $0x1, SI		
  0x43c239		0f8335f9ffff		JAE 0x43bb74		
  0x43c23f		4c8b8c2480020000	MOVQ 0x280(SP), R9	
  0x43c247		e947f9ffff		JMP 0x43bb93		
  0x43c24c		488bbc2480020000	MOVQ 0x280(SP), DI	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, elideWrapper && nprint != 0) {
  0x43c254		48893c24		MOVQ DI, 0(SP)			
  0x43c258		4c8b842488020000	MOVQ 0x288(SP), R8		
  0x43c260		4c89442408		MOVQ R8, 0x8(SP)		
  0x43c265		4c8b8c2420030000	MOVQ 0x320(SP), R9		
  0x43c26d		4c894c2410		MOVQ R9, 0x10(SP)		
  0x43c272		4c8b542468		MOVQ 0x68(SP), R10		
  0x43c277		4d85d2			TESTQ R10, R10			
  0x43c27a		4c8b9c2498020000	MOVQ 0x298(SP), R11		
  0x43c282		410f9403		SETE 0(R11)			
  0x43c286		440fb6642440		MOVZX 0x40(SP), R12		
  0x43c28c		4584e4			TESTL R12, R12			
  0x43c28f		744d			JE 0x43c2de			
  0x43c291		4d85d2			TESTQ R10, R10			
  0x43c294		410f95c4		SETNE R12			
  0x43c298		4488642419		MOVB R12, 0x19(SP)		
  0x43c29d		e8ee170000		CALL runtime.showframe(SB)	
  0x43c2a2		0fb6442420		MOVZX 0x20(SP), AX		
  0x43c2a7		84c0			TESTL AL, AL			
  0x43c2a9		750a			JNE 0x43c2b5			
  0x43c2ab		488b442468		MOVQ 0x68(SP), AX		
			elideWrapper = nextElideWrapper
  0x43c2b0		e996fcffff		JMP 0x43bf4b			
  0x43c2b5		488b842408020000	MOVQ 0x208(SP), AX		
  0x43c2bd		488b4c2478		MOVQ 0x78(SP), CX		
  0x43c2c2		0fb6542442		MOVZX 0x42(SP), DX		
  0x43c2c7		48bb72756e74696d652e	MOVQ $0x2e656d69746e7572, BX	
  0x43c2d1		488bb42450030000	MOVQ 0x350(SP), SI		
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, elideWrapper && nprint != 0) {
  0x43c2d9		e97df8ffff		JMP 0x43bb5b		
  0x43c2de		4531e4			XORL R12, R12		
  0x43c2e1		ebb5			JMP 0x43c298		
	return !(name == "runtime.gopanic" || name == "runtime.sigpanic" || name == "runtime.panicwrap")
  0x43c2e3		4883f910		CMPQ $0x10, CX			
  0x43c2e7		0f858a000000		JNE 0x43c377			
  0x43c2ed		488b10			MOVQ 0(AX), DX			
  0x43c2f0		4839d3			CMPQ DX, BX			
  0x43c2f3		7574			JNE 0x43c369			
  0x43c2f5		488b5008		MOVQ 0x8(AX), DX		
  0x43c2f9		48be73696770616e6963	MOVQ $0x63696e6170676973, SI	
  0x43c303		4839d6			CMPQ DX, SI			
  0x43c306		0f94c2			SETE DL				
  0x43c309		84d2			TESTL DL, DL			
  0x43c30b		740a			JE 0x43c317			
  0x43c30d		ba01000000		MOVL $0x1, DX			
  0x43c312		e92ef8ffff		JMP 0x43bb45			
  0x43c317		4883f911		CMPQ $0x11, CX			
  0x43c31b		7407			JE 0x43c324			
  0x43c31d		31d2			XORL DX, DX			
  0x43c31f		e921f8ffff		JMP 0x43bb45			
  0x43c324		48890424		MOVQ AX, 0(SP)			
  0x43c328		488d1561e90200		LEAQ 0x2e961(IP), DX		
  0x43c32f		4889542408		MOVQ DX, 0x8(SP)		
  0x43c334		48894c2410		MOVQ CX, 0x10(SP)		
  0x43c339		e802a00000		CALL runtime.memequal(SB)	
  0x43c33e		0fb6542418		MOVZX 0x18(SP), DX		
  0x43c343		488b842408020000	MOVQ 0x208(SP), AX		
  0x43c34b		488b4c2478		MOVQ 0x78(SP), CX		
  0x43c350		48bb72756e74696d652e	MOVQ $0x2e656d69746e7572, BX	
  0x43c35a		48be73696770616e6963	MOVQ $0x63696e6170676973, SI	
  0x43c364		e9dcf7ffff		JMP 0x43bb45			
  0x43c369		48be73696770616e6963	MOVQ $0x63696e6170676973, SI	
  0x43c373		31d2			XORL DX, DX			
  0x43c375		eb92			JMP 0x43c309			
  0x43c377		48be73696770616e6963	MOVQ $0x63696e6170676973, SI	
  0x43c381		31d2			XORL DX, DX			
  0x43c383		eb84			JMP 0x43c309			
  0x43c385		48bb72756e74696d652e	MOVQ $0x2e656d69746e7572, BX	
  0x43c38f		e94fffffff		JMP 0x43c2e3			
				tracepc := frame.pc
  0x43c394		4c8bac24b0020000	MOVQ 0x2b0(SP), R13	
				if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43c39c		4885c9			TESTQ CX, CX		
  0x43c39f		0f8e3a020000		JLE 0x43c5df		
  0x43c3a5		4d8b3424		MOVQ 0(R12), R14	
  0x43c3a9		4d39f5			CMPQ R14, R13		
  0x43c3ac		7608			JBE 0x43c3b6		
		if waspanic {
  0x43c3ae		84d2			TESTL DL, DL		
				if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43c3b0		0f8421020000		JE 0x43c5d7		
  0x43c3b6		4c896c2458		MOVQ R13, 0x58(SP)	
				inldata := funcdata(f, _FUNCDATA_InlTree)
  0x43c3bb		4c892424		MOVQ R12, 0(SP)			
  0x43c3bf		488b842488020000	MOVQ 0x288(SP), AX		
  0x43c3c7		4889442408		MOVQ AX, 0x8(SP)		
  0x43c3cc		c744241002000000	MOVL $0x2, 0x10(SP)		
  0x43c3d4		e817cbffff		CALL runtime.funcdata(SB)	
  0x43c3d9		488b442418		MOVQ 0x18(SP), AX		
				if inldata == nil {
  0x43c3de		4885c0			TESTQ AX, AX		
  0x43c3e1		7561			JNE 0x43c444		
  0x43c3e3		4c8bac2428030000	MOVQ 0x328(SP), R13	
					skip--
  0x43c3eb		4d8d45ff		LEAQ -0x1(R13), R8	
  0x43c3ef		488b842440030000	MOVQ 0x340(SP), AX	
  0x43c3f7		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43c3ff		488bbc2478020000	MOVQ 0x278(SP), DI	
  0x43c407		4c8b942458020000	MOVQ 0x258(SP), R10	
  0x43c40f		4c8b9c2430030000	MOVQ 0x330(SP), R11	
  0x43c417		4c8ba42480020000	MOVQ 0x280(SP), R12	
  0x43c41f		440fb6742441		MOVZX 0x41(SP), R14	
  0x43c425		4c8bbc2448020000	MOVQ 0x248(SP), R15	
  0x43c42d		0fb65c2440		MOVZX 0x40(SP), BX	
  0x43c432		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x43c437		488b8c2488000000	MOVQ 0x88(SP), CX	
					goto skipped
  0x43c43f		e97ff1ffff		JMP 0x43b5c3		
  0x43c444		4889842470020000	MOVQ AX, 0x270(SP)	
  0x43c44c		488b842480020000	MOVQ 0x280(SP), AX	
				ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, &cache)
  0x43c454		48890424		MOVQ AX, 0(SP)			
  0x43c458		488b8c2488020000	MOVQ 0x288(SP), CX		
  0x43c460		48894c2408		MOVQ CX, 0x8(SP)		
  0x43c465		c744241001000000	MOVL $0x1, 0x10(SP)		
  0x43c46d		488b542458		MOVQ 0x58(SP), DX		
  0x43c472		4889542418		MOVQ DX, 0x18(SP)		
  0x43c477		488d942408010000	LEAQ 0x108(SP), DX		
  0x43c47f		4889542420		MOVQ DX, 0x20(SP)		
  0x43c484		e8b7c9ffff		CALL runtime.pcdatavalue(SB)	
  0x43c489		8b442428		MOVL 0x28(SP), AX		
  0x43c48d		488b8c2470020000	MOVQ 0x270(SP), CX		
  0x43c495		488b942428030000	MOVQ 0x328(SP), DX		
  0x43c49d		31db			XORL BX, BX			
				for ix >= 0 && skip > 0 {
  0x43c49f		eb0d			JMP 0x43c4ae		
					skip--
  0x43c4a1		48ffca			DECQ DX			
					logicalSkipped++
  0x43c4a4		48ffc3			INCQ BX			
					ix = inltree[ix].parent
  0x43c4a7		48c1e004		SHLQ $0x4, AX		
  0x43c4ab		8b0401			MOVL 0(CX)(AX*1), AX	
				for ix >= 0 && skip > 0 {
  0x43c4ae		85c0			TESTL AX, AX		
  0x43c4b0		7c15			JL 0x43c4c7		
  0x43c4b2		4885d2			TESTQ DX, DX		
  0x43c4b5		7e10			JLE 0x43c4c7		
					ix = inltree[ix].parent
  0x43c4b7		4863c0			MOVSXD AX, AX		
  0x43c4ba		483d00001000		CMPQ $0x100000, AX	
  0x43c4c0		72df			JB 0x43c4a1		
  0x43c4c2		e91d0a0000		JMP 0x43cee4		
				if skip > 0 {
  0x43c4c7		4885d2			TESTQ DX, DX		
  0x43c4ca		7e59			JLE 0x43c525		
					skip--
  0x43c4cc		4c8d42ff		LEAQ -0x1(DX), R8	
  0x43c4d0		488b842440030000	MOVQ 0x340(SP), AX	
  0x43c4d8		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43c4e0		488bbc2478020000	MOVQ 0x278(SP), DI	
  0x43c4e8		4c8b942458020000	MOVQ 0x258(SP), R10	
  0x43c4f0		4c8b9c2430030000	MOVQ 0x330(SP), R11	
  0x43c4f8		4c8ba42480020000	MOVQ 0x280(SP), R12	
  0x43c500		440fb6742441		MOVZX 0x41(SP), R14	
  0x43c506		4c8bbc2448020000	MOVQ 0x248(SP), R15	
  0x43c50e		0fb65c2440		MOVZX 0x40(SP), BX	
  0x43c513		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x43c518		488b8c2488000000	MOVQ 0x88(SP), CX	
					goto skipped
  0x43c520		e99ef0ffff		JMP 0x43b5c3		
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = frame.pc
  0x43c525		488b8424b0020000	MOVQ 0x2b0(SP), AX	
  0x43c52d		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x43c535		4881f900001000		CMPQ $0x100000, CX	
  0x43c53c		0f839b090000		JAE 0x43cedd		
  0x43c542		488bb42430030000	MOVQ 0x330(SP), SI	
  0x43c54a		488904ce		MOVQ AX, 0(SI)(CX*8)	
				if n+1 < max {
  0x43c54e		488d4101		LEAQ 0x1(CX), AX	
  0x43c552		488bbc2438030000	MOVQ 0x338(SP), DI	
  0x43c55a		4839f8			CMPQ DI, AX		
  0x43c55d		7d73			JGE 0x43c5d2		
					pc := skipPC + uintptr(logicalSkipped)
  0x43c55f		4c8b0562740800		MOVQ runtime.skipPC(SB), R8	
  0x43c566		4c01c3			ADDQ R8, BX			
					(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43c569		483d00001000		CMPQ $0x100000, AX	
  0x43c56f		0f8361090000		JAE 0x43ced6		
  0x43c575		48895cce08		MOVQ BX, 0x8(SI)(CX*8)	
  0x43c57a		0fb65c2440		MOVZX 0x40(SP), BX	
  0x43c57f		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43c587		488bbc2478020000	MOVQ 0x278(SP), DI	
  0x43c58f		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x43c594		4c8b942458020000	MOVQ 0x258(SP), R10	
  0x43c59c		4c8b9c2430030000	MOVQ 0x330(SP), R11	
  0x43c5a4		4c8ba42480020000	MOVQ 0x280(SP), R12	
  0x43c5ac		440fb6742441		MOVZX 0x41(SP), R14	
  0x43c5b2		4c8bbc2448020000	MOVQ 0x248(SP), R15	
  0x43c5ba		4889c1			MOVQ AX, CX		
  0x43c5bd		4989d0			MOVQ DX, R8		
  0x43c5c0		488b842440030000	MOVQ 0x340(SP), AX	
  0x43c5c8		0fb654243f		MOVZX 0x3f(SP), DX	
		if printing {
  0x43c5cd		e9e5efffff		JMP 0x43b5b7		
  0x43c5d2		4889c8			MOVQ CX, AX		
				if n+1 < max {
  0x43c5d5		eba3			JMP 0x43c57a		
					tracepc--
  0x43c5d7		49ffcd			DECQ R13		
  0x43c5da		e9d7fdffff		JMP 0x43c3b6		
  0x43c5df		4c8bb42450030000	MOVQ 0x350(SP), R14	
				if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43c5e7		410fbae601		BTL $0x1, R14		
  0x43c5ec		0f82c4fdffff		JB 0x43c3b6		
  0x43c5f2		440fb6742441		MOVZX 0x41(SP), R14	
  0x43c5f8		e9a8fdffff		JMP 0x43c3a5		
			if !callback((*stkframe)(noescape(unsafe.Pointer(&frame))), v) {
  0x43c5fd		488d8c24a0020000	LEAQ 0x2a0(SP), CX	
  0x43c605		48890c24		MOVQ CX, 0(SP)		
  0x43c609		488b9c2448030000	MOVQ 0x348(SP), BX	
  0x43c611		48895c2408		MOVQ BX, 0x8(SP)	
  0x43c616		488b30			MOVQ 0(AX), SI		
  0x43c619		4889c2			MOVQ AX, DX		
  0x43c61c		ffd6			CALL SI			
  0x43c61e		0fb6442410		MOVZX 0x10(SP), AX	
  0x43c623		84c0			TESTL AL, AL		
  0x43c625		7465			JE 0x43c68c		
  0x43c627		4c8b9c2430030000	MOVQ 0x330(SP), R11	
	printing := pcbuf == nil && callback == nil
  0x43c62f		4d85db			TESTQ R11, R11		
  0x43c632		488b842440030000	MOVQ 0x340(SP), AX	
  0x43c63a		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x43c642		0fb654243f		MOVZX 0x3f(SP), DX	
  0x43c647		0fb65c2440		MOVZX 0x40(SP), BX	
  0x43c64c		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43c654		488bbc2478020000	MOVQ 0x278(SP), DI	
  0x43c65c		4c8b842428030000	MOVQ 0x328(SP), R8	
  0x43c664		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x43c669		4c8b942458020000	MOVQ 0x258(SP), R10	
  0x43c671		4c8ba42480020000	MOVQ 0x280(SP), R12	
  0x43c679		440fb6742441		MOVZX 0x41(SP), R14	
  0x43c67f		4c8bbc2448020000	MOVQ 0x248(SP), R15	
		if pcbuf != nil {
  0x43c687		e907efffff		JMP 0x43b593		
				return n
  0x43c68c		488b842488000000	MOVQ 0x88(SP), AX	
  0x43c694		4889842458030000	MOVQ AX, 0x358(SP)	
  0x43c69c		488bac24f8020000	MOVQ 0x2f8(SP), BP	
  0x43c6a4		4881c400030000		ADDQ $0x300, SP		
  0x43c6ab		c3			RET			
		if callback != nil || printing {
  0x43c6ac		4885c0			TESTQ AX, AX		
		for _defer != nil && (_defer.sp == frame.sp || _defer.sp == _NoArgs) {
  0x43c6af		e9c6eeffff		JMP 0x43b57a		
				frame.continpc = 0
  0x43c6b4		48c78424b802000000000000	MOVQ $0x0, 0x2b8(SP)	
  0x43c6c0		e992eeffff			JMP 0x43b557		
			frame.argp = frame.fp + sys.MinFrameSize
  0x43c6c5		488b8424d0020000	MOVQ 0x2d0(SP), AX	
  0x43c6cd		48898424e0020000	MOVQ AX, 0x2e0(SP)	
			frame.arglen, frame.argmap = getArgInfo(&frame, f, callback != nil, nil)
  0x43c6d5		488d8424a0020000	LEAQ 0x2a0(SP), AX		
  0x43c6dd		48890424		MOVQ AX, 0(SP)			
  0x43c6e1		4c89642408		MOVQ R12, 0x8(SP)		
  0x43c6e6		4c896c2410		MOVQ R13, 0x10(SP)		
  0x43c6eb		44885c2418		MOVB R11, 0x18(SP)		
  0x43c6f0		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43c6f9		e872080000		CALL runtime.getArgInfo(SB)	
  0x43c6fe		488b442428		MOVQ 0x28(SP), AX		
  0x43c703		488b4c2430		MOVQ 0x30(SP), CX		
  0x43c708		48898424e8020000	MOVQ AX, 0x2e8(SP)		
  0x43c710		48898c24f0020000	MOVQ CX, 0x2f0(SP)		
  0x43c718		488b842440030000	MOVQ 0x340(SP), AX		
  0x43c720		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x43c728		0fb654243f		MOVZX 0x3f(SP), DX		
  0x43c72d		0fb65c2440		MOVZX 0x40(SP), BX		
  0x43c732		488bb424a8000000	MOVQ 0xa8(SP), SI		
  0x43c73a		488bbc2478020000	MOVQ 0x278(SP), DI		
  0x43c742		4c8b842428030000	MOVQ 0x328(SP), R8		
  0x43c74a		4c8b4c2468		MOVQ 0x68(SP), R9		
  0x43c74f		4c8b942490020000	MOVQ 0x290(SP), R10		
  0x43c757		4c8ba42480020000	MOVQ 0x280(SP), R12		
  0x43c75f		4c8bac2488020000	MOVQ 0x288(SP), R13		
  0x43c767		440fb6742441		MOVZX 0x41(SP), R14		
  0x43c76d		4c8bbc2448020000	MOVQ 0x248(SP), R15		
  0x43c775		e938f0ffff		JMP 0x43b7b2			
				if frame.lr == 0 {
  0x43c77a		488b8424c0020000	MOVQ 0x2c0(SP), AX	
  0x43c782		4885c0			TESTQ AX, AX		
  0x43c785		0f8555020000		JNE 0x43c9e0		
					lrPtr = frame.fp - sys.RegSize
  0x43c78b		488b8424d0020000	MOVQ 0x2d0(SP), AX	
  0x43c793		4883c0f8		ADDQ $-0x8, AX		
  0x43c797		4989c7			MOVQ AX, R15		
					frame.lr = uintptr(*(*sys.Uintreg)(unsafe.Pointer(lrPtr)))
  0x43c79a		488b00			MOVQ 0(AX), AX		
  0x43c79d		48898424c0020000	MOVQ AX, 0x2c0(SP)	
  0x43c7a5		4c89bc2490000000	MOVQ R15, 0x90(SP)	
			flr = findfunc(frame.lr)
  0x43c7ad		488b8424c0020000	MOVQ 0x2c0(SP), AX		
  0x43c7b5		48890424		MOVQ AX, 0(SP)			
  0x43c7b9		e812baffff		CALL runtime.findfunc(SB)	
  0x43c7be		488b442410		MOVQ 0x10(SP), AX		
  0x43c7c3		488b4c2408		MOVQ 0x8(SP), CX		
	return f._func != nil
  0x43c7c8		4885c9			TESTQ CX, CX		
			if !flr.valid() {
  0x43c7cb		745f			JE 0x43c82c		
  0x43c7cd		0fb654243f		MOVZX 0x3f(SP), DX	
  0x43c7d2		0fb65c2440		MOVZX 0x40(SP), BX	
  0x43c7d7		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43c7df		488bbc2478020000	MOVQ 0x278(SP), DI	
  0x43c7e7		4c8b842428030000	MOVQ 0x328(SP), R8	
  0x43c7ef		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x43c7f4		4c8b942490020000	MOVQ 0x290(SP), R10	
  0x43c7fc		4c8b9c2438030000	MOVQ 0x338(SP), R11	
  0x43c804		4c8ba42480020000	MOVQ 0x280(SP), R12	
  0x43c80c		4c8bac2488020000	MOVQ 0x288(SP), R13	
  0x43c814		4c8bb42420030000	MOVQ 0x320(SP), R14	
  0x43c81c		4989cf			MOVQ CX, R15		
  0x43c81f		488b8c2488000000	MOVQ 0x88(SP), CX	
		frame.varp = frame.fp
  0x43c827		e91aefffff		JMP 0x43b746		
  0x43c82c		0fb65c2441		MOVZX 0x41(SP), BX	
	printing := pcbuf == nil && callback == nil
  0x43c831		84db			TESTL BL, BL		
				if doPrint && gp.m.incgo && f.funcID == funcID_sigpanic {
  0x43c833		0f8490010000		JE 0x43c9c9		
  0x43c839		488bb42420030000	MOVQ 0x320(SP), SI	
  0x43c841		488b7e30		MOVQ 0x30(SI), DI	
  0x43c845		0fb6bf19010000		MOVZX 0x119(DI), DI	
  0x43c84c		4084ff			TESTL DI, DI		
  0x43c84f		0f846a010000		JE 0x43c9bf		
  0x43c855		488bbc2480020000	MOVQ 0x280(SP), DI	
  0x43c85d		448b4710		MOVL 0x10(DI), R8	
  0x43c861		4183f808		CMPL $0x8, R8		
  0x43c865		0f854d010000		JNE 0x43c9b8		
  0x43c86b		31d2			XORL DX, DX		
				if callback != nil || doPrint {
  0x43c86d		4889842428020000	MOVQ AX, 0x228(SP)	
  0x43c875		48898c2430020000	MOVQ CX, 0x230(SP)	
  0x43c87d		4c8b842440030000	MOVQ 0x340(SP), R8	
  0x43c885		4d85c0			TESTQ R8, R8		
  0x43c888		7512			JNE 0x43c89c		
  0x43c88a		84d2			TESTL DL, DL		
  0x43c88c		750e			JNE 0x43c89c		
  0x43c88e		4d85c0			TESTQ R8, R8		
				if callback != nil {
  0x43c891		0f855b060000		JNE 0x43cef2		
  0x43c897		e931ffffff		JMP 0x43c7cd		
					print("runtime: unexpected return pc for ", funcname(f), " called from ", hex(frame.lr), "\n")
  0x43c89c		48893c24		MOVQ DI, 0(SP)			
  0x43c8a0		488b842488020000	MOVQ 0x288(SP), AX		
  0x43c8a8		4889442408		MOVQ AX, 0x8(SP)		
  0x43c8ad		e84ec0ffff		CALL runtime.funcname(SB)	
  0x43c8b2		488b442418		MOVQ 0x18(SP), AX		
  0x43c8b7		48898424c8000000	MOVQ AX, 0xc8(SP)		
  0x43c8bf		488b4c2410		MOVQ 0x10(SP), CX		
  0x43c8c4		48898c2460020000	MOVQ CX, 0x260(SP)		
  0x43c8cc		488b9424c0020000	MOVQ 0x2c0(SP), DX		
  0x43c8d4		48899424f8000000	MOVQ DX, 0xf8(SP)		
  0x43c8dc		e81f52feff		CALL runtime.printlock(SB)	
  0x43c8e1		488d0578030300		LEAQ 0x30378(IP), AX		
  0x43c8e8		48890424		MOVQ AX, 0(SP)			
  0x43c8ec		48c744240822000000	MOVQ $0x22, 0x8(SP)		
  0x43c8f5		e8465bfeff		CALL runtime.printstring(SB)	
  0x43c8fa		488b842460020000	MOVQ 0x260(SP), AX		
  0x43c902		48890424		MOVQ AX, 0(SP)			
  0x43c906		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x43c90e		4889442408		MOVQ AX, 0x8(SP)		
  0x43c913		e8285bfeff		CALL runtime.printstring(SB)	
  0x43c918		488d0545dd0200		LEAQ 0x2dd45(IP), AX		
  0x43c91f		48890424		MOVQ AX, 0(SP)			
  0x43c923		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x43c92c		e80f5bfeff		CALL runtime.printstring(SB)	
  0x43c931		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43c939		48890424		MOVQ AX, 0(SP)			
  0x43c93d		e8ae59feff		CALL runtime.printhex(SB)	
  0x43c942		e84954feff		CALL runtime.printnl(SB)	
  0x43c947		e83452feff		CALL runtime.printunlock(SB)	
  0x43c94c		488b842420030000	MOVQ 0x320(SP), AX		
					tracebackHexdump(gp.stack, &frame, lrPtr)
  0x43c954		488b4808		MOVQ 0x8(AX), CX			
  0x43c958		488b10			MOVQ 0(AX), DX				
  0x43c95b		48891424		MOVQ DX, 0(SP)				
  0x43c95f		48894c2408		MOVQ CX, 0x8(SP)			
  0x43c964		488d8c24a0020000	LEAQ 0x2a0(SP), CX			
  0x43c96c		48894c2410		MOVQ CX, 0x10(SP)			
  0x43c971		488b942490000000	MOVQ 0x90(SP), DX			
  0x43c979		4889542418		MOVQ DX, 0x18(SP)			
  0x43c97e		e89d180000		CALL runtime.tracebackHexdump(SB)	
  0x43c983		4c8b842440030000	MOVQ 0x340(SP), R8			
				if callback != nil || doPrint {
  0x43c98b		4d85c0			TESTQ R8, R8		
  0x43c98e		488b842428020000	MOVQ 0x228(SP), AX	
  0x43c996		488b8c2430020000	MOVQ 0x230(SP), CX	
  0x43c99e		0fb65c2441		MOVZX 0x41(SP), BX	
  0x43c9a3		488bb42420030000	MOVQ 0x320(SP), SI	
  0x43c9ab		488bbc2480020000	MOVQ 0x280(SP), DI	
					tracebackHexdump(gp.stack, &frame, lrPtr)
  0x43c9b3		e9d9feffff		JMP 0x43c891		
  0x43c9b8		89da			MOVL BX, DX		
				if doPrint && gp.m.incgo && f.funcID == funcID_sigpanic {
  0x43c9ba		e9aefeffff		JMP 0x43c86d		
  0x43c9bf		488bbc2480020000	MOVQ 0x280(SP), DI	
  0x43c9c7		ebef			JMP 0x43c9b8		
  0x43c9c9		488bb42420030000	MOVQ 0x320(SP), SI	
  0x43c9d1		488bbc2480020000	MOVQ 0x280(SP), DI	
  0x43c9d9		31d2			XORL DX, DX		
  0x43c9db		e98dfeffff		JMP 0x43c86d		
  0x43c9e0		4531ff			XORL R15, R15		
				if frame.lr == 0 {
  0x43c9e3		e9bdfdffff		JMP 0x43c7a5		
		f.funcID == funcID_mstart ||
  0x43c9e8		83f805			CMPL $0x5, AX		
  0x43c9eb		750a			JNE 0x43c9f7		
  0x43c9ed		b801000000		MOVL $0x1, AX		
  0x43c9f2		e926edffff		JMP 0x43b71d		
		f.funcID == funcID_mcall ||
  0x43c9f7		83f803			CMPL $0x3, AX		
  0x43c9fa		750a			JNE 0x43ca06		
  0x43c9fc		b801000000		MOVL $0x1, AX		
  0x43ca01		e917edffff		JMP 0x43b71d		
		f.funcID == funcID_morestack ||
  0x43ca06		83f804			CMPL $0x4, AX		
  0x43ca09		750a			JNE 0x43ca15		
  0x43ca0b		b801000000		MOVL $0x1, AX		
  0x43ca10		e908edffff		JMP 0x43b71d		
		f.funcID == funcID_rt0_go ||
  0x43ca15		83f806			CMPL $0x6, AX		
  0x43ca18		750a			JNE 0x43ca24		
  0x43ca1a		b801000000		MOVL $0x1, AX		
  0x43ca1f		e9f9ecffff		JMP 0x43b71d		
		f.funcID == funcID_externalthreadhandler ||
  0x43ca24		83f812			CMPL $0x12, AX		
  0x43ca27		750a			JNE 0x43ca33		
  0x43ca29		b801000000		MOVL $0x1, AX		
  0x43ca2e		e9eaecffff		JMP 0x43b71d		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43ca33		4584ff			TESTL R15, R15		
		(g0 && f.funcID == funcID_asmcgocall)
  0x43ca36		740b			JE 0x43ca43		
  0x43ca38		83f807			CMPL $0x7, AX		
  0x43ca3b		0f94c0			SETE AL			
  0x43ca3e		e9daecffff		JMP 0x43b71d		
  0x43ca43		31c0			XORL AX, AX		
  0x43ca45		e9d3ecffff		JMP 0x43b71d		
  0x43ca4a		4531ff			XORL R15, R15		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43ca4d		e9b8ecffff		JMP 0x43b70a		
			sp := frame.sp
  0x43ca52		4c8bb424c8020000	MOVQ 0x2c8(SP), R14	
  0x43ca5a		4c8bbc2450030000	MOVQ 0x350(SP), R15	
			if flags&_TraceJumpStack != 0 && f.funcID == funcID_systemstack && gp == g.m.g0 && gp.m.curg != nil {
  0x43ca62		410fbae702		BTL $0x2, R15		
  0x43ca67		0f834a010000		JAE 0x43cbb7		
  0x43ca6d		418b442410		MOVL 0x10(R12), AX	
  0x43ca72		83f80f			CMPL $0xf, AX		
  0x43ca75		0f852b010000		JNE 0x43cba6		
  0x43ca7b		488b842420020000	MOVQ 0x220(SP), AX	
  0x43ca83		488b4030		MOVQ 0x30(AX), AX	
  0x43ca87		488b00			MOVQ 0(AX), AX		
  0x43ca8a		4c8bbc2420030000	MOVQ 0x320(SP), R15	
  0x43ca92		4c39f8			CMPQ R15, AX		
  0x43ca95		0f85fa000000		JNE 0x43cb95		
  0x43ca9b		498b4730		MOVQ 0x30(R15), AX	
  0x43ca9f		488b80c0000000		MOVQ 0xc0(AX), AX	
  0x43caa6		4885c0			TESTQ AX, AX		
  0x43caa9		0f84d5000000		JE 0x43cb84		
				sp = gp.m.curg.sched.sp
  0x43caaf		488b4038		MOVQ 0x38(AX), AX	
				frame.sp = sp
  0x43cab3		48898424c8020000	MOVQ AX, 0x2c8(SP)	
				cgoCtxt = gp.m.curg.cgoCtxt
  0x43cabb		498b7730		MOVQ 0x30(R15), SI	
  0x43cabf		488bb6c0000000		MOVQ 0xc0(SI), SI	
  0x43cac6		488bbe48010000		MOVQ 0x148(SI), DI	
  0x43cacd		488bb640010000		MOVQ 0x140(SI), SI	
  0x43cad4		4889442460		MOVQ AX, 0x60(SP)	
  0x43cad9		4889bc24a8000000	MOVQ DI, 0xa8(SP)	
  0x43cae1		4889b42478020000	MOVQ SI, 0x278(SP)	
			frame.fp = sp + uintptr(funcspdelta(f, frame.pc, &cache))
  0x43cae9		4c892424		MOVQ R12, 0(SP)			
  0x43caed		4c896c2408		MOVQ R13, 0x8(SP)		
  0x43caf2		488b8c24b0020000	MOVQ 0x2b0(SP), CX		
  0x43cafa		48894c2410		MOVQ CX, 0x10(SP)		
  0x43caff		488d8c2408010000	LEAQ 0x108(SP), CX		
  0x43cb07		48894c2418		MOVQ CX, 0x18(SP)		
  0x43cb0c		e8bfc1ffff		CALL runtime.funcspdelta(SB)	
  0x43cb11		4863442420		MOVSXD 0x20(SP), AX		
  0x43cb16		488b4c2460		MOVQ 0x60(SP), CX		
				frame.fp += sys.RegSize
  0x43cb1b		488d440808		LEAQ 0x8(AX)(CX*1), AX	
  0x43cb20		48898424d0020000	MOVQ AX, 0x2d0(SP)	
  0x43cb28		488b842498020000	MOVQ 0x298(SP), AX	
  0x43cb30		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x43cb38		0fb654243f		MOVZX 0x3f(SP), DX	
  0x43cb3d		0fb65c2440		MOVZX 0x40(SP), BX	
  0x43cb42		4c8b842428030000	MOVQ 0x328(SP), R8	
  0x43cb4a		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x43cb4f		4c8b942490020000	MOVQ 0x290(SP), R10	
  0x43cb57		4c8b9c2438030000	MOVQ 0x338(SP), R11	
  0x43cb5f		4c8ba42480020000	MOVQ 0x280(SP), R12	
  0x43cb67		4c8bac2488020000	MOVQ 0x288(SP), R13	
  0x43cb6f		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43cb77		488bbc2478020000	MOVQ 0x278(SP), DI	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43cb7f		e967ebffff		JMP 0x43b6eb		
  0x43cb84		4c89f0			MOVQ R14, AX		
  0x43cb87		4989fe			MOVQ DI, R14		
  0x43cb8a		4889f7			MOVQ SI, DI		
  0x43cb8d		4c89f6			MOVQ R14, SI		
			if flags&_TraceJumpStack != 0 && f.funcID == funcID_systemstack && gp == g.m.g0 && gp.m.curg != nil {
  0x43cb90		e93fffffff		JMP 0x43cad4		
  0x43cb95		4c89f0			MOVQ R14, AX		
  0x43cb98		4989fe			MOVQ DI, R14		
  0x43cb9b		4889f7			MOVQ SI, DI		
  0x43cb9e		4c89f6			MOVQ R14, SI		
  0x43cba1		e92effffff		JMP 0x43cad4		
  0x43cba6		4c89f0			MOVQ R14, AX		
  0x43cba9		4989fe			MOVQ DI, R14		
  0x43cbac		4889f7			MOVQ SI, DI		
  0x43cbaf		4c89f6			MOVQ R14, SI		
  0x43cbb2		e91dffffff		JMP 0x43cad4		
  0x43cbb7		4c89f0			MOVQ R14, AX		
  0x43cbba		4989fe			MOVQ DI, R14		
  0x43cbbd		4889f7			MOVQ SI, DI		
  0x43cbc0		4c89f6			MOVQ R14, SI		
  0x43cbc3		e90cffffff		JMP 0x43cad4		
  0x43cbc8		488b842440030000	MOVQ 0x340(SP), AX	
  0x43cbd0		440fb6742441		MOVZX 0x41(SP), R14	
			break
  0x43cbd6		e91eecffff		JMP 0x43b7f9		
  0x43cbdb		488b842440030000	MOVQ 0x340(SP), AX	
  0x43cbe3		440fb6742441		MOVZX 0x41(SP), R14	
	for n < max {
  0x43cbe9		e90becffff		JMP 0x43b7f9		
  0x43cbee		488b842440030000	MOVQ 0x340(SP), AX	
		if callback != nil || printing {
  0x43cbf6		4885c0			TESTQ AX, AX		
  0x43cbf9		0f84a9000000		JE 0x43cca8		
			print("runtime: unknown pc ", hex(frame.pc), "\n")
  0x43cbff		488b8424b0020000	MOVQ 0x2b0(SP), AX		
  0x43cc07		48898424f8000000	MOVQ AX, 0xf8(SP)		
  0x43cc0f		e8ec4efeff		CALL runtime.printlock(SB)	
  0x43cc14		488d05b6e50200		LEAQ 0x2e5b6(IP), AX		
  0x43cc1b		48890424		MOVQ AX, 0(SP)			
  0x43cc1f		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x43cc28		e81358feff		CALL runtime.printstring(SB)	
  0x43cc2d		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43cc35		48890424		MOVQ AX, 0(SP)			
  0x43cc39		e8b256feff		CALL runtime.printhex(SB)	
  0x43cc3e		e84d51feff		CALL runtime.printnl(SB)	
  0x43cc43		e8384ffeff		CALL runtime.printunlock(SB)	
  0x43cc48		488b842420030000	MOVQ 0x320(SP), AX		
			tracebackHexdump(gp.stack, &frame, 0)
  0x43cc50		488b4808		MOVQ 0x8(AX), CX			
  0x43cc54		488b00			MOVQ 0(AX), AX				
  0x43cc57		48890424		MOVQ AX, 0(SP)				
  0x43cc5b		48894c2408		MOVQ CX, 0x8(SP)			
  0x43cc60		488d8424a0020000	LEAQ 0x2a0(SP), AX			
  0x43cc68		4889442410		MOVQ AX, 0x10(SP)			
  0x43cc6d		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x43cc76		e8a5150000		CALL runtime.tracebackHexdump(SB)	
  0x43cc7b		488b842440030000	MOVQ 0x340(SP), AX			
		if callback != nil || printing {
  0x43cc83		4885c0			TESTQ AX, AX		
		if callback != nil {
  0x43cc86		0f8581020000		JNE 0x43cf0d		
		return 0
  0x43cc8c		48c784245803000000000000	MOVQ $0x0, 0x358(SP)	
  0x43cc98		488bac24f8020000		MOVQ 0x2f8(SP), BP	
  0x43cca0		4881c400030000			ADDQ $0x300, SP		
  0x43cca7		c3				RET			
  0x43cca8		0fb64c2441			MOVZX 0x41(SP), CX	
	printing := pcbuf == nil && callback == nil
  0x43ccad		84c9			TESTL CL, CL		
		if callback != nil || printing {
  0x43ccaf		0f854affffff		JNE 0x43cbff		
  0x43ccb5		4885c0			TESTQ AX, AX		
  0x43ccb8		ebcc			JMP 0x43cc86		
	printing := pcbuf == nil && callback == nil
  0x43ccba		4885c9			TESTQ CX, CX		
  0x43ccbd		400f94c7		SETE DI			
  0x43ccc1		e99be7ffff		JMP 0x43b461		
			pc0 = gp.sched.pc
  0x43ccc6		4c8b4b40		MOVQ 0x40(BX), R9	
			sp0 = gp.sched.sp
  0x43ccca		4c8b4338		MOVQ 0x38(BX), R8	
	var frame stkframe
  0x43ccce		e92fe7ffff		JMP 0x43b402		
  0x43ccd3		4d89c1			MOVQ R8, R9		
  0x43ccd6		4c8b842410030000	MOVQ 0x310(SP), R8	
	if pc0 == ^uintptr(0) && sp0 == ^uintptr(0) { // Signal to fetch saved values from gp.
  0x43ccde		e91fe7ffff		JMP 0x43b402		
  0x43cce3		4d89c1			MOVQ R8, R9		
  0x43cce6		4c8b842410030000	MOVQ 0x310(SP), R8	
  0x43ccee		e90fe7ffff		JMP 0x43b402		
		level = int32(t >> tracebackShift)
  0x43ccf3		c1ee02			SHRL $0x2, SI		
  0x43ccf6		e9d2e6ffff		JMP 0x43b3cd		
  0x43ccfb		488b8c2440030000	MOVQ 0x340(SP), CX	
	if skip > 0 && callback != nil {
  0x43cd03		e97ce6ffff		JMP 0x43b384		
  0x43cd08		48898424f8000000	MOVQ AX, 0xf8(SP)	
  0x43cd10		48899c24f0000000	MOVQ BX, 0xf0(SP)	
  0x43cd18		4c898c2488000000	MOVQ R9, 0x88(SP)	
		print("runtime: g", gp.goid, ": frame.sp=", hex(frame.sp), " top=", hex(gp.stktopsp), "\n")
  0x43cd20		488b8298000000		MOVQ 0x98(DX), AX		
  0x43cd27		4889842400010000	MOVQ AX, 0x100(SP)		
  0x43cd2f		e8cc4dfeff		CALL runtime.printlock(SB)	
  0x43cd34		488d0521d60200		LEAQ 0x2d621(IP), AX		
  0x43cd3b		48890424		MOVQ AX, 0(SP)			
  0x43cd3f		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43cd48		e8f356feff		CALL runtime.printstring(SB)	
  0x43cd4d		488b842400010000	MOVQ 0x100(SP), AX		
  0x43cd55		48890424		MOVQ AX, 0(SP)			
  0x43cd59		e82255feff		CALL runtime.printint(SB)	
  0x43cd5e		488d05d8d60200		LEAQ 0x2d6d8(IP), AX		
  0x43cd65		48890424		MOVQ AX, 0(SP)			
  0x43cd69		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x43cd72		e8c956feff		CALL runtime.printstring(SB)	
  0x43cd77		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43cd7f		48890424		MOVQ AX, 0(SP)			
  0x43cd83		e86855feff		CALL runtime.printhex(SB)	
  0x43cd88		488d05f7cf0200		LEAQ 0x2cff7(IP), AX		
  0x43cd8f		48890424		MOVQ AX, 0(SP)			
  0x43cd93		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43cd9c		e89f56feff		CALL runtime.printstring(SB)	
  0x43cda1		488b8424f0000000	MOVQ 0xf0(SP), AX		
  0x43cda9		48890424		MOVQ AX, 0(SP)			
  0x43cdad		e83e55feff		CALL runtime.printhex(SB)	
  0x43cdb2		e8d94ffeff		CALL runtime.printnl(SB)	
  0x43cdb7		e8c44dfeff		CALL runtime.printunlock(SB)	
  0x43cdbc		488b842420030000	MOVQ 0x320(SP), AX		
		print("\tstack=[", hex(gp.stack.lo), "-", hex(gp.stack.hi), "] n=", n, " max=", max, "\n")
  0x43cdc4		488b08			MOVQ 0(AX), CX			
  0x43cdc7		48898c24f8000000	MOVQ CX, 0xf8(SP)		
  0x43cdcf		488b4008		MOVQ 0x8(AX), AX		
  0x43cdd3		48898424f0000000	MOVQ AX, 0xf0(SP)		
  0x43cddb		e8204dfeff		CALL runtime.printlock(SB)	
  0x43cde0		488d0520d20200		LEAQ 0x2d220(IP), AX		
  0x43cde7		48890424		MOVQ AX, 0(SP)			
  0x43cdeb		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43cdf4		e84756feff		CALL runtime.printstring(SB)	
  0x43cdf9		488b8424f8000000	MOVQ 0xf8(SP), AX		
  0x43ce01		48890424		MOVQ AX, 0(SP)			
  0x43ce05		e8e654feff		CALL runtime.printhex(SB)	
  0x43ce0a		488d0544ce0200		LEAQ 0x2ce44(IP), AX		
  0x43ce11		48890424		MOVQ AX, 0(SP)			
  0x43ce15		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43ce1e		e81d56feff		CALL runtime.printstring(SB)	
  0x43ce23		488b8424f0000000	MOVQ 0xf0(SP), AX		
  0x43ce2b		48890424		MOVQ AX, 0(SP)			
  0x43ce2f		e8bc54feff		CALL runtime.printhex(SB)	
  0x43ce34		488d05c3ce0200		LEAQ 0x2cec3(IP), AX		
  0x43ce3b		48890424		MOVQ AX, 0(SP)			
  0x43ce3f		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43ce48		e8f355feff		CALL runtime.printstring(SB)	
  0x43ce4d		488b842488000000	MOVQ 0x88(SP), AX		
  0x43ce55		48890424		MOVQ AX, 0(SP)			
  0x43ce59		e82254feff		CALL runtime.printint(SB)	
  0x43ce5e		488d050dcf0200		LEAQ 0x2cf0d(IP), AX		
  0x43ce65		48890424		MOVQ AX, 0(SP)			
  0x43ce69		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43ce72		e8c955feff		CALL runtime.printstring(SB)	
  0x43ce77		488b842438030000	MOVQ 0x338(SP), AX		
  0x43ce7f		48890424		MOVQ AX, 0(SP)			
  0x43ce83		e8f853feff		CALL runtime.printint(SB)	
  0x43ce88		e8034ffeff		CALL runtime.printnl(SB)	
  0x43ce8d		e8ee4cfeff		CALL runtime.printunlock(SB)	
		throw("traceback did not unwind completely")
  0x43ce92		488d0522ff0200		LEAQ 0x2ff22(IP), AX	
  0x43ce99		48890424		MOVQ AX, 0(SP)		
  0x43ce9d		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x43cea6		e82543feff		CALL runtime.throw(SB)	
  0x43ceab		0f0b			UD2			
		throw("traceback has leftover defers")
  0x43cead		488d0522f50200		LEAQ 0x2f522(IP), AX	
  0x43ceb4		48890424		MOVQ AX, 0(SP)		
  0x43ceb8		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x43cec1		e80a43feff		CALL runtime.throw(SB)	
  0x43cec6		0f0b			UD2			
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43cec8		e8732bfeff		CALL runtime.panicindex(SB)	
  0x43cecd		0f0b			UD2				
						name := funcnameFromNameoff(f, inltree[ix].func_)
  0x43cecf		e86c2bfeff		CALL runtime.panicindex(SB)	
  0x43ced4		0f0b			UD2				
					(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43ced6		e8652bfeff		CALL runtime.panicindex(SB)	
  0x43cedb		0f0b			UD2				
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = frame.pc
  0x43cedd		e85e2bfeff		CALL runtime.panicindex(SB)	
  0x43cee2		0f0b			UD2				
					ix = inltree[ix].parent
  0x43cee4		e8572bfeff		CALL runtime.panicindex(SB)	
  0x43cee9		0f0b			UD2				
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = frame.pc
  0x43ceeb		e8502bfeff		CALL runtime.panicindex(SB)	
  0x43cef0		0f0b			UD2				
					throw("unknown caller pc")
  0x43cef2		488d0530de0200		LEAQ 0x2de30(IP), AX	
  0x43cef9		48890424		MOVQ AX, 0(SP)		
  0x43cefd		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x43cf06		e8c542feff		CALL runtime.throw(SB)	
  0x43cf0b		0f0b			UD2			
			throw("unknown pc")
  0x43cf0d		488d057ad40200		LEAQ 0x2d47a(IP), AX	
  0x43cf14		48890424		MOVQ AX, 0(SP)		
  0x43cf18		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x43cf21		e8aa42feff		CALL runtime.throw(SB)	
  0x43cf26		0f0b			UD2			
		throw("gentraceback cannot trace user goroutine on its own stack")
  0x43cf28		488d05a80d0300		LEAQ 0x30da8(IP), AX	
  0x43cf2f		48890424		MOVQ AX, 0(SP)		
  0x43cf33		48c744240839000000	MOVQ $0x39, 0x8(SP)	
  0x43cf3c		e88f42feff		CALL runtime.throw(SB)	
  0x43cf41		0f0b			UD2			
		throw("gentraceback callback cannot be used with non-zero skip")
  0x43cf43		488d05e70c0300		LEAQ 0x30ce7(IP), AX	
  0x43cf4a		48890424		MOVQ AX, 0(SP)		
  0x43cf4e		48c744240837000000	MOVQ $0x37, 0x8(SP)	
  0x43cf57		e87442feff		CALL runtime.throw(SB)	
  0x43cf5c		0f0b			UD2			
func gentraceback(pc0, sp0, lr0 uintptr, gp *g, skip int, pcbuf *uintptr, max int, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer, flags uint) int {
  0x43cf5e		e80d760000		CALL runtime.morestack_noctxt(SB)	
  0x43cf63		e9c8e3ffff		JMP runtime.gentraceback(SB)		

TEXT runtime.getArgInfo(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector) {
  0x43cf70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43cf79		483b6110		CMPQ 0x10(CX), SP	
  0x43cf7d		0f869c010000		JBE 0x43d11f		
  0x43cf83		4883ec40		SUBQ $0x40, SP		
  0x43cf87		48896c2438		MOVQ BP, 0x38(SP)	
  0x43cf8c		488d6c2438		LEAQ 0x38(SP), BP	
  0x43cf91		488b442450		MOVQ 0x50(SP), AX	
	arglen = uintptr(f.args)
  0x43cf96		8b480c			MOVL 0xc(AX), CX	
  0x43cf99		4863d1			MOVSXD CX, DX		
  0x43cf9c		0fb65c2460		MOVZX 0x60(SP), BX	
func getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector) {
  0x43cfa1		84db			TESTL BL, BL		
	if needArgMap && f.args == _ArgsSizeUnknown {
  0x43cfa3		0f84ed000000		JE 0x43d096		
  0x43cfa9		81f900000080		CMPL $-0x80000000, CX	
  0x43cfaf		7416			JE 0x43cfc7		
  0x43cfb1		31c0			XORL AX, AX		
	return
  0x43cfb3		4889542470		MOVQ DX, 0x70(SP)	
  0x43cfb8		4889442478		MOVQ AX, 0x78(SP)	
  0x43cfbd		488b6c2438		MOVQ 0x38(SP), BP	
  0x43cfc2		4883c440		ADDQ $0x40, SP		
  0x43cfc6		c3			RET			
  0x43cfc7		4889542428		MOVQ DX, 0x28(SP)	
		switch funcname(f) {
  0x43cfcc		48890424		MOVQ AX, 0(SP)			
  0x43cfd0		488b4c2458		MOVQ 0x58(SP), CX		
  0x43cfd5		48894c2408		MOVQ CX, 0x8(SP)		
  0x43cfda		e821b9ffff		CALL runtime.funcname(SB)	
  0x43cfdf		488b442418		MOVQ 0x18(SP), AX		
  0x43cfe4		488b4c2410		MOVQ 0x10(SP), CX		
		case "reflect.makeFuncStub", "reflect.methodValueCall":
  0x43cfe9		4883f814		CMPQ $0x14, AX		
  0x43cfed		746b			JE 0x43d05a		
  0x43cfef		4883f817		CMPQ $0x17, AX		
  0x43cff3		740c			JE 0x43d001		
  0x43cff5		31c0			XORL AX, AX		
  0x43cff7		488b4c2428		MOVQ 0x28(SP), CX	
		switch funcname(f) {
  0x43cffc		4889ca			MOVQ CX, DX		
	return
  0x43cfff		ebb2			JMP 0x43cfb3		
		case "reflect.makeFuncStub", "reflect.methodValueCall":
  0x43d001		48890c24		MOVQ CX, 0(SP)			
  0x43d005		488d0d26e70200		LEAQ 0x2e726(IP), CX		
  0x43d00c		48894c2408		MOVQ CX, 0x8(SP)		
  0x43d011		4889442410		MOVQ AX, 0x10(SP)		
  0x43d016		e825930000		CALL runtime.memequal(SB)	
  0x43d01b		0fb6442418		MOVZX 0x18(SP), AX		
  0x43d020		84c0			TESTL AL, AL			
  0x43d022		74d1			JE 0x43cff5			
  0x43d024		488b442468		MOVQ 0x68(SP), AX		
			if ctxt != nil {
  0x43d029		4885c0			TESTQ AX, AX		
  0x43d02c		741e			JE 0x43d04c		
			if mv.fn != f.entry {
  0x43d02e		488b08			MOVQ 0(AX), CX		
  0x43d031		488b542450		MOVQ 0x50(SP), DX	
  0x43d036		488b1a			MOVQ 0(DX), BX		
  0x43d039		4839d9			CMPQ BX, CX		
  0x43d03c		755f			JNE 0x43d09d		
			bv := mv.stack
  0x43d03e		488b4008		MOVQ 0x8(AX), AX	
			arglen = uintptr(bv.n * sys.PtrSize)
  0x43d042		8b10			MOVL 0(AX), DX		
  0x43d044		c1e203			SHLL $0x3, DX		
  0x43d047		4863ca			MOVSXD DX, CX		
		switch funcname(f) {
  0x43d04a		ebb0			JMP 0x43cffc		
  0x43d04c		488b4c2448		MOVQ 0x48(SP), CX	
				arg0 := frame.sp + sys.MinFrameSize
  0x43d051		488b4928		MOVQ 0x28(CX), CX	
				mv = *(**reflectMethodValue)(unsafe.Pointer(arg0))
  0x43d055		488b01			MOVQ 0(CX), AX		
  0x43d058		ebd4			JMP 0x43d02e		
  0x43d05a		4889442420		MOVQ AX, 0x20(SP)	
  0x43d05f		48894c2430		MOVQ CX, 0x30(SP)	
		case "reflect.makeFuncStub", "reflect.methodValueCall":
  0x43d064		48890c24		MOVQ CX, 0(SP)			
  0x43d068		488d153ae10200		LEAQ 0x2e13a(IP), DX		
  0x43d06f		4889542408		MOVQ DX, 0x8(SP)		
  0x43d074		4889442410		MOVQ AX, 0x10(SP)		
  0x43d079		e8c2920000		CALL runtime.memequal(SB)	
  0x43d07e		0fb6442418		MOVZX 0x18(SP), AX		
  0x43d083		84c0			TESTL AL, AL			
  0x43d085		759d			JNE 0x43d024			
  0x43d087		488b442420		MOVQ 0x20(SP), AX		
  0x43d08c		488b4c2430		MOVQ 0x30(SP), CX		
  0x43d091		e959ffffff		JMP 0x43cfef			
  0x43d096		31c0			XORL AX, AX			
	if needArgMap && f.args == _ArgsSizeUnknown {
  0x43d098		e916ffffff		JMP 0x43cfb3		
				print("runtime: confused by ", funcname(f), "\n")
  0x43d09d		48891424		MOVQ DX, 0(SP)			
  0x43d0a1		488b442458		MOVQ 0x58(SP), AX		
  0x43d0a6		4889442408		MOVQ AX, 0x8(SP)		
  0x43d0ab		e850b8ffff		CALL runtime.funcname(SB)	
  0x43d0b0		488b442410		MOVQ 0x10(SP), AX		
  0x43d0b5		4889442430		MOVQ AX, 0x30(SP)		
  0x43d0ba		488b4c2418		MOVQ 0x18(SP), CX		
  0x43d0bf		48894c2420		MOVQ CX, 0x20(SP)		
  0x43d0c4		e8374afeff		CALL runtime.printlock(SB)	
  0x43d0c9		488d0537e20200		LEAQ 0x2e237(IP), AX		
  0x43d0d0		48890424		MOVQ AX, 0(SP)			
  0x43d0d4		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x43d0dd		e85e53feff		CALL runtime.printstring(SB)	
  0x43d0e2		488b442430		MOVQ 0x30(SP), AX		
  0x43d0e7		48890424		MOVQ AX, 0(SP)			
  0x43d0eb		488b442420		MOVQ 0x20(SP), AX		
  0x43d0f0		4889442408		MOVQ AX, 0x8(SP)		
  0x43d0f5		e84653feff		CALL runtime.printstring(SB)	
  0x43d0fa		e8914cfeff		CALL runtime.printnl(SB)	
  0x43d0ff		e87c4afeff		CALL runtime.printunlock(SB)	
				throw("reflect mismatch")
  0x43d104		488d0537da0200		LEAQ 0x2da37(IP), AX	
  0x43d10b		48890424		MOVQ AX, 0(SP)		
  0x43d10f		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x43d118		e8b340feff		CALL runtime.throw(SB)	
  0x43d11d		0f0b			UD2			
func getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector) {
  0x43d11f		e84c740000		CALL runtime.morestack_noctxt(SB)	
  0x43d124		e947feffff		JMP runtime.getArgInfo(SB)		

TEXT runtime.tracebackCgoContext(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43d130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d139		488d842408feffff	LEAQ 0xfffffe08(SP), AX	
  0x43d141		483b4110		CMPQ 0x10(CX), AX	
  0x43d145		0f8629020000		JBE 0x43d374		
  0x43d14b		4881ec78020000		SUBQ $0x278, SP		
  0x43d152		4889ac2470020000	MOVQ BP, 0x270(SP)	
  0x43d15a		488dac2470020000	LEAQ 0x270(SP), BP	
	var cgoPCs [32]uintptr
  0x43d162		488d7c2438		LEAQ 0x38(SP), DI	
  0x43d167		0f57c0			XORPS X0, X0		
  0x43d16a		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43d16f		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43d174		e80b990000		CALL 0x446a84		
  0x43d179		488b6d00		MOVQ 0(BP), BP		
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43d17d		488b842490020000	MOVQ 0x290(SP), AX	
	cgoContextPCs(ctxt, cgoPCs[:])
  0x43d185		48890424		MOVQ AX, 0(SP)			
  0x43d189		488d442438		LEAQ 0x38(SP), AX		
  0x43d18e		4889442408		MOVQ AX, 0x8(SP)		
  0x43d193		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x43d19c		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x43d1a5		e8e6160000		CALL runtime.cgoContextPCs(SB)	
	var arg cgoSymbolizerArg
  0x43d1aa		48c784243802000000000000	MOVQ $0x0, 0x238(SP)	
  0x43d1b6		0f57c9				XORPS X1, X1		
  0x43d1b9		0f118c2440020000		MOVUPS X1, 0x240(SP)	
  0x43d1c1		0f118c2450020000		MOVUPS X1, 0x250(SP)	
  0x43d1c9		0f118c2460020000		MOVUPS X1, 0x260(SP)	
	for _, pc := range cgoPCs {
  0x43d1d1		488dbc2438010000	LEAQ 0x138(SP), DI	
  0x43d1d9		488d742438		LEAQ 0x38(SP), SI	
  0x43d1de		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43d1e3		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43d1e8		e8939b0000		CALL 0x446d80		
  0x43d1ed		488b6d00		MOVQ 0(BP), BP		
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43d1f1		31c0			XORL AX, AX		
  0x43d1f3		31c9			XORL CX, CX		
  0x43d1f5		488b942498020000	MOVQ 0x298(SP), DX	
	for _, pc := range cgoPCs {
  0x43d1fd		eb06			JMP 0x43d205		
  0x43d1ff		48ffc0			INCQ AX			
		n++
  0x43d202		48ffc2			INCQ DX			
	for _, pc := range cgoPCs {
  0x43d205		4889942498020000	MOVQ DX, 0x298(SP)		
  0x43d20d		4883f820		CMPQ $0x20, AX			
  0x43d211		0f8d13010000		JGE 0x43d32a			
  0x43d217		488b9cc438010000	MOVQ 0x138(SP)(AX*8), BX	
		if pc == 0 || n >= max {
  0x43d21f		4885db			TESTQ BX, BX		
  0x43d222		0f8402010000		JE 0x43d32a		
  0x43d228		488bb424a0020000	MOVQ 0x2a0(SP), SI	
  0x43d230		4839f2			CMPQ SI, DX		
  0x43d233		0f8df1000000		JGE 0x43d32a		
  0x43d239		488bbc2480020000	MOVQ 0x280(SP), DI	
		if pcbuf != nil {
  0x43d241		4885ff			TESTQ DI, DI		
  0x43d244		7411			JE 0x43d257		
			(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43d246		4881fa00001000		CMPQ $0x100000, DX	
  0x43d24d		0f831a010000		JAE 0x43d36d		
  0x43d253		48891cd7		MOVQ BX, 0(DI)(DX*8)	
  0x43d257		440fb6842488020000	MOVZX 0x288(SP), R8	
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43d260		4584c0			TESTL R8, R8		
		if printing {
  0x43d263		749a			JE 0x43d1ff		
  0x43d265		4889442430		MOVQ AX, 0x30(SP)	
  0x43d26a		884c2426		MOVB CL, 0x26(SP)	
			if cgoSymbolizer == nil {
  0x43d26e		4c8b0dc3a30600		MOVQ runtime.cgoSymbolizer(SB), R9	
  0x43d275		4d85c9			TESTQ R9, R9				
  0x43d278		410f95c1		SETNE R9				
  0x43d27c		44884c2427		MOVB R9, 0x27(SP)			
  0x43d281		7462			JE 0x43d2e5				
				c := printOneCgoTraceback(pc, max-n, &arg)
  0x43d283		48891c24		MOVQ BX, 0(SP)				
  0x43d287		4829d6			SUBQ DX, SI				
  0x43d28a		4889742408		MOVQ SI, 0x8(SP)			
  0x43d28f		488d8c2438020000	LEAQ 0x238(SP), CX			
  0x43d297		48894c2410		MOVQ CX, 0x10(SP)			
  0x43d29c		e86f130000		CALL runtime.printOneCgoTraceback(SB)	
  0x43d2a1		488b442418		MOVQ 0x18(SP), AX			
  0x43d2a6		488b8c2498020000	MOVQ 0x298(SP), CX			
				n += c - 1 // +1 a few lines down
  0x43d2ae		488d4408ff		LEAQ -0x1(AX)(CX*1), AX	
				anySymbolized = true
  0x43d2b3		0fb64c2427		MOVZX 0x27(SP), CX	
  0x43d2b8		0fb65c2426		MOVZX 0x26(SP), BX	
	if anySymbolized {
  0x43d2bd		09d9			ORL BX, CX		
  0x43d2bf		488bb424a0020000	MOVQ 0x2a0(SP), SI	
  0x43d2c7		488bbc2480020000	MOVQ 0x280(SP), DI	
  0x43d2cf		440fb6842488020000	MOVZX 0x288(SP), R8	
  0x43d2d8		4889c2			MOVQ AX, DX		
  0x43d2db		488b442430		MOVQ 0x30(SP), AX	
		n++
  0x43d2e0		e91affffff		JMP 0x43d1ff		
  0x43d2e5		48895c2428		MOVQ BX, 0x28(SP)	
				print("non-Go function at pc=", hex(pc), "\n")
  0x43d2ea		e81148feff		CALL runtime.printlock(SB)	
  0x43d2ef		488d0580e10200		LEAQ 0x2e180(IP), AX		
  0x43d2f6		48890424		MOVQ AX, 0(SP)			
  0x43d2fa		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x43d303		e83851feff		CALL runtime.printstring(SB)	
  0x43d308		488b442428		MOVQ 0x28(SP), AX		
  0x43d30d		48890424		MOVQ AX, 0(SP)			
  0x43d311		e8da4ffeff		CALL runtime.printhex(SB)	
  0x43d316		e8754afeff		CALL runtime.printnl(SB)	
  0x43d31b		e86048feff		CALL runtime.printunlock(SB)	
  0x43d320		488b842498020000	MOVQ 0x298(SP), AX		
  0x43d328		eb89			JMP 0x43d2b3			
	if anySymbolized {
  0x43d32a		84c9			TESTL CL, CL		
  0x43d32c		7518			JNE 0x43d346		
	return n
  0x43d32e		48899424a8020000	MOVQ DX, 0x2a8(SP)	
  0x43d336		488bac2470020000	MOVQ 0x270(SP), BP	
  0x43d33e		4881c478020000		ADDQ $0x278, SP		
  0x43d345		c3			RET			
		arg.pc = 0
  0x43d346		48c784243802000000000000	MOVQ $0x0, 0x238(SP)	
		callCgoSymbolizer(&arg)
  0x43d352		488d842438020000	LEAQ 0x238(SP), AX			
  0x43d35a		48890424		MOVQ AX, 0(SP)				
  0x43d35e		e8ad140000		CALL runtime.callCgoSymbolizer(SB)	
  0x43d363		488b942498020000	MOVQ 0x298(SP), DX			
  0x43d36b		ebc1			JMP 0x43d32e				
			(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43d36d		e8ce26feff		CALL runtime.panicindex(SB)	
  0x43d372		0f0b			UD2				
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43d374		e8f7710000		CALL runtime.morestack_noctxt(SB)	
  0x43d379		e9b2fdffff		JMP runtime.tracebackCgoContext(SB)	

TEXT runtime.printcreatedby(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func printcreatedby(gp *g) {
  0x43d380		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d389		483b6110		CMPQ 0x10(CX), SP	
  0x43d38d		0f8620020000		JBE 0x43d5b3		
  0x43d393		4881ec80000000		SUBQ $0x80, SP		
  0x43d39a		48896c2478		MOVQ BP, 0x78(SP)	
  0x43d39f		488d6c2478		LEAQ 0x78(SP), BP	
  0x43d3a4		488b842488000000	MOVQ 0x88(SP), AX	
	pc := gp.gopc
  0x43d3ac		488b8820010000		MOVQ 0x120(AX), CX	
  0x43d3b3		48894c2430		MOVQ CX, 0x30(SP)	
	f := findfunc(pc)
  0x43d3b8		48890c24		MOVQ CX, 0(SP)			
  0x43d3bc		e80faeffff		CALL runtime.findfunc(SB)	
  0x43d3c1		488b442410		MOVQ 0x10(SP), AX		
  0x43d3c6		488b4c2408		MOVQ 0x8(SP), CX		
	return f._func != nil
  0x43d3cb		4885c9			TESTQ CX, CX		
	if f.valid() && showframe(f, gp, false, false) && gp.goid != 1 {
  0x43d3ce		750d			JNE 0x43d3dd			
  0x43d3d0		488b6c2478		MOVQ 0x78(SP), BP		
  0x43d3d5		4881c480000000		ADDQ $0x80, SP			
  0x43d3dc		c3			RET				
  0x43d3dd		4889442470		MOVQ AX, 0x70(SP)		
  0x43d3e2		48894c2468		MOVQ CX, 0x68(SP)		
  0x43d3e7		48890c24		MOVQ CX, 0(SP)			
  0x43d3eb		4889442408		MOVQ AX, 0x8(SP)		
  0x43d3f0		488b942488000000	MOVQ 0x88(SP), DX		
  0x43d3f8		4889542410		MOVQ DX, 0x10(SP)		
  0x43d3fd		66c74424180000		MOVW $0x0, 0x18(SP)		
  0x43d404		e887060000		CALL runtime.showframe(SB)	
  0x43d409		0fb6442420		MOVZX 0x20(SP), AX		
  0x43d40e		84c0			TESTL AL, AL			
  0x43d410		74be			JE 0x43d3d0			
  0x43d412		488b842488000000	MOVQ 0x88(SP), AX		
  0x43d41a		488b8098000000		MOVQ 0x98(AX), AX		
  0x43d421		4883f801		CMPQ $0x1, AX			
  0x43d425		74a9			JE 0x43d3d0			
  0x43d427		488b442468		MOVQ 0x68(SP), AX		
		print("created by ", funcname(f), "\n")
  0x43d42c		48890424		MOVQ AX, 0(SP)			
  0x43d430		488b4c2470		MOVQ 0x70(SP), CX		
  0x43d435		48894c2408		MOVQ CX, 0x8(SP)		
  0x43d43a		e8c1b4ffff		CALL runtime.funcname(SB)	
  0x43d43f		488b442418		MOVQ 0x18(SP), AX		
  0x43d444		4889442450		MOVQ AX, 0x50(SP)		
  0x43d449		488b4c2410		MOVQ 0x10(SP), CX		
  0x43d44e		48894c2460		MOVQ CX, 0x60(SP)		
  0x43d453		e8a846feff		CALL runtime.printlock(SB)	
  0x43d458		488d0520d00200		LEAQ 0x2d020(IP), AX		
  0x43d45f		48890424		MOVQ AX, 0(SP)			
  0x43d463		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x43d46c		e8cf4ffeff		CALL runtime.printstring(SB)	
  0x43d471		488b442460		MOVQ 0x60(SP), AX		
  0x43d476		48890424		MOVQ AX, 0(SP)			
  0x43d47a		488b442450		MOVQ 0x50(SP), AX		
  0x43d47f		4889442408		MOVQ AX, 0x8(SP)		
  0x43d484		e8b74ffeff		CALL runtime.printstring(SB)	
  0x43d489		e80249feff		CALL runtime.printnl(SB)	
  0x43d48e		e8ed46feff		CALL runtime.printunlock(SB)	
  0x43d493		488b442468		MOVQ 0x68(SP), AX		
		if pc > f.entry {
  0x43d498		488b08			MOVQ 0(AX), CX		
  0x43d49b		488b542430		MOVQ 0x30(SP), DX	
  0x43d4a0		4839ca			CMPQ CX, DX		
  0x43d4a3		0f8602010000		JBE 0x43d5ab		
			tracepc -= sys.PCQuantum
  0x43d4a9		488d4aff		LEAQ -0x1(DX), CX	
		file, line := funcline(f, tracepc)
  0x43d4ad		48890424		MOVQ AX, 0(SP)			
  0x43d4b1		488b542470		MOVQ 0x70(SP), DX		
  0x43d4b6		4889542408		MOVQ DX, 0x8(SP)		
  0x43d4bb		48894c2410		MOVQ CX, 0x10(SP)		
  0x43d4c0		e88bb7ffff		CALL runtime.funcline(SB)	
  0x43d4c5		488b442418		MOVQ 0x18(SP), AX		
  0x43d4ca		4889442458		MOVQ AX, 0x58(SP)		
  0x43d4cf		488b4c2420		MOVQ 0x20(SP), CX		
  0x43d4d4		48894c2438		MOVQ CX, 0x38(SP)		
		print("\t", file, ":", line)
  0x43d4d9		4863542428		MOVSXD 0x28(SP), DX		
  0x43d4de		4889542448		MOVQ DX, 0x48(SP)		
  0x43d4e3		e81846feff		CALL runtime.printlock(SB)	
  0x43d4e8		488d056fc70200		LEAQ 0x2c76f(IP), AX		
  0x43d4ef		48890424		MOVQ AX, 0(SP)			
  0x43d4f3		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43d4fc		e83f4ffeff		CALL runtime.printstring(SB)	
  0x43d501		488b442458		MOVQ 0x58(SP), AX		
  0x43d506		48890424		MOVQ AX, 0(SP)			
  0x43d50a		488b442438		MOVQ 0x38(SP), AX		
  0x43d50f		4889442408		MOVQ AX, 0x8(SP)		
  0x43d514		e8274ffeff		CALL runtime.printstring(SB)	
  0x43d519		488d0538c70200		LEAQ 0x2c738(IP), AX		
  0x43d520		48890424		MOVQ AX, 0(SP)			
  0x43d524		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43d52d		e80e4ffeff		CALL runtime.printstring(SB)	
  0x43d532		488b442448		MOVQ 0x48(SP), AX		
  0x43d537		48890424		MOVQ AX, 0(SP)			
  0x43d53b		e8404dfeff		CALL runtime.printint(SB)	
  0x43d540		e83b46feff		CALL runtime.printunlock(SB)	
  0x43d545		488b442468		MOVQ 0x68(SP), AX		
		if pc > f.entry {
  0x43d54a		488b00			MOVQ 0(AX), AX		
  0x43d54d		488b4c2430		MOVQ 0x30(SP), CX	
  0x43d552		4839c1			CMPQ AX, CX		
  0x43d555		7714			JA 0x43d56b		
		print("\n")
  0x43d557		e8a445feff		CALL runtime.printlock(SB)	
  0x43d55c		e82f48feff		CALL runtime.printnl(SB)	
  0x43d561		e81a46feff		CALL runtime.printunlock(SB)	
  0x43d566		e965feffff		JMP 0x43d3d0			
  0x43d56b		4889442440		MOVQ AX, 0x40(SP)		
			print(" +", hex(pc-f.entry))
  0x43d570		e88b45feff		CALL runtime.printlock(SB)	
  0x43d575		488d05e4c60200		LEAQ 0x2c6e4(IP), AX		
  0x43d57c		48890424		MOVQ AX, 0(SP)			
  0x43d580		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43d589		e8b24efeff		CALL runtime.printstring(SB)	
  0x43d58e		488b442430		MOVQ 0x30(SP), AX		
  0x43d593		488b4c2440		MOVQ 0x40(SP), CX		
  0x43d598		4829c8			SUBQ CX, AX			
  0x43d59b		48890424		MOVQ AX, 0(SP)			
  0x43d59f		e84c4dfeff		CALL runtime.printhex(SB)	
  0x43d5a4		e8d745feff		CALL runtime.printunlock(SB)	
  0x43d5a9		ebac			JMP 0x43d557			
  0x43d5ab		4889d1			MOVQ DX, CX			
		if pc > f.entry {
  0x43d5ae		e9fafeffff		JMP 0x43d4ad		
func printcreatedby(gp *g) {
  0x43d5b3		e8b86f0000		CALL runtime.morestack_noctxt(SB)	
  0x43d5b8		e9c3fdffff		JMP runtime.printcreatedby(SB)		

TEXT runtime.traceback(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func traceback(pc, sp, lr uintptr, gp *g) {
  0x43d5c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d5c9		483b6110		CMPQ 0x10(CX), SP	
  0x43d5cd		764d			JBE 0x43d61c		
  0x43d5cf		4883ec30		SUBQ $0x30, SP		
  0x43d5d3		48896c2428		MOVQ BP, 0x28(SP)	
  0x43d5d8		488d6c2428		LEAQ 0x28(SP), BP	
  0x43d5dd		488b442438		MOVQ 0x38(SP), AX	
	traceback1(pc, sp, lr, gp, 0)
  0x43d5e2		48890424		MOVQ AX, 0(SP)		
func traceback(pc, sp, lr uintptr, gp *g) {
  0x43d5e6		488b442440		MOVQ 0x40(SP), AX	
	traceback1(pc, sp, lr, gp, 0)
  0x43d5eb		4889442408		MOVQ AX, 0x8(SP)	
func traceback(pc, sp, lr uintptr, gp *g) {
  0x43d5f0		488b442448		MOVQ 0x48(SP), AX	
	traceback1(pc, sp, lr, gp, 0)
  0x43d5f5		4889442410		MOVQ AX, 0x10(SP)	
func traceback(pc, sp, lr uintptr, gp *g) {
  0x43d5fa		488b442450		MOVQ 0x50(SP), AX	
	traceback1(pc, sp, lr, gp, 0)
  0x43d5ff		4889442418		MOVQ AX, 0x18(SP)		
  0x43d604		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43d60d		e88e000000		CALL runtime.traceback1(SB)	
}
  0x43d612		488b6c2428		MOVQ 0x28(SP), BP	
  0x43d617		4883c430		ADDQ $0x30, SP		
  0x43d61b		c3			RET			
func traceback(pc, sp, lr uintptr, gp *g) {
  0x43d61c		e84f6f0000		CALL runtime.morestack_noctxt(SB)	
  0x43d621		eb9d			JMP runtime.traceback(SB)		

TEXT runtime.tracebacktrap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func tracebacktrap(pc, sp, lr uintptr, gp *g) {
  0x43d630		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d639		483b6110		CMPQ 0x10(CX), SP	
  0x43d63d		764d			JBE 0x43d68c		
  0x43d63f		4883ec30		SUBQ $0x30, SP		
  0x43d643		48896c2428		MOVQ BP, 0x28(SP)	
  0x43d648		488d6c2428		LEAQ 0x28(SP), BP	
  0x43d64d		488b442438		MOVQ 0x38(SP), AX	
	traceback1(pc, sp, lr, gp, _TraceTrap)
  0x43d652		48890424		MOVQ AX, 0(SP)		
func tracebacktrap(pc, sp, lr uintptr, gp *g) {
  0x43d656		488b442440		MOVQ 0x40(SP), AX	
	traceback1(pc, sp, lr, gp, _TraceTrap)
  0x43d65b		4889442408		MOVQ AX, 0x8(SP)	
func tracebacktrap(pc, sp, lr uintptr, gp *g) {
  0x43d660		488b442448		MOVQ 0x48(SP), AX	
	traceback1(pc, sp, lr, gp, _TraceTrap)
  0x43d665		4889442410		MOVQ AX, 0x10(SP)	
func tracebacktrap(pc, sp, lr uintptr, gp *g) {
  0x43d66a		488b442450		MOVQ 0x50(SP), AX	
	traceback1(pc, sp, lr, gp, _TraceTrap)
  0x43d66f		4889442418		MOVQ AX, 0x18(SP)		
  0x43d674		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43d67d		e81e000000		CALL runtime.traceback1(SB)	
}
  0x43d682		488b6c2428		MOVQ 0x28(SP), BP	
  0x43d687		4883c430		ADDQ $0x30, SP		
  0x43d68b		c3			RET			
func tracebacktrap(pc, sp, lr uintptr, gp *g) {
  0x43d68c		e8df6e0000		CALL runtime.morestack_noctxt(SB)	
  0x43d691		eb9d			JMP runtime.tracebacktrap(SB)		

TEXT runtime.traceback1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func traceback1(pc, sp, lr uintptr, gp *g, flags uint) {
  0x43d6a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d6a9		488d842420ffffff	LEAQ 0xffffff20(SP), AX	
  0x43d6b1		483b4110		CMPQ 0x10(CX), AX	
  0x43d6b5		0f8636020000		JBE 0x43d8f1		
  0x43d6bb		4881ec60010000		SUBQ $0x160, SP		
  0x43d6c2		4889ac2458010000	MOVQ BP, 0x158(SP)	
  0x43d6ca		488dac2458010000	LEAQ 0x158(SP), BP	
	if iscgo && gp.m != nil && gp.m.ncgo > 0 && gp.syscallsp != 0 && gp.m.cgoCallers != nil && gp.m.cgoCallers[0] != 0 {
  0x43d6d2		0fb605d3610800		MOVZX runtime.iscgo(SB), AX	
  0x43d6d9		84c0			TESTL AL, AL			
  0x43d6db		0f8403020000		JE 0x43d8e4			
  0x43d6e1		488b842480010000	MOVQ 0x180(SP), AX		
  0x43d6e9		488b4830		MOVQ 0x30(AX), CX		
  0x43d6ed		4885c9			TESTQ CX, CX			
  0x43d6f0		742b			JE 0x43d71d			
  0x43d6f2		8b9138010000		MOVL 0x138(CX), DX		
  0x43d6f8		85d2			TESTL DX, DX			
  0x43d6fa		7e21			JLE 0x43d71d			
  0x43d6fc		488b5070		MOVQ 0x70(AX), DX		
  0x43d700		4885d2			TESTQ DX, DX			
  0x43d703		7418			JE 0x43d71d			
  0x43d705		488b9140010000		MOVQ 0x140(CX), DX		
  0x43d70c		4885d2			TESTQ DX, DX			
  0x43d70f		740c			JE 0x43d71d			
  0x43d711		488b12			MOVQ 0(DX), DX			
  0x43d714		4885d2			TESTQ DX, DX			
  0x43d717		0f855e010000		JNE 0x43d87b			
	return atomic.Load(&gp.atomicstatus)
  0x43d71d		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp)&^_Gscan == _Gsyscall {
  0x43d723		81e1ffefffff		ANDL $-0x1001, CX	
  0x43d729		83f903			CMPL $0x3, CX		
  0x43d72c		0f852c010000		JNE 0x43d85e		
		pc = gp.syscallpc
  0x43d732		488b4878		MOVQ 0x78(AX), CX	
		sp = gp.syscallsp
  0x43d736		488b5070		MOVQ 0x70(AX), DX	
  0x43d73a		488b9c2488010000	MOVQ 0x188(SP), BX	
		flags &^= _TraceTrap
  0x43d742		4883e3fd		ANDQ $-0x3, BX		
  0x43d746		48898c2468010000	MOVQ CX, 0x168(SP)	
  0x43d74e		4889942470010000	MOVQ DX, 0x170(SP)	
  0x43d756		48899c2488010000	MOVQ BX, 0x188(SP)	
	n = gentraceback(pc, sp, lr, gp, 0, nil, _TracebackMaxFrames, nil, nil, flags)
  0x43d75e		48890c24		MOVQ CX, 0(SP)			
  0x43d762		4889542408		MOVQ DX, 0x8(SP)		
  0x43d767		488bb42478010000	MOVQ 0x178(SP), SI		
  0x43d76f		4889742410		MOVQ SI, 0x10(SP)		
  0x43d774		4889442418		MOVQ AX, 0x18(SP)		
  0x43d779		0f57c0			XORPS X0, X0			
  0x43d77c		0f11442420		MOVUPS X0, 0x20(SP)		
  0x43d781		48c744243064000000	MOVQ $0x64, 0x30(SP)		
  0x43d78a		0f11442438		MOVUPS X0, 0x38(SP)		
  0x43d78f		48895c2448		MOVQ BX, 0x48(SP)		
  0x43d794		e897dbffff		CALL runtime.gentraceback(SB)	
  0x43d799		488b442450		MOVQ 0x50(SP), AX		
	if n == 0 && (flags&_TraceRuntimeFrames) == 0 {
  0x43d79e		4885c0			TESTQ AX, AX		
  0x43d7a1		750e			JNE 0x43d7b1		
  0x43d7a3		488b8c2488010000	MOVQ 0x188(SP), CX	
  0x43d7ab		0fbae100		BTL $0x0, CX		
  0x43d7af		734c			JAE 0x43d7fd		
	if n == _TracebackMaxFrames {
  0x43d7b1		4883f864		CMPQ $0x64, AX		
  0x43d7b5		7421			JE 0x43d7d8		
  0x43d7b7		488b842480010000	MOVQ 0x180(SP), AX	
	printcreatedby(gp)
  0x43d7bf		48890424		MOVQ AX, 0(SP)			
  0x43d7c3		e8b8fbffff		CALL runtime.printcreatedby(SB)	
}
  0x43d7c8		488bac2458010000	MOVQ 0x158(SP), BP	
  0x43d7d0		4881c460010000		ADDQ $0x160, SP		
  0x43d7d7		c3			RET			
		print("...additional frames elided...\n")
  0x43d7d8		e82343feff		CALL runtime.printlock(SB)	
  0x43d7dd		488d050dee0200		LEAQ 0x2ee0d(IP), AX		
  0x43d7e4		48890424		MOVQ AX, 0(SP)			
  0x43d7e8		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x43d7f1		e84a4cfeff		CALL runtime.printstring(SB)	
  0x43d7f6		e88543feff		CALL runtime.printunlock(SB)	
  0x43d7fb		ebba			JMP 0x43d7b7			
  0x43d7fd		488b842468010000	MOVQ 0x168(SP), AX		
		n = gentraceback(pc, sp, lr, gp, 0, nil, _TracebackMaxFrames, nil, nil, flags|_TraceRuntimeFrames)
  0x43d805		48890424		MOVQ AX, 0(SP)			
  0x43d809		488b842470010000	MOVQ 0x170(SP), AX		
  0x43d811		4889442408		MOVQ AX, 0x8(SP)		
  0x43d816		488b842478010000	MOVQ 0x178(SP), AX		
  0x43d81e		4889442410		MOVQ AX, 0x10(SP)		
  0x43d823		488b842480010000	MOVQ 0x180(SP), AX		
  0x43d82b		4889442418		MOVQ AX, 0x18(SP)		
  0x43d830		0f57c0			XORPS X0, X0			
  0x43d833		0f11442420		MOVUPS X0, 0x20(SP)		
  0x43d838		48c744243064000000	MOVQ $0x64, 0x30(SP)		
  0x43d841		0f11442438		MOVUPS X0, 0x38(SP)		
  0x43d846		4883c901		ORQ $0x1, CX			
  0x43d84a		48894c2448		MOVQ CX, 0x48(SP)		
  0x43d84f		e8dcdaffff		CALL runtime.gentraceback(SB)	
  0x43d854		488b442450		MOVQ 0x50(SP), AX		
  0x43d859		e953ffffff		JMP 0x43d7b1			
  0x43d85e		488b8c2468010000	MOVQ 0x168(SP), CX		
  0x43d866		488b942470010000	MOVQ 0x170(SP), DX		
  0x43d86e		488b9c2488010000	MOVQ 0x188(SP), BX		
	if readgstatus(gp)&^_Gscan == _Gsyscall {
  0x43d876		e9cbfeffff		JMP 0x43d746		
		atomic.Store(&gp.m.cgoCallersUse, 1)
  0x43d87b		ba01000000		MOVL $0x1, DX		
  0x43d880		87913c010000		XCHGL DX, 0x13c(CX)	
		cgoCallers := *gp.m.cgoCallers
  0x43d886		488b4830		MOVQ 0x30(AX), CX	
  0x43d88a		488bb140010000		MOVQ 0x140(CX), SI	
  0x43d891		8401			TESTB AL, 0(CX)		
  0x43d893		488d7c2458		LEAQ 0x58(SP), DI	
  0x43d898		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43d89d		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43d8a2		e8d9940000		CALL 0x446d80		
  0x43d8a7		488b6d00		MOVQ 0(BP), BP		
		gp.m.cgoCallers[0] = 0
  0x43d8ab		488b4830		MOVQ 0x30(AX), CX	
  0x43d8af		488b8940010000		MOVQ 0x140(CX), CX	
  0x43d8b6		48c70100000000		MOVQ $0x0, 0(CX)	
		atomic.Store(&gp.m.cgoCallersUse, 0)
  0x43d8bd		488b4830		MOVQ 0x30(AX), CX	
  0x43d8c1		31d2			XORL DX, DX		
  0x43d8c3		87913c010000		XCHGL DX, 0x13c(CX)	
		printCgoTraceback(&cgoCallers)
  0x43d8c9		488d4c2458		LEAQ 0x58(SP), CX			
  0x43d8ce		48890c24		MOVQ CX, 0(SP)				
  0x43d8d2		e8090c0000		CALL runtime.printCgoTraceback(SB)	
  0x43d8d7		488b842480010000	MOVQ 0x180(SP), AX			
  0x43d8df		e939feffff		JMP 0x43d71d				
  0x43d8e4		488b842480010000	MOVQ 0x180(SP), AX			
	if iscgo && gp.m != nil && gp.m.ncgo > 0 && gp.syscallsp != 0 && gp.m.cgoCallers != nil && gp.m.cgoCallers[0] != 0 {
  0x43d8ec		e92cfeffff		JMP 0x43d71d		
func traceback1(pc, sp, lr uintptr, gp *g, flags uint) {
  0x43d8f1		e87a6c0000		CALL runtime.morestack_noctxt(SB)	
  0x43d8f6		e9a5fdffff		JMP runtime.traceback1(SB)		

TEXT runtime.callers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func callers(skip int, pcbuf []uintptr) int {
  0x43d900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d909		483b6110		CMPQ 0x10(CX), SP	
  0x43d90d		0f86bf000000		JBE 0x43d9d2		
  0x43d913		4883ec60		SUBQ $0x60, SP		
  0x43d917		48896c2458		MOVQ BP, 0x58(SP)	
  0x43d91c		488d6c2458		LEAQ 0x58(SP), BP	
	gp := getg()
  0x43d921		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	var n int
  0x43d92a		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	systemstack(func() {
  0x43d933		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x43d93c		0f57c0			XORPS X0, X0				
  0x43d93f		0f11442418		MOVUPS X0, 0x18(SP)			
  0x43d944		0f11442428		MOVUPS X0, 0x28(SP)			
  0x43d949		0f11442438		MOVUPS X0, 0x38(SP)			
  0x43d94e		0f11442448		MOVUPS X0, 0x48(SP)			
  0x43d953		488d0d56630000		LEAQ runtime.callers.func1(SB), CX	
  0x43d95a		48894c2410		MOVQ CX, 0x10(SP)			
  0x43d95f		488b4c2460		MOVQ 0x60(SP), CX			
  0x43d964		48894c2418		MOVQ CX, 0x18(SP)			
  0x43d969		488d4c2468		LEAQ 0x68(SP), CX			
  0x43d96e		48894c2420		MOVQ CX, 0x20(SP)			
  0x43d973		4889442428		MOVQ AX, 0x28(SP)			
  0x43d978		488d442468		LEAQ 0x68(SP), AX			
  0x43d97d		4889442430		MOVQ AX, 0x30(SP)			
func callers(skip int, pcbuf []uintptr) int {
  0x43d982		488b442470		MOVQ 0x70(SP), AX	
	systemstack(func() {
  0x43d987		4889442438		MOVQ AX, 0x38(SP)	
func callers(skip int, pcbuf []uintptr) int {
  0x43d98c		488b442478		MOVQ 0x78(SP), AX	
	systemstack(func() {
  0x43d991		4889442440		MOVQ AX, 0x40(SP)	
func callers(skip int, pcbuf []uintptr) int {
  0x43d996		488b842480000000	MOVQ 0x80(SP), AX	
	systemstack(func() {
  0x43d99e		4889442448		MOVQ AX, 0x48(SP)		
  0x43d9a3		488d442408		LEAQ 0x8(SP), AX		
  0x43d9a8		4889442450		MOVQ AX, 0x50(SP)		
  0x43d9ad		488d442410		LEAQ 0x10(SP), AX		
  0x43d9b2		48890424		MOVQ AX, 0(SP)			
  0x43d9b6		e8656a0000		CALL runtime.systemstack(SB)	
	return n
  0x43d9bb		488b442408		MOVQ 0x8(SP), AX	
  0x43d9c0		4889842488000000	MOVQ AX, 0x88(SP)	
  0x43d9c8		488b6c2458		MOVQ 0x58(SP), BP	
  0x43d9cd		4883c460		ADDQ $0x60, SP		
  0x43d9d1		c3			RET			
func callers(skip int, pcbuf []uintptr) int {
  0x43d9d2		e8996b0000		CALL runtime.morestack_noctxt(SB)	
  0x43d9d7		e924ffffff		JMP runtime.callers(SB)			

TEXT runtime.gcallers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func gcallers(gp *g, skip int, pcbuf []uintptr) int {
  0x43d9e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d9e9		483b6110		CMPQ 0x10(CX), SP	
  0x43d9ed		0f868c000000		JBE 0x43da7f		
  0x43d9f3		4883ec60		SUBQ $0x60, SP		
  0x43d9f7		48896c2458		MOVQ BP, 0x58(SP)	
  0x43d9fc		488d6c2458		LEAQ 0x58(SP), BP	
  0x43da01		488b842480000000	MOVQ 0x80(SP), AX	
	return gentraceback(^uintptr(0), ^uintptr(0), 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
  0x43da09		4885c0			TESTQ AX, AX			
  0x43da0c		766a			JBE 0x43da78			
  0x43da0e		488b4c2478		MOVQ 0x78(SP), CX		
  0x43da13		48894c2428		MOVQ CX, 0x28(SP)		
  0x43da18		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x43da20		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43da29		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43da32		488b4c2468		MOVQ 0x68(SP), CX		
  0x43da37		48894c2418		MOVQ CX, 0x18(SP)		
  0x43da3c		488b4c2470		MOVQ 0x70(SP), CX		
  0x43da41		48894c2420		MOVQ CX, 0x20(SP)		
  0x43da46		4889442430		MOVQ AX, 0x30(SP)		
  0x43da4b		0f57c0			XORPS X0, X0			
  0x43da4e		0f11442438		MOVUPS X0, 0x38(SP)		
  0x43da53		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x43da5c		e8cfd8ffff		CALL runtime.gentraceback(SB)	
  0x43da61		488b442450		MOVQ 0x50(SP), AX		
  0x43da66		4889842490000000	MOVQ AX, 0x90(SP)		
  0x43da6e		488b6c2458		MOVQ 0x58(SP), BP		
  0x43da73		4883c460		ADDQ $0x60, SP			
  0x43da77		c3			RET				
  0x43da78		e8c31ffeff		CALL runtime.panicindex(SB)	
  0x43da7d		0f0b			UD2				
func gcallers(gp *g, skip int, pcbuf []uintptr) int {
  0x43da7f		e8ec6a0000		CALL runtime.morestack_noctxt(SB)	
  0x43da84		e957ffffff		JMP runtime.gcallers(SB)		

TEXT runtime.showframe(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func showframe(f funcInfo, gp *g, firstFrame, elideWrapper bool) bool {
  0x43da90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43da99		483b6110		CMPQ 0x10(CX), SP	
  0x43da9d		0f8669020000		JBE 0x43dd0c		
  0x43daa3		4883ec48		SUBQ $0x48, SP		
  0x43daa7		48896c2440		MOVQ BP, 0x40(SP)	
  0x43daac		488d6c2440		LEAQ 0x40(SP), BP	
	g := getg()
  0x43dab1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if g.m.throwing > 0 && gp != nil && (gp == g.m.curg || gp == g.m.caughtsig.ptr()) {
  0x43daba		488b4830		MOVQ 0x30(AX), CX	
  0x43dabe		8b91ec000000		MOVL 0xec(CX), DX	
  0x43dac4		85d2			TESTL DX, DX		
  0x43dac6		7e31			JLE 0x43daf9		
  0x43dac8		488b542460		MOVQ 0x60(SP), DX	
  0x43dacd		4885d2			TESTQ DX, DX		
  0x43dad0		7427			JE 0x43daf9		
  0x43dad2		488b99c0000000		MOVQ 0xc0(CX), BX	
  0x43dad9		4839d3			CMPQ DX, BX		
  0x43dadc		750f			JNE 0x43daed		
		return true
  0x43dade		c644247001		MOVB $0x1, 0x70(SP)	
  0x43dae3		488b6c2440		MOVQ 0x40(SP), BP	
  0x43dae8		4883c448		ADDQ $0x48, SP		
  0x43daec		c3			RET			
	if g.m.throwing > 0 && gp != nil && (gp == g.m.curg || gp == g.m.caughtsig.ptr()) {
  0x43daed		488b89c8000000		MOVQ 0xc8(CX), CX	
  0x43daf4		4839d1			CMPQ DX, CX		
  0x43daf7		74e5			JE 0x43dade		
	t := atomic.Load(&traceback_cache)
  0x43daf9		8b0d09750600		MOVL runtime.traceback_cache(SB), CX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x43daff		488b4030		MOVQ 0x30(AX), AX	
	if _g_.m.traceback != 0 {
  0x43db03		0fb68029010000		MOVZX 0x129(AX), AX	
  0x43db0a		84c0			TESTL AL, AL		
  0x43db0c		0f84f0010000		JE 0x43dd02		
		level = int32(_g_.m.traceback)
  0x43db12		0fb6c0			MOVZX AL, AX		
	if level > 1 {
  0x43db15		83f801			CMPL $0x1, AX		
  0x43db18		0f8fd5010000		JG 0x43dcf3		
  0x43db1e		488b442450		MOVQ 0x50(SP), AX	
	return f._func != nil
  0x43db23		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x43db26		0f84b8010000		JE 0x43dce4		
  0x43db2c		0fb64c2469		MOVZX 0x69(SP), CX	
func showframe(f funcInfo, gp *g, firstFrame, elideWrapper bool) bool {
  0x43db31		84c9			TESTL CL, CL		
	if elideWrapper {
  0x43db33		0f8539010000		JNE 0x43dc72		
	name := funcname(f)
  0x43db39		48890424		MOVQ AX, 0(SP)			
  0x43db3d		488b442458		MOVQ 0x58(SP), AX		
  0x43db42		4889442408		MOVQ AX, 0x8(SP)		
  0x43db47		e8b4adffff		CALL runtime.funcname(SB)	
  0x43db4c		488b442418		MOVQ 0x18(SP), AX		
  0x43db51		488b4c2410		MOVQ 0x10(SP), CX		
	if name == "runtime.gopanic" && !firstFrame {
  0x43db56		4883f80f		CMPQ $0xf, AX			
  0x43db5a		753e			JNE 0x43db9a			
  0x43db5c		488b11			MOVQ 0(CX), DX			
  0x43db5f		48bb72756e74696d652e	MOVQ $0x2e656d69746e7572, BX	
  0x43db69		4839da			CMPQ BX, DX			
  0x43db6c		752c			JNE 0x43db9a			
  0x43db6e		8b5108			MOVL 0x8(CX), DX		
  0x43db71		81fa676f7061		CMPL $0x61706f67, DX		
  0x43db77		7521			JNE 0x43db9a			
  0x43db79		0fb7510c		MOVZX 0xc(CX), DX		
  0x43db7d		6681fa6e69		CMPW $0x696e, DX		
  0x43db82		7516			JNE 0x43db9a			
  0x43db84		0fb6510e		MOVZX 0xe(CX), DX		
  0x43db88		80fa63			CMPL $0x63, DL			
  0x43db8b		750d			JNE 0x43db9a			
  0x43db8d		0fb6542468		MOVZX 0x68(SP), DX		
func showframe(f funcInfo, gp *g, firstFrame, elideWrapper bool) bool {
  0x43db92		84d2			TESTL DL, DL		
	if name == "runtime.gopanic" && !firstFrame {
  0x43db94		0f84c9000000		JE 0x43dc63		
  0x43db9a		4889442430		MOVQ AX, 0x30(SP)	
  0x43db9f		48894c2438		MOVQ CX, 0x38(SP)	
	return contains(name, ".") && (!hasprefix(name, "runtime.") || isExportedRuntime(name))
  0x43dba4		48890c24		MOVQ CX, 0(SP)			
  0x43dba8		4889442408		MOVQ AX, 0x8(SP)		
  0x43dbad		488d15a2c00200		LEAQ 0x2c0a2(IP), DX		
  0x43dbb4		4889542410		MOVQ DX, 0x10(SP)		
  0x43dbb9		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43dbc2		e8c998ffff		CALL runtime.contains(SB)	
  0x43dbc7		0fb6442420		MOVZX 0x20(SP), AX		
  0x43dbcc		84c0			TESTL AL, AL			
  0x43dbce		0f848b000000		JE 0x43dc5f			
  0x43dbd4		488b442430		MOVQ 0x30(SP), AX		
	return len(s) >= len(t) && s[:len(t)] == t
  0x43dbd9		4883f808		CMPQ $0x8, AX		
  0x43dbdd		7d51			JGE 0x43dc30		
  0x43dbdf		31c9			XORL CX, CX		
  0x43dbe1		84c9			TESTL CL, CL		
	return contains(name, ".") && (!hasprefix(name, "runtime.") || isExportedRuntime(name))
  0x43dbe3		7444			JE 0x43dc29		
	return len(s) >= len(t) && s[:len(t)] == t
  0x43dbe5		4883f808		CMPQ $0x8, AX		
	return len(name) > n && name[:n] == "runtime." && 'A' <= name[n] && name[n] <= 'Z'
  0x43dbe9		7e3a			JLE 0x43dc25			
  0x43dbeb		488b442438		MOVQ 0x38(SP), AX		
  0x43dbf0		488b08			MOVQ 0(AX), CX			
  0x43dbf3		48ba72756e74696d652e	MOVQ $0x2e656d69746e7572, DX	
  0x43dbfd		4839d1			CMPQ DX, CX			
  0x43dc00		751f			JNE 0x43dc21			
  0x43dc02		0fb64008		MOVZX 0x8(AX), AX		
  0x43dc06		3c41			CMPL $0x41, AL			
  0x43dc08		7213			JB 0x43dc1d			
  0x43dc0a		3c5a			CMPL $0x5a, AL			
  0x43dc0c		0f96c0			SETBE AL			
	return contains(name, ".") && (!hasprefix(name, "runtime.") || isExportedRuntime(name))
  0x43dc0f		88442470		MOVB AL, 0x70(SP)	
  0x43dc13		488b6c2440		MOVQ 0x40(SP), BP	
  0x43dc18		4883c448		ADDQ $0x48, SP		
  0x43dc1c		c3			RET			
  0x43dc1d		31c0			XORL AX, AX		
	return len(name) > n && name[:n] == "runtime." && 'A' <= name[n] && name[n] <= 'Z'
  0x43dc1f		ebee			JMP 0x43dc0f		
  0x43dc21		31c0			XORL AX, AX		
  0x43dc23		ebea			JMP 0x43dc0f		
  0x43dc25		31c0			XORL AX, AX		
  0x43dc27		ebe6			JMP 0x43dc0f		
  0x43dc29		b801000000		MOVL $0x1, AX		
	return contains(name, ".") && (!hasprefix(name, "runtime.") || isExportedRuntime(name))
  0x43dc2e		ebdf			JMP 0x43dc0f		
  0x43dc30		488b442438		MOVQ 0x38(SP), AX	
	return len(s) >= len(t) && s[:len(t)] == t
  0x43dc35		48890424		MOVQ AX, 0(SP)			
  0x43dc39		488d0de7c30200		LEAQ 0x2c3e7(IP), CX		
  0x43dc40		48894c2408		MOVQ CX, 0x8(SP)		
  0x43dc45		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x43dc4e		e8ed860000		CALL runtime.memequal(SB)	
  0x43dc53		0fb64c2418		MOVZX 0x18(SP), CX		
  0x43dc58		488b442430		MOVQ 0x30(SP), AX		
  0x43dc5d		eb82			JMP 0x43dbe1			
  0x43dc5f		31c0			XORL AX, AX			
	return contains(name, ".") && (!hasprefix(name, "runtime.") || isExportedRuntime(name))
  0x43dc61		ebac			JMP 0x43dc0f		
		return true
  0x43dc63		c644247001		MOVB $0x1, 0x70(SP)	
  0x43dc68		488b6c2440		MOVQ 0x40(SP), BP	
  0x43dc6d		4883c448		ADDQ $0x48, SP		
  0x43dc71		c3			RET			
		file, _ := funcline(f, f.entry)
  0x43dc72		488b08			MOVQ 0(AX), CX			
  0x43dc75		48894c2410		MOVQ CX, 0x10(SP)		
  0x43dc7a		48890424		MOVQ AX, 0(SP)			
  0x43dc7e		488b4c2458		MOVQ 0x58(SP), CX		
  0x43dc83		48894c2408		MOVQ CX, 0x8(SP)		
  0x43dc88		e8c3afffff		CALL runtime.funcline(SB)	
  0x43dc8d		488b442420		MOVQ 0x20(SP), AX		
  0x43dc92		488b4c2418		MOVQ 0x18(SP), CX		
		if file == "<autogenerated>" {
  0x43dc97		4883f80f		CMPQ $0xf, AX			
  0x43dc9b		752e			JNE 0x43dccb			
  0x43dc9d		488b01			MOVQ 0(CX), AX			
  0x43dca0		48ba3c6175746f67656e	MOVQ $0x6e65676f7475613c, DX	
  0x43dcaa		4839c2			CMPQ AX, DX			
  0x43dcad		751c			JNE 0x43dccb			
  0x43dcaf		8b4108			MOVL 0x8(CX), AX		
  0x43dcb2		3d65726174		CMPL $0x74617265, AX		
  0x43dcb7		7512			JNE 0x43dccb			
  0x43dcb9		0fb7410c		MOVZX 0xc(CX), AX		
  0x43dcbd		663d6564		CMPW $0x6465, AX		
  0x43dcc1		7508			JNE 0x43dccb			
  0x43dcc3		0fb6410e		MOVZX 0xe(CX), AX		
  0x43dcc7		3c3e			CMPL $0x3e, AL			
  0x43dcc9		740a			JE 0x43dcd5			
  0x43dccb		488b442450		MOVQ 0x50(SP), AX		
	name := funcname(f)
  0x43dcd0		e964feffff		JMP 0x43db39		
			return false
  0x43dcd5		c644247000		MOVB $0x0, 0x70(SP)	
  0x43dcda		488b6c2440		MOVQ 0x40(SP), BP	
  0x43dcdf		4883c448		ADDQ $0x48, SP		
  0x43dce3		c3			RET			
		return false
  0x43dce4		c644247000		MOVB $0x0, 0x70(SP)	
  0x43dce9		488b6c2440		MOVQ 0x40(SP), BP	
  0x43dcee		4883c448		ADDQ $0x48, SP		
  0x43dcf2		c3			RET			
		return true
  0x43dcf3		c644247001		MOVB $0x1, 0x70(SP)	
  0x43dcf8		488b6c2440		MOVQ 0x40(SP), BP	
  0x43dcfd		4883c448		ADDQ $0x48, SP		
  0x43dd01		c3			RET			
		level = int32(t >> tracebackShift)
  0x43dd02		c1e902			SHRL $0x2, CX		
  0x43dd05		89c8			MOVL CX, AX		
  0x43dd07		e909feffff		JMP 0x43db15		
func showframe(f funcInfo, gp *g, firstFrame, elideWrapper bool) bool {
  0x43dd0c		e85f680000		CALL runtime.morestack_noctxt(SB)	
  0x43dd11		e97afdffff		JMP runtime.showframe(SB)		

TEXT runtime.goroutineheader(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func goroutineheader(gp *g) {
  0x43dd20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43dd29		483b6110		CMPQ 0x10(CX), SP	
  0x43dd2d		0f867a020000		JBE 0x43dfad		
  0x43dd33		4883ec40		SUBQ $0x40, SP		
  0x43dd37		48896c2438		MOVQ BP, 0x38(SP)	
  0x43dd3c		488d6c2438		LEAQ 0x38(SP), BP	
  0x43dd41		488b442448		MOVQ 0x48(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x43dd46		8b8890000000		MOVL 0x90(AX), CX	
  0x43dd4c		89ca			MOVL CX, DX		
	gpstatus &^= _Gscan // drop the scan bit
  0x43dd4e		81e1ffefffff		ANDL $-0x1001, CX	
	if 0 <= gpstatus && gpstatus < uint32(len(gStatusStrings)) {
  0x43dd54		83f909			CMPL $0x9, CX		
  0x43dd57		0f8336020000		JAE 0x43df93		
		status = gStatusStrings[gpstatus]
  0x43dd5d		4883f909		CMPQ $0x9, CX				
  0x43dd61		0f833f020000		JAE 0x43dfa6				
  0x43dd67		89cb			MOVL CX, BX				
  0x43dd69		48c1e104		SHLQ $0x4, CX				
  0x43dd6d		488d352c7f0600		LEAQ runtime.gStatusStrings(SB), SI	
  0x43dd74		488b7c0e08		MOVQ 0x8(SI)(CX*1), DI			
  0x43dd79		488b0c0e		MOVQ 0(SI)(CX*1), CX			
	if gpstatus == _Gwaiting && gp.waitreason != "" {
  0x43dd7d		83fb04			CMPL $0x4, BX		
  0x43dd80		0f8502020000		JNE 0x43df88		
  0x43dd86		488bb0b0000000		MOVQ 0xb0(AX), SI	
  0x43dd8d		4c8b80a8000000		MOVQ 0xa8(AX), R8	
  0x43dd94		4885f6			TESTQ SI, SI		
  0x43dd97		0f84dd010000		JE 0x43df7a		
  0x43dd9d		83fb04			CMPL $0x4, BX		
		status = gp.waitreason
  0x43dda0		89542414		MOVL DX, 0x14(SP)	
  0x43dda4		4889742420		MOVQ SI, 0x20(SP)	
  0x43dda9		4c89442430		MOVQ R8, 0x30(SP)	
	if (gpstatus == _Gwaiting || gpstatus == _Gsyscall) && gp.waitsince != 0 {
  0x43ddae		0f85b6010000		JNE 0x43df6a		
  0x43ddb4		488b88a0000000		MOVQ 0xa0(AX), CX	
  0x43ddbb		4885c9			TESTQ CX, CX		
  0x43ddbe		0f8568010000		JNE 0x43df2c		
  0x43ddc4		31c9			XORL CX, CX		
  0x43ddc6		48894c2418		MOVQ CX, 0x18(SP)	
	print("goroutine ", gp.goid, " [", status)
  0x43ddcb		488b9098000000		MOVQ 0x98(AX), DX		
  0x43ddd2		4889542428		MOVQ DX, 0x28(SP)		
  0x43ddd7		e8243dfeff		CALL runtime.printlock(SB)	
  0x43dddc		488d0565c50200		LEAQ 0x2c565(IP), AX		
  0x43dde3		48890424		MOVQ AX, 0(SP)			
  0x43dde7		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43ddf0		e84b46feff		CALL runtime.printstring(SB)	
  0x43ddf5		488b442428		MOVQ 0x28(SP), AX		
  0x43ddfa		48890424		MOVQ AX, 0(SP)			
  0x43ddfe		e87d44feff		CALL runtime.printint(SB)	
  0x43de03		488d055cbe0200		LEAQ 0x2be5c(IP), AX		
  0x43de0a		48890424		MOVQ AX, 0(SP)			
  0x43de0e		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43de17		e82446feff		CALL runtime.printstring(SB)	
  0x43de1c		488b442430		MOVQ 0x30(SP), AX		
  0x43de21		48890424		MOVQ AX, 0(SP)			
  0x43de25		488b442420		MOVQ 0x20(SP), AX		
  0x43de2a		4889442408		MOVQ AX, 0x8(SP)		
  0x43de2f		e80c46feff		CALL runtime.printstring(SB)	
  0x43de34		e8473dfeff		CALL runtime.printunlock(SB)	
  0x43de39		8b442414		MOVL 0x14(SP), AX		
	isScan := gpstatus&_Gscan != 0
  0x43de3d		0fbae00c		BTL $0xc, AX		
	if isScan {
  0x43de41		0f82bd000000		JB 0x43df04		
  0x43de47		488b442418		MOVQ 0x18(SP), AX	
	if waitfor >= 1 {
  0x43de4c		4883f801		CMPQ $0x1, AX		
  0x43de50		7d63			JGE 0x43deb5		
  0x43de52		488b442448		MOVQ 0x48(SP), AX	
	if gp.lockedm != 0 {
  0x43de57		488b80e0000000		MOVQ 0xe0(AX), AX	
  0x43de5e		4885c0			TESTQ AX, AX		
  0x43de61		752d			JNE 0x43de90		
	print("]:\n")
  0x43de63		e8983cfeff		CALL runtime.printlock(SB)	
  0x43de68		488d0536be0200		LEAQ 0x2be36(IP), AX		
  0x43de6f		48890424		MOVQ AX, 0(SP)			
  0x43de73		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43de7c		e8bf45feff		CALL runtime.printstring(SB)	
  0x43de81		e8fa3cfeff		CALL runtime.printunlock(SB)	
}
  0x43de86		488b6c2438		MOVQ 0x38(SP), BP	
  0x43de8b		4883c440		ADDQ $0x40, SP		
  0x43de8f		c3			RET			
		print(", locked to thread")
  0x43de90		e86b3cfeff		CALL runtime.printlock(SB)	
  0x43de95		488d05d3ce0200		LEAQ 0x2ced3(IP), AX		
  0x43de9c		48890424		MOVQ AX, 0(SP)			
  0x43dea0		48c744240812000000	MOVQ $0x12, 0x8(SP)		
  0x43dea9		e89245feff		CALL runtime.printstring(SB)	
  0x43deae		e8cd3cfeff		CALL runtime.printunlock(SB)	
  0x43deb3		ebae			JMP 0x43de63			
		print(", ", waitfor, " minutes")
  0x43deb5		e8463cfeff		CALL runtime.printlock(SB)	
  0x43deba		488d05abbd0200		LEAQ 0x2bdab(IP), AX		
  0x43dec1		48890424		MOVQ AX, 0(SP)			
  0x43dec5		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43dece		e86d45feff		CALL runtime.printstring(SB)	
  0x43ded3		488b442418		MOVQ 0x18(SP), AX		
  0x43ded8		48890424		MOVQ AX, 0(SP)			
  0x43dedc		e89f43feff		CALL runtime.printint(SB)	
  0x43dee1		488d05c7c00200		LEAQ 0x2c0c7(IP), AX		
  0x43dee8		48890424		MOVQ AX, 0(SP)			
  0x43deec		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43def5		e84645feff		CALL runtime.printstring(SB)	
  0x43defa		e8813cfeff		CALL runtime.printunlock(SB)	
  0x43deff		e94effffff		JMP 0x43de52			
		print(" (scan)")
  0x43df04		e8f73bfeff		CALL runtime.printlock(SB)	
  0x43df09		488d054abf0200		LEAQ 0x2bf4a(IP), AX		
  0x43df10		48890424		MOVQ AX, 0(SP)			
  0x43df14		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43df1d		e81e45feff		CALL runtime.printstring(SB)	
  0x43df22		e8593cfeff		CALL runtime.printunlock(SB)	
  0x43df27		e91bffffff		JMP 0x43de47			
		waitfor = (nanotime() - gp.waitsince) / 60e9
  0x43df2c		e8ff9a0000		CALL runtime.nanotime(SB)	
  0x43df31		488b0424		MOVQ 0(SP), AX			
  0x43df35		488b4c2448		MOVQ 0x48(SP), CX		
  0x43df3a		482b81a0000000		SUBQ 0xa0(CX), AX		
  0x43df41		4889c2			MOVQ AX, DX			
  0x43df44		48b840474f3f9aff4c49	MOVQ $0x494cff9a3f4f4740, AX	
  0x43df4e		4889d3			MOVQ DX, BX			
  0x43df51		48f7ea			IMULQ DX			
  0x43df54		48c1fa22		SARQ $0x22, DX			
  0x43df58		48c1fb3f		SARQ $0x3f, BX			
  0x43df5c		4829da			SUBQ BX, DX			
  0x43df5f		4889c8			MOVQ CX, AX			
  0x43df62		4889d1			MOVQ DX, CX			
  0x43df65		e95cfeffff		JMP 0x43ddc6			
	if (gpstatus == _Gwaiting || gpstatus == _Gsyscall) && gp.waitsince != 0 {
  0x43df6a		83fb03			CMPL $0x3, BX		
  0x43df6d		0f8441feffff		JE 0x43ddb4		
  0x43df73		31c9			XORL CX, CX		
  0x43df75		e94cfeffff		JMP 0x43ddc6		
	if gpstatus == _Gwaiting && gp.waitreason != "" {
  0x43df7a		83fb04			CMPL $0x4, BX		
  0x43df7d		4889fe			MOVQ DI, SI		
  0x43df80		4989c8			MOVQ CX, R8		
  0x43df83		e918feffff		JMP 0x43dda0		
  0x43df88		4889fe			MOVQ DI, SI		
  0x43df8b		4989c8			MOVQ CX, R8		
  0x43df8e		e90dfeffff		JMP 0x43dda0		
  0x43df93		89cb			MOVL CX, BX		
  0x43df95		bf03000000		MOVL $0x3, DI		
  0x43df9a		488d0dfbbc0200		LEAQ 0x2bcfb(IP), CX	
  0x43dfa1		e9d7fdffff		JMP 0x43dd7d		
		status = gStatusStrings[gpstatus]
  0x43dfa6		e8951afeff		CALL runtime.panicindex(SB)	
  0x43dfab		0f0b			UD2				
func goroutineheader(gp *g) {
  0x43dfad		e8be650000		CALL runtime.morestack_noctxt(SB)	
  0x43dfb2		e969fdffff		JMP runtime.goroutineheader(SB)		

TEXT runtime.tracebackothers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func tracebackothers(me *g) {
  0x43dfc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43dfc9		483b6110		CMPQ 0x10(CX), SP	
  0x43dfcd		0f863d020000		JBE 0x43e210		
  0x43dfd3		4883ec60		SUBQ $0x60, SP		
  0x43dfd7		48896c2458		MOVQ BP, 0x58(SP)	
  0x43dfdc		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x43dfe1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	t := atomic.Load(&traceback_cache)
  0x43dfea		8b0d18700600		MOVL runtime.traceback_cache(SB), CX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x43dff0		488b4030		MOVQ 0x30(AX), AX	
	if _g_.m.traceback != 0 {
  0x43dff4		0fb68029010000		MOVZX 0x129(AX), AX	
  0x43dffb		84c0			TESTL AL, AL		
  0x43dffd		0f8403020000		JE 0x43e206		
		level = int32(_g_.m.traceback)
  0x43e003		0fb6c0			MOVZX AL, AX		
  0x43e006		89442424		MOVL AX, 0x24(SP)	
	g := getg()
  0x43e00a		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e013		48894c2448		MOVQ CX, 0x48(SP)	
	gp := g.m.curg
  0x43e018		488b5130		MOVQ 0x30(CX), DX	
  0x43e01c		488b92c0000000		MOVQ 0xc0(DX), DX	
	if gp != nil && gp != me {
  0x43e023		4885d2			TESTQ DX, DX		
  0x43e026		0f84d0010000		JE 0x43e1fc		
  0x43e02c		488b5c2468		MOVQ 0x68(SP), BX	
  0x43e031		4839d3			CMPQ DX, BX		
  0x43e034		0f8572010000		JNE 0x43e1ac		
	lock(&allglock)
  0x43e03a		488d05d7580800		LEAQ runtime.allglock(SB), AX	
  0x43e041		48890424		MOVQ AX, 0(SP)			
  0x43e045		e8d6b4fcff		CALL runtime.lock(SB)		
	for _, gp := range allgs {
  0x43e04a		488b0547960600		MOVQ runtime.allgs+8(SB), AX	
  0x43e051		4889442430		MOVQ AX, 0x30(SP)		
  0x43e056		488b0d33960600		MOVQ runtime.allgs(SB), CX	
  0x43e05d		48894c2450		MOVQ CX, 0x50(SP)		
  0x43e062		31d2			XORL DX, DX			
  0x43e064		eb03			JMP 0x43e069			
  0x43e066		48ffc2			INCQ DX				
  0x43e069		4839c2			CMPQ AX, DX			
  0x43e06c		0f8d20010000		JGE 0x43e192			
  0x43e072		488b1cd1		MOVQ 0(CX)(DX*8), BX		
  0x43e076		488b742468		MOVQ 0x68(SP), SI		
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp) && level < 2 {
  0x43e07b		4839de			CMPQ BX, SI		
  0x43e07e		74e6			JE 0x43e066		
  0x43e080		488b7c2448		MOVQ 0x48(SP), DI	
  0x43e085		4c8b4730		MOVQ 0x30(DI), R8	
  0x43e089		4d8b80c0000000		MOVQ 0xc0(R8), R8	
  0x43e090		4c39c3			CMPQ R8, BX		
  0x43e093		74d1			JE 0x43e066		
	return atomic.Load(&gp.atomicstatus)
  0x43e095		448b8390000000		MOVL 0x90(BX), R8	
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp) && level < 2 {
  0x43e09c		4183f806		CMPL $0x6, R8				
  0x43e0a0		74c4			JE 0x43e066				
  0x43e0a2		4889542428		MOVQ DX, 0x28(SP)			
  0x43e0a7		48895c2438		MOVQ BX, 0x38(SP)			
  0x43e0ac		48891c24		MOVQ BX, 0(SP)				
  0x43e0b0		e87b030000		CALL runtime.isSystemGoroutine(SB)	
  0x43e0b5		0fb6442408		MOVZX 0x8(SP), AX			
  0x43e0ba		84c0			TESTL AL, AL				
  0x43e0bc		741f			JE 0x43e0dd				
  0x43e0be		8b442424		MOVL 0x24(SP), AX			
  0x43e0c2		83f802			CMPL $0x2, AX				
  0x43e0c5		7d16			JGE 0x43e0dd				
  0x43e0c7		488b442430		MOVQ 0x30(SP), AX			
  0x43e0cc		488b4c2450		MOVQ 0x50(SP), CX			
  0x43e0d1		488b542428		MOVQ 0x28(SP), DX			
  0x43e0d6		488b742468		MOVQ 0x68(SP), SI			
  0x43e0db		eb89			JMP 0x43e066				
		print("\n")
  0x43e0dd		e81e3afeff		CALL runtime.printlock(SB)	
  0x43e0e2		e8a93cfeff		CALL runtime.printnl(SB)	
  0x43e0e7		e8943afeff		CALL runtime.printunlock(SB)	
  0x43e0ec		488b442438		MOVQ 0x38(SP), AX		
		goroutineheader(gp)
  0x43e0f1		48890424		MOVQ AX, 0(SP)				
  0x43e0f5		e826fcffff		CALL runtime.goroutineheader(SB)	
  0x43e0fa		488b442438		MOVQ 0x38(SP), AX			
		if gp.m != g.m && readgstatus(gp)&^_Gscan == _Grunning {
  0x43e0ff		488b4830		MOVQ 0x30(AX), CX	
  0x43e103		488b542448		MOVQ 0x48(SP), DX	
  0x43e108		488b5a30		MOVQ 0x30(DX), BX	
  0x43e10c		4839d9			CMPQ BX, CX		
  0x43e10f		7411			JE 0x43e122		
	return atomic.Load(&gp.atomicstatus)
  0x43e111		8b8890000000		MOVL 0x90(AX), CX	
		if gp.m != g.m && readgstatus(gp)&^_Gscan == _Grunning {
  0x43e117		81e1ffefffff		ANDL $-0x1001, CX	
  0x43e11d		83f902			CMPL $0x2, CX		
  0x43e120		743d			JE 0x43e15f		
			traceback(^uintptr(0), ^uintptr(0), 0, gp)
  0x43e122		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x43e12a		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43e133		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43e13c		4889442418		MOVQ AX, 0x18(SP)		
  0x43e141		e87af4ffff		CALL runtime.traceback(SB)	
  0x43e146		488b442430		MOVQ 0x30(SP), AX		
  0x43e14b		488b4c2450		MOVQ 0x50(SP), CX		
  0x43e150		488b542428		MOVQ 0x28(SP), DX		
  0x43e155		488b742468		MOVQ 0x68(SP), SI		
	for _, gp := range allgs {
  0x43e15a		e907ffffff		JMP 0x43e066		
			print("\tgoroutine running on other thread; stack unavailable\n")
  0x43e15f		e89c39feff		CALL runtime.printlock(SB)	
  0x43e164		488d05edf90200		LEAQ 0x2f9ed(IP), AX		
  0x43e16b		48890424		MOVQ AX, 0(SP)			
  0x43e16f		48c744240836000000	MOVQ $0x36, 0x8(SP)		
  0x43e178		e8c342feff		CALL runtime.printstring(SB)	
  0x43e17d		e8fe39feff		CALL runtime.printunlock(SB)	
  0x43e182		488b442438		MOVQ 0x38(SP), AX		
			printcreatedby(gp)
  0x43e187		48890424		MOVQ AX, 0(SP)			
  0x43e18b		e8f0f1ffff		CALL runtime.printcreatedby(SB)	
  0x43e190		ebb4			JMP 0x43e146			
	unlock(&allglock)
  0x43e192		488d057f570800		LEAQ runtime.allglock(SB), AX	
  0x43e199		48890424		MOVQ AX, 0(SP)			
  0x43e19d		e81eb5fcff		CALL runtime.unlock(SB)		
}
  0x43e1a2		488b6c2458		MOVQ 0x58(SP), BP	
  0x43e1a7		4883c460		ADDQ $0x60, SP		
  0x43e1ab		c3			RET			
  0x43e1ac		4889542440		MOVQ DX, 0x40(SP)	
		print("\n")
  0x43e1b1		e84a39feff		CALL runtime.printlock(SB)	
  0x43e1b6		e8d53bfeff		CALL runtime.printnl(SB)	
  0x43e1bb		e8c039feff		CALL runtime.printunlock(SB)	
  0x43e1c0		488b442440		MOVQ 0x40(SP), AX		
		goroutineheader(gp)
  0x43e1c5		48890424		MOVQ AX, 0(SP)				
  0x43e1c9		e852fbffff		CALL runtime.goroutineheader(SB)	
		traceback(^uintptr(0), ^uintptr(0), 0, gp)
  0x43e1ce		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x43e1d6		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43e1df		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43e1e8		488b442440		MOVQ 0x40(SP), AX		
  0x43e1ed		4889442418		MOVQ AX, 0x18(SP)		
  0x43e1f2		e8c9f3ffff		CALL runtime.traceback(SB)	
  0x43e1f7		e93efeffff		JMP 0x43e03a			
  0x43e1fc		488b5c2468		MOVQ 0x68(SP), BX		
	if gp != nil && gp != me {
  0x43e201		e934feffff		JMP 0x43e03a		
		level = int32(t >> tracebackShift)
  0x43e206		c1e902			SHRL $0x2, CX		
  0x43e209		89c8			MOVL CX, AX		
  0x43e20b		e9f6fdffff		JMP 0x43e006		
func tracebackothers(me *g) {
  0x43e210		e85b630000		CALL runtime.morestack_noctxt(SB)	
  0x43e215		e9a6fdffff		JMP runtime.tracebackothers(SB)		

TEXT runtime.tracebackHexdump(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func tracebackHexdump(stk stack, frame *stkframe, bad uintptr) {
  0x43e220		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e229		483b6110		CMPQ 0x10(CX), SP	
  0x43e22d		0f86ef010000		JBE 0x43e422		
  0x43e233		4883ec58		SUBQ $0x58, SP		
  0x43e237		48896c2450		MOVQ BP, 0x50(SP)	
  0x43e23c		488d6c2450		LEAQ 0x50(SP), BP	
  0x43e241		488b442470		MOVQ 0x70(SP), AX	
	lo, hi := frame.sp, frame.sp
  0x43e246		488b4828		MOVQ 0x28(AX), CX	
	if frame.fp != 0 && frame.fp < lo {
  0x43e24a		488b5030		MOVQ 0x30(AX), DX	
  0x43e24e		4885d2			TESTQ DX, DX		
  0x43e251		0f84c0010000		JE 0x43e417		
  0x43e257		4839ca			CMPQ CX, DX		
  0x43e25a		0f83b4010000		JAE 0x43e414		
  0x43e260		4885d2			TESTQ DX, DX		
  0x43e263		4889d3			MOVQ DX, BX		
	if frame.fp != 0 && frame.fp > hi {
  0x43e266		0f849d010000		JE 0x43e409		
  0x43e26c		4839cb			CMPQ CX, BX		
  0x43e26f		0f8694010000		JBE 0x43e409		
  0x43e275		4889de			MOVQ BX, SI		
	lo, hi = lo-expand, hi+expand
  0x43e278		4881c200ffffff		ADDQ $-0x100, DX	
	if lo < frame.sp-maxExpand {
  0x43e27f		488db900f8ffff		LEAQ 0xfffff800(CX), DI	
  0x43e286		4839fa			CMPQ DI, DX		
  0x43e289		0f8372010000		JAE 0x43e401		
	lo, hi = lo-expand, hi+expand
  0x43e28f		488d9300010000		LEAQ 0x100(BX), DX	
	if hi > frame.sp+maxExpand {
  0x43e296		488d9900080000		LEAQ 0x800(CX), BX	
  0x43e29d		4839da			CMPQ BX, DX		
  0x43e2a0		0f8653010000		JBE 0x43e3f9		
  0x43e2a6		488b542460		MOVQ 0x60(SP), DX	
	if lo < stk.lo {
  0x43e2ab		4839d7			CMPQ DX, DI		
  0x43e2ae		0f8338010000		JAE 0x43e3ec		
  0x43e2b4		4889d7			MOVQ DX, DI		
		lo = stk.lo
  0x43e2b7		48894c2420		MOVQ CX, 0x20(SP)	
  0x43e2bc		4889742430		MOVQ SI, 0x30(SP)	
  0x43e2c1		4889542418		MOVQ DX, 0x18(SP)	
  0x43e2c6		4c8b442468		MOVQ 0x68(SP), R8	
	if hi > stk.hi {
  0x43e2cb		4c39c3			CMPQ R8, BX		
  0x43e2ce		0f8610010000		JBE 0x43e3e4		
  0x43e2d4		4c89442428		MOVQ R8, 0x28(SP)	
	print("stack: frame={sp:", hex(frame.sp), ", fp:", hex(frame.fp), "} stack=[", hex(stk.lo), ",", hex(stk.hi), ")\n")
  0x43e2d9		e82238feff		CALL runtime.printlock(SB)	
  0x43e2de		488d0522ca0200		LEAQ 0x2ca22(IP), AX		
  0x43e2e5		48890424		MOVQ AX, 0(SP)			
  0x43e2e9		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x43e2f2		e84941feff		CALL runtime.printstring(SB)	
  0x43e2f7		488b442420		MOVQ 0x20(SP), AX		
  0x43e2fc		48890424		MOVQ AX, 0(SP)			
  0x43e300		e8eb3ffeff		CALL runtime.printhex(SB)	
  0x43e305		488d058eba0200		LEAQ 0x2ba8e(IP), AX		
  0x43e30c		48890424		MOVQ AX, 0(SP)			
  0x43e310		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43e319		e82241feff		CALL runtime.printstring(SB)	
  0x43e31e		488b442430		MOVQ 0x30(SP), AX		
  0x43e323		48890424		MOVQ AX, 0(SP)			
  0x43e327		e8c43ffeff		CALL runtime.printhex(SB)	
  0x43e32c		488d053abf0200		LEAQ 0x2bf3a(IP), AX		
  0x43e333		48890424		MOVQ AX, 0(SP)			
  0x43e337		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x43e340		e8fb40feff		CALL runtime.printstring(SB)	
  0x43e345		488b442460		MOVQ 0x60(SP), AX		
  0x43e34a		48890424		MOVQ AX, 0(SP)			
  0x43e34e		e89d3ffeff		CALL runtime.printhex(SB)	
  0x43e353		488d05fab80200		LEAQ 0x2b8fa(IP), AX		
  0x43e35a		48890424		MOVQ AX, 0(SP)			
  0x43e35e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e367		e8d440feff		CALL runtime.printstring(SB)	
  0x43e36c		488b442468		MOVQ 0x68(SP), AX		
  0x43e371		48890424		MOVQ AX, 0(SP)			
  0x43e375		e8763ffeff		CALL runtime.printhex(SB)	
  0x43e37a		488d05e9b80200		LEAQ 0x2b8e9(IP), AX		
  0x43e381		48890424		MOVQ AX, 0(SP)			
  0x43e385		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43e38e		e8ad40feff		CALL runtime.printstring(SB)	
  0x43e393		e8e837feff		CALL runtime.printunlock(SB)	
	hexdumpWords(lo, hi, func(p uintptr) byte {
  0x43e398		488d05c1590000		LEAQ runtime.tracebackHexdump.func1(SB), AX	
  0x43e39f		4889442438		MOVQ AX, 0x38(SP)				
  0x43e3a4		488b442470		MOVQ 0x70(SP), AX				
  0x43e3a9		4889442440		MOVQ AX, 0x40(SP)				
  0x43e3ae		488b442478		MOVQ 0x78(SP), AX				
  0x43e3b3		4889442448		MOVQ AX, 0x48(SP)				
  0x43e3b8		488b442418		MOVQ 0x18(SP), AX				
  0x43e3bd		48890424		MOVQ AX, 0(SP)					
  0x43e3c1		488b442428		MOVQ 0x28(SP), AX				
  0x43e3c6		4889442408		MOVQ AX, 0x8(SP)				
  0x43e3cb		488d442438		LEAQ 0x38(SP), AX				
  0x43e3d0		4889442410		MOVQ AX, 0x10(SP)				
  0x43e3d5		e88642feff		CALL runtime.hexdumpWords(SB)			
}
  0x43e3da		488b6c2450		MOVQ 0x50(SP), BP	
  0x43e3df		4883c458		ADDQ $0x58, SP		
  0x43e3e3		c3			RET			
  0x43e3e4		4989d8			MOVQ BX, R8		
	if hi > stk.hi {
  0x43e3e7		e9e8feffff		JMP 0x43e2d4		
  0x43e3ec		4889fa			MOVQ DI, DX		
  0x43e3ef		488b7c2460		MOVQ 0x60(SP), DI	
	if lo < stk.lo {
  0x43e3f4		e9befeffff		JMP 0x43e2b7		
  0x43e3f9		4889d3			MOVQ DX, BX		
	if hi > frame.sp+maxExpand {
  0x43e3fc		e9a5feffff		JMP 0x43e2a6		
  0x43e401		4889d7			MOVQ DX, DI		
	if lo < frame.sp-maxExpand {
  0x43e404		e986feffff		JMP 0x43e28f		
  0x43e409		4889de			MOVQ BX, SI		
  0x43e40c		4889cb			MOVQ CX, BX		
	if frame.fp != 0 && frame.fp > hi {
  0x43e40f		e964feffff		JMP 0x43e278		
	if frame.fp != 0 && frame.fp < lo {
  0x43e414		4885d2			TESTQ DX, DX		
  0x43e417		4889d3			MOVQ DX, BX		
  0x43e41a		4889ca			MOVQ CX, DX		
  0x43e41d		e944feffff		JMP 0x43e266		
func tracebackHexdump(stk stack, frame *stkframe, bad uintptr) {
  0x43e422		e849610000		CALL runtime.morestack_noctxt(SB)	
  0x43e427		e9f4fdffff		JMP runtime.tracebackHexdump(SB)	

TEXT runtime.isSystemGoroutine(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func isSystemGoroutine(gp *g) bool {
  0x43e430		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e439		483b6110		CMPQ 0x10(CX), SP	
  0x43e43d		0f868e000000		JBE 0x43e4d1		
  0x43e443		4883ec20		SUBQ $0x20, SP		
  0x43e447		48896c2418		MOVQ BP, 0x18(SP)	
  0x43e44c		488d6c2418		LEAQ 0x18(SP), BP	
  0x43e451		488b442428		MOVQ 0x28(SP), AX	
	f := findfunc(gp.startpc)
  0x43e456		488b8028010000		MOVQ 0x128(AX), AX		
  0x43e45d		48890424		MOVQ AX, 0(SP)			
  0x43e461		e86a9dffff		CALL runtime.findfunc(SB)	
  0x43e466		488b442408		MOVQ 0x8(SP), AX		
	return f._func != nil
  0x43e46b		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x43e46e		7452			JE 0x43e4c2		
	return f.funcID == funcID_runfinq && !fingRunning ||
  0x43e470		8b4010			MOVL 0x10(AX), AX			
  0x43e473		83f809			CMPL $0x9, AX				
  0x43e476		750b			JNE 0x43e483				
  0x43e478		0fb60d25540800		MOVZX runtime.fingRunning(SB), CX	
  0x43e47f		84c9			TESTL CL, CL				
  0x43e481		7438			JE 0x43e4bb				
		f.funcID == funcID_bgsweep ||
  0x43e483		83f80a			CMPL $0xa, AX		
  0x43e486		7513			JNE 0x43e49b		
  0x43e488		b801000000		MOVL $0x1, AX		
	return f.funcID == funcID_runfinq && !fingRunning ||
  0x43e48d		88442430		MOVB AL, 0x30(SP)	
		f.funcID == funcID_gcBgMarkWorker
  0x43e491		488b6c2418		MOVQ 0x18(SP), BP	
  0x43e496		4883c420		ADDQ $0x20, SP		
  0x43e49a		c3			RET			
		f.funcID == funcID_forcegchelper ||
  0x43e49b		83f80b			CMPL $0xb, AX		
  0x43e49e		7507			JNE 0x43e4a7		
  0x43e4a0		b801000000		MOVL $0x1, AX		
  0x43e4a5		ebe6			JMP 0x43e48d		
		f.funcID == funcID_timerproc ||
  0x43e4a7		83f80c			CMPL $0xc, AX		
  0x43e4aa		7507			JNE 0x43e4b3		
  0x43e4ac		b801000000		MOVL $0x1, AX		
  0x43e4b1		ebda			JMP 0x43e48d		
		f.funcID == funcID_gcBgMarkWorker
  0x43e4b3		83f80d			CMPL $0xd, AX		
  0x43e4b6		0f94c0			SETE AL			
  0x43e4b9		ebd2			JMP 0x43e48d		
  0x43e4bb		b801000000		MOVL $0x1, AX		
	return f.funcID == funcID_runfinq && !fingRunning ||
  0x43e4c0		ebcb			JMP 0x43e48d		
		return false
  0x43e4c2		c644243000		MOVB $0x0, 0x30(SP)	
  0x43e4c7		488b6c2418		MOVQ 0x18(SP), BP	
  0x43e4cc		4883c420		ADDQ $0x20, SP		
  0x43e4d0		c3			RET			
func isSystemGoroutine(gp *g) bool {
  0x43e4d1		e89a600000		CALL runtime.morestack_noctxt(SB)	
  0x43e4d6		e955ffffff		JMP runtime.isSystemGoroutine(SB)	

TEXT runtime.printCgoTraceback(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func printCgoTraceback(callers *cgoCallers) {
  0x43e4e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e4e9		483b6110		CMPQ 0x10(CX), SP	
  0x43e4ed		0f8605010000		JBE 0x43e5f8		
  0x43e4f3		4883ec70		SUBQ $0x70, SP		
  0x43e4f7		48896c2468		MOVQ BP, 0x68(SP)	
  0x43e4fc		488d6c2468		LEAQ 0x68(SP), BP	
	if cgoSymbolizer == nil {
  0x43e501		488b0530910600		MOVQ runtime.cgoSymbolizer(SB), AX	
  0x43e508		4885c0			TESTQ AX, AX				
  0x43e50b		747f			JE 0x43e58c				
	var arg cgoSymbolizerArg
  0x43e50d		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x43e516		0f57c0			XORPS X0, X0		
  0x43e519		0f11442438		MOVUPS X0, 0x38(SP)	
  0x43e51e		0f11442448		MOVUPS X0, 0x48(SP)	
  0x43e523		0f11442458		MOVUPS X0, 0x58(SP)	
  0x43e528		31c0			XORL AX, AX		
	for _, c := range callers {
  0x43e52a		eb29			JMP 0x43e555		
  0x43e52c		4889442428		MOVQ AX, 0x28(SP)	
		printOneCgoTraceback(c, 0x7fffffff, &arg)
  0x43e531		48891424		MOVQ DX, 0(SP)				
  0x43e535		48c7442408ffffff7f	MOVQ $0x7fffffff, 0x8(SP)		
  0x43e53e		488d442430		LEAQ 0x30(SP), AX			
  0x43e543		4889442410		MOVQ AX, 0x10(SP)			
  0x43e548		e8c3000000		CALL runtime.printOneCgoTraceback(SB)	
  0x43e54d		488b442428		MOVQ 0x28(SP), AX			
	for _, c := range callers {
  0x43e552		48ffc0			INCQ AX			
  0x43e555		4883f820		CMPQ $0x20, AX		
  0x43e559		7d10			JGE 0x43e56b		
  0x43e55b		488b4c2478		MOVQ 0x78(SP), CX	
  0x43e560		8401			TESTB AL, 0(CX)		
  0x43e562		488b14c1		MOVQ 0(CX)(AX*8), DX	
		if c == 0 {
  0x43e566		4885d2			TESTQ DX, DX		
  0x43e569		75c1			JNE 0x43e52c		
	arg.pc = 0
  0x43e56b		48c744243000000000	MOVQ $0x0, 0x30(SP)	
	callCgoSymbolizer(&arg)
  0x43e574		488d442430		LEAQ 0x30(SP), AX			
  0x43e579		48890424		MOVQ AX, 0(SP)				
  0x43e57d		e88e020000		CALL runtime.callCgoSymbolizer(SB)	
}
  0x43e582		488b6c2468		MOVQ 0x68(SP), BP	
  0x43e587		4883c470		ADDQ $0x70, SP		
  0x43e58b		c3			RET			
  0x43e58c		31c0			XORL AX, AX		
		for _, c := range callers {
  0x43e58e		eb48			JMP 0x43e5d8		
  0x43e590		4889442428		MOVQ AX, 0x28(SP)	
  0x43e595		4889542420		MOVQ DX, 0x20(SP)	
			print("non-Go function at pc=", hex(c), "\n")
  0x43e59a		e86135feff		CALL runtime.printlock(SB)	
  0x43e59f		488d05d0ce0200		LEAQ 0x2ced0(IP), AX		
  0x43e5a6		48890424		MOVQ AX, 0(SP)			
  0x43e5aa		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x43e5b3		e8883efeff		CALL runtime.printstring(SB)	
  0x43e5b8		488b442420		MOVQ 0x20(SP), AX		
  0x43e5bd		48890424		MOVQ AX, 0(SP)			
  0x43e5c1		e82a3dfeff		CALL runtime.printhex(SB)	
  0x43e5c6		e8c537feff		CALL runtime.printnl(SB)	
  0x43e5cb		e8b035feff		CALL runtime.printunlock(SB)	
  0x43e5d0		488b442428		MOVQ 0x28(SP), AX		
		for _, c := range callers {
  0x43e5d5		48ffc0			INCQ AX			
  0x43e5d8		4883f820		CMPQ $0x20, AX		
  0x43e5dc		7d10			JGE 0x43e5ee		
  0x43e5de		488b4c2478		MOVQ 0x78(SP), CX	
  0x43e5e3		8401			TESTB AL, 0(CX)		
  0x43e5e5		488b14c1		MOVQ 0(CX)(AX*8), DX	
			if c == 0 {
  0x43e5e9		4885d2			TESTQ DX, DX		
  0x43e5ec		75a2			JNE 0x43e590		
		return
  0x43e5ee		488b6c2468		MOVQ 0x68(SP), BP	
  0x43e5f3		4883c470		ADDQ $0x70, SP		
  0x43e5f7		c3			RET			
func printCgoTraceback(callers *cgoCallers) {
  0x43e5f8		e8735f0000		CALL runtime.morestack_noctxt(SB)	
  0x43e5fd		e9defeffff		JMP runtime.printCgoTraceback(SB)	

TEXT runtime.printOneCgoTraceback(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func printOneCgoTraceback(pc uintptr, max int, arg *cgoSymbolizerArg) int {
  0x43e610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e619		483b6110		CMPQ 0x10(CX), SP	
  0x43e61d		0f86d7010000		JBE 0x43e7fa		
  0x43e623		4883ec40		SUBQ $0x40, SP		
  0x43e627		48896c2438		MOVQ BP, 0x38(SP)	
  0x43e62c		488d6c2438		LEAQ 0x38(SP), BP	
  0x43e631		488b442448		MOVQ 0x48(SP), AX	
  0x43e636		488b4c2458		MOVQ 0x58(SP), CX	
	arg.pc = pc
  0x43e63b		488901			MOVQ AX, 0(CX)		
func printOneCgoTraceback(pc uintptr, max int, arg *cgoSymbolizerArg) int {
  0x43e63e		31d2			XORL DX, DX		
	for {
  0x43e640		eb08			JMP 0x43e64a		
  0x43e642		4889c2			MOVQ AX, DX		
  0x43e645		488b442448		MOVQ 0x48(SP), AX	
		if c > max {
  0x43e64a		488b5c2450		MOVQ 0x50(SP), BX	
  0x43e64f		4839da			CMPQ BX, DX		
  0x43e652		0f8f9a010000		JG 0x43e7f2		
  0x43e658		4889542418		MOVQ DX, 0x18(SP)	
		callCgoSymbolizer(arg)
  0x43e65d		48890c24		MOVQ CX, 0(SP)				
  0x43e661		e8aa010000		CALL runtime.callCgoSymbolizer(SB)	
  0x43e666		488b442458		MOVQ 0x58(SP), AX			
		if arg.funcName != nil {
  0x43e66b		488b4818		MOVQ 0x18(AX), CX	
  0x43e66f		4885c9			TESTQ CX, CX		
  0x43e672		0f8452010000		JE 0x43e7ca		
			println(gostringnocopy(arg.funcName))
  0x43e678		48890c24		MOVQ CX, 0(SP)			
  0x43e67c		e86f90ffff		CALL runtime.gostringnocopy(SB)	
  0x43e681		488b442410		MOVQ 0x10(SP), AX		
  0x43e686		4889442428		MOVQ AX, 0x28(SP)		
  0x43e68b		488b4c2408		MOVQ 0x8(SP), CX		
  0x43e690		48894c2430		MOVQ CX, 0x30(SP)		
  0x43e695		e86634feff		CALL runtime.printlock(SB)	
  0x43e69a		488b442430		MOVQ 0x30(SP), AX		
  0x43e69f		48890424		MOVQ AX, 0(SP)			
  0x43e6a3		488b442428		MOVQ 0x28(SP), AX		
  0x43e6a8		4889442408		MOVQ AX, 0x8(SP)		
  0x43e6ad		e88e3dfeff		CALL runtime.printstring(SB)	
  0x43e6b2		e8d936feff		CALL runtime.printnl(SB)	
  0x43e6b7		e8c434feff		CALL runtime.printunlock(SB)	
		print("\t")
  0x43e6bc		e83f34feff		CALL runtime.printlock(SB)	
  0x43e6c1		488d0596b50200		LEAQ 0x2b596(IP), AX		
  0x43e6c8		48890424		MOVQ AX, 0(SP)			
  0x43e6cc		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e6d5		e8663dfeff		CALL runtime.printstring(SB)	
  0x43e6da		e8a134feff		CALL runtime.printunlock(SB)	
  0x43e6df		488b442458		MOVQ 0x58(SP), AX		
		if arg.file != nil {
  0x43e6e4		488b4808		MOVQ 0x8(AX), CX	
  0x43e6e8		4885c9			TESTQ CX, CX		
  0x43e6eb		755f			JNE 0x43e74c		
		print("pc=", hex(pc), "\n")
  0x43e6ed		e80e34feff		CALL runtime.printlock(SB)	
  0x43e6f2		488d05beb50200		LEAQ 0x2b5be(IP), AX		
  0x43e6f9		48890424		MOVQ AX, 0(SP)			
  0x43e6fd		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43e706		e8353dfeff		CALL runtime.printstring(SB)	
  0x43e70b		488b442448		MOVQ 0x48(SP), AX		
  0x43e710		48890424		MOVQ AX, 0(SP)			
  0x43e714		e8d73bfeff		CALL runtime.printhex(SB)	
  0x43e719		e87236feff		CALL runtime.printnl(SB)	
  0x43e71e		e85d34feff		CALL runtime.printunlock(SB)	
  0x43e723		488b442418		MOVQ 0x18(SP), AX		
		c++
  0x43e728		48ffc0			INCQ AX			
  0x43e72b		488b4c2458		MOVQ 0x58(SP), CX	
		if arg.more == 0 {
  0x43e730		488b5128		MOVQ 0x28(CX), DX	
  0x43e734		4885d2			TESTQ DX, DX		
  0x43e737		0f8505ffffff		JNE 0x43e642		
	return c
  0x43e73d		4889442460		MOVQ AX, 0x60(SP)	
  0x43e742		488b6c2438		MOVQ 0x38(SP), BP	
  0x43e747		4883c440		ADDQ $0x40, SP		
  0x43e74b		c3			RET			
			print(gostringnocopy(arg.file), ":", arg.lineno, " ")
  0x43e74c		48890c24		MOVQ CX, 0(SP)			
  0x43e750		e89b8fffff		CALL runtime.gostringnocopy(SB)	
  0x43e755		488b442408		MOVQ 0x8(SP), AX		
  0x43e75a		4889442430		MOVQ AX, 0x30(SP)		
  0x43e75f		488b4c2410		MOVQ 0x10(SP), CX		
  0x43e764		48894c2428		MOVQ CX, 0x28(SP)		
  0x43e769		488b542458		MOVQ 0x58(SP), DX		
  0x43e76e		488b5a10		MOVQ 0x10(DX), BX		
  0x43e772		48895c2420		MOVQ BX, 0x20(SP)		
  0x43e777		e88433feff		CALL runtime.printlock(SB)	
  0x43e77c		488b442430		MOVQ 0x30(SP), AX		
  0x43e781		48890424		MOVQ AX, 0(SP)			
  0x43e785		488b442428		MOVQ 0x28(SP), AX		
  0x43e78a		4889442408		MOVQ AX, 0x8(SP)		
  0x43e78f		e8ac3cfeff		CALL runtime.printstring(SB)	
  0x43e794		488d05bdb40200		LEAQ 0x2b4bd(IP), AX		
  0x43e79b		48890424		MOVQ AX, 0(SP)			
  0x43e79f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e7a8		e8933cfeff		CALL runtime.printstring(SB)	
  0x43e7ad		488b442420		MOVQ 0x20(SP), AX		
  0x43e7b2		48890424		MOVQ AX, 0(SP)			
  0x43e7b6		e8b539feff		CALL runtime.printuint(SB)	
  0x43e7bb		e88035feff		CALL runtime.printsp(SB)	
  0x43e7c0		e8bb33feff		CALL runtime.printunlock(SB)	
  0x43e7c5		e923ffffff		JMP 0x43e6ed			
			println("non-Go function")
  0x43e7ca		e83133feff		CALL runtime.printlock(SB)	
  0x43e7cf		488d054cc30200		LEAQ 0x2c34c(IP), AX		
  0x43e7d6		48890424		MOVQ AX, 0(SP)			
  0x43e7da		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x43e7e3		e8583cfeff		CALL runtime.printstring(SB)	
  0x43e7e8		e89333feff		CALL runtime.printunlock(SB)	
  0x43e7ed		e9cafeffff		JMP 0x43e6bc			
  0x43e7f2		4889d0			MOVQ DX, AX			
			break
  0x43e7f5		e943ffffff		JMP 0x43e73d		
func printOneCgoTraceback(pc uintptr, max int, arg *cgoSymbolizerArg) int {
  0x43e7fa		e8715d0000		CALL runtime.morestack_noctxt(SB)	
  0x43e7ff		e90cfeffff		JMP runtime.printOneCgoTraceback(SB)	

TEXT runtime.callCgoSymbolizer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func callCgoSymbolizer(arg *cgoSymbolizerArg) {
  0x43e810		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e819		483b6110		CMPQ 0x10(CX), SP	
  0x43e81d		7668			JBE 0x43e887		
  0x43e81f		4883ec20		SUBQ $0x20, SP		
  0x43e823		48896c2418		MOVQ BP, 0x18(SP)	
  0x43e828		488d6c2418		LEAQ 0x18(SP), BP	
	if panicking > 0 || getg().m.curg != getg() {
  0x43e82d		8b05c1500800		MOVL runtime.panicking(SB), AX	
  0x43e833		85c0			TESTL AX, AX			
  0x43e835		762e			JBE 0x43e865			
  0x43e837		488d0562f70200		LEAQ 0x2f762(IP), AX		
	call(cgoSymbolizer, noescape(unsafe.Pointer(arg)))
  0x43e83e		488b0df38d0600		MOVQ runtime.cgoSymbolizer(SB), CX	
  0x43e845		48890c24		MOVQ CX, 0(SP)				
  0x43e849		488b4c2428		MOVQ 0x28(SP), CX			
  0x43e84e		48894c2408		MOVQ CX, 0x8(SP)			
  0x43e853		488b08			MOVQ 0(AX), CX				
  0x43e856		4889c2			MOVQ AX, DX				
  0x43e859		ffd1			CALL CX					
}
  0x43e85b		488b6c2418		MOVQ 0x18(SP), BP	
  0x43e860		4883c420		ADDQ $0x20, SP		
  0x43e864		c3			RET			
	if panicking > 0 || getg().m.curg != getg() {
  0x43e865		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43e86e		488b4830		MOVQ 0x30(AX), CX	
  0x43e872		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x43e879		4839c1			CMPQ AX, CX		
  0x43e87c		75b9			JNE 0x43e837		
  0x43e87e		488d0573f70200		LEAQ 0x2f773(IP), AX	
  0x43e885		ebb7			JMP 0x43e83e		
func callCgoSymbolizer(arg *cgoSymbolizerArg) {
  0x43e887		e8e45c0000		CALL runtime.morestack_noctxt(SB)	
  0x43e88c		eb82			JMP runtime.callCgoSymbolizer(SB)	

TEXT runtime.cgoContextPCs(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
func cgoContextPCs(ctxt uintptr, buf []uintptr) {
  0x43e890		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e899		483b6110		CMPQ 0x10(CX), SP	
  0x43e89d		0f86b5000000		JBE 0x43e958		
  0x43e8a3		4883ec40		SUBQ $0x40, SP		
  0x43e8a7		48896c2438		MOVQ BP, 0x38(SP)	
  0x43e8ac		488d6c2438		LEAQ 0x38(SP), BP	
	if cgoTraceback == nil {
  0x43e8b1		488b05888d0600		MOVQ runtime.cgoTraceback(SB), AX	
  0x43e8b8		4885c0			TESTQ AX, AX				
  0x43e8bb		0f8486000000		JE 0x43e947				
	if panicking > 0 || getg().m.curg != getg() {
  0x43e8c1		8b052d500800		MOVL runtime.panicking(SB), AX	
  0x43e8c7		85c0			TESTL AX, AX			
  0x43e8c9		765a			JBE 0x43e925			
  0x43e8cb		488d05cef60200		LEAQ 0x2f6ce(IP), AX		
		buf:     (*uintptr)(noescape(unsafe.Pointer(&buf[0]))),
  0x43e8d2		488b4c2458		MOVQ 0x58(SP), CX	
  0x43e8d7		4885c9			TESTQ CX, CX		
  0x43e8da		7675			JBE 0x43e951		
	arg := cgoTracebackArg{
  0x43e8dc		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x43e8e5		488b5c2448		MOVQ 0x48(SP), BX	
  0x43e8ea		48895c2418		MOVQ BX, 0x18(SP)	
  0x43e8ef		488b5c2450		MOVQ 0x50(SP), BX	
		buf:     (*uintptr)(noescape(unsafe.Pointer(&buf[0]))),
  0x43e8f4		48895c2428		MOVQ BX, 0x28(SP)	
		max:     uintptr(len(buf)),
  0x43e8f9		48894c2430		MOVQ CX, 0x30(SP)	
	call(cgoTraceback, noescape(unsafe.Pointer(&arg)))
  0x43e8fe		488b0d3b8d0600		MOVQ runtime.cgoTraceback(SB), CX	
  0x43e905		48890c24		MOVQ CX, 0(SP)				
  0x43e909		488d4c2418		LEAQ 0x18(SP), CX			
  0x43e90e		48894c2408		MOVQ CX, 0x8(SP)			
  0x43e913		488b08			MOVQ 0(AX), CX				
  0x43e916		4889c2			MOVQ AX, DX				
  0x43e919		ffd1			CALL CX					
}
  0x43e91b		488b6c2438		MOVQ 0x38(SP), BP	
  0x43e920		4883c440		ADDQ $0x40, SP		
  0x43e924		c3			RET			
	if panicking > 0 || getg().m.curg != getg() {
  0x43e925		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43e92e		488b4830		MOVQ 0x30(AX), CX	
  0x43e932		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x43e939		4839c1			CMPQ AX, CX		
  0x43e93c		758d			JNE 0x43e8cb		
  0x43e93e		488d05b3f60200		LEAQ 0x2f6b3(IP), AX	
  0x43e945		eb8b			JMP 0x43e8d2		
		return
  0x43e947		488b6c2438		MOVQ 0x38(SP), BP	
  0x43e94c		4883c440		ADDQ $0x40, SP		
  0x43e950		c3			RET			
		buf:     (*uintptr)(noescape(unsafe.Pointer(&buf[0]))),
  0x43e951		e8ea10feff		CALL runtime.panicindex(SB)	
  0x43e956		0f0b			UD2				
func cgoContextPCs(ctxt uintptr, buf []uintptr) {
  0x43e958		e8135c0000		CALL runtime.morestack_noctxt(SB)	
  0x43e95d		e92effffff		JMP runtime.cgoContextPCs(SB)		

TEXT runtime.(*_type).string(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (t *_type) string() string {
  0x43e970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43e979		483b6110		CMPQ 0x10(CX), SP	
  0x43e97d		0f8692000000		JBE 0x43ea15		
  0x43e983		4883ec20		SUBQ $0x20, SP		
  0x43e987		48896c2418		MOVQ BP, 0x18(SP)	
  0x43e98c		488d6c2418		LEAQ 0x18(SP), BP	
  0x43e991		488b442428		MOVQ 0x28(SP), AX	
	s := t.nameOff(t.str).name()
  0x43e996		8b4828			MOVL 0x28(AX), CX			
  0x43e999		894c2408		MOVL CX, 0x8(SP)			
  0x43e99d		48890424		MOVQ AX, 0(SP)				
  0x43e9a1		e88a040000		CALL runtime.(*_type).nameOff(SB)	
  0x43e9a6		488b442410		MOVQ 0x10(SP), AX			
  0x43e9ab		48890424		MOVQ AX, 0(SP)				
  0x43e9af		e8dc0b0000		CALL runtime.name.name(SB)		
  0x43e9b4		488b442408		MOVQ 0x8(SP), AX			
  0x43e9b9		488b4c2410		MOVQ 0x10(SP), CX			
  0x43e9be		488b542428		MOVQ 0x28(SP), DX			
	if t.tflag&tflagExtraStar != 0 {
  0x43e9c3		0fb65214		MOVZX 0x14(DX), DX	
  0x43e9c7		f6c202			TESTL $0x2, DL		
  0x43e9ca		742e			JE 0x43e9fa		
		return s[1:]
  0x43e9cc		4883f901		CMPQ $0x1, CX		
  0x43e9d0		723c			JB 0x43ea0e		
  0x43e9d2		48ffc9			DECQ CX			
  0x43e9d5		4889ca			MOVQ CX, DX		
  0x43e9d8		48f7d9			NEGQ CX			
  0x43e9db		48c1f93f		SARQ $0x3f, CX		
  0x43e9df		4883e101		ANDQ $0x1, CX		
  0x43e9e3		4801c8			ADDQ CX, AX		
  0x43e9e6		4889442430		MOVQ AX, 0x30(SP)	
  0x43e9eb		4889542438		MOVQ DX, 0x38(SP)	
  0x43e9f0		488b6c2418		MOVQ 0x18(SP), BP	
  0x43e9f5		4883c420		ADDQ $0x20, SP		
  0x43e9f9		c3			RET			
	return s
  0x43e9fa		4889442430		MOVQ AX, 0x30(SP)	
  0x43e9ff		48894c2438		MOVQ CX, 0x38(SP)	
  0x43ea04		488b6c2418		MOVQ 0x18(SP), BP	
  0x43ea09		4883c420		ADDQ $0x20, SP		
  0x43ea0d		c3			RET			
		return s[1:]
  0x43ea0e		e89d10feff		CALL runtime.panicslice(SB)	
  0x43ea13		0f0b			UD2				
func (t *_type) string() string {
  0x43ea15		e8565b0000		CALL runtime.morestack_noctxt(SB)	
  0x43ea1a		e951ffffff		JMP runtime.(*_type).string(SB)		

TEXT runtime.(*_type).uncommon(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (t *_type) uncommon() *uncommontype {
  0x43ea20		488b442408		MOVQ 0x8(SP), AX	
	if t.tflag&tflagUncommon == 0 {
  0x43ea25		0fb64814		MOVZX 0x14(AX), CX	
  0x43ea29		f6c101			TESTL $0x1, CL		
  0x43ea2c		0f848e000000		JE 0x43eac0		
	switch t.kind & kindMask {
  0x43ea32		0fb64817		MOVZX 0x17(AX), CX	
  0x43ea36		83e11f			ANDL $0x1f, CX		
  0x43ea39		80f914			CMPL $0x14, CL		
  0x43ea3c		7746			JA 0x43ea84		
  0x43ea3e		80f912			CMPL $0x12, CL		
  0x43ea41		7728			JA 0x43ea6b		
	case kindArray:
  0x43ea43		80f911			CMPL $0x11, CL		
  0x43ea46		7419			JE 0x43ea61		
	switch t.kind & kindMask {
  0x43ea48		80f912			CMPL $0x12, CL		
	case kindChan:
  0x43ea4b		740a			JE 0x43ea57		
		return &(*u)(unsafe.Pointer(t)).u
  0x43ea4d		4883c030		ADDQ $0x30, AX		
  0x43ea51		4889442410		MOVQ AX, 0x10(SP)	
  0x43ea56		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x43ea57		4883c040		ADDQ $0x40, AX		
  0x43ea5b		4889442410		MOVQ AX, 0x10(SP)	
  0x43ea60		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x43ea61		4883c048		ADDQ $0x48, AX		
  0x43ea65		4889442410		MOVQ AX, 0x10(SP)	
  0x43ea6a		c3			RET			
	case kindFunc:
  0x43ea6b		80f913			CMPL $0x13, CL		
  0x43ea6e		750a			JNE 0x43ea7a		
		return &(*u)(unsafe.Pointer(t)).u
  0x43ea70		4883c038		ADDQ $0x38, AX		
  0x43ea74		4889442410		MOVQ AX, 0x10(SP)	
  0x43ea79		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x43ea7a		4883c050		ADDQ $0x50, AX		
  0x43ea7e		4889442410		MOVQ AX, 0x10(SP)	
  0x43ea83		c3			RET			
	switch t.kind & kindMask {
  0x43ea84		80f916			CMPL $0x16, CL		
  0x43ea87		7719			JA 0x43eaa2		
	case kindMap:
  0x43ea89		80f915			CMPL $0x15, CL		
  0x43ea8c		750a			JNE 0x43ea98		
		return &(*u)(unsafe.Pointer(t)).u
  0x43ea8e		4883c058		ADDQ $0x58, AX		
  0x43ea92		4889442410		MOVQ AX, 0x10(SP)	
  0x43ea97		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x43ea98		4883c038		ADDQ $0x38, AX		
  0x43ea9c		4889442410		MOVQ AX, 0x10(SP)	
  0x43eaa1		c3			RET			
	case kindSlice:
  0x43eaa2		80f917			CMPL $0x17, CL		
  0x43eaa5		740f			JE 0x43eab6		
	case kindStruct:
  0x43eaa7		80f919			CMPL $0x19, CL		
  0x43eaaa		75a1			JNE 0x43ea4d		
		return &(*u)(unsafe.Pointer(t)).u
  0x43eaac		4883c050		ADDQ $0x50, AX		
  0x43eab0		4889442410		MOVQ AX, 0x10(SP)	
  0x43eab5		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x43eab6		4883c038		ADDQ $0x38, AX		
  0x43eaba		4889442410		MOVQ AX, 0x10(SP)	
  0x43eabf		c3			RET			
		return nil
  0x43eac0		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x43eac9		c3			RET			

TEXT runtime.reflectOffsLock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func reflectOffsLock() {
  0x43ead0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ead9		483b6110		CMPQ 0x10(CX), SP	
  0x43eadd		7628			JBE 0x43eb07		
  0x43eadf		4883ec10		SUBQ $0x10, SP		
  0x43eae3		48896c2408		MOVQ BP, 0x8(SP)	
  0x43eae8		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&reflectOffs.lock)
  0x43eaed		488d05ac8c0600		LEAQ runtime.reflectOffs(SB), AX	
  0x43eaf4		48890424		MOVQ AX, 0(SP)				
  0x43eaf8		e823aafcff		CALL runtime.lock(SB)			
  0x43eafd		488b6c2408		MOVQ 0x8(SP), BP			
  0x43eb02		4883c410		ADDQ $0x10, SP				
  0x43eb06		c3			RET					
func reflectOffsLock() {
  0x43eb07		e8645a0000		CALL runtime.morestack_noctxt(SB)	
  0x43eb0c		ebc2			JMP runtime.reflectOffsLock(SB)		

TEXT runtime.reflectOffsUnlock(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func reflectOffsUnlock() {
  0x43eb10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43eb19		483b6110		CMPQ 0x10(CX), SP	
  0x43eb1d		7628			JBE 0x43eb47		
  0x43eb1f		4883ec10		SUBQ $0x10, SP		
  0x43eb23		48896c2408		MOVQ BP, 0x8(SP)	
  0x43eb28		488d6c2408		LEAQ 0x8(SP), BP	
	unlock(&reflectOffs.lock)
  0x43eb2d		488d056c8c0600		LEAQ runtime.reflectOffs(SB), AX	
  0x43eb34		48890424		MOVQ AX, 0(SP)				
  0x43eb38		e883abfcff		CALL runtime.unlock(SB)			
}
  0x43eb3d		488b6c2408		MOVQ 0x8(SP), BP	
  0x43eb42		4883c410		ADDQ $0x10, SP		
  0x43eb46		c3			RET			
func reflectOffsUnlock() {
  0x43eb47		e8245a0000		CALL runtime.morestack_noctxt(SB)	
  0x43eb4c		ebc2			JMP runtime.reflectOffsUnlock(SB)	

TEXT runtime.resolveNameOff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {
  0x43eb50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43eb59		483b6110		CMPQ 0x10(CX), SP	
  0x43eb5d		0f86bd020000		JBE 0x43ee20		
  0x43eb63		4883ec60		SUBQ $0x60, SP		
  0x43eb67		48896c2458		MOVQ BP, 0x58(SP)	
  0x43eb6c		488d6c2458		LEAQ 0x58(SP), BP	
  0x43eb71		8b442470		MOVL 0x70(SP), AX	
	if off == 0 {
  0x43eb75		85c0			TESTL AX, AX		
  0x43eb77		0f84ca010000		JE 0x43ed47		
  0x43eb7d		488b4c2468		MOVQ 0x68(SP), CX	
	base := uintptr(ptrInModule)
  0x43eb82		488d15b76c0600		LEAQ runtime.firstmoduledata(SB), DX	
	for md := &firstmoduledata; md != nil; md = md.next {
  0x43eb89		eb07			JMP 0x43eb92		
  0x43eb8b		488b92c0010000		MOVQ 0x1c0(DX), DX	
  0x43eb92		4885d2			TESTQ DX, DX		
  0x43eb95		7436			JE 0x43ebcd		
		if base >= md.types && base < md.etypes {
  0x43eb97		488b9ac8000000		MOVQ 0xc8(DX), BX	
  0x43eb9e		4839d9			CMPQ BX, CX		
  0x43eba1		72e8			JB 0x43eb8b		
  0x43eba3		488bb2d0000000		MOVQ 0xd0(DX), SI	
  0x43ebaa		4839f1			CMPQ SI, CX		
  0x43ebad		73dc			JAE 0x43eb8b		
			res := md.types + uintptr(off)
  0x43ebaf		4863c8			MOVSXD AX, CX		
  0x43ebb2		4801d9			ADDQ BX, CX		
			if res > md.etypes {
  0x43ebb5		4839f1			CMPQ SI, CX		
  0x43ebb8		0f87b7010000		JA 0x43ed75		
			return name{(*byte)(unsafe.Pointer(res))}
  0x43ebbe		48894c2478		MOVQ CX, 0x78(SP)	
  0x43ebc3		488b6c2458		MOVQ 0x58(SP), BP	
  0x43ebc8		4883c460		ADDQ $0x60, SP		
  0x43ebcc		c3			RET			
  0x43ebcd		48894c2430		MOVQ CX, 0x30(SP)	
	reflectOffsLock()
  0x43ebd2		e8f9feffff		CALL runtime.reflectOffsLock(SB)	
	res, found := reflectOffs.m[int32(off)]
  0x43ebd7		488d05a2bd0100		LEAQ 0x1bda2(IP), AX			
  0x43ebde		48890424		MOVQ AX, 0(SP)				
  0x43ebe2		488b05c78b0600		MOVQ runtime.reflectOffs+16(SB), AX	
  0x43ebe9		4889442408		MOVQ AX, 0x8(SP)			
  0x43ebee		8b442470		MOVL 0x70(SP), AX			
  0x43ebf2		89442410		MOVL AX, 0x10(SP)			
  0x43ebf6		e8158efcff		CALL runtime.mapaccess2_fast32(SB)	
  0x43ebfb		488b442418		MOVQ 0x18(SP), AX			
  0x43ec00		0fb64c2420		MOVZX 0x20(SP), CX			
  0x43ec05		884c242f		MOVB CL, 0x2f(SP)			
  0x43ec09		488b00			MOVQ 0(AX), AX				
  0x43ec0c		4889442448		MOVQ AX, 0x48(SP)			
	reflectOffsUnlock()
  0x43ec11		e8fafeffff		CALL runtime.reflectOffsUnlock(SB)	
  0x43ec16		0fb644242f		MOVZX 0x2f(SP), AX			
	res, found := reflectOffs.m[int32(off)]
  0x43ec1b		84c0			TESTL AL, AL		
	if !found {
  0x43ec1d		0f8510010000		JNE 0x43ed33		
		println("runtime: nameOff", hex(off), "base", hex(base), "not in ranges:")
  0x43ec23		e8d82efeff		CALL runtime.printlock(SB)		
  0x43ec28		488d0572c00200		LEAQ 0x2c072(IP), AX			
  0x43ec2f		48890424		MOVQ AX, 0(SP)				
  0x43ec33		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x43ec3c		e8ff37feff		CALL runtime.printstring(SB)		
  0x43ec41		8b442470		MOVL 0x70(SP), AX			
  0x43ec45		4863c0			MOVSXD AX, AX				
  0x43ec48		48890424		MOVQ AX, 0(SP)				
  0x43ec4c		e89f36feff		CALL runtime.printhex(SB)		
  0x43ec51		488d0595b10200		LEAQ 0x2b195(IP), AX			
  0x43ec58		48890424		MOVQ AX, 0(SP)				
  0x43ec5c		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x43ec65		e8d637feff		CALL runtime.printstring(SB)		
  0x43ec6a		488b442430		MOVQ 0x30(SP), AX			
  0x43ec6f		48890424		MOVQ AX, 0(SP)				
  0x43ec73		e87836feff		CALL runtime.printhex(SB)		
  0x43ec78		488d0593bd0200		LEAQ 0x2bd93(IP), AX			
  0x43ec7f		48890424		MOVQ AX, 0(SP)				
  0x43ec83		48c744240810000000	MOVQ $0x10, 0x8(SP)			
  0x43ec8c		e8af37feff		CALL runtime.printstring(SB)		
  0x43ec91		e8ea2efeff		CALL runtime.printunlock(SB)		
  0x43ec96		488d05a36b0600		LEAQ runtime.firstmoduledata(SB), AX	
		for next := &firstmoduledata; next != nil; next = next.next {
  0x43ec9d		e986000000		JMP 0x43ed28		
  0x43eca2		4889442450		MOVQ AX, 0x50(SP)	
			println("\ttypes", hex(next.types), "etypes", hex(next.etypes))
  0x43eca7		488b88c8000000		MOVQ 0xc8(AX), CX		
  0x43ecae		48894c2440		MOVQ CX, 0x40(SP)		
  0x43ecb3		488b90d0000000		MOVQ 0xd0(AX), DX		
  0x43ecba		4889542438		MOVQ DX, 0x38(SP)		
  0x43ecbf		e83c2efeff		CALL runtime.printlock(SB)	
  0x43ecc4		488d05eab10200		LEAQ 0x2b1ea(IP), AX		
  0x43eccb		48890424		MOVQ AX, 0(SP)			
  0x43eccf		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43ecd8		e86337feff		CALL runtime.printstring(SB)	
  0x43ecdd		488b442440		MOVQ 0x40(SP), AX		
  0x43ece2		48890424		MOVQ AX, 0(SP)			
  0x43ece6		e80536feff		CALL runtime.printhex(SB)	
  0x43eceb		488d0595b20200		LEAQ 0x2b295(IP), AX		
  0x43ecf2		48890424		MOVQ AX, 0(SP)			
  0x43ecf6		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43ecff		e83c37feff		CALL runtime.printstring(SB)	
  0x43ed04		488b442438		MOVQ 0x38(SP), AX		
  0x43ed09		48890424		MOVQ AX, 0(SP)			
  0x43ed0d		e8de35feff		CALL runtime.printhex(SB)	
  0x43ed12		e87930feff		CALL runtime.printnl(SB)	
  0x43ed17		e8642efeff		CALL runtime.printunlock(SB)	
  0x43ed1c		488b442450		MOVQ 0x50(SP), AX		
		for next := &firstmoduledata; next != nil; next = next.next {
  0x43ed21		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x43ed28		4885c0			TESTQ AX, AX		
  0x43ed2b		0f8571ffffff		JNE 0x43eca2		
  0x43ed31		eb27			JMP 0x43ed5a		
	return name{(*byte)(res)}
  0x43ed33		488b442448		MOVQ 0x48(SP), AX	
  0x43ed38		4889442478		MOVQ AX, 0x78(SP)	
  0x43ed3d		488b6c2458		MOVQ 0x58(SP), BP	
  0x43ed42		4883c460		ADDQ $0x60, SP		
  0x43ed46		c3			RET			
		return name{}
  0x43ed47		48c744247800000000	MOVQ $0x0, 0x78(SP)	
  0x43ed50		488b6c2458		MOVQ 0x58(SP), BP	
  0x43ed55		4883c460		ADDQ $0x60, SP		
  0x43ed59		c3			RET			
		throw("runtime: name offset base pointer out of range")
  0x43ed5a		488d0527ea0200		LEAQ 0x2ea27(IP), AX	
  0x43ed61		48890424		MOVQ AX, 0(SP)		
  0x43ed65		48c74424082e000000	MOVQ $0x2e, 0x8(SP)	
  0x43ed6e		e85d24feff		CALL runtime.throw(SB)	
  0x43ed73		0f0b			UD2			
  0x43ed75		48895c2440		MOVQ BX, 0x40(SP)	
  0x43ed7a		4889742438		MOVQ SI, 0x38(SP)	
				println("runtime: nameOff", hex(off), "out of range", hex(md.types), "-", hex(md.etypes))
  0x43ed7f		e87c2dfeff		CALL runtime.printlock(SB)	
  0x43ed84		488d0516bf0200		LEAQ 0x2bf16(IP), AX		
  0x43ed8b		48890424		MOVQ AX, 0(SP)			
  0x43ed8f		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x43ed98		e8a336feff		CALL runtime.printstring(SB)	
  0x43ed9d		8b442470		MOVL 0x70(SP), AX		
  0x43eda1		4863c0			MOVSXD AX, AX			
  0x43eda4		48890424		MOVQ AX, 0(SP)			
  0x43eda8		e84335feff		CALL runtime.printhex(SB)	
  0x43edad		488d0538ba0200		LEAQ 0x2ba38(IP), AX		
  0x43edb4		48890424		MOVQ AX, 0(SP)			
  0x43edb8		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x43edc1		e87a36feff		CALL runtime.printstring(SB)	
  0x43edc6		488b442440		MOVQ 0x40(SP), AX		
  0x43edcb		48890424		MOVQ AX, 0(SP)			
  0x43edcf		e81c35feff		CALL runtime.printhex(SB)	
  0x43edd4		488d05afae0200		LEAQ 0x2aeaf(IP), AX		
  0x43eddb		48890424		MOVQ AX, 0(SP)			
  0x43eddf		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43ede8		e85336feff		CALL runtime.printstring(SB)	
  0x43eded		488b442438		MOVQ 0x38(SP), AX		
  0x43edf2		48890424		MOVQ AX, 0(SP)			
  0x43edf6		e8f534feff		CALL runtime.printhex(SB)	
  0x43edfb		e8902ffeff		CALL runtime.printnl(SB)	
  0x43ee00		e87b2dfeff		CALL runtime.printunlock(SB)	
				throw("runtime: name offset out of range")
  0x43ee05		488d05a1dc0200		LEAQ 0x2dca1(IP), AX	
  0x43ee0c		48890424		MOVQ AX, 0(SP)		
  0x43ee10		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x43ee19		e8b223feff		CALL runtime.throw(SB)	
  0x43ee1e		0f0b			UD2			
func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {
  0x43ee20		e84b570000		CALL runtime.morestack_noctxt(SB)	
  0x43ee25		e926fdffff		JMP runtime.resolveNameOff(SB)		

TEXT runtime.(*_type).nameOff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (t *_type) nameOff(off nameOff) name {
  0x43ee30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ee39		483b6110		CMPQ 0x10(CX), SP	
  0x43ee3d		7638			JBE 0x43ee77		
  0x43ee3f		4883ec20		SUBQ $0x20, SP		
  0x43ee43		48896c2418		MOVQ BP, 0x18(SP)	
  0x43ee48		488d6c2418		LEAQ 0x18(SP), BP	
  0x43ee4d		488b442428		MOVQ 0x28(SP), AX	
	return resolveNameOff(unsafe.Pointer(t), off)
  0x43ee52		48890424		MOVQ AX, 0(SP)		
func (t *_type) nameOff(off nameOff) name {
  0x43ee56		8b442430		MOVL 0x30(SP), AX	
	return resolveNameOff(unsafe.Pointer(t), off)
  0x43ee5a		89442408		MOVL AX, 0x8(SP)		
  0x43ee5e		e8edfcffff		CALL runtime.resolveNameOff(SB)	
  0x43ee63		488b442410		MOVQ 0x10(SP), AX		
  0x43ee68		4889442438		MOVQ AX, 0x38(SP)		
  0x43ee6d		488b6c2418		MOVQ 0x18(SP), BP		
  0x43ee72		4883c420		ADDQ $0x20, SP			
  0x43ee76		c3			RET				
func (t *_type) nameOff(off nameOff) name {
  0x43ee77		e8f4560000		CALL runtime.morestack_noctxt(SB)	
  0x43ee7c		ebb2			JMP runtime.(*_type).nameOff(SB)	

TEXT runtime.resolveTypeOff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {
  0x43ee80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ee89		483b6110		CMPQ 0x10(CX), SP	
  0x43ee8d		0f861b030000		JBE 0x43f1ae		
  0x43ee93		4883ec58		SUBQ $0x58, SP		
  0x43ee97		48896c2450		MOVQ BP, 0x50(SP)	
  0x43ee9c		488d6c2450		LEAQ 0x50(SP), BP	
  0x43eea1		8b442468		MOVL 0x68(SP), AX	
	if off == 0 {
  0x43eea5		85c0			TESTL AX, AX		
  0x43eea7		0f8428020000		JE 0x43f0d5		
  0x43eead		488b4c2460		MOVQ 0x60(SP), CX	
	base := uintptr(ptrInModule)
  0x43eeb2		488d1587690600		LEAQ runtime.firstmoduledata(SB), DX	
	for next := &firstmoduledata; next != nil; next = next.next {
  0x43eeb9		eb07			JMP 0x43eec2		
  0x43eebb		488b92c0010000		MOVQ 0x1c0(DX), DX	
  0x43eec2		4885d2			TESTQ DX, DX		
  0x43eec5		0f8403020000		JE 0x43f0ce		
		if base >= next.types && base < next.etypes {
  0x43eecb		488b9ac8000000		MOVQ 0xc8(DX), BX	
  0x43eed2		4839d9			CMPQ BX, CX		
  0x43eed5		72e4			JB 0x43eebb		
  0x43eed7		488b9ad0000000		MOVQ 0xd0(DX), BX	
  0x43eede		4839d9			CMPQ BX, CX		
  0x43eee1		73d8			JAE 0x43eebb		
	if md == nil {
  0x43eee3		4885d2			TESTQ DX, DX		
  0x43eee6		7476			JE 0x43ef5e		
  0x43eee8		4889542448		MOVQ DX, 0x48(SP)	
	if t := md.typemap[off]; t != nil {
  0x43eeed		488b8ab0010000		MOVQ 0x1b0(DX), CX			
  0x43eef4		48894c2408		MOVQ CX, 0x8(SP)			
  0x43eef9		488d0d40bb0100		LEAQ 0x1bb40(IP), CX			
  0x43ef00		48890c24		MOVQ CX, 0(SP)				
  0x43ef04		89442410		MOVL AX, 0x10(SP)			
  0x43ef08		e86389fcff		CALL runtime.mapaccess1_fast32(SB)	
  0x43ef0d		488b442418		MOVQ 0x18(SP), AX			
  0x43ef12		488b00			MOVQ 0(AX), AX				
  0x43ef15		4885c0			TESTQ AX, AX				
  0x43ef18		7535			JNE 0x43ef4f				
  0x43ef1a		488b442448		MOVQ 0x48(SP), AX			
	res := md.types + uintptr(off)
  0x43ef1f		488b88c8000000		MOVQ 0xc8(AX), CX	
  0x43ef26		8b542468		MOVL 0x68(SP), DX	
  0x43ef2a		4863da			MOVSXD DX, BX		
  0x43ef2d		4801cb			ADDQ CX, BX		
	if res > md.etypes {
  0x43ef30		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x43ef37		4839c3			CMPQ AX, BX		
  0x43ef3a		0f87a8010000		JA 0x43f0e8		
	return (*_type)(unsafe.Pointer(res))
  0x43ef40		48895c2470		MOVQ BX, 0x70(SP)	
  0x43ef45		488b6c2450		MOVQ 0x50(SP), BP	
  0x43ef4a		4883c458		ADDQ $0x58, SP		
  0x43ef4e		c3			RET			
		return t
  0x43ef4f		4889442470		MOVQ AX, 0x70(SP)	
  0x43ef54		488b6c2450		MOVQ 0x50(SP), BP	
  0x43ef59		4883c458		ADDQ $0x58, SP		
  0x43ef5d		c3			RET			
  0x43ef5e		48894c2420		MOVQ CX, 0x20(SP)	
		reflectOffsLock()
  0x43ef63		e868fbffff		CALL runtime.reflectOffsLock(SB)	
		res := reflectOffs.m[int32(off)]
  0x43ef68		488d0511ba0100		LEAQ 0x1ba11(IP), AX			
  0x43ef6f		48890424		MOVQ AX, 0(SP)				
  0x43ef73		488b0536880600		MOVQ runtime.reflectOffs+16(SB), AX	
  0x43ef7a		4889442408		MOVQ AX, 0x8(SP)			
  0x43ef7f		8b442468		MOVL 0x68(SP), AX			
  0x43ef83		89442410		MOVL AX, 0x10(SP)			
  0x43ef87		e8e488fcff		CALL runtime.mapaccess1_fast32(SB)	
  0x43ef8c		488b442418		MOVQ 0x18(SP), AX			
  0x43ef91		488b00			MOVQ 0(AX), AX				
  0x43ef94		4889442438		MOVQ AX, 0x38(SP)			
		reflectOffsUnlock()
  0x43ef99		e872fbffff		CALL runtime.reflectOffsUnlock(SB)	
  0x43ef9e		488b442438		MOVQ 0x38(SP), AX			
		if res == nil {
  0x43efa3		4885c0			TESTQ AX, AX		
  0x43efa6		0f8513010000		JNE 0x43f0bf		
			println("runtime: typeOff", hex(off), "base", hex(base), "not in ranges:")
  0x43efac		e84f2bfeff		CALL runtime.printlock(SB)		
  0x43efb1		488d052dbd0200		LEAQ 0x2bd2d(IP), AX			
  0x43efb8		48890424		MOVQ AX, 0(SP)				
  0x43efbc		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x43efc5		e87634feff		CALL runtime.printstring(SB)		
  0x43efca		8b442468		MOVL 0x68(SP), AX			
  0x43efce		4863c0			MOVSXD AX, AX				
  0x43efd1		48890424		MOVQ AX, 0(SP)				
  0x43efd5		e81633feff		CALL runtime.printhex(SB)		
  0x43efda		488d050cae0200		LEAQ 0x2ae0c(IP), AX			
  0x43efe1		48890424		MOVQ AX, 0(SP)				
  0x43efe5		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x43efee		e84d34feff		CALL runtime.printstring(SB)		
  0x43eff3		488b442420		MOVQ 0x20(SP), AX			
  0x43eff8		48890424		MOVQ AX, 0(SP)				
  0x43effc		e8ef32feff		CALL runtime.printhex(SB)		
  0x43f001		488d050aba0200		LEAQ 0x2ba0a(IP), AX			
  0x43f008		48890424		MOVQ AX, 0(SP)				
  0x43f00c		48c744240810000000	MOVQ $0x10, 0x8(SP)			
  0x43f015		e82634feff		CALL runtime.printstring(SB)		
  0x43f01a		e8612bfeff		CALL runtime.printunlock(SB)		
  0x43f01f		488d051a680600		LEAQ runtime.firstmoduledata(SB), AX	
			for next := &firstmoduledata; next != nil; next = next.next {
  0x43f026		e986000000		JMP 0x43f0b1		
  0x43f02b		4889442440		MOVQ AX, 0x40(SP)	
				println("\ttypes", hex(next.types), "etypes", hex(next.etypes))
  0x43f030		488b88c8000000		MOVQ 0xc8(AX), CX		
  0x43f037		48894c2430		MOVQ CX, 0x30(SP)		
  0x43f03c		488b90d0000000		MOVQ 0xd0(AX), DX		
  0x43f043		4889542428		MOVQ DX, 0x28(SP)		
  0x43f048		e8b32afeff		CALL runtime.printlock(SB)	
  0x43f04d		488d0561ae0200		LEAQ 0x2ae61(IP), AX		
  0x43f054		48890424		MOVQ AX, 0(SP)			
  0x43f058		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43f061		e8da33feff		CALL runtime.printstring(SB)	
  0x43f066		488b442430		MOVQ 0x30(SP), AX		
  0x43f06b		48890424		MOVQ AX, 0(SP)			
  0x43f06f		e87c32feff		CALL runtime.printhex(SB)	
  0x43f074		488d050caf0200		LEAQ 0x2af0c(IP), AX		
  0x43f07b		48890424		MOVQ AX, 0(SP)			
  0x43f07f		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43f088		e8b333feff		CALL runtime.printstring(SB)	
  0x43f08d		488b442428		MOVQ 0x28(SP), AX		
  0x43f092		48890424		MOVQ AX, 0(SP)			
  0x43f096		e85532feff		CALL runtime.printhex(SB)	
  0x43f09b		e8f02cfeff		CALL runtime.printnl(SB)	
  0x43f0a0		e8db2afeff		CALL runtime.printunlock(SB)	
  0x43f0a5		488b442440		MOVQ 0x40(SP), AX		
			for next := &firstmoduledata; next != nil; next = next.next {
  0x43f0aa		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x43f0b1		4885c0			TESTQ AX, AX		
  0x43f0b4		0f8571ffffff		JNE 0x43f02b		
  0x43f0ba		e9d4000000		JMP 0x43f193		
		return (*_type)(res)
  0x43f0bf		4889442470		MOVQ AX, 0x70(SP)	
  0x43f0c4		488b6c2450		MOVQ 0x50(SP), BP	
  0x43f0c9		4883c458		ADDQ $0x58, SP		
  0x43f0cd		c3			RET			
  0x43f0ce		31d2			XORL DX, DX		
	for next := &firstmoduledata; next != nil; next = next.next {
  0x43f0d0		e90efeffff		JMP 0x43eee3		
		return nil
  0x43f0d5		48c744247000000000	MOVQ $0x0, 0x70(SP)	
  0x43f0de		488b6c2450		MOVQ 0x50(SP), BP	
  0x43f0e3		4883c458		ADDQ $0x58, SP		
  0x43f0e7		c3			RET			
  0x43f0e8		48894c2430		MOVQ CX, 0x30(SP)	
  0x43f0ed		4889442428		MOVQ AX, 0x28(SP)	
		println("runtime: typeOff", hex(off), "out of range", hex(md.types), "-", hex(md.etypes))
  0x43f0f2		e8092afeff		CALL runtime.printlock(SB)	
  0x43f0f7		488d05e7bb0200		LEAQ 0x2bbe7(IP), AX		
  0x43f0fe		48890424		MOVQ AX, 0(SP)			
  0x43f102		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x43f10b		e83033feff		CALL runtime.printstring(SB)	
  0x43f110		8b442468		MOVL 0x68(SP), AX		
  0x43f114		4863c0			MOVSXD AX, AX			
  0x43f117		48890424		MOVQ AX, 0(SP)			
  0x43f11b		e8d031feff		CALL runtime.printhex(SB)	
  0x43f120		488d05c5b60200		LEAQ 0x2b6c5(IP), AX		
  0x43f127		48890424		MOVQ AX, 0(SP)			
  0x43f12b		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x43f134		e80733feff		CALL runtime.printstring(SB)	
  0x43f139		488b442430		MOVQ 0x30(SP), AX		
  0x43f13e		48890424		MOVQ AX, 0(SP)			
  0x43f142		e8a931feff		CALL runtime.printhex(SB)	
  0x43f147		488d053cab0200		LEAQ 0x2ab3c(IP), AX		
  0x43f14e		48890424		MOVQ AX, 0(SP)			
  0x43f152		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43f15b		e8e032feff		CALL runtime.printstring(SB)	
  0x43f160		488b442428		MOVQ 0x28(SP), AX		
  0x43f165		48890424		MOVQ AX, 0(SP)			
  0x43f169		e88231feff		CALL runtime.printhex(SB)	
  0x43f16e		e81d2cfeff		CALL runtime.printnl(SB)	
  0x43f173		e8082afeff		CALL runtime.printunlock(SB)	
		throw("runtime: type offset out of range")
  0x43f178		488d0570d90200		LEAQ 0x2d970(IP), AX	
  0x43f17f		48890424		MOVQ AX, 0(SP)		
  0x43f183		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x43f18c		e83f20feff		CALL runtime.throw(SB)	
  0x43f191		0f0b			UD2			
			throw("runtime: type offset base pointer out of range")
  0x43f193		488d0578e60200		LEAQ 0x2e678(IP), AX	
  0x43f19a		48890424		MOVQ AX, 0(SP)		
  0x43f19e		48c74424082e000000	MOVQ $0x2e, 0x8(SP)	
  0x43f1a7		e82420feff		CALL runtime.throw(SB)	
  0x43f1ac		0f0b			UD2			
func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {
  0x43f1ae		e8bd530000		CALL runtime.morestack_noctxt(SB)	
  0x43f1b3		e9c8fcffff		JMP runtime.resolveTypeOff(SB)		

TEXT runtime.(*_type).typeOff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (t *_type) typeOff(off typeOff) *_type {
  0x43f1c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f1c9		483b6110		CMPQ 0x10(CX), SP	
  0x43f1cd		7638			JBE 0x43f207		
  0x43f1cf		4883ec20		SUBQ $0x20, SP		
  0x43f1d3		48896c2418		MOVQ BP, 0x18(SP)	
  0x43f1d8		488d6c2418		LEAQ 0x18(SP), BP	
  0x43f1dd		488b442428		MOVQ 0x28(SP), AX	
	return resolveTypeOff(unsafe.Pointer(t), off)
  0x43f1e2		48890424		MOVQ AX, 0(SP)		
func (t *_type) typeOff(off typeOff) *_type {
  0x43f1e6		8b442430		MOVL 0x30(SP), AX	
	return resolveTypeOff(unsafe.Pointer(t), off)
  0x43f1ea		89442408		MOVL AX, 0x8(SP)		
  0x43f1ee		e88dfcffff		CALL runtime.resolveTypeOff(SB)	
  0x43f1f3		488b442410		MOVQ 0x10(SP), AX		
  0x43f1f8		4889442438		MOVQ AX, 0x38(SP)		
  0x43f1fd		488b6c2418		MOVQ 0x18(SP), BP		
  0x43f202		4883c420		ADDQ $0x20, SP			
  0x43f206		c3			RET				
func (t *_type) typeOff(off typeOff) *_type {
  0x43f207		e864530000		CALL runtime.morestack_noctxt(SB)	
  0x43f20c		ebb2			JMP runtime.(*_type).typeOff(SB)	

TEXT runtime.(*_type).textOff(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (t *_type) textOff(off textOff) unsafe.Pointer {
  0x43f210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f219		483b6110		CMPQ 0x10(CX), SP	
  0x43f21d		0f8603030000		JBE 0x43f526		
  0x43f223		4883ec50		SUBQ $0x50, SP		
  0x43f227		48896c2448		MOVQ BP, 0x48(SP)	
  0x43f22c		488d6c2448		LEAQ 0x48(SP), BP	
  0x43f231		488b442458		MOVQ 0x58(SP), AX	
	base := uintptr(unsafe.Pointer(t))
  0x43f236		488d0d03660600		LEAQ runtime.firstmoduledata(SB), CX	
	for next := &firstmoduledata; next != nil; next = next.next {
  0x43f23d		eb07			JMP 0x43f246		
  0x43f23f		488b89c0010000		MOVQ 0x1c0(CX), CX	
  0x43f246		4885c9			TESTQ CX, CX		
  0x43f249		0f8406020000		JE 0x43f455		
		if base >= next.types && base < next.etypes {
  0x43f24f		488b91c8000000		MOVQ 0xc8(CX), DX	
  0x43f256		4839d0			CMPQ DX, AX		
  0x43f259		72e4			JB 0x43f23f		
  0x43f25b		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x43f262		4839d0			CMPQ DX, AX		
  0x43f265		73d8			JAE 0x43f23f		
	if md == nil {
  0x43f267		4885c9			TESTQ CX, CX		
  0x43f26a		7479			JE 0x43f2e5		
	if len(md.textsectmap) > 1 {
  0x43f26c		488b81d8000000		MOVQ 0xd8(CX), AX	
  0x43f273		488b91e0000000		MOVQ 0xe0(CX), DX	
  0x43f27a		4883fa01		CMPQ $0x1, DX		
  0x43f27e		7e58			JLE 0x43f2d8		
  0x43f280		8b5c2460		MOVL 0x60(SP), BX	
  0x43f284		31f6			XORL SI, SI		
		for i := range md.textsectmap {
  0x43f286		eb03			JMP 0x43f28b		
  0x43f288		48ffc6			INCQ SI			
  0x43f28b		4839d6			CMPQ DX, SI		
  0x43f28e		7d44			JGE 0x43f2d4		
			sectaddr := md.textsectmap[i].vaddr
  0x43f290		488d3c76		LEAQ 0(SI)(SI*2), DI	
  0x43f294		4c8b04f8		MOVQ 0(AX)(DI*8), R8	
			sectlen := md.textsectmap[i].length
  0x43f298		4c8b4cf808		MOVQ 0x8(AX)(DI*8), R9	
			if uintptr(off) >= sectaddr && uintptr(off) <= sectaddr+sectlen {
  0x43f29d		4c63d3			MOVSXD BX, R10		
  0x43f2a0		4d39c2			CMPQ R8, R10		
  0x43f2a3		72e3			JB 0x43f288		
  0x43f2a5		4d01c1			ADDQ R8, R9		
  0x43f2a8		4d39ca			CMPQ R9, R10		
  0x43f2ab		77db			JA 0x43f288		
				res = md.textsectmap[i].baseaddr + uintptr(off) - uintptr(md.textsectmap[i].vaddr)
  0x43f2ad		488b44f810		MOVQ 0x10(AX)(DI*8), AX	
  0x43f2b2		4c01d0			ADDQ R10, AX		
  0x43f2b5		4c29c0			SUBQ R8, AX		
	if res > md.etext {
  0x43f2b8		488b5168		MOVQ 0x68(CX), DX	
  0x43f2bc		4839d0			CMPQ DX, AX		
  0x43f2bf		0f8797010000		JA 0x43f45c		
	return unsafe.Pointer(res)
  0x43f2c5		4889442468		MOVQ AX, 0x68(SP)	
  0x43f2ca		488b6c2448		MOVQ 0x48(SP), BP	
  0x43f2cf		4883c450		ADDQ $0x50, SP		
  0x43f2d3		c3			RET			
  0x43f2d4		31c0			XORL AX, AX		
		for i := range md.textsectmap {
  0x43f2d6		ebe0			JMP 0x43f2b8		
  0x43f2d8		8b5c2460		MOVL 0x60(SP), BX	
		res = md.text + uintptr(off)
  0x43f2dc		4863c3			MOVSXD BX, AX		
  0x43f2df		48034160		ADDQ 0x60(CX), AX	
  0x43f2e3		ebd3			JMP 0x43f2b8		
  0x43f2e5		4889442420		MOVQ AX, 0x20(SP)	
		reflectOffsLock()
  0x43f2ea		e8e1f7ffff		CALL runtime.reflectOffsLock(SB)	
		res := reflectOffs.m[int32(off)]
  0x43f2ef		488d058ab60100		LEAQ 0x1b68a(IP), AX			
  0x43f2f6		48890424		MOVQ AX, 0(SP)				
  0x43f2fa		488b05af840600		MOVQ runtime.reflectOffs+16(SB), AX	
  0x43f301		4889442408		MOVQ AX, 0x8(SP)			
  0x43f306		8b442460		MOVL 0x60(SP), AX			
  0x43f30a		89442410		MOVL AX, 0x10(SP)			
  0x43f30e		e85d85fcff		CALL runtime.mapaccess1_fast32(SB)	
  0x43f313		488b442418		MOVQ 0x18(SP), AX			
  0x43f318		488b00			MOVQ 0(AX), AX				
  0x43f31b		4889442438		MOVQ AX, 0x38(SP)			
		reflectOffsUnlock()
  0x43f320		e8ebf7ffff		CALL runtime.reflectOffsUnlock(SB)	
  0x43f325		488b442438		MOVQ 0x38(SP), AX			
		if res == nil {
  0x43f32a		4885c0			TESTQ AX, AX		
  0x43f32d		0f8513010000		JNE 0x43f446		
			println("runtime: textOff", hex(off), "base", hex(base), "not in ranges:")
  0x43f333		e8c827feff		CALL runtime.printlock(SB)		
  0x43f338		488d0595b90200		LEAQ 0x2b995(IP), AX			
  0x43f33f		48890424		MOVQ AX, 0(SP)				
  0x43f343		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x43f34c		e8ef30feff		CALL runtime.printstring(SB)		
  0x43f351		8b442460		MOVL 0x60(SP), AX			
  0x43f355		4863c0			MOVSXD AX, AX				
  0x43f358		48890424		MOVQ AX, 0(SP)				
  0x43f35c		e88f2ffeff		CALL runtime.printhex(SB)		
  0x43f361		488d0585aa0200		LEAQ 0x2aa85(IP), AX			
  0x43f368		48890424		MOVQ AX, 0(SP)				
  0x43f36c		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x43f375		e8c630feff		CALL runtime.printstring(SB)		
  0x43f37a		488b442420		MOVQ 0x20(SP), AX			
  0x43f37f		48890424		MOVQ AX, 0(SP)				
  0x43f383		e8682ffeff		CALL runtime.printhex(SB)		
  0x43f388		488d0583b60200		LEAQ 0x2b683(IP), AX			
  0x43f38f		48890424		MOVQ AX, 0(SP)				
  0x43f393		48c744240810000000	MOVQ $0x10, 0x8(SP)			
  0x43f39c		e89f30feff		CALL runtime.printstring(SB)		
  0x43f3a1		e8da27feff		CALL runtime.printunlock(SB)		
  0x43f3a6		488d0593640600		LEAQ runtime.firstmoduledata(SB), AX	
			for next := &firstmoduledata; next != nil; next = next.next {
  0x43f3ad		e986000000		JMP 0x43f438		
  0x43f3b2		4889442440		MOVQ AX, 0x40(SP)	
				println("\ttypes", hex(next.types), "etypes", hex(next.etypes))
  0x43f3b7		488b88c8000000		MOVQ 0xc8(AX), CX		
  0x43f3be		48894c2430		MOVQ CX, 0x30(SP)		
  0x43f3c3		488b90d0000000		MOVQ 0xd0(AX), DX		
  0x43f3ca		4889542428		MOVQ DX, 0x28(SP)		
  0x43f3cf		e82c27feff		CALL runtime.printlock(SB)	
  0x43f3d4		488d05daaa0200		LEAQ 0x2aada(IP), AX		
  0x43f3db		48890424		MOVQ AX, 0(SP)			
  0x43f3df		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43f3e8		e85330feff		CALL runtime.printstring(SB)	
  0x43f3ed		488b442430		MOVQ 0x30(SP), AX		
  0x43f3f2		48890424		MOVQ AX, 0(SP)			
  0x43f3f6		e8f52efeff		CALL runtime.printhex(SB)	
  0x43f3fb		488d0585ab0200		LEAQ 0x2ab85(IP), AX		
  0x43f402		48890424		MOVQ AX, 0(SP)			
  0x43f406		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43f40f		e82c30feff		CALL runtime.printstring(SB)	
  0x43f414		488b442428		MOVQ 0x28(SP), AX		
  0x43f419		48890424		MOVQ AX, 0(SP)			
  0x43f41d		e8ce2efeff		CALL runtime.printhex(SB)	
  0x43f422		e86929feff		CALL runtime.printnl(SB)	
  0x43f427		e85427feff		CALL runtime.printunlock(SB)	
  0x43f42c		488b442440		MOVQ 0x40(SP), AX		
			for next := &firstmoduledata; next != nil; next = next.next {
  0x43f431		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x43f438		4885c0			TESTQ AX, AX		
  0x43f43b		0f8571ffffff		JNE 0x43f3b2		
  0x43f441		e9c5000000		JMP 0x43f50b		
		return res
  0x43f446		4889442468		MOVQ AX, 0x68(SP)	
  0x43f44b		488b6c2448		MOVQ 0x48(SP), BP	
  0x43f450		4883c450		ADDQ $0x50, SP		
  0x43f454		c3			RET			
  0x43f455		31c9			XORL CX, CX		
	for next := &firstmoduledata; next != nil; next = next.next {
  0x43f457		e90bfeffff		JMP 0x43f267		
  0x43f45c		4889542430		MOVQ DX, 0x30(SP)	
		println("runtime: textOff", hex(off), "out of range", hex(md.text), "-", hex(md.etext))
  0x43f461		488b4160		MOVQ 0x60(CX), AX		
  0x43f465		4889442428		MOVQ AX, 0x28(SP)		
  0x43f46a		e89126feff		CALL runtime.printlock(SB)	
  0x43f46f		488d055eb80200		LEAQ 0x2b85e(IP), AX		
  0x43f476		48890424		MOVQ AX, 0(SP)			
  0x43f47a		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x43f483		e8b82ffeff		CALL runtime.printstring(SB)	
  0x43f488		8b442460		MOVL 0x60(SP), AX		
  0x43f48c		4863c0			MOVSXD AX, AX			
  0x43f48f		48890424		MOVQ AX, 0(SP)			
  0x43f493		e8582efeff		CALL runtime.printhex(SB)	
  0x43f498		488d054db30200		LEAQ 0x2b34d(IP), AX		
  0x43f49f		48890424		MOVQ AX, 0(SP)			
  0x43f4a3		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x43f4ac		e88f2ffeff		CALL runtime.printstring(SB)	
  0x43f4b1		488b442428		MOVQ 0x28(SP), AX		
  0x43f4b6		48890424		MOVQ AX, 0(SP)			
  0x43f4ba		e8312efeff		CALL runtime.printhex(SB)	
  0x43f4bf		488d05c4a70200		LEAQ 0x2a7c4(IP), AX		
  0x43f4c6		48890424		MOVQ AX, 0(SP)			
  0x43f4ca		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43f4d3		e8682ffeff		CALL runtime.printstring(SB)	
  0x43f4d8		488b442430		MOVQ 0x30(SP), AX		
  0x43f4dd		48890424		MOVQ AX, 0(SP)			
  0x43f4e1		e80a2efeff		CALL runtime.printhex(SB)	
  0x43f4e6		e8a528feff		CALL runtime.printnl(SB)	
  0x43f4eb		e89026feff		CALL runtime.printunlock(SB)	
		throw("runtime: text offset out of range")
  0x43f4f0		488d05d7d50200		LEAQ 0x2d5d7(IP), AX	
  0x43f4f7		48890424		MOVQ AX, 0(SP)		
  0x43f4fb		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x43f504		e8c71cfeff		CALL runtime.throw(SB)	
  0x43f509		0f0b			UD2			
			throw("runtime: text offset base pointer out of range")
  0x43f50b		488d05d2e20200		LEAQ 0x2e2d2(IP), AX	
  0x43f512		48890424		MOVQ AX, 0(SP)		
  0x43f516		48c74424082e000000	MOVQ $0x2e, 0x8(SP)	
  0x43f51f		e8ac1cfeff		CALL runtime.throw(SB)	
  0x43f524		0f0b			UD2			
func (t *_type) textOff(off textOff) unsafe.Pointer {
  0x43f526		e845500000		CALL runtime.morestack_noctxt(SB)	
  0x43f52b		e9e0fcffff		JMP runtime.(*_type).textOff(SB)	

TEXT runtime.name.tagLen(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (n name) tagLen() int {
  0x43f530		488b442408		MOVQ 0x8(SP), AX	
	if *n.data(0)&(1<<1) == 0 {
  0x43f535		0fb608			MOVZX 0(AX), CX		
  0x43f538		f6c102			TESTL $0x2, CL		
  0x43f53b		750a			JNE 0x43f547		
		return 0
  0x43f53d		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x43f546		c3			RET			
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f547		b901000000		MOVL $0x1, CX		
  0x43f54c		0fb60c08		MOVZX 0(AX)(CX*1), CX	
  0x43f550		c1e108			SHLL $0x8, CX		
  0x43f553		ba02000000		MOVL $0x2, DX		
  0x43f558		0fb61410		MOVZX 0(AX)(DX*1), DX	
  0x43f55c		09d1			ORL DX, CX		
  0x43f55e		0fb7c9			MOVZX CX, CX		
  0x43f561		4889c2			MOVQ AX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x43f564		488d5c0103		LEAQ 0x3(CX)(AX*1), BX	
  0x43f569		488d440104		LEAQ 0x4(CX)(AX*1), AX	
  0x43f56e		488d4a01		LEAQ 0x1(DX), CX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f572		8401			TESTB AL, 0(CX)		
	return unsafe.Pointer(uintptr(p) + x)
  0x43f574		488d4a02		LEAQ 0x2(DX), CX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f578		8401			TESTB AL, 0(CX)		
	return int(uint16(*n.data(off))<<8 | uint16(*n.data(off + 1)))
  0x43f57a		0fb60b			MOVZX 0(BX), CX		
  0x43f57d		0fb600			MOVZX 0(AX), AX		
  0x43f580		c1e108			SHLL $0x8, CX		
  0x43f583		09c1			ORL AX, CX		
  0x43f585		0fb7c1			MOVZX CX, AX		
  0x43f588		4889442410		MOVQ AX, 0x10(SP)	
  0x43f58d		c3			RET			

TEXT runtime.name.name(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (n name) name() (s string) {
  0x43f590		0f57c0			XORPS X0, X0		
  0x43f593		0f11442410		MOVUPS X0, 0x10(SP)	
  0x43f598		488b442408		MOVQ 0x8(SP), AX	
	if n.bytes == nil {
  0x43f59d		4885c0			TESTQ AX, AX		
  0x43f5a0		7440			JE 0x43f5e2		
	return unsafe.Pointer(uintptr(p) + x)
  0x43f5a2		488d4801		LEAQ 0x1(AX), CX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f5a6		8401			TESTB AL, 0(CX)		
	return unsafe.Pointer(uintptr(p) + x)
  0x43f5a8		488d4802		LEAQ 0x2(AX), CX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f5ac		8401			TESTB AL, 0(CX)		
  0x43f5ae		b901000000		MOVL $0x1, CX		
  0x43f5b3		0fb60c08		MOVZX 0(AX)(CX*1), CX	
  0x43f5b7		c1e108			SHLL $0x8, CX		
  0x43f5ba		ba02000000		MOVL $0x2, DX		
  0x43f5bf		0fb61410		MOVZX 0(AX)(DX*1), DX	
  0x43f5c3		09d1			ORL DX, CX		
  0x43f5c5		0fb7c9			MOVZX CX, CX		
	if nl == 0 {
  0x43f5c8		4885c9			TESTQ CX, CX		
  0x43f5cb		7506			JNE 0x43f5d3		
		return ""
  0x43f5cd		0f11442410		MOVUPS X0, 0x10(SP)	
  0x43f5d2		c3			RET			
	return unsafe.Pointer(uintptr(p) + x)
  0x43f5d3		4883c003		ADDQ $0x3, AX		
	hdr.str = unsafe.Pointer(n.data(3))
  0x43f5d7		4889442410		MOVQ AX, 0x10(SP)	
	hdr.len = nl
  0x43f5dc		48894c2418		MOVQ CX, 0x18(SP)	
	return s
  0x43f5e1		c3			RET			
		return ""
  0x43f5e2		0f11442410		MOVUPS X0, 0x10(SP)	
  0x43f5e7		c3			RET			

TEXT runtime.name.tag(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (n name) tag() (s string) {
  0x43f5f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f5f9		483b6110		CMPQ 0x10(CX), SP	
  0x43f5fd		0f8684000000		JBE 0x43f687		
  0x43f603		4883ec18		SUBQ $0x18, SP		
  0x43f607		48896c2410		MOVQ BP, 0x10(SP)	
  0x43f60c		488d6c2410		LEAQ 0x10(SP), BP	
  0x43f611		0f57c0			XORPS X0, X0		
  0x43f614		0f11442428		MOVUPS X0, 0x28(SP)	
  0x43f619		488b442420		MOVQ 0x20(SP), AX	
	tl := n.tagLen()
  0x43f61e		48890424		MOVQ AX, 0(SP)			
  0x43f622		e809ffffff		CALL runtime.name.tagLen(SB)	
  0x43f627		488b442408		MOVQ 0x8(SP), AX		
	if tl == 0 {
  0x43f62c		4885c0			TESTQ AX, AX		
  0x43f62f		7512			JNE 0x43f643		
		return ""
  0x43f631		0f57c0			XORPS X0, X0		
  0x43f634		0f11442428		MOVUPS X0, 0x28(SP)	
  0x43f639		488b6c2410		MOVQ 0x10(SP), BP	
  0x43f63e		4883c418		ADDQ $0x18, SP		
  0x43f642		c3			RET			
  0x43f643		488b4c2420		MOVQ 0x20(SP), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x43f648		488d5101		LEAQ 0x1(CX), DX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f64c		8402			TESTB AL, 0(DX)		
	return unsafe.Pointer(uintptr(p) + x)
  0x43f64e		488d5102		LEAQ 0x2(CX), DX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f652		8402			TESTB AL, 0(DX)		
  0x43f654		ba01000000		MOVL $0x1, DX		
  0x43f659		0fb61411		MOVZX 0(CX)(DX*1), DX	
  0x43f65d		c1e208			SHLL $0x8, DX		
  0x43f660		bb02000000		MOVL $0x2, BX		
  0x43f665		0fb61c19		MOVZX 0(CX)(BX*1), BX	
  0x43f669		09da			ORL BX, DX		
  0x43f66b		0fb7d2			MOVZX DX, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x43f66e		488d4c0a05		LEAQ 0x5(DX)(CX*1), CX	
	hdr.str = unsafe.Pointer(n.data(3 + nl + 2))
  0x43f673		48894c2428		MOVQ CX, 0x28(SP)	
	hdr.len = tl
  0x43f678		4889442430		MOVQ AX, 0x30(SP)	
	return s
  0x43f67d		488b6c2410		MOVQ 0x10(SP), BP	
  0x43f682		4883c418		ADDQ $0x18, SP		
  0x43f686		c3			RET			
func (n name) tag() (s string) {
  0x43f687		e8e44e0000		CALL runtime.morestack_noctxt(SB)	
  0x43f68c		e95fffffff		JMP runtime.name.tag(SB)		

TEXT runtime.name.pkgPath(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func (n name) pkgPath() string {
  0x43f6a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f6a9		483b6110		CMPQ 0x10(CX), SP	
  0x43f6ad		0f86e4000000		JBE 0x43f797		
  0x43f6b3		4883ec28		SUBQ $0x28, SP		
  0x43f6b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x43f6bc		488d6c2420		LEAQ 0x20(SP), BP	
  0x43f6c1		488b442430		MOVQ 0x30(SP), AX	
	if n.bytes == nil || *n.data(0)&(1<<2) == 0 {
  0x43f6c6		4885c0			TESTQ AX, AX		
  0x43f6c9		7408			JE 0x43f6d3		
  0x43f6cb		0fb608			MOVZX 0(AX), CX		
  0x43f6ce		f6c104			TESTL $0x4, CL		
  0x43f6d1		7512			JNE 0x43f6e5		
		return ""
  0x43f6d3		0f57c0			XORPS X0, X0		
  0x43f6d6		0f11442438		MOVUPS X0, 0x38(SP)	
  0x43f6db		488b6c2420		MOVQ 0x20(SP), BP	
  0x43f6e0		4883c428		ADDQ $0x28, SP		
  0x43f6e4		c3			RET			
	return unsafe.Pointer(uintptr(p) + x)
  0x43f6e5		488d4801		LEAQ 0x1(AX), CX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f6e9		8401			TESTB AL, 0(CX)		
	return unsafe.Pointer(uintptr(p) + x)
  0x43f6eb		488d4802		LEAQ 0x2(AX), CX	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f6ef		8401			TESTB AL, 0(CX)		
  0x43f6f1		b901000000		MOVL $0x1, CX		
  0x43f6f6		0fb60c08		MOVZX 0(AX)(CX*1), CX	
  0x43f6fa		66894c241a		MOVW CX, 0x1a(SP)	
  0x43f6ff		ba02000000		MOVL $0x2, DX		
  0x43f704		0fb61410		MOVZX 0(AX)(DX*1), DX	
  0x43f708		6689542418		MOVW DX, 0x18(SP)	
	if tl := n.tagLen(); tl > 0 {
  0x43f70d		48890424		MOVQ AX, 0(SP)			
  0x43f711		e81afeffff		CALL runtime.name.tagLen(SB)	
  0x43f716		0fb744241a		MOVZX 0x1a(SP), AX		
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x43f71b		c1e008			SHLL $0x8, AX		
  0x43f71e		0fb74c2418		MOVZX 0x18(SP), CX	
  0x43f723		09c8			ORL CX, AX		
  0x43f725		0fb7c0			MOVZX AX, AX		
	off := 3 + n.nameLen()
  0x43f728		488d4803		LEAQ 0x3(AX), CX	
	if tl := n.tagLen(); tl > 0 {
  0x43f72c		488b542408		MOVQ 0x8(SP), DX	
  0x43f731		4885d2			TESTQ DX, DX		
  0x43f734		7e5c			JLE 0x43f792		
		off += 2 + tl
  0x43f736		488d440205		LEAQ 0x5(DX)(AX*1), AX	
	var nameOff nameOff
  0x43f73b		c744241c00000000	MOVL $0x0, 0x1c(SP)	
  0x43f743		488b4c2430		MOVQ 0x30(SP), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x43f748		488d1408		LEAQ 0(AX)(CX*1), DX	
	copy((*[4]byte)(unsafe.Pointer(&nameOff))[:], (*[4]byte)(unsafe.Pointer(n.data(off)))[:])
  0x43f74c		8402			TESTB AL, 0(DX)		
  0x43f74e		8b0408			MOVL 0(AX)(CX*1), AX	
  0x43f751		8944241c		MOVL AX, 0x1c(SP)	
	pkgPathName := resolveNameOff(unsafe.Pointer(n.bytes), nameOff)
  0x43f755		48890c24		MOVQ CX, 0(SP)			
  0x43f759		8b44241c		MOVL 0x1c(SP), AX		
  0x43f75d		89442408		MOVL AX, 0x8(SP)		
  0x43f761		e8eaf3ffff		CALL runtime.resolveNameOff(SB)	
  0x43f766		488b442410		MOVQ 0x10(SP), AX		
	return pkgPathName.name()
  0x43f76b		48890424		MOVQ AX, 0(SP)			
  0x43f76f		e81cfeffff		CALL runtime.name.name(SB)	
  0x43f774		488b442410		MOVQ 0x10(SP), AX		
  0x43f779		488b4c2408		MOVQ 0x8(SP), CX		
  0x43f77e		48894c2438		MOVQ CX, 0x38(SP)		
  0x43f783		4889442440		MOVQ AX, 0x40(SP)		
  0x43f788		488b6c2420		MOVQ 0x20(SP), BP		
  0x43f78d		4883c428		ADDQ $0x28, SP			
  0x43f791		c3			RET				
  0x43f792		4889c8			MOVQ CX, AX			
	if tl := n.tagLen(); tl > 0 {
  0x43f795		eba4			JMP 0x43f73b		
func (n name) pkgPath() string {
  0x43f797		e8d44d0000		CALL runtime.morestack_noctxt(SB)	
  0x43f79c		e9fffeffff		JMP runtime.name.pkgPath(SB)		

TEXT runtime.typelinksinit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func typelinksinit() {
  0x43f7b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f7b9		488d8424b8fdffff	LEAQ 0xfffffdb8(SP), AX	
  0x43f7c1		483b4110		CMPQ 0x10(CX), AX	
  0x43f7c5		0f86c7060000		JBE 0x43fe92		
  0x43f7cb		4881ecc8020000		SUBQ $0x2c8, SP		
  0x43f7d2		4889ac24c0020000	MOVQ BP, 0x2c0(SP)	
  0x43f7da		488dac24c0020000	LEAQ 0x2c0(SP), BP	
  0x43f7e2		0f57c0			XORPS X0, X0		
  0x43f7e5		488dbc2410010000	LEAQ 0x110(SP), DI	
  0x43f7ed		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43f7f2		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43f7f7		e8a6720000		CALL 0x446aa2		
  0x43f7fc		488b6d00		MOVQ 0(BP), BP		
  0x43f800		0f118424e0000000	MOVUPS X0, 0xe0(SP)	
  0x43f808		0f118424f0000000	MOVUPS X0, 0xf0(SP)	
  0x43f810		0f11842400010000	MOVUPS X0, 0x100(SP)	
	if firstmoduledata.next == nil {
  0x43f818		488b05e1610600		MOVQ runtime.firstmoduledata+448(SB), AX	
  0x43f81f		4885c0			TESTQ AX, AX					
  0x43f822		0f8453060000		JE 0x43fe7b					
	typehash := make(map[uint32][]*_type, len(firstmoduledata.typelinks))
  0x43f828		488b0509610600		MOVQ runtime.firstmoduledata+248(SB), AX	
  0x43f82f		0f57c0			XORPS X0, X0					
  0x43f832		0f11842410010000	MOVUPS X0, 0x110(SP)				
  0x43f83a		0f11842420010000	MOVUPS X0, 0x120(SP)				
  0x43f842		0f11842430010000	MOVUPS X0, 0x130(SP)				
  0x43f84a		488dbc24d0010000	LEAQ 0x1d0(SP), DI				
  0x43f852		488d7ff0		LEAQ -0x10(DI), DI				
  0x43f856		48896c24f0		MOVQ BP, -0x10(SP)				
  0x43f85b		488d6c24f0		LEAQ -0x10(SP), BP				
  0x43f860		e822720000		CALL 0x446a87					
  0x43f865		488b6d00		MOVQ 0(BP), BP					
  0x43f869		488d8c24d0010000	LEAQ 0x1d0(SP), CX				
  0x43f871		48898c2420010000	MOVQ CX, 0x120(SP)				
  0x43f879		488d0d80b20100		LEAQ 0x1b280(IP), CX				
  0x43f880		48890c24		MOVQ CX, 0(SP)					
  0x43f884		4889442408		MOVQ AX, 0x8(SP)				
  0x43f889		488d842410010000	LEAQ 0x110(SP), AX				
  0x43f891		4889442410		MOVQ AX, 0x10(SP)				
  0x43f896		e8e569fcff		CALL runtime.makemap(SB)			
  0x43f89b		488b442418		MOVQ 0x18(SP), AX				
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x43f8a0		488b0dd17d0600		MOVQ runtime.modulesSlice(SB), CX	
	if p == nil {
  0x43f8a7		4885c9			TESTQ CX, CX		
  0x43f8aa		0f84c0050000		JE 0x43fe70		
	return *p
  0x43f8b0		488b5108		MOVQ 0x8(CX), DX	
  0x43f8b4		488b5910		MOVQ 0x10(CX), BX	
  0x43f8b8		488b09			MOVQ 0(CX), CX		
	prev := modules[0]
  0x43f8bb		4885d2			TESTQ DX, DX		
  0x43f8be		0f86c7050000		JBE 0x43fe8b		
  0x43f8c4		4889842480000000	MOVQ AX, 0x80(SP)	
  0x43f8cc		488b31			MOVQ 0(CX), SI		
	for _, md := range modules[1:] {
  0x43f8cf		48ffcb			DECQ BX			
  0x43f8d2		48f7db			NEGQ BX			
  0x43f8d5		48c1fb3f		SARQ $0x3f, BX		
  0x43f8d9		4883e308		ANDQ $0x8, BX		
  0x43f8dd		4801d9			ADDQ BX, CX		
  0x43f8e0		48898c24d8000000	MOVQ CX, 0xd8(SP)	
  0x43f8e8		48ffca			DECQ DX			
  0x43f8eb		4889542478		MOVQ DX, 0x78(SP)	
  0x43f8f0		31db			XORL BX, BX		
  0x43f8f2		e9ff010000		JMP 0x43faf6		
			for _, tcur := range tlist {
  0x43f8f7		48ffc6			INCQ SI			
  0x43f8fa		4839c6			CMPQ AX, SI		
  0x43f8fd		0f8db9000000		JGE 0x43f9bc		
  0x43f903		4c8b04f2		MOVQ 0(DX)(SI*8), R8	
				if tcur == t {
  0x43f907		4939d8			CMPQ BX, R8		
  0x43f90a		75eb			JNE 0x43f8f7		
  0x43f90c		4c8b5c2460		MOVQ 0x60(SP), R11	
		for _, tl := range prev.typelinks {
  0x43f911		4d8d5301		LEAQ 0x1(R11), R10	
  0x43f915		488b842480000000	MOVQ 0x80(SP), AX	
  0x43f91d		488b8c24d8000000	MOVQ 0xd8(SP), CX	
  0x43f925		488b542478		MOVQ 0x78(SP), DX	
  0x43f92a		488b5c2470		MOVQ 0x70(SP), BX	
  0x43f92f		488bb424a0000000	MOVQ 0xa0(SP), SI	
  0x43f937		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x43f93f		4c8b8424d0000000	MOVQ 0xd0(SP), R8	
  0x43f947		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x43f94c		4d39ca			CMPQ R9, R10		
  0x43f94f		0f8d88010000		JGE 0x43fadd		
  0x43f955		4c89542460		MOVQ R10, 0x60(SP)	
  0x43f95a		478b1c90		MOVL 0(R8)(R10*4), R11	
			if prev.typemap == nil {
  0x43f95e		4c8ba6b0010000		MOVQ 0x1b0(SI), R12	
  0x43f965		4d85e4			TESTQ R12, R12		
  0x43f968		0f8540010000		JNE 0x43faae		
				t = (*_type)(unsafe.Pointer(prev.types + uintptr(tl)))
  0x43f96e		4d63db			MOVSXD R11, R11		
  0x43f971		4c039ec8000000		ADDQ 0xc8(SI), R11	
  0x43f978		4c899c2490000000	MOVQ R11, 0x90(SP)	
			tlist := typehash[t.hash]
  0x43f980		418b4b10		MOVL 0x10(R11), CX			
  0x43f984		894c2410		MOVL CX, 0x10(SP)			
  0x43f988		488d0d71b10100		LEAQ 0x1b171(IP), CX			
  0x43f98f		48890c24		MOVQ CX, 0(SP)				
  0x43f993		4889442408		MOVQ AX, 0x8(SP)			
  0x43f998		e8d37efcff		CALL runtime.mapaccess1_fast32(SB)	
  0x43f99d		488b442418		MOVQ 0x18(SP), AX			
  0x43f9a2		488b4810		MOVQ 0x10(AX), CX			
  0x43f9a6		488b10			MOVQ 0(AX), DX				
  0x43f9a9		488b4008		MOVQ 0x8(AX), AX			
  0x43f9ad		488b9c2490000000	MOVQ 0x90(SP), BX			
  0x43f9b5		31f6			XORL SI, SI				
			for _, tcur := range tlist {
  0x43f9b7		e93effffff		JMP 0x43f8fa		
			typehash[t.hash] = append(tlist, t)
  0x43f9bc		488d7001		LEAQ 0x1(AX), SI			
  0x43f9c0		4839ce			CMPQ CX, SI				
  0x43f9c3		0f8f97000000		JG 0x43fa60				
  0x43f9c9		48899424c8000000	MOVQ DX, 0xc8(SP)			
  0x43f9d1		4889742458		MOVQ SI, 0x58(SP)			
  0x43f9d6		48894c2450		MOVQ CX, 0x50(SP)			
  0x43f9db		488d3cc2		LEAQ 0(DX)(AX*8), DI			
  0x43f9df		448b052a400800		MOVL runtime.writeBarrier(SB), R8	
  0x43f9e6		4585c0			TESTL R8, R8				
  0x43f9e9		756b			JNE 0x43fa56				
  0x43f9eb		48891cc2		MOVQ BX, 0(DX)(AX*8)			
  0x43f9ef		8b4310			MOVL 0x10(BX), AX			
  0x43f9f2		89442410		MOVL AX, 0x10(SP)			
  0x43f9f6		488d0503b10100		LEAQ 0x1b103(IP), AX			
  0x43f9fd		48890424		MOVQ AX, 0(SP)				
  0x43fa01		488b8c2480000000	MOVQ 0x80(SP), CX			
  0x43fa09		48894c2408		MOVQ CX, 0x8(SP)			
  0x43fa0e		e8bd81fcff		CALL runtime.mapassign_fast32(SB)	
  0x43fa13		488b7c2418		MOVQ 0x18(SP), DI			
  0x43fa18		488b442458		MOVQ 0x58(SP), AX			
  0x43fa1d		48894708		MOVQ AX, 0x8(DI)			
  0x43fa21		488b442450		MOVQ 0x50(SP), AX			
  0x43fa26		48894710		MOVQ AX, 0x10(DI)			
  0x43fa2a		8b05e03f0800		MOVL runtime.writeBarrier(SB), AX	
  0x43fa30		85c0			TESTL AX, AX				
  0x43fa32		7510			JNE 0x43fa44				
  0x43fa34		488b8424c8000000	MOVQ 0xc8(SP), AX			
  0x43fa3c		488907			MOVQ AX, 0(DI)				
  0x43fa3f		e9c8feffff		JMP 0x43f90c				
  0x43fa44		488b8424c8000000	MOVQ 0xc8(SP), AX			
  0x43fa4c		e84f6e0000		CALL runtime.gcWriteBarrier(SB)		
  0x43fa51		e9b6feffff		JMP 0x43f90c				
  0x43fa56		4889d8			MOVQ BX, AX				
  0x43fa59		e8426e0000		CALL runtime.gcWriteBarrier(SB)		
  0x43fa5e		eb8f			JMP 0x43f9ef				
  0x43fa60		4889442448		MOVQ AX, 0x48(SP)			
  0x43fa65		488d1d94fd0100		LEAQ 0x1fd94(IP), BX			
  0x43fa6c		48891c24		MOVQ BX, 0(SP)				
  0x43fa70		4889542408		MOVQ DX, 0x8(SP)			
  0x43fa75		4889442410		MOVQ AX, 0x10(SP)			
  0x43fa7a		48894c2418		MOVQ CX, 0x18(SP)			
  0x43fa7f		4889742420		MOVQ SI, 0x20(SP)			
  0x43fa84		e8d73dffff		CALL runtime.growslice(SB)		
  0x43fa89		488b542428		MOVQ 0x28(SP), DX			
  0x43fa8e		488b442430		MOVQ 0x30(SP), AX			
  0x43fa93		488b4c2438		MOVQ 0x38(SP), CX			
  0x43fa98		488d7001		LEAQ 0x1(AX), SI			
  0x43fa9c		488b442448		MOVQ 0x48(SP), AX			
  0x43faa1		488b9c2490000000	MOVQ 0x90(SP), BX			
  0x43faa9		e91bffffff		JMP 0x43f9c9				
				t = prev.typemap[typeOff(tl)]
  0x43faae		4c89642408		MOVQ R12, 0x8(SP)			
  0x43fab3		488d0586af0100		LEAQ 0x1af86(IP), AX			
  0x43faba		48890424		MOVQ AX, 0(SP)				
  0x43fabe		44895c2410		MOVL R11, 0x10(SP)			
  0x43fac3		e8a87dfcff		CALL runtime.mapaccess1_fast32(SB)	
  0x43fac8		488b442418		MOVQ 0x18(SP), AX			
  0x43facd		4c8b18			MOVQ 0(AX), R11				
  0x43fad0		488b842480000000	MOVQ 0x80(SP), AX			
  0x43fad8		e99bfeffff		JMP 0x43f978				
		if md.typemap == nil {
  0x43fadd		488bb7b0010000		MOVQ 0x1b0(DI), SI	
  0x43fae4		4c8d87b0010000		LEAQ 0x1b0(DI), R8	
  0x43faeb		4885f6			TESTQ SI, SI		
  0x43faee		744b			JE 0x43fb3b		
	for _, md := range modules[1:] {
  0x43faf0		48ffc3			INCQ BX			
  0x43faf3		4889fe			MOVQ DI, SI		
  0x43faf6		4839d3			CMPQ DX, BX		
  0x43faf9		0f8d61030000		JGE 0x43fe60		
  0x43faff		48895c2470		MOVQ BX, 0x70(SP)	
  0x43fb04		4889b424a0000000	MOVQ SI, 0xa0(SP)	
  0x43fb0c		488b3cd9		MOVQ 0(CX)(BX*8), DI	
  0x43fb10		4889bc24a8000000	MOVQ DI, 0xa8(SP)	
		for _, tl := range prev.typelinks {
  0x43fb18		4c8b86f0000000		MOVQ 0xf0(SI), R8	
  0x43fb1f		4c898424d0000000	MOVQ R8, 0xd0(SP)	
  0x43fb27		4c8b8ef8000000		MOVQ 0xf8(SI), R9	
  0x43fb2e		4c894c2468		MOVQ R9, 0x68(SP)	
  0x43fb33		4531d2			XORL R10, R10		
  0x43fb36		e911feffff		JMP 0x43f94c		
  0x43fb3b		4c898424c0000000	MOVQ R8, 0xc0(SP)	
			tm := make(map[typeOff]*_type, len(md.typelinks))
  0x43fb43		488b87f8000000		MOVQ 0xf8(DI), AX		
  0x43fb4a		488d0defae0100		LEAQ 0x1aeef(IP), CX		
  0x43fb51		48890c24		MOVQ CX, 0(SP)			
  0x43fb55		4889442408		MOVQ AX, 0x8(SP)		
  0x43fb5a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43fb63		e81867fcff		CALL runtime.makemap(SB)	
  0x43fb68		488b442418		MOVQ 0x18(SP), AX		
			pinnedTypemaps = append(pinnedTypemaps, tm)
  0x43fb6d		488b0ddc7b0600		MOVQ runtime.pinnedTypemaps(SB), CX	
  0x43fb74		488b15dd7b0600		MOVQ runtime.pinnedTypemaps+8(SB), DX	
  0x43fb7b		488b1dde7b0600		MOVQ runtime.pinnedTypemaps+16(SB), BX	
  0x43fb82		488d7201		LEAQ 0x1(DX), SI			
  0x43fb86		4839de			CMPQ BX, SI				
  0x43fb89		0f8f5d020000		JG 0x43fdec				
  0x43fb8f		488d5a01		LEAQ 0x1(DX), BX			
  0x43fb93		48891dbe7b0600		MOVQ BX, runtime.pinnedTypemaps+8(SB)	
  0x43fb9a		488d3cd1		LEAQ 0(CX)(DX*8), DI			
  0x43fb9e		8b1d6c3e0800		MOVL runtime.writeBarrier(SB), BX	
  0x43fba4		85db			TESTL BX, BX				
  0x43fba6		0f8521020000		JNE 0x43fdcd				
  0x43fbac		488904d1		MOVQ AX, 0(CX)(DX*8)			
  0x43fbb0		488b8c24a8000000	MOVQ 0xa8(SP), CX			
			md.typemap = tm
  0x43fbb8		488981b0010000		MOVQ AX, 0x1b0(CX)	
			for _, tl := range md.typelinks {
  0x43fbbf		488b81f8000000		MOVQ 0xf8(CX), AX	
  0x43fbc6		4889442468		MOVQ AX, 0x68(SP)	
  0x43fbcb		488b91f0000000		MOVQ 0xf0(CX), DX	
  0x43fbd2		48899424d0000000	MOVQ DX, 0xd0(SP)	
  0x43fbda		31db			XORL BX, BX		
  0x43fbdc		e93b010000		JMP 0x43fd1c		
  0x43fbe1		488b5c2450		MOVQ 0x50(SP), BX	
				for _, candidate := range typehash[t.hash] {
  0x43fbe6		488d5301		LEAQ 0x1(BX), DX	
  0x43fbea		488b8424c8000000	MOVQ 0xc8(SP), AX	
  0x43fbf2		488b4c2458		MOVQ 0x58(SP), CX	
  0x43fbf7		4839ca			CMPQ CX, DX		
  0x43fbfa		0f8d99010000		JGE 0x43fd99		
  0x43fc00		4889542450		MOVQ DX, 0x50(SP)	
  0x43fc05		488b0cd0		MOVQ 0(AX)(DX*8), CX	
  0x43fc09		48898c24b0000000	MOVQ CX, 0xb0(SP)	
					seen := map[_typePair]struct{}{}
  0x43fc11		0f57c0			XORPS X0, X0			
  0x43fc14		0f118424e0000000	MOVUPS X0, 0xe0(SP)		
  0x43fc1c		0f118424f0000000	MOVUPS X0, 0xf0(SP)		
  0x43fc24		0f11842400010000	MOVUPS X0, 0x100(SP)		
  0x43fc2c		488dbc2440010000	LEAQ 0x140(SP), DI		
  0x43fc34		488d7fd0		LEAQ -0x30(DI), DI		
  0x43fc38		48896c24f0		MOVQ BP, -0x10(SP)		
  0x43fc3d		488d6c24f0		LEAQ -0x10(SP), BP		
  0x43fc42		e85b6e0000		CALL 0x446aa2			
  0x43fc47		488b6d00		MOVQ 0(BP), BP			
  0x43fc4b		488d9c2440010000	LEAQ 0x140(SP), BX		
  0x43fc53		48899c24f0000000	MOVQ BX, 0xf0(SP)		
  0x43fc5b		e8207bffff		CALL runtime.fastrand(SB)	
  0x43fc60		8b0424			MOVL 0(SP), AX			
  0x43fc63		898424ec000000		MOVL AX, 0xec(SP)		
  0x43fc6a		488b8424b8000000	MOVQ 0xb8(SP), AX		
					if typesEqual(t, candidate, seen) {
  0x43fc72		48890424		MOVQ AX, 0(SP)			
  0x43fc76		488b8c24b0000000	MOVQ 0xb0(SP), CX		
  0x43fc7e		48894c2408		MOVQ CX, 0x8(SP)		
  0x43fc83		488d9424e0000000	LEAQ 0xe0(SP), DX		
  0x43fc8b		4889542410		MOVQ DX, 0x10(SP)		
  0x43fc90		e80b020000		CALL runtime.typesEqual(SB)	
  0x43fc95		0fb6442418		MOVZX 0x18(SP), AX		
  0x43fc9a		84c0			TESTL AL, AL			
  0x43fc9c		0f843fffffff		JE 0x43fbe1			
  0x43fca2		488b8424b0000000	MOVQ 0xb0(SP), AX		
						break
  0x43fcaa		4889842498000000	MOVQ AX, 0x98(SP)	
  0x43fcb2		488b8c24a8000000	MOVQ 0xa8(SP), CX	
				md.typemap[typeOff(tl)] = t
  0x43fcba		488b91b0010000		MOVQ 0x1b0(CX), DX			
  0x43fcc1		4889542408		MOVQ DX, 0x8(SP)			
  0x43fcc6		488d1573ad0100		LEAQ 0x1ad73(IP), DX			
  0x43fccd		48891424		MOVQ DX, 0(SP)				
  0x43fcd1		8b5c2444		MOVL 0x44(SP), BX			
  0x43fcd5		895c2410		MOVL BX, 0x10(SP)			
  0x43fcd9		e8f27efcff		CALL runtime.mapassign_fast32(SB)	
  0x43fcde		488b7c2418		MOVQ 0x18(SP), DI			
  0x43fce3		8407			TESTB AL, 0(DI)				
  0x43fce5		8b05253d0800		MOVL runtime.writeBarrier(SB), AX	
  0x43fceb		85c0			TESTL AX, AX				
  0x43fced		0f8594000000		JNE 0x43fd87				
  0x43fcf3		488b842498000000	MOVQ 0x98(SP), AX			
  0x43fcfb		488907			MOVQ AX, 0(DI)				
  0x43fcfe		488b742460		MOVQ 0x60(SP), SI			
			for _, tl := range md.typelinks {
  0x43fd03		488d5e01		LEAQ 0x1(SI), BX	
  0x43fd07		488b442468		MOVQ 0x68(SP), AX	
  0x43fd0c		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x43fd14		488b9424d0000000	MOVQ 0xd0(SP), DX	
  0x43fd1c		4839c3			CMPQ AX, BX		
  0x43fd1f		0f8d81000000		JGE 0x43fda6		
  0x43fd25		48895c2460		MOVQ BX, 0x60(SP)	
  0x43fd2a		8b049a			MOVL 0(DX)(BX*4), AX	
  0x43fd2d		89442444		MOVL AX, 0x44(SP)	
				t := (*_type)(unsafe.Pointer(md.types + uintptr(tl)))
  0x43fd31		4863f0			MOVSXD AX, SI		
  0x43fd34		4803b1c8000000		ADDQ 0xc8(CX), SI	
  0x43fd3b		4889b424b8000000	MOVQ SI, 0xb8(SP)	
				for _, candidate := range typehash[t.hash] {
  0x43fd43		8b7e10			MOVL 0x10(SI), DI			
  0x43fd46		897c2410		MOVL DI, 0x10(SP)			
  0x43fd4a		488d3dafad0100		LEAQ 0x1adaf(IP), DI			
  0x43fd51		48893c24		MOVQ DI, 0(SP)				
  0x43fd55		4c8b842480000000	MOVQ 0x80(SP), R8			
  0x43fd5d		4c89442408		MOVQ R8, 0x8(SP)			
  0x43fd62		e8097bfcff		CALL runtime.mapaccess1_fast32(SB)	
  0x43fd67		488b442418		MOVQ 0x18(SP), AX			
  0x43fd6c		488b4808		MOVQ 0x8(AX), CX			
  0x43fd70		48894c2458		MOVQ CX, 0x58(SP)			
  0x43fd75		488b00			MOVQ 0(AX), AX				
  0x43fd78		48898424c8000000	MOVQ AX, 0xc8(SP)			
  0x43fd80		31d2			XORL DX, DX				
  0x43fd82		e970feffff		JMP 0x43fbf7				
  0x43fd87		488b842498000000	MOVQ 0x98(SP), AX			
				md.typemap[typeOff(tl)] = t
  0x43fd8f		e80c6b0000		CALL runtime.gcWriteBarrier(SB)	
  0x43fd94		e965ffffff		JMP 0x43fcfe			
  0x43fd99		488b8424b8000000	MOVQ 0xb8(SP), AX		
				for _, candidate := range typehash[t.hash] {
  0x43fda1		e904ffffff		JMP 0x43fcaa		
  0x43fda6		488b842480000000	MOVQ 0x80(SP), AX	
  0x43fdae		488b8c24d8000000	MOVQ 0xd8(SP), CX	
  0x43fdb6		488b542478		MOVQ 0x78(SP), DX	
  0x43fdbb		488b5c2470		MOVQ 0x70(SP), BX	
  0x43fdc0		488bbc24a8000000	MOVQ 0xa8(SP), DI	
		prev = md
  0x43fdc8		e923fdffff		JMP 0x43faf0		
			pinnedTypemaps = append(pinnedTypemaps, tm)
  0x43fdcd		e8ce6a0000		CALL runtime.gcWriteBarrier(SB)	
  0x43fdd2		488bbc24c0000000	MOVQ 0xc0(SP), DI		
			md.typemap = tm
  0x43fdda		e8c16a0000		CALL runtime.gcWriteBarrier(SB)	
  0x43fddf		488b8c24a8000000	MOVQ 0xa8(SP), CX		
			pinnedTypemaps = append(pinnedTypemaps, tm)
  0x43fde7		e9d3fdffff		JMP 0x43fbbf				
  0x43fdec		4889842488000000	MOVQ AX, 0x88(SP)			
  0x43fdf4		488d0545ac0100		LEAQ 0x1ac45(IP), AX			
  0x43fdfb		48890424		MOVQ AX, 0(SP)				
  0x43fdff		48894c2408		MOVQ CX, 0x8(SP)			
  0x43fe04		4889542410		MOVQ DX, 0x10(SP)			
  0x43fe09		48895c2418		MOVQ BX, 0x18(SP)			
  0x43fe0e		4889742420		MOVQ SI, 0x20(SP)			
  0x43fe13		e8483affff		CALL runtime.growslice(SB)		
  0x43fe18		488b442428		MOVQ 0x28(SP), AX			
  0x43fe1d		488b4c2430		MOVQ 0x30(SP), CX			
  0x43fe22		488b542438		MOVQ 0x38(SP), DX			
  0x43fe27		48891532790600		MOVQ DX, runtime.pinnedTypemaps+16(SB)	
  0x43fe2e		8b15dc3b0800		MOVL runtime.writeBarrier(SB), DX	
  0x43fe34		85d2			TESTL DX, DX				
  0x43fe36		751a			JNE 0x43fe52				
  0x43fe38		48890511790600		MOVQ AX, runtime.pinnedTypemaps(SB)	
  0x43fe3f		4889ca			MOVQ CX, DX				
  0x43fe42		4889c1			MOVQ AX, CX				
  0x43fe45		488b842488000000	MOVQ 0x88(SP), AX			
  0x43fe4d		e93dfdffff		JMP 0x43fb8f				
  0x43fe52		488d3df7780600		LEAQ runtime.pinnedTypemaps(SB), DI	
  0x43fe59		e8426a0000		CALL runtime.gcWriteBarrier(SB)		
  0x43fe5e		ebdf			JMP 0x43fe3f				
  0x43fe60		488bac24c0020000	MOVQ 0x2c0(SP), BP			
  0x43fe68		4881c4c8020000		ADDQ $0x2c8, SP				
  0x43fe6f		c3			RET					
  0x43fe70		31db			XORL BX, BX				
  0x43fe72		31d2			XORL DX, DX				
  0x43fe74		31c9			XORL CX, CX				
	modules := activeModules()
  0x43fe76		e940faffff		JMP 0x43f8bb		
		return
  0x43fe7b		488bac24c0020000	MOVQ 0x2c0(SP), BP	
  0x43fe83		4881c4c8020000		ADDQ $0x2c8, SP		
  0x43fe8a		c3			RET			
	prev := modules[0]
  0x43fe8b		e8b0fbfdff		CALL runtime.panicindex(SB)	
  0x43fe90		0f0b			UD2				
func typelinksinit() {
  0x43fe92		e8d9460000		CALL runtime.morestack_noctxt(SB)	
  0x43fe97		e914f9ffff		JMP runtime.typelinksinit(SB)		

TEXT runtime.typesEqual(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/type.go
func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool {
  0x43fea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43fea9		488d842438ffffff	LEAQ 0xffffff38(SP), AX	
  0x43feb1		483b4110		CMPQ 0x10(CX), AX	
  0x43feb5		0f86420f0000		JBE 0x440dfd		
  0x43febb		4881ec48010000		SUBQ $0x148, SP		
  0x43fec2		4889ac2440010000	MOVQ BP, 0x140(SP)	
  0x43feca		488dac2440010000	LEAQ 0x140(SP), BP	
  0x43fed2		488b842450010000	MOVQ 0x150(SP), AX	
	if _, ok := seen[tp]; ok {
  0x43feda		4889842430010000	MOVQ AX, 0x130(SP)	
func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool {
  0x43fee2		488b8c2458010000	MOVQ 0x158(SP), CX	
	if _, ok := seen[tp]; ok {
  0x43feea		48898c2438010000	MOVQ CX, 0x138(SP)	
  0x43fef2		488d15e7aa0100		LEAQ 0x1aae7(IP), DX	
  0x43fef9		48891424		MOVQ DX, 0(SP)		
func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool {
  0x43fefd		488b9c2460010000	MOVQ 0x160(SP), BX	
	if _, ok := seen[tp]; ok {
  0x43ff05		48895c2408		MOVQ BX, 0x8(SP)		
  0x43ff0a		488db42430010000	LEAQ 0x130(SP), SI		
  0x43ff12		4889742410		MOVQ SI, 0x10(SP)		
  0x43ff17		e85465fcff		CALL runtime.mapaccess2(SB)	
  0x43ff1c		0fb6442420		MOVZX 0x20(SP), AX		
  0x43ff21		84c0			TESTL AL, AL			
  0x43ff23		0f85300e0000		JNE 0x440d59			
	seen[tp] = struct{}{}
  0x43ff29		488b842450010000	MOVQ 0x150(SP), AX		
  0x43ff31		4889842420010000	MOVQ AX, 0x120(SP)		
  0x43ff39		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x43ff41		48898c2428010000	MOVQ CX, 0x128(SP)		
  0x43ff49		488d1590aa0100		LEAQ 0x1aa90(IP), DX		
  0x43ff50		48891424		MOVQ DX, 0(SP)			
  0x43ff54		488b942460010000	MOVQ 0x160(SP), DX		
  0x43ff5c		4889542408		MOVQ DX, 0x8(SP)		
  0x43ff61		488d9c2420010000	LEAQ 0x120(SP), BX		
  0x43ff69		48895c2410		MOVQ BX, 0x10(SP)		
  0x43ff6e		e83d67fcff		CALL runtime.mapassign(SB)	
  0x43ff73		488b442418		MOVQ 0x18(SP), AX		
  0x43ff78		8400			TESTB AL, 0(AX)			
func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool {
  0x43ff7a		488b842450010000	MOVQ 0x150(SP), AX	
  0x43ff82		488b8c2458010000	MOVQ 0x158(SP), CX	
	if t == v {
  0x43ff8a		4839c8			CMPQ CX, AX		
  0x43ff8d		0f84ae0d0000		JE 0x440d41		
	kind := t.kind & kindMask
  0x43ff93		0fb65017		MOVZX 0x17(AX), DX	
  0x43ff97		89d3			MOVL DX, BX		
  0x43ff99		83e21f			ANDL $0x1f, DX		
	if kind != v.kind&kindMask {
  0x43ff9c		0fb67117		MOVZX 0x17(CX), SI	
  0x43ffa0		83e61f			ANDL $0x1f, SI		
  0x43ffa3		4038f2			CMPL SI, DL		
  0x43ffa6		0f857d0d0000		JNE 0x440d29		
  0x43ffac		885c242f		MOVB BL, 0x2f(SP)	
  0x43ffb0		8854242e		MOVB DL, 0x2e(SP)	
	if t.string() != v.string() {
  0x43ffb4		48890424		MOVQ AX, 0(SP)				
  0x43ffb8		e8b3e9ffff		CALL runtime.(*_type).string(SB)	
  0x43ffbd		488b442410		MOVQ 0x10(SP), AX			
  0x43ffc2		4889842488000000	MOVQ AX, 0x88(SP)			
  0x43ffca		488b4c2408		MOVQ 0x8(SP), CX			
  0x43ffcf		48898c2418010000	MOVQ CX, 0x118(SP)			
  0x43ffd7		488b942458010000	MOVQ 0x158(SP), DX			
  0x43ffdf		48891424		MOVQ DX, 0(SP)				
  0x43ffe3		e888e9ffff		CALL runtime.(*_type).string(SB)	
  0x43ffe8		488b442410		MOVQ 0x10(SP), AX			
  0x43ffed		488b8c2488000000	MOVQ 0x88(SP), CX			
  0x43fff5		4839c8			CMPQ CX, AX				
  0x43fff8		7418			JE 0x440012				
		return false
  0x43fffa		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440002		488bac2440010000	MOVQ 0x140(SP), BP	
  0x44000a		4881c448010000		ADDQ $0x148, SP		
  0x440011		c3			RET			
  0x440012		488b842418010000	MOVQ 0x118(SP), AX	
	if t.string() != v.string() {
  0x44001a		48890424		MOVQ AX, 0(SP)			
  0x44001e		48894c2410		MOVQ CX, 0x10(SP)		
  0x440023		e818630000		CALL runtime.memequal(SB)	
  0x440028		0fb6442418		MOVZX 0x18(SP), AX		
  0x44002d		84c0			TESTL AL, AL			
  0x44002f		74c9			JE 0x43fffa			
  0x440031		488b842450010000	MOVQ 0x150(SP), AX		
	ut := t.uncommon()
  0x440039		48890424		MOVQ AX, 0(SP)				
  0x44003d		e8dee9ffff		CALL runtime.(*_type).uncommon(SB)	
  0x440042		488b442408		MOVQ 0x8(SP), AX			
  0x440047		48898424a8000000	MOVQ AX, 0xa8(SP)			
  0x44004f		488b8c2458010000	MOVQ 0x158(SP), CX			
	uv := v.uncommon()
  0x440057		48890c24		MOVQ CX, 0(SP)				
  0x44005b		e8c0e9ffff		CALL runtime.(*_type).uncommon(SB)	
  0x440060		488b442408		MOVQ 0x8(SP), AX			
  0x440065		488b8c24a8000000	MOVQ 0xa8(SP), CX			
	if ut != nil || uv != nil {
  0x44006d		4885c9			TESTQ CX, CX		
  0x440070		0f85d90b0000		JNE 0x440c4f		
  0x440076		4885c0			TESTQ AX, AX		
  0x440079		0f85cd0b0000		JNE 0x440c4c		
  0x44007f		0fb644242e		MOVZX 0x2e(SP), AX	
	if kindBool <= kind && kind <= kindComplex128 {
  0x440084		8d48ff			LEAL -0x1(AX), CX	
  0x440087		80f90f			CMPL $0xf, CL		
  0x44008a		0f86a40b0000		JBE 0x440c34		
	switch kind {
  0x440090		3c15			CMPL $0x15, AL		
  0x440092		0f879b070000		JA 0x440833		
  0x440098		3c12			CMPL $0x12, AL		
  0x44009a		0f86b2060000		JBE 0x440752		
	case kindFunc:
  0x4400a0		3c13			CMPL $0x13, AL		
  0x4400a2		0f85a9020000		JNE 0x440351		
  0x4400a8		488b842450010000	MOVQ 0x150(SP), AX	
		if ft.outCount != fv.outCount || ft.inCount != fv.inCount {
  0x4400b0		0fb74832		MOVZX 0x32(AX), CX	
  0x4400b4		488b942458010000	MOVQ 0x158(SP), DX	
  0x4400bc		0fb75a32		MOVZX 0x32(DX), BX	
  0x4400c0		6639d9			CMPW BX, CX		
  0x4400c3		0f8570020000		JNE 0x440339		
  0x4400c9		0fb74830		MOVZX 0x30(AX), CX	
  0x4400cd		0fb75a30		MOVZX 0x30(DX), BX	
  0x4400d1		6639cb			CMPW CX, BX		
  0x4400d4		0f855f020000		JNE 0x440339		
	if t.typ.tflag&tflagUncommon != 0 {
  0x4400da		0fb67014		MOVZX 0x14(AX), SI	
  0x4400de		40f6c601		TESTL $0x1, SI		
  0x4400e2		0f8447020000		JE 0x44032f		
  0x4400e8		be48000000		MOVL $0x48, SI		
	return unsafe.Pointer(uintptr(p) + x)
  0x4400ed		4801c6			ADDQ AX, SI		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[:t.inCount]
  0x4400f0		8406			TESTB AL, 0(SI)		
  0x4400f2		0fb7c9			MOVZX CX, CX		
	if t.typ.tflag&tflagUncommon != 0 {
  0x4400f5		0fb67a14		MOVZX 0x14(DX), DI	
  0x4400f9		40f6c701		TESTL $0x1, DI		
  0x4400fd		0f8422020000		JE 0x440325		
  0x440103		bf48000000		MOVL $0x48, DI		
	return unsafe.Pointer(uintptr(p) + x)
  0x440108		4801d7			ADDQ DX, DI		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[:t.inCount]
  0x44010b		8407			TESTB AL, 0(DI)		
  0x44010d		0fb7db			MOVZX BX, BX		
  0x440110		4889b42410010000	MOVQ SI, 0x110(SP)	
  0x440118		48894c2448		MOVQ CX, 0x48(SP)	
  0x44011d		4889bc2408010000	MOVQ DI, 0x108(SP)	
  0x440125		48895c2438		MOVQ BX, 0x38(SP)	
  0x44012a		4531c0			XORL R8, R8		
		for i := 0; i < len(tin); i++ {
  0x44012d		eb33			JMP 0x440162		
  0x44012f		4c8b4c2458		MOVQ 0x58(SP), R9	
  0x440134		4d8d4101		LEAQ 0x1(R9), R8	
  0x440138		488b842450010000	MOVQ 0x150(SP), AX	
  0x440140		488b4c2448		MOVQ 0x48(SP), CX	
  0x440145		488b942458010000	MOVQ 0x158(SP), DX	
  0x44014d		488b5c2438		MOVQ 0x38(SP), BX	
  0x440152		488bb42410010000	MOVQ 0x110(SP), SI	
  0x44015a		488bbc2408010000	MOVQ 0x108(SP), DI	
  0x440162		4939c8			CMPQ CX, R8		
  0x440165		7d52			JGE 0x4401b9		
			if !typesEqual(tin[i], vin[i], seen) {
  0x440167		4e8b0cc6		MOVQ 0(SI)(R8*8), R9		
  0x44016b		4939d8			CMPQ BX, R8			
  0x44016e		0f832e0c0000		JAE 0x440da2			
  0x440174		4c89442458		MOVQ R8, 0x58(SP)		
  0x440179		4a8b04c7		MOVQ 0(DI)(R8*8), AX		
  0x44017d		4889442408		MOVQ AX, 0x8(SP)		
  0x440182		4c890c24		MOVQ R9, 0(SP)			
  0x440186		488b842460010000	MOVQ 0x160(SP), AX		
  0x44018e		4889442410		MOVQ AX, 0x10(SP)		
  0x440193		e808fdffff		CALL runtime.typesEqual(SB)	
  0x440198		0fb6442418		MOVZX 0x18(SP), AX		
  0x44019d		84c0			TESTL AL, AL			
  0x44019f		758e			JNE 0x44012f			
				return false
  0x4401a1		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x4401a9		488bac2440010000	MOVQ 0x140(SP), BP	
  0x4401b1		4881c448010000		ADDQ $0x148, SP		
  0x4401b8		c3			RET			
	if t.typ.tflag&tflagUncommon != 0 {
  0x4401b9		0fb64814		MOVZX 0x14(AX), CX	
  0x4401bd		f6c101			TESTL $0x1, CL		
  0x4401c0		0f8455010000		JE 0x44031b		
  0x4401c6		b948000000		MOVL $0x48, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4401cb		4801c1			ADDQ AX, CX		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x4401ce		8401			TESTB AL, 0(CX)		
	outCount := t.outCount & (1<<15 - 1)
  0x4401d0		0fb75832		MOVZX 0x32(AX), BX	
  0x4401d4		81e3ff7f0000		ANDL $0x7fff, BX	
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x4401da		0fb74030		MOVZX 0x30(AX), AX	
  0x4401de		0fb7f0			MOVZX AX, SI		
  0x4401e1		01d8			ADDL BX, AX		
  0x4401e3		0fb7c0			MOVZX AX, AX		
  0x4401e6		4839c6			CMPQ AX, SI		
  0x4401e9		0f87ac0b0000		JA 0x440d9b		
  0x4401ef		4829f0			SUBQ SI, AX		
  0x4401f2		488d9e0000f0ff		LEAQ 0xfff00000(SI), BX	
  0x4401f9		48f7db			NEGQ BX			
  0x4401fc		48f7db			NEGQ BX			
  0x4401ff		48c1fb3f		SARQ $0x3f, BX		
  0x440203		48c1e603		SHLQ $0x3, SI		
  0x440207		4821de			ANDQ BX, SI		
  0x44020a		4801f1			ADDQ SI, CX		
	if t.typ.tflag&tflagUncommon != 0 {
  0x44020d		0fb65a14		MOVZX 0x14(DX), BX	
  0x440211		f6c301			TESTL $0x1, BL		
  0x440214		0f84f7000000		JE 0x440311		
  0x44021a		bb48000000		MOVL $0x48, BX		
	return unsafe.Pointer(uintptr(p) + x)
  0x44021f		4801d3			ADDQ DX, BX		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x440222		8403			TESTB AL, 0(BX)		
	outCount := t.outCount & (1<<15 - 1)
  0x440224		0fb77232		MOVZX 0x32(DX), SI	
  0x440228		81e6ff7f0000		ANDL $0x7fff, SI	
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x44022e		0fb75230		MOVZX 0x30(DX), DX	
  0x440232		0fb7fa			MOVZX DX, DI		
  0x440235		01f2			ADDL SI, DX		
  0x440237		0fb7d2			MOVZX DX, DX		
  0x44023a		4839d7			CMPQ DX, DI		
  0x44023d		0f87510b0000		JA 0x440d94		
  0x440243		4889442440		MOVQ AX, 0x40(SP)	
  0x440248		48898c24b0000000	MOVQ CX, 0xb0(SP)	
  0x440250		4829fa			SUBQ DI, DX		
  0x440253		4889542430		MOVQ DX, 0x30(SP)	
  0x440258		488db70000f0ff		LEAQ 0xfff00000(DI), SI	
  0x44025f		48f7de			NEGQ SI			
  0x440262		48f7de			NEGQ SI			
  0x440265		48c1e703		SHLQ $0x3, DI		
  0x440269		48c1fe3f		SARQ $0x3f, SI		
  0x44026d		4821f7			ANDQ SI, DI		
  0x440270		4801fb			ADDQ DI, BX		
  0x440273		48899c2490000000	MOVQ BX, 0x90(SP)	
  0x44027b		31f6			XORL SI, SI		
		for i := 0; i < len(tout); i++ {
  0x44027d		eb23			JMP 0x4402a2		
  0x44027f		488b7c2468		MOVQ 0x68(SP), DI	
  0x440284		488d7701		LEAQ 0x1(DI), SI	
  0x440288		488b442440		MOVQ 0x40(SP), AX	
  0x44028d		488b8c24b0000000	MOVQ 0xb0(SP), CX	
  0x440295		488b542430		MOVQ 0x30(SP), DX	
  0x44029a		488b9c2490000000	MOVQ 0x90(SP), BX	
  0x4402a2		4839c6			CMPQ AX, SI		
  0x4402a5		7d52			JGE 0x4402f9		
			if !typesEqual(tout[i], vout[i], seen) {
  0x4402a7		488b3cf1		MOVQ 0(CX)(SI*8), DI		
  0x4402ab		4839d6			CMPQ DX, SI			
  0x4402ae		0f83d90a0000		JAE 0x440d8d			
  0x4402b4		4889742468		MOVQ SI, 0x68(SP)		
  0x4402b9		488b04f3		MOVQ 0(BX)(SI*8), AX		
  0x4402bd		4889442408		MOVQ AX, 0x8(SP)		
  0x4402c2		48893c24		MOVQ DI, 0(SP)			
  0x4402c6		488b842460010000	MOVQ 0x160(SP), AX		
  0x4402ce		4889442410		MOVQ AX, 0x10(SP)		
  0x4402d3		e8c8fbffff		CALL runtime.typesEqual(SB)	
  0x4402d8		0fb6442418		MOVZX 0x18(SP), AX		
  0x4402dd		84c0			TESTL AL, AL			
  0x4402df		759e			JNE 0x44027f			
				return false
  0x4402e1		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x4402e9		488bac2440010000	MOVQ 0x140(SP), BP	
  0x4402f1		4881c448010000		ADDQ $0x148, SP		
  0x4402f8		c3			RET			
		return true
  0x4402f9		c684246801000001	MOVB $0x1, 0x168(SP)	
  0x440301		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440309		4881c448010000		ADDQ $0x148, SP		
  0x440310		c3			RET			
  0x440311		bb38000000		MOVL $0x38, BX		
	if t.typ.tflag&tflagUncommon != 0 {
  0x440316		e904ffffff		JMP 0x44021f		
  0x44031b		b938000000		MOVL $0x38, CX		
  0x440320		e9a6feffff		JMP 0x4401cb		
  0x440325		bf38000000		MOVL $0x38, DI		
	if t.typ.tflag&tflagUncommon != 0 {
  0x44032a		e9d9fdffff		JMP 0x440108		
  0x44032f		be38000000		MOVL $0x38, SI		
  0x440334		e9b4fdffff		JMP 0x4400ed		
			return false
  0x440339		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440341		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440349		4881c448010000		ADDQ $0x148, SP		
  0x440350		c3			RET			
	case kindInterface:
  0x440351		3c14			CMPL $0x14, AL		
  0x440353		0f856a030000		JNE 0x4406c3		
  0x440359		488b842450010000	MOVQ 0x150(SP), AX	
		if it.pkgpath.name() != iv.pkgpath.name() {
  0x440361		488b4830		MOVQ 0x30(AX), CX		
  0x440365		48890c24		MOVQ CX, 0(SP)			
  0x440369		e822f2ffff		CALL runtime.name.name(SB)	
  0x44036e		488b442410		MOVQ 0x10(SP), AX		
  0x440373		4889842488000000	MOVQ AX, 0x88(SP)		
  0x44037b		488b4c2408		MOVQ 0x8(SP), CX		
  0x440380		48898c2418010000	MOVQ CX, 0x118(SP)		
  0x440388		488b942458010000	MOVQ 0x158(SP), DX		
  0x440390		488b5a30		MOVQ 0x30(DX), BX		
  0x440394		48891c24		MOVQ BX, 0(SP)			
  0x440398		e8f3f1ffff		CALL runtime.name.name(SB)	
  0x44039d		488b442410		MOVQ 0x10(SP), AX		
  0x4403a2		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x4403aa		4839c8			CMPQ CX, AX			
  0x4403ad		7418			JE 0x4403c7			
			return false
  0x4403af		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x4403b7		488bac2440010000	MOVQ 0x140(SP), BP	
  0x4403bf		4881c448010000		ADDQ $0x148, SP		
  0x4403c6		c3			RET			
  0x4403c7		488b842418010000	MOVQ 0x118(SP), AX	
		if it.pkgpath.name() != iv.pkgpath.name() {
  0x4403cf		48890424		MOVQ AX, 0(SP)			
  0x4403d3		48894c2410		MOVQ CX, 0x10(SP)		
  0x4403d8		e8635f0000		CALL runtime.memequal(SB)	
  0x4403dd		0fb6442418		MOVZX 0x18(SP), AX		
  0x4403e2		84c0			TESTL AL, AL			
  0x4403e4		74c9			JE 0x4403af			
  0x4403e6		488b842450010000	MOVQ 0x150(SP), AX		
		if len(it.mhdr) != len(iv.mhdr) {
  0x4403ee		488b4840		MOVQ 0x40(AX), CX	
  0x4403f2		488b942458010000	MOVQ 0x158(SP), DX	
  0x4403fa		488b5a40		MOVQ 0x40(DX), BX	
  0x4403fe		4839d9			CMPQ BX, CX		
  0x440401		0f85a4020000		JNE 0x4406ab		
  0x440407		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x44040f		31db			XORL BX, BX		
		for i := range it.mhdr {
  0x440411		eb21			JMP 0x440434		
  0x440413		488b742460		MOVQ 0x60(SP), SI	
  0x440418		488d5e01		LEAQ 0x1(SI), BX	
  0x44041c		488b842450010000	MOVQ 0x150(SP), AX	
  0x440424		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x44042c		488b942458010000	MOVQ 0x158(SP), DX	
  0x440434		4839cb			CMPQ CX, BX		
  0x440437		0f8d56020000		JGE 0x440693		
			tm := &it.mhdr[i]
  0x44043d		488b7040		MOVQ 0x40(AX), SI	
  0x440441		488b7838		MOVQ 0x38(AX), DI	
  0x440445		4839f3			CMPQ SI, BX		
  0x440448		0f8338090000		JAE 0x440d86		
  0x44044e		488d34df		LEAQ 0(DI)(BX*8), SI	
			vm := &iv.mhdr[i]
  0x440452		4c8b4240		MOVQ 0x40(DX), R8	
  0x440456		4c8b4a38		MOVQ 0x38(DX), R9	
  0x44045a		4c39c3			CMPQ R8, BX		
  0x44045d		0f831c090000		JAE 0x440d7f		
  0x440463		4c898c2400010000	MOVQ R9, 0x100(SP)	
  0x44046b		4889bc24f8000000	MOVQ DI, 0xf8(SP)	
  0x440473		48895c2460		MOVQ BX, 0x60(SP)	
  0x440478		4889b424b8000000	MOVQ SI, 0xb8(SP)	
			tname := resolveNameOff(unsafe.Pointer(tm), tm.name)
  0x440480		8b04df			MOVL 0(DI)(BX*8), AX		
  0x440483		89442408		MOVL AX, 0x8(SP)		
  0x440487		48893424		MOVQ SI, 0(SP)			
  0x44048b		e8c0e6ffff		CALL runtime.resolveNameOff(SB)	
  0x440490		488b442410		MOVQ 0x10(SP), AX		
  0x440495		48898424f0000000	MOVQ AX, 0xf0(SP)		
  0x44049d		488b4c2460		MOVQ 0x60(SP), CX		
  0x4404a2		488b942400010000	MOVQ 0x100(SP), DX		
			vname := resolveNameOff(unsafe.Pointer(vm), vm.name)
  0x4404aa		8b1cca			MOVL 0(DX)(CX*8), BX	
  0x4404ad		895c2408		MOVL BX, 0x8(SP)	
			vm := &iv.mhdr[i]
  0x4404b1		488d1cca		LEAQ 0(DX)(CX*8), BX	
  0x4404b5		48899c2498000000	MOVQ BX, 0x98(SP)	
			vname := resolveNameOff(unsafe.Pointer(vm), vm.name)
  0x4404bd		48891c24		MOVQ BX, 0(SP)			
  0x4404c1		e88ae6ffff		CALL runtime.resolveNameOff(SB)	
  0x4404c6		488b442410		MOVQ 0x10(SP), AX		
  0x4404cb		48898424e8000000	MOVQ AX, 0xe8(SP)		
  0x4404d3		488b8c24f0000000	MOVQ 0xf0(SP), CX		
			if tname.name() != vname.name() {
  0x4404db		48890c24		MOVQ CX, 0(SP)			
  0x4404df		e8acf0ffff		CALL runtime.name.name(SB)	
  0x4404e4		488b442410		MOVQ 0x10(SP), AX		
  0x4404e9		4889842480000000	MOVQ AX, 0x80(SP)		
  0x4404f1		488b4c2408		MOVQ 0x8(SP), CX		
  0x4404f6		48898c24e0000000	MOVQ CX, 0xe0(SP)		
  0x4404fe		488b9424e8000000	MOVQ 0xe8(SP), DX		
  0x440506		48891424		MOVQ DX, 0(SP)			
  0x44050a		e881f0ffff		CALL runtime.name.name(SB)	
  0x44050f		488b442410		MOVQ 0x10(SP), AX		
  0x440514		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x44051c		4839c8			CMPQ CX, AX			
  0x44051f		0f8556010000		JNE 0x44067b			
  0x440525		488b8424e0000000	MOVQ 0xe0(SP), AX		
  0x44052d		48890424		MOVQ AX, 0(SP)			
  0x440531		48894c2410		MOVQ CX, 0x10(SP)		
  0x440536		e8055e0000		CALL runtime.memequal(SB)	
  0x44053b		0fb6442418		MOVZX 0x18(SP), AX		
  0x440540		84c0			TESTL AL, AL			
  0x440542		0f8433010000		JE 0x44067b			
  0x440548		488b8424f0000000	MOVQ 0xf0(SP), AX		
			if tname.pkgPath() != vname.pkgPath() {
  0x440550		48890424		MOVQ AX, 0(SP)			
  0x440554		e847f1ffff		CALL runtime.name.pkgPath(SB)	
  0x440559		488b442410		MOVQ 0x10(SP), AX		
  0x44055e		4889842480000000	MOVQ AX, 0x80(SP)		
  0x440566		488b4c2408		MOVQ 0x8(SP), CX		
  0x44056b		48898c2418010000	MOVQ CX, 0x118(SP)		
  0x440573		488b9424e8000000	MOVQ 0xe8(SP), DX		
  0x44057b		48891424		MOVQ DX, 0(SP)			
  0x44057f		e81cf1ffff		CALL runtime.name.pkgPath(SB)	
  0x440584		488b442410		MOVQ 0x10(SP), AX		
  0x440589		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x440591		4839c8			CMPQ CX, AX			
  0x440594		0f85c9000000		JNE 0x440663			
  0x44059a		488b842418010000	MOVQ 0x118(SP), AX		
  0x4405a2		48890424		MOVQ AX, 0(SP)			
  0x4405a6		48894c2410		MOVQ CX, 0x10(SP)		
  0x4405ab		e8905d0000		CALL runtime.memequal(SB)	
  0x4405b0		0fb6442418		MOVZX 0x18(SP), AX		
  0x4405b5		84c0			TESTL AL, AL			
  0x4405b7		0f84a6000000		JE 0x440663			
  0x4405bd		488b442460		MOVQ 0x60(SP), AX		
  0x4405c2		488b8c24f8000000	MOVQ 0xf8(SP), CX		
			tityp := resolveTypeOff(unsafe.Pointer(tm), tm.ityp)
  0x4405ca		8b4cc104		MOVL 0x4(CX)(AX*8), CX		
  0x4405ce		894c2408		MOVL CX, 0x8(SP)		
  0x4405d2		488b8c24b8000000	MOVQ 0xb8(SP), CX		
  0x4405da		48890c24		MOVQ CX, 0(SP)			
  0x4405de		e89de8ffff		CALL runtime.resolveTypeOff(SB)	
  0x4405e3		488b442410		MOVQ 0x10(SP), AX		
  0x4405e8		48898424c0000000	MOVQ AX, 0xc0(SP)		
  0x4405f0		488b4c2460		MOVQ 0x60(SP), CX		
  0x4405f5		488b942400010000	MOVQ 0x100(SP), DX		
			vityp := resolveTypeOff(unsafe.Pointer(vm), vm.ityp)
  0x4405fd		8b54ca04		MOVL 0x4(DX)(CX*8), DX		
  0x440601		89542408		MOVL DX, 0x8(SP)		
  0x440605		488b942498000000	MOVQ 0x98(SP), DX		
  0x44060d		48891424		MOVQ DX, 0(SP)			
  0x440611		e86ae8ffff		CALL runtime.resolveTypeOff(SB)	
  0x440616		488b442410		MOVQ 0x10(SP), AX		
  0x44061b		488b8c24c0000000	MOVQ 0xc0(SP), CX		
			if !typesEqual(tityp, vityp, seen) {
  0x440623		48890c24		MOVQ CX, 0(SP)			
  0x440627		4889442408		MOVQ AX, 0x8(SP)		
  0x44062c		488b842460010000	MOVQ 0x160(SP), AX		
  0x440634		4889442410		MOVQ AX, 0x10(SP)		
  0x440639		e862f8ffff		CALL runtime.typesEqual(SB)	
  0x44063e		0fb6442418		MOVZX 0x18(SP), AX		
  0x440643		84c0			TESTL AL, AL			
  0x440645		0f85c8fdffff		JNE 0x440413			
				return false
  0x44064b		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440653		488bac2440010000	MOVQ 0x140(SP), BP	
  0x44065b		4881c448010000		ADDQ $0x148, SP		
  0x440662		c3			RET			
				return false
  0x440663		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x44066b		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440673		4881c448010000		ADDQ $0x148, SP		
  0x44067a		c3			RET			
				return false
  0x44067b		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440683		488bac2440010000	MOVQ 0x140(SP), BP	
  0x44068b		4881c448010000		ADDQ $0x148, SP		
  0x440692		c3			RET			
		return true
  0x440693		c684246801000001	MOVB $0x1, 0x168(SP)	
  0x44069b		488bac2440010000	MOVQ 0x140(SP), BP	
  0x4406a3		4881c448010000		ADDQ $0x148, SP		
  0x4406aa		c3			RET			
			return false
  0x4406ab		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x4406b3		488bac2440010000	MOVQ 0x140(SP), BP	
  0x4406bb		4881c448010000		ADDQ $0x148, SP		
  0x4406c2		c3			RET			
  0x4406c3		488b842450010000	MOVQ 0x150(SP), AX	
		return typesEqual(mt.key, mv.key, seen) && typesEqual(mt.elem, mv.elem, seen)
  0x4406cb		488b4830		MOVQ 0x30(AX), CX		
  0x4406cf		488b942458010000	MOVQ 0x158(SP), DX		
  0x4406d7		488b5a30		MOVQ 0x30(DX), BX		
  0x4406db		48895c2408		MOVQ BX, 0x8(SP)		
  0x4406e0		48890c24		MOVQ CX, 0(SP)			
  0x4406e4		488b8c2460010000	MOVQ 0x160(SP), CX		
  0x4406ec		48894c2410		MOVQ CX, 0x10(SP)		
  0x4406f1		e8aaf7ffff		CALL runtime.typesEqual(SB)	
  0x4406f6		0fb6442418		MOVZX 0x18(SP), AX		
  0x4406fb		84c0			TESTL AL, AL			
  0x4406fd		7519			JNE 0x440718			
  0x4406ff		31c0			XORL AX, AX			
  0x440701		88842468010000		MOVB AL, 0x168(SP)		
  0x440708		488bac2440010000	MOVQ 0x140(SP), BP		
  0x440710		4881c448010000		ADDQ $0x148, SP			
  0x440717		c3			RET				
  0x440718		488b842450010000	MOVQ 0x150(SP), AX		
  0x440720		488b4038		MOVQ 0x38(AX), AX		
  0x440724		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x44072c		488b4938		MOVQ 0x38(CX), CX		
  0x440730		48894c2408		MOVQ CX, 0x8(SP)		
  0x440735		48890424		MOVQ AX, 0(SP)			
  0x440739		488b842460010000	MOVQ 0x160(SP), AX		
  0x440741		4889442410		MOVQ AX, 0x10(SP)		
  0x440746		e855f7ffff		CALL runtime.typesEqual(SB)	
  0x44074b		0fb6442418		MOVZX 0x18(SP), AX		
  0x440750		ebaf			JMP 0x440701			
	case kindArray:
  0x440752		3c11			CMPL $0x11, AL		
  0x440754		7468			JE 0x4407be		
	switch kind {
  0x440756		3c12			CMPL $0x12, AL		
	case kindChan:
  0x440758		0f854b060000		JNE 0x440da9		
  0x44075e		488b842450010000	MOVQ 0x150(SP), AX	
		return ct.dir == cv.dir && typesEqual(ct.elem, cv.elem, seen)
  0x440766		488b4838		MOVQ 0x38(AX), CX		
  0x44076a		488b942458010000	MOVQ 0x158(SP), DX		
  0x440772		488b5a38		MOVQ 0x38(DX), BX		
  0x440776		4839d9			CMPQ BX, CX			
  0x440779		7419			JE 0x440794			
  0x44077b		31c0			XORL AX, AX			
  0x44077d		88842468010000		MOVB AL, 0x168(SP)		
  0x440784		488bac2440010000	MOVQ 0x140(SP), BP		
  0x44078c		4881c448010000		ADDQ $0x148, SP			
  0x440793		c3			RET				
  0x440794		488b4030		MOVQ 0x30(AX), AX		
  0x440798		488b4a30		MOVQ 0x30(DX), CX		
  0x44079c		48894c2408		MOVQ CX, 0x8(SP)		
  0x4407a1		48890424		MOVQ AX, 0(SP)			
  0x4407a5		488b842460010000	MOVQ 0x160(SP), AX		
  0x4407ad		4889442410		MOVQ AX, 0x10(SP)		
  0x4407b2		e8e9f6ffff		CALL runtime.typesEqual(SB)	
  0x4407b7		0fb6442418		MOVZX 0x18(SP), AX		
  0x4407bc		ebbf			JMP 0x44077d			
  0x4407be		488b842450010000	MOVQ 0x150(SP), AX		
		return typesEqual(at.elem, av.elem, seen) && at.len == av.len
  0x4407c6		488b4830		MOVQ 0x30(AX), CX		
  0x4407ca		488b942458010000	MOVQ 0x158(SP), DX		
  0x4407d2		488b5a30		MOVQ 0x30(DX), BX		
  0x4407d6		48895c2408		MOVQ BX, 0x8(SP)		
  0x4407db		48890c24		MOVQ CX, 0(SP)			
  0x4407df		488b8c2460010000	MOVQ 0x160(SP), CX		
  0x4407e7		48894c2410		MOVQ CX, 0x10(SP)		
  0x4407ec		e8aff6ffff		CALL runtime.typesEqual(SB)	
  0x4407f1		0fb6442418		MOVZX 0x18(SP), AX		
  0x4407f6		84c0			TESTL AL, AL			
  0x4407f8		7435			JE 0x44082f			
  0x4407fa		488b842450010000	MOVQ 0x150(SP), AX		
  0x440802		488b4040		MOVQ 0x40(AX), AX		
  0x440806		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x44080e		488b4940		MOVQ 0x40(CX), CX		
  0x440812		4839c8			CMPQ CX, AX			
  0x440815		0f94c0			SETE AL				
  0x440818		88842468010000		MOVB AL, 0x168(SP)		
  0x44081f		488bac2440010000	MOVQ 0x140(SP), BP		
  0x440827		4881c448010000		ADDQ $0x148, SP			
  0x44082e		c3			RET				
  0x44082f		31c0			XORL AX, AX			
  0x440831		ebe5			JMP 0x440818			
	switch kind {
  0x440833		3c17			CMPL $0x17, AL		
  0x440835		0f87a2000000		JA 0x4408dd		
	case kindPtr:
  0x44083b		3c16			CMPL $0x16, AL		
  0x44083d		754f			JNE 0x44088e		
  0x44083f		488b842450010000	MOVQ 0x150(SP), AX	
		return typesEqual(pt.elem, pv.elem, seen)
  0x440847		488b4030		MOVQ 0x30(AX), AX		
  0x44084b		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x440853		488b4930		MOVQ 0x30(CX), CX		
  0x440857		48894c2408		MOVQ CX, 0x8(SP)		
  0x44085c		48890424		MOVQ AX, 0(SP)			
  0x440860		488b842460010000	MOVQ 0x160(SP), AX		
  0x440868		4889442410		MOVQ AX, 0x10(SP)		
  0x44086d		e82ef6ffff		CALL runtime.typesEqual(SB)	
  0x440872		0fb6442418		MOVZX 0x18(SP), AX		
  0x440877		88842468010000		MOVB AL, 0x168(SP)		
  0x44087e		488bac2440010000	MOVQ 0x140(SP), BP		
  0x440886		4881c448010000		ADDQ $0x148, SP			
  0x44088d		c3			RET				
  0x44088e		488b842450010000	MOVQ 0x150(SP), AX		
		return typesEqual(st.elem, sv.elem, seen)
  0x440896		488b4030		MOVQ 0x30(AX), AX		
  0x44089a		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x4408a2		488b4930		MOVQ 0x30(CX), CX		
  0x4408a6		48894c2408		MOVQ CX, 0x8(SP)		
  0x4408ab		48890424		MOVQ AX, 0(SP)			
  0x4408af		488b842460010000	MOVQ 0x160(SP), AX		
  0x4408b7		4889442410		MOVQ AX, 0x10(SP)		
  0x4408bc		e8dff5ffff		CALL runtime.typesEqual(SB)	
  0x4408c1		0fb6442418		MOVZX 0x18(SP), AX		
  0x4408c6		88842468010000		MOVB AL, 0x168(SP)		
  0x4408cd		488bac2440010000	MOVQ 0x140(SP), BP		
  0x4408d5		4881c448010000		ADDQ $0x148, SP			
  0x4408dc		c3			RET				
	case kindString, kindUnsafePointer:
  0x4408dd		3c18			CMPL $0x18, AL		
  0x4408df		7518			JNE 0x4408f9		
		return true
  0x4408e1		c684246801000001	MOVB $0x1, 0x168(SP)	
  0x4408e9		488bac2440010000	MOVQ 0x140(SP), BP	
  0x4408f1		4881c448010000		ADDQ $0x148, SP		
  0x4408f8		c3			RET			
	case kindStruct:
  0x4408f9		3c19			CMPL $0x19, AL		
  0x4408fb		0f8526030000		JNE 0x440c27		
  0x440901		488b842450010000	MOVQ 0x150(SP), AX	
		if len(st.fields) != len(sv.fields) {
  0x440909		488b4840		MOVQ 0x40(AX), CX	
  0x44090d		488b942458010000	MOVQ 0x158(SP), DX	
  0x440915		488b5a40		MOVQ 0x40(DX), BX	
  0x440919		4839d9			CMPQ BX, CX		
  0x44091c		0f85ed020000		JNE 0x440c0f		
		if st.pkgPath.name() != sv.pkgPath.name() {
  0x440922		488b4830		MOVQ 0x30(AX), CX		
  0x440926		48890c24		MOVQ CX, 0(SP)			
  0x44092a		e861ecffff		CALL runtime.name.name(SB)	
  0x44092f		488b442410		MOVQ 0x10(SP), AX		
  0x440934		4889842488000000	MOVQ AX, 0x88(SP)		
  0x44093c		488b4c2408		MOVQ 0x8(SP), CX		
  0x440941		48898c2418010000	MOVQ CX, 0x118(SP)		
  0x440949		488b942458010000	MOVQ 0x158(SP), DX		
  0x440951		488b5a30		MOVQ 0x30(DX), BX		
  0x440955		48891c24		MOVQ BX, 0(SP)			
  0x440959		e832ecffff		CALL runtime.name.name(SB)	
  0x44095e		488b442410		MOVQ 0x10(SP), AX		
  0x440963		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x44096b		4839c8			CMPQ CX, AX			
  0x44096e		7418			JE 0x440988			
			return false
  0x440970		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440978		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440980		4881c448010000		ADDQ $0x148, SP		
  0x440987		c3			RET			
  0x440988		488b842418010000	MOVQ 0x118(SP), AX	
		if st.pkgPath.name() != sv.pkgPath.name() {
  0x440990		48890424		MOVQ AX, 0(SP)			
  0x440994		48894c2410		MOVQ CX, 0x10(SP)		
  0x440999		e8a2590000		CALL runtime.memequal(SB)	
  0x44099e		0fb6442418		MOVZX 0x18(SP), AX		
  0x4409a3		84c0			TESTL AL, AL			
  0x4409a5		74c9			JE 0x440970			
  0x4409a7		488b842450010000	MOVQ 0x150(SP), AX		
		for i := range st.fields {
  0x4409af		488b4840		MOVQ 0x40(AX), CX	
  0x4409b3		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x4409bb		31d2			XORL DX, DX		
  0x4409bd		eb19			JMP 0x4409d8		
  0x4409bf		488b5c2470		MOVQ 0x70(SP), BX	
  0x4409c4		488d5301		LEAQ 0x1(BX), DX	
  0x4409c8		488b842450010000	MOVQ 0x150(SP), AX	
  0x4409d0		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x4409d8		4839ca			CMPQ CX, DX		
  0x4409db		0f8d16020000		JGE 0x440bf7		
			tf := &st.fields[i]
  0x4409e1		488b5840		MOVQ 0x40(AX), BX	
  0x4409e5		488b7038		MOVQ 0x38(AX), SI	
  0x4409e9		4839da			CMPQ BX, DX		
  0x4409ec		0f8386030000		JAE 0x440d78		
  0x4409f2		488d1c52		LEAQ 0(DX)(DX*2), BX	
  0x4409f6		488bbc2458010000	MOVQ 0x158(SP), DI	
			vf := &sv.fields[i]
  0x4409fe		4c8b4740		MOVQ 0x40(DI), R8	
  0x440a02		4c8b4f38		MOVQ 0x38(DI), R9	
  0x440a06		4c39c2			CMPQ R8, DX		
  0x440a09		0f8362030000		JAE 0x440d71		
  0x440a0f		4c898c24d8000000	MOVQ R9, 0xd8(SP)	
  0x440a17		4889542470		MOVQ DX, 0x70(SP)	
  0x440a1c		48899c2480000000	MOVQ BX, 0x80(SP)	
  0x440a24		4889b424d0000000	MOVQ SI, 0xd0(SP)	
			if tf.name.name() != vf.name.name() {
  0x440a2c		488b04de		MOVQ 0(SI)(BX*8), AX		
  0x440a30		48890424		MOVQ AX, 0(SP)			
  0x440a34		e857ebffff		CALL runtime.name.name(SB)	
  0x440a39		488b442408		MOVQ 0x8(SP), AX		
  0x440a3e		4889842418010000	MOVQ AX, 0x118(SP)		
  0x440a46		488b4c2410		MOVQ 0x10(SP), CX		
  0x440a4b		48894c2478		MOVQ CX, 0x78(SP)		
  0x440a50		488b942480000000	MOVQ 0x80(SP), DX		
  0x440a58		488b9c24d8000000	MOVQ 0xd8(SP), BX		
  0x440a60		488b34d3		MOVQ 0(BX)(DX*8), SI		
  0x440a64		48893424		MOVQ SI, 0(SP)			
  0x440a68		e823ebffff		CALL runtime.name.name(SB)	
  0x440a6d		488b442410		MOVQ 0x10(SP), AX		
  0x440a72		488b4c2478		MOVQ 0x78(SP), CX		
  0x440a77		4839c8			CMPQ CX, AX			
  0x440a7a		0f855f010000		JNE 0x440bdf			
  0x440a80		488b842418010000	MOVQ 0x118(SP), AX		
  0x440a88		48890424		MOVQ AX, 0(SP)			
  0x440a8c		48894c2410		MOVQ CX, 0x10(SP)		
  0x440a91		e8aa580000		CALL runtime.memequal(SB)	
  0x440a96		0fb6442418		MOVZX 0x18(SP), AX		
  0x440a9b		84c0			TESTL AL, AL			
  0x440a9d		0f843c010000		JE 0x440bdf			
  0x440aa3		488b842480000000	MOVQ 0x80(SP), AX		
  0x440aab		488b8c24d0000000	MOVQ 0xd0(SP), CX		
			if !typesEqual(tf.typ, vf.typ, seen) {
  0x440ab3		488b54c108		MOVQ 0x8(CX)(AX*8), DX		
  0x440ab8		488b9c24d8000000	MOVQ 0xd8(SP), BX		
  0x440ac0		488b74c308		MOVQ 0x8(BX)(AX*8), SI		
  0x440ac5		4889742408		MOVQ SI, 0x8(SP)		
  0x440aca		48891424		MOVQ DX, 0(SP)			
  0x440ace		488b942460010000	MOVQ 0x160(SP), DX		
  0x440ad6		4889542410		MOVQ DX, 0x10(SP)		
  0x440adb		e8c0f3ffff		CALL runtime.typesEqual(SB)	
  0x440ae0		0fb6442418		MOVZX 0x18(SP), AX		
  0x440ae5		84c0			TESTL AL, AL			
  0x440ae7		0f84da000000		JE 0x440bc7			
  0x440aed		488b842480000000	MOVQ 0x80(SP), AX		
  0x440af5		488b8c24d0000000	MOVQ 0xd0(SP), CX		
			if tf.name.tag() != vf.name.tag() {
  0x440afd		488b14c1		MOVQ 0(CX)(AX*8), DX		
  0x440b01		48891424		MOVQ DX, 0(SP)			
  0x440b05		e8e6eaffff		CALL runtime.name.tag(SB)	
  0x440b0a		488b442410		MOVQ 0x10(SP), AX		
  0x440b0f		4889442478		MOVQ AX, 0x78(SP)		
  0x440b14		488b4c2408		MOVQ 0x8(SP), CX		
  0x440b19		48898c2418010000	MOVQ CX, 0x118(SP)		
  0x440b21		488b942480000000	MOVQ 0x80(SP), DX		
  0x440b29		488b9c24d8000000	MOVQ 0xd8(SP), BX		
  0x440b31		488b34d3		MOVQ 0(BX)(DX*8), SI		
  0x440b35		48893424		MOVQ SI, 0(SP)			
  0x440b39		e8b2eaffff		CALL runtime.name.tag(SB)	
  0x440b3e		488b442410		MOVQ 0x10(SP), AX		
  0x440b43		488b4c2478		MOVQ 0x78(SP), CX		
  0x440b48		4839c8			CMPQ CX, AX			
  0x440b4b		7562			JNE 0x440baf			
  0x440b4d		488b842418010000	MOVQ 0x118(SP), AX		
  0x440b55		48890424		MOVQ AX, 0(SP)			
  0x440b59		48894c2410		MOVQ CX, 0x10(SP)		
  0x440b5e		e8dd570000		CALL runtime.memequal(SB)	
  0x440b63		0fb6442418		MOVZX 0x18(SP), AX		
  0x440b68		84c0			TESTL AL, AL			
  0x440b6a		7443			JE 0x440baf			
  0x440b6c		488b842480000000	MOVQ 0x80(SP), AX		
  0x440b74		488b8c24d0000000	MOVQ 0xd0(SP), CX		
			if tf.offsetAnon != vf.offsetAnon {
  0x440b7c		488b4cc110		MOVQ 0x10(CX)(AX*8), CX	
  0x440b81		488b9424d8000000	MOVQ 0xd8(SP), DX	
  0x440b89		488b44c210		MOVQ 0x10(DX)(AX*8), AX	
  0x440b8e		4839c1			CMPQ AX, CX		
  0x440b91		0f8428feffff		JE 0x4409bf		
				return false
  0x440b97		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440b9f		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440ba7		4881c448010000		ADDQ $0x148, SP		
  0x440bae		c3			RET			
				return false
  0x440baf		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440bb7		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440bbf		4881c448010000		ADDQ $0x148, SP		
  0x440bc6		c3			RET			
				return false
  0x440bc7		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440bcf		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440bd7		4881c448010000		ADDQ $0x148, SP		
  0x440bde		c3			RET			
				return false
  0x440bdf		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440be7		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440bef		4881c448010000		ADDQ $0x148, SP		
  0x440bf6		c3			RET			
		return true
  0x440bf7		c684246801000001	MOVB $0x1, 0x168(SP)	
  0x440bff		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440c07		4881c448010000		ADDQ $0x148, SP		
  0x440c0e		c3			RET			
			return false
  0x440c0f		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440c17		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440c1f		4881c448010000		ADDQ $0x148, SP		
  0x440c26		c3			RET			
	case kindString, kindUnsafePointer:
  0x440c27		3c1a			CMPL $0x1a, AL		
  0x440c29		0f84b2fcffff		JE 0x4408e1		
  0x440c2f		e975010000		JMP 0x440da9		
		return true
  0x440c34		c684246801000001	MOVB $0x1, 0x168(SP)	
  0x440c3c		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440c44		4881c448010000		ADDQ $0x148, SP		
  0x440c4b		c3			RET			
	if ut != nil || uv != nil {
  0x440c4c		4885c9			TESTQ CX, CX		
		if ut == nil || uv == nil {
  0x440c4f		7405			JE 0x440c56		
  0x440c51		4885c0			TESTQ AX, AX		
  0x440c54		7518			JNE 0x440c6e		
			return false
  0x440c56		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440c5e		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440c66		4881c448010000		ADDQ $0x148, SP		
  0x440c6d		c3			RET			
  0x440c6e		48898424a0000000	MOVQ AX, 0xa0(SP)	
		pkgpatht := t.nameOff(ut.pkgpath).name()
  0x440c76		8b01			MOVL 0(CX), AX				
  0x440c78		89442408		MOVL AX, 0x8(SP)			
  0x440c7c		488b842450010000	MOVQ 0x150(SP), AX			
  0x440c84		48890424		MOVQ AX, 0(SP)				
  0x440c88		e8a3e1ffff		CALL runtime.(*_type).nameOff(SB)	
  0x440c8d		488b442410		MOVQ 0x10(SP), AX			
  0x440c92		48890424		MOVQ AX, 0(SP)				
  0x440c96		e8f5e8ffff		CALL runtime.name.name(SB)		
  0x440c9b		488b442410		MOVQ 0x10(SP), AX			
  0x440ca0		4889442450		MOVQ AX, 0x50(SP)			
  0x440ca5		488b4c2408		MOVQ 0x8(SP), CX			
  0x440caa		48898c24c8000000	MOVQ CX, 0xc8(SP)			
  0x440cb2		488b9424a0000000	MOVQ 0xa0(SP), DX			
		pkgpathv := v.nameOff(uv.pkgpath).name()
  0x440cba		8b12			MOVL 0(DX), DX				
  0x440cbc		89542408		MOVL DX, 0x8(SP)			
  0x440cc0		488b942458010000	MOVQ 0x158(SP), DX			
  0x440cc8		48891424		MOVQ DX, 0(SP)				
  0x440ccc		e85fe1ffff		CALL runtime.(*_type).nameOff(SB)	
  0x440cd1		488b442410		MOVQ 0x10(SP), AX			
  0x440cd6		48890424		MOVQ AX, 0(SP)				
  0x440cda		e8b1e8ffff		CALL runtime.name.name(SB)		
  0x440cdf		488b442410		MOVQ 0x10(SP), AX			
  0x440ce4		488b4c2450		MOVQ 0x50(SP), CX			
		if pkgpatht != pkgpathv {
  0x440ce9		4839c8			CMPQ CX, AX			
  0x440cec		7523			JNE 0x440d11			
  0x440cee		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x440cf6		48890424		MOVQ AX, 0(SP)			
  0x440cfa		48894c2410		MOVQ CX, 0x10(SP)		
  0x440cff		e83c560000		CALL runtime.memequal(SB)	
  0x440d04		0fb6442418		MOVZX 0x18(SP), AX		
  0x440d09		84c0			TESTL AL, AL			
  0x440d0b		0f856ef3ffff		JNE 0x44007f			
			return false
  0x440d11		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440d19		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440d21		4881c448010000		ADDQ $0x148, SP		
  0x440d28		c3			RET			
		return false
  0x440d29		c684246801000000	MOVB $0x0, 0x168(SP)	
  0x440d31		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440d39		4881c448010000		ADDQ $0x148, SP		
  0x440d40		c3			RET			
		return true
  0x440d41		c684246801000001	MOVB $0x1, 0x168(SP)	
  0x440d49		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440d51		4881c448010000		ADDQ $0x148, SP		
  0x440d58		c3			RET			
		return true
  0x440d59		c684246801000001	MOVB $0x1, 0x168(SP)	
  0x440d61		488bac2440010000	MOVQ 0x140(SP), BP	
  0x440d69		4881c448010000		ADDQ $0x148, SP		
  0x440d70		c3			RET			
			vf := &sv.fields[i]
  0x440d71		e8caecfdff		CALL runtime.panicindex(SB)	
  0x440d76		0f0b			UD2				
			tf := &st.fields[i]
  0x440d78		e8c3ecfdff		CALL runtime.panicindex(SB)	
  0x440d7d		0f0b			UD2				
			vm := &iv.mhdr[i]
  0x440d7f		e8bcecfdff		CALL runtime.panicindex(SB)	
  0x440d84		0f0b			UD2				
			tm := &it.mhdr[i]
  0x440d86		e8b5ecfdff		CALL runtime.panicindex(SB)	
  0x440d8b		0f0b			UD2				
			if !typesEqual(tout[i], vout[i], seen) {
  0x440d8d		e8aeecfdff		CALL runtime.panicindex(SB)	
  0x440d92		0f0b			UD2				
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x440d94		e817edfdff		CALL runtime.panicslice(SB)	
  0x440d99		0f0b			UD2				
  0x440d9b		e810edfdff		CALL runtime.panicslice(SB)	
  0x440da0		0f0b			UD2				
			if !typesEqual(tin[i], vin[i], seen) {
  0x440da2		e899ecfdff		CALL runtime.panicindex(SB)	
  0x440da7		0f0b			UD2				
		println("runtime: impossible type kind", kind)
  0x440da9		e8520dfeff		CALL runtime.printlock(SB)	
  0x440dae		488d051eb80200		LEAQ 0x2b81e(IP), AX		
  0x440db5		48890424		MOVQ AX, 0(SP)			
  0x440db9		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x440dc2		e87916feff		CALL runtime.printstring(SB)	
  0x440dc7		0fb644242f		MOVZX 0x2f(SP), AX		
  0x440dcc		83e01f			ANDL $0x1f, AX			
  0x440dcf		48890424		MOVQ AX, 0(SP)			
  0x440dd3		e89813feff		CALL runtime.printuint(SB)	
  0x440dd8		e8b30ffeff		CALL runtime.printnl(SB)	
  0x440ddd		e89e0dfeff		CALL runtime.printunlock(SB)	
		throw("runtime: impossible type kind")
  0x440de2		488d05cbb40200		LEAQ 0x2b4cb(IP), AX	
  0x440de9		48890424		MOVQ AX, 0(SP)		
  0x440ded		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x440df6		e8d503feff		CALL runtime.throw(SB)	
  0x440dfb		0f0b			UD2			
func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool {
  0x440dfd		e86e370000		CALL runtime.morestack_noctxt(SB)	
  0x440e02		e999f0ffff		JMP runtime.typesEqual(SB)		

TEXT runtime.vdso_init_from_sysinfo_ehdr(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/vdso_linux.go
func vdso_init_from_sysinfo_ehdr(info *vdso_info, hdr *elfEhdr) {
  0x440e10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440e19		483b6110		CMPQ 0x10(CX), SP	
  0x440e1d		0f8643040000		JBE 0x441266		
  0x440e23		4883ec08		SUBQ $0x8, SP		
  0x440e27		48892c24		MOVQ BP, 0(SP)		
  0x440e2b		488d2c24		LEAQ 0(SP), BP		
  0x440e2f		488b4c2410		MOVQ 0x10(SP), CX	
	info.valid = false
  0x440e34		c60100			MOVB $0x0, 0(CX)	
func vdso_init_from_sysinfo_ehdr(info *vdso_info, hdr *elfEhdr) {
  0x440e37		488b542418		MOVQ 0x18(SP), DX	
  0x440e3c		4889d3			MOVQ DX, BX		
	info.load_addr = uintptr(unsafe.Pointer(hdr))
  0x440e3f		48895108		MOVQ DX, 0x8(CX)	
	pt := unsafe.Pointer(info.load_addr + uintptr(hdr.e_phoff))
  0x440e43		488b7320		MOVQ 0x20(BX), SI	
  0x440e47		4801f2			ADDQ SI, DX		
  0x440e4a		31c0			XORL AX, AX		
  0x440e4c		31f6			XORL SI, SI		
  0x440e4e		31ff			XORL DI, DI		
	for i := uint16(0); i < hdr.e_phnum; i++ {
  0x440e50		eb02			JMP 0x440e54		
  0x440e52		ffc0			INCL AX			
  0x440e54		440fb74338		MOVZX 0x38(BX), R8	
  0x440e59		664439c0		CMPW R8, AX		
  0x440e5d		734d			JAE 0x440eac		
		pt := (*elfPhdr)(add(pt, uintptr(i)*unsafe.Sizeof(elfPhdr{})))
  0x440e5f		440fb7c0		MOVZX AX, R8		
  0x440e63		4d6bc038		IMULQ $0x38, R8, R8	
	return unsafe.Pointer(uintptr(p) + x)
  0x440e67		4e8d0c02		LEAQ 0(DX)(R8*1), R9	
		switch pt.p_type {
  0x440e6b		418401			TESTB AL, 0(R9)		
  0x440e6e		468b0c02		MOVL 0(DX)(R8*1), R9	
		case _PT_LOAD:
  0x440e72		4183f901		CMPL $0x1, R9		
  0x440e76		7523			JNE 0x440e9b		
			if !found_vaddr {
  0x440e78		4084f6			TESTL SI, SI		
  0x440e7b		7407			JE 0x440e84		
  0x440e7d		be01000000		MOVL $0x1, SI		
		switch pt.p_type {
  0x440e82		ebce			JMP 0x440e52		
				info.load_offset = info.load_addr + uintptr(pt.p_offset-pt.p_vaddr)
  0x440e84		498b741008		MOVQ 0x8(R8)(DX*1), SI	
  0x440e89		4e8b440210		MOVQ 0x10(DX)(R8*1), R8	
  0x440e8e		4c29c6			SUBQ R8, SI		
  0x440e91		48037108		ADDQ 0x8(CX), SI	
  0x440e95		48897110		MOVQ SI, 0x10(CX)	
  0x440e99		ebe2			JMP 0x440e7d		
		case _PT_DYNAMIC:
  0x440e9b		4183f902		CMPL $0x2, R9		
  0x440e9f		75b1			JNE 0x440e52		
			dyn = (*[vdsoDynSize]elfDyn)(unsafe.Pointer(info.load_addr + uintptr(pt.p_offset)))
  0x440ea1		498b7c1008		MOVQ 0x8(R8)(DX*1), DI	
  0x440ea6		48037908		ADDQ 0x8(CX), DI	
		switch pt.p_type {
  0x440eaa		eba6			JMP 0x440e52		
			if !found_vaddr {
  0x440eac		4084f6			TESTL SI, SI		
	if !found_vaddr || dyn == nil {
  0x440eaf		0f8485030000		JE 0x44123a		
  0x440eb5		4885ff			TESTQ DI, DI		
  0x440eb8		0f847c030000		JE 0x44123a		
	info.symstrings = nil
  0x440ebe		8b154c2b0800		MOVL runtime.writeBarrier(SB), DX	
  0x440ec4		488d5920		LEAQ 0x20(CX), BX			
	info.symtab = nil
  0x440ec8		488d7118		LEAQ 0x18(CX), SI	
	info.versym = nil
  0x440ecc		4c8d4160		LEAQ 0x60(CX), R8	
	info.verdef = nil
  0x440ed0		4c8d4968		LEAQ 0x68(CX), R9	
	info.symstrings = nil
  0x440ed4		85d2			TESTL DX, DX		
  0x440ed6		0f8528030000		JNE 0x441204		
  0x440edc		48c7412000000000	MOVQ $0x0, 0x20(CX)	
	info.symtab = nil
  0x440ee4		48c7411800000000	MOVQ $0x0, 0x18(CX)	
	info.verdef = nil
  0x440eec		0f57c0			XORPS X0, X0		
  0x440eef		0f114160		MOVUPS X0, 0x60(CX)	
	info.symstrings = nil
  0x440ef3		31c0			XORL AX, AX		
  0x440ef5		31d2			XORL DX, DX		
  0x440ef7		4989d2			MOVQ DX, R10		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x440efa		eb09			JMP 0x440f05			
  0x440efc		49ffc4			INCQ R12			
  0x440eff		4889c2			MOVQ AX, DX			
  0x440f02		4c89e0			MOVQ R12, AX			
  0x440f05		49bbffffffffff3f0000	MOVQ $0x3fffffffffff, R11	
  0x440f0f		4c39d8			CMPQ R11, AX			
  0x440f12		0f8347030000		JAE 0x44125f			
  0x440f18		4989c4			MOVQ AX, R12			
  0x440f1b		48c1e004		SHLQ $0x4, AX			
  0x440f1f		4c8b2c07		MOVQ 0(DI)(AX*1), R13		
  0x440f23		4d85ed			TESTQ R13, R13			
  0x440f26		0f84ee000000		JE 0x44101a			
		p := info.load_offset + uintptr(dt.d_val)
  0x440f2c		488b440708		MOVQ 0x8(DI)(AX*1), AX	
  0x440f31		48034110		ADDQ 0x10(CX), AX	
		switch dt.d_tag {
  0x440f35		4983fd06		CMPQ $0x6, R13		
  0x440f39		7f69			JG 0x440fa4		
		case _DT_HASH:
  0x440f3b		4983fd04		CMPQ $0x4, R13		
  0x440f3f		7502			JNE 0x440f43		
		switch dt.d_tag {
  0x440f41		ebb9			JMP 0x440efc		
		case _DT_STRTAB:
  0x440f43		4983fd05		CMPQ $0x5, R13		
  0x440f47		7525			JNE 0x440f6e		
			info.symstrings = (*[vdsoSymStringsSize]byte)(unsafe.Pointer(p))
  0x440f49		448b2dc02a0800		MOVL runtime.writeBarrier(SB), R13	
  0x440f50		4585ed			TESTL R13, R13				
  0x440f53		7509			JNE 0x440f5e				
  0x440f55		48894120		MOVQ AX, 0x20(CX)			
  0x440f59		4889d0			MOVQ DX, AX				
		switch dt.d_tag {
  0x440f5c		eb9e			JMP 0x440efc		
  0x440f5e		4989fd			MOVQ DI, R13		
  0x440f61		4889df			MOVQ BX, DI		
			info.symstrings = (*[vdsoSymStringsSize]byte)(unsafe.Pointer(p))
  0x440f64		e837590000		CALL runtime.gcWriteBarrier(SB)	
  0x440f69		4c89ef			MOVQ R13, DI			
  0x440f6c		ebeb			JMP 0x440f59			
		switch dt.d_tag {
  0x440f6e		4983fd06		CMPQ $0x6, R13		
		case _DT_SYMTAB:
  0x440f72		7528			JNE 0x440f9c		
			info.symtab = (*[vdsoSymTabSize]elfSym)(unsafe.Pointer(p))
  0x440f74		448b2d952a0800		MOVL runtime.writeBarrier(SB), R13	
  0x440f7b		4585ed			TESTL R13, R13				
  0x440f7e		750c			JNE 0x440f8c				
  0x440f80		48894118		MOVQ AX, 0x18(CX)			
  0x440f84		4889d0			MOVQ DX, AX				
		switch dt.d_tag {
  0x440f87		e970ffffff		JMP 0x440efc		
  0x440f8c		4989fd			MOVQ DI, R13		
  0x440f8f		4889f7			MOVQ SI, DI		
			info.symtab = (*[vdsoSymTabSize]elfSym)(unsafe.Pointer(p))
  0x440f92		e809590000		CALL runtime.gcWriteBarrier(SB)	
  0x440f97		4c89ef			MOVQ R13, DI			
  0x440f9a		ebe8			JMP 0x440f84			
  0x440f9c		4889d0			MOVQ DX, AX			
		switch dt.d_tag {
  0x440f9f		e958ffffff		JMP 0x440efc		
		case _DT_GNU_HASH:
  0x440fa4		4981fdf5feff6f		CMPQ $0x6ffffef5, R13	
  0x440fab		750b			JNE 0x440fb8		
			gnuhash = (*[vdsoHashSize]uint32)(unsafe.Pointer(p))
  0x440fad		4989c2			MOVQ AX, R10		
  0x440fb0		4889d0			MOVQ DX, AX		
		switch dt.d_tag {
  0x440fb3		e944ffffff		JMP 0x440efc		
		case _DT_VERSYM:
  0x440fb8		4981fdf0ffff6f		CMPQ $0x6ffffff0, R13	
  0x440fbf		7528			JNE 0x440fe9		
			info.versym = (*[vdsoVerSymSize]uint16)(unsafe.Pointer(p))
  0x440fc1		448b2d482a0800		MOVL runtime.writeBarrier(SB), R13	
  0x440fc8		4585ed			TESTL R13, R13				
  0x440fcb		750c			JNE 0x440fd9				
  0x440fcd		48894160		MOVQ AX, 0x60(CX)			
  0x440fd1		4889d0			MOVQ DX, AX				
		switch dt.d_tag {
  0x440fd4		e923ffffff		JMP 0x440efc		
  0x440fd9		4989fd			MOVQ DI, R13		
  0x440fdc		4c89c7			MOVQ R8, DI		
			info.versym = (*[vdsoVerSymSize]uint16)(unsafe.Pointer(p))
  0x440fdf		e8bc580000		CALL runtime.gcWriteBarrier(SB)	
  0x440fe4		4c89ef			MOVQ R13, DI			
  0x440fe7		ebe8			JMP 0x440fd1			
		case _DT_VERDEF:
  0x440fe9		4981fdfcffff6f		CMPQ $0x6ffffffc, R13	
  0x440ff0		75aa			JNE 0x440f9c		
			info.verdef = (*elfVerdef)(unsafe.Pointer(p))
  0x440ff2		448b2d172a0800		MOVL runtime.writeBarrier(SB), R13	
  0x440ff9		4585ed			TESTL R13, R13				
  0x440ffc		750c			JNE 0x44100a				
  0x440ffe		48894168		MOVQ AX, 0x68(CX)			
  0x441002		4889d0			MOVQ DX, AX				
		switch dt.d_tag {
  0x441005		e9f2feffff		JMP 0x440efc		
  0x44100a		4989fd			MOVQ DI, R13		
  0x44100d		4c89cf			MOVQ R9, DI		
			info.verdef = (*elfVerdef)(unsafe.Pointer(p))
  0x441010		e88b580000		CALL runtime.gcWriteBarrier(SB)	
  0x441015		4c89ef			MOVQ R13, DI			
  0x441018		ebe8			JMP 0x441002			
	if info.symstrings == nil || info.symtab == nil || (hash == nil && gnuhash == nil) {
  0x44101a		488b5920		MOVQ 0x20(CX), BX	
  0x44101e		4885db			TESTQ BX, BX		
  0x441021		0f84d4010000		JE 0x4411fb		
  0x441027		488b5918		MOVQ 0x18(CX), BX	
  0x44102b		4885db			TESTQ BX, BX		
  0x44102e		0f84c7010000		JE 0x4411fb		
  0x441034		4885d2			TESTQ DX, DX		
  0x441037		0f84b5010000		JE 0x4411f2		
	if info.verdef == nil {
  0x44103d		488b5968		MOVQ 0x68(CX), BX	
  0x441041		4885db			TESTQ BX, BX		
  0x441044		0f8482010000		JE 0x4411cc		
	if gnuhash != nil {
  0x44104a		4d85d2			TESTQ R10, R10		
  0x44104d		0f84c6000000		JE 0x441119		
		nbucket := gnuhash[0]
  0x441053		418b12			MOVL 0(R10), DX		
		info.symOff = gnuhash[1]
  0x441056		418b5a04		MOVL 0x4(R10), BX	
  0x44105a		895958			MOVL BX, 0x58(CX)	
		bloomSize := gnuhash[2]
  0x44105d		418b5a08		MOVL 0x8(R10), BX	
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x441061		d1e3			SHLL $0x1, BX				
  0x441063		8d7304			LEAL 0x4(BX), SI			
  0x441066		49b8ffffffffffff0000	MOVQ $0xffffffffffff, R8		
  0x441070		4c39c6			CMPQ R8, SI				
  0x441073		0f87df010000		JA 0x441258				
  0x441079		4929f0			SUBQ SI, R8				
  0x44107c		48c1e602		SHLQ $0x2, SI				
  0x441080		4d89c1			MOVQ R8, R9				
  0x441083		49f7d8			NEGQ R8					
  0x441086		49c1f83f		SARQ $0x3f, R8				
  0x44108a		4c21c6			ANDQ R8, SI				
  0x44108d		498d0432		LEAQ 0(R10)(SI*1), AX			
  0x441091		4c39ca			CMPQ R9, DX				
  0x441094		0f87be010000		JA 0x441258				
  0x44109a		48895148		MOVQ DX, 0x48(CX)			
  0x44109e		4c894950		MOVQ R9, 0x50(CX)			
  0x4410a2		8b3568290800		MOVL runtime.writeBarrier(SB), SI	
  0x4410a8		488d7940		LEAQ 0x40(CX), DI			
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x4410ac		01da			ADDL BX, DX		
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x4410ae		85f6			TESTL SI, SI		
  0x4410b0		7560			JNE 0x441112		
  0x4410b2		48894140		MOVQ AX, 0x40(CX)	
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x4410b6		83c204			ADDL $0x4, DX				
  0x4410b9		48bbffffffffffff0000	MOVQ $0xffffffffffff, BX		
  0x4410c3		4839da			CMPQ BX, DX				
  0x4410c6		0f8785010000		JA 0x441251				
  0x4410cc		4829d3			SUBQ DX, BX				
  0x4410cf		48895930		MOVQ BX, 0x30(CX)			
  0x4410d3		48895938		MOVQ BX, 0x38(CX)			
  0x4410d7		8b3533290800		MOVL runtime.writeBarrier(SB), SI	
  0x4410dd		488d7928		LEAQ 0x28(CX), DI			
  0x4410e1		48f7db			NEGQ BX					
  0x4410e4		48c1e202		SHLQ $0x2, DX				
  0x4410e8		48c1fb3f		SARQ $0x3f, BX				
  0x4410ec		4821da			ANDQ BX, DX				
  0x4410ef		498d0412		LEAQ 0(R10)(DX*1), AX			
  0x4410f3		85f6			TESTL SI, SI				
  0x4410f5		7514			JNE 0x44110b				
  0x4410f7		48894128		MOVQ AX, 0x28(CX)			
		info.isGNUHash = true
  0x4410fb		c6415c01		MOVB $0x1, 0x5c(CX)	
	info.valid = true
  0x4410ff		c60101			MOVB $0x1, 0(CX)	
}
  0x441102		488b2c24		MOVQ 0(SP), BP		
  0x441106		4883c408		ADDQ $0x8, SP		
  0x44110a		c3			RET			
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x44110b		e890570000		CALL runtime.gcWriteBarrier(SB)	
  0x441110		ebe9			JMP 0x4410fb			
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x441112		e889570000		CALL runtime.gcWriteBarrier(SB)	
  0x441117		eb9d			JMP 0x4410b6			
		nbucket := hash[0]
  0x441119		8b1a			MOVL 0(DX), BX		
		nchain := hash[1]
  0x44111b		8b7204			MOVL 0x4(DX), SI	
		info.bucket = hash[2 : 2+nbucket]
  0x44111e		448d4302		LEAL 0x2(BX), R8			
  0x441122		4983f802		CMPQ $0x2, R8				
  0x441126		0f821e010000		JB 0x44124a				
  0x44112c		49b9ffffffffffff0000	MOVQ $0xffffffffffff, R9		
  0x441136		4d39c8			CMPQ R9, R8				
  0x441139		0f870b010000		JA 0x44124a				
  0x44113f		4d8d50fe		LEAQ -0x2(R8), R10			
  0x441143		4c895148		MOVQ R10, 0x48(CX)			
  0x441147		49bafdffffffffff0000	MOVQ $0xfffffffffffd, R10		
  0x441151		4c895150		MOVQ R10, 0x50(CX)			
  0x441155		448b15b4280800		MOVL runtime.writeBarrier(SB), R10	
  0x44115c		488d7940		LEAQ 0x40(CX), DI			
  0x441160		488d4208		LEAQ 0x8(DX), AX			
		info.chain = hash[2+nbucket : 2+nbucket+nchain]
  0x441164		01f3			ADDL SI, BX		
		info.bucket = hash[2 : 2+nbucket]
  0x441166		4585d2			TESTL R10, R10		
  0x441169		755a			JNE 0x4411c5		
  0x44116b		48894140		MOVQ AX, 0x40(CX)	
		info.chain = hash[2+nbucket : 2+nbucket+nchain]
  0x44116f		83c302			ADDL $0x2, BX				
  0x441172		4939d8			CMPQ BX, R8				
  0x441175		0f87c8000000		JA 0x441243				
  0x44117b		4c39cb			CMPQ R9, BX				
  0x44117e		0f87bf000000		JA 0x441243				
  0x441184		4c29c3			SUBQ R8, BX				
  0x441187		48895930		MOVQ BX, 0x30(CX)			
  0x44118b		4d29c1			SUBQ R8, R9				
  0x44118e		4c894938		MOVQ R9, 0x38(CX)			
  0x441192		8b1d78280800		MOVL runtime.writeBarrier(SB), BX	
  0x441198		488d7928		LEAQ 0x28(CX), DI			
  0x44119c		49f7d9			NEGQ R9					
  0x44119f		49c1e002		SHLQ $0x2, R8				
  0x4411a3		49c1f93f		SARQ $0x3f, R9				
  0x4411a7		4d21c8			ANDQ R9, R8				
  0x4411aa		4a8d0402		LEAQ 0(DX)(R8*1), AX			
  0x4411ae		85db			TESTL BX, BX				
  0x4411b0		7509			JNE 0x4411bb				
  0x4411b2		48894128		MOVQ AX, 0x28(CX)			
  0x4411b6		e944ffffff		JMP 0x4410ff				
  0x4411bb		e8e0560000		CALL runtime.gcWriteBarrier(SB)		
  0x4411c0		e93affffff		JMP 0x4410ff				
		info.bucket = hash[2 : 2+nbucket]
  0x4411c5		e8d6560000		CALL runtime.gcWriteBarrier(SB)	
  0x4411ca		eba3			JMP 0x44116f			
		info.versym = nil
  0x4411cc		8b1d3e280800		MOVL runtime.writeBarrier(SB), BX	
  0x4411d2		85db			TESTL BX, BX				
  0x4411d4		750d			JNE 0x4411e3				
  0x4411d6		48c7416000000000	MOVQ $0x0, 0x60(CX)			
  0x4411de		e967feffff		JMP 0x44104a				
  0x4411e3		4c89c7			MOVQ R8, DI				
  0x4411e6		31c0			XORL AX, AX				
  0x4411e8		e8b3560000		CALL runtime.gcWriteBarrier(SB)		
  0x4411ed		e958feffff		JMP 0x44104a				
	if info.symstrings == nil || info.symtab == nil || (hash == nil && gnuhash == nil) {
  0x4411f2		4d85d2			TESTQ R10, R10		
  0x4411f5		0f8542feffff		JNE 0x44103d		
		return // Failed
  0x4411fb		488b2c24		MOVQ 0(SP), BP		
  0x4411ff		4883c408		ADDQ $0x8, SP		
  0x441203		c3			RET			
  0x441204		4889f8			MOVQ DI, AX		
  0x441207		4889df			MOVQ BX, DI		
  0x44120a		4889c2			MOVQ AX, DX		
	info.symstrings = nil
  0x44120d		31c0			XORL AX, AX			
  0x44120f		e88c560000		CALL runtime.gcWriteBarrier(SB)	
  0x441214		4889f7			MOVQ SI, DI			
	info.symtab = nil
  0x441217		31c0			XORL AX, AX			
  0x441219		e882560000		CALL runtime.gcWriteBarrier(SB)	
  0x44121e		4c89c7			MOVQ R8, DI			
	info.versym = nil
  0x441221		31c0			XORL AX, AX			
  0x441223		e878560000		CALL runtime.gcWriteBarrier(SB)	
  0x441228		4c89cf			MOVQ R9, DI			
	info.verdef = nil
  0x44122b		31c0			XORL AX, AX			
  0x44122d		e86e560000		CALL runtime.gcWriteBarrier(SB)	
  0x441232		4889d7			MOVQ DX, DI			
	info.symstrings = nil
  0x441235		e9b9fcffff		JMP 0x440ef3		
		return // Failed
  0x44123a		488b2c24		MOVQ 0(SP), BP		
  0x44123e		4883c408		ADDQ $0x8, SP		
  0x441242		c3			RET			
		info.chain = hash[2+nbucket : 2+nbucket+nchain]
  0x441243		e868e8fdff		CALL runtime.panicslice(SB)	
  0x441248		0f0b			UD2				
		info.bucket = hash[2 : 2+nbucket]
  0x44124a		e861e8fdff		CALL runtime.panicslice(SB)	
  0x44124f		0f0b			UD2				
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x441251		e85ae8fdff		CALL runtime.panicslice(SB)	
  0x441256		0f0b			UD2				
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x441258		e853e8fdff		CALL runtime.panicslice(SB)	
  0x44125d		0f0b			UD2				
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x44125f		e8dce7fdff		CALL runtime.panicindex(SB)	
  0x441264		0f0b			UD2				
func vdso_init_from_sysinfo_ehdr(info *vdso_info, hdr *elfEhdr) {
  0x441266		e805330000		CALL runtime.morestack_noctxt(SB)		
  0x44126b		e9a0fbffff		JMP runtime.vdso_init_from_sysinfo_ehdr(SB)	

TEXT runtime.vdso_find_version(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/vdso_linux.go
func vdso_find_version(info *vdso_info, ver *version_key) int32 {
  0x441270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441279		483b6110		CMPQ 0x10(CX), SP	
  0x44127d		0f860c010000		JBE 0x44138f		
  0x441283		4883ec30		SUBQ $0x30, SP		
  0x441287		48896c2428		MOVQ BP, 0x28(SP)	
  0x44128c		488d6c2428		LEAQ 0x28(SP), BP	
  0x441291		488b442438		MOVQ 0x38(SP), AX	
	if !info.valid {
  0x441296		0fb608			MOVZX 0(AX), CX		
  0x441299		84c9			TESTL CL, CL		
  0x44129b		0f84dc000000		JE 0x44137d		
	def := info.verdef
  0x4412a1		488b4868		MOVQ 0x68(AX), CX	
	for {
  0x4412a5		eb03			JMP 0x4412aa		
	return unsafe.Pointer(uintptr(p) + x)
  0x4412a7		4801d1			ADDQ DX, CX		
		if def.vd_flags&_VER_FLG_BASE == 0 {
  0x4412aa		0fb75102		MOVZX 0x2(CX), DX	
  0x4412ae		66f7c20100		TESTW $0x1, DX		
  0x4412b3		0f85ba000000		JNE 0x441373		
			aux := (*elfVerdaux)(add(unsafe.Pointer(def), uintptr(def.vd_aux)))
  0x4412b9		8b510c			MOVL 0xc(CX), DX	
			if def.vd_hash == ver.ver_hash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x4412bc		8b5908			MOVL 0x8(CX), BX	
  0x4412bf		488b742440		MOVQ 0x40(SP), SI	
  0x4412c4		8b7e10			MOVL 0x10(SI), DI	
	return unsafe.Pointer(uintptr(p) + x)
  0x4412c7		4c8d0411		LEAQ 0(CX)(DX*1), R8	
			if def.vd_hash == ver.ver_hash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x4412cb		39fb			CMPL DI, BX		
  0x4412cd		7419			JE 0x4412e8		
		if def.vd_next == 0 {
  0x4412cf		8b5110			MOVL 0x10(CX), DX	
  0x4412d2		85d2			TESTL DX, DX		
  0x4412d4		75d1			JNE 0x4412a7		
	return -1 // cannot match any version
  0x4412d6		c7442448ffffffff	MOVL $-0x1, 0x48(SP)	
  0x4412de		488b6c2428		MOVQ 0x28(SP), BP	
  0x4412e3		4883c430		ADDQ $0x30, SP		
  0x4412e7		c3			RET			
  0x4412e8		48894c2420		MOVQ CX, 0x20(SP)	
			if def.vd_hash == ver.ver_hash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x4412ed		488b5820		MOVQ 0x20(AX), BX		
  0x4412f1		8403			TESTB AL, 0(BX)			
  0x4412f3		418400			TESTB AL, 0(R8)			
  0x4412f6		8b1411			MOVL 0(CX)(DX*1), DX		
  0x4412f9		4801da			ADDQ BX, DX			
  0x4412fc		48891424		MOVQ DX, 0(SP)			
  0x441300		e8eb63ffff		CALL runtime.gostringnocopy(SB)	
  0x441305		488b442440		MOVQ 0x40(SP), AX		
  0x44130a		488b4808		MOVQ 0x8(AX), CX		
  0x44130e		488b10			MOVQ 0(AX), DX			
  0x441311		488b5c2410		MOVQ 0x10(SP), BX		
  0x441316		4839d9			CMPQ BX, CX			
  0x441319		7411			JE 0x44132c			
  0x44131b		488b442438		MOVQ 0x38(SP), AX		
  0x441320		488b4c2420		MOVQ 0x20(SP), CX		
  0x441325		488b742440		MOVQ 0x40(SP), SI		
  0x44132a		eba3			JMP 0x4412cf			
  0x44132c		48891424		MOVQ DX, 0(SP)			
  0x441330		48894c2410		MOVQ CX, 0x10(SP)		
  0x441335		e806500000		CALL runtime.memequal(SB)	
  0x44133a		0fb6442418		MOVZX 0x18(SP), AX		
  0x44133f		84c0			TESTL AL, AL			
  0x441341		7514			JNE 0x441357			
  0x441343		488b442438		MOVQ 0x38(SP), AX		
  0x441348		488b4c2420		MOVQ 0x20(SP), CX		
  0x44134d		488b742440		MOVQ 0x40(SP), SI		
  0x441352		e978ffffff		JMP 0x4412cf			
  0x441357		488b442420		MOVQ 0x20(SP), AX		
				return int32(def.vd_ndx & 0x7fff)
  0x44135c		0fb74004		MOVZX 0x4(AX), AX	
  0x441360		25ff7f0000		ANDL $0x7fff, AX	
  0x441365		89442448		MOVL AX, 0x48(SP)	
  0x441369		488b6c2428		MOVQ 0x28(SP), BP	
  0x44136e		4883c430		ADDQ $0x30, SP		
  0x441372		c3			RET			
  0x441373		488b742440		MOVQ 0x40(SP), SI	
		if def.vd_flags&_VER_FLG_BASE == 0 {
  0x441378		e952ffffff		JMP 0x4412cf		
		return 0
  0x44137d		c744244800000000	MOVL $0x0, 0x48(SP)	
  0x441385		488b6c2428		MOVQ 0x28(SP), BP	
  0x44138a		4883c430		ADDQ $0x30, SP		
  0x44138e		c3			RET			
func vdso_find_version(info *vdso_info, ver *version_key) int32 {
  0x44138f		e8dc310000		CALL runtime.morestack_noctxt(SB)	
  0x441394		e9d7feffff		JMP runtime.vdso_find_version(SB)	

TEXT runtime.vdso_parse_symbols(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/vdso_linux.go
func vdso_parse_symbols(info *vdso_info, version int32) {
  0x4413a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4413a9		488d4424e0		LEAQ -0x20(SP), AX	
  0x4413ae		483b4110		CMPQ 0x10(CX), AX	
  0x4413b2		0f865a030000		JBE 0x441712		
  0x4413b8		4881eca0000000		SUBQ $0xa0, SP		
  0x4413bf		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x4413c7		488dac2498000000	LEAQ 0x98(SP), BP	
  0x4413cf		488b8c24a8000000	MOVQ 0xa8(SP), CX	
	if !info.valid {
  0x4413d7		0fb619			MOVZX 0(CX), BX		
  0x4413da		84db			TESTL BL, BL		
  0x4413dc		0f84fd020000		JE 0x4416df		
	apply := func(symIndex uint32, k symbol_key) bool {
  0x4413e2		488d1db7290000		LEAQ runtime.vdso_parse_symbols.func1(SB), BX	
  0x4413e9		48899c2480000000	MOVQ BX, 0x80(SP)				
  0x4413f1		48898c2488000000	MOVQ CX, 0x88(SP)				
  0x4413f9		8b9c24b0000000		MOVL 0xb0(SP), BX				
  0x441400		899c2490000000		MOVL BX, 0x90(SP)				
	if !info.isGNUHash {
  0x441407		0fb6595c		MOVZX 0x5c(CX), BX	
  0x44140b		84db			TESTL BL, BL		
  0x44140d		0f848f010000		JE 0x4415a2		
	for _, k := range sym_keys {
  0x441413		488b1dae470600		MOVQ runtime.sym_keys+8(SB), BX	
  0x44141a		48895c2458		MOVQ BX, 0x58(SP)		
  0x44141f		488b359a470600		MOVQ runtime.sym_keys(SB), SI	
  0x441426		31c0			XORL AX, AX			
  0x441428		eb08			JMP 0x441432			
  0x44142a		4883c620		ADDQ $0x20, SI			
  0x44142e		498d4601		LEAQ 0x1(R14), AX		
  0x441432		4839d8			CMPQ BX, AX			
  0x441435		0f8d57010000		JGE 0x441592			
  0x44143b		488b7e08		MOVQ 0x8(SI), DI		
  0x44143f		4c8b06			MOVQ 0(SI), R8			
  0x441442		4c8b4e18		MOVQ 0x18(SI), R9		
  0x441446		448b5614		MOVL 0x14(SI), R10		
  0x44144a		448b5e10		MOVL 0x10(SI), R11		
		symIndex := info.bucket[k.gnu_hash%uint32(len(info.bucket))]
  0x44144e		4c8b6148		MOVQ 0x48(CX), R12	
  0x441452		4c8b6940		MOVQ 0x40(CX), R13	
  0x441456		4585e4			TESTL R12, R12		
  0x441459		0f849e020000		JE 0x4416fd		
  0x44145f		4889c2			MOVQ AX, DX		
  0x441462		4489d0			MOVL R10, AX		
  0x441465		4989d6			MOVQ DX, R14		
  0x441468		31d2			XORL DX, DX		
  0x44146a		41f7f4			DIVL R12		
  0x44146d		4189d7			MOVL DX, R15		
  0x441470		4d39e7			CMPQ R12, R15		
  0x441473		0f837d020000		JAE 0x4416f6		
  0x441479		478b64bd00		MOVL 0(R13)(R15*4), R12	
		if symIndex < info.symOff {
  0x44147e		448b6958		MOVL 0x58(CX), R13	
  0x441482		4539ec			CMPL R13, R12		
  0x441485		72a3			JB 0x44142a		
  0x441487		48897c2450		MOVQ DI, 0x50(SP)	
  0x44148c		4c89442478		MOVQ R8, 0x78(SP)	
  0x441491		4c89742448		MOVQ R14, 0x48(SP)	
  0x441496		4c894c2470		MOVQ R9, 0x70(SP)	
  0x44149b		4489542444		MOVL R10, 0x44(SP)	
  0x4414a0		44895c2440		MOVL R11, 0x40(SP)	
  0x4414a5		4889742468		MOVQ SI, 0x68(SP)	
			hash := info.chain[symIndex-info.symOff]
  0x4414aa		eb0a			JMP 0x4414b6		
		for ; ; symIndex++ {
  0x4414ac		448d6201		LEAL 0x1(DX), R12	
  0x4414b0		4889c3			MOVQ AX, BX		
  0x4414b3		4589ea			MOVL R13, R10		
			hash := info.chain[symIndex-info.symOff]
  0x4414b6		4c8b6930		MOVQ 0x30(CX), R13	
  0x4414ba		4c8b7928		MOVQ 0x28(CX), R15	
  0x4414be		4889d8			MOVQ BX, AX		
  0x4414c1		8b5958			MOVL 0x58(CX), BX	
  0x4414c4		4489e2			MOVL R12, DX		
  0x4414c7		4129dc			SUBL BX, R12		
  0x4414ca		4d39ec			CMPQ R13, R12		
  0x4414cd		0f831c020000		JAE 0x4416ef		
  0x4414d3		438b1ca7		MOVL 0(R15)(R12*4), BX	
  0x4414d7		4189dc			MOVL BX, R12		
			if hash|1 == k.gnu_hash|1 {
  0x4414da		83cb01			ORL $0x1, BX		
  0x4414dd		4589d5			MOVL R10, R13		
  0x4414e0		4183ca01		ORL $0x1, R10		
  0x4414e4		4439d3			CMPL R10, BX		
  0x4414e7		740f			JE 0x4414f8		
			if hash&1 != 0 {
  0x4414e9		410fbae400		BTL $0x0, R12		
  0x4414ee		73bc			JAE 0x4414ac		
  0x4414f0		4889c3			MOVQ AX, BX		
	for _, k := range sym_keys {
  0x4414f3		e932ffffff		JMP 0x44142a		
  0x4414f8		448964243c		MOVL R12, 0x3c(SP)	
  0x4414fd		89542438		MOVL DX, 0x38(SP)	
				if apply(symIndex, k) {
  0x441501		891424			MOVL DX, 0(SP)		
  0x441504		4c89442408		MOVQ R8, 0x8(SP)	
  0x441509		48897c2410		MOVQ DI, 0x10(SP)	
  0x44150e		44895c2418		MOVL R11, 0x18(SP)	
  0x441513		44896c241c		MOVL R13, 0x1c(SP)	
  0x441518		4c894c2420		MOVQ R9, 0x20(SP)	
  0x44151d		488b842480000000	MOVQ 0x80(SP), AX	
  0x441525		488d942480000000	LEAQ 0x80(SP), DX	
  0x44152d		ffd0			CALL AX			
  0x44152f		0fb6442428		MOVZX 0x28(SP), AX	
  0x441534		84c0			TESTL AL, AL		
  0x441536		753e			JNE 0x441576		
  0x441538		488b442458		MOVQ 0x58(SP), AX	
  0x44153d		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x441545		8b542438		MOVL 0x38(SP), DX	
  0x441549		488b742468		MOVQ 0x68(SP), SI	
  0x44154e		488b7c2450		MOVQ 0x50(SP), DI	
  0x441553		4c8b442478		MOVQ 0x78(SP), R8	
  0x441558		4c8b4c2470		MOVQ 0x70(SP), R9	
  0x44155d		448b5c2440		MOVL 0x40(SP), R11	
  0x441562		448b64243c		MOVL 0x3c(SP), R12	
  0x441567		448b6c2444		MOVL 0x44(SP), R13	
  0x44156c		4c8b742448		MOVQ 0x48(SP), R14	
			if hash&1 != 0 {
  0x441571		e973ffffff		JMP 0x4414e9		
  0x441576		488b442458		MOVQ 0x58(SP), AX	
  0x44157b		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x441583		488b742468		MOVQ 0x68(SP), SI	
  0x441588		4c8b742448		MOVQ 0x48(SP), R14	
					break
  0x44158d		e95effffff		JMP 0x4414f0		
  0x441592		488bac2498000000	MOVQ 0x98(SP), BP	
  0x44159a		4881c4a0000000		ADDQ $0xa0, SP		
  0x4415a1		c3			RET			
		for _, k := range sym_keys {
  0x4415a2		488b1d1f460600		MOVQ runtime.sym_keys+8(SB), BX	
  0x4415a9		48895c2458		MOVQ BX, 0x58(SP)		
  0x4415ae		488b350b460600		MOVQ runtime.sym_keys(SB), SI	
  0x4415b5		31c0			XORL AX, AX			
  0x4415b7		e9ad000000		JMP 0x441669			
			for chain := info.bucket[k.sym_hash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x4415bc		448b24be		MOVL 0(SI)(DI*4), R12	
  0x4415c0		488b5c2458		MOVQ 0x58(SP), BX	
  0x4415c5		488b742460		MOVQ 0x60(SP), SI	
  0x4415ca		8b7c2444		MOVL 0x44(SP), DI	
  0x4415ce		4c8b442470		MOVQ 0x70(SP), R8	
  0x4415d3		448b4c2440		MOVL 0x40(SP), R9	
  0x4415d8		4c8b542478		MOVQ 0x78(SP), R10	
  0x4415dd		4c8b5c2448		MOVQ 0x48(SP), R11	
  0x4415e2		4c8b742450		MOVQ 0x50(SP), R14	
  0x4415e7		4585e4			TESTL R12, R12		
  0x4415ea		745e			JE 0x44164a		
  0x4415ec		4489642434		MOVL R12, 0x34(SP)	
				if apply(chain, k) {
  0x4415f1		44892424		MOVL R12, 0(SP)		
  0x4415f5		4c89542408		MOVQ R10, 0x8(SP)	
  0x4415fa		4c895c2410		MOVQ R11, 0x10(SP)	
  0x4415ff		44894c2418		MOVL R9, 0x18(SP)	
  0x441604		897c241c		MOVL DI, 0x1c(SP)	
  0x441608		4c89442420		MOVQ R8, 0x20(SP)	
  0x44160d		488b842480000000	MOVQ 0x80(SP), AX	
  0x441615		488d942480000000	LEAQ 0x80(SP), DX	
  0x44161d		ffd0			CALL AX			
  0x44161f		0fb6442428		MOVZX 0x28(SP), AX	
  0x441624		84c0			TESTL AL, AL		
  0x441626		7522			JNE 0x44164a		
  0x441628		488b8c24a8000000	MOVQ 0xa8(SP), CX	
			for chain := info.bucket[k.sym_hash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x441630		488b5930		MOVQ 0x30(CX), BX	
  0x441634		488b7128		MOVQ 0x28(CX), SI	
  0x441638		8b7c2434		MOVL 0x34(SP), DI	
  0x44163c		4839df			CMPQ BX, DI		
  0x44163f		0f8277ffffff		JB 0x4415bc		
  0x441645		e9ba000000		JMP 0x441704		
  0x44164a		488b7c2460		MOVQ 0x60(SP), DI	
		for _, k := range sym_keys {
  0x44164f		488d7720		LEAQ 0x20(DI), SI	
  0x441653		488b7c2450		MOVQ 0x50(SP), DI	
  0x441658		488d4701		LEAQ 0x1(DI), AX	
  0x44165c		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x441664		488b5c2458		MOVQ 0x58(SP), BX	
  0x441669		4839d8			CMPQ BX, AX		
  0x44166c		7d61			JGE 0x4416cf		
  0x44166e		8b7e14			MOVL 0x14(SI), DI	
  0x441671		4c8b4618		MOVQ 0x18(SI), R8	
  0x441675		448b4e10		MOVL 0x10(SI), R9	
  0x441679		4c8b16			MOVQ 0(SI), R10		
  0x44167c		4c8b5e08		MOVQ 0x8(SI), R11	
			for chain := info.bucket[k.sym_hash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x441680		4c8b6148		MOVQ 0x48(CX), R12	
  0x441684		4c8b6940		MOVQ 0x40(CX), R13	
  0x441688		4585e4			TESTL R12, R12		
  0x44168b		747e			JE 0x44170b		
  0x44168d		4889c2			MOVQ AX, DX		
  0x441690		4489c8			MOVL R9, AX		
  0x441693		4989d6			MOVQ DX, R14		
  0x441696		31d2			XORL DX, DX		
  0x441698		41f7f4			DIVL R12		
  0x44169b		4189d7			MOVL DX, R15		
  0x44169e		4d39e7			CMPQ R12, R15		
  0x4416a1		7361			JAE 0x441704		
  0x4416a3		4c89742450		MOVQ R14, 0x50(SP)	
  0x4416a8		897c2444		MOVL DI, 0x44(SP)	
  0x4416ac		4c89442470		MOVQ R8, 0x70(SP)	
  0x4416b1		44894c2440		MOVL R9, 0x40(SP)	
  0x4416b6		4c89542478		MOVQ R10, 0x78(SP)	
  0x4416bb		4c895c2448		MOVQ R11, 0x48(SP)	
  0x4416c0		4889742460		MOVQ SI, 0x60(SP)	
  0x4416c5		478b64bd00		MOVL 0(R13)(R15*4), R12	
  0x4416ca		e918ffffff		JMP 0x4415e7		
		return
  0x4416cf		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4416d7		4881c4a0000000		ADDQ $0xa0, SP		
  0x4416de		c3			RET			
		return
  0x4416df		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4416e7		4881c4a0000000		ADDQ $0xa0, SP		
  0x4416ee		c3			RET			
			hash := info.chain[symIndex-info.symOff]
  0x4416ef		e84ce3fdff		CALL runtime.panicindex(SB)	
  0x4416f4		0f0b			UD2				
		symIndex := info.bucket[k.gnu_hash%uint32(len(info.bucket))]
  0x4416f6		e845e3fdff		CALL runtime.panicindex(SB)	
  0x4416fb		0f0b			UD2				
  0x4416fd		e81ee4fdff		CALL runtime.panicdivide(SB)	
  0x441702		0f0b			UD2				
			for chain := info.bucket[k.sym_hash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x441704		e837e3fdff		CALL runtime.panicindex(SB)	
  0x441709		0f0b			UD2				
  0x44170b		e810e4fdff		CALL runtime.panicdivide(SB)	
  0x441710		0f0b			UD2				
func vdso_parse_symbols(info *vdso_info, version int32) {
  0x441712		e8592e0000		CALL runtime.morestack_noctxt(SB)	
  0x441717		e984fcffff		JMP runtime.vdso_parse_symbols(SB)	

TEXT runtime.archauxv(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/vdso_linux.go
func archauxv(tag, val uintptr) {
  0x441720		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441729		488d4424f0		LEAQ -0x10(SP), AX	
  0x44172e		483b4110		CMPQ 0x10(CX), AX	
  0x441732		0f86b4000000		JBE 0x4417ec		
  0x441738		4881ec90000000		SUBQ $0x90, SP		
  0x44173f		4889ac2488000000	MOVQ BP, 0x88(SP)	
  0x441747		488dac2488000000	LEAQ 0x88(SP), BP	
  0x44174f		488b842498000000	MOVQ 0x98(SP), AX	
	case _AT_SYSINFO_EHDR:
  0x441757		4883f821		CMPQ $0x21, AX		
  0x44175b		756f			JNE 0x4417cc		
  0x44175d		488b8424a0000000	MOVQ 0xa0(SP), AX	
		if val == 0 {
  0x441765		4885c0			TESTQ AX, AX		
  0x441768		7472			JE 0x4417dc		
		var info vdso_info
  0x44176a		488d7c2418		LEAQ 0x18(SP), DI	
  0x44176f		0f57c0			XORPS X0, X0		
  0x441772		488d7ff0		LEAQ -0x10(DI), DI	
  0x441776		48896c24f0		MOVQ BP, -0x10(SP)	
  0x44177b		488d6c24f0		LEAQ -0x10(SP), BP	
  0x441780		e828530000		CALL 0x446aad		
  0x441785		488b6d00		MOVQ 0(BP), BP		
		vdso_init_from_sysinfo_ehdr(info1, (*elfEhdr)(unsafe.Pointer(val)))
  0x441789		488d4c2418		LEAQ 0x18(SP), CX				
  0x44178e		48890c24		MOVQ CX, 0(SP)					
  0x441792		4889442408		MOVQ AX, 0x8(SP)				
  0x441797		e874f6ffff		CALL runtime.vdso_init_from_sysinfo_ehdr(SB)	
		vdso_parse_symbols(info1, vdso_find_version(info1, &linux26))
  0x44179c		488d442418		LEAQ 0x18(SP), AX			
  0x4417a1		48890424		MOVQ AX, 0(SP)				
  0x4417a5		488d0db4430600		LEAQ runtime.linux26(SB), CX		
  0x4417ac		48894c2408		MOVQ CX, 0x8(SP)			
  0x4417b1		e8bafaffff		CALL runtime.vdso_find_version(SB)	
  0x4417b6		8b442410		MOVL 0x10(SP), AX			
  0x4417ba		488d4c2418		LEAQ 0x18(SP), CX			
  0x4417bf		48890c24		MOVQ CX, 0(SP)				
  0x4417c3		89442408		MOVL AX, 0x8(SP)			
  0x4417c7		e8d4fbffff		CALL runtime.vdso_parse_symbols(SB)	
  0x4417cc		488bac2488000000	MOVQ 0x88(SP), BP			
  0x4417d4		4881c490000000		ADDQ $0x90, SP				
  0x4417db		c3			RET					
			return
  0x4417dc		488bac2488000000	MOVQ 0x88(SP), BP	
  0x4417e4		4881c490000000		ADDQ $0x90, SP		
  0x4417eb		c3			RET			
func archauxv(tag, val uintptr) {
  0x4417ec		e87f2d0000		CALL runtime.morestack_noctxt(SB)	
  0x4417f1		e92affffff		JMP runtime.archauxv(SB)		

TEXT runtime.writeErr(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/write_err.go
func writeErr(b []byte) {
  0x441800		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441809		483b6110		CMPQ 0x10(CX), SP	
  0x44180d		7644			JBE 0x441853		
  0x44180f		4883ec28		SUBQ $0x28, SP		
  0x441813		48896c2420		MOVQ BP, 0x20(SP)	
  0x441818		488d6c2420		LEAQ 0x20(SP), BP	
  0x44181d		488b442438		MOVQ 0x38(SP), AX	
	write(2, unsafe.Pointer(&b[0]), int32(len(b)))
  0x441822		4885c0			TESTQ AX, AX		
  0x441825		7625			JBE 0x44184c		
  0x441827		488b4c2430		MOVQ 0x30(SP), CX	
  0x44182c		48894c2408		MOVQ CX, 0x8(SP)	
  0x441831		48c7042402000000	MOVQ $0x2, 0(SP)	
  0x441839		89442410		MOVL AX, 0x10(SP)	
  0x44183d		e80e600000		CALL runtime.write(SB)	
}
  0x441842		488b6c2420		MOVQ 0x20(SP), BP	
  0x441847		4883c428		ADDQ $0x28, SP		
  0x44184b		c3			RET			
	write(2, unsafe.Pointer(&b[0]), int32(len(b)))
  0x44184c		e8efe1fdff		CALL runtime.panicindex(SB)	
  0x441851		0f0b			UD2				
func writeErr(b []byte) {
  0x441853		e8182d0000		CALL runtime.morestack_noctxt(SB)	
  0x441858		eba6			JMP runtime.writeErr(SB)		

TEXT runtime.mmap.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgo_mmap.go
		systemstack(func() {
  0x441860		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441869		483b6110		CMPQ 0x10(CX), SP	
  0x44186d		7662			JBE 0x4418d1		
  0x44186f		4883ec38		SUBQ $0x38, SP		
  0x441873		48896c2430		MOVQ BP, 0x30(SP)	
  0x441878		488d6c2430		LEAQ 0x30(SP), BP	
  0x44187d		488b4208		MOVQ 0x8(DX), AX	
  0x441881		488b4a10		MOVQ 0x10(DX), CX	
  0x441885		8b5a18			MOVL 0x18(DX), BX	
  0x441888		8b721c			MOVL 0x1c(DX), SI	
  0x44188b		8b7a20			MOVL 0x20(DX), DI	
  0x44188e		448b4224		MOVL 0x24(DX), R8	
  0x441892		488b5228		MOVQ 0x28(DX), DX	
  0x441896		4889542428		MOVQ DX, 0x28(SP)	
			ret = callCgoMmap(addr, n, prot, flags, fd, off)
  0x44189b		48890424		MOVQ AX, 0(SP)			
  0x44189f		48894c2408		MOVQ CX, 0x8(SP)		
  0x4418a4		895c2410		MOVL BX, 0x10(SP)		
  0x4418a8		89742414		MOVL SI, 0x14(SP)		
  0x4418ac		897c2418		MOVL DI, 0x18(SP)		
  0x4418b0		448944241c		MOVL R8, 0x1c(SP)		
  0x4418b5		e866640000		CALL runtime.callCgoMmap(SB)	
  0x4418ba		488b442420		MOVQ 0x20(SP), AX		
  0x4418bf		488b4c2428		MOVQ 0x28(SP), CX		
  0x4418c4		488901			MOVQ AX, 0(CX)			
		})
  0x4418c7		488b6c2430		MOVQ 0x30(SP), BP	
  0x4418cc		4883c438		ADDQ $0x38, SP		
  0x4418d0		c3			RET			
		systemstack(func() {
  0x4418d1		e8fa2b0000		CALL runtime.morestack(SB)	
  0x4418d6		eb88			JMP runtime.mmap.func1(SB)	

TEXT runtime.munmap.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgo_mmap.go
		systemstack(func() { callCgoMunmap(addr, n) })
  0x4418e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x4418e9		483b6110		CMPQ 0x10(CX), SP		
  0x4418ed		762e			JBE 0x44191d			
  0x4418ef		4883ec18		SUBQ $0x18, SP			
  0x4418f3		48896c2410		MOVQ BP, 0x10(SP)		
  0x4418f8		488d6c2410		LEAQ 0x10(SP), BP		
  0x4418fd		488b4208		MOVQ 0x8(DX), AX		
  0x441901		488b4a10		MOVQ 0x10(DX), CX		
  0x441905		48890424		MOVQ AX, 0(SP)			
  0x441909		48894c2408		MOVQ CX, 0x8(SP)		
  0x44190e		e89d640000		CALL runtime.callCgoMunmap(SB)	
  0x441913		488b6c2410		MOVQ 0x10(SP), BP		
  0x441918		4883c418		ADDQ $0x18, SP			
  0x44191c		c3			RET				
  0x44191d		e8ae2b0000		CALL runtime.morestack(SB)	
  0x441922		ebbc			JMP runtime.munmap.func1(SB)	

TEXT runtime.rt_sigaction.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgo_sigaction.go
			systemstack(func() {
  0x441930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441939		483b6110		CMPQ 0x10(CX), SP	
  0x44193d		764e			JBE 0x44198d		
  0x44193f		4883ec30		SUBQ $0x30, SP		
  0x441943		48896c2428		MOVQ BP, 0x28(SP)	
  0x441948		488d6c2428		LEAQ 0x28(SP), BP	
  0x44194d		488b4208		MOVQ 0x8(DX), AX	
  0x441951		488b4a10		MOVQ 0x10(DX), CX	
  0x441955		488b5a18		MOVQ 0x18(DX), BX	
  0x441959		488b5220		MOVQ 0x20(DX), DX	
  0x44195d		4889542420		MOVQ DX, 0x20(SP)	
				ret = callCgoSigaction(sig, new, old)
  0x441962		488b00			MOVQ 0(AX), AX				
  0x441965		48890424		MOVQ AX, 0(SP)				
  0x441969		48894c2408		MOVQ CX, 0x8(SP)			
  0x44196e		48895c2410		MOVQ BX, 0x10(SP)			
  0x441973		e8a8610000		CALL runtime.callCgoSigaction(SB)	
  0x441978		8b442418		MOVL 0x18(SP), AX			
  0x44197c		488b4c2420		MOVQ 0x20(SP), CX			
  0x441981		8901			MOVL AX, 0(CX)				
			})
  0x441983		488b6c2428		MOVQ 0x28(SP), BP	
  0x441988		4883c430		ADDQ $0x30, SP		
  0x44198c		c3			RET			
			systemstack(func() {
  0x44198d		e83e2b0000		CALL runtime.morestack(SB)		
  0x441992		eb9c			JMP runtime.rt_sigaction.func1(SB)	

TEXT runtime.cgoCheckWriteBarrier.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
	systemstack(func() {
  0x4419a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4419a9		483b6110		CMPQ 0x10(CX), SP	
  0x4419ad		0f8698000000		JBE 0x441a4b		
  0x4419b3		4883ec28		SUBQ $0x28, SP		
  0x4419b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4419bc		488d6c2420		LEAQ 0x20(SP), BP	
  0x4419c1		488b4208		MOVQ 0x8(DX), AX	
  0x4419c5		4889442410		MOVQ AX, 0x10(SP)	
  0x4419ca		488b4a10		MOVQ 0x10(DX), CX	
		println("write of Go pointer", hex(src), "to non-Go memory", hex(uintptr(unsafe.Pointer(dst))))
  0x4419ce		48894c2418		MOVQ CX, 0x18(SP)		
  0x4419d3		e82801feff		CALL runtime.printlock(SB)	
  0x4419d8		488d0542980200		LEAQ 0x29842(IP), AX		
  0x4419df		48890424		MOVQ AX, 0(SP)			
  0x4419e3		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x4419ec		e84f0afeff		CALL runtime.printstring(SB)	
  0x4419f1		488b442410		MOVQ 0x10(SP), AX		
  0x4419f6		48890424		MOVQ AX, 0(SP)			
  0x4419fa		e8f108feff		CALL runtime.printhex(SB)	
  0x4419ff		488d0557930200		LEAQ 0x29357(IP), AX		
  0x441a06		48890424		MOVQ AX, 0(SP)			
  0x441a0a		48c744240812000000	MOVQ $0x12, 0x8(SP)		
  0x441a13		e8280afeff		CALL runtime.printstring(SB)	
  0x441a18		488b442418		MOVQ 0x18(SP), AX		
  0x441a1d		48890424		MOVQ AX, 0(SP)			
  0x441a21		e8ca08feff		CALL runtime.printhex(SB)	
  0x441a26		e86503feff		CALL runtime.printnl(SB)	
  0x441a2b		e85001feff		CALL runtime.printunlock(SB)	
		throw(cgoWriteBarrierFail)
  0x441a30		488d05a7b30200		LEAQ 0x2b3a7(IP), AX	
  0x441a37		48890424		MOVQ AX, 0(SP)		
  0x441a3b		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x441a44		e887f7fdff		CALL runtime.throw(SB)	
  0x441a49		0f0b			UD2			
	systemstack(func() {
  0x441a4b		e8802a0000		CALL runtime.morestack(SB)			
  0x441a50		e94bffffff		JMP runtime.cgoCheckWriteBarrier.func1(SB)	

TEXT runtime.cgoCheckTypedBlock.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
		systemstack(func() {
  0x441a60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441a69		483b6110		CMPQ 0x10(CX), SP	
  0x441a6d		7640			JBE 0x441aaf		
  0x441a6f		4883ec28		SUBQ $0x28, SP		
  0x441a73		48896c2420		MOVQ BP, 0x20(SP)	
  0x441a78		488d6c2420		LEAQ 0x20(SP), BP	
  0x441a7d		488b4208		MOVQ 0x8(DX), AX	
  0x441a81		488b4a10		MOVQ 0x10(DX), CX	
  0x441a85		488b5a18		MOVQ 0x18(DX), BX	
  0x441a89		488b5220		MOVQ 0x20(DX), DX	
			cgoCheckUsingType(typ, src, off, size)
  0x441a8d		48890424		MOVQ AX, 0(SP)				
  0x441a91		48894c2408		MOVQ CX, 0x8(SP)			
  0x441a96		48895c2410		MOVQ BX, 0x10(SP)			
  0x441a9b		4889542418		MOVQ DX, 0x18(SP)			
  0x441aa0		e8cb10fcff		CALL runtime.cgoCheckUsingType(SB)	
		})
  0x441aa5		488b6c2420		MOVQ 0x20(SP), BP	
  0x441aaa		4883c428		ADDQ $0x28, SP		
  0x441aae		c3			RET			
		systemstack(func() {
  0x441aaf		e81c2a0000		CALL runtime.morestack(SB)			
  0x441ab4		ebaa			JMP runtime.cgoCheckTypedBlock.func1(SB)	

TEXT runtime.cgoCheckTypedBlock.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
				systemstack(func() {
  0x441ac0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441ac9		483b6110		CMPQ 0x10(CX), SP	
  0x441acd		7629			JBE 0x441af8		
  0x441acf		4883ec18		SUBQ $0x18, SP		
  0x441ad3		48896c2410		MOVQ BP, 0x10(SP)	
  0x441ad8		488d6c2410		LEAQ 0x10(SP), BP	
					throw(cgoWriteBarrierFail)
  0x441add		488d05fab20200		LEAQ 0x2b2fa(IP), AX	
  0x441ae4		48890424		MOVQ AX, 0(SP)		
  0x441ae8		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x441af1		e8daf6fdff		CALL runtime.throw(SB)	
  0x441af6		0f0b			UD2			
				systemstack(func() {
  0x441af8		e8732a0000		CALL runtime.morestack_noctxt(SB)		
  0x441afd		ebc1			JMP runtime.cgoCheckTypedBlock.func2(SB)	

TEXT runtime.cgoCheckBits.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/cgocheck.go
					systemstack(func() {
  0x441b00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441b09		483b6110		CMPQ 0x10(CX), SP	
  0x441b0d		7629			JBE 0x441b38		
  0x441b0f		4883ec18		SUBQ $0x18, SP		
  0x441b13		48896c2410		MOVQ BP, 0x10(SP)	
  0x441b18		488d6c2410		LEAQ 0x10(SP), BP	
						throw(cgoWriteBarrierFail)
  0x441b1d		488d05bab20200		LEAQ 0x2b2ba(IP), AX	
  0x441b24		48890424		MOVQ AX, 0(SP)		
  0x441b28		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x441b31		e89af6fdff		CALL runtime.throw(SB)	
  0x441b36		0f0b			UD2			
					systemstack(func() {
  0x441b38		e8332a0000		CALL runtime.morestack_noctxt(SB)	
  0x441b3d		ebc1			JMP runtime.cgoCheckBits.func1(SB)	

TEXT runtime.chansend.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x441b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x441b49		483b6110		CMPQ 0x10(CX), SP		
  0x441b4d		762b			JBE 0x441b7a			
  0x441b4f		4883ec10		SUBQ $0x10, SP			
  0x441b53		48896c2408		MOVQ BP, 0x8(SP)		
  0x441b58		488d6c2408		LEAQ 0x8(SP), BP		
  0x441b5d		488b4208		MOVQ 0x8(DX), AX		
  0x441b61		8400			TESTB AL, 0(AX)			
  0x441b63		4883c058		ADDQ $0x58, AX			
  0x441b67		48890424		MOVQ AX, 0(SP)			
  0x441b6b		e8507bfcff		CALL runtime.unlock(SB)		
  0x441b70		488b6c2408		MOVQ 0x8(SP), BP		
  0x441b75		4883c410		ADDQ $0x10, SP			
  0x441b79		c3			RET				
  0x441b7a		e851290000		CALL runtime.morestack(SB)	
  0x441b7f		ebbf			JMP runtime.chansend.func1(SB)	

TEXT runtime.chanrecv.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/chan.go
		recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x441b90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x441b99		483b6110		CMPQ 0x10(CX), SP		
  0x441b9d		762b			JBE 0x441bca			
  0x441b9f		4883ec10		SUBQ $0x10, SP			
  0x441ba3		48896c2408		MOVQ BP, 0x8(SP)		
  0x441ba8		488d6c2408		LEAQ 0x8(SP), BP		
  0x441bad		488b4208		MOVQ 0x8(DX), AX		
  0x441bb1		8400			TESTB AL, 0(AX)			
  0x441bb3		4883c058		ADDQ $0x58, AX			
  0x441bb7		48890424		MOVQ AX, 0(SP)			
  0x441bbb		e8007bfcff		CALL runtime.unlock(SB)		
  0x441bc0		488b6c2408		MOVQ 0x8(SP), BP		
  0x441bc5		4883c410		ADDQ $0x10, SP			
  0x441bc9		c3			RET				
  0x441bca		e801290000		CALL runtime.morestack(SB)	
  0x441bcf		ebbf			JMP runtime.chanrecv.func1(SB)	

TEXT runtime.(*mcache).nextFree.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
		systemstack(func() {
  0x441be0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441be9		483b6110		CMPQ 0x10(CX), SP	
  0x441bed		762d			JBE 0x441c1c		
  0x441bef		4883ec18		SUBQ $0x18, SP		
  0x441bf3		48896c2410		MOVQ BP, 0x10(SP)	
  0x441bf8		488d6c2410		LEAQ 0x10(SP), BP	
  0x441bfd		488b4208		MOVQ 0x8(DX), AX	
  0x441c01		0fb64a10		MOVZX 0x10(DX), CX	
			c.refill(spc)
  0x441c05		48890424		MOVQ AX, 0(SP)				
  0x441c09		884c2408		MOVB CL, 0x8(SP)			
  0x441c0d		e81ec8fcff		CALL runtime.(*mcache).refill(SB)	
		})
  0x441c12		488b6c2410		MOVQ 0x10(SP), BP	
  0x441c17		4883c418		ADDQ $0x18, SP		
  0x441c1b		c3			RET			
		systemstack(func() {
  0x441c1c		e8af280000		CALL runtime.morestack(SB)			
  0x441c21		ebbd			JMP runtime.(*mcache).nextFree.func1(SB)	

TEXT runtime.mallocgc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
		systemstack(func() {
  0x441c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441c39		483b6110		CMPQ 0x10(CX), SP	
  0x441c3d		764e			JBE 0x441c8d		
  0x441c3f		4883ec28		SUBQ $0x28, SP		
  0x441c43		48896c2420		MOVQ BP, 0x20(SP)	
  0x441c48		488d6c2420		LEAQ 0x20(SP), BP	
  0x441c4d		488b4208		MOVQ 0x8(DX), AX	
  0x441c51		0fb64a10		MOVZX 0x10(DX), CX	
  0x441c55		0fb65a11		MOVZX 0x11(DX), BX	
  0x441c59		488b5218		MOVQ 0x18(DX), DX	
  0x441c5d		4889542418		MOVQ DX, 0x18(SP)	
			s = largeAlloc(size, needzero, noscan)
  0x441c62		488b00			MOVQ 0(AX), AX			
  0x441c65		48890424		MOVQ AX, 0(SP)			
  0x441c69		884c2408		MOVB CL, 0x8(SP)		
  0x441c6d		885c2409		MOVB BL, 0x9(SP)		
  0x441c71		e86a93fcff		CALL runtime.largeAlloc(SB)	
  0x441c76		488b442410		MOVQ 0x10(SP), AX		
  0x441c7b		488b4c2418		MOVQ 0x18(SP), CX		
  0x441c80		488901			MOVQ AX, 0(CX)			
		})
  0x441c83		488b6c2420		MOVQ 0x20(SP), BP	
  0x441c88		4883c428		ADDQ $0x28, SP		
  0x441c8c		c3			RET			
		systemstack(func() {
  0x441c8d		e83e280000		CALL runtime.morestack(SB)	
  0x441c92		eb9c			JMP runtime.mallocgc.func1(SB)	

TEXT runtime.persistentalloc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/malloc.go
	systemstack(func() {
  0x441ca0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441ca9		483b6110		CMPQ 0x10(CX), SP	
  0x441cad		764d			JBE 0x441cfc		
  0x441caf		4883ec30		SUBQ $0x30, SP		
  0x441cb3		48896c2428		MOVQ BP, 0x28(SP)	
  0x441cb8		488d6c2428		LEAQ 0x28(SP), BP	
  0x441cbd		488b4208		MOVQ 0x8(DX), AX	
  0x441cc1		488b4a10		MOVQ 0x10(DX), CX	
  0x441cc5		488b5a18		MOVQ 0x18(DX), BX	
  0x441cc9		488b5220		MOVQ 0x20(DX), DX	
  0x441ccd		4889542420		MOVQ DX, 0x20(SP)	
		p = persistentalloc1(size, align, sysStat)
  0x441cd2		48890424		MOVQ AX, 0(SP)				
  0x441cd6		48894c2408		MOVQ CX, 0x8(SP)			
  0x441cdb		48895c2410		MOVQ BX, 0x10(SP)			
  0x441ce0		e85b98fcff		CALL runtime.persistentalloc1(SB)	
  0x441ce5		488b442418		MOVQ 0x18(SP), AX			
  0x441cea		488b4c2420		MOVQ 0x20(SP), CX			
  0x441cef		488901			MOVQ AX, 0(CX)				
	})
  0x441cf2		488b6c2428		MOVQ 0x28(SP), BP	
  0x441cf7		4883c430		ADDQ $0x30, SP		
  0x441cfb		c3			RET			
	systemstack(func() {
  0x441cfc		e8cf270000		CALL runtime.morestack(SB)		
  0x441d01		eb9d			JMP runtime.persistentalloc.func1(SB)	

TEXT runtime.writebarrierptr_prewrite1.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
	systemstack(func() {
  0x441d10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441d19		483b6110		CMPQ 0x10(CX), SP	
  0x441d1d		0f86e5000000		JBE 0x441e08		
  0x441d23		4883ec18		SUBQ $0x18, SP		
  0x441d27		48896c2410		MOVQ BP, 0x10(SP)	
  0x441d2c		488d6c2410		LEAQ 0x10(SP), BP	
  0x441d31		488b4208		MOVQ 0x8(DX), AX	
  0x441d35		488b4a10		MOVQ 0x10(DX), CX	
  0x441d39		488b5218		MOVQ 0x18(DX), DX	
		if mp.p == 0 && memstats.enablegc && !mp.inwb && inheap(src) {
  0x441d3d		488b98d0000000		MOVQ 0xd0(AX), BX			
  0x441d44		4885db			TESTQ BX, BX				
  0x441d47		7516			JNE 0x441d5f				
  0x441d49		0fb61d803a0800		MOVZX runtime.memstats+4304(SB), BX	
  0x441d50		84db			TESTL BL, BL				
  0x441d52		740b			JE 0x441d5f				
  0x441d54		0fb69816010000		MOVZX 0x116(AX), BX			
  0x441d5b		84db			TESTL BL, BL				
  0x441d5d		741f			JE 0x441d7e				
		mp.inwb = true
  0x441d5f		c6801601000001		MOVB $0x1, 0x116(AX)	
		gcmarkwb_m(dst, src)
  0x441d66		48891424		MOVQ DX, 0(SP)			
  0x441d6a		48894c2408		MOVQ CX, 0x8(SP)		
  0x441d6f		e8ac9afcff		CALL runtime.gcmarkwb_m(SB)	
	})
  0x441d74		488b6c2410		MOVQ 0x10(SP), BP	
  0x441d79		4883c418		ADDQ $0x18, SP		
  0x441d7d		c3			RET			
	if b == 0 || b < mheap_.arena_start || b >= mheap_.arena_used {
  0x441d7e		4885c9			TESTQ CX, CX				
  0x441d81		74dc			JE 0x441d5f				
  0x441d83		488b1d3eb80600		MOVQ runtime.mheap_+4904(SB), BX	
  0x441d8a		4839d9			CMPQ BX, CX				
  0x441d8d		72d0			JB 0x441d5f				
  0x441d8f		488b353ab80600		MOVQ runtime.mheap_+4912(SB), SI	
  0x441d96		4839f1			CMPQ SI, CX				
  0x441d99		73c4			JAE 0x441d5f				
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x441d9b		488b354eb50600		MOVQ runtime.mheap_+4176(SB), SI	
  0x441da2		488b3d3fb50600		MOVQ runtime.mheap_+4168(SB), DI	
  0x441da9		4989c8			MOVQ CX, R8				
  0x441dac		4829d9			SUBQ BX, CX				
  0x441daf		48c1e90d		SHRQ $0xd, CX				
  0x441db3		4839f1			CMPQ SI, CX				
  0x441db6		732e			JAE 0x441de6				
  0x441db8		488b0ccf		MOVQ 0(DI)(CX*8), CX			
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x441dbc		4885c9			TESTQ CX, CX		
  0x441dbf		7409			JE 0x441dca		
	return s.startAddr
  0x441dc1		488b5918		MOVQ 0x18(CX), BX	
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x441dc5		4939d8			CMPQ BX, R8		
  0x441dc8		7305			JAE 0x441dcf		
  0x441dca		4c89c1			MOVQ R8, CX		
		if mp.p == 0 && memstats.enablegc && !mp.inwb && inheap(src) {
  0x441dcd		eb90			JMP 0x441d5f		
	if s == nil || b < s.base() || b >= s.limit || s.state != mSpanInUse {
  0x441dcf		488b9980000000		MOVQ 0x80(CX), BX	
  0x441dd6		4939d8			CMPQ BX, R8		
  0x441dd9		73ef			JAE 0x441dca		
  0x441ddb		0fb64964		MOVZX 0x64(CX), CX	
  0x441ddf		80f901			CMPL $0x1, CL		
  0x441de2		75e6			JNE 0x441dca		
  0x441de4		eb07			JMP 0x441ded		
	s := mheap_.spans[(b-mheap_.arena_start)>>_PageShift]
  0x441de6		e855dcfdff		CALL runtime.panicindex(SB)	
  0x441deb		0f0b			UD2				
			throw("writebarrierptr_prewrite1 called with mp.p == nil")
  0x441ded		488d05cdbb0200		LEAQ 0x2bbcd(IP), AX	
  0x441df4		48890424		MOVQ AX, 0(SP)		
  0x441df8		48c744240831000000	MOVQ $0x31, 0x8(SP)	
  0x441e01		e8caf3fdff		CALL runtime.throw(SB)	
  0x441e06		0f0b			UD2			
	systemstack(func() {
  0x441e08		e8c3260000		CALL runtime.morestack(SB)			
  0x441e0d		e9fefeffff		JMP runtime.writebarrierptr_prewrite1.func1(SB)	

TEXT runtime.writebarrierptr_prewrite.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mbarrier.go
		systemstack(func() { throw("bad pointer in write barrier") })
  0x441e20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x441e29		483b6110		CMPQ 0x10(CX), SP				
  0x441e2d		7629			JBE 0x441e58					
  0x441e2f		4883ec18		SUBQ $0x18, SP					
  0x441e33		48896c2410		MOVQ BP, 0x10(SP)				
  0x441e38		488d6c2410		LEAQ 0x10(SP), BP				
  0x441e3d		488d0502a20200		LEAQ 0x2a202(IP), AX				
  0x441e44		48890424		MOVQ AX, 0(SP)					
  0x441e48		48c74424081c000000	MOVQ $0x1c, 0x8(SP)				
  0x441e51		e87af3fdff		CALL runtime.throw(SB)				
  0x441e56		0f0b			UD2						
  0x441e58		e813270000		CALL runtime.morestack_noctxt(SB)		
  0x441e5d		ebc1			JMP runtime.writebarrierptr_prewrite.func1(SB)	

TEXT runtime.freemcache.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mcache.go
	systemstack(func() {
  0x441e60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441e69		483b6110		CMPQ 0x10(CX), SP	
  0x441e6d		0f869a000000		JBE 0x441f0d		
  0x441e73		4883ec18		SUBQ $0x18, SP		
  0x441e77		48896c2410		MOVQ BP, 0x10(SP)	
  0x441e7c		488d6c2410		LEAQ 0x10(SP), BP	
  0x441e81		488b4208		MOVQ 0x8(DX), AX	
  0x441e85		4889442408		MOVQ AX, 0x8(SP)	
		c.releaseAll()
  0x441e8a		48890424		MOVQ AX, 0(SP)				
  0x441e8e		e8ddc6fcff		CALL runtime.(*mcache).releaseAll(SB)	
  0x441e93		488b442408		MOVQ 0x8(SP), AX			
		stackcache_clear(c)
  0x441e98		48890424		MOVQ AX, 0(SP)				
  0x441e9c		e88f25ffff		CALL runtime.stackcache_clear(SB)	
		lock(&mheap_.lock)
  0x441ea1		488d05f8a30600		LEAQ runtime.mheap_(SB), AX	
  0x441ea8		48890424		MOVQ AX, 0(SP)			
  0x441eac		e86f76fcff		CALL runtime.lock(SB)		
  0x441eb1		488b442408		MOVQ 0x8(SP), AX		
		purgecachedstats(c)
  0x441eb6		48890424		MOVQ AX, 0(SP)				
  0x441eba		e851c3fdff		CALL runtime.purgecachedstats(SB)	
	f.inuse -= f.size
  0x441ebf		488d05f2d80600		LEAQ runtime.mheap_+13592(SB), AX	
  0x441ec6		8400			TESTB AL, 0(AX)				
  0x441ec8		488b0519d90600		MOVQ runtime.mheap_+13640(SB), AX	
  0x441ecf		482b05e2d80600		SUBQ runtime.mheap_+13592(SB), AX	
  0x441ed6		4889050bd90600		MOVQ AX, runtime.mheap_+13640(SB)	
	v.next = f.list
  0x441edd		488b05ecd80600		MOVQ runtime.mheap_+13616(SB), AX	
  0x441ee4		488b4c2408		MOVQ 0x8(SP), CX			
  0x441ee9		488901			MOVQ AX, 0(CX)				
	f.list = v
  0x441eec		48890dddd80600		MOVQ CX, runtime.mheap_+13616(SB)	
		unlock(&mheap_.lock)
  0x441ef3		488d05a6a30600		LEAQ runtime.mheap_(SB), AX	
  0x441efa		48890424		MOVQ AX, 0(SP)			
  0x441efe		e8bd77fcff		CALL runtime.unlock(SB)		
	})
  0x441f03		488b6c2410		MOVQ 0x10(SP), BP	
  0x441f08		4883c418		ADDQ $0x18, SP		
  0x441f0c		c3			RET			
	systemstack(func() {
  0x441f0d		e8be250000		CALL runtime.morestack(SB)		
  0x441f12		e949ffffff		JMP runtime.freemcache.func1(SB)	

TEXT runtime.gcStart.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
	systemstack(func() {
  0x441f20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441f29		483b6110		CMPQ 0x10(CX), SP	
  0x441f2d		761a			JBE 0x441f49		
  0x441f2f		4883ec08		SUBQ $0x8, SP		
  0x441f33		48892c24		MOVQ BP, 0(SP)		
  0x441f37		488d2c24		LEAQ 0(SP), BP		
		finishsweep_m()
  0x441f3b		e8d059fdff		CALL runtime.finishsweep_m(SB)	
	})
  0x441f40		488b2c24		MOVQ 0(SP), BP		
  0x441f44		4883c408		ADDQ $0x8, SP		
  0x441f48		c3			RET			
	systemstack(func() {
  0x441f49		e822260000		CALL runtime.morestack_noctxt(SB)	
  0x441f4e		ebd0			JMP runtime.gcStart.func1(SB)		

TEXT runtime.gcStart.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
		systemstack(func() {
  0x441f50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441f59		483b6110		CMPQ 0x10(CX), SP	
  0x441f5d		763d			JBE 0x441f9c		
  0x441f5f		4883ec20		SUBQ $0x20, SP		
  0x441f63		48896c2418		MOVQ BP, 0x18(SP)	
  0x441f68		488d6c2418		LEAQ 0x18(SP), BP	
  0x441f6d		488b4208		MOVQ 0x8(DX), AX	
  0x441f71		4889442410		MOVQ AX, 0x10(SP)	
			now = startTheWorldWithSema(trace.enabled)
  0x441f76		0fb60d53180700		MOVZX runtime.trace+16(SB), CX		
  0x441f7d		880c24			MOVB CL, 0(SP)				
  0x441f80		e86b35feff		CALL runtime.startTheWorldWithSema(SB)	
  0x441f85		488b442408		MOVQ 0x8(SP), AX			
  0x441f8a		488b4c2410		MOVQ 0x10(SP), CX			
  0x441f8f		488901			MOVQ AX, 0(CX)				
		})
  0x441f92		488b6c2418		MOVQ 0x18(SP), BP	
  0x441f97		4883c420		ADDQ $0x20, SP		
  0x441f9b		c3			RET			
		systemstack(func() {
  0x441f9c		e82f250000		CALL runtime.morestack(SB)	
  0x441fa1		ebad			JMP runtime.gcStart.func2(SB)	

TEXT runtime.gcMarkDone.func1.1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
			forEachP(func(_p_ *p) {
  0x441fb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441fb9		483b6110		CMPQ 0x10(CX), SP	
  0x441fbd		763c			JBE 0x441ffb		
  0x441fbf		4883ec10		SUBQ $0x10, SP		
  0x441fc3		48896c2408		MOVQ BP, 0x8(SP)	
  0x441fc8		488d6c2408		LEAQ 0x8(SP), BP	
  0x441fcd		488b442418		MOVQ 0x18(SP), AX	
				wbBufFlush1(_p_)
  0x441fd2		48890424		MOVQ AX, 0(SP)			
  0x441fd6		e8f5c5fdff		CALL runtime.wbBufFlush1(SB)	
  0x441fdb		488b442418		MOVQ 0x18(SP), AX		
				_p_.gcw.dispose()
  0x441fe0		8400			TESTB AL, 0(AX)				
  0x441fe2		480570120000		ADDQ $0x1270, AX			
  0x441fe8		48890424		MOVQ AX, 0(SP)				
  0x441fec		e88f72fdff		CALL runtime.(*gcWork).dispose(SB)	
			})
  0x441ff1		488b6c2408		MOVQ 0x8(SP), BP	
  0x441ff6		4883c410		ADDQ $0x10, SP		
  0x441ffa		c3			RET			
			forEachP(func(_p_ *p) {
  0x441ffb		e870250000		CALL runtime.morestack_noctxt(SB)	
  0x442000		ebae			JMP runtime.gcMarkDone.func1.1(SB)	

TEXT runtime.gcMarkDone.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
		systemstack(func() {
  0x442010		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442019		483b6110		CMPQ 0x10(CX), SP	
  0x44201d		7628			JBE 0x442047		
  0x44201f		4883ec10		SUBQ $0x10, SP		
  0x442023		48896c2408		MOVQ BP, 0x8(SP)	
  0x442028		488d6c2408		LEAQ 0x8(SP), BP	
			forEachP(func(_p_ *p) {
  0x44202d		488d0554c00200		LEAQ 0x2c054(IP), AX		
  0x442034		48890424		MOVQ AX, 0(SP)			
  0x442038		e8733bfeff		CALL runtime.forEachP(SB)	
		})
  0x44203d		488b6c2408		MOVQ 0x8(SP), BP	
  0x442042		4883c410		ADDQ $0x10, SP		
  0x442046		c3			RET			
		systemstack(func() {
  0x442047		e824250000		CALL runtime.morestack_noctxt(SB)	
  0x44204c		ebc2			JMP runtime.gcMarkDone.func1(SB)	

TEXT runtime.gcMarkTermination.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
	systemstack(func() {
  0x442050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442059		483b6110		CMPQ 0x10(CX), SP	
  0x44205d		7628			JBE 0x442087		
  0x44205f		4883ec10		SUBQ $0x10, SP		
  0x442063		48896c2408		MOVQ BP, 0x8(SP)	
  0x442068		488d6c2408		LEAQ 0x8(SP), BP	
  0x44206d		488b4208		MOVQ 0x8(DX), AX	
		gcMark(startTime)
  0x442071		488b00			MOVQ 0(AX), AX		
  0x442074		48890424		MOVQ AX, 0(SP)		
  0x442078		e8630afdff		CALL runtime.gcMark(SB)	
	})
  0x44207d		488b6c2408		MOVQ 0x8(SP), BP	
  0x442082		4883c410		ADDQ $0x10, SP		
  0x442086		c3			RET			
	systemstack(func() {
  0x442087		e844240000		CALL runtime.morestack(SB)		
  0x44208c		ebc2			JMP runtime.gcMarkTermination.func1(SB)	

TEXT runtime.gcMarkTermination.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
	systemstack(func() {
  0x442090		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442099		483b6110		CMPQ 0x10(CX), SP	
  0x44209d		0f869e010000		JBE 0x442241		
  0x4420a3		4883ec18		SUBQ $0x18, SP		
  0x4420a7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4420ac		488d6c2410		LEAQ 0x10(SP), BP	
  0x4420b1		488b4208		MOVQ 0x8(DX), AX	
  0x4420b5		4889442408		MOVQ AX, 0x8(SP)	
		work.heap2 = work.bytesMarked
  0x4420ba		488b0d5f5d0600		MOVQ runtime.work+128(SB), CX	
  0x4420c1		48890d705e0600		MOVQ CX, runtime.work+408(SB)	
		if debug.gccheckmark > 0 {
  0x4420c8		8b0dfe190800		MOVL runtime.debug+12(SB), CX	
  0x4420ce		85c9			TESTL CX, CX			
  0x4420d0		0f8f41010000		JG 0x442217			
	atomic.Store(&gcphase, x)
  0x4420d6		31c9			XORL CX, CX			
  0x4420d8		488d15fd170800		LEAQ runtime.gcphase(SB), DX	
  0x4420df		870a			XCHGL CX, 0(DX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x4420e1		8b0df5170800		MOVL runtime.gcphase(SB), CX		
  0x4420e7		83f901			CMPL $0x1, CX				
  0x4420ea		0f851c010000		JNE 0x44220c				
  0x4420f0		b901000000		MOVL $0x1, CX				
  0x4420f5		880d19190800		MOVB CL, runtime.writeBarrier+4(SB)	
  0x4420fb		84c9			TESTL CL, CL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x4420fd		0f84fd000000		JE 0x442200				
  0x442103		b901000000		MOVL $0x1, CX				
  0x442108		880d02190800		MOVB CL, runtime.writeBarrier(SB)	
		gcSweep(work.mode)
  0x44210e		488b058b5d0600		MOVQ runtime.work+256(SB), AX	
  0x442115		48890424		MOVQ AX, 0(SP)			
  0x442119		e8c20cfdff		CALL runtime.gcSweep(SB)	
		if debug.gctrace > 1 {
  0x44211e		8b05bc190800		MOVL runtime.debug+32(SB), AX	
  0x442124		83f801			CMPL $0x1, AX			
  0x442127		7f0a			JG 0x442133			
  0x442129		488b6c2410		MOVQ 0x10(SP), BP		
  0x44212e		4883c418		ADDQ $0x18, SP			
  0x442132		c3			RET				
			startTime = nanotime()
  0x442133		e8f8580000		CALL runtime.nanotime(SB)	
  0x442138		488b0424		MOVQ 0(SP), AX			
  0x44213c		488b4c2408		MOVQ 0x8(SP), CX		
  0x442141		488901			MOVQ AX, 0(CX)			
			gcResetMarkState()
  0x442144		e8470efdff		CALL runtime.gcResetMarkState(SB)	
			finishsweep_m()
  0x442149		e8c257fdff		CALL runtime.finishsweep_m(SB)	
	atomic.Store(&gcphase, x)
  0x44214e		b802000000		MOVL $0x2, AX			
  0x442153		488d0d82170800		LEAQ runtime.gcphase(SB), CX	
  0x44215a		8701			XCHGL AX, 0(CX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x44215c		8b057a170800		MOVL runtime.gcphase(SB), AX		
  0x442162		83f801			CMPL $0x1, AX				
  0x442165		0f858a000000		JNE 0x4421f5				
  0x44216b		b801000000		MOVL $0x1, AX				
  0x442170		88059e180800		MOVB AL, runtime.writeBarrier+4(SB)	
  0x442176		84c0			TESTL AL, AL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x442178		7472			JE 0x4421ec				
  0x44217a		b801000000		MOVL $0x1, AX				
  0x44217f		88058b180800		MOVB AL, runtime.writeBarrier(SB)	
  0x442185		488b442408		MOVQ 0x8(SP), AX			
			gcMark(startTime)
  0x44218a		488b00			MOVQ 0(AX), AX		
  0x44218d		48890424		MOVQ AX, 0(SP)		
  0x442191		e84a09fdff		CALL runtime.gcMark(SB)	
	atomic.Store(&gcphase, x)
  0x442196		31c0			XORL AX, AX			
  0x442198		488d0d3d170800		LEAQ runtime.gcphase(SB), CX	
  0x44219f		8701			XCHGL AX, 0(CX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x4421a1		8b0535170800		MOVL runtime.gcphase(SB), AX		
  0x4421a7		83f801			CMPL $0x1, AX				
  0x4421aa		7538			JNE 0x4421e4				
  0x4421ac		b801000000		MOVL $0x1, AX				
  0x4421b1		88055d180800		MOVB AL, runtime.writeBarrier+4(SB)	
  0x4421b7		84c0			TESTL AL, AL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x4421b9		7420			JE 0x4421db				
  0x4421bb		b801000000		MOVL $0x1, AX				
  0x4421c0		88054a180800		MOVB AL, runtime.writeBarrier(SB)	
			gcSweep(work.mode)
  0x4421c6		488b05d35c0600		MOVQ runtime.work+256(SB), AX	
  0x4421cd		48890424		MOVQ AX, 0(SP)			
  0x4421d1		e80a0cfdff		CALL runtime.gcSweep(SB)	
  0x4421d6		e94effffff		JMP 0x442129			
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x4421db		0fb60533180800		MOVZX runtime.writeBarrier+5(SB), AX	
  0x4421e2		ebdc			JMP 0x4421c0				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x4421e4		83f802			CMPL $0x2, AX		
  0x4421e7		0f94c0			SETE AL			
  0x4421ea		ebc5			JMP 0x4421b1		
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x4421ec		0fb60522180800		MOVZX runtime.writeBarrier+5(SB), AX	
  0x4421f3		eb8a			JMP 0x44217f				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x4421f5		83f802			CMPL $0x2, AX		
  0x4421f8		0f94c0			SETE AL			
  0x4421fb		e970ffffff		JMP 0x442170		
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x442200		0fb60d0e180800		MOVZX runtime.writeBarrier+5(SB), CX	
  0x442207		e9fcfeffff		JMP 0x442108				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x44220c		83f902			CMPL $0x2, CX		
  0x44220f		0f94c1			SETE CL			
  0x442212		e9defeffff		JMP 0x4420f5		
			gcResetMarkState()
  0x442217		e8740dfdff		CALL runtime.gcResetMarkState(SB)	
			initCheckmarks()
  0x44221c		e80f55fdff		CALL runtime.initCheckmarks(SB)	
  0x442221		488b442408		MOVQ 0x8(SP), AX		
			gcMark(startTime)
  0x442226		488b08			MOVQ 0(AX), CX		
  0x442229		48890c24		MOVQ CX, 0(SP)		
  0x44222d		e8ae08fdff		CALL runtime.gcMark(SB)	
			clearCheckmarks()
  0x442232		e8e955fdff		CALL runtime.clearCheckmarks(SB)	
  0x442237		488b442408		MOVQ 0x8(SP), AX			
  0x44223c		e995feffff		JMP 0x4420d6				
	systemstack(func() {
  0x442241		e88a220000		CALL runtime.morestack(SB)		
  0x442246		e945feffff		JMP runtime.gcMarkTermination.func2(SB)	

TEXT runtime.gcMarkTermination.func3(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
	systemstack(func() { startTheWorldWithSema(true) })
  0x442250		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x442259		483b6110		CMPQ 0x10(CX), SP			
  0x44225d		7621			JBE 0x442280				
  0x44225f		4883ec18		SUBQ $0x18, SP				
  0x442263		48896c2410		MOVQ BP, 0x10(SP)			
  0x442268		488d6c2410		LEAQ 0x10(SP), BP			
  0x44226d		c6042401		MOVB $0x1, 0(SP)			
  0x442271		e87a32feff		CALL runtime.startTheWorldWithSema(SB)	
  0x442276		488b6c2410		MOVQ 0x10(SP), BP			
  0x44227b		4883c418		ADDQ $0x18, SP				
  0x44227f		c3			RET					
  0x442280		e8eb220000		CALL runtime.morestack_noctxt(SB)	
  0x442285		ebc9			JMP runtime.gcMarkTermination.func3(SB)	

TEXT runtime.gcBgMarkWorker.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
		gopark(func(g *g, parkp unsafe.Pointer) bool {
  0x442290		488b4c2410		MOVQ 0x10(SP), CX	
			releasem(park.m.ptr())
  0x442295		488b11			MOVQ 0(CX), DX		
	_g_ := getg()
  0x442298		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
	mp.locks--
  0x4422a1		8bb200010000		MOVL 0x100(DX), SI	
  0x4422a7		8d7eff			LEAL -0x1(SI), DI	
  0x4422aa		89ba00010000		MOVL DI, 0x100(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x4422b0		83fe01			CMPL $0x1, SI		
  0x4422b3		7513			JNE 0x4422c8		
  0x4422b5		0fb693c0000000		MOVZX 0xc0(BX), DX	
  0x4422bc		84d2			TESTL DL, DL		
  0x4422be		7408			JE 0x4422c8		
		_g_.stackguard0 = stackPreempt
  0x4422c0		48c74310defaffff	MOVQ $-0x522, 0x10(BX)	
			if park.attach != 0 {
  0x4422c8		488b5108		MOVQ 0x8(CX), DX	
  0x4422cc		488d5908		LEAQ 0x8(CX), BX	
  0x4422d0		4885d2			TESTQ DX, DX		
  0x4422d3		7421			JE 0x4422f6		
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4422d5		8403			TESTB AL, 0(BX)		
  0x4422d7		31db			XORL BX, BX		
  0x4422d9		48895908		MOVQ BX, 0x8(CX)	
				if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {
  0x4422dd		8402			TESTB AL, 0(DX)		
  0x4422df		488b4c2408		MOVQ 0x8(SP), CX	
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x4422e4		31c0			XORL AX, AX			
  0x4422e6		f0480fb18a58120000	LOCK CMPXCHGQ CX, 0x1258(DX)	
  0x4422ef		0f94c1			SETE CL				
  0x4422f2		84c9			TESTL CL, CL			
				if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {
  0x4422f4		7406			JE 0x4422fc		
			return true
  0x4422f6		c644241801		MOVB $0x1, 0x18(SP)	
  0x4422fb		c3			RET			
					return false
  0x4422fc		c644241800		MOVB $0x0, 0x18(SP)	
  0x442301		c3			RET			

TEXT runtime.gcBgMarkWorker.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgc.go
		systemstack(func() {
  0x442310		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442319		483b6110		CMPQ 0x10(CX), SP	
  0x44231d		0f86ab010000		JBE 0x4424ce		
  0x442323		4883ec38		SUBQ $0x38, SP		
  0x442327		48896c2430		MOVQ BP, 0x30(SP)	
  0x44232c		488d6c2430		LEAQ 0x30(SP), BP	
  0x442331		488b4208		MOVQ 0x8(DX), AX	
  0x442335		4889442418		MOVQ AX, 0x18(SP)	
  0x44233a		488b4a10		MOVQ 0x10(DX), CX	
  0x44233e		48894c2420		MOVQ CX, 0x20(SP)	
			casgstatus(gp, _Grunning, _Gwaiting)
  0x442343		48890424		MOVQ AX, 0(SP)			
  0x442347		48ba0200000004000000	MOVQ $0x400000002, DX		
  0x442351		4889542408		MOVQ DX, 0x8(SP)		
  0x442356		e82527feff		CALL runtime.casgstatus(SB)	
  0x44235b		488b442420		MOVQ 0x20(SP), AX		
			switch _p_.gcMarkWorkerMode {
  0x442360		8400			TESTB AL, 0(AX)		
  0x442362		488b8860120000		MOVQ 0x1260(AX), CX	
			case gcMarkWorkerDedicatedMode:
  0x442369		4885c9			TESTQ CX, CX		
  0x44236c		0f8501010000		JNE 0x442473		
				gcDrain(&_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)
  0x442372		488d8870120000		LEAQ 0x1270(AX), CX		
  0x442379		48894c2428		MOVQ CX, 0x28(SP)		
  0x44237e		48890c24		MOVQ CX, 0(SP)			
  0x442382		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x44238b		e8403bfdff		CALL runtime.gcDrain(SB)	
  0x442390		488b442418		MOVQ 0x18(SP), AX		
				if gp.preempt {
  0x442395		0fb688c0000000		MOVZX 0xc0(AX), CX	
  0x44239c		84c9			TESTL CL, CL		
  0x44239e		0f8491000000		JE 0x442435		
					lock(&sched.lock)
  0x4423a4		488d0585550600		LEAQ runtime.sched+16(SB), AX	
  0x4423ab		48890424		MOVQ AX, 0(SP)			
  0x4423af		e86c71fcff		CALL runtime.lock(SB)		
					for {
  0x4423b4		eb16			JMP 0x4423cc		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4423b6		488d05c3550600		LEAQ runtime.sched+96(SB), AX	
  0x4423bd		8400			TESTB AL, 0(AX)			
  0x4423bf		488915ba550600		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x4423c6		ff05bc550600		INCL runtime.sched+104(SB)	
						gp, _ := runqget(_p_)
  0x4423cc		488b442420		MOVQ 0x20(SP), AX		
  0x4423d1		48890424		MOVQ AX, 0(SP)			
  0x4423d5		e896bdfeff		CALL runtime.runqget(SB)	
  0x4423da		488b442408		MOVQ 0x8(SP), AX		
						if gp == nil {
  0x4423df		4885c0			TESTQ AX, AX		
  0x4423e2		7441			JE 0x442425		
	gp.schedlink = 0
  0x4423e4		48c780b800000000000000	MOVQ $0x0, 0xb8(AX)	
	if sched.runqtail != 0 {
  0x4423ef		488b0d8a550600		MOVQ runtime.sched+96(SB), CX	
  0x4423f6		4885c9			TESTQ CX, CX			
  0x4423f9		7415			JE 0x442410			
		sched.runqtail.ptr().schedlink.set(gp)
  0x4423fb		488d91b8000000		LEAQ 0xb8(CX), DX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x442402		8402			TESTB AL, 0(DX)		
  0x442404		4889c2			MOVQ AX, DX		
  0x442407		488981b8000000		MOVQ AX, 0xb8(CX)	
	sched.runqtail.set(gp)
  0x44240e		eba6			JMP 0x4423b6		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x442410		488d0d61550600		LEAQ runtime.sched+88(SB), CX	
  0x442417		8401			TESTB AL, 0(CX)			
  0x442419		4889c2			MOVQ AX, DX			
  0x44241c		48890555550600		MOVQ AX, runtime.sched+88(SB)	
	sched.runqtail.set(gp)
  0x442423		eb91			JMP 0x4423b6		
					unlock(&sched.lock)
  0x442425		488d0504550600		LEAQ runtime.sched+16(SB), AX	
  0x44242c		48890424		MOVQ AX, 0(SP)			
  0x442430		e88b72fcff		CALL runtime.unlock(SB)		
  0x442435		488b442428		MOVQ 0x28(SP), AX		
				gcDrain(&_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)
  0x44243a		48890424		MOVQ AX, 0(SP)			
  0x44243e		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x442447		e8843afdff		CALL runtime.gcDrain(SB)	
			switch _p_.gcMarkWorkerMode {
  0x44244c		488b442418		MOVQ 0x18(SP), AX	
			casgstatus(gp, _Gwaiting, _Grunning)
  0x442451		48890424		MOVQ AX, 0(SP)			
  0x442455		48b80400000002000000	MOVQ $0x200000004, AX		
  0x44245f		4889442408		MOVQ AX, 0x8(SP)		
  0x442464		e81726feff		CALL runtime.casgstatus(SB)	
		})
  0x442469		488b6c2430		MOVQ 0x30(SP), BP	
  0x44246e		4883c438		ADDQ $0x38, SP		
  0x442472		c3			RET			
			case gcMarkWorkerFractionalMode:
  0x442473		4883f901		CMPQ $0x1, CX		
  0x442477		7420			JE 0x442499		
			case gcMarkWorkerIdleMode:
  0x442479		4883f902		CMPQ $0x2, CX		
  0x44247d		7534			JNE 0x4424b3		
				gcDrain(&_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)
  0x44247f		480570120000		ADDQ $0x1270, AX		
  0x442485		48890424		MOVQ AX, 0(SP)			
  0x442489		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x442492		e8393afdff		CALL runtime.gcDrain(SB)	
			switch _p_.gcMarkWorkerMode {
  0x442497		ebb3			JMP 0x44244c		
				gcDrain(&_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)
  0x442499		480570120000		ADDQ $0x1270, AX		
  0x44249f		48890424		MOVQ AX, 0(SP)			
  0x4424a3		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4424ac		e81f3afdff		CALL runtime.gcDrain(SB)	
			switch _p_.gcMarkWorkerMode {
  0x4424b1		eb99			JMP 0x44244c		
				throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")
  0x4424b3		488d0565b00200		LEAQ 0x2b065(IP), AX	
  0x4424ba		48890424		MOVQ AX, 0(SP)		
  0x4424be		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x4424c7		e804edfdff		CALL runtime.throw(SB)	
  0x4424cc		0f0b			UD2			
		systemstack(func() {
  0x4424ce		e8fd1f0000		CALL runtime.morestack(SB)		
  0x4424d3		e938feffff		JMP runtime.gcBgMarkWorker.func2(SB)	

TEXT runtime.markroot.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
		systemstack(func() {
  0x4424e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4424e9		483b6110		CMPQ 0x10(CX), SP	
  0x4424ed		0f8607010000		JBE 0x4425fa		
  0x4424f3		4883ec38		SUBQ $0x38, SP		
  0x4424f7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4424fc		488d6c2430		LEAQ 0x30(SP), BP	
			userG := getg().m.curg
  0x442501		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x44250a		488b4030		MOVQ 0x30(AX), AX	
		systemstack(func() {
  0x44250e		488b4a08		MOVQ 0x8(DX), CX	
  0x442512		488b5210		MOVQ 0x10(DX), DX	
			userG := getg().m.curg
  0x442516		488b80c0000000		MOVQ 0xc0(AX), AX	
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x44251d		4839c1			CMPQ AX, CX		
  0x442520		0f85cd000000		JNE 0x4425f3		
	return atomic.Load(&gp.atomicstatus)
  0x442526		8b9890000000		MOVL 0x90(AX), BX	
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x44252c		83fb02			CMPL $0x2, BX		
  0x44252f		0f94c3			SETE BL			
  0x442532		4889442420		MOVQ AX, 0x20(SP)	
  0x442537		885c2417		MOVB BL, 0x17(SP)	
  0x44253b		84db			TESTL BL, BL		
			if selfScan {
  0x44253d		7540			JNE 0x44257f		
			scang(gp, gcw)
  0x44253f		48890c24		MOVQ CX, 0(SP)		
  0x442543		4889542408		MOVQ DX, 0x8(SP)	
  0x442548		e82327feff		CALL runtime.scang(SB)	
  0x44254d		0fb6442417		MOVZX 0x17(SP), AX	
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x442552		84c0			TESTL AL, AL		
			if selfScan {
  0x442554		750a			JNE 0x442560		
  0x442556		488b6c2430		MOVQ 0x30(SP), BP	
  0x44255b		4883c438		ADDQ $0x38, SP		
  0x44255f		c3			RET			
  0x442560		488b442420		MOVQ 0x20(SP), AX	
				casgstatus(userG, _Gwaiting, _Grunning)
  0x442565		48890424		MOVQ AX, 0(SP)			
  0x442569		48b80400000002000000	MOVQ $0x200000004, AX		
  0x442573		4889442408		MOVQ AX, 0x8(SP)		
  0x442578		e80325feff		CALL runtime.casgstatus(SB)	
  0x44257d		ebd7			JMP 0x442556			
  0x44257f		48894c2418		MOVQ CX, 0x18(SP)		
  0x442584		4889542428		MOVQ DX, 0x28(SP)		
				casgstatus(userG, _Grunning, _Gwaiting)
  0x442589		48890424		MOVQ AX, 0(SP)			
  0x44258d		48b90200000004000000	MOVQ $0x400000002, CX		
  0x442597		48894c2408		MOVQ CX, 0x8(SP)		
  0x44259c		e8df24feff		CALL runtime.casgstatus(SB)	
  0x4425a1		488b442420		MOVQ 0x20(SP), AX		
				userG.waitreason = "garbage collection scan"
  0x4425a6		48c780b000000017000000	MOVQ $0x17, 0xb0(AX)			
  0x4425b1		8b0d59140800		MOVL runtime.writeBarrier(SB), CX	
  0x4425b7		488db8a8000000		LEAQ 0xa8(AX), DI			
  0x4425be		85c9			TESTL CX, CX				
  0x4425c0		751d			JNE 0x4425df				
  0x4425c2		488d0d9a900200		LEAQ 0x2909a(IP), CX			
  0x4425c9		488988a8000000		MOVQ CX, 0xa8(AX)			
  0x4425d0		488b4c2418		MOVQ 0x18(SP), CX			
  0x4425d5		488b542428		MOVQ 0x28(SP), DX			
  0x4425da		e960ffffff		JMP 0x44253f				
  0x4425df		4889c1			MOVQ AX, CX				
  0x4425e2		488d057a900200		LEAQ 0x2907a(IP), AX			
  0x4425e9		e8b2420000		CALL runtime.gcWriteBarrier(SB)		
  0x4425ee		4889c8			MOVQ CX, AX				
  0x4425f1		ebdd			JMP 0x4425d0				
  0x4425f3		31db			XORL BX, BX				
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x4425f5		e938ffffff		JMP 0x442532		
		systemstack(func() {
  0x4425fa		e8d11e0000		CALL runtime.morestack(SB)	
  0x4425ff		e9dcfeffff		JMP runtime.markroot.func1(SB)	

TEXT runtime.gcAssistAlloc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
	systemstack(func() {
  0x442610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442619		483b6110		CMPQ 0x10(CX), SP	
  0x44261d		762e			JBE 0x44264d		
  0x44261f		4883ec18		SUBQ $0x18, SP		
  0x442623		48896c2410		MOVQ BP, 0x10(SP)	
  0x442628		488d6c2410		LEAQ 0x10(SP), BP	
  0x44262d		488b4208		MOVQ 0x8(DX), AX	
  0x442631		488b4a10		MOVQ 0x10(DX), CX	
		gcAssistAlloc1(gp, scanWork)
  0x442635		48890424		MOVQ AX, 0(SP)			
  0x442639		48894c2408		MOVQ CX, 0x8(SP)		
  0x44263e		e8bd25fdff		CALL runtime.gcAssistAlloc1(SB)	
	})
  0x442643		488b6c2410		MOVQ 0x10(SP), BP	
  0x442648		4883c418		ADDQ $0x18, SP		
  0x44264c		c3			RET			
	systemstack(func() {
  0x44264d		e87e1e0000		CALL runtime.morestack(SB)		
  0x442652		ebbc			JMP runtime.gcAssistAlloc.func1(SB)	

TEXT runtime.scanstack.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcmark.go
	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  0x442660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442669		483b6110		CMPQ 0x10(CX), SP	
  0x44266d		763d			JBE 0x4426ac		
  0x44266f		4883ec20		SUBQ $0x20, SP		
  0x442673		48896c2418		MOVQ BP, 0x18(SP)	
  0x442678		488d6c2418		LEAQ 0x18(SP), BP	
  0x44267d		488b4208		MOVQ 0x8(DX), AX	
  0x442681		488b4a10		MOVQ 0x10(DX), CX	
		scanframeworker(frame, &cache, gcw)
  0x442685		4889442408		MOVQ AX, 0x8(SP)	
	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  0x44268a		488b442428		MOVQ 0x28(SP), AX	
		scanframeworker(frame, &cache, gcw)
  0x44268f		48890424		MOVQ AX, 0(SP)				
  0x442693		48894c2410		MOVQ CX, 0x10(SP)			
  0x442698		e89331fdff		CALL runtime.scanframeworker(SB)	
		return true
  0x44269d		c644243801		MOVB $0x1, 0x38(SP)	
  0x4426a2		488b6c2418		MOVQ 0x18(SP), BP	
  0x4426a7		4883c420		ADDQ $0x20, SP		
  0x4426ab		c3			RET			
	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  0x4426ac		e81f1e0000		CALL runtime.morestack(SB)	
  0x4426b1		ebad			JMP runtime.scanstack.func1(SB)	

TEXT runtime.gosweepone.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcsweep.go
	systemstack(func() {
  0x4426c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4426c9		483b6110		CMPQ 0x10(CX), SP	
  0x4426cd		7632			JBE 0x442701		
  0x4426cf		4883ec18		SUBQ $0x18, SP		
  0x4426d3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4426d8		488d6c2410		LEAQ 0x10(SP), BP	
  0x4426dd		488b4208		MOVQ 0x8(DX), AX	
  0x4426e1		4889442408		MOVQ AX, 0x8(SP)	
		ret = sweepone()
  0x4426e6		e8d553fdff		CALL runtime.sweepone(SB)	
  0x4426eb		488b0424		MOVQ 0(SP), AX			
  0x4426ef		488b4c2408		MOVQ 0x8(SP), CX		
  0x4426f4		488901			MOVQ AX, 0(CX)			
	})
  0x4426f7		488b6c2410		MOVQ 0x10(SP), BP	
  0x4426fc		4883c418		ADDQ $0x18, SP		
  0x442700		c3			RET			
	systemstack(func() {
  0x442701		e8ca1d0000		CALL runtime.morestack(SB)		
  0x442706		ebb8			JMP runtime.gosweepone.func1(SB)	

TEXT runtime.getempty.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
			systemstack(func() {
  0x442710		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442719		483b6110		CMPQ 0x10(CX), SP	
  0x44271d		7653			JBE 0x442772		
  0x44271f		4883ec30		SUBQ $0x30, SP		
  0x442723		48896c2428		MOVQ BP, 0x28(SP)	
  0x442728		488d6c2428		LEAQ 0x28(SP), BP	
  0x44272d		488b4208		MOVQ 0x8(DX), AX	
  0x442731		4889442420		MOVQ AX, 0x20(SP)	
				s = mheap_.allocManual(workbufAlloc/pageSize, &memstats.gc_sys)
  0x442736		488d0d639b0600		LEAQ runtime.mheap_(SB), CX		
  0x44273d		48890c24		MOVQ CX, 0(SP)				
  0x442741		48c744240804000000	MOVQ $0x4, 0x8(SP)			
  0x44274a		488d0d47200800		LEAQ runtime.memstats+152(SB), CX	
  0x442751		48894c2410		MOVQ CX, 0x10(SP)			
  0x442756		e8a585fdff		CALL runtime.(*mheap).allocManual(SB)	
  0x44275b		488b442418		MOVQ 0x18(SP), AX			
  0x442760		488b4c2420		MOVQ 0x20(SP), CX			
  0x442765		488901			MOVQ AX, 0(CX)				
			})
  0x442768		488b6c2428		MOVQ 0x28(SP), BP	
  0x44276d		4883c430		ADDQ $0x30, SP		
  0x442771		c3			RET			
			systemstack(func() {
  0x442772		e8591d0000		CALL runtime.morestack(SB)	
  0x442777		eb97			JMP runtime.getempty.func1(SB)	

TEXT runtime.freeSomeWbufs.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mgcwork.go
	systemstack(func() {
  0x442780		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442789		483b6110		CMPQ 0x10(CX), SP	
  0x44278d		0f86b6000000		JBE 0x442849		
  0x442793		4883ec40		SUBQ $0x40, SP		
  0x442797		48896c2438		MOVQ BP, 0x38(SP)	
  0x44279c		488d6c2438		LEAQ 0x38(SP), BP	
		gp := getg().m.curg
  0x4427a1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4427aa		488b4030		MOVQ 0x30(AX), AX	
	systemstack(func() {
  0x4427ae		0fb64a08		MOVZX 0x8(DX), CX	
  0x4427b2		884c241f		MOVB CL, 0x1f(SP)	
		gp := getg().m.curg
  0x4427b6		488b80c0000000		MOVQ 0xc0(AX), AX	
  0x4427bd		4889442428		MOVQ AX, 0x28(SP)	
  0x4427c2		31d2			XORL DX, DX		
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x4427c4		eb58			JMP 0x44281e		
  0x4427c6		4889542420		MOVQ DX, 0x20(SP)	
  0x4427cb		48895c2430		MOVQ BX, 0x30(SP)	
			work.wbufSpans.free.remove(span)
  0x4427d0		488d0521560600		LEAQ runtime.work+88(SB), AX		
  0x4427d7		48890424		MOVQ AX, 0(SP)				
  0x4427db		48895c2408		MOVQ BX, 0x8(SP)			
  0x4427e0		e8cb98fdff		CALL runtime.(*mSpanList).remove(SB)	
			mheap_.freeManual(span, &memstats.gc_sys)
  0x4427e5		488d05b49a0600		LEAQ runtime.mheap_(SB), AX		
  0x4427ec		48890424		MOVQ AX, 0(SP)				
  0x4427f0		488b4c2430		MOVQ 0x30(SP), CX			
  0x4427f5		48894c2408		MOVQ CX, 0x8(SP)			
  0x4427fa		488d0d971f0800		LEAQ runtime.memstats+152(SB), CX	
  0x442801		48894c2410		MOVQ CX, 0x10(SP)			
  0x442806		e8f58cfdff		CALL runtime.(*mheap).freeManual(SB)	
  0x44280b		488b442420		MOVQ 0x20(SP), AX			
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x442810		488d5001		LEAQ 0x1(AX), DX	
  0x442814		488b442428		MOVQ 0x28(SP), AX	
  0x442819		0fb64c241f		MOVZX 0x1f(SP), CX	
  0x44281e		4883fa40		CMPQ $0x40, DX		
  0x442822		7d1b			JGE 0x44283f		
	systemstack(func() {
  0x442824		84c9			TESTL CL, CL		
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x442826		740b			JE 0x442833		
  0x442828		0fb698c0000000		MOVZX 0xc0(AX), BX	
  0x44282f		84db			TESTL BL, BL		
  0x442831		750c			JNE 0x44283f		
			span := work.wbufSpans.free.first
  0x442833		488b1dbe550600		MOVQ runtime.work+88(SB), BX	
			if span == nil {
  0x44283a		4885db			TESTQ BX, BX		
  0x44283d		7587			JNE 0x4427c6		
  0x44283f		488b6c2438		MOVQ 0x38(SP), BP	
  0x442844		4883c440		ADDQ $0x40, SP		
  0x442848		c3			RET			
	systemstack(func() {
  0x442849		e8821c0000		CALL runtime.morestack(SB)		
  0x44284e		e92dffffff		JMP runtime.freeSomeWbufs.func1(SB)	

TEXT runtime.(*mheap).alloc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
	systemstack(func() {
  0x442860		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442869		483b6110		CMPQ 0x10(CX), SP	
  0x44286d		7655			JBE 0x4428c4		
  0x44286f		4883ec30		SUBQ $0x30, SP		
  0x442873		48896c2428		MOVQ BP, 0x28(SP)	
  0x442878		488d6c2428		LEAQ 0x28(SP), BP	
  0x44287d		488b4208		MOVQ 0x8(DX), AX	
  0x442881		488b4a10		MOVQ 0x10(DX), CX	
  0x442885		0fb65a18		MOVZX 0x18(DX), BX	
  0x442889		0fb67219		MOVZX 0x19(DX), SI	
  0x44288d		488b5220		MOVQ 0x20(DX), DX	
  0x442891		4889542420		MOVQ DX, 0x20(SP)	
		s = h.alloc_m(npage, spanclass, large)
  0x442896		48890424		MOVQ AX, 0(SP)				
  0x44289a		48894c2408		MOVQ CX, 0x8(SP)			
  0x44289f		885c2410		MOVB BL, 0x10(SP)			
  0x4428a3		4088742411		MOVB SI, 0x11(SP)			
  0x4428a8		e83380fdff		CALL runtime.(*mheap).alloc_m(SB)	
  0x4428ad		488b442418		MOVQ 0x18(SP), AX			
  0x4428b2		488b4c2420		MOVQ 0x20(SP), CX			
  0x4428b7		488901			MOVQ AX, 0(CX)				
	})
  0x4428ba		488b6c2428		MOVQ 0x28(SP), BP	
  0x4428bf		4883c430		ADDQ $0x30, SP		
  0x4428c3		c3			RET			
	systemstack(func() {
  0x4428c4		e8071c0000		CALL runtime.morestack(SB)		
  0x4428c9		eb95			JMP runtime.(*mheap).alloc.func1(SB)	

TEXT runtime.(*mheap).freeSpan.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mheap.go
	systemstack(func() {
  0x4428d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4428d9		483b6110		CMPQ 0x10(CX), SP	
  0x4428dd		0f8608010000		JBE 0x4429eb		
  0x4428e3		4883ec48		SUBQ $0x48, SP		
  0x4428e7		48896c2440		MOVQ BP, 0x40(SP)	
  0x4428ec		488d6c2440		LEAQ 0x40(SP), BP	
  0x4428f1		488b4208		MOVQ 0x8(DX), AX	
  0x4428f5		4889442438		MOVQ AX, 0x38(SP)	
		lock(&h.lock)
  0x4428fa		8400			TESTB AL, 0(AX)		
	systemstack(func() {
  0x4428fc		488b4a10		MOVQ 0x10(DX), CX	
  0x442900		48894c2428		MOVQ CX, 0x28(SP)	
  0x442905		8b5218			MOVL 0x18(DX), DX	
  0x442908		89542424		MOVL DX, 0x24(SP)	
		mp := getg().m
  0x44290c		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x442915		488b5b30		MOVQ 0x30(BX), BX	
  0x442919		48895c2430		MOVQ BX, 0x30(SP)	
		lock(&h.lock)
  0x44291e		48890424		MOVQ AX, 0(SP)		
  0x442922		e8f96bfcff		CALL runtime.lock(SB)	
  0x442927		488b442430		MOVQ 0x30(SP), AX	
		memstats.heap_scan += uint64(mp.mcache.local_scan)
  0x44292c		488b8860010000		MOVQ 0x160(AX), CX			
  0x442933		488b4908		MOVQ 0x8(CX), CX			
  0x442937		48030d0a350800		ADDQ runtime.memstats+5960(SB), CX	
  0x44293e		48890d03350800		MOVQ CX, runtime.memstats+5960(SB)	
		mp.mcache.local_scan = 0
  0x442945		488b8860010000		MOVQ 0x160(AX), CX	
  0x44294c		48c7410800000000	MOVQ $0x0, 0x8(CX)	
		memstats.tinyallocs += uint64(mp.mcache.local_tinyallocs)
  0x442954		488b8860010000		MOVQ 0x160(AX), CX			
  0x44295b		488b4920		MOVQ 0x20(CX), CX			
  0x44295f		488d15c2340800		LEAQ runtime.memstats+5928(SB), DX	
  0x442966		48030a			ADDQ 0(DX), CX				
  0x442969		48890db8340800		MOVQ CX, runtime.memstats+5928(SB)	
		mp.mcache.local_tinyallocs = 0
  0x442970		488b8060010000		MOVQ 0x160(AX), AX	
  0x442977		48c7402000000000	MOVQ $0x0, 0x20(AX)	
  0x44297f		8b442424		MOVL 0x24(SP), AX	
		if acct != 0 {
  0x442983		85c0			TESTL AX, AX		
  0x442985		7408			JE 0x44298f		
			memstats.heap_objects--
  0x442987		488305c91d0800ff	ADDQ $-0x1, runtime.memstats+88(SB)	
		if gcBlackenEnabled != 0 {
  0x44298f		8b053f0f0800		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x442995		85c0			TESTL AX, AX				
  0x442997		7540			JNE 0x4429d9				
  0x442999		488b442438		MOVQ 0x38(SP), AX			
		h.freeSpanLocked(s, true, true, 0)
  0x44299e		48890424		MOVQ AX, 0(SP)					
  0x4429a2		488b4c2428		MOVQ 0x28(SP), CX				
  0x4429a7		48894c2408		MOVQ CX, 0x8(SP)				
  0x4429ac		66c74424100101		MOVW $0x101, 0x10(SP)				
  0x4429b3		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x4429bc		e8ef8bfdff		CALL runtime.(*mheap).freeSpanLocked(SB)	
  0x4429c1		488b442438		MOVQ 0x38(SP), AX				
		unlock(&h.lock)
  0x4429c6		48890424		MOVQ AX, 0(SP)		
  0x4429ca		e8f16cfcff		CALL runtime.unlock(SB)	
	})
  0x4429cf		488b6c2440		MOVQ 0x40(SP), BP	
  0x4429d4		4883c448		ADDQ $0x48, SP		
  0x4429d8		c3			RET			
			gcController.revise()
  0x4429d9		488d0540120800		LEAQ runtime.gcController(SB), AX		
  0x4429e0		48890424		MOVQ AX, 0(SP)					
  0x4429e4		e8d7d8fcff		CALL runtime.(*gcControllerState).revise(SB)	
  0x4429e9		ebae			JMP 0x442999					
	systemstack(func() {
  0x4429eb		e8e01a0000		CALL runtime.morestack(SB)		
  0x4429f0		e9dbfeffff		JMP runtime.(*mheap).freeSpan.func1(SB)	

TEXT runtime.mProf_Malloc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
	systemstack(func() {
  0x442a00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442a09		483b6110		CMPQ 0x10(CX), SP	
  0x442a0d		762e			JBE 0x442a3d		
  0x442a0f		4883ec18		SUBQ $0x18, SP		
  0x442a13		48896c2410		MOVQ BP, 0x10(SP)	
  0x442a18		488d6c2410		LEAQ 0x10(SP), BP	
  0x442a1d		488b4208		MOVQ 0x8(DX), AX	
  0x442a21		488b4a10		MOVQ 0x10(DX), CX	
		setprofilebucket(p, b)
  0x442a25		48890424		MOVQ AX, 0(SP)				
  0x442a29		48894c2408		MOVQ CX, 0x8(SP)			
  0x442a2e		e8ed9cfdff		CALL runtime.setprofilebucket(SB)	
	})
  0x442a33		488b6c2410		MOVQ 0x10(SP), BP	
  0x442a38		4883c418		ADDQ $0x18, SP		
  0x442a3c		c3			RET			
	systemstack(func() {
  0x442a3d		e88e1a0000		CALL runtime.morestack(SB)		
  0x442a42		ebbc			JMP runtime.mProf_Malloc.func1(SB)	

TEXT runtime.tracealloc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
		systemstack(func() {
  0x442a50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442a59		483b6110		CMPQ 0x10(CX), SP	
  0x442a5d		7640			JBE 0x442a9f		
  0x442a5f		4883ec28		SUBQ $0x28, SP		
  0x442a63		48896c2420		MOVQ BP, 0x20(SP)	
  0x442a68		488d6c2420		LEAQ 0x20(SP), BP	
  0x442a6d		488b4208		MOVQ 0x8(DX), AX	
  0x442a71		488b4a10		MOVQ 0x10(DX), CX	
  0x442a75		488b5218		MOVQ 0x18(DX), DX	
			traceback(pc, sp, 0, gp)
  0x442a79		48890424		MOVQ AX, 0(SP)			
  0x442a7d		48894c2408		MOVQ CX, 0x8(SP)		
  0x442a82		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x442a8b		4889542418		MOVQ DX, 0x18(SP)		
  0x442a90		e82babffff		CALL runtime.traceback(SB)	
		})
  0x442a95		488b6c2420		MOVQ 0x20(SP), BP	
  0x442a9a		4883c428		ADDQ $0x28, SP		
  0x442a9e		c3			RET			
		systemstack(func() {
  0x442a9f		e82c1a0000		CALL runtime.morestack(SB)		
  0x442aa4		ebaa			JMP runtime.tracealloc.func1(SB)	

TEXT runtime.tracefree.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mprof.go
	systemstack(func() {
  0x442ab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442ab9		483b6110		CMPQ 0x10(CX), SP	
  0x442abd		7640			JBE 0x442aff		
  0x442abf		4883ec28		SUBQ $0x28, SP		
  0x442ac3		48896c2420		MOVQ BP, 0x20(SP)	
  0x442ac8		488d6c2420		LEAQ 0x20(SP), BP	
  0x442acd		488b4208		MOVQ 0x8(DX), AX	
  0x442ad1		488b4a10		MOVQ 0x10(DX), CX	
  0x442ad5		488b5218		MOVQ 0x18(DX), DX	
		traceback(pc, sp, 0, gp)
  0x442ad9		48890424		MOVQ AX, 0(SP)			
  0x442add		48894c2408		MOVQ CX, 0x8(SP)		
  0x442ae2		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x442aeb		4889542418		MOVQ DX, 0x18(SP)		
  0x442af0		e8cbaaffff		CALL runtime.traceback(SB)	
	})
  0x442af5		488b6c2420		MOVQ 0x20(SP), BP	
  0x442afa		4883c428		ADDQ $0x28, SP		
  0x442afe		c3			RET			
	systemstack(func() {
  0x442aff		e8cc190000		CALL runtime.morestack(SB)	
  0x442b04		ebaa			JMP runtime.tracefree.func1(SB)	

TEXT runtime.wbBufFlush.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/mwbbuf.go
	systemstack(func() {
  0x442b10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442b19		483b6110		CMPQ 0x10(CX), SP	
  0x442b1d		7635			JBE 0x442b54		
  0x442b1f		4883ec10		SUBQ $0x10, SP		
  0x442b23		48896c2408		MOVQ BP, 0x8(SP)	
  0x442b28		488d6c2408		LEAQ 0x8(SP), BP	
		wbBufFlush1(getg().m.p.ptr())
  0x442b2d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX		
  0x442b36		488b4030		MOVQ 0x30(AX), AX		
  0x442b3a		488b80d0000000		MOVQ 0xd0(AX), AX		
  0x442b41		48890424		MOVQ AX, 0(SP)			
  0x442b45		e886bafdff		CALL runtime.wbBufFlush1(SB)	
	})
  0x442b4a		488b6c2408		MOVQ 0x8(SP), BP	
  0x442b4f		4883c410		ADDQ $0x10, SP		
  0x442b53		c3			RET			
	systemstack(func() {
  0x442b54		e8171a0000		CALL runtime.morestack_noctxt(SB)	
  0x442b59		ebb5			JMP runtime.wbBufFlush.func1(SB)	

TEXT runtime.futexwakeup.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/os_linux.go
	systemstack(func() {
  0x442b60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442b69		483b6110		CMPQ 0x10(CX), SP	
  0x442b6d		0f8687000000		JBE 0x442bfa		
  0x442b73		4883ec28		SUBQ $0x28, SP		
  0x442b77		48896c2420		MOVQ BP, 0x20(SP)	
  0x442b7c		488d6c2420		LEAQ 0x20(SP), BP	
  0x442b81		488b4208		MOVQ 0x8(DX), AX	
  0x442b85		4889442418		MOVQ AX, 0x18(SP)	
		print("futexwakeup addr=", addr, " returned ", ret, "\n")
  0x442b8a		48634a10		MOVSXD 0x10(DX), CX		
  0x442b8e		48894c2410		MOVQ CX, 0x10(SP)		
  0x442b93		e868effdff		CALL runtime.printlock(SB)	
  0x442b98		488d059c800200		LEAQ 0x2809c(IP), AX		
  0x442b9f		48890424		MOVQ AX, 0(SP)			
  0x442ba3		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x442bac		e88ff8fdff		CALL runtime.printstring(SB)	
  0x442bb1		488b442418		MOVQ 0x18(SP), AX		
  0x442bb6		48890424		MOVQ AX, 0(SP)			
  0x442bba		e841f8fdff		CALL runtime.printpointer(SB)	
  0x442bbf		488d05d8760200		LEAQ 0x276d8(IP), AX		
  0x442bc6		48890424		MOVQ AX, 0(SP)			
  0x442bca		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x442bd3		e868f8fdff		CALL runtime.printstring(SB)	
  0x442bd8		488b442410		MOVQ 0x10(SP), AX		
  0x442bdd		48890424		MOVQ AX, 0(SP)			
  0x442be1		e89af6fdff		CALL runtime.printint(SB)	
  0x442be6		e8a5f1fdff		CALL runtime.printnl(SB)	
  0x442beb		e890effdff		CALL runtime.printunlock(SB)	
	})
  0x442bf0		488b6c2420		MOVQ 0x20(SP), BP	
  0x442bf5		4883c428		ADDQ $0x28, SP		
  0x442bf9		c3			RET			
	systemstack(func() {
  0x442bfa		e8d1180000		CALL runtime.morestack(SB)		
  0x442bff		e95cffffff		JMP runtime.futexwakeup.func1(SB)	

TEXT runtime.newdefer.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
			systemstack(func() {
  0x442c10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442c19		483b6110		CMPQ 0x10(CX), SP	
  0x442c1d		0f86ba010000		JBE 0x442ddd		
  0x442c23		4883ec70		SUBQ $0x70, SP		
  0x442c27		48896c2468		MOVQ BP, 0x68(SP)	
  0x442c2c		488d6c2468		LEAQ 0x68(SP), BP	
  0x442c31		488b4208		MOVQ 0x8(DX), AX	
  0x442c35		4889442450		MOVQ AX, 0x50(SP)	
  0x442c3a		488b4a10		MOVQ 0x10(DX), CX	
  0x442c3e		48894c2440		MOVQ CX, 0x40(SP)	
				lock(&sched.deferlock)
  0x442c43		488d15764d0600		LEAQ runtime.sched+160(SB), DX	
  0x442c4a		48891424		MOVQ DX, 0(SP)			
  0x442c4e		e8cd68fcff		CALL runtime.lock(SB)		
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x442c53		488b4c2450		MOVQ 0x50(SP), CX		
  0x442c58		8401			TESTB AL, 0(CX)			
  0x442c5a		488b542440		MOVQ 0x40(SP), DX		
  0x442c5f		4883fa05		CMPQ $0x5, DX			
  0x442c63		0f836d010000		JAE 0x442dd6			
  0x442c69		488d1c52		LEAQ 0(DX)(DX*2), BX		
  0x442c6d		488b74d968		MOVQ 0x68(CX)(BX*8), SI		
  0x442c72		4c8b44d960		MOVQ 0x60(CX)(BX*8), R8		
  0x442c77		4c8d4cd958		LEAQ 0x58(CX)(BX*8), R9		
  0x442c7c		48d1ee			SHRQ $0x1, SI			
  0x442c7f		4939f0			CMPQ SI, R8			
  0x442c82		0f8d34010000		JGE 0x442dbc			
  0x442c88		488d35914c0600		LEAQ runtime.sched(SB), SI	
  0x442c8f		488b84d6a8000000	MOVQ 0xa8(SI)(DX*8), AX		
  0x442c97		488dbcd6a8000000	LEAQ 0xa8(SI)(DX*8), DI		
  0x442c9f		4885c0			TESTQ AX, AX			
  0x442ca2		0f8414010000		JE 0x442dbc			
					sched.deferpool[sc] = d.link
  0x442ca8		448b05610d0800		MOVL runtime.writeBarrier(SB), R8	
  0x442caf		4c8b5028		MOVQ 0x28(AX), R10			
  0x442cb3		4c8d5828		LEAQ 0x28(AX), R11			
  0x442cb7		4585c0			TESTL R8, R8				
  0x442cba		0f85df000000		JNE 0x442d9f				
  0x442cc0		4c8994d6a8000000	MOVQ R10, 0xa8(SI)(DX*8)		
					d.link = nil
  0x442cc8		48c7402800000000	MOVQ $0x0, 0x28(AX)	
					pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x442cd0		4c8b44d960		MOVQ 0x60(CX)(BX*8), R8			
  0x442cd5		4c8b54d958		MOVQ 0x58(CX)(BX*8), R10		
  0x442cda		4c8b5cd968		MOVQ 0x68(CX)(BX*8), R11		
  0x442cdf		4d8d6001		LEAQ 0x1(R8), R12			
  0x442ce3		4d39dc			CMPQ R11, R12				
  0x442ce6		7f2a			JG 0x442d12				
  0x442ce8		4d8d4801		LEAQ 0x1(R8), R9			
  0x442cec		4c894cd960		MOVQ R9, 0x60(CX)(BX*8)			
  0x442cf1		8b1d190d0800		MOVL runtime.writeBarrier(SB), BX	
  0x442cf7		4b8d3cc2		LEAQ 0(R10)(R8*8), DI			
  0x442cfb		85db			TESTL BX, BX				
  0x442cfd		7509			JNE 0x442d08				
  0x442cff		4b8904c2		MOVQ AX, 0(R10)(R8*8)			
  0x442d03		e94bffffff		JMP 0x442c53				
  0x442d08		e8933b0000		CALL runtime.gcWriteBarrier(SB)		
  0x442d0d		e941ffffff		JMP 0x442c53				
  0x442d12		4c894c2460		MOVQ R9, 0x60(SP)			
  0x442d17		4889442458		MOVQ AX, 0x58(SP)			
  0x442d1c		48895c2448		MOVQ BX, 0x48(SP)			
  0x442d21		488d05580e0100		LEAQ 0x10e58(IP), AX			
  0x442d28		48890424		MOVQ AX, 0(SP)				
  0x442d2c		4c89542408		MOVQ R10, 0x8(SP)			
  0x442d31		4c89442410		MOVQ R8, 0x10(SP)			
  0x442d36		4c895c2418		MOVQ R11, 0x18(SP)			
  0x442d3b		4c89642420		MOVQ R12, 0x20(SP)			
  0x442d40		e81b0bffff		CALL runtime.growslice(SB)		
  0x442d45		488b442428		MOVQ 0x28(SP), AX			
  0x442d4a		488b4c2430		MOVQ 0x30(SP), CX			
  0x442d4f		488b542438		MOVQ 0x38(SP), DX			
  0x442d54		488b5c2448		MOVQ 0x48(SP), BX			
  0x442d59		488b742450		MOVQ 0x50(SP), SI			
  0x442d5e		488954de68		MOVQ DX, 0x68(SI)(BX*8)			
  0x442d63		8b15a70c0800		MOVL runtime.writeBarrier(SB), DX	
  0x442d69		85d2			TESTL DX, DX				
  0x442d6b		7526			JNE 0x442d93				
  0x442d6d		488944de58		MOVQ AX, 0x58(SI)(BX*8)			
  0x442d72		488b542440		MOVQ 0x40(SP), DX			
  0x442d77		488d35a24b0600		LEAQ runtime.sched(SB), SI		
  0x442d7e		4989c8			MOVQ CX, R8				
  0x442d81		4989c2			MOVQ AX, R10				
  0x442d84		488b442458		MOVQ 0x58(SP), AX			
  0x442d89		488b4c2450		MOVQ 0x50(SP), CX			
  0x442d8e		e955ffffff		JMP 0x442ce8				
  0x442d93		488b7c2460		MOVQ 0x60(SP), DI			
  0x442d98		e8033b0000		CALL runtime.gcWriteBarrier(SB)		
  0x442d9d		ebd3			JMP 0x442d72				
  0x442d9f		4989c0			MOVQ AX, R8				
  0x442da2		4c89d0			MOVQ R10, AX				
					sched.deferpool[sc] = d.link
  0x442da5		e8f63a0000		CALL runtime.gcWriteBarrier(SB)	
  0x442daa		4c89df			MOVQ R11, DI			
					d.link = nil
  0x442dad		31c0			XORL AX, AX			
  0x442daf		e8ec3a0000		CALL runtime.gcWriteBarrier(SB)	
  0x442db4		4c89c0			MOVQ R8, AX			
					sched.deferpool[sc] = d.link
  0x442db7		e914ffffff		JMP 0x442cd0		
				unlock(&sched.deferlock)
  0x442dbc		488d05fd4b0600		LEAQ runtime.sched+160(SB), AX	
  0x442dc3		48890424		MOVQ AX, 0(SP)			
  0x442dc7		e8f468fcff		CALL runtime.unlock(SB)		
			})
  0x442dcc		488b6c2468		MOVQ 0x68(SP), BP	
  0x442dd1		4883c470		ADDQ $0x70, SP		
  0x442dd5		c3			RET			
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x442dd6		e865ccfdff		CALL runtime.panicindex(SB)	
  0x442ddb		0f0b			UD2				
			systemstack(func() {
  0x442ddd		e8ee160000		CALL runtime.morestack(SB)	
  0x442de2		e929feffff		JMP runtime.newdefer.func1(SB)	

TEXT runtime.newdefer.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
		systemstack(func() {
  0x442df0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442df9		483b6110		CMPQ 0x10(CX), SP	
  0x442dfd		0f862a010000		JBE 0x442f2d		
  0x442e03		4883ec30		SUBQ $0x30, SP		
  0x442e07		48896c2428		MOVQ BP, 0x28(SP)	
  0x442e0c		488d6c2428		LEAQ 0x28(SP), BP	
  0x442e11		488b4210		MOVQ 0x10(DX), AX	
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x442e15		48634a08		MOVSXD 0x8(DX), CX	
	if siz <= minDeferArgs {
  0x442e19		4885c9			TESTQ CX, CX		
  0x442e1c		0f87f4000000		JA 0x442f16		
  0x442e22		b930000000		MOVL $0x30, CX		
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x442e27		4889442420		MOVQ AX, 0x20(SP)	
	if size < _MaxSmallSize {
  0x442e2c		4881f900800000		CMPQ $0x8000, CX	
  0x442e33		0f83ba000000		JAE 0x442ef3		
		if size <= smallSizeMax-8 {
  0x442e39		4881f9f8030000		CMPQ $0x3f8, CX		
  0x442e40		777f			JA 0x442ec1		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x442e42		4883c107		ADDQ $0x7, CX				
  0x442e46		48c1e903		SHRQ $0x3, CX				
  0x442e4a		4881f981000000		CMPQ $0x81, CX				
  0x442e51		0f83cf000000		JAE 0x442f26				
  0x442e57		488d15c2220600		LEAQ runtime.size_to_class8(SB), DX	
  0x442e5e		0fb60c11		MOVZX 0(CX)(DX*1), CX			
  0x442e62		4883f943		CMPQ $0x43, CX				
  0x442e66		0f83ba000000		JAE 0x442f26				
  0x442e6c		488d154d230600		LEAQ runtime.class_to_size(SB), DX	
  0x442e73		0fb70c4a		MOVZX 0(DX)(CX*2), CX			
			d = (*_defer)(mallocgc(total, deferType, true))
  0x442e77		48890c24		MOVQ CX, 0(SP)				
  0x442e7b		488b05c6470600		MOVQ runtime.deferType(SB), AX		
  0x442e82		4889442408		MOVQ AX, 0x8(SP)			
  0x442e87		c644241001		MOVB $0x1, 0x10(SP)			
  0x442e8c		e87f77fcff		CALL runtime.mallocgc(SB)		
  0x442e91		8b05790b0800		MOVL runtime.writeBarrier(SB), AX	
  0x442e97		488b4c2418		MOVQ 0x18(SP), CX			
  0x442e9c		85c0			TESTL AX, AX				
  0x442e9e		7512			JNE 0x442eb2				
  0x442ea0		488b442420		MOVQ 0x20(SP), AX			
  0x442ea5		488908			MOVQ CX, 0(AX)				
		})
  0x442ea8		488b6c2428		MOVQ 0x28(SP), BP	
  0x442ead		4883c430		ADDQ $0x30, SP		
  0x442eb1		c3			RET			
  0x442eb2		488b7c2420		MOVQ 0x20(SP), DI	
  0x442eb7		4889c8			MOVQ CX, AX		
			d = (*_defer)(mallocgc(total, deferType, true))
  0x442eba		e8e1390000		CALL runtime.gcWriteBarrier(SB)	
  0x442ebf		ebe7			JMP 0x442ea8			
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x442ec1		4881c17ffcffff		ADDQ $-0x381, CX			
  0x442ec8		48c1e907		SHRQ $0x7, CX				
  0x442ecc		4881f9f9000000		CMPQ $0xf9, CX				
  0x442ed3		734a			JAE 0x442f1f				
  0x442ed5		488d1584230600		LEAQ runtime.size_to_class128(SB), DX	
  0x442edc		0fb60c0a		MOVZX 0(DX)(CX*1), CX			
  0x442ee0		4883f943		CMPQ $0x43, CX				
  0x442ee4		7339			JAE 0x442f1f				
  0x442ee6		488d15d3220600		LEAQ runtime.class_to_size(SB), DX	
  0x442eed		0fb70c4a		MOVZX 0(DX)(CX*2), CX			
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x442ef1		eb84			JMP 0x442e77		
	if size+_PageSize < size {
  0x442ef3		488d9100200000		LEAQ 0x2000(CX), DX	
  0x442efa		4839ca			CMPQ CX, DX		
  0x442efd		0f8274ffffff		JB 0x442e77		
	return (n + a - 1) &^ (a - 1)
  0x442f03		4881c1ff1f0000		ADDQ $0x1fff, CX	
  0x442f0a		4881e100e0ffff		ANDQ $-0x2000, CX	
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x442f11		e961ffffff		JMP 0x442e77		
	return deferHeaderSize + siz
  0x442f16		4883c130		ADDQ $0x30, CX		
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x442f1a		e908ffffff		JMP 0x442e27		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x442f1f		e81ccbfdff		CALL runtime.panicindex(SB)	
  0x442f24		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x442f26		e815cbfdff		CALL runtime.panicindex(SB)	
  0x442f2b		0f0b			UD2				
		systemstack(func() {
  0x442f2d		e89e150000		CALL runtime.morestack(SB)	
  0x442f32		e9b9feffff		JMP runtime.newdefer.func2(SB)	

TEXT runtime.freedefer.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
		systemstack(func() {
  0x442f40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442f49		483b6110		CMPQ 0x10(CX), SP	
  0x442f4d		0f8673010000		JBE 0x4430c6		
  0x442f53		4883ec28		SUBQ $0x28, SP		
  0x442f57		48896c2420		MOVQ BP, 0x20(SP)	
  0x442f5c		488d6c2420		LEAQ 0x20(SP), BP	
  0x442f61		488b4a08		MOVQ 0x8(DX), CX	
  0x442f65		488b5210		MOVQ 0x10(DX), DX	
  0x442f69		31c0			XORL AX, AX		
  0x442f6b		4889c3			MOVQ AX, BX		
			for len(pp.deferpool[sc]) > cap(pp.deferpool[sc])/2 {
  0x442f6e		eb03			JMP 0x442f73			
  0x442f70		4c89d8			MOVQ R11, AX			
  0x442f73		8401			TESTB AL, 0(CX)			
  0x442f75		4883fa05		CMPQ $0x5, DX			
  0x442f79		0f8340010000		JAE 0x4430bf			
  0x442f7f		488d3452		LEAQ 0(DX)(DX*2), SI		
  0x442f83		4c8b44f168		MOVQ 0x68(CX)(SI*8), R8		
  0x442f88		4c8b4cf160		MOVQ 0x60(CX)(SI*8), R9		
  0x442f8d		4c8b54f158		MOVQ 0x58(CX)(SI*8), R10	
  0x442f92		49d1e8			SHRQ $0x1, R8			
  0x442f95		4d39c1			CMPQ R8, R9			
  0x442f98		0f8e81000000		JLE 0x44301f			
				d := pp.deferpool[sc][n-1]
  0x442f9e		4d8d41ff		LEAQ -0x1(R9), R8		
  0x442fa2		4d39c8			CMPQ R9, R8			
  0x442fa5		0f830d010000		JAE 0x4430b8			
  0x442fab		4f8b5ccaf8		MOVQ -0x8(R10)(R9*8), R11	
  0x442fb0		4b8d7ccaf8		LEAQ -0x8(R10)(R9*8), DI	
				pp.deferpool[sc][n-1] = nil
  0x442fb5		448b25540a0800		MOVL runtime.writeBarrier(SB), R12	
  0x442fbc		4585e4			TESTL R12, R12				
  0x442fbf		754f			JNE 0x443010				
  0x442fc1		4bc744caf800000000	MOVQ $0x0, -0x8(R10)(R9*8)		
				pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x442fca		4c8b4cf168		MOVQ 0x68(CX)(SI*8), R9	
  0x442fcf		4d39c8			CMPQ R9, R8		
  0x442fd2		0f87d9000000		JA 0x4430b1		
  0x442fd8		4c8944f160		MOVQ R8, 0x60(CX)(SI*8)	
				if first == nil {
  0x442fdd		4885db			TESTQ BX, BX		
  0x442fe0		7426			JE 0x443008		
					last.link = d
  0x442fe2		8400			TESTB AL, 0(AX)				
  0x442fe4		8b35260a0800		MOVL runtime.writeBarrier(SB), SI	
  0x442fea		488d7828		LEAQ 0x28(AX), DI			
  0x442fee		85f6			TESTL SI, SI				
  0x442ff0		7509			JNE 0x442ffb				
  0x442ff2		4c895828		MOVQ R11, 0x28(AX)			
  0x442ff6		e975ffffff		JMP 0x442f70				
  0x442ffb		4c89d8			MOVQ R11, AX				
  0x442ffe		e89d380000		CALL runtime.gcWriteBarrier(SB)		
  0x443003		e968ffffff		JMP 0x442f70				
  0x443008		4c89db			MOVQ R11, BX				
					first = d
  0x44300b		e960ffffff		JMP 0x442f70		
  0x443010		4989c1			MOVQ AX, R9		
				pp.deferpool[sc][n-1] = nil
  0x443013		31c0			XORL AX, AX			
  0x443015		e886380000		CALL runtime.gcWriteBarrier(SB)	
  0x44301a		4c89c8			MOVQ R9, AX			
  0x44301d		ebab			JMP 0x442fca			
  0x44301f		4889542408		MOVQ DX, 0x8(SP)		
  0x443024		48895c2418		MOVQ BX, 0x18(SP)		
  0x443029		4889442410		MOVQ AX, 0x10(SP)		
			lock(&sched.deferlock)
  0x44302e		488d058b490600		LEAQ runtime.sched+160(SB), AX	
  0x443035		48890424		MOVQ AX, 0(SP)			
  0x443039		e8e264fcff		CALL runtime.lock(SB)		
  0x44303e		488b442410		MOVQ 0x10(SP), AX		
			last.link = sched.deferpool[sc]
  0x443043		8400			TESTB AL, 0(AX)				
  0x443045		8b0dc5090800		MOVL runtime.writeBarrier(SB), CX	
  0x44304b		488d7828		LEAQ 0x28(AX), DI			
  0x44304f		488b542408		MOVQ 0x8(SP), DX			
  0x443054		488d1dc5480600		LEAQ runtime.sched(SB), BX		
  0x44305b		488bb4d3a8000000	MOVQ 0xa8(BX)(DX*8), SI			
  0x443063		4c8d84d3a8000000	LEAQ 0xa8(BX)(DX*8), R8			
  0x44306b		85c9			TESTL CX, CX				
  0x44306d		752b			JNE 0x44309a				
  0x44306f		48897028		MOVQ SI, 0x28(AX)			
  0x443073		488b442418		MOVQ 0x18(SP), AX			
			sched.deferpool[sc] = first
  0x443078		488984d3a8000000	MOVQ AX, 0xa8(BX)(DX*8)	
			unlock(&sched.deferlock)
  0x443080		488d0539490600		LEAQ runtime.sched+160(SB), AX	
  0x443087		48890424		MOVQ AX, 0(SP)			
  0x44308b		e83066fcff		CALL runtime.unlock(SB)		
		})
  0x443090		488b6c2420		MOVQ 0x20(SP), BP	
  0x443095		4883c428		ADDQ $0x28, SP		
  0x443099		c3			RET			
  0x44309a		4889f0			MOVQ SI, AX		
			last.link = sched.deferpool[sc]
  0x44309d		e8fe370000		CALL runtime.gcWriteBarrier(SB)	
  0x4430a2		4c89c7			MOVQ R8, DI			
  0x4430a5		488b442418		MOVQ 0x18(SP), AX		
			sched.deferpool[sc] = first
  0x4430aa		e8f1370000		CALL runtime.gcWriteBarrier(SB)	
			last.link = sched.deferpool[sc]
  0x4430af		ebcf			JMP 0x443080		
				pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x4430b1		e8fac9fdff		CALL runtime.panicslice(SB)	
  0x4430b6		0f0b			UD2				
				d := pp.deferpool[sc][n-1]
  0x4430b8		e883c9fdff		CALL runtime.panicindex(SB)	
  0x4430bd		0f0b			UD2				
			for len(pp.deferpool[sc]) > cap(pp.deferpool[sc])/2 {
  0x4430bf		e87cc9fdff		CALL runtime.panicindex(SB)	
  0x4430c4		0f0b			UD2				
		systemstack(func() {
  0x4430c6		e805140000		CALL runtime.morestack(SB)	
  0x4430cb		e970feffff		JMP runtime.freedefer.func1(SB)	

TEXT runtime.preprintpanics.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
	defer func() {
  0x4430d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4430d9		483b6110		CMPQ 0x10(CX), SP	
  0x4430dd		764b			JBE 0x44312a		
  0x4430df		4883ec20		SUBQ $0x20, SP		
  0x4430e3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4430e8		488d6c2418		LEAQ 0x18(SP), BP	
		if recover() != nil {
  0x4430ed		488d442428		LEAQ 0x28(SP), AX		
  0x4430f2		48890424		MOVQ AX, 0(SP)			
  0x4430f6		e8f5dffdff		CALL runtime.gorecover(SB)	
  0x4430fb		488b442408		MOVQ 0x8(SP), AX		
  0x443100		4885c0			TESTQ AX, AX			
  0x443103		750a			JNE 0x44310f			
  0x443105		488b6c2418		MOVQ 0x18(SP), BP		
  0x44310a		4883c420		ADDQ $0x20, SP			
  0x44310e		c3			RET				
			throw("panic while printing panic value")
  0x44310f		488d050d970200		LEAQ 0x2970d(IP), AX	
  0x443116		48890424		MOVQ AX, 0(SP)		
  0x44311a		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x443123		e8a8e0fdff		CALL runtime.throw(SB)	
  0x443128		0f0b			UD2			
	defer func() {
  0x44312a		e841140000		CALL runtime.morestack_noctxt(SB)	
  0x44312f		eb9f			JMP runtime.preprintpanics.func1(SB)	

TEXT runtime.dopanic.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/panic.go
	systemstack(func() {
  0x443140		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443149		483b6110		CMPQ 0x10(CX), SP	
  0x44314d		7637			JBE 0x443186		
  0x44314f		4883ec20		SUBQ $0x20, SP		
  0x443153		48896c2418		MOVQ BP, 0x18(SP)	
  0x443158		488d6c2418		LEAQ 0x18(SP), BP	
  0x44315d		488b4208		MOVQ 0x8(DX), AX	
  0x443161		488b4a10		MOVQ 0x10(DX), CX	
  0x443165		488b5218		MOVQ 0x18(DX), DX	
		dopanic_m(gp, pc, sp) // should never return
  0x443169		48890424		MOVQ AX, 0(SP)			
  0x44316d		48894c2408		MOVQ CX, 0x8(SP)		
  0x443172		4889542410		MOVQ DX, 0x10(SP)		
  0x443177		e814e4fdff		CALL runtime.dopanic_m(SB)	
	})
  0x44317c		488b6c2418		MOVQ 0x18(SP), BP	
  0x443181		4883c420		ADDQ $0x20, SP		
  0x443185		c3			RET			
	systemstack(func() {
  0x443186		e845130000		CALL runtime.morestack(SB)	
  0x44318b		ebb3			JMP runtime.dopanic.func1(SB)	

TEXT runtime.hexdumpWords.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/print.go
	p1 := func(x uintptr) {
  0x443190		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443199		483b6110		CMPQ 0x10(CX), SP	
  0x44319d		0f8694000000		JBE 0x443237		
  0x4431a3		4883ec30		SUBQ $0x30, SP		
  0x4431a7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4431ac		488d6c2428		LEAQ 0x28(SP), BP	
		var buf [2 * sys.PtrSize]byte
  0x4431b1		0f57c0			XORPS X0, X0		
  0x4431b4		0f11442418		MOVUPS X0, 0x18(SP)	
	p1 := func(x uintptr) {
  0x4431b9		488b442438		MOVQ 0x38(SP), AX	
  0x4431be		b90f000000		MOVL $0xf, CX		
		for i := len(buf) - 1; i >= 0; i-- {
  0x4431c3		eb0a			JMP 0x4431cf		
  0x4431c5		48ffc9			DECQ CX			
			x >>= 4
  0x4431c8		48c1ea04		SHRQ $0x4, DX		
  0x4431cc		4889d0			MOVQ DX, AX		
		for i := len(buf) - 1; i >= 0; i-- {
  0x4431cf		4885c9			TESTQ CX, CX		
  0x4431d2		7c2b			JL 0x4431ff		
  0x4431d4		4889c2			MOVQ AX, DX		
			if x&0xF < 10 {
  0x4431d7		4883e00f		ANDQ $0xf, AX		
  0x4431db		4883f80a		CMPQ $0xa, AX		
  0x4431df		730f			JAE 0x4431f0		
				buf[i] = byte(x&0xF) + '0'
  0x4431e1		4883f910		CMPQ $0x10, CX		
  0x4431e5		7349			JAE 0x443230		
  0x4431e7		83c030			ADDL $0x30, AX		
  0x4431ea		88440c18		MOVB AL, 0x18(SP)(CX*1)	
  0x4431ee		ebd5			JMP 0x4431c5		
				buf[i] = byte(x&0xF) - 10 + 'a'
  0x4431f0		4883f910		CMPQ $0x10, CX		
  0x4431f4		7333			JAE 0x443229		
  0x4431f6		83c057			ADDL $0x57, AX		
  0x4431f9		88440c18		MOVB AL, 0x18(SP)(CX*1)	
  0x4431fd		ebc6			JMP 0x4431c5		
		gwrite(buf[:])
  0x4431ff		488d442418		LEAQ 0x18(SP), AX	
  0x443204		48890424		MOVQ AX, 0(SP)		
  0x443208		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x443211		48c744241010000000	MOVQ $0x10, 0x10(SP)	
  0x44321a		e8d1e9fdff		CALL runtime.gwrite(SB)	
	}
  0x44321f		488b6c2428		MOVQ 0x28(SP), BP	
  0x443224		4883c430		ADDQ $0x30, SP		
  0x443228		c3			RET			
				buf[i] = byte(x&0xF) - 10 + 'a'
  0x443229		e812c8fdff		CALL runtime.panicindex(SB)	
  0x44322e		0f0b			UD2				
				buf[i] = byte(x&0xF) + '0'
  0x443230		e80bc8fdff		CALL runtime.panicindex(SB)	
  0x443235		0f0b			UD2				
	p1 := func(x uintptr) {
  0x443237		e834130000		CALL runtime.morestack_noctxt(SB)	
  0x44323c		e94fffffff		JMP runtime.hexdumpWords.func1(SB)	

TEXT runtime.main.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	systemstack(func() {
  0x443250		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443259		483b6110		CMPQ 0x10(CX), SP	
  0x44325d		7631			JBE 0x443290		
  0x44325f		4883ec18		SUBQ $0x18, SP		
  0x443263		48896c2410		MOVQ BP, 0x10(SP)	
  0x443268		488d6c2410		LEAQ 0x10(SP), BP	
		newm(sysmon, nil)
  0x44326d		488d05acaf0200		LEAQ 0x2afac(IP), AX	
  0x443274		48890424		MOVQ AX, 0(SP)		
  0x443278		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x443281		e8ba35feff		CALL runtime.newm(SB)	
	})
  0x443286		488b6c2410		MOVQ 0x10(SP), BP	
  0x44328b		4883c418		ADDQ $0x18, SP		
  0x44328f		c3			RET			
	systemstack(func() {
  0x443290		e8db120000		CALL runtime.morestack_noctxt(SB)	
  0x443295		ebb9			JMP runtime.main.func1(SB)		

TEXT runtime.main.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	defer func() {
  0x4432a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4432a9		483b6110		CMPQ 0x10(CX), SP	
  0x4432ad		7628			JBE 0x4432d7		
  0x4432af		4883ec08		SUBQ $0x8, SP		
  0x4432b3		48892c24		MOVQ BP, 0(SP)		
  0x4432b7		488d2c24		LEAQ 0(SP), BP		
  0x4432bb		488b442410		MOVQ 0x10(SP), AX	
		if needUnlock {
  0x4432c0		0fb600			MOVZX 0(AX), AX		
  0x4432c3		84c0			TESTL AL, AL		
  0x4432c5		7509			JNE 0x4432d0		
  0x4432c7		488b2c24		MOVQ 0(SP), BP		
  0x4432cb		4883c408		ADDQ $0x8, SP		
  0x4432cf		c3			RET			
			unlockOSThread()
  0x4432d0		e8cb7afeff		CALL runtime.unlockOSThread(SB)	
  0x4432d5		ebf0			JMP 0x4432c7			
	defer func() {
  0x4432d7		e894120000		CALL runtime.morestack_noctxt(SB)	
  0x4432dc		ebc2			JMP runtime.main.func2(SB)		

TEXT runtime.goready.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	systemstack(func() {
  0x4432e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4432e9		483b6110		CMPQ 0x10(CX), SP	
  0x4432ed		7633			JBE 0x443322		
  0x4432ef		4883ec20		SUBQ $0x20, SP		
  0x4432f3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4432f8		488d6c2418		LEAQ 0x18(SP), BP	
  0x4432fd		488b4208		MOVQ 0x8(DX), AX	
  0x443301		488b4a10		MOVQ 0x10(DX), CX	
		ready(gp, traceskip, true)
  0x443305		48890424		MOVQ AX, 0(SP)		
  0x443309		48894c2408		MOVQ CX, 0x8(SP)	
  0x44330e		c644241001		MOVB $0x1, 0x10(SP)	
  0x443313		e8380cfeff		CALL runtime.ready(SB)	
	})
  0x443318		488b6c2418		MOVQ 0x18(SP), BP	
  0x44331d		4883c420		ADDQ $0x20, SP		
  0x443321		c3			RET			
	systemstack(func() {
  0x443322		e8a9110000		CALL runtime.morestack(SB)	
  0x443327		ebb7			JMP runtime.goready.func1(SB)	

TEXT runtime.casgstatus.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x443330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443339		483b6110		CMPQ 0x10(CX), SP	
  0x44333d		0f8696000000		JBE 0x4433d9		
  0x443343		4883ec28		SUBQ $0x28, SP		
  0x443347		48896c2420		MOVQ BP, 0x20(SP)	
  0x44334c		488d6c2420		LEAQ 0x20(SP), BP	
			print("runtime: casgstatus: oldval=", hex(oldval), " newval=", hex(newval), "\n")
  0x443351		8b4208			MOVL 0x8(DX), AX		
  0x443354		4889442418		MOVQ AX, 0x18(SP)		
  0x443359		8b4a0c			MOVL 0xc(DX), CX		
  0x44335c		48894c2410		MOVQ CX, 0x10(SP)		
  0x443361		e89ae7fdff		CALL runtime.printlock(SB)	
  0x443366		488d05458e0200		LEAQ 0x28e45(IP), AX		
  0x44336d		48890424		MOVQ AX, 0(SP)			
  0x443371		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x44337a		e8c1f0fdff		CALL runtime.printstring(SB)	
  0x44337f		488b442418		MOVQ 0x18(SP), AX		
  0x443384		48890424		MOVQ AX, 0(SP)			
  0x443388		e863effdff		CALL runtime.printhex(SB)	
  0x44338d		488d052b6c0200		LEAQ 0x26c2b(IP), AX		
  0x443394		48890424		MOVQ AX, 0(SP)			
  0x443398		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4433a1		e89af0fdff		CALL runtime.printstring(SB)	
  0x4433a6		488b442410		MOVQ 0x10(SP), AX		
  0x4433ab		48890424		MOVQ AX, 0(SP)			
  0x4433af		e83ceffdff		CALL runtime.printhex(SB)	
  0x4433b4		e8d7e9fdff		CALL runtime.printnl(SB)	
  0x4433b9		e8c2e7fdff		CALL runtime.printunlock(SB)	
			throw("casgstatus: bad incoming values")
  0x4433be		488d0589920200		LEAQ 0x29289(IP), AX	
  0x4433c5		48890424		MOVQ AX, 0(SP)		
  0x4433c9		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x4433d2		e8f9ddfdff		CALL runtime.throw(SB)	
  0x4433d7		0f0b			UD2			
		systemstack(func() {
  0x4433d9		e8f2100000		CALL runtime.morestack(SB)		
  0x4433de		e94dffffff		JMP runtime.casgstatus.func1(SB)	

TEXT runtime.casgstatus.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x4433f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4433f9		483b6110		CMPQ 0x10(CX), SP	
  0x4433fd		0f86e0000000		JBE 0x4434e3		
  0x443403		4883ec30		SUBQ $0x30, SP		
  0x443407		48896c2428		MOVQ BP, 0x28(SP)	
  0x44340c		488d6c2428		LEAQ 0x28(SP), BP	
  0x443411		488b4210		MOVQ 0x10(DX), AX	
			print("runtime: casgstatus ", hex(oldval), "->", hex(newval), " gp.status=", hex(gp.atomicstatus), " gp.gcscanvalid=true\n")
  0x443415		8b4a08			MOVL 0x8(DX), CX		
  0x443418		48894c2420		MOVQ CX, 0x20(SP)		
  0x44341d		8b520c			MOVL 0xc(DX), DX		
  0x443420		4889542418		MOVQ DX, 0x18(SP)		
  0x443425		8b8090000000		MOVL 0x90(AX), AX		
  0x44342b		4889442410		MOVQ AX, 0x10(SP)		
  0x443430		e8cbe6fdff		CALL runtime.printlock(SB)	
  0x443435		488d05817d0200		LEAQ 0x27d81(IP), AX		
  0x44343c		48890424		MOVQ AX, 0(SP)			
  0x443440		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x443449		e8f2effdff		CALL runtime.printstring(SB)	
  0x44344e		488b442420		MOVQ 0x20(SP), AX		
  0x443453		48890424		MOVQ AX, 0(SP)			
  0x443457		e894eefdff		CALL runtime.printhex(SB)	
  0x44345c		488d050b680200		LEAQ 0x2680b(IP), AX		
  0x443463		48890424		MOVQ AX, 0(SP)			
  0x443467		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x443470		e8cbeffdff		CALL runtime.printstring(SB)	
  0x443475		488b442418		MOVQ 0x18(SP), AX		
  0x44347a		48890424		MOVQ AX, 0(SP)			
  0x44347e		e86deefdff		CALL runtime.printhex(SB)	
  0x443483		488d052f6f0200		LEAQ 0x26f2f(IP), AX		
  0x44348a		48890424		MOVQ AX, 0(SP)			
  0x44348e		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x443497		e8a4effdff		CALL runtime.printstring(SB)	
  0x44349c		488b442410		MOVQ 0x10(SP), AX		
  0x4434a1		48890424		MOVQ AX, 0(SP)			
  0x4434a5		e846eefdff		CALL runtime.printhex(SB)	
  0x4434aa		488d05847d0200		LEAQ 0x27d84(IP), AX		
  0x4434b1		48890424		MOVQ AX, 0(SP)			
  0x4434b5		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4434be		e87deffdff		CALL runtime.printstring(SB)	
  0x4434c3		e8b8e6fdff		CALL runtime.printunlock(SB)	
			throw("casgstatus")
  0x4434c8		488d056f6e0200		LEAQ 0x26e6f(IP), AX	
  0x4434cf		48890424		MOVQ AX, 0(SP)		
  0x4434d3		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x4434dc		e8efdcfdff		CALL runtime.throw(SB)	
  0x4434e1		0f0b			UD2			
		systemstack(func() {
  0x4434e3		e8e80f0000		CALL runtime.morestack(SB)		
  0x4434e8		e903ffffff		JMP runtime.casgstatus.func2(SB)	

TEXT runtime.casgstatus.func3(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
			systemstack(func() {
  0x4434f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4434f9		483b6110		CMPQ 0x10(CX), SP	
  0x4434fd		7629			JBE 0x443528		
  0x4434ff		4883ec18		SUBQ $0x18, SP		
  0x443503		48896c2410		MOVQ BP, 0x10(SP)	
  0x443508		488d6c2410		LEAQ 0x10(SP), BP	
				throw("casgstatus: waiting for Gwaiting but is Grunnable")
  0x44350d		488d05e9a30200		LEAQ 0x2a3e9(IP), AX	
  0x443514		48890424		MOVQ AX, 0(SP)		
  0x443518		48c744240831000000	MOVQ $0x31, 0x8(SP)	
  0x443521		e8aadcfdff		CALL runtime.throw(SB)	
  0x443526		0f0b			UD2			
			systemstack(func() {
  0x443528		e843100000		CALL runtime.morestack_noctxt(SB)	
  0x44352d		ebc1			JMP runtime.casgstatus.func3(SB)	

TEXT runtime.reentersyscall.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x443530		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443539		483b6110		CMPQ 0x10(CX), SP	
  0x44353d		0f86df000000		JBE 0x443622		
  0x443543		4883ec30		SUBQ $0x30, SP		
  0x443547		48896c2428		MOVQ BP, 0x28(SP)	
  0x44354c		488d6c2428		LEAQ 0x28(SP), BP	
  0x443551		488b4208		MOVQ 0x8(DX), AX	
			print("entersyscall inconsistent ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
  0x443555		488b4870		MOVQ 0x70(AX), CX		
  0x443559		48894c2420		MOVQ CX, 0x20(SP)		
  0x44355e		488b10			MOVQ 0(AX), DX			
  0x443561		4889542418		MOVQ DX, 0x18(SP)		
  0x443566		488b4008		MOVQ 0x8(AX), AX		
  0x44356a		4889442410		MOVQ AX, 0x10(SP)		
  0x44356f		e88ce5fdff		CALL runtime.printlock(SB)	
  0x443574		488d0545860200		LEAQ 0x28645(IP), AX		
  0x44357b		48890424		MOVQ AX, 0(SP)			
  0x44357f		48c74424081a000000	MOVQ $0x1a, 0x8(SP)		
  0x443588		e8b3eefdff		CALL runtime.printstring(SB)	
  0x44358d		488b442420		MOVQ 0x20(SP), AX		
  0x443592		48890424		MOVQ AX, 0(SP)			
  0x443596		e855edfdff		CALL runtime.printhex(SB)	
  0x44359b		488d05c4660200		LEAQ 0x266c4(IP), AX		
  0x4435a2		48890424		MOVQ AX, 0(SP)			
  0x4435a6		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4435af		e88ceefdff		CALL runtime.printstring(SB)	
  0x4435b4		488b442418		MOVQ 0x18(SP), AX		
  0x4435b9		48890424		MOVQ AX, 0(SP)			
  0x4435bd		e82eedfdff		CALL runtime.printhex(SB)	
  0x4435c2		488d058b660200		LEAQ 0x2668b(IP), AX		
  0x4435c9		48890424		MOVQ AX, 0(SP)			
  0x4435cd		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4435d6		e865eefdff		CALL runtime.printstring(SB)	
  0x4435db		488b442410		MOVQ 0x10(SP), AX		
  0x4435e0		48890424		MOVQ AX, 0(SP)			
  0x4435e4		e807edfdff		CALL runtime.printhex(SB)	
  0x4435e9		488d0586660200		LEAQ 0x26686(IP), AX		
  0x4435f0		48890424		MOVQ AX, 0(SP)			
  0x4435f4		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4435fd		e83eeefdff		CALL runtime.printstring(SB)	
  0x443602		e879e5fdff		CALL runtime.printunlock(SB)	
			throw("entersyscall")
  0x443607		488d0500700200		LEAQ 0x27000(IP), AX	
  0x44360e		48890424		MOVQ AX, 0(SP)		
  0x443612		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x44361b		e8b0dbfdff		CALL runtime.throw(SB)	
  0x443620		0f0b			UD2			
		systemstack(func() {
  0x443622		e8a90e0000		CALL runtime.morestack(SB)		
  0x443627		e904ffffff		JMP runtime.reentersyscall.func1(SB)	

TEXT runtime.entersyscallblock.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x443630		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443639		483b6110		CMPQ 0x10(CX), SP	
  0x44363d		0f8617010000		JBE 0x44375a		
  0x443643		4883ec40		SUBQ $0x40, SP		
  0x443647		48896c2438		MOVQ BP, 0x38(SP)	
  0x44364c		488d6c2438		LEAQ 0x38(SP), BP	
  0x443651		488b4220		MOVQ 0x20(DX), AX	
  0x443655		488b4a08		MOVQ 0x8(DX), CX	
  0x443659		48894c2420		MOVQ CX, 0x20(SP)	
  0x44365e		488b5a10		MOVQ 0x10(DX), BX	
  0x443662		48895c2418		MOVQ BX, 0x18(SP)	
  0x443667		488b5218		MOVQ 0x18(DX), DX	
  0x44366b		4889542410		MOVQ DX, 0x10(SP)	
			print("entersyscallblock inconsistent ", hex(sp1), " ", hex(sp2), " ", hex(sp3), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
  0x443670		488b30			MOVQ 0(AX), SI			
  0x443673		4889742428		MOVQ SI, 0x28(SP)		
  0x443678		488b4008		MOVQ 0x8(AX), AX		
  0x44367c		4889442430		MOVQ AX, 0x30(SP)		
  0x443681		e87ae4fdff		CALL runtime.printlock(SB)	
  0x443686		488d05ff8f0200		LEAQ 0x28fff(IP), AX		
  0x44368d		48890424		MOVQ AX, 0(SP)			
  0x443691		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x44369a		e8a1edfdff		CALL runtime.printstring(SB)	
  0x44369f		488b442420		MOVQ 0x20(SP), AX		
  0x4436a4		48890424		MOVQ AX, 0(SP)			
  0x4436a8		e843ecfdff		CALL runtime.printhex(SB)	
  0x4436ad		e88ee6fdff		CALL runtime.printsp(SB)	
  0x4436b2		488b442418		MOVQ 0x18(SP), AX		
  0x4436b7		48890424		MOVQ AX, 0(SP)			
  0x4436bb		e830ecfdff		CALL runtime.printhex(SB)	
  0x4436c0		e87be6fdff		CALL runtime.printsp(SB)	
  0x4436c5		488b442410		MOVQ 0x10(SP), AX		
  0x4436ca		48890424		MOVQ AX, 0(SP)			
  0x4436ce		e81decfdff		CALL runtime.printhex(SB)	
  0x4436d3		488d058c650200		LEAQ 0x2658c(IP), AX		
  0x4436da		48890424		MOVQ AX, 0(SP)			
  0x4436de		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4436e7		e854edfdff		CALL runtime.printstring(SB)	
  0x4436ec		488b442428		MOVQ 0x28(SP), AX		
  0x4436f1		48890424		MOVQ AX, 0(SP)			
  0x4436f5		e8f6ebfdff		CALL runtime.printhex(SB)	
  0x4436fa		488d0553650200		LEAQ 0x26553(IP), AX		
  0x443701		48890424		MOVQ AX, 0(SP)			
  0x443705		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x44370e		e82dedfdff		CALL runtime.printstring(SB)	
  0x443713		488b442430		MOVQ 0x30(SP), AX		
  0x443718		48890424		MOVQ AX, 0(SP)			
  0x44371c		e8cfebfdff		CALL runtime.printhex(SB)	
  0x443721		488d054e650200		LEAQ 0x2654e(IP), AX		
  0x443728		48890424		MOVQ AX, 0(SP)			
  0x44372c		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x443735		e806edfdff		CALL runtime.printstring(SB)	
  0x44373a		e841e4fdff		CALL runtime.printunlock(SB)	
			throw("entersyscallblock")
  0x44373f		488d05e4740200		LEAQ 0x274e4(IP), AX	
  0x443746		48890424		MOVQ AX, 0(SP)		
  0x44374a		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x443753		e878dafdff		CALL runtime.throw(SB)	
  0x443758		0f0b			UD2			
		systemstack(func() {
  0x44375a		e8710d0000		CALL runtime.morestack(SB)		
  0x44375f		e9ccfeffff		JMP runtime.entersyscallblock.func1(SB)	

TEXT runtime.entersyscallblock.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x443770		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443779		483b6110		CMPQ 0x10(CX), SP	
  0x44377d		0f8617010000		JBE 0x44389a		
  0x443783		4883ec40		SUBQ $0x40, SP		
  0x443787		48896c2438		MOVQ BP, 0x38(SP)	
  0x44378c		488d6c2438		LEAQ 0x38(SP), BP	
  0x443791		488b4210		MOVQ 0x10(DX), AX	
  0x443795		488b4a08		MOVQ 0x8(DX), CX	
  0x443799		48894c2410		MOVQ CX, 0x10(SP)	
			print("entersyscallblock inconsistent ", hex(sp), " ", hex(_g_.sched.sp), " ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
  0x44379e		488b5038		MOVQ 0x38(AX), DX		
  0x4437a2		4889542428		MOVQ DX, 0x28(SP)		
  0x4437a7		488b5870		MOVQ 0x70(AX), BX		
  0x4437ab		48895c2420		MOVQ BX, 0x20(SP)		
  0x4437b0		488b30			MOVQ 0(AX), SI			
  0x4437b3		4889742418		MOVQ SI, 0x18(SP)		
  0x4437b8		488b4008		MOVQ 0x8(AX), AX		
  0x4437bc		4889442430		MOVQ AX, 0x30(SP)		
  0x4437c1		e83ae3fdff		CALL runtime.printlock(SB)	
  0x4437c6		488d05bf8e0200		LEAQ 0x28ebf(IP), AX		
  0x4437cd		48890424		MOVQ AX, 0(SP)			
  0x4437d1		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x4437da		e861ecfdff		CALL runtime.printstring(SB)	
  0x4437df		488b442410		MOVQ 0x10(SP), AX		
  0x4437e4		48890424		MOVQ AX, 0(SP)			
  0x4437e8		e803ebfdff		CALL runtime.printhex(SB)	
  0x4437ed		e84ee5fdff		CALL runtime.printsp(SB)	
  0x4437f2		488b442428		MOVQ 0x28(SP), AX		
  0x4437f7		48890424		MOVQ AX, 0(SP)			
  0x4437fb		e8f0eafdff		CALL runtime.printhex(SB)	
  0x443800		e83be5fdff		CALL runtime.printsp(SB)	
  0x443805		488b442420		MOVQ 0x20(SP), AX		
  0x44380a		48890424		MOVQ AX, 0(SP)			
  0x44380e		e8ddeafdff		CALL runtime.printhex(SB)	
  0x443813		488d054c640200		LEAQ 0x2644c(IP), AX		
  0x44381a		48890424		MOVQ AX, 0(SP)			
  0x44381e		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x443827		e814ecfdff		CALL runtime.printstring(SB)	
  0x44382c		488b442418		MOVQ 0x18(SP), AX		
  0x443831		48890424		MOVQ AX, 0(SP)			
  0x443835		e8b6eafdff		CALL runtime.printhex(SB)	
  0x44383a		488d0513640200		LEAQ 0x26413(IP), AX		
  0x443841		48890424		MOVQ AX, 0(SP)			
  0x443845		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x44384e		e8edebfdff		CALL runtime.printstring(SB)	
  0x443853		488b442430		MOVQ 0x30(SP), AX		
  0x443858		48890424		MOVQ AX, 0(SP)			
  0x44385c		e88feafdff		CALL runtime.printhex(SB)	
  0x443861		488d050e640200		LEAQ 0x2640e(IP), AX		
  0x443868		48890424		MOVQ AX, 0(SP)			
  0x44386c		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x443875		e8c6ebfdff		CALL runtime.printstring(SB)	
  0x44387a		e801e3fdff		CALL runtime.printunlock(SB)	
			throw("entersyscallblock")
  0x44387f		488d05a4730200		LEAQ 0x273a4(IP), AX	
  0x443886		48890424		MOVQ AX, 0(SP)		
  0x44388a		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x443893		e838d9fdff		CALL runtime.throw(SB)	
  0x443898		0f0b			UD2			
		systemstack(func() {
  0x44389a		e8310c0000		CALL runtime.morestack(SB)		
  0x44389f		e9ccfeffff		JMP runtime.entersyscallblock.func2(SB)	

TEXT runtime.exitsyscall.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x4438b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4438b9		483b6110		CMPQ 0x10(CX), SP	
  0x4438bd		7629			JBE 0x4438e8		
  0x4438bf		4883ec18		SUBQ $0x18, SP		
  0x4438c3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4438c8		488d6c2410		LEAQ 0x10(SP), BP	
			throw("exitsyscall: syscall frame is no longer valid")
  0x4438cd		488d05d19d0200		LEAQ 0x29dd1(IP), AX	
  0x4438d4		48890424		MOVQ AX, 0(SP)		
  0x4438d8		48c74424082d000000	MOVQ $0x2d, 0x8(SP)	
  0x4438e1		e8ead8fdff		CALL runtime.throw(SB)	
  0x4438e6		0f0b			UD2			
		systemstack(func() {
  0x4438e8		e8830c0000		CALL runtime.morestack_noctxt(SB)	
  0x4438ed		ebc1			JMP runtime.exitsyscall.func1(SB)	

TEXT runtime.exitsyscall.func2(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
			systemstack(func() {
  0x4438f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4438f9		483b6110		CMPQ 0x10(CX), SP	
  0x4438fd		7629			JBE 0x443928		
  0x4438ff		4883ec18		SUBQ $0x18, SP		
  0x443903		48896c2410		MOVQ BP, 0x10(SP)	
  0x443908		488d6c2410		LEAQ 0x10(SP), BP	
				throw("lost mcache")
  0x44390d		488d05a26b0200		LEAQ 0x26ba2(IP), AX	
  0x443914		48890424		MOVQ AX, 0(SP)		
  0x443918		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x443921		e8aad8fdff		CALL runtime.throw(SB)	
  0x443926		0f0b			UD2			
			systemstack(func() {
  0x443928		e8430c0000		CALL runtime.morestack_noctxt(SB)	
  0x44392d		ebc1			JMP runtime.exitsyscall.func2(SB)	

TEXT runtime.exitsyscall.func3(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x443930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443939		483b6110		CMPQ 0x10(CX), SP	
  0x44393d		7629			JBE 0x443968		
  0x44393f		4883ec18		SUBQ $0x18, SP		
  0x443943		48896c2410		MOVQ BP, 0x10(SP)	
  0x443948		488d6c2410		LEAQ 0x10(SP), BP	
			throw("lost mcache")
  0x44394d		488d05626b0200		LEAQ 0x26b62(IP), AX	
  0x443954		48890424		MOVQ AX, 0(SP)		
  0x443958		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x443961		e86ad8fdff		CALL runtime.throw(SB)	
  0x443966		0f0b			UD2			
		systemstack(func() {
  0x443968		e8030c0000		CALL runtime.morestack_noctxt(SB)	
  0x44396d		ebc1			JMP runtime.exitsyscall.func3(SB)	

TEXT runtime.exitsyscallfast.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x443970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443979		483b6110		CMPQ 0x10(CX), SP	
  0x44397d		0f868b000000		JBE 0x443a0e		
  0x443983		4883ec28		SUBQ $0x28, SP		
  0x443987		48896c2420		MOVQ BP, 0x20(SP)	
  0x44398c		488d6c2420		LEAQ 0x20(SP), BP	
  0x443991		488b4208		MOVQ 0x8(DX), AX	
  0x443995		4889442418		MOVQ AX, 0x18(SP)	
  0x44399a		488b4a10		MOVQ 0x10(DX), CX	
  0x44399e		48894c2408		MOVQ CX, 0x8(SP)	
  0x4439a3		488b5218		MOVQ 0x18(DX), DX	
  0x4439a7		4889542410		MOVQ DX, 0x10(SP)	
			ok = exitsyscallfast_pidle()
  0x4439ac		e8cf65feff		CALL runtime.exitsyscallfast_pidle(SB)	
  0x4439b1		0fb60424		MOVZX 0(SP), AX				
  0x4439b5		488b4c2418		MOVQ 0x18(SP), CX			
  0x4439ba		8801			MOVB AL, 0(CX)				
  0x4439bc		84c0			TESTL AL, AL				
			if ok && trace.enabled {
  0x4439be		7444			JE 0x443a04			
  0x4439c0		0fb60509fe0600		MOVZX runtime.trace+16(SB), AX	
  0x4439c7		84c0			TESTL AL, AL			
  0x4439c9		7439			JE 0x443a04			
  0x4439cb		488b442408		MOVQ 0x8(SP), AX		
				if oldp != nil {
  0x4439d0		4885c0			TESTQ AX, AX		
  0x4439d3		750c			JNE 0x4439e1		
  0x4439d5		eb20			JMP 0x4439f7		
						osyield()
  0x4439d7		e874450000		CALL runtime.osyield(SB)	
  0x4439dc		488b442408		MOVQ 0x8(SP), AX		
					for oldp.syscalltick == _g_.m.syscalltick {
  0x4439e1		488b4c2410		MOVQ 0x10(SP), CX	
  0x4439e6		488b5130		MOVQ 0x30(CX), DX	
  0x4439ea		8b581c			MOVL 0x1c(AX), BX	
  0x4439ed		8b922c030000		MOVL 0x32c(DX), DX	
  0x4439f3		39d3			CMPL DX, BX		
  0x4439f5		74e0			JE 0x4439d7		
				traceGoSysExit(0)
  0x4439f7		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x4439ff		e81c74ffff		CALL runtime.traceGoSysExit(SB)	
  0x443a04		488b6c2420		MOVQ 0x20(SP), BP		
  0x443a09		4883c428		ADDQ $0x28, SP			
  0x443a0d		c3			RET				
		systemstack(func() {
  0x443a0e		e8bd0a0000		CALL runtime.morestack(SB)		
  0x443a13		e958ffffff		JMP runtime.exitsyscallfast.func1(SB)	

TEXT runtime.exitsyscallfast_reacquired.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
			systemstack(func() {
  0x443a20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443a29		483b6110		CMPQ 0x10(CX), SP	
  0x443a2d		763d			JBE 0x443a6c		
  0x443a2f		4883ec10		SUBQ $0x10, SP		
  0x443a33		48896c2408		MOVQ BP, 0x8(SP)	
  0x443a38		488d6c2408		LEAQ 0x8(SP), BP	
  0x443a3d		488b4208		MOVQ 0x8(DX), AX	
				traceGoSysBlock(_g_.m.p.ptr())
  0x443a41		488b4030		MOVQ 0x30(AX), AX			
  0x443a45		488b80d0000000		MOVQ 0xd0(AX), AX			
  0x443a4c		48890424		MOVQ AX, 0(SP)				
  0x443a50		e8ab74ffff		CALL runtime.traceGoSysBlock(SB)	
				traceGoSysExit(0)
  0x443a55		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x443a5d		e8be73ffff		CALL runtime.traceGoSysExit(SB)	
			})
  0x443a62		488b6c2408		MOVQ 0x8(SP), BP	
  0x443a67		4883c410		ADDQ $0x10, SP		
  0x443a6b		c3			RET			
			systemstack(func() {
  0x443a6c		e85f0a0000		CALL runtime.morestack(SB)				
  0x443a71		ebad			JMP runtime.exitsyscallfast_reacquired.func1(SB)	

TEXT runtime.malg.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
		systemstack(func() {
  0x443a80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443a89		483b6110		CMPQ 0x10(CX), SP	
  0x443a8d		7642			JBE 0x443ad1		
  0x443a8f		4883ec28		SUBQ $0x28, SP		
  0x443a93		48896c2420		MOVQ BP, 0x20(SP)	
  0x443a98		488d6c2420		LEAQ 0x20(SP), BP	
  0x443a9d		8b4208			MOVL 0x8(DX), AX	
  0x443aa0		488b4a10		MOVQ 0x10(DX), CX	
  0x443aa4		48894c2418		MOVQ CX, 0x18(SP)	
			newg.stack = stackalloc(uint32(stacksize))
  0x443aa9		890424			MOVL AX, 0(SP)			
  0x443aac		e85f0affff		CALL runtime.stackalloc(SB)	
  0x443ab1		488b442408		MOVQ 0x8(SP), AX		
  0x443ab6		488b4c2410		MOVQ 0x10(SP), CX		
  0x443abb		488b542418		MOVQ 0x18(SP), DX		
  0x443ac0		488902			MOVQ AX, 0(DX)			
  0x443ac3		48894a08		MOVQ CX, 0x8(DX)		
		})
  0x443ac7		488b6c2420		MOVQ 0x20(SP), BP	
  0x443acc		4883c428		ADDQ $0x28, SP		
  0x443ad0		c3			RET			
		systemstack(func() {
  0x443ad1		e8fa090000		CALL runtime.morestack(SB)	
  0x443ad6		eba8			JMP runtime.malg.func1(SB)	

TEXT runtime.newproc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
	systemstack(func() {
  0x443ae0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443ae9		483b6110		CMPQ 0x10(CX), SP	
  0x443aed		7641			JBE 0x443b30		
  0x443aef		4883ec28		SUBQ $0x28, SP		
  0x443af3		48896c2420		MOVQ BP, 0x20(SP)	
  0x443af8		488d6c2420		LEAQ 0x20(SP), BP	
  0x443afd		488b4208		MOVQ 0x8(DX), AX	
  0x443b01		488b4a10		MOVQ 0x10(DX), CX	
  0x443b05		8b5a18			MOVL 0x18(DX), BX	
  0x443b08		488b5220		MOVQ 0x20(DX), DX	
		newproc1(fn, (*uint8)(argp), siz, pc)
  0x443b0c		488b00			MOVQ 0(AX), AX			
  0x443b0f		48890424		MOVQ AX, 0(SP)			
  0x443b13		48894c2408		MOVQ CX, 0x8(SP)		
  0x443b18		895c2410		MOVL BX, 0x10(SP)		
  0x443b1c		4889542418		MOVQ DX, 0x18(SP)		
  0x443b21		e83a68feff		CALL runtime.newproc1(SB)	
	})
  0x443b26		488b6c2420		MOVQ 0x20(SP), BP	
  0x443b2b		4883c428		ADDQ $0x28, SP		
  0x443b2f		c3			RET			
	systemstack(func() {
  0x443b30		e89b090000		CALL runtime.morestack(SB)	
  0x443b35		eba9			JMP runtime.newproc.func1(SB)	

TEXT runtime.gfget.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/proc.go
			systemstack(func() {
  0x443b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443b49		483b6110		CMPQ 0x10(CX), SP	
  0x443b4d		7643			JBE 0x443b92		
  0x443b4f		4883ec28		SUBQ $0x28, SP		
  0x443b53		48896c2420		MOVQ BP, 0x20(SP)	
  0x443b58		488d6c2420		LEAQ 0x20(SP), BP	
  0x443b5d		488b4208		MOVQ 0x8(DX), AX	
  0x443b61		4889442418		MOVQ AX, 0x18(SP)	
				gp.stack = stackalloc(_FixedStack)
  0x443b66		c7042400080000		MOVL $0x800, 0(SP)		
  0x443b6d		e89e09ffff		CALL runtime.stackalloc(SB)	
  0x443b72		488b442408		MOVQ 0x8(SP), AX		
  0x443b77		488b4c2410		MOVQ 0x10(SP), CX		
  0x443b7c		488b542418		MOVQ 0x18(SP), DX		
  0x443b81		488902			MOVQ AX, 0(DX)			
  0x443b84		48894a08		MOVQ CX, 0x8(DX)		
			})
  0x443b88		488b6c2420		MOVQ 0x20(SP), BP	
  0x443b8d		4883c428		ADDQ $0x28, SP		
  0x443b91		c3			RET			
			systemstack(func() {
  0x443b92		e839090000		CALL runtime.morestack(SB)	
  0x443b97		eba7			JMP runtime.gfget.func1(SB)	

TEXT runtime.(*rwmutex).rlock.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/rwmutex.go
		systemstack(func() {
  0x443ba0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443ba9		483b6110		CMPQ 0x10(CX), SP	
  0x443bad		0f86a9000000		JBE 0x443c5c		
  0x443bb3		4883ec28		SUBQ $0x28, SP		
  0x443bb7		48896c2420		MOVQ BP, 0x20(SP)	
  0x443bbc		488d6c2420		LEAQ 0x20(SP), BP	
  0x443bc1		488b4208		MOVQ 0x8(DX), AX	
  0x443bc5		4889442408		MOVQ AX, 0x8(SP)	
			lock(&rw.rLock)
  0x443bca		8400			TESTB AL, 0(AX)		
  0x443bcc		48890424		MOVQ AX, 0(SP)		
  0x443bd0		e84b59fcff		CALL runtime.lock(SB)	
  0x443bd5		488b442408		MOVQ 0x8(SP), AX	
			if rw.readerPass > 0 {
  0x443bda		8b4810			MOVL 0x10(AX), CX	
  0x443bdd		85c9			TESTL CX, CX		
  0x443bdf		7618			JBE 0x443bf9		
				rw.readerPass -= 1
  0x443be1		ffc9			DECL CX			
  0x443be3		894810			MOVL CX, 0x10(AX)	
				unlock(&rw.rLock)
  0x443be6		48890424		MOVQ AX, 0(SP)		
  0x443bea		e8d15afcff		CALL runtime.unlock(SB)	
  0x443bef		488b6c2420		MOVQ 0x20(SP), BP	
  0x443bf4		4883c428		ADDQ $0x28, SP		
  0x443bf8		c3			RET			
				m := getg().m
  0x443bf9		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443c02		488b4930		MOVQ 0x30(CX), CX	
  0x443c06		48894c2410		MOVQ CX, 0x10(SP)	
				m.schedlink = rw.readers
  0x443c0b		488b5008		MOVQ 0x8(AX), DX	
  0x443c0f		48899158010000		MOVQ DX, 0x158(CX)	
  0x443c16		488d5008		LEAQ 0x8(AX), DX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x443c1a		8402			TESTB AL, 0(DX)		
  0x443c1c		48894808		MOVQ CX, 0x8(AX)	
				unlock(&rw.rLock)
  0x443c20		48890424		MOVQ AX, 0(SP)		
  0x443c24		e8975afcff		CALL runtime.unlock(SB)	
  0x443c29		488b442410		MOVQ 0x10(SP), AX	
				notesleep(&m.park)
  0x443c2e		488d8848010000		LEAQ 0x148(AX), CX		
  0x443c35		48894c2418		MOVQ CX, 0x18(SP)		
  0x443c3a		48890c24		MOVQ CX, 0(SP)			
  0x443c3e		e80d5cfcff		CALL runtime.notesleep(SB)	
  0x443c43		488b442418		MOVQ 0x18(SP), AX		
	n.key = 0
  0x443c48		8400			TESTB AL, 0(AX)		
  0x443c4a		488b442410		MOVQ 0x10(SP), AX	
  0x443c4f		48c7804801000000000000	MOVQ $0x0, 0x148(AX)	
  0x443c5a		eb93			JMP 0x443bef		
		systemstack(func() {
  0x443c5c		e86f080000		CALL runtime.morestack(SB)		
  0x443c61		e93affffff		JMP runtime.(*rwmutex).rlock.func1(SB)	

TEXT runtime.morestackc.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/stack.go
	systemstack(func() {
  0x443c70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443c79		483b6110		CMPQ 0x10(CX), SP	
  0x443c7d		7629			JBE 0x443ca8		
  0x443c7f		4883ec18		SUBQ $0x18, SP		
  0x443c83		48896c2410		MOVQ BP, 0x10(SP)	
  0x443c88		488d6c2410		LEAQ 0x10(SP), BP	
		throw("attempt to execute system stack code on user stack")
  0x443c8d		488d055e9d0200		LEAQ 0x29d5e(IP), AX	
  0x443c94		48890424		MOVQ AX, 0(SP)		
  0x443c98		48c744240832000000	MOVQ $0x32, 0x8(SP)	
  0x443ca1		e82ad5fdff		CALL runtime.throw(SB)	
  0x443ca6		0f0b			UD2			
	systemstack(func() {
  0x443ca8		e8c3080000		CALL runtime.morestack_noctxt(SB)	
  0x443cad		ebc1			JMP runtime.morestackc.func1(SB)	

TEXT runtime.callers.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
	systemstack(func() {
  0x443cb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443cb9		483b6110		CMPQ 0x10(CX), SP	
  0x443cbd		0f8691000000		JBE 0x443d54		
  0x443cc3		4883ec68		SUBQ $0x68, SP		
  0x443cc7		48896c2460		MOVQ BP, 0x60(SP)	
  0x443ccc		488d6c2460		LEAQ 0x60(SP), BP	
  0x443cd1		488b4208		MOVQ 0x8(DX), AX	
  0x443cd5		488b4a10		MOVQ 0x10(DX), CX	
  0x443cd9		488b5a18		MOVQ 0x18(DX), BX	
  0x443cdd		488b7220		MOVQ 0x20(DX), SI	
  0x443ce1		488b7a40		MOVQ 0x40(DX), DI	
		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
  0x443ce5		488b36			MOVQ 0(SI), SI			
  0x443ce8		4c8b4228		MOVQ 0x28(DX), R8		
  0x443cec		488b5230		MOVQ 0x30(DX), DX		
  0x443cf0		4885d2			TESTQ DX, DX			
  0x443cf3		7658			JBE 0x443d4d			
  0x443cf5		48897c2458		MOVQ DI, 0x58(SP)		
  0x443cfa		4c89442428		MOVQ R8, 0x28(SP)		
  0x443cff		48890424		MOVQ AX, 0(SP)			
  0x443d03		48894c2408		MOVQ CX, 0x8(SP)		
  0x443d08		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x443d11		48895c2418		MOVQ BX, 0x18(SP)		
  0x443d16		4889742420		MOVQ SI, 0x20(SP)		
  0x443d1b		4889542430		MOVQ DX, 0x30(SP)		
  0x443d20		0f57c0			XORPS X0, X0			
  0x443d23		0f11442438		MOVUPS X0, 0x38(SP)		
  0x443d28		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x443d31		e8fa75ffff		CALL runtime.gentraceback(SB)	
  0x443d36		488b442450		MOVQ 0x50(SP), AX		
  0x443d3b		488b4c2458		MOVQ 0x58(SP), CX		
  0x443d40		488901			MOVQ AX, 0(CX)			
	})
  0x443d43		488b6c2460		MOVQ 0x60(SP), BP	
  0x443d48		4883c468		ADDQ $0x68, SP		
  0x443d4c		c3			RET			
		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
  0x443d4d		e8eebcfdff		CALL runtime.panicindex(SB)	
  0x443d52		0f0b			UD2				
	systemstack(func() {
  0x443d54		e877070000		CALL runtime.morestack(SB)	
  0x443d59		e952ffffff		JMP runtime.callers.func1(SB)	

TEXT runtime.tracebackHexdump.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/traceback.go
	hexdumpWords(lo, hi, func(p uintptr) byte {
  0x443d60		488b4208		MOVQ 0x8(DX), AX	
  0x443d64		488b4a10		MOVQ 0x10(DX), CX	
		case frame.fp:
  0x443d68		488b5030		MOVQ 0x30(AX), DX	
  0x443d6c		488b5c2408		MOVQ 0x8(SP), BX	
  0x443d71		4839da			CMPQ BX, DX		
  0x443d74		7420			JE 0x443d96		
		case frame.sp:
  0x443d76		488b4028		MOVQ 0x28(AX), AX	
  0x443d7a		4839d8			CMPQ BX, AX		
  0x443d7d		7411			JE 0x443d90		
		case bad:
  0x443d7f		4839d9			CMPQ BX, CX		
  0x443d82		7506			JNE 0x443d8a		
			return '!'
  0x443d84		c644241021		MOVB $0x21, 0x10(SP)	
  0x443d89		c3			RET			
		return 0
  0x443d8a		c644241000		MOVB $0x0, 0x10(SP)	
  0x443d8f		c3			RET			
			return '<'
  0x443d90		c64424103c		MOVB $0x3c, 0x10(SP)	
  0x443d95		c3			RET			
			return '>'
  0x443d96		c64424103e		MOVB $0x3e, 0x10(SP)	
  0x443d9b		c3			RET			

TEXT runtime.vdso_parse_symbols.func1(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/vdso_linux.go
	apply := func(symIndex uint32, k symbol_key) bool {
  0x443da0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443da9		483b6110		CMPQ 0x10(CX), SP	
  0x443dad		0f862b010000		JBE 0x443ede		
  0x443db3		4883ec48		SUBQ $0x48, SP		
  0x443db7		48896c2440		MOVQ BP, 0x40(SP)	
  0x443dbc		488d6c2440		LEAQ 0x40(SP), BP	
  0x443dc1		488b4208		MOVQ 0x8(DX), AX	
		sym := &info.symtab[symIndex]
  0x443dc5		488b4818		MOVQ 0x18(AX), CX	
  0x443dc9		8401			TESTB AL, 0(CX)		
  0x443dcb		8400			TESTB AL, 0(AX)		
	apply := func(symIndex uint32, k symbol_key) bool {
  0x443dcd		8b5210			MOVL 0x10(DX), DX	
  0x443dd0		8b5c2450		MOVL 0x50(SP), BX	
		sym := &info.symtab[symIndex]
  0x443dd4		488d345b		LEAQ 0(BX)(BX*2), SI	
  0x443dd8		4889f7			MOVQ SI, DI		
  0x443ddb		48c1e603		SHLQ $0x3, SI		
		typ := _ELF_ST_TYPE(sym.st_info)
  0x443ddf		440fb6443104		MOVZX 0x4(CX)(SI*1), R8	
  0x443de5		4589c1			MOVL R8, R9		
func _ELF_ST_TYPE(val byte) byte { return val & 0xf }
  0x443de8		4183e00f		ANDL $0xf, R8		
		if typ != _STT_FUNC || bind != _STB_GLOBAL && bind != _STB_WEAK || sym.st_shndx == _SHN_UNDEF {
  0x443dec		4180f802		CMPL $0x2, R8		
  0x443df0		740f			JE 0x443e01		
			return false
  0x443df2		c644247800		MOVB $0x0, 0x78(SP)	
  0x443df7		488b6c2440		MOVQ 0x40(SP), BP	
  0x443dfc		4883c448		ADDQ $0x48, SP		
  0x443e00		c3			RET			
func _ELF_ST_BIND(val byte) byte { return val >> 4 }
  0x443e01		41c0e904		SHRL $0x4, R9		
		if typ != _STT_FUNC || bind != _STB_GLOBAL && bind != _STB_WEAK || sym.st_shndx == _SHN_UNDEF {
  0x443e05		4180f901		CMPL $0x1, R9		
  0x443e09		7406			JE 0x443e11		
  0x443e0b		4180f902		CMPL $0x2, R9		
  0x443e0f		75e1			JNE 0x443df2		
  0x443e11		0fb7743106		MOVZX 0x6(CX)(SI*1), SI	
  0x443e16		6685f6			TESTW SI, SI		
  0x443e19		74d7			JE 0x443df2		
  0x443e1b		4889442430		MOVQ AX, 0x30(SP)	
  0x443e20		89542424		MOVL DX, 0x24(SP)	
  0x443e24		48894c2438		MOVQ CX, 0x38(SP)	
  0x443e29		48897c2428		MOVQ DI, 0x28(SP)	
		if k.name != gostringnocopy(&info.symstrings[sym.st_name]) {
  0x443e2e		488b5020		MOVQ 0x20(AX), DX		
  0x443e32		8402			TESTB AL, 0(DX)			
  0x443e34		8b1cf9			MOVL 0(CX)(DI*8), BX		
  0x443e37		4801da			ADDQ BX, DX			
  0x443e3a		48891424		MOVQ DX, 0(SP)			
  0x443e3e		e8ad38ffff		CALL runtime.gostringnocopy(SB)	
  0x443e43		488b442410		MOVQ 0x10(SP), AX		
  0x443e48		488b4c2460		MOVQ 0x60(SP), CX		
  0x443e4d		4839c1			CMPQ AX, CX			
  0x443e50		740f			JE 0x443e61			
			return false
  0x443e52		c644247800		MOVB $0x0, 0x78(SP)	
  0x443e57		488b6c2440		MOVQ 0x40(SP), BP	
  0x443e5c		4883c448		ADDQ $0x48, SP		
  0x443e60		c3			RET			
  0x443e61		488b442458		MOVQ 0x58(SP), AX	
		if k.name != gostringnocopy(&info.symstrings[sym.st_name]) {
  0x443e66		48890424		MOVQ AX, 0(SP)			
  0x443e6a		48894c2410		MOVQ CX, 0x10(SP)		
  0x443e6f		e8cc240000		CALL runtime.memequal(SB)	
  0x443e74		0fb6442418		MOVZX 0x18(SP), AX		
  0x443e79		84c0			TESTL AL, AL			
  0x443e7b		74d5			JE 0x443e52			
  0x443e7d		488b442430		MOVQ 0x30(SP), AX		
		if info.versym != nil && version != 0 && int32(info.versym[symIndex]&0x7fff) != version {
  0x443e82		488b4860		MOVQ 0x60(AX), CX	
  0x443e86		4885c9			TESTQ CX, CX		
  0x443e89		741a			JE 0x443ea5		
  0x443e8b		8b542424		MOVL 0x24(SP), DX	
  0x443e8f		85d2			TESTL DX, DX		
  0x443e91		7412			JE 0x443ea5		
  0x443e93		8b5c2450		MOVL 0x50(SP), BX	
  0x443e97		0fb70c59		MOVZX 0(CX)(BX*2), CX	
  0x443e9b		81e1ff7f0000		ANDL $0x7fff, CX	
  0x443ea1		39d1			CMPL DX, CX		
  0x443ea3		752a			JNE 0x443ecf		
  0x443ea5		488b4c2428		MOVQ 0x28(SP), CX	
  0x443eaa		488b542438		MOVQ 0x38(SP), DX	
		*k.ptr = info.load_offset + uintptr(sym.st_value)
  0x443eaf		488b4cca08		MOVQ 0x8(DX)(CX*8), CX	
  0x443eb4		48034810		ADDQ 0x10(AX), CX	
  0x443eb8		488b442470		MOVQ 0x70(SP), AX	
  0x443ebd		488908			MOVQ CX, 0(AX)		
		return true
  0x443ec0		c644247801		MOVB $0x1, 0x78(SP)	
  0x443ec5		488b6c2440		MOVQ 0x40(SP), BP	
  0x443eca		4883c448		ADDQ $0x48, SP		
  0x443ece		c3			RET			
			return false
  0x443ecf		c644247800		MOVB $0x0, 0x78(SP)	
  0x443ed4		488b6c2440		MOVQ 0x40(SP), BP	
  0x443ed9		4883c448		ADDQ $0x48, SP		
  0x443edd		c3			RET			
	apply := func(symIndex uint32, k symbol_key) bool {
  0x443ede		e8ed050000		CALL runtime.morestack(SB)			
  0x443ee3		e9b8feffff		JMP runtime.vdso_parse_symbols.func1(SB)	

TEXT runtime.init(SB) <autogenerated>

  0x443ef0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x443ef9		483b6110		CMPQ 0x10(CX), SP			
  0x443efd		0f86e6000000		JBE 0x443fe9				
  0x443f03		4883ec20		SUBQ $0x20, SP				
  0x443f07		48896c2418		MOVQ BP, 0x18(SP)			
  0x443f0c		488d6c2418		LEAQ 0x18(SP), BP			
  0x443f11		0fb60591f90700		MOVZX runtime.initdone.(SB), AX		
  0x443f18		3c01			CMPL $0x1, AL				
  0x443f1a		760a			JBE 0x443f26				
  0x443f1c		488b6c2418		MOVQ 0x18(SP), BP			
  0x443f21		4883c420		ADDQ $0x20, SP				
  0x443f25		c3			RET					
  0x443f26		7507			JNE 0x443f2f				
  0x443f28		e8b3bdfdff		CALL runtime.throwinit(SB)		
  0x443f2d		0f0b			UD2					
  0x443f2f		c60573f9070001		MOVB $0x1, runtime.initdone.(SB)	
var inf = float64frombits(0x7FF0000000000000)
  0x443f36		48b8000000000000f07f	MOVQ $0x7ff0000000000000, AX		
  0x443f40		48890424		MOVQ AX, 0(SP)				
  0x443f44		e8b71bfcff		CALL runtime.float64frombits(SB)	
  0x443f49		f20f10442408		MOVSD_XMM 0x8(SP), X0			
  0x443f4f		f20f110519fa0700	MOVSD_XMM X0, runtime.inf(SB)		
	chansendpc = funcPC(chansend)
  0x443f57		488d05026f0100		LEAQ 0x16f02(IP), AX		
  0x443f5e		48890424		MOVQ AX, 0(SP)			
  0x443f62		488d059fa00200		LEAQ 0x2a09f(IP), AX		
  0x443f69		4889442408		MOVQ AX, 0x8(SP)		
  0x443f6e		e80df8fdff		CALL runtime.funcPC(SB)		
  0x443f73		488b442410		MOVQ 0x10(SP), AX		
  0x443f78		488905c1f90700		MOVQ AX, runtime.chansendpc(SB)	
	chanrecvpc = funcPC(chanrecv)
  0x443f7f		488d057a6e0100		LEAQ 0x16e7a(IP), AX		
  0x443f86		48890424		MOVQ AX, 0(SP)			
  0x443f8a		488d056fa00200		LEAQ 0x2a06f(IP), AX		
  0x443f91		4889442408		MOVQ AX, 0x8(SP)		
  0x443f96		e8e5f7fdff		CALL runtime.funcPC(SB)		
  0x443f9b		488b442410		MOVQ 0x10(SP), AX		
  0x443fa0		48890591f90700		MOVQ AX, runtime.chanrecvpc(SB)	
var startNano int64 = nanotime() - 1
  0x443fa7		e8843a0000		CALL runtime.nanotime(SB)	
  0x443fac		488b0424		MOVQ 0(SP), AX			
  0x443fb0		48ffc8			DECQ AX				
  0x443fb3		4889051efa0700		MOVQ AX, runtime.startNano(SB)	

  0x443fba		e8b105fcff		CALL runtime.init.0(SB)			
  0x443fbf		e86c4dfdff		CALL runtime.init.1(SB)			
  0x443fc4		e877a0fdff		CALL runtime.init.2(SB)			
  0x443fc9		e8d2c0fdff		CALL runtime.init.3(SB)			
  0x443fce		e85decfdff		CALL runtime.init.4(SB)			
  0x443fd3		e8c8e0feff		CALL runtime.init.5(SB)			
  0x443fd8		c605caf8070002		MOVB $0x2, runtime.initdone.(SB)	
  0x443fdf		488b6c2418		MOVQ 0x18(SP), BP			
  0x443fe4		4883c420		ADDQ $0x20, SP				
  0x443fe8		c3			RET					
  0x443fe9		e882050000		CALL runtime.morestack_noctxt(SB)	
  0x443fee		e9fdfeffff		JMP runtime.init(SB)			

TEXT runtime.skipPleaseUseCallersFrames(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm.s

  0x444000		90			NOPL			
  0x444001		90			NOPL			
  0x444002		90			NOPL			
  0x444003		90			NOPL			
  0x444004		90			NOPL			
  0x444005		90			NOPL			
  0x444006		90			NOPL			
  0x444007		90			NOPL			
  0x444008		90			NOPL			
  0x444009		90			NOPL			
  0x44400a		90			NOPL			
  0x44400b		90			NOPL			
  0x44400c		90			NOPL			
  0x44400d		90			NOPL			
  0x44400e		90			NOPL			
  0x44400f		90			NOPL			
  0x444010		90			NOPL			
  0x444011		90			NOPL			
  0x444012		90			NOPL			
  0x444013		90			NOPL			
  0x444014		90			NOPL			
  0x444015		90			NOPL			
  0x444016		90			NOPL			
  0x444017		90			NOPL			
  0x444018		90			NOPL			
  0x444019		90			NOPL			
  0x44401a		90			NOPL			
  0x44401b		90			NOPL			
  0x44401c		90			NOPL			
  0x44401d		90			NOPL			
  0x44401e		90			NOPL			
  0x44401f		90			NOPL			
  0x444020		90			NOPL			
  0x444021		90			NOPL			
  0x444022		90			NOPL			
  0x444023		90			NOPL			
  0x444024		90			NOPL			
  0x444025		90			NOPL			
  0x444026		90			NOPL			
  0x444027		90			NOPL			
  0x444028		90			NOPL			
  0x444029		90			NOPL			
  0x44402a		90			NOPL			
  0x44402b		90			NOPL			
  0x44402c		90			NOPL			
  0x44402d		90			NOPL			
  0x44402e		90			NOPL			
  0x44402f		90			NOPL			
  0x444030		90			NOPL			
  0x444031		90			NOPL			
  0x444032		90			NOPL			
  0x444033		90			NOPL			
  0x444034		90			NOPL			
  0x444035		90			NOPL			
  0x444036		90			NOPL			
  0x444037		90			NOPL			
  0x444038		90			NOPL			
  0x444039		90			NOPL			
  0x44403a		90			NOPL			
  0x44403b		90			NOPL			
  0x44403c		90			NOPL			
  0x44403d		90			NOPL			
  0x44403e		90			NOPL			
  0x44403f		90			NOPL			
  0x444040		90			NOPL			
  0x444041		90			NOPL			
  0x444042		90			NOPL			
  0x444043		90			NOPL			
  0x444044		90			NOPL			
  0x444045		90			NOPL			
  0x444046		90			NOPL			
  0x444047		90			NOPL			
  0x444048		90			NOPL			
  0x444049		90			NOPL			
  0x44404a		90			NOPL			
  0x44404b		90			NOPL			
  0x44404c		90			NOPL			
  0x44404d		90			NOPL			
  0x44404e		90			NOPL			
  0x44404f		90			NOPL			
  0x444050		90			NOPL			
  0x444051		90			NOPL			
  0x444052		90			NOPL			
  0x444053		90			NOPL			
  0x444054		90			NOPL			
  0x444055		90			NOPL			
  0x444056		90			NOPL			
  0x444057		90			NOPL			
  0x444058		90			NOPL			
  0x444059		90			NOPL			
  0x44405a		90			NOPL			
  0x44405b		90			NOPL			
  0x44405c		90			NOPL			
  0x44405d		90			NOPL			
  0x44405e		90			NOPL			
  0x44405f		90			NOPL			
  0x444060		90			NOPL			
  0x444061		90			NOPL			
  0x444062		90			NOPL			
  0x444063		90			NOPL			
  0x444064		90			NOPL			
  0x444065		90			NOPL			
  0x444066		90			NOPL			
  0x444067		90			NOPL			
  0x444068		90			NOPL			
  0x444069		90			NOPL			
  0x44406a		90			NOPL			
  0x44406b		90			NOPL			
  0x44406c		90			NOPL			
  0x44406d		90			NOPL			
  0x44406e		90			NOPL			
  0x44406f		90			NOPL			
  0x444070		90			NOPL			
  0x444071		90			NOPL			
  0x444072		90			NOPL			
  0x444073		90			NOPL			
  0x444074		90			NOPL			
  0x444075		90			NOPL			
  0x444076		90			NOPL			
  0x444077		90			NOPL			
  0x444078		90			NOPL			
  0x444079		90			NOPL			
  0x44407a		90			NOPL			
  0x44407b		90			NOPL			
  0x44407c		90			NOPL			
  0x44407d		90			NOPL			
  0x44407e		90			NOPL			
  0x44407f		90			NOPL			
  0x444080		90			NOPL			
  0x444081		90			NOPL			
  0x444082		90			NOPL			
  0x444083		90			NOPL			
  0x444084		90			NOPL			
  0x444085		90			NOPL			
  0x444086		90			NOPL			
  0x444087		90			NOPL			
  0x444088		90			NOPL			
  0x444089		90			NOPL			
  0x44408a		90			NOPL			
  0x44408b		90			NOPL			
  0x44408c		90			NOPL			
  0x44408d		90			NOPL			
  0x44408e		90			NOPL			
  0x44408f		90			NOPL			
  0x444090		90			NOPL			
  0x444091		90			NOPL			
  0x444092		90			NOPL			
  0x444093		90			NOPL			
  0x444094		90			NOPL			
  0x444095		90			NOPL			
  0x444096		90			NOPL			
  0x444097		90			NOPL			
  0x444098		90			NOPL			
  0x444099		90			NOPL			
  0x44409a		90			NOPL			
  0x44409b		90			NOPL			
  0x44409c		90			NOPL			
  0x44409d		90			NOPL			
  0x44409e		90			NOPL			
  0x44409f		90			NOPL			
  0x4440a0		90			NOPL			
  0x4440a1		90			NOPL			
  0x4440a2		90			NOPL			
  0x4440a3		90			NOPL			
  0x4440a4		90			NOPL			
  0x4440a5		90			NOPL			
  0x4440a6		90			NOPL			
  0x4440a7		90			NOPL			
  0x4440a8		90			NOPL			
  0x4440a9		90			NOPL			
  0x4440aa		90			NOPL			
  0x4440ab		90			NOPL			
  0x4440ac		90			NOPL			
  0x4440ad		90			NOPL			
  0x4440ae		90			NOPL			
  0x4440af		90			NOPL			
  0x4440b0		90			NOPL			
  0x4440b1		90			NOPL			
  0x4440b2		90			NOPL			
  0x4440b3		90			NOPL			
  0x4440b4		90			NOPL			
  0x4440b5		90			NOPL			
  0x4440b6		90			NOPL			
  0x4440b7		90			NOPL			
  0x4440b8		90			NOPL			
  0x4440b9		90			NOPL			
  0x4440ba		90			NOPL			
  0x4440bb		90			NOPL			
  0x4440bc		90			NOPL			
  0x4440bd		90			NOPL			
  0x4440be		90			NOPL			
  0x4440bf		90			NOPL			
  0x4440c0		90			NOPL			
  0x4440c1		90			NOPL			
  0x4440c2		90			NOPL			
  0x4440c3		90			NOPL			
  0x4440c4		90			NOPL			
  0x4440c5		90			NOPL			
  0x4440c6		90			NOPL			
  0x4440c7		90			NOPL			
  0x4440c8		90			NOPL			
  0x4440c9		90			NOPL			
  0x4440ca		90			NOPL			
  0x4440cb		90			NOPL			
  0x4440cc		90			NOPL			
  0x4440cd		90			NOPL			
  0x4440ce		90			NOPL			
  0x4440cf		90			NOPL			
  0x4440d0		90			NOPL			
  0x4440d1		90			NOPL			
  0x4440d2		90			NOPL			
  0x4440d3		90			NOPL			
  0x4440d4		90			NOPL			
  0x4440d5		90			NOPL			
  0x4440d6		90			NOPL			
  0x4440d7		90			NOPL			
  0x4440d8		90			NOPL			
  0x4440d9		90			NOPL			
  0x4440da		90			NOPL			
  0x4440db		90			NOPL			
  0x4440dc		90			NOPL			
  0x4440dd		90			NOPL			
  0x4440de		90			NOPL			
  0x4440df		90			NOPL			
  0x4440e0		90			NOPL			
  0x4440e1		90			NOPL			
  0x4440e2		90			NOPL			
  0x4440e3		90			NOPL			
  0x4440e4		90			NOPL			
  0x4440e5		90			NOPL			
  0x4440e6		90			NOPL			
  0x4440e7		90			NOPL			
  0x4440e8		90			NOPL			
  0x4440e9		90			NOPL			
  0x4440ea		90			NOPL			
  0x4440eb		90			NOPL			
  0x4440ec		90			NOPL			
  0x4440ed		90			NOPL			
  0x4440ee		90			NOPL			
  0x4440ef		90			NOPL			
  0x4440f0		90			NOPL			
  0x4440f1		90			NOPL			
  0x4440f2		90			NOPL			
  0x4440f3		90			NOPL			
  0x4440f4		90			NOPL			
  0x4440f5		90			NOPL			
  0x4440f6		90			NOPL			
  0x4440f7		90			NOPL			
  0x4440f8		90			NOPL			
  0x4440f9		90			NOPL			
  0x4440fa		90			NOPL			
  0x4440fb		90			NOPL			
  0x4440fc		90			NOPL			
  0x4440fd		90			NOPL			
  0x4440fe		90			NOPL			
  0x4440ff		90			NOPL			

TEXT _rt0_amd64(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444100		488b3c24		MOVQ 0(SP), DI		

  0x444104		488d742408		LEAQ 0x8(SP), SI	

  0x444109		e902000000		JMP runtime.rt0_go(SB)	

TEXT runtime.rt0_go(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444110		4889f8			MOVQ DI, AX		

  0x444113		4889f3			MOVQ SI, BX		

  0x444116		4883ec27		SUBQ $0x27, SP		

  0x44411a		4883e4f0		ANDQ $-0x10, SP		

  0x44411e		4889442410		MOVQ AX, 0x10(SP)	

  0x444123		48895c2418		MOVQ BX, 0x18(SP)	

  0x444128		488d3d31390600		LEAQ runtime.g0(SB), DI	

  0x44412f		488d9c246800ffff	LEAQ 0xffff0068(SP), BX	

  0x444137		48895f10		MOVQ BX, 0x10(DI)	

  0x44413b		48895f18		MOVQ BX, 0x18(DI)	

  0x44413f		48891f			MOVQ BX, 0(DI)		

  0x444142		48896708		MOVQ SP, 0x8(DI)	

  0x444146		b800000000		MOVL $0x0, AX		

  0x44414b		0fa2			CPUID			

  0x44414d		89c6			MOVL AX, SI		

  0x44414f		83f800			CMPL $0x0, AX		

  0x444152		0f8407010000		JE 0x44425f		

  0x444158		81fb47656e75		CMPL $0x756e6547, BX	

  0x44415e		751e			JNE 0x44417e		

  0x444160		81fa696e6549		CMPL $0x49656e69, DX	

  0x444166		7516			JNE 0x44417e		

  0x444168		81f96e74656c		CMPL $0x6c65746e, CX	

  0x44416e		750e			JNE 0x44417e		

  0x444170		c60533f7070001		MOVB $0x1, runtime.isIntel(SB)	

  0x444177		c60530f7070001		MOVB $0x1, runtime.lfenceBeforeRdtsc(SB)	

  0x44417e		b801000000		MOVL $0x1, AX		

  0x444183		0fa2			CPUID			

  0x444185		89056df70700		MOVL AX, runtime.processorVersionInfo(SB)	

  0x44418b		f7c200000004		TESTL $0x4000000, DX	

  0x444191		0f950521f70700		SETNE runtime.support_sse2(SB)	

  0x444198		f7c100020000		TESTL $0x200, CX	

  0x44419e		0f950517f70700		SETNE runtime.support_ssse3(SB)	

  0x4441a5		f7c100000800		TESTL $0x80000, CX	

  0x4441ab		0f950508f70700		SETNE runtime.support_sse41(SB)	

  0x4441b2		f7c100001000		TESTL $0x100000, CX	

  0x4441b8		0f9505fcf60700		SETNE runtime.support_sse42(SB)	

  0x4441bf		f7c100008000		TESTL $0x800000, CX	

  0x4441c5		0f9505ecf60700		SETNE runtime.support_popcnt(SB)	

  0x4441cc		f7c100000002		TESTL $0x2000000, CX	

  0x4441d2		0f9505d8f60700		SETNE runtime.support_aes(SB)	

  0x4441d9		f7c100000008		TESTL $0x8000000, CX	

  0x4441df		0f9505d1f60700		SETNE runtime.support_osxsave(SB)	

  0x4441e6		f7c100000010		TESTL $0x10000000, CX	

  0x4441ec		0f9505bff60700		SETNE runtime.support_avx(SB)	

  0x4441f3		83fe07			CMPL $0x7, SI		

  0x4441f6		7c40			JL 0x444238		

  0x4441f8		b807000000		MOVL $0x7, AX		

  0x4441fd		b900000000		MOVL $0x0, CX		

  0x444202		0fa2			CPUID			

  0x444204		f7c308000000		TESTL $0x8, BX		

  0x44420a		0f9505a3f60700		SETNE runtime.support_bmi1(SB)	

  0x444211		f7c320000000		TESTL $0x20, BX		

  0x444217		0f950595f60700		SETNE runtime.support_avx2(SB)	

  0x44421e		f7c300010000		TESTL $0x100, BX	

  0x444224		0f95058af60700		SETNE runtime.support_bmi2(SB)	

  0x44422b		f7c300020000		TESTL $0x200, BX	

  0x444231		0f95057ef60700		SETNE runtime.support_erms(SB)	

  0x444238		803d78f6070001		CMPB $0x1, runtime.support_osxsave(SB)	

  0x44423f		7510			JNE 0x444251		

  0x444241		b900000000		MOVL $0x0, CX		

  0x444246		0f01d0			XGETBV			

  0x444249		83e006			ANDL $0x6, AX		

  0x44424c		83f806			CMPL $0x6, AX		

  0x44424f		740e			JE 0x44425f		

  0x444251		c6055af6070000		MOVB $0x0, runtime.support_avx(SB)	

  0x444258		c60554f6070000		MOVB $0x0, runtime.support_avx2(SB)	

  0x44425f		488b0562330600		MOVQ _cgo_init(SB), AX	

  0x444266		4885c0			TESTQ AX, AX		

  0x444269		7426			JE 0x444291		

  0x44426b		4889f9			MOVQ DI, CX		

  0x44426e		488d354b1a0000		LEAQ setg_gcc(SB), SI	

  0x444275		ffd0			CALL AX			

  0x444277		488d0de2370600		LEAQ runtime.g0(SB), CX	

  0x44427e		488b01			MOVQ 0(CX), AX		

  0x444281		480570030000		ADDQ $0x370, AX		

  0x444287		48894110		MOVQ AX, 0x10(CX)	

  0x44428b		48894118		MOVQ AX, 0x18(CX)	

  0x44428f		eb2f			JMP 0x4442c0		

  0x444291		488d3d503d0600		LEAQ runtime.m0+136(SB), DI	

  0x444298		e8633c0000		CALL runtime.settls(SB)	

  0x44429d		6448c70425f8ffffff23010000	MOVQ $0x123, FS:0xfffffff8	

  0x4442aa		488b05373d0600		MOVQ runtime.m0+136(SB), AX	

  0x4442b1		483d23010000		CMPQ $0x123, AX		

  0x4442b7		7407			JE 0x4442c0		

  0x4442b9		89042500000000		MOVL AX, 0		

  0x4442c0		488d0d99370600		LEAQ runtime.g0(SB), CX	

  0x4442c7		6448890c25f8ffffff	MOVQ CX, FS:0xfffffff8	

  0x4442d0		488d05893c0600		LEAQ runtime.m0(SB), AX	

  0x4442d7		488908			MOVQ CX, 0(AX)		

  0x4442da		48894130		MOVQ AX, 0x30(CX)	

  0x4442de		fc			CLD			

  0x4442df		e85caffeff		CALL runtime.check(SB)	

  0x4442e4		8b442410		MOVL 0x10(SP), AX	

  0x4442e8		890424			MOVL AX, 0(SP)		

  0x4442eb		488b442418		MOVQ 0x18(SP), AX	

  0x4442f0		4889442408		MOVQ AX, 0x8(SP)	

  0x4442f5		e8d6a9feff		CALL runtime.args(SB)	

  0x4442fa		e811b1fdff		CALL runtime.osinit(SB)	

  0x4442ff		e85cf7fdff		CALL runtime.schedinit(SB)	

  0x444304		488d0535080300		LEAQ runtime.mainPC(SB), AX	

  0x44430b		50			PUSHL AX		

  0x44430c		6a00			PUSHL $0x0		

  0x44430e		e8dd5ffeff		CALL runtime.newproc(SB)	

  0x444313		58			POPL AX			

  0x444314		58			POPL AX			

  0x444315		e83614feff		CALL runtime.mstart(SB)	

  0x44431a		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x444325		c3			RET			

TEXT runtime.asminit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444330		c3			RET			

TEXT runtime.gogo(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444340		4883ec18		SUBQ $0x18, SP		
  0x444344		48896c2410		MOVQ BP, 0x10(SP)	
  0x444349		488d6c2410		LEAQ 0x10(SP), BP	

  0x44434e		488b5c2420		MOVQ 0x20(SP), BX	

  0x444353		488b5310		MOVQ 0x10(BX), DX	

  0x444357		488b0a			MOVQ 0(DX), CX		

  0x44435a		6448891425f8ffffff	MOVQ DX, FS:0xfffffff8	

  0x444363		488b23			MOVQ 0(BX), SP		

  0x444366		488b4320		MOVQ 0x20(BX), AX	

  0x44436a		488b5318		MOVQ 0x18(BX), DX	

  0x44436e		488b6b30		MOVQ 0x30(BX), BP	

  0x444372		48c70300000000		MOVQ $0x0, 0(BX)	

  0x444379		48c7432000000000	MOVQ $0x0, 0x20(BX)	

  0x444381		48c7431800000000	MOVQ $0x0, 0x18(BX)	

  0x444389		48c7433000000000	MOVQ $0x0, 0x30(BX)	

  0x444391		488b5b08		MOVQ 0x8(BX), BX	

  0x444395		ffe3			JMP BX			

TEXT runtime.mcall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4443a0		488b7c2408		MOVQ 0x8(SP), DI	

  0x4443a5		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x4443ae		488b1c24		MOVQ 0(SP), BX		

  0x4443b2		48895840		MOVQ BX, 0x40(AX)	

  0x4443b6		488d5c2408		LEAQ 0x8(SP), BX	

  0x4443bb		48895838		MOVQ BX, 0x38(AX)	

  0x4443bf		48894048		MOVQ AX, 0x48(AX)	

  0x4443c3		48896868		MOVQ BP, 0x68(AX)	

  0x4443c7		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	

  0x4443d0		488b5b30		MOVQ 0x30(BX), BX	

  0x4443d4		488b33			MOVQ 0(BX), SI		

  0x4443d7		4839c6			CMPQ AX, SI		

  0x4443da		7509			JNE 0x4443e5		

  0x4443dc		488d05bdf3fdff		LEAQ 0xfffdf3bd(IP), AX	

  0x4443e3		ffe0			JMP AX			

  0x4443e5		6448893425f8ffffff	MOVQ SI, FS:0xfffffff8	

  0x4443ee		488b6638		MOVQ 0x38(SI), SP	

  0x4443f2		50			PUSHL AX		

  0x4443f3		4889fa			MOVQ DI, DX		

  0x4443f6		488b3f			MOVQ 0(DI), DI		

  0x4443f9		ffd7			CALL DI			

  0x4443fb		58			POPL AX			

  0x4443fc		488d05ddf3fdff		LEAQ 0xfffdf3dd(IP), AX	

  0x444403		ffe0			JMP AX			

  0x444405		c3			RET			

TEXT runtime.systemstack_switch(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444410		c3			RET			

TEXT runtime.systemstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444420		488b7c2408		MOVQ 0x8(SP), DI	

  0x444425		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x44442e		488b5830		MOVQ 0x30(AX), BX	

  0x444432		488b5350		MOVQ 0x50(BX), DX	

  0x444436		4839d0			CMPQ DX, AX		

  0x444439		0f8484000000		JE 0x4444c3		

  0x44443f		488b13			MOVQ 0(BX), DX		

  0x444442		4839d0			CMPQ DX, AX		

  0x444445		747c			JE 0x4444c3		

  0x444447		4c8b83c0000000		MOVQ 0xc0(BX), R8	

  0x44444e		4c39c0			CMPQ R8, AX		

  0x444451		7409			JE 0x44445c		

  0x444453		488d05e632ffff		LEAQ 0xffff32e6(IP), AX	

  0x44445a		ffd0			CALL AX			

  0x44445c		488d35adffffff		LEAQ 0xffffffad(IP), SI	

  0x444463		48897040		MOVQ SI, 0x40(AX)	

  0x444467		48896038		MOVQ SP, 0x38(AX)	

  0x44446b		48894048		MOVQ AX, 0x48(AX)	

  0x44446f		48896868		MOVQ BP, 0x68(AX)	

  0x444473		6448891425f8ffffff	MOVQ DX, FS:0xfffffff8	

  0x44447c		488b5a38		MOVQ 0x38(DX), BX	

  0x444480		4883eb08		SUBQ $0x8, BX		

  0x444484		488d15c512feff		LEAQ 0xfffe12c5(IP), DX	

  0x44448b		488913			MOVQ DX, 0(BX)		

  0x44448e		4889dc			MOVQ BX, SP		

  0x444491		4889fa			MOVQ DI, DX		

  0x444494		488b3f			MOVQ 0(DI), DI		

  0x444497		ffd7			CALL DI			

  0x444499		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x4444a2		488b5830		MOVQ 0x30(AX), BX	

  0x4444a6		488b83c0000000		MOVQ 0xc0(BX), AX	

  0x4444ad		6448890425f8ffffff	MOVQ AX, FS:0xfffffff8	

  0x4444b6		488b6038		MOVQ 0x38(AX), SP	

  0x4444ba		48c7403800000000	MOVQ $0x0, 0x38(AX)	

  0x4444c2		c3			RET			

  0x4444c3		4889fa			MOVQ DI, DX		

  0x4444c6		488b3f			MOVQ 0(DI), DI		

  0x4444c9		ffe7			JMP DI			

TEXT runtime.morestack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4444d0		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	

  0x4444d9		488b5b30		MOVQ 0x30(BX), BX	

  0x4444dd		488b33			MOVQ 0(BX), SI		

  0x4444e0		6448393425f8ffffff	CMPQ SI, FS:0xfffffff8	

  0x4444e9		7507			JNE 0x4444f2		

  0x4444eb		e880f3fdff		CALL runtime.badmorestackg0(SB)	

  0x4444f0		cd03			INT $0x3		

  0x4444f2		488b7350		MOVQ 0x50(BX), SI	

  0x4444f6		6448393425f8ffffff	CMPQ SI, FS:0xfffffff8	

  0x4444ff		7507			JNE 0x444508		

  0x444501		e8aaf3fdff		CALL runtime.badmorestackgsignal(SB)	

  0x444506		cd03			INT $0x3		

  0x444508		488b442408		MOVQ 0x8(SP), AX	

  0x44450d		48894310		MOVQ AX, 0x10(BX)	

  0x444511		488d442410		LEAQ 0x10(SP), AX	

  0x444516		48894308		MOVQ AX, 0x8(BX)	

  0x44451a		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	

  0x444523		48897318		MOVQ SI, 0x18(BX)	

  0x444527		488b0424		MOVQ 0(SP), AX		

  0x44452b		48894640		MOVQ AX, 0x40(SI)	

  0x44452f		48897648		MOVQ SI, 0x48(SI)	

  0x444533		488d442408		LEAQ 0x8(SP), AX	

  0x444538		48894638		MOVQ AX, 0x38(SI)	

  0x44453c		48896e68		MOVQ BP, 0x68(SI)	

  0x444540		48895650		MOVQ DX, 0x50(SI)	

  0x444544		488b1b			MOVQ 0(BX), BX		

  0x444547		6448891c25f8ffffff	MOVQ BX, FS:0xfffffff8	

  0x444550		488b6338		MOVQ 0x38(BX), SP	

  0x444554		e85717ffff		CALL runtime.newstack(SB)	

  0x444559		48c704250310000000000000	MOVQ $0x0, 0x1003	

  0x444565		c3			RET			

TEXT runtime.morestack_noctxt(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444570		ba00000000		MOVL $0x0, DX		

  0x444575		e956ffffff		JMP runtime.morestack(SB)	

TEXT runtime.reflectcall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444580		8b4c2420		MOVL 0x20(SP), CX	

  0x444584		4883f920		CMPQ $0x20, CX			
  0x444588		7709			JA 0x444593			
  0x44458a		488d05ff010000		LEAQ runtime.call32(SB), AX	
  0x444591		ffe0			JMP AX				

  0x444593		4883f940		CMPQ $0x40, CX			
  0x444597		7709			JA 0x4445a2			
  0x444599		488d0570020000		LEAQ runtime.call64(SB), AX	
  0x4445a0		ffe0			JMP AX				

  0x4445a2		4881f980000000		CMPQ $0x80, CX			
  0x4445a9		7709			JA 0x4445b4			
  0x4445ab		488d05de020000		LEAQ runtime.call128(SB), AX	
  0x4445b2		ffe0			JMP AX				

  0x4445b4		4881f900010000		CMPQ $0x100, CX			
  0x4445bb		7709			JA 0x4445c6			
  0x4445bd		488d057c030000		LEAQ runtime.call256(SB), AX	
  0x4445c4		ffe0			JMP AX				

  0x4445c6		4881f900020000		CMPQ $0x200, CX			
  0x4445cd		7709			JA 0x4445d8			
  0x4445cf		488d051a040000		LEAQ runtime.call512(SB), AX	
  0x4445d6		ffe0			JMP AX				

  0x4445d8		4881f900040000		CMPQ $0x400, CX			
  0x4445df		7709			JA 0x4445ea			
  0x4445e1		488d05b8040000		LEAQ runtime.call1024(SB), AX	
  0x4445e8		ffe0			JMP AX				

  0x4445ea		4881f900080000		CMPQ $0x800, CX			
  0x4445f1		7709			JA 0x4445fc			
  0x4445f3		488d0556050000		LEAQ runtime.call2048(SB), AX	
  0x4445fa		ffe0			JMP AX				

  0x4445fc		4881f900100000		CMPQ $0x1000, CX		
  0x444603		7709			JA 0x44460e			
  0x444605		488d05f4050000		LEAQ runtime.call4096(SB), AX	
  0x44460c		ffe0			JMP AX				

  0x44460e		4881f900200000		CMPQ $0x2000, CX		
  0x444615		7709			JA 0x444620			
  0x444617		488d05b2060000		LEAQ runtime.call8192(SB), AX	
  0x44461e		ffe0			JMP AX				

  0x444620		4881f900400000		CMPQ $0x4000, CX		
  0x444627		7709			JA 0x444632			
  0x444629		488d0570070000		LEAQ runtime.call16384(SB), AX	
  0x444630		ffe0			JMP AX				

  0x444632		4881f900800000		CMPQ $0x8000, CX		
  0x444639		7709			JA 0x444644			
  0x44463b		488d052e080000		LEAQ runtime.call32768(SB), AX	
  0x444642		ffe0			JMP AX				

  0x444644		4881f900000100		CMPQ $0x10000, CX		
  0x44464b		7709			JA 0x444656			
  0x44464d		488d05ec080000		LEAQ runtime.call65536(SB), AX	
  0x444654		ffe0			JMP AX				

  0x444656		4881f900000200		CMPQ $0x20000, CX		
  0x44465d		7709			JA 0x444668			
  0x44465f		488d05aa090000		LEAQ runtime.call131072(SB), AX	
  0x444666		ffe0			JMP AX				

  0x444668		4881f900000400		CMPQ $0x40000, CX		
  0x44466f		7709			JA 0x44467a			
  0x444671		488d05680a0000		LEAQ runtime.call262144(SB), AX	
  0x444678		ffe0			JMP AX				

  0x44467a		4881f900000800		CMPQ $0x80000, CX		
  0x444681		7709			JA 0x44468c			
  0x444683		488d05260b0000		LEAQ runtime.call524288(SB), AX	
  0x44468a		ffe0			JMP AX				

  0x44468c		4881f900001000		CMPQ $0x100000, CX			
  0x444693		7709			JA 0x44469e				
  0x444695		488d05e40b0000		LEAQ runtime.call1048576(SB), AX	
  0x44469c		ffe0			JMP AX					

  0x44469e		4881f900002000		CMPQ $0x200000, CX			
  0x4446a5		7709			JA 0x4446b0				
  0x4446a7		488d05a20c0000		LEAQ runtime.call2097152(SB), AX	
  0x4446ae		ffe0			JMP AX					

  0x4446b0		4881f900004000		CMPQ $0x400000, CX			
  0x4446b7		7709			JA 0x4446c2				
  0x4446b9		488d05600d0000		LEAQ runtime.call4194304(SB), AX	
  0x4446c0		ffe0			JMP AX					

  0x4446c2		4881f900008000		CMPQ $0x800000, CX			
  0x4446c9		7709			JA 0x4446d4				
  0x4446cb		488d051e0e0000		LEAQ runtime.call8388608(SB), AX	
  0x4446d2		ffe0			JMP AX					

  0x4446d4		4881f900000001		CMPQ $0x1000000, CX			
  0x4446db		7709			JA 0x4446e6				
  0x4446dd		488d05dc0e0000		LEAQ runtime.call16777216(SB), AX	
  0x4446e4		ffe0			JMP AX					

  0x4446e6		4881f900000002		CMPQ $0x2000000, CX			
  0x4446ed		7709			JA 0x4446f8				
  0x4446ef		488d059a0f0000		LEAQ runtime.call33554432(SB), AX	
  0x4446f6		ffe0			JMP AX					

  0x4446f8		4881f900000004		CMPQ $0x4000000, CX			
  0x4446ff		7709			JA 0x44470a				
  0x444701		488d0558100000		LEAQ runtime.call67108864(SB), AX	
  0x444708		ffe0			JMP AX					

  0x44470a		4881f900000008		CMPQ $0x8000000, CX			
  0x444711		7709			JA 0x44471c				
  0x444713		488d0516110000		LEAQ runtime.call134217728(SB), AX	
  0x44471a		ffe0			JMP AX					

  0x44471c		4881f900000010		CMPQ $0x10000000, CX			
  0x444723		7709			JA 0x44472e				
  0x444725		488d05d4110000		LEAQ runtime.call268435456(SB), AX	
  0x44472c		ffe0			JMP AX					

  0x44472e		4881f900000020		CMPQ $0x20000000, CX			
  0x444735		7709			JA 0x444740				
  0x444737		488d0592120000		LEAQ runtime.call536870912(SB), AX	
  0x44473e		ffe0			JMP AX					

  0x444740		4881f900000040		CMPQ $0x40000000, CX			
  0x444747		7709			JA 0x444752				
  0x444749		488d0550130000		LEAQ runtime.call1073741824(SB), AX	
  0x444750		ffe0			JMP AX					

  0x444752		488d05c7f0fdff		LEAQ 0xfffdf0c7(IP), AX	

  0x444759		ffe0			JMP AX			

TEXT callRet(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444760		4883ec28		SUBQ $0x28, SP		
  0x444764		48896c2420		MOVQ BP, 0x20(SP)	
  0x444769		488d6c2420		LEAQ 0x20(SP), BP	

  0x44476e		48891424		MOVQ DX, 0(SP)		

  0x444772		48897c2408		MOVQ DI, 0x8(SP)	

  0x444777		4889742410		MOVQ SI, 0x10(SP)	

  0x44477c		48894c2418		MOVQ CX, 0x18(SP)	

  0x444781		e8ba73fcff		CALL runtime.reflectcallmove(SB)	

  0x444786		488b6c2420		MOVQ 0x20(SP), BP	
  0x44478b		4883c428		ADDQ $0x28, SP		
  0x44478f		c3			RET			

TEXT runtime.call32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444799		483b6110		CMPQ 0x10(CX), SP			
  0x44479d		7659			JBE 0x4447f8				
  0x44479f		4883ec28		SUBQ $0x28, SP				
  0x4447a3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4447a8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4447ad		488b5920		MOVQ 0x20(CX), BX			
  0x4447b1		4885db			TESTQ BX, BX				
  0x4447b4		7549			JNE 0x4447ff				
  0x4447b6		488b742440		MOVQ 0x40(SP), SI			
  0x4447bb		8b4c2448		MOVL 0x48(SP), CX			
  0x4447bf		4889e7			MOVQ SP, DI				
  0x4447c2		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4447c4		488b542438		MOVQ 0x38(SP), DX			
  0x4447c9		ff12			CALL 0(DX)				
  0x4447cb		488b542430		MOVQ 0x30(SP), DX			
  0x4447d0		488b7c2440		MOVQ 0x40(SP), DI			
  0x4447d5		8b4c2448		MOVL 0x48(SP), CX			
  0x4447d9		8b5c244c		MOVL 0x4c(SP), BX			
  0x4447dd		4889e6			MOVQ SP, SI				
  0x4447e0		4801df			ADDQ BX, DI				
  0x4447e3		4801de			ADDQ BX, SI				
  0x4447e6		4829d9			SUBQ BX, CX				
  0x4447e9		e872ffffff		CALL callRet(SB)			
  0x4447ee		488b6c2420		MOVQ 0x20(SP), BP			
  0x4447f3		4883c428		ADDQ $0x28, SP				
  0x4447f7		c3			RET					
  0x4447f8		e873fdffff		CALL runtime.morestack_noctxt(SB)	
  0x4447fd		eb91			JMP runtime.call32(SB)			
  0x4447ff		488d7c2430		LEAQ 0x30(SP), DI			
  0x444804		48393b			CMPQ DI, 0(BX)				
  0x444807		75ad			JNE 0x4447b6				
  0x444809		488923			MOVQ SP, 0(BX)				
  0x44480c		eba8			JMP 0x4447b6				

TEXT runtime.call64(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444810		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444819		483b6110		CMPQ 0x10(CX), SP			
  0x44481d		7659			JBE 0x444878				
  0x44481f		4883ec48		SUBQ $0x48, SP				
  0x444823		48896c2440		MOVQ BP, 0x40(SP)			
  0x444828		488d6c2440		LEAQ 0x40(SP), BP			
  0x44482d		488b5920		MOVQ 0x20(CX), BX			
  0x444831		4885db			TESTQ BX, BX				
  0x444834		7549			JNE 0x44487f				
  0x444836		488b742460		MOVQ 0x60(SP), SI			
  0x44483b		8b4c2468		MOVL 0x68(SP), CX			
  0x44483f		4889e7			MOVQ SP, DI				
  0x444842		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444844		488b542458		MOVQ 0x58(SP), DX			
  0x444849		ff12			CALL 0(DX)				
  0x44484b		488b542450		MOVQ 0x50(SP), DX			
  0x444850		488b7c2460		MOVQ 0x60(SP), DI			
  0x444855		8b4c2468		MOVL 0x68(SP), CX			
  0x444859		8b5c246c		MOVL 0x6c(SP), BX			
  0x44485d		4889e6			MOVQ SP, SI				
  0x444860		4801df			ADDQ BX, DI				
  0x444863		4801de			ADDQ BX, SI				
  0x444866		4829d9			SUBQ BX, CX				
  0x444869		e8f2feffff		CALL callRet(SB)			
  0x44486e		488b6c2440		MOVQ 0x40(SP), BP			
  0x444873		4883c448		ADDQ $0x48, SP				
  0x444877		c3			RET					
  0x444878		e8f3fcffff		CALL runtime.morestack_noctxt(SB)	
  0x44487d		eb91			JMP runtime.call64(SB)			
  0x44487f		488d7c2450		LEAQ 0x50(SP), DI			
  0x444884		48393b			CMPQ DI, 0(BX)				
  0x444887		75ad			JNE 0x444836				
  0x444889		488923			MOVQ SP, 0(BX)				
  0x44488c		eba8			JMP 0x444836				

TEXT runtime.call128(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444890		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444899		488d4424f8		LEAQ -0x8(SP), AX			
  0x44489e		483b4110		CMPQ 0x10(CX), AX			
  0x4448a2		767d			JBE 0x444921				
  0x4448a4		4881ec88000000		SUBQ $0x88, SP				
  0x4448ab		4889ac2480000000	MOVQ BP, 0x80(SP)			
  0x4448b3		488dac2480000000	LEAQ 0x80(SP), BP			
  0x4448bb		488b5920		MOVQ 0x20(CX), BX			
  0x4448bf		4885db			TESTQ BX, BX				
  0x4448c2		7567			JNE 0x44492b				
  0x4448c4		488bb424a0000000	MOVQ 0xa0(SP), SI			
  0x4448cc		8b8c24a8000000		MOVL 0xa8(SP), CX			
  0x4448d3		4889e7			MOVQ SP, DI				
  0x4448d6		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4448d8		488b942498000000	MOVQ 0x98(SP), DX			
  0x4448e0		ff12			CALL 0(DX)				
  0x4448e2		488b942490000000	MOVQ 0x90(SP), DX			
  0x4448ea		488bbc24a0000000	MOVQ 0xa0(SP), DI			
  0x4448f2		8b8c24a8000000		MOVL 0xa8(SP), CX			
  0x4448f9		8b9c24ac000000		MOVL 0xac(SP), BX			
  0x444900		4889e6			MOVQ SP, SI				
  0x444903		4801df			ADDQ BX, DI				
  0x444906		4801de			ADDQ BX, SI				
  0x444909		4829d9			SUBQ BX, CX				
  0x44490c		e84ffeffff		CALL callRet(SB)			
  0x444911		488bac2480000000	MOVQ 0x80(SP), BP			
  0x444919		4881c488000000		ADDQ $0x88, SP				
  0x444920		c3			RET					
  0x444921		e84afcffff		CALL runtime.morestack_noctxt(SB)	
  0x444926		e965ffffff		JMP runtime.call128(SB)			
  0x44492b		488dbc2490000000	LEAQ 0x90(SP), DI			
  0x444933		48393b			CMPQ DI, 0(BX)				
  0x444936		758c			JNE 0x4448c4				
  0x444938		488923			MOVQ SP, 0(BX)				
  0x44493b		eb87			JMP 0x4448c4				

TEXT runtime.call256(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444940		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444949		488d842478ffffff	LEAQ 0xffffff78(SP), AX			
  0x444951		483b4110		CMPQ 0x10(CX), AX			
  0x444955		767d			JBE 0x4449d4				
  0x444957		4881ec08010000		SUBQ $0x108, SP				
  0x44495e		4889ac2400010000	MOVQ BP, 0x100(SP)			
  0x444966		488dac2400010000	LEAQ 0x100(SP), BP			
  0x44496e		488b5920		MOVQ 0x20(CX), BX			
  0x444972		4885db			TESTQ BX, BX				
  0x444975		7567			JNE 0x4449de				
  0x444977		488bb42420010000	MOVQ 0x120(SP), SI			
  0x44497f		8b8c2428010000		MOVL 0x128(SP), CX			
  0x444986		4889e7			MOVQ SP, DI				
  0x444989		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x44498b		488b942418010000	MOVQ 0x118(SP), DX			
  0x444993		ff12			CALL 0(DX)				
  0x444995		488b942410010000	MOVQ 0x110(SP), DX			
  0x44499d		488bbc2420010000	MOVQ 0x120(SP), DI			
  0x4449a5		8b8c2428010000		MOVL 0x128(SP), CX			
  0x4449ac		8b9c242c010000		MOVL 0x12c(SP), BX			
  0x4449b3		4889e6			MOVQ SP, SI				
  0x4449b6		4801df			ADDQ BX, DI				
  0x4449b9		4801de			ADDQ BX, SI				
  0x4449bc		4829d9			SUBQ BX, CX				
  0x4449bf		e89cfdffff		CALL callRet(SB)			
  0x4449c4		488bac2400010000	MOVQ 0x100(SP), BP			
  0x4449cc		4881c408010000		ADDQ $0x108, SP				
  0x4449d3		c3			RET					
  0x4449d4		e897fbffff		CALL runtime.morestack_noctxt(SB)	
  0x4449d9		e962ffffff		JMP runtime.call256(SB)			
  0x4449de		488dbc2410010000	LEAQ 0x110(SP), DI			
  0x4449e6		48393b			CMPQ DI, 0(BX)				
  0x4449e9		758c			JNE 0x444977				
  0x4449eb		488923			MOVQ SP, 0(BX)				
  0x4449ee		eb87			JMP 0x444977				

TEXT runtime.call512(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4449f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4449f9		488d842478feffff	LEAQ 0xfffffe78(SP), AX			
  0x444a01		483b4110		CMPQ 0x10(CX), AX			
  0x444a05		767d			JBE 0x444a84				
  0x444a07		4881ec08020000		SUBQ $0x208, SP				
  0x444a0e		4889ac2400020000	MOVQ BP, 0x200(SP)			
  0x444a16		488dac2400020000	LEAQ 0x200(SP), BP			
  0x444a1e		488b5920		MOVQ 0x20(CX), BX			
  0x444a22		4885db			TESTQ BX, BX				
  0x444a25		7567			JNE 0x444a8e				
  0x444a27		488bb42420020000	MOVQ 0x220(SP), SI			
  0x444a2f		8b8c2428020000		MOVL 0x228(SP), CX			
  0x444a36		4889e7			MOVQ SP, DI				
  0x444a39		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444a3b		488b942418020000	MOVQ 0x218(SP), DX			
  0x444a43		ff12			CALL 0(DX)				
  0x444a45		488b942410020000	MOVQ 0x210(SP), DX			
  0x444a4d		488bbc2420020000	MOVQ 0x220(SP), DI			
  0x444a55		8b8c2428020000		MOVL 0x228(SP), CX			
  0x444a5c		8b9c242c020000		MOVL 0x22c(SP), BX			
  0x444a63		4889e6			MOVQ SP, SI				
  0x444a66		4801df			ADDQ BX, DI				
  0x444a69		4801de			ADDQ BX, SI				
  0x444a6c		4829d9			SUBQ BX, CX				
  0x444a6f		e8ecfcffff		CALL callRet(SB)			
  0x444a74		488bac2400020000	MOVQ 0x200(SP), BP			
  0x444a7c		4881c408020000		ADDQ $0x208, SP				
  0x444a83		c3			RET					
  0x444a84		e8e7faffff		CALL runtime.morestack_noctxt(SB)	
  0x444a89		e962ffffff		JMP runtime.call512(SB)			
  0x444a8e		488dbc2410020000	LEAQ 0x210(SP), DI			
  0x444a96		48393b			CMPQ DI, 0(BX)				
  0x444a99		758c			JNE 0x444a27				
  0x444a9b		488923			MOVQ SP, 0(BX)				
  0x444a9e		eb87			JMP 0x444a27				

TEXT runtime.call1024(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444aa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444aa9		488d842478fcffff	LEAQ 0xfffffc78(SP), AX			
  0x444ab1		483b4110		CMPQ 0x10(CX), AX			
  0x444ab5		767d			JBE 0x444b34				
  0x444ab7		4881ec08040000		SUBQ $0x408, SP				
  0x444abe		4889ac2400040000	MOVQ BP, 0x400(SP)			
  0x444ac6		488dac2400040000	LEAQ 0x400(SP), BP			
  0x444ace		488b5920		MOVQ 0x20(CX), BX			
  0x444ad2		4885db			TESTQ BX, BX				
  0x444ad5		7567			JNE 0x444b3e				
  0x444ad7		488bb42420040000	MOVQ 0x420(SP), SI			
  0x444adf		8b8c2428040000		MOVL 0x428(SP), CX			
  0x444ae6		4889e7			MOVQ SP, DI				
  0x444ae9		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444aeb		488b942418040000	MOVQ 0x418(SP), DX			
  0x444af3		ff12			CALL 0(DX)				
  0x444af5		488b942410040000	MOVQ 0x410(SP), DX			
  0x444afd		488bbc2420040000	MOVQ 0x420(SP), DI			
  0x444b05		8b8c2428040000		MOVL 0x428(SP), CX			
  0x444b0c		8b9c242c040000		MOVL 0x42c(SP), BX			
  0x444b13		4889e6			MOVQ SP, SI				
  0x444b16		4801df			ADDQ BX, DI				
  0x444b19		4801de			ADDQ BX, SI				
  0x444b1c		4829d9			SUBQ BX, CX				
  0x444b1f		e83cfcffff		CALL callRet(SB)			
  0x444b24		488bac2400040000	MOVQ 0x400(SP), BP			
  0x444b2c		4881c408040000		ADDQ $0x408, SP				
  0x444b33		c3			RET					
  0x444b34		e837faffff		CALL runtime.morestack_noctxt(SB)	
  0x444b39		e962ffffff		JMP runtime.call1024(SB)		
  0x444b3e		488dbc2410040000	LEAQ 0x410(SP), DI			
  0x444b46		48393b			CMPQ DI, 0(BX)				
  0x444b49		758c			JNE 0x444ad7				
  0x444b4b		488923			MOVQ SP, 0(BX)				
  0x444b4e		eb87			JMP 0x444ad7				

TEXT runtime.call2048(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444b50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444b59		488d842478f8ffff	LEAQ 0xfffff878(SP), AX			
  0x444b61		483b4110		CMPQ 0x10(CX), AX			
  0x444b65		767d			JBE 0x444be4				
  0x444b67		4881ec08080000		SUBQ $0x808, SP				
  0x444b6e		4889ac2400080000	MOVQ BP, 0x800(SP)			
  0x444b76		488dac2400080000	LEAQ 0x800(SP), BP			
  0x444b7e		488b5920		MOVQ 0x20(CX), BX			
  0x444b82		4885db			TESTQ BX, BX				
  0x444b85		7567			JNE 0x444bee				
  0x444b87		488bb42420080000	MOVQ 0x820(SP), SI			
  0x444b8f		8b8c2428080000		MOVL 0x828(SP), CX			
  0x444b96		4889e7			MOVQ SP, DI				
  0x444b99		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444b9b		488b942418080000	MOVQ 0x818(SP), DX			
  0x444ba3		ff12			CALL 0(DX)				
  0x444ba5		488b942410080000	MOVQ 0x810(SP), DX			
  0x444bad		488bbc2420080000	MOVQ 0x820(SP), DI			
  0x444bb5		8b8c2428080000		MOVL 0x828(SP), CX			
  0x444bbc		8b9c242c080000		MOVL 0x82c(SP), BX			
  0x444bc3		4889e6			MOVQ SP, SI				
  0x444bc6		4801df			ADDQ BX, DI				
  0x444bc9		4801de			ADDQ BX, SI				
  0x444bcc		4829d9			SUBQ BX, CX				
  0x444bcf		e88cfbffff		CALL callRet(SB)			
  0x444bd4		488bac2400080000	MOVQ 0x800(SP), BP			
  0x444bdc		4881c408080000		ADDQ $0x808, SP				
  0x444be3		c3			RET					
  0x444be4		e887f9ffff		CALL runtime.morestack_noctxt(SB)	
  0x444be9		e962ffffff		JMP runtime.call2048(SB)		
  0x444bee		488dbc2410080000	LEAQ 0x810(SP), DI			
  0x444bf6		48393b			CMPQ DI, 0(BX)				
  0x444bf9		758c			JNE 0x444b87				
  0x444bfb		488923			MOVQ SP, 0(BX)				
  0x444bfe		eb87			JMP 0x444b87				

TEXT runtime.call4096(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444c00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444c09		488b7110		MOVQ 0x10(CX), SI			
  0x444c0d		4881fedefaffff		CMPQ $-0x522, SI			
  0x444c14		0f8490000000		JE 0x444caa				
  0x444c1a		488d842470030000	LEAQ 0x370(SP), AX			
  0x444c22		4829f0			SUBQ SI, AX				
  0x444c25		483df8120000		CMPQ $0x12f8, AX			
  0x444c2b		767d			JBE 0x444caa				
  0x444c2d		4881ec08100000		SUBQ $0x1008, SP			
  0x444c34		4889ac2400100000	MOVQ BP, 0x1000(SP)			
  0x444c3c		488dac2400100000	LEAQ 0x1000(SP), BP			
  0x444c44		488b5920		MOVQ 0x20(CX), BX			
  0x444c48		4885db			TESTQ BX, BX				
  0x444c4b		7567			JNE 0x444cb4				
  0x444c4d		488bb42420100000	MOVQ 0x1020(SP), SI			
  0x444c55		8b8c2428100000		MOVL 0x1028(SP), CX			
  0x444c5c		4889e7			MOVQ SP, DI				
  0x444c5f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444c61		488b942418100000	MOVQ 0x1018(SP), DX			
  0x444c69		ff12			CALL 0(DX)				
  0x444c6b		488b942410100000	MOVQ 0x1010(SP), DX			
  0x444c73		488bbc2420100000	MOVQ 0x1020(SP), DI			
  0x444c7b		8b8c2428100000		MOVL 0x1028(SP), CX			
  0x444c82		8b9c242c100000		MOVL 0x102c(SP), BX			
  0x444c89		4889e6			MOVQ SP, SI				
  0x444c8c		4801df			ADDQ BX, DI				
  0x444c8f		4801de			ADDQ BX, SI				
  0x444c92		4829d9			SUBQ BX, CX				
  0x444c95		e8c6faffff		CALL callRet(SB)			
  0x444c9a		488bac2400100000	MOVQ 0x1000(SP), BP			
  0x444ca2		4881c408100000		ADDQ $0x1008, SP			
  0x444ca9		c3			RET					
  0x444caa		e8c1f8ffff		CALL runtime.morestack_noctxt(SB)	
  0x444caf		e94cffffff		JMP runtime.call4096(SB)		
  0x444cb4		488dbc2410100000	LEAQ 0x1010(SP), DI			
  0x444cbc		48393b			CMPQ DI, 0(BX)				
  0x444cbf		758c			JNE 0x444c4d				
  0x444cc1		488923			MOVQ SP, 0(BX)				
  0x444cc4		eb87			JMP 0x444c4d				

TEXT runtime.call8192(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444cd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444cd9		488b7110		MOVQ 0x10(CX), SI			
  0x444cdd		4881fedefaffff		CMPQ $-0x522, SI			
  0x444ce4		0f8490000000		JE 0x444d7a				
  0x444cea		488d842470030000	LEAQ 0x370(SP), AX			
  0x444cf2		4829f0			SUBQ SI, AX				
  0x444cf5		483df8220000		CMPQ $0x22f8, AX			
  0x444cfb		767d			JBE 0x444d7a				
  0x444cfd		4881ec08200000		SUBQ $0x2008, SP			
  0x444d04		4889ac2400200000	MOVQ BP, 0x2000(SP)			
  0x444d0c		488dac2400200000	LEAQ 0x2000(SP), BP			
  0x444d14		488b5920		MOVQ 0x20(CX), BX			
  0x444d18		4885db			TESTQ BX, BX				
  0x444d1b		7567			JNE 0x444d84				
  0x444d1d		488bb42420200000	MOVQ 0x2020(SP), SI			
  0x444d25		8b8c2428200000		MOVL 0x2028(SP), CX			
  0x444d2c		4889e7			MOVQ SP, DI				
  0x444d2f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444d31		488b942418200000	MOVQ 0x2018(SP), DX			
  0x444d39		ff12			CALL 0(DX)				
  0x444d3b		488b942410200000	MOVQ 0x2010(SP), DX			
  0x444d43		488bbc2420200000	MOVQ 0x2020(SP), DI			
  0x444d4b		8b8c2428200000		MOVL 0x2028(SP), CX			
  0x444d52		8b9c242c200000		MOVL 0x202c(SP), BX			
  0x444d59		4889e6			MOVQ SP, SI				
  0x444d5c		4801df			ADDQ BX, DI				
  0x444d5f		4801de			ADDQ BX, SI				
  0x444d62		4829d9			SUBQ BX, CX				
  0x444d65		e8f6f9ffff		CALL callRet(SB)			
  0x444d6a		488bac2400200000	MOVQ 0x2000(SP), BP			
  0x444d72		4881c408200000		ADDQ $0x2008, SP			
  0x444d79		c3			RET					
  0x444d7a		e8f1f7ffff		CALL runtime.morestack_noctxt(SB)	
  0x444d7f		e94cffffff		JMP runtime.call8192(SB)		
  0x444d84		488dbc2410200000	LEAQ 0x2010(SP), DI			
  0x444d8c		48393b			CMPQ DI, 0(BX)				
  0x444d8f		758c			JNE 0x444d1d				
  0x444d91		488923			MOVQ SP, 0(BX)				
  0x444d94		eb87			JMP 0x444d1d				

TEXT runtime.call16384(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444da0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444da9		488b7110		MOVQ 0x10(CX), SI			
  0x444dad		4881fedefaffff		CMPQ $-0x522, SI			
  0x444db4		0f8490000000		JE 0x444e4a				
  0x444dba		488d842470030000	LEAQ 0x370(SP), AX			
  0x444dc2		4829f0			SUBQ SI, AX				
  0x444dc5		483df8420000		CMPQ $0x42f8, AX			
  0x444dcb		767d			JBE 0x444e4a				
  0x444dcd		4881ec08400000		SUBQ $0x4008, SP			
  0x444dd4		4889ac2400400000	MOVQ BP, 0x4000(SP)			
  0x444ddc		488dac2400400000	LEAQ 0x4000(SP), BP			
  0x444de4		488b5920		MOVQ 0x20(CX), BX			
  0x444de8		4885db			TESTQ BX, BX				
  0x444deb		7567			JNE 0x444e54				
  0x444ded		488bb42420400000	MOVQ 0x4020(SP), SI			
  0x444df5		8b8c2428400000		MOVL 0x4028(SP), CX			
  0x444dfc		4889e7			MOVQ SP, DI				
  0x444dff		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444e01		488b942418400000	MOVQ 0x4018(SP), DX			
  0x444e09		ff12			CALL 0(DX)				
  0x444e0b		488b942410400000	MOVQ 0x4010(SP), DX			
  0x444e13		488bbc2420400000	MOVQ 0x4020(SP), DI			
  0x444e1b		8b8c2428400000		MOVL 0x4028(SP), CX			
  0x444e22		8b9c242c400000		MOVL 0x402c(SP), BX			
  0x444e29		4889e6			MOVQ SP, SI				
  0x444e2c		4801df			ADDQ BX, DI				
  0x444e2f		4801de			ADDQ BX, SI				
  0x444e32		4829d9			SUBQ BX, CX				
  0x444e35		e826f9ffff		CALL callRet(SB)			
  0x444e3a		488bac2400400000	MOVQ 0x4000(SP), BP			
  0x444e42		4881c408400000		ADDQ $0x4008, SP			
  0x444e49		c3			RET					
  0x444e4a		e821f7ffff		CALL runtime.morestack_noctxt(SB)	
  0x444e4f		e94cffffff		JMP runtime.call16384(SB)		
  0x444e54		488dbc2410400000	LEAQ 0x4010(SP), DI			
  0x444e5c		48393b			CMPQ DI, 0(BX)				
  0x444e5f		758c			JNE 0x444ded				
  0x444e61		488923			MOVQ SP, 0(BX)				
  0x444e64		eb87			JMP 0x444ded				

TEXT runtime.call32768(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444e70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444e79		488b7110		MOVQ 0x10(CX), SI			
  0x444e7d		4881fedefaffff		CMPQ $-0x522, SI			
  0x444e84		0f8490000000		JE 0x444f1a				
  0x444e8a		488d842470030000	LEAQ 0x370(SP), AX			
  0x444e92		4829f0			SUBQ SI, AX				
  0x444e95		483df8820000		CMPQ $0x82f8, AX			
  0x444e9b		767d			JBE 0x444f1a				
  0x444e9d		4881ec08800000		SUBQ $0x8008, SP			
  0x444ea4		4889ac2400800000	MOVQ BP, 0x8000(SP)			
  0x444eac		488dac2400800000	LEAQ 0x8000(SP), BP			
  0x444eb4		488b5920		MOVQ 0x20(CX), BX			
  0x444eb8		4885db			TESTQ BX, BX				
  0x444ebb		7567			JNE 0x444f24				
  0x444ebd		488bb42420800000	MOVQ 0x8020(SP), SI			
  0x444ec5		8b8c2428800000		MOVL 0x8028(SP), CX			
  0x444ecc		4889e7			MOVQ SP, DI				
  0x444ecf		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444ed1		488b942418800000	MOVQ 0x8018(SP), DX			
  0x444ed9		ff12			CALL 0(DX)				
  0x444edb		488b942410800000	MOVQ 0x8010(SP), DX			
  0x444ee3		488bbc2420800000	MOVQ 0x8020(SP), DI			
  0x444eeb		8b8c2428800000		MOVL 0x8028(SP), CX			
  0x444ef2		8b9c242c800000		MOVL 0x802c(SP), BX			
  0x444ef9		4889e6			MOVQ SP, SI				
  0x444efc		4801df			ADDQ BX, DI				
  0x444eff		4801de			ADDQ BX, SI				
  0x444f02		4829d9			SUBQ BX, CX				
  0x444f05		e856f8ffff		CALL callRet(SB)			
  0x444f0a		488bac2400800000	MOVQ 0x8000(SP), BP			
  0x444f12		4881c408800000		ADDQ $0x8008, SP			
  0x444f19		c3			RET					
  0x444f1a		e851f6ffff		CALL runtime.morestack_noctxt(SB)	
  0x444f1f		e94cffffff		JMP runtime.call32768(SB)		
  0x444f24		488dbc2410800000	LEAQ 0x8010(SP), DI			
  0x444f2c		48393b			CMPQ DI, 0(BX)				
  0x444f2f		758c			JNE 0x444ebd				
  0x444f31		488923			MOVQ SP, 0(BX)				
  0x444f34		eb87			JMP 0x444ebd				

TEXT runtime.call65536(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x444f40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x444f49		488b7110		MOVQ 0x10(CX), SI			
  0x444f4d		4881fedefaffff		CMPQ $-0x522, SI			
  0x444f54		0f8490000000		JE 0x444fea				
  0x444f5a		488d842470030000	LEAQ 0x370(SP), AX			
  0x444f62		4829f0			SUBQ SI, AX				
  0x444f65		483df8020100		CMPQ $0x102f8, AX			
  0x444f6b		767d			JBE 0x444fea				
  0x444f6d		4881ec08000100		SUBQ $0x10008, SP			
  0x444f74		4889ac2400000100	MOVQ BP, 0x10000(SP)			
  0x444f7c		488dac2400000100	LEAQ 0x10000(SP), BP			
  0x444f84		488b5920		MOVQ 0x20(CX), BX			
  0x444f88		4885db			TESTQ BX, BX				
  0x444f8b		7567			JNE 0x444ff4				
  0x444f8d		488bb42420000100	MOVQ 0x10020(SP), SI			
  0x444f95		8b8c2428000100		MOVL 0x10028(SP), CX			
  0x444f9c		4889e7			MOVQ SP, DI				
  0x444f9f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x444fa1		488b942418000100	MOVQ 0x10018(SP), DX			
  0x444fa9		ff12			CALL 0(DX)				
  0x444fab		488b942410000100	MOVQ 0x10010(SP), DX			
  0x444fb3		488bbc2420000100	MOVQ 0x10020(SP), DI			
  0x444fbb		8b8c2428000100		MOVL 0x10028(SP), CX			
  0x444fc2		8b9c242c000100		MOVL 0x1002c(SP), BX			
  0x444fc9		4889e6			MOVQ SP, SI				
  0x444fcc		4801df			ADDQ BX, DI				
  0x444fcf		4801de			ADDQ BX, SI				
  0x444fd2		4829d9			SUBQ BX, CX				
  0x444fd5		e886f7ffff		CALL callRet(SB)			
  0x444fda		488bac2400000100	MOVQ 0x10000(SP), BP			
  0x444fe2		4881c408000100		ADDQ $0x10008, SP			
  0x444fe9		c3			RET					
  0x444fea		e881f5ffff		CALL runtime.morestack_noctxt(SB)	
  0x444fef		e94cffffff		JMP runtime.call65536(SB)		
  0x444ff4		488dbc2410000100	LEAQ 0x10010(SP), DI			
  0x444ffc		48393b			CMPQ DI, 0(BX)				
  0x444fff		758c			JNE 0x444f8d				
  0x445001		488923			MOVQ SP, 0(BX)				
  0x445004		eb87			JMP 0x444f8d				

TEXT runtime.call131072(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445010		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445019		488b7110		MOVQ 0x10(CX), SI			
  0x44501d		4881fedefaffff		CMPQ $-0x522, SI			
  0x445024		0f8490000000		JE 0x4450ba				
  0x44502a		488d842470030000	LEAQ 0x370(SP), AX			
  0x445032		4829f0			SUBQ SI, AX				
  0x445035		483df8020200		CMPQ $0x202f8, AX			
  0x44503b		767d			JBE 0x4450ba				
  0x44503d		4881ec08000200		SUBQ $0x20008, SP			
  0x445044		4889ac2400000200	MOVQ BP, 0x20000(SP)			
  0x44504c		488dac2400000200	LEAQ 0x20000(SP), BP			
  0x445054		488b5920		MOVQ 0x20(CX), BX			
  0x445058		4885db			TESTQ BX, BX				
  0x44505b		7567			JNE 0x4450c4				
  0x44505d		488bb42420000200	MOVQ 0x20020(SP), SI			
  0x445065		8b8c2428000200		MOVL 0x20028(SP), CX			
  0x44506c		4889e7			MOVQ SP, DI				
  0x44506f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445071		488b942418000200	MOVQ 0x20018(SP), DX			
  0x445079		ff12			CALL 0(DX)				
  0x44507b		488b942410000200	MOVQ 0x20010(SP), DX			
  0x445083		488bbc2420000200	MOVQ 0x20020(SP), DI			
  0x44508b		8b8c2428000200		MOVL 0x20028(SP), CX			
  0x445092		8b9c242c000200		MOVL 0x2002c(SP), BX			
  0x445099		4889e6			MOVQ SP, SI				
  0x44509c		4801df			ADDQ BX, DI				
  0x44509f		4801de			ADDQ BX, SI				
  0x4450a2		4829d9			SUBQ BX, CX				
  0x4450a5		e8b6f6ffff		CALL callRet(SB)			
  0x4450aa		488bac2400000200	MOVQ 0x20000(SP), BP			
  0x4450b2		4881c408000200		ADDQ $0x20008, SP			
  0x4450b9		c3			RET					
  0x4450ba		e8b1f4ffff		CALL runtime.morestack_noctxt(SB)	
  0x4450bf		e94cffffff		JMP runtime.call131072(SB)		
  0x4450c4		488dbc2410000200	LEAQ 0x20010(SP), DI			
  0x4450cc		48393b			CMPQ DI, 0(BX)				
  0x4450cf		758c			JNE 0x44505d				
  0x4450d1		488923			MOVQ SP, 0(BX)				
  0x4450d4		eb87			JMP 0x44505d				

TEXT runtime.call262144(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4450e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4450e9		488b7110		MOVQ 0x10(CX), SI			
  0x4450ed		4881fedefaffff		CMPQ $-0x522, SI			
  0x4450f4		0f8490000000		JE 0x44518a				
  0x4450fa		488d842470030000	LEAQ 0x370(SP), AX			
  0x445102		4829f0			SUBQ SI, AX				
  0x445105		483df8020400		CMPQ $0x402f8, AX			
  0x44510b		767d			JBE 0x44518a				
  0x44510d		4881ec08000400		SUBQ $0x40008, SP			
  0x445114		4889ac2400000400	MOVQ BP, 0x40000(SP)			
  0x44511c		488dac2400000400	LEAQ 0x40000(SP), BP			
  0x445124		488b5920		MOVQ 0x20(CX), BX			
  0x445128		4885db			TESTQ BX, BX				
  0x44512b		7567			JNE 0x445194				
  0x44512d		488bb42420000400	MOVQ 0x40020(SP), SI			
  0x445135		8b8c2428000400		MOVL 0x40028(SP), CX			
  0x44513c		4889e7			MOVQ SP, DI				
  0x44513f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445141		488b942418000400	MOVQ 0x40018(SP), DX			
  0x445149		ff12			CALL 0(DX)				
  0x44514b		488b942410000400	MOVQ 0x40010(SP), DX			
  0x445153		488bbc2420000400	MOVQ 0x40020(SP), DI			
  0x44515b		8b8c2428000400		MOVL 0x40028(SP), CX			
  0x445162		8b9c242c000400		MOVL 0x4002c(SP), BX			
  0x445169		4889e6			MOVQ SP, SI				
  0x44516c		4801df			ADDQ BX, DI				
  0x44516f		4801de			ADDQ BX, SI				
  0x445172		4829d9			SUBQ BX, CX				
  0x445175		e8e6f5ffff		CALL callRet(SB)			
  0x44517a		488bac2400000400	MOVQ 0x40000(SP), BP			
  0x445182		4881c408000400		ADDQ $0x40008, SP			
  0x445189		c3			RET					
  0x44518a		e8e1f3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44518f		e94cffffff		JMP runtime.call262144(SB)		
  0x445194		488dbc2410000400	LEAQ 0x40010(SP), DI			
  0x44519c		48393b			CMPQ DI, 0(BX)				
  0x44519f		758c			JNE 0x44512d				
  0x4451a1		488923			MOVQ SP, 0(BX)				
  0x4451a4		eb87			JMP 0x44512d				

TEXT runtime.call524288(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4451b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4451b9		488b7110		MOVQ 0x10(CX), SI			
  0x4451bd		4881fedefaffff		CMPQ $-0x522, SI			
  0x4451c4		0f8490000000		JE 0x44525a				
  0x4451ca		488d842470030000	LEAQ 0x370(SP), AX			
  0x4451d2		4829f0			SUBQ SI, AX				
  0x4451d5		483df8020800		CMPQ $0x802f8, AX			
  0x4451db		767d			JBE 0x44525a				
  0x4451dd		4881ec08000800		SUBQ $0x80008, SP			
  0x4451e4		4889ac2400000800	MOVQ BP, 0x80000(SP)			
  0x4451ec		488dac2400000800	LEAQ 0x80000(SP), BP			
  0x4451f4		488b5920		MOVQ 0x20(CX), BX			
  0x4451f8		4885db			TESTQ BX, BX				
  0x4451fb		7567			JNE 0x445264				
  0x4451fd		488bb42420000800	MOVQ 0x80020(SP), SI			
  0x445205		8b8c2428000800		MOVL 0x80028(SP), CX			
  0x44520c		4889e7			MOVQ SP, DI				
  0x44520f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445211		488b942418000800	MOVQ 0x80018(SP), DX			
  0x445219		ff12			CALL 0(DX)				
  0x44521b		488b942410000800	MOVQ 0x80010(SP), DX			
  0x445223		488bbc2420000800	MOVQ 0x80020(SP), DI			
  0x44522b		8b8c2428000800		MOVL 0x80028(SP), CX			
  0x445232		8b9c242c000800		MOVL 0x8002c(SP), BX			
  0x445239		4889e6			MOVQ SP, SI				
  0x44523c		4801df			ADDQ BX, DI				
  0x44523f		4801de			ADDQ BX, SI				
  0x445242		4829d9			SUBQ BX, CX				
  0x445245		e816f5ffff		CALL callRet(SB)			
  0x44524a		488bac2400000800	MOVQ 0x80000(SP), BP			
  0x445252		4881c408000800		ADDQ $0x80008, SP			
  0x445259		c3			RET					
  0x44525a		e811f3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44525f		e94cffffff		JMP runtime.call524288(SB)		
  0x445264		488dbc2410000800	LEAQ 0x80010(SP), DI			
  0x44526c		48393b			CMPQ DI, 0(BX)				
  0x44526f		758c			JNE 0x4451fd				
  0x445271		488923			MOVQ SP, 0(BX)				
  0x445274		eb87			JMP 0x4451fd				

TEXT runtime.call1048576(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445289		488b7110		MOVQ 0x10(CX), SI			
  0x44528d		4881fedefaffff		CMPQ $-0x522, SI			
  0x445294		0f8490000000		JE 0x44532a				
  0x44529a		488d842470030000	LEAQ 0x370(SP), AX			
  0x4452a2		4829f0			SUBQ SI, AX				
  0x4452a5		483df8021000		CMPQ $0x1002f8, AX			
  0x4452ab		767d			JBE 0x44532a				
  0x4452ad		4881ec08001000		SUBQ $0x100008, SP			
  0x4452b4		4889ac2400001000	MOVQ BP, 0x100000(SP)			
  0x4452bc		488dac2400001000	LEAQ 0x100000(SP), BP			
  0x4452c4		488b5920		MOVQ 0x20(CX), BX			
  0x4452c8		4885db			TESTQ BX, BX				
  0x4452cb		7567			JNE 0x445334				
  0x4452cd		488bb42420001000	MOVQ 0x100020(SP), SI			
  0x4452d5		8b8c2428001000		MOVL 0x100028(SP), CX			
  0x4452dc		4889e7			MOVQ SP, DI				
  0x4452df		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4452e1		488b942418001000	MOVQ 0x100018(SP), DX			
  0x4452e9		ff12			CALL 0(DX)				
  0x4452eb		488b942410001000	MOVQ 0x100010(SP), DX			
  0x4452f3		488bbc2420001000	MOVQ 0x100020(SP), DI			
  0x4452fb		8b8c2428001000		MOVL 0x100028(SP), CX			
  0x445302		8b9c242c001000		MOVL 0x10002c(SP), BX			
  0x445309		4889e6			MOVQ SP, SI				
  0x44530c		4801df			ADDQ BX, DI				
  0x44530f		4801de			ADDQ BX, SI				
  0x445312		4829d9			SUBQ BX, CX				
  0x445315		e846f4ffff		CALL callRet(SB)			
  0x44531a		488bac2400001000	MOVQ 0x100000(SP), BP			
  0x445322		4881c408001000		ADDQ $0x100008, SP			
  0x445329		c3			RET					
  0x44532a		e841f2ffff		CALL runtime.morestack_noctxt(SB)	
  0x44532f		e94cffffff		JMP runtime.call1048576(SB)		
  0x445334		488dbc2410001000	LEAQ 0x100010(SP), DI			
  0x44533c		48393b			CMPQ DI, 0(BX)				
  0x44533f		758c			JNE 0x4452cd				
  0x445341		488923			MOVQ SP, 0(BX)				
  0x445344		eb87			JMP 0x4452cd				

TEXT runtime.call2097152(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445350		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445359		488b7110		MOVQ 0x10(CX), SI			
  0x44535d		4881fedefaffff		CMPQ $-0x522, SI			
  0x445364		0f8490000000		JE 0x4453fa				
  0x44536a		488d842470030000	LEAQ 0x370(SP), AX			
  0x445372		4829f0			SUBQ SI, AX				
  0x445375		483df8022000		CMPQ $0x2002f8, AX			
  0x44537b		767d			JBE 0x4453fa				
  0x44537d		4881ec08002000		SUBQ $0x200008, SP			
  0x445384		4889ac2400002000	MOVQ BP, 0x200000(SP)			
  0x44538c		488dac2400002000	LEAQ 0x200000(SP), BP			
  0x445394		488b5920		MOVQ 0x20(CX), BX			
  0x445398		4885db			TESTQ BX, BX				
  0x44539b		7567			JNE 0x445404				
  0x44539d		488bb42420002000	MOVQ 0x200020(SP), SI			
  0x4453a5		8b8c2428002000		MOVL 0x200028(SP), CX			
  0x4453ac		4889e7			MOVQ SP, DI				
  0x4453af		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4453b1		488b942418002000	MOVQ 0x200018(SP), DX			
  0x4453b9		ff12			CALL 0(DX)				
  0x4453bb		488b942410002000	MOVQ 0x200010(SP), DX			
  0x4453c3		488bbc2420002000	MOVQ 0x200020(SP), DI			
  0x4453cb		8b8c2428002000		MOVL 0x200028(SP), CX			
  0x4453d2		8b9c242c002000		MOVL 0x20002c(SP), BX			
  0x4453d9		4889e6			MOVQ SP, SI				
  0x4453dc		4801df			ADDQ BX, DI				
  0x4453df		4801de			ADDQ BX, SI				
  0x4453e2		4829d9			SUBQ BX, CX				
  0x4453e5		e876f3ffff		CALL callRet(SB)			
  0x4453ea		488bac2400002000	MOVQ 0x200000(SP), BP			
  0x4453f2		4881c408002000		ADDQ $0x200008, SP			
  0x4453f9		c3			RET					
  0x4453fa		e871f1ffff		CALL runtime.morestack_noctxt(SB)	
  0x4453ff		e94cffffff		JMP runtime.call2097152(SB)		
  0x445404		488dbc2410002000	LEAQ 0x200010(SP), DI			
  0x44540c		48393b			CMPQ DI, 0(BX)				
  0x44540f		758c			JNE 0x44539d				
  0x445411		488923			MOVQ SP, 0(BX)				
  0x445414		eb87			JMP 0x44539d				

TEXT runtime.call4194304(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445420		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445429		488b7110		MOVQ 0x10(CX), SI			
  0x44542d		4881fedefaffff		CMPQ $-0x522, SI			
  0x445434		0f8490000000		JE 0x4454ca				
  0x44543a		488d842470030000	LEAQ 0x370(SP), AX			
  0x445442		4829f0			SUBQ SI, AX				
  0x445445		483df8024000		CMPQ $0x4002f8, AX			
  0x44544b		767d			JBE 0x4454ca				
  0x44544d		4881ec08004000		SUBQ $0x400008, SP			
  0x445454		4889ac2400004000	MOVQ BP, 0x400000(SP)			
  0x44545c		488dac2400004000	LEAQ 0x400000(SP), BP			
  0x445464		488b5920		MOVQ 0x20(CX), BX			
  0x445468		4885db			TESTQ BX, BX				
  0x44546b		7567			JNE 0x4454d4				
  0x44546d		488bb42420004000	MOVQ 0x400020(SP), SI			
  0x445475		8b8c2428004000		MOVL 0x400028(SP), CX			
  0x44547c		4889e7			MOVQ SP, DI				
  0x44547f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445481		488b942418004000	MOVQ 0x400018(SP), DX			
  0x445489		ff12			CALL 0(DX)				
  0x44548b		488b942410004000	MOVQ 0x400010(SP), DX			
  0x445493		488bbc2420004000	MOVQ 0x400020(SP), DI			
  0x44549b		8b8c2428004000		MOVL 0x400028(SP), CX			
  0x4454a2		8b9c242c004000		MOVL 0x40002c(SP), BX			
  0x4454a9		4889e6			MOVQ SP, SI				
  0x4454ac		4801df			ADDQ BX, DI				
  0x4454af		4801de			ADDQ BX, SI				
  0x4454b2		4829d9			SUBQ BX, CX				
  0x4454b5		e8a6f2ffff		CALL callRet(SB)			
  0x4454ba		488bac2400004000	MOVQ 0x400000(SP), BP			
  0x4454c2		4881c408004000		ADDQ $0x400008, SP			
  0x4454c9		c3			RET					
  0x4454ca		e8a1f0ffff		CALL runtime.morestack_noctxt(SB)	
  0x4454cf		e94cffffff		JMP runtime.call4194304(SB)		
  0x4454d4		488dbc2410004000	LEAQ 0x400010(SP), DI			
  0x4454dc		48393b			CMPQ DI, 0(BX)				
  0x4454df		758c			JNE 0x44546d				
  0x4454e1		488923			MOVQ SP, 0(BX)				
  0x4454e4		eb87			JMP 0x44546d				

TEXT runtime.call8388608(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4454f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4454f9		488b7110		MOVQ 0x10(CX), SI			
  0x4454fd		4881fedefaffff		CMPQ $-0x522, SI			
  0x445504		0f8490000000		JE 0x44559a				
  0x44550a		488d842470030000	LEAQ 0x370(SP), AX			
  0x445512		4829f0			SUBQ SI, AX				
  0x445515		483df8028000		CMPQ $0x8002f8, AX			
  0x44551b		767d			JBE 0x44559a				
  0x44551d		4881ec08008000		SUBQ $0x800008, SP			
  0x445524		4889ac2400008000	MOVQ BP, 0x800000(SP)			
  0x44552c		488dac2400008000	LEAQ 0x800000(SP), BP			
  0x445534		488b5920		MOVQ 0x20(CX), BX			
  0x445538		4885db			TESTQ BX, BX				
  0x44553b		7567			JNE 0x4455a4				
  0x44553d		488bb42420008000	MOVQ 0x800020(SP), SI			
  0x445545		8b8c2428008000		MOVL 0x800028(SP), CX			
  0x44554c		4889e7			MOVQ SP, DI				
  0x44554f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445551		488b942418008000	MOVQ 0x800018(SP), DX			
  0x445559		ff12			CALL 0(DX)				
  0x44555b		488b942410008000	MOVQ 0x800010(SP), DX			
  0x445563		488bbc2420008000	MOVQ 0x800020(SP), DI			
  0x44556b		8b8c2428008000		MOVL 0x800028(SP), CX			
  0x445572		8b9c242c008000		MOVL 0x80002c(SP), BX			
  0x445579		4889e6			MOVQ SP, SI				
  0x44557c		4801df			ADDQ BX, DI				
  0x44557f		4801de			ADDQ BX, SI				
  0x445582		4829d9			SUBQ BX, CX				
  0x445585		e8d6f1ffff		CALL callRet(SB)			
  0x44558a		488bac2400008000	MOVQ 0x800000(SP), BP			
  0x445592		4881c408008000		ADDQ $0x800008, SP			
  0x445599		c3			RET					
  0x44559a		e8d1efffff		CALL runtime.morestack_noctxt(SB)	
  0x44559f		e94cffffff		JMP runtime.call8388608(SB)		
  0x4455a4		488dbc2410008000	LEAQ 0x800010(SP), DI			
  0x4455ac		48393b			CMPQ DI, 0(BX)				
  0x4455af		758c			JNE 0x44553d				
  0x4455b1		488923			MOVQ SP, 0(BX)				
  0x4455b4		eb87			JMP 0x44553d				

TEXT runtime.call16777216(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4455c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4455c9		488b7110		MOVQ 0x10(CX), SI			
  0x4455cd		4881fedefaffff		CMPQ $-0x522, SI			
  0x4455d4		0f8490000000		JE 0x44566a				
  0x4455da		488d842470030000	LEAQ 0x370(SP), AX			
  0x4455e2		4829f0			SUBQ SI, AX				
  0x4455e5		483df8020001		CMPQ $0x10002f8, AX			
  0x4455eb		767d			JBE 0x44566a				
  0x4455ed		4881ec08000001		SUBQ $0x1000008, SP			
  0x4455f4		4889ac2400000001	MOVQ BP, 0x1000000(SP)			
  0x4455fc		488dac2400000001	LEAQ 0x1000000(SP), BP			
  0x445604		488b5920		MOVQ 0x20(CX), BX			
  0x445608		4885db			TESTQ BX, BX				
  0x44560b		7567			JNE 0x445674				
  0x44560d		488bb42420000001	MOVQ 0x1000020(SP), SI			
  0x445615		8b8c2428000001		MOVL 0x1000028(SP), CX			
  0x44561c		4889e7			MOVQ SP, DI				
  0x44561f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445621		488b942418000001	MOVQ 0x1000018(SP), DX			
  0x445629		ff12			CALL 0(DX)				
  0x44562b		488b942410000001	MOVQ 0x1000010(SP), DX			
  0x445633		488bbc2420000001	MOVQ 0x1000020(SP), DI			
  0x44563b		8b8c2428000001		MOVL 0x1000028(SP), CX			
  0x445642		8b9c242c000001		MOVL 0x100002c(SP), BX			
  0x445649		4889e6			MOVQ SP, SI				
  0x44564c		4801df			ADDQ BX, DI				
  0x44564f		4801de			ADDQ BX, SI				
  0x445652		4829d9			SUBQ BX, CX				
  0x445655		e806f1ffff		CALL callRet(SB)			
  0x44565a		488bac2400000001	MOVQ 0x1000000(SP), BP			
  0x445662		4881c408000001		ADDQ $0x1000008, SP			
  0x445669		c3			RET					
  0x44566a		e801efffff		CALL runtime.morestack_noctxt(SB)	
  0x44566f		e94cffffff		JMP runtime.call16777216(SB)		
  0x445674		488dbc2410000001	LEAQ 0x1000010(SP), DI			
  0x44567c		48393b			CMPQ DI, 0(BX)				
  0x44567f		758c			JNE 0x44560d				
  0x445681		488923			MOVQ SP, 0(BX)				
  0x445684		eb87			JMP 0x44560d				

TEXT runtime.call33554432(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445690		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445699		488b7110		MOVQ 0x10(CX), SI			
  0x44569d		4881fedefaffff		CMPQ $-0x522, SI			
  0x4456a4		0f8490000000		JE 0x44573a				
  0x4456aa		488d842470030000	LEAQ 0x370(SP), AX			
  0x4456b2		4829f0			SUBQ SI, AX				
  0x4456b5		483df8020002		CMPQ $0x20002f8, AX			
  0x4456bb		767d			JBE 0x44573a				
  0x4456bd		4881ec08000002		SUBQ $0x2000008, SP			
  0x4456c4		4889ac2400000002	MOVQ BP, 0x2000000(SP)			
  0x4456cc		488dac2400000002	LEAQ 0x2000000(SP), BP			
  0x4456d4		488b5920		MOVQ 0x20(CX), BX			
  0x4456d8		4885db			TESTQ BX, BX				
  0x4456db		7567			JNE 0x445744				
  0x4456dd		488bb42420000002	MOVQ 0x2000020(SP), SI			
  0x4456e5		8b8c2428000002		MOVL 0x2000028(SP), CX			
  0x4456ec		4889e7			MOVQ SP, DI				
  0x4456ef		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4456f1		488b942418000002	MOVQ 0x2000018(SP), DX			
  0x4456f9		ff12			CALL 0(DX)				
  0x4456fb		488b942410000002	MOVQ 0x2000010(SP), DX			
  0x445703		488bbc2420000002	MOVQ 0x2000020(SP), DI			
  0x44570b		8b8c2428000002		MOVL 0x2000028(SP), CX			
  0x445712		8b9c242c000002		MOVL 0x200002c(SP), BX			
  0x445719		4889e6			MOVQ SP, SI				
  0x44571c		4801df			ADDQ BX, DI				
  0x44571f		4801de			ADDQ BX, SI				
  0x445722		4829d9			SUBQ BX, CX				
  0x445725		e836f0ffff		CALL callRet(SB)			
  0x44572a		488bac2400000002	MOVQ 0x2000000(SP), BP			
  0x445732		4881c408000002		ADDQ $0x2000008, SP			
  0x445739		c3			RET					
  0x44573a		e831eeffff		CALL runtime.morestack_noctxt(SB)	
  0x44573f		e94cffffff		JMP runtime.call33554432(SB)		
  0x445744		488dbc2410000002	LEAQ 0x2000010(SP), DI			
  0x44574c		48393b			CMPQ DI, 0(BX)				
  0x44574f		758c			JNE 0x4456dd				
  0x445751		488923			MOVQ SP, 0(BX)				
  0x445754		eb87			JMP 0x4456dd				

TEXT runtime.call67108864(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445760		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445769		488b7110		MOVQ 0x10(CX), SI			
  0x44576d		4881fedefaffff		CMPQ $-0x522, SI			
  0x445774		0f8490000000		JE 0x44580a				
  0x44577a		488d842470030000	LEAQ 0x370(SP), AX			
  0x445782		4829f0			SUBQ SI, AX				
  0x445785		483df8020004		CMPQ $0x40002f8, AX			
  0x44578b		767d			JBE 0x44580a				
  0x44578d		4881ec08000004		SUBQ $0x4000008, SP			
  0x445794		4889ac2400000004	MOVQ BP, 0x4000000(SP)			
  0x44579c		488dac2400000004	LEAQ 0x4000000(SP), BP			
  0x4457a4		488b5920		MOVQ 0x20(CX), BX			
  0x4457a8		4885db			TESTQ BX, BX				
  0x4457ab		7567			JNE 0x445814				
  0x4457ad		488bb42420000004	MOVQ 0x4000020(SP), SI			
  0x4457b5		8b8c2428000004		MOVL 0x4000028(SP), CX			
  0x4457bc		4889e7			MOVQ SP, DI				
  0x4457bf		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4457c1		488b942418000004	MOVQ 0x4000018(SP), DX			
  0x4457c9		ff12			CALL 0(DX)				
  0x4457cb		488b942410000004	MOVQ 0x4000010(SP), DX			
  0x4457d3		488bbc2420000004	MOVQ 0x4000020(SP), DI			
  0x4457db		8b8c2428000004		MOVL 0x4000028(SP), CX			
  0x4457e2		8b9c242c000004		MOVL 0x400002c(SP), BX			
  0x4457e9		4889e6			MOVQ SP, SI				
  0x4457ec		4801df			ADDQ BX, DI				
  0x4457ef		4801de			ADDQ BX, SI				
  0x4457f2		4829d9			SUBQ BX, CX				
  0x4457f5		e866efffff		CALL callRet(SB)			
  0x4457fa		488bac2400000004	MOVQ 0x4000000(SP), BP			
  0x445802		4881c408000004		ADDQ $0x4000008, SP			
  0x445809		c3			RET					
  0x44580a		e861edffff		CALL runtime.morestack_noctxt(SB)	
  0x44580f		e94cffffff		JMP runtime.call67108864(SB)		
  0x445814		488dbc2410000004	LEAQ 0x4000010(SP), DI			
  0x44581c		48393b			CMPQ DI, 0(BX)				
  0x44581f		758c			JNE 0x4457ad				
  0x445821		488923			MOVQ SP, 0(BX)				
  0x445824		eb87			JMP 0x4457ad				

TEXT runtime.call134217728(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445839		488b7110		MOVQ 0x10(CX), SI			
  0x44583d		4881fedefaffff		CMPQ $-0x522, SI			
  0x445844		0f8490000000		JE 0x4458da				
  0x44584a		488d842470030000	LEAQ 0x370(SP), AX			
  0x445852		4829f0			SUBQ SI, AX				
  0x445855		483df8020008		CMPQ $0x80002f8, AX			
  0x44585b		767d			JBE 0x4458da				
  0x44585d		4881ec08000008		SUBQ $0x8000008, SP			
  0x445864		4889ac2400000008	MOVQ BP, 0x8000000(SP)			
  0x44586c		488dac2400000008	LEAQ 0x8000000(SP), BP			
  0x445874		488b5920		MOVQ 0x20(CX), BX			
  0x445878		4885db			TESTQ BX, BX				
  0x44587b		7567			JNE 0x4458e4				
  0x44587d		488bb42420000008	MOVQ 0x8000020(SP), SI			
  0x445885		8b8c2428000008		MOVL 0x8000028(SP), CX			
  0x44588c		4889e7			MOVQ SP, DI				
  0x44588f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445891		488b942418000008	MOVQ 0x8000018(SP), DX			
  0x445899		ff12			CALL 0(DX)				
  0x44589b		488b942410000008	MOVQ 0x8000010(SP), DX			
  0x4458a3		488bbc2420000008	MOVQ 0x8000020(SP), DI			
  0x4458ab		8b8c2428000008		MOVL 0x8000028(SP), CX			
  0x4458b2		8b9c242c000008		MOVL 0x800002c(SP), BX			
  0x4458b9		4889e6			MOVQ SP, SI				
  0x4458bc		4801df			ADDQ BX, DI				
  0x4458bf		4801de			ADDQ BX, SI				
  0x4458c2		4829d9			SUBQ BX, CX				
  0x4458c5		e896eeffff		CALL callRet(SB)			
  0x4458ca		488bac2400000008	MOVQ 0x8000000(SP), BP			
  0x4458d2		4881c408000008		ADDQ $0x8000008, SP			
  0x4458d9		c3			RET					
  0x4458da		e891ecffff		CALL runtime.morestack_noctxt(SB)	
  0x4458df		e94cffffff		JMP runtime.call134217728(SB)		
  0x4458e4		488dbc2410000008	LEAQ 0x8000010(SP), DI			
  0x4458ec		48393b			CMPQ DI, 0(BX)				
  0x4458ef		758c			JNE 0x44587d				
  0x4458f1		488923			MOVQ SP, 0(BX)				
  0x4458f4		eb87			JMP 0x44587d				

TEXT runtime.call268435456(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445909		488b7110		MOVQ 0x10(CX), SI			
  0x44590d		4881fedefaffff		CMPQ $-0x522, SI			
  0x445914		0f8490000000		JE 0x4459aa				
  0x44591a		488d842470030000	LEAQ 0x370(SP), AX			
  0x445922		4829f0			SUBQ SI, AX				
  0x445925		483df8020010		CMPQ $0x100002f8, AX			
  0x44592b		767d			JBE 0x4459aa				
  0x44592d		4881ec08000010		SUBQ $0x10000008, SP			
  0x445934		4889ac2400000010	MOVQ BP, 0x10000000(SP)			
  0x44593c		488dac2400000010	LEAQ 0x10000000(SP), BP			
  0x445944		488b5920		MOVQ 0x20(CX), BX			
  0x445948		4885db			TESTQ BX, BX				
  0x44594b		7567			JNE 0x4459b4				
  0x44594d		488bb42420000010	MOVQ 0x10000020(SP), SI			
  0x445955		8b8c2428000010		MOVL 0x10000028(SP), CX			
  0x44595c		4889e7			MOVQ SP, DI				
  0x44595f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445961		488b942418000010	MOVQ 0x10000018(SP), DX			
  0x445969		ff12			CALL 0(DX)				
  0x44596b		488b942410000010	MOVQ 0x10000010(SP), DX			
  0x445973		488bbc2420000010	MOVQ 0x10000020(SP), DI			
  0x44597b		8b8c2428000010		MOVL 0x10000028(SP), CX			
  0x445982		8b9c242c000010		MOVL 0x1000002c(SP), BX			
  0x445989		4889e6			MOVQ SP, SI				
  0x44598c		4801df			ADDQ BX, DI				
  0x44598f		4801de			ADDQ BX, SI				
  0x445992		4829d9			SUBQ BX, CX				
  0x445995		e8c6edffff		CALL callRet(SB)			
  0x44599a		488bac2400000010	MOVQ 0x10000000(SP), BP			
  0x4459a2		4881c408000010		ADDQ $0x10000008, SP			
  0x4459a9		c3			RET					
  0x4459aa		e8c1ebffff		CALL runtime.morestack_noctxt(SB)	
  0x4459af		e94cffffff		JMP runtime.call268435456(SB)		
  0x4459b4		488dbc2410000010	LEAQ 0x10000010(SP), DI			
  0x4459bc		48393b			CMPQ DI, 0(BX)				
  0x4459bf		758c			JNE 0x44594d				
  0x4459c1		488923			MOVQ SP, 0(BX)				
  0x4459c4		eb87			JMP 0x44594d				

TEXT runtime.call536870912(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4459d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4459d9		488b7110		MOVQ 0x10(CX), SI			
  0x4459dd		4881fedefaffff		CMPQ $-0x522, SI			
  0x4459e4		0f8490000000		JE 0x445a7a				
  0x4459ea		488d842470030000	LEAQ 0x370(SP), AX			
  0x4459f2		4829f0			SUBQ SI, AX				
  0x4459f5		483df8020020		CMPQ $0x200002f8, AX			
  0x4459fb		767d			JBE 0x445a7a				
  0x4459fd		4881ec08000020		SUBQ $0x20000008, SP			
  0x445a04		4889ac2400000020	MOVQ BP, 0x20000000(SP)			
  0x445a0c		488dac2400000020	LEAQ 0x20000000(SP), BP			
  0x445a14		488b5920		MOVQ 0x20(CX), BX			
  0x445a18		4885db			TESTQ BX, BX				
  0x445a1b		7567			JNE 0x445a84				
  0x445a1d		488bb42420000020	MOVQ 0x20000020(SP), SI			
  0x445a25		8b8c2428000020		MOVL 0x20000028(SP), CX			
  0x445a2c		4889e7			MOVQ SP, DI				
  0x445a2f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445a31		488b942418000020	MOVQ 0x20000018(SP), DX			
  0x445a39		ff12			CALL 0(DX)				
  0x445a3b		488b942410000020	MOVQ 0x20000010(SP), DX			
  0x445a43		488bbc2420000020	MOVQ 0x20000020(SP), DI			
  0x445a4b		8b8c2428000020		MOVL 0x20000028(SP), CX			
  0x445a52		8b9c242c000020		MOVL 0x2000002c(SP), BX			
  0x445a59		4889e6			MOVQ SP, SI				
  0x445a5c		4801df			ADDQ BX, DI				
  0x445a5f		4801de			ADDQ BX, SI				
  0x445a62		4829d9			SUBQ BX, CX				
  0x445a65		e8f6ecffff		CALL callRet(SB)			
  0x445a6a		488bac2400000020	MOVQ 0x20000000(SP), BP			
  0x445a72		4881c408000020		ADDQ $0x20000008, SP			
  0x445a79		c3			RET					
  0x445a7a		e8f1eaffff		CALL runtime.morestack_noctxt(SB)	
  0x445a7f		e94cffffff		JMP runtime.call536870912(SB)		
  0x445a84		488dbc2410000020	LEAQ 0x20000010(SP), DI			
  0x445a8c		48393b			CMPQ DI, 0(BX)				
  0x445a8f		758c			JNE 0x445a1d				
  0x445a91		488923			MOVQ SP, 0(BX)				
  0x445a94		eb87			JMP 0x445a1d				

TEXT runtime.call1073741824(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445aa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x445aa9		488b7110		MOVQ 0x10(CX), SI			
  0x445aad		4881fedefaffff		CMPQ $-0x522, SI			
  0x445ab4		0f8490000000		JE 0x445b4a				
  0x445aba		488d842470030000	LEAQ 0x370(SP), AX			
  0x445ac2		4829f0			SUBQ SI, AX				
  0x445ac5		483df8020040		CMPQ $0x400002f8, AX			
  0x445acb		767d			JBE 0x445b4a				
  0x445acd		4881ec08000040		SUBQ $0x40000008, SP			
  0x445ad4		4889ac2400000040	MOVQ BP, 0x40000000(SP)			
  0x445adc		488dac2400000040	LEAQ 0x40000000(SP), BP			
  0x445ae4		488b5920		MOVQ 0x20(CX), BX			
  0x445ae8		4885db			TESTQ BX, BX				
  0x445aeb		7567			JNE 0x445b54				
  0x445aed		488bb42420000040	MOVQ 0x40000020(SP), SI			
  0x445af5		8b8c2428000040		MOVL 0x40000028(SP), CX			
  0x445afc		4889e7			MOVQ SP, DI				
  0x445aff		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x445b01		488b942418000040	MOVQ 0x40000018(SP), DX			
  0x445b09		ff12			CALL 0(DX)				
  0x445b0b		488b942410000040	MOVQ 0x40000010(SP), DX			
  0x445b13		488bbc2420000040	MOVQ 0x40000020(SP), DI			
  0x445b1b		8b8c2428000040		MOVL 0x40000028(SP), CX			
  0x445b22		8b9c242c000040		MOVL 0x4000002c(SP), BX			
  0x445b29		4889e6			MOVQ SP, SI				
  0x445b2c		4801df			ADDQ BX, DI				
  0x445b2f		4801de			ADDQ BX, SI				
  0x445b32		4829d9			SUBQ BX, CX				
  0x445b35		e826ecffff		CALL callRet(SB)			
  0x445b3a		488bac2400000040	MOVQ 0x40000000(SP), BP			
  0x445b42		4881c408000040		ADDQ $0x40000008, SP			
  0x445b49		c3			RET					
  0x445b4a		e821eaffff		CALL runtime.morestack_noctxt(SB)	
  0x445b4f		e94cffffff		JMP runtime.call1073741824(SB)		
  0x445b54		488dbc2410000040	LEAQ 0x40000010(SP), DI			
  0x445b5c		48393b			CMPQ DI, 0(BX)				
  0x445b5f		758c			JNE 0x445aed				
  0x445b61		488923			MOVQ SP, 0(BX)				
  0x445b64		eb87			JMP 0x445aed				

TEXT runtime.procyield(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445b70		8b442408		MOVL 0x8(SP), AX	

  0x445b74		f390			PAUSE			

  0x445b76		83e801			SUBL $0x1, AX		

  0x445b79		75f9			JNE 0x445b74		

  0x445b7b		c3			RET			

TEXT runtime.publicationBarrier(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445b80		c3			RET			

TEXT runtime.jmpdefer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445b90		488b542408		MOVQ 0x8(SP), DX	

  0x445b95		488b5c2410		MOVQ 0x10(SP), BX	

  0x445b9a		488d63f8		LEAQ -0x8(BX), SP	

  0x445b9e		488b6c24f8		MOVQ -0x8(SP), BP	

  0x445ba3		48832c2405		SUBQ $0x5, 0(SP)	

  0x445ba8		488b1a			MOVQ 0(DX), BX		

  0x445bab		ffe3			JMP BX			

TEXT gosave(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445bb0		644c8b0425f8ffffff	MOVQ FS:0xfffffff8, R8	

  0x445bb9		4c8b0c24		MOVQ 0(SP), R9		

  0x445bbd		4d894840		MOVQ R9, 0x40(R8)	

  0x445bc1		4c8d4c2408		LEAQ 0x8(SP), R9	

  0x445bc6		4d894838		MOVQ R9, 0x38(R8)	

  0x445bca		49c7405800000000	MOVQ $0x0, 0x58(R8)	

  0x445bd2		49896868		MOVQ BP, 0x68(R8)	

  0x445bd6		4d8b4850		MOVQ 0x50(R8), R9	

  0x445bda		4d85c9			TESTQ R9, R9		

  0x445bdd		7405			JE 0x445be4		

  0x445bdf		e80cddfdff		CALL runtime.badctxt(SB)	

  0x445be4		c3			RET			

TEXT runtime.asmcgocall(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445bf0		488b442408		MOVQ 0x8(SP), AX	

  0x445bf5		488b5c2410		MOVQ 0x10(SP), BX	

  0x445bfa		4889e2			MOVQ SP, DX		

  0x445bfd		644c8b0425f8ffffff	MOVQ FS:0xfffffff8, R8	

  0x445c06		4983f800		CMPQ $0x0, R8		

  0x445c0a		7473			JE 0x445c7f		

  0x445c0c		4d8b4030		MOVQ 0x30(R8), R8	

  0x445c10		498b30			MOVQ 0(R8), SI		

  0x445c13		64488b3c25f8ffffff	MOVQ FS:0xfffffff8, DI	

  0x445c1c		4839fe			CMPQ DI, SI		

  0x445c1f		745e			JE 0x445c7f		

  0x445c21		498b7050		MOVQ 0x50(R8), SI	

  0x445c25		4839fe			CMPQ DI, SI		

  0x445c28		7455			JE 0x445c7f		

  0x445c2a		498b30			MOVQ 0(R8), SI		

  0x445c2d		e87effffff		CALL gosave(SB)		

  0x445c32		6448893425f8ffffff	MOVQ SI, FS:0xfffffff8	

  0x445c3b		488b6638		MOVQ 0x38(SI), SP	

  0x445c3f		4883ec40		SUBQ $0x40, SP		

  0x445c43		4883e4f0		ANDQ $-0x10, SP		

  0x445c47		48897c2430		MOVQ DI, 0x30(SP)	

  0x445c4c		488b7f08		MOVQ 0x8(DI), DI	

  0x445c50		4829d7			SUBQ DX, DI		

  0x445c53		48897c2428		MOVQ DI, 0x28(SP)	

  0x445c58		4889df			MOVQ BX, DI		

  0x445c5b		4889d9			MOVQ BX, CX		

  0x445c5e		ffd0			CALL AX			

  0x445c60		488b7c2430		MOVQ 0x30(SP), DI	

  0x445c65		488b7708		MOVQ 0x8(DI), SI	

  0x445c69		482b742428		SUBQ 0x28(SP), SI	

  0x445c6e		6448893c25f8ffffff	MOVQ DI, FS:0xfffffff8	

  0x445c77		4889f4			MOVQ SI, SP		

  0x445c7a		89442418		MOVL AX, 0x18(SP)	

  0x445c7e		c3			RET			

  0x445c7f		4883ec40		SUBQ $0x40, SP		

  0x445c83		4883e4f0		ANDQ $-0x10, SP		

  0x445c87		48c744243000000000	MOVQ $0x0, 0x30(SP)	

  0x445c90		4889542428		MOVQ DX, 0x28(SP)	

  0x445c95		4889df			MOVQ BX, DI		

  0x445c98		4889d9			MOVQ BX, CX		

  0x445c9b		ffd0			CALL AX			

  0x445c9d		488b742428		MOVQ 0x28(SP), SI	

  0x445ca2		4889f4			MOVQ SI, SP		

  0x445ca5		89442418		MOVL AX, 0x18(SP)	

  0x445ca9		c3			RET			

TEXT runtime.setg(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445cb0		488b5c2408		MOVQ 0x8(SP), BX	

  0x445cb5		6448891c25f8ffffff	MOVQ BX, FS:0xfffffff8	

  0x445cbe		c3			RET			

TEXT setg_gcc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445cc0		6448893c25f8ffffff	MOVQ DI, FS:0xfffffff8	

  0x445cc9		c3			RET			

TEXT runtime.stackcheck(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445cd0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x445cd9		48396008		CMPQ SP, 0x8(AX)	

  0x445cdd		7702			JA 0x445ce1		

  0x445cdf		cd03			INT $0x3		

  0x445ce1		483b20			CMPQ 0(AX), SP		

  0x445ce4		7702			JA 0x445ce8		

  0x445ce6		cd03			INT $0x3		

  0x445ce8		c3			RET			

TEXT runtime.cputicks(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445cf0		803db7db070001		CMPB $0x1, runtime.lfenceBeforeRdtsc(SB)	

  0x445cf7		7505			JNE 0x445cfe		

  0x445cf9		0faee8			LFENCE			

  0x445cfc		eb03			JMP 0x445d01		

  0x445cfe		0faef0			MFENCE			

  0x445d01		0f31			RDTSC			

  0x445d03		48c1e220		SHLQ $0x20, DX		

  0x445d07		4801d0			ADDQ DX, AX		

  0x445d0a		4889442408		MOVQ AX, 0x8(SP)	

  0x445d0f		c3			RET			

TEXT runtime.aeshash(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445d10		488b442408		MOVQ 0x8(SP), AX	

  0x445d15		488b4c2418		MOVQ 0x18(SP), CX	

  0x445d1a		488d542420		LEAQ 0x20(SP), DX	

  0x445d1f		e92c000000		JMP runtime.aeshashbody(SB)	

TEXT runtime.aeshashstr(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445d30		488b442408		MOVQ 0x8(SP), AX	

  0x445d35		488b4808		MOVQ 0x8(AX), CX	

  0x445d39		488b00			MOVQ 0(AX), AX		

  0x445d3c		488d542418		LEAQ 0x18(SP), DX	

  0x445d41		e90a000000		JMP runtime.aeshashbody(SB)	

TEXT runtime.aeshashbody(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x445d50		f30f7e442410		MOVQ 0x10(SP), X0	

  0x445d56		660fc4c104		PINSRW $0x4, CX, X0	

  0x445d5b		f30f70c000		PSHUFHW $0x0, X0, X0	

  0x445d60		660f6fc8		MOVDQA X0, X1		

  0x445d64		660fef0534de0700	PXOR runtime.aeskeysched(SB), X0	

  0x445d6c		660f38dcc0		AESENC X0, X0		

  0x445d71		4883f910		CMPQ $0x10, CX		

  0x445d75		7224			JB 0x445d9b		

  0x445d77		747f			JE 0x445df8		

  0x445d79		4883f920		CMPQ $0x20, CX		

  0x445d7d		767f			JBE 0x445dfe		

  0x445d7f		4883f940		CMPQ $0x40, CX		

  0x445d83		0f86bb000000		JBE 0x445e44		

  0x445d89		4881f980000000		CMPQ $0x80, CX		

  0x445d90		0f864f010000		JBE 0x445ee5		

  0x445d96		e9d1020000		JMP 0x44606c		

  0x445d9b		4885c9			TESTQ CX, CX		

  0x445d9e		744e			JE 0x445dee		

  0x445da0		4883c010		ADDQ $0x10, AX		

  0x445da4		66a9f00f		TESTW $0xff0, AX	

  0x445da8		742c			JE 0x445dd6		

  0x445daa		f30f6f48f0		MOVDQU -0x10(AX), X1	

  0x445daf		4801c9			ADDQ CX, CX		

  0x445db2		488d0527f20200		LEAQ masks(SB), AX	

  0x445db9		660fdb0cc8		PAND 0(AX)(CX*8), X1	

  0x445dbe		660fefc8		PXOR X0, X1		

  0x445dc2		660f38dcc9		AESENC X1, X1		

  0x445dc7		660f38dcc9		AESENC X1, X1		

  0x445dcc		660f38dcc9		AESENC X1, X1		

  0x445dd1		660fd60a		MOVQ X1, 0(DX)		

  0x445dd5		c3			RET			

  0x445dd6		f30f6f4c08e0		MOVDQU -0x20(AX)(CX*1), X1	

  0x445ddc		4801c9			ADDQ CX, CX		

  0x445ddf		488d05faf20200		LEAQ shifts(SB), AX	

  0x445de6		660f38000cc8		PSHUFB 0(AX)(CX*8), X1	

  0x445dec		ebd0			JMP 0x445dbe		

  0x445dee		660f38dcc0		AESENC X0, X0		

  0x445df3		660fd602		MOVQ X0, 0(DX)		

  0x445df7		c3			RET			

  0x445df8		f30f6f08		MOVDQU 0(AX), X1	

  0x445dfc		ebc0			JMP 0x445dbe		

  0x445dfe		660fef0daadd0700	PXOR runtime.aeskeysched+16(SB), X1	

  0x445e06		660f38dcc9		AESENC X1, X1		

  0x445e0b		f30f6f10		MOVDQU 0(AX), X2	

  0x445e0f		f30f6f5c08f0		MOVDQU -0x10(AX)(CX*1), X3	

  0x445e15		660fefd0		PXOR X0, X2		

  0x445e19		660fefd9		PXOR X1, X3		

  0x445e1d		660f38dcd2		AESENC X2, X2		

  0x445e22		660f38dcdb		AESENC X3, X3		

  0x445e27		660f38dcd2		AESENC X2, X2		

  0x445e2c		660f38dcdb		AESENC X3, X3		

  0x445e31		660f38dcd2		AESENC X2, X2		

  0x445e36		660f38dcdb		AESENC X3, X3		

  0x445e3b		660fefd3		PXOR X3, X2		

  0x445e3f		660fd612		MOVQ X2, 0(DX)		

  0x445e43		c3			RET			

  0x445e44		660f6fd1		MOVDQA X1, X2		

  0x445e48		660f6fd9		MOVDQA X1, X3		

  0x445e4c		660fef0d5cdd0700	PXOR runtime.aeskeysched+16(SB), X1	

  0x445e54		660fef1564dd0700	PXOR runtime.aeskeysched+32(SB), X2	

  0x445e5c		660fef1d6cdd0700	PXOR runtime.aeskeysched+48(SB), X3	

  0x445e64		660f38dcc9		AESENC X1, X1		

  0x445e69		660f38dcd2		AESENC X2, X2		

  0x445e6e		660f38dcdb		AESENC X3, X3		

  0x445e73		f30f6f20		MOVDQU 0(AX), X4	

  0x445e77		f30f6f6810		MOVDQU 0x10(AX), X5	

  0x445e7c		f30f6f7408e0		MOVDQU -0x20(AX)(CX*1), X6	

  0x445e82		f30f6f7c08f0		MOVDQU -0x10(AX)(CX*1), X7	

  0x445e88		660fefe0		PXOR X0, X4		

  0x445e8c		660fefe9		PXOR X1, X5		

  0x445e90		660feff2		PXOR X2, X6		

  0x445e94		660feffb		PXOR X3, X7		

  0x445e98		660f38dce4		AESENC X4, X4		

  0x445e9d		660f38dced		AESENC X5, X5		

  0x445ea2		660f38dcf6		AESENC X6, X6		

  0x445ea7		660f38dcff		AESENC X7, X7		

  0x445eac		660f38dce4		AESENC X4, X4		

  0x445eb1		660f38dced		AESENC X5, X5		

  0x445eb6		660f38dcf6		AESENC X6, X6		

  0x445ebb		660f38dcff		AESENC X7, X7		

  0x445ec0		660f38dce4		AESENC X4, X4		

  0x445ec5		660f38dced		AESENC X5, X5		

  0x445eca		660f38dcf6		AESENC X6, X6		

  0x445ecf		660f38dcff		AESENC X7, X7		

  0x445ed4		660fefe6		PXOR X6, X4		

  0x445ed8		660fefef		PXOR X7, X5		

  0x445edc		660fefe5		PXOR X5, X4		

  0x445ee0		660fd622		MOVQ X4, 0(DX)		

  0x445ee4		c3			RET			

  0x445ee5		660f6fd1		MOVDQA X1, X2		

  0x445ee9		660f6fd9		MOVDQA X1, X3		

  0x445eed		660f6fe1		MOVDQA X1, X4		

  0x445ef1		660f6fe9		MOVDQA X1, X5		

  0x445ef5		660f6ff1		MOVDQA X1, X6		

  0x445ef9		660f6ff9		MOVDQA X1, X7		

  0x445efd		660fef0dabdc0700	PXOR runtime.aeskeysched+16(SB), X1	

  0x445f05		660fef15b3dc0700	PXOR runtime.aeskeysched+32(SB), X2	

  0x445f0d		660fef1dbbdc0700	PXOR runtime.aeskeysched+48(SB), X3	

  0x445f15		660fef25c3dc0700	PXOR runtime.aeskeysched+64(SB), X4	

  0x445f1d		660fef2dcbdc0700	PXOR runtime.aeskeysched+80(SB), X5	

  0x445f25		660fef35d3dc0700	PXOR runtime.aeskeysched+96(SB), X6	

  0x445f2d		660fef3ddbdc0700	PXOR runtime.aeskeysched+112(SB), X7	

  0x445f35		660f38dcc9		AESENC X1, X1		

  0x445f3a		660f38dcd2		AESENC X2, X2		

  0x445f3f		660f38dcdb		AESENC X3, X3		

  0x445f44		660f38dce4		AESENC X4, X4		

  0x445f49		660f38dced		AESENC X5, X5		

  0x445f4e		660f38dcf6		AESENC X6, X6		

  0x445f53		660f38dcff		AESENC X7, X7		

  0x445f58		f3440f6f00		MOVDQU 0(AX), X8	

  0x445f5d		f3440f6f4810		MOVDQU 0x10(AX), X9	

  0x445f63		f3440f6f5020		MOVDQU 0x20(AX), X10	

  0x445f69		f3440f6f5830		MOVDQU 0x30(AX), X11	

  0x445f6f		f3440f6f6408c0		MOVDQU -0x40(AX)(CX*1), X12	

  0x445f76		f3440f6f6c08d0		MOVDQU -0x30(AX)(CX*1), X13	

  0x445f7d		f3440f6f7408e0		MOVDQU -0x20(AX)(CX*1), X14	

  0x445f84		f3440f6f7c08f0		MOVDQU -0x10(AX)(CX*1), X15	

  0x445f8b		66440fefc0		PXOR X0, X8		

  0x445f90		66440fefc9		PXOR X1, X9		

  0x445f95		66440fefd2		PXOR X2, X10		

  0x445f9a		66440fefdb		PXOR X3, X11		

  0x445f9f		66440fefe4		PXOR X4, X12		

  0x445fa4		66440fefed		PXOR X5, X13		

  0x445fa9		66440feff6		PXOR X6, X14		

  0x445fae		66440fefff		PXOR X7, X15		

  0x445fb3		66450f38dcc0		AESENC X8, X8		

  0x445fb9		66450f38dcc9		AESENC X9, X9		

  0x445fbf		66450f38dcd2		AESENC X10, X10		

  0x445fc5		66450f38dcdb		AESENC X11, X11		

  0x445fcb		66450f38dce4		AESENC X12, X12		

  0x445fd1		66450f38dced		AESENC X13, X13		

  0x445fd7		66450f38dcf6		AESENC X14, X14		

  0x445fdd		66450f38dcff		AESENC X15, X15		

  0x445fe3		66450f38dcc0		AESENC X8, X8		

  0x445fe9		66450f38dcc9		AESENC X9, X9		

  0x445fef		66450f38dcd2		AESENC X10, X10		

  0x445ff5		66450f38dcdb		AESENC X11, X11		

  0x445ffb		66450f38dce4		AESENC X12, X12		

  0x446001		66450f38dced		AESENC X13, X13		

  0x446007		66450f38dcf6		AESENC X14, X14		

  0x44600d		66450f38dcff		AESENC X15, X15		

  0x446013		66450f38dcc0		AESENC X8, X8		

  0x446019		66450f38dcc9		AESENC X9, X9		

  0x44601f		66450f38dcd2		AESENC X10, X10		

  0x446025		66450f38dcdb		AESENC X11, X11		

  0x44602b		66450f38dce4		AESENC X12, X12		

  0x446031		66450f38dced		AESENC X13, X13		

  0x446037		66450f38dcf6		AESENC X14, X14		

  0x44603d		66450f38dcff		AESENC X15, X15		

  0x446043		66450fefc4		PXOR X12, X8		

  0x446048		66450fefcd		PXOR X13, X9		

  0x44604d		66450fefd6		PXOR X14, X10		

  0x446052		66450fefdf		PXOR X15, X11		

  0x446057		66450fefc2		PXOR X10, X8		

  0x44605c		66450fefcb		PXOR X11, X9		

  0x446061		66450fefc1		PXOR X9, X8		

  0x446066		66440fd602		MOVQ X8, 0(DX)		

  0x44606b		c3			RET			

  0x44606c		660f6fd1		MOVDQA X1, X2		

  0x446070		660f6fd9		MOVDQA X1, X3		

  0x446074		660f6fe1		MOVDQA X1, X4		

  0x446078		660f6fe9		MOVDQA X1, X5		

  0x44607c		660f6ff1		MOVDQA X1, X6		

  0x446080		660f6ff9		MOVDQA X1, X7		

  0x446084		660fef0d24db0700	PXOR runtime.aeskeysched+16(SB), X1	

  0x44608c		660fef152cdb0700	PXOR runtime.aeskeysched+32(SB), X2	

  0x446094		660fef1d34db0700	PXOR runtime.aeskeysched+48(SB), X3	

  0x44609c		660fef253cdb0700	PXOR runtime.aeskeysched+64(SB), X4	

  0x4460a4		660fef2d44db0700	PXOR runtime.aeskeysched+80(SB), X5	

  0x4460ac		660fef354cdb0700	PXOR runtime.aeskeysched+96(SB), X6	

  0x4460b4		660fef3d54db0700	PXOR runtime.aeskeysched+112(SB), X7	

  0x4460bc		660f38dcc9		AESENC X1, X1		

  0x4460c1		660f38dcd2		AESENC X2, X2		

  0x4460c6		660f38dcdb		AESENC X3, X3		

  0x4460cb		660f38dce4		AESENC X4, X4		

  0x4460d0		660f38dced		AESENC X5, X5		

  0x4460d5		660f38dcf6		AESENC X6, X6		

  0x4460da		660f38dcff		AESENC X7, X7		

  0x4460df		f3440f6f440880		MOVDQU -0x80(AX)(CX*1), X8	

  0x4460e6		f3440f6f4c0890		MOVDQU -0x70(AX)(CX*1), X9	

  0x4460ed		f3440f6f5408a0		MOVDQU -0x60(AX)(CX*1), X10	

  0x4460f4		f3440f6f5c08b0		MOVDQU -0x50(AX)(CX*1), X11	

  0x4460fb		f3440f6f6408c0		MOVDQU -0x40(AX)(CX*1), X12	

  0x446102		f3440f6f6c08d0		MOVDQU -0x30(AX)(CX*1), X13	

  0x446109		f3440f6f7408e0		MOVDQU -0x20(AX)(CX*1), X14	

  0x446110		f3440f6f7c08f0		MOVDQU -0x10(AX)(CX*1), X15	

  0x446117		66440fefc0		PXOR X0, X8		

  0x44611c		66440fefc9		PXOR X1, X9		

  0x446121		66440fefd2		PXOR X2, X10		

  0x446126		66440fefdb		PXOR X3, X11		

  0x44612b		66440fefe4		PXOR X4, X12		

  0x446130		66440fefed		PXOR X5, X13		

  0x446135		66440feff6		PXOR X6, X14		

  0x44613a		66440fefff		PXOR X7, X15		

  0x44613f		48ffc9			DECQ CX			

  0x446142		48c1e907		SHRQ $0x7, CX		

  0x446146		66450f38dcc0		AESENC X8, X8		

  0x44614c		66450f38dcc9		AESENC X9, X9		

  0x446152		66450f38dcd2		AESENC X10, X10		

  0x446158		66450f38dcdb		AESENC X11, X11		

  0x44615e		66450f38dce4		AESENC X12, X12		

  0x446164		66450f38dced		AESENC X13, X13		

  0x44616a		66450f38dcf6		AESENC X14, X14		

  0x446170		66450f38dcff		AESENC X15, X15		

  0x446176		f30f6f00		MOVDQU 0(AX), X0	

  0x44617a		f30f6f4810		MOVDQU 0x10(AX), X1	

  0x44617f		f30f6f5020		MOVDQU 0x20(AX), X2	

  0x446184		f30f6f5830		MOVDQU 0x30(AX), X3	

  0x446189		66440f38dcc0		AESENC X0, X8		

  0x44618f		66440f38dcc9		AESENC X1, X9		

  0x446195		66440f38dcd2		AESENC X2, X10		

  0x44619b		66440f38dcdb		AESENC X3, X11		

  0x4461a1		f30f6f6040		MOVDQU 0x40(AX), X4	

  0x4461a6		f30f6f6850		MOVDQU 0x50(AX), X5	

  0x4461ab		f30f6f7060		MOVDQU 0x60(AX), X6	

  0x4461b0		f30f6f7870		MOVDQU 0x70(AX), X7	

  0x4461b5		66440f38dce4		AESENC X4, X12		

  0x4461bb		66440f38dced		AESENC X5, X13		

  0x4461c1		66440f38dcf6		AESENC X6, X14		

  0x4461c7		66440f38dcff		AESENC X7, X15		

  0x4461cd		480580000000		ADDQ $0x80, AX		

  0x4461d3		48ffc9			DECQ CX			

  0x4461d6		0f856affffff		JNE 0x446146		

  0x4461dc		66450f38dcc0		AESENC X8, X8		

  0x4461e2		66450f38dcc9		AESENC X9, X9		

  0x4461e8		66450f38dcd2		AESENC X10, X10		

  0x4461ee		66450f38dcdb		AESENC X11, X11		

  0x4461f4		66450f38dce4		AESENC X12, X12		

  0x4461fa		66450f38dced		AESENC X13, X13		

  0x446200		66450f38dcf6		AESENC X14, X14		

  0x446206		66450f38dcff		AESENC X15, X15		

  0x44620c		66450f38dcc0		AESENC X8, X8		

  0x446212		66450f38dcc9		AESENC X9, X9		

  0x446218		66450f38dcd2		AESENC X10, X10		

  0x44621e		66450f38dcdb		AESENC X11, X11		

  0x446224		66450f38dce4		AESENC X12, X12		

  0x44622a		66450f38dced		AESENC X13, X13		

  0x446230		66450f38dcf6		AESENC X14, X14		

  0x446236		66450f38dcff		AESENC X15, X15		

  0x44623c		66450f38dcc0		AESENC X8, X8		

  0x446242		66450f38dcc9		AESENC X9, X9		

  0x446248		66450f38dcd2		AESENC X10, X10		

  0x44624e		66450f38dcdb		AESENC X11, X11		

  0x446254		66450f38dce4		AESENC X12, X12		

  0x44625a		66450f38dced		AESENC X13, X13		

  0x446260		66450f38dcf6		AESENC X14, X14		

  0x446266		66450f38dcff		AESENC X15, X15		

  0x44626c		66450fefc4		PXOR X12, X8		

  0x446271		66450fefcd		PXOR X13, X9		

  0x446276		66450fefd6		PXOR X14, X10		

  0x44627b		66450fefdf		PXOR X15, X11		

  0x446280		66450fefc2		PXOR X10, X8		

  0x446285		66450fefcb		PXOR X11, X9		

  0x44628a		66450fefc1		PXOR X9, X8		

  0x44628f		66440fd602		MOVQ X8, 0(DX)		

  0x446294		c3			RET			

TEXT runtime.aeshash32(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4462a0		488b442408		MOVQ 0x8(SP), AX	

  0x4462a5		f30f7e442410		MOVQ 0x10(SP), X0	

  0x4462ab		660f3a220002		PINSRD $0x2, 0(AX), X0	

  0x4462b1		660f38dc05e6d80700	AESENC runtime.aeskeysched(SB), X0	

  0x4462ba		660f38dc05edd80700	AESENC runtime.aeskeysched+16(SB), X0	

  0x4462c3		660f38dc05f4d80700	AESENC runtime.aeskeysched+32(SB), X0	

  0x4462cc		660fd6442418		MOVQ X0, 0x18(SP)	

  0x4462d2		c3			RET			

TEXT runtime.aeshash64(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4462e0		488b442408		MOVQ 0x8(SP), AX	

  0x4462e5		f30f7e442410		MOVQ 0x10(SP), X0	

  0x4462eb		66480f3a220001		PINSRQ $0x1, 0(AX), X0	

  0x4462f2		660f38dc05a5d80700	AESENC runtime.aeskeysched(SB), X0	

  0x4462fb		660f38dc05acd80700	AESENC runtime.aeskeysched+16(SB), X0	

  0x446304		660f38dc05b3d80700	AESENC runtime.aeskeysched+32(SB), X0	

  0x44630d		660fd6442418		MOVQ X0, 0x18(SP)	

  0x446313		c3			RET			

TEXT runtime.checkASM(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446320		488d05b9ec0200		LEAQ masks(SB), AX	

  0x446327		488d1db2ed0200		LEAQ shifts(SB), BX	

  0x44632e		4809d8			ORQ BX, AX		

  0x446331		48a90f000000		TESTQ $0xf, AX		

  0x446337		0f94442408		SETE 0x8(SP)		

  0x44633c		c3			RET			

TEXT runtime.memequal(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446340		488b742408		MOVQ 0x8(SP), SI	

  0x446345		488b7c2410		MOVQ 0x10(SP), DI	

  0x44634a		4839fe			CMPQ DI, SI		

  0x44634d		740f			JE 0x44635e		

  0x44634f		488b5c2418		MOVQ 0x18(SP), BX	

  0x446354		488d442420		LEAQ 0x20(SP), AX	

  0x446359		e942000000		JMP runtime.memeqbody(SB)	

  0x44635e		c644242001		MOVB $0x1, 0x20(SP)	

  0x446363		c3			RET			

TEXT runtime.memequal_varlen(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446370		488b742408		MOVQ 0x8(SP), SI	

  0x446375		488b7c2410		MOVQ 0x10(SP), DI	

  0x44637a		4839fe			CMPQ DI, SI		

  0x44637d		740e			JE 0x44638d		

  0x44637f		488b5a08		MOVQ 0x8(DX), BX	

  0x446383		488d442418		LEAQ 0x18(SP), AX	

  0x446388		e913000000		JMP runtime.memeqbody(SB)	

  0x44638d		c644241801		MOVB $0x1, 0x18(SP)	

  0x446392		c3			RET			

TEXT runtime.memeqbody(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4463a0		4883fb08		CMPQ $0x8, BX		

  0x4463a4		0f82f3000000		JB 0x44649d		

  0x4463aa		4883fb40		CMPQ $0x40, BX		

  0x4463ae		0f82b7000000		JB 0x44646b		

  0x4463b4		803df8d4070001		CMPB $0x1, runtime.support_avx2(SB)	

  0x4463bb		7468			JE 0x446425		

  0x4463bd		4883fb40		CMPQ $0x40, BX		

  0x4463c1		0f82a4000000		JB 0x44646b		

  0x4463c7		f30f6f06		MOVDQU 0(SI), X0	

  0x4463cb		f30f6f0f		MOVDQU 0(DI), X1	

  0x4463cf		f30f6f5610		MOVDQU 0x10(SI), X2	

  0x4463d4		f30f6f5f10		MOVDQU 0x10(DI), X3	

  0x4463d9		f30f6f6620		MOVDQU 0x20(SI), X4	

  0x4463de		f30f6f6f20		MOVDQU 0x20(DI), X5	

  0x4463e3		f30f6f7630		MOVDQU 0x30(SI), X6	

  0x4463e8		f30f6f7f30		MOVDQU 0x30(DI), X7	

  0x4463ed		660f74c1		PCMPEQB X1, X0		

  0x4463f1		660f74d3		PCMPEQB X3, X2		

  0x4463f5		660f74e5		PCMPEQB X5, X4		

  0x4463f9		660f74f7		PCMPEQB X7, X6		

  0x4463fd		660fdbc2		PAND X2, X0		

  0x446401		660fdbe6		PAND X6, X4		

  0x446405		660fdbc4		PAND X4, X0		

  0x446409		660fd7d0		PMOVMSKB X0, DX		

  0x44640d		4883c640		ADDQ $0x40, SI		

  0x446411		4883c740		ADDQ $0x40, DI		

  0x446415		4883eb40		SUBQ $0x40, BX		

  0x446419		81faffff0000		CMPL $0xffff, DX	

  0x44641f		749c			JE 0x4463bd		

  0x446421		c60000			MOVB $0x0, 0(AX)	

  0x446424		c3			RET			

  0x446425		4883fb40		CMPQ $0x40, BX		

  0x446429		723d			JB 0x446468		

  0x44642b		c5fe6f06		VMOVDQU 0(SI), X0	

  0x44642f		c5fe6f0f		VMOVDQU 0(DI), X1	

  0x446433		c5fe6f5620		VMOVDQU 0x20(SI), X2	

  0x446438		c5fe6f5f20		VMOVDQU 0x20(DI), X3	

  0x44643d		c5fd74e1		JE 0x446422		

  0x446441		c5e574ea		JE 0x44642f		

  0x446445		c5d5dbf4		FCOMI F4, F0		

  0x446449		c5fdd7			XLATB DS:0(BX)		
  0x44644c		d6			?			

  0x44644d		4883c640		ADDQ $0x40, SI		

  0x446451		4883c740		ADDQ $0x40, DI		

  0x446455		4883eb40		SUBQ $0x40, BX		

  0x446459		81faffffffff		CMPL $-0x1, DX		

  0x44645f		74c4			JE 0x446425		

  0x446461		c5f877			VZEROUPPER		

  0x446464		c60000			MOVB $0x0, 0(AX)	

  0x446467		c3			RET			

  0x446468		c5f877			VZEROUPPER		

  0x44646b		4883fb08		CMPQ $0x8, BX		

  0x44646f		761b			JBE 0x44648c		

  0x446471		488b0e			MOVQ 0(SI), CX		

  0x446474		488b17			MOVQ 0(DI), DX		

  0x446477		4883c608		ADDQ $0x8, SI		

  0x44647b		4883c708		ADDQ $0x8, DI		

  0x44647f		4883eb08		SUBQ $0x8, BX		

  0x446483		4839d1			CMPQ DX, CX		

  0x446486		74e3			JE 0x44646b		

  0x446488		c60000			MOVB $0x0, 0(AX)	

  0x44648b		c3			RET			

  0x44648c		488b4c1ef8		MOVQ -0x8(SI)(BX*1), CX	

  0x446491		488b541ff8		MOVQ -0x8(DI)(BX*1), DX	

  0x446496		4839d1			CMPQ DX, CX		

  0x446499		0f9400			SETE 0(AX)		

  0x44649c		c3			RET			

  0x44649d		4883fb00		CMPQ $0x0, BX		

  0x4464a1		7437			JE 0x4464da		

  0x4464a3		488d0cdd00000000	LEAQ 0(BX*8), CX	

  0x4464ab		48f7d9			NEGQ CX			

  0x4464ae		4080fef8		CMPL $0xf8, SI		

  0x4464b2		7705			JA 0x4464b9		

  0x4464b4		488b36			MOVQ 0(SI), SI		

  0x4464b7		eb08			JMP 0x4464c1		

  0x4464b9		488b741ef8		MOVQ -0x8(SI)(BX*1), SI	

  0x4464be		48d3ee			SHRQ CL, SI		

  0x4464c1		4080fff8		CMPL $0xf8, DI		

  0x4464c5		7705			JA 0x4464cc		

  0x4464c7		488b3f			MOVQ 0(DI), DI		

  0x4464ca		eb08			JMP 0x4464d4		

  0x4464cc		488b7c1ff8		MOVQ -0x8(DI)(BX*1), DI	

  0x4464d1		48d3ef			SHRQ CL, DI		

  0x4464d4		4829f7			SUBQ SI, DI		

  0x4464d7		48d3e7			SHLQ CL, DI		

  0x4464da		0f9400			SETE 0(AX)		

  0x4464dd		c3			RET			

TEXT runtime.cmpstring(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4464e0		488b742408		MOVQ 0x8(SP), SI	

  0x4464e5		488b5c2410		MOVQ 0x10(SP), BX	

  0x4464ea		488b7c2418		MOVQ 0x18(SP), DI	

  0x4464ef		488b542420		MOVQ 0x20(SP), DX	

  0x4464f4		4c8d4c2428		LEAQ 0x28(SP), R9	

  0x4464f9		e902000000		JMP runtime.cmpbody(SB)	

TEXT runtime.cmpbody(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446500		4839fe			CMPQ DI, SI		

  0x446503		0f842b010000		JE 0x446634		

  0x446509		4839d3			CMPQ DX, BX		

  0x44650c		4989d0			MOVQ DX, R8		

  0x44650f		4c0f4cc3		CMOVL BX, R8		

  0x446513		4983f808		CMPQ $0x8, R8		

  0x446517		0f82bc000000		JB 0x4465d9		

  0x44651d		4983f83f		CMPQ $0x3f, R8		

  0x446521		7612			JBE 0x446535		

  0x446523		803d89d3070001		CMPB $0x1, runtime.support_avx2(SB)	

  0x44652a		0f84ad010000		JE 0x4466dd		

  0x446530		e917010000		JMP 0x44664c		

  0x446535		4983f810		CMPQ $0x10, R8		

  0x446539		765e			JBE 0x446599		

  0x44653b		f30f6f06		MOVDQU 0(SI), X0	

  0x44653f		f30f6f0f		MOVDQU 0(DI), X1	

  0x446543		660f74c8		PCMPEQB X0, X1		

  0x446547		660fd7c1		PMOVMSKB X1, AX		

  0x44654b		4835ffff0000		XORQ $0xffff, AX	

  0x446551		752a			JNE 0x44657d		

  0x446553		4883c610		ADDQ $0x10, SI		

  0x446557		4883c710		ADDQ $0x10, DI		

  0x44655b		4983e810		SUBQ $0x10, R8		

  0x44655f		ebd4			JMP 0x446535		

  0x446561		4883c630		ADDQ $0x30, SI		

  0x446565		4883c730		ADDQ $0x30, DI		

  0x446569		eb12			JMP 0x44657d		

  0x44656b		4883c620		ADDQ $0x20, SI		

  0x44656f		4883c720		ADDQ $0x20, DI		

  0x446573		eb08			JMP 0x44657d		

  0x446575		4883c610		ADDQ $0x10, SI		

  0x446579		4883c710		ADDQ $0x10, DI		

  0x44657d		480fbcd8		BSFQ AX, BX		

  0x446581		4831c0			XORQ AX, AX		

  0x446584		8a0c1e			MOVB 0(SI)(BX*1), CL	

  0x446587		3a0c1f			CMPB 0(DI)(BX*1), CL	

  0x44658a		0f97c0			SETA AL			

  0x44658d		488d0445ffffffff	LEAQ 0xffffffff(AX*2), AX	

  0x446595		498901			MOVQ AX, 0(R9)		

  0x446598		c3			RET			

  0x446599		4983f808		CMPQ $0x8, R8		

  0x44659d		760b			JBE 0x4465aa		

  0x44659f		488b06			MOVQ 0(SI), AX		

  0x4465a2		488b0f			MOVQ 0(DI), CX		

  0x4465a5		4839c8			CMPQ CX, AX		

  0x4465a8		750f			JNE 0x4465b9		

  0x4465aa		4a8b4406f8		MOVQ -0x8(SI)(R8*1), AX	

  0x4465af		4a8b4c07f8		MOVQ -0x8(DI)(R8*1), CX	

  0x4465b4		4839c8			CMPQ CX, AX		

  0x4465b7		747b			JE 0x446634		

  0x4465b9		480fc8			BSWAP AX		

  0x4465bc		480fc9			BSWAP CX		

  0x4465bf		4831c1			XORQ AX, CX		

  0x4465c2		480fbdc9		BSRQ CX, CX		

  0x4465c6		48d3e8			SHRQ CL, AX		

  0x4465c9		4883e001		ANDQ $0x1, AX		

  0x4465cd		488d0445ffffffff	LEAQ 0xffffffff(AX*2), AX	

  0x4465d5		498901			MOVQ AX, 0(R9)		

  0x4465d8		c3			RET			

  0x4465d9		4a8d0cc500000000	LEAQ 0(R8*8), CX	

  0x4465e1		48f7d9			NEGQ CX			

  0x4465e4		744e			JE 0x446634		

  0x4465e6		4080fef8		CMPL $0xf8, SI		

  0x4465ea		7705			JA 0x4465f1		

  0x4465ec		488b36			MOVQ 0(SI), SI		

  0x4465ef		eb08			JMP 0x4465f9		

  0x4465f1		4a8b7406f8		MOVQ -0x8(SI)(R8*1), SI	

  0x4465f6		48d3ee			SHRQ CL, SI		

  0x4465f9		48d3e6			SHLQ CL, SI		

  0x4465fc		4080fff8		CMPL $0xf8, DI		

  0x446600		7705			JA 0x446607		

  0x446602		488b3f			MOVQ 0(DI), DI		

  0x446605		eb08			JMP 0x44660f		

  0x446607		4a8b7c07f8		MOVQ -0x8(DI)(R8*1), DI	

  0x44660c		48d3ef			SHRQ CL, DI		

  0x44660f		48d3e7			SHLQ CL, DI		

  0x446612		480fce			BSWAP SI		

  0x446615		480fcf			BSWAP DI		

  0x446618		4831f7			XORQ SI, DI		

  0x44661b		7417			JE 0x446634		

  0x44661d		480fbdcf		BSRQ DI, CX		

  0x446621		48d3ee			SHRQ CL, SI		

  0x446624		4883e601		ANDQ $0x1, SI		

  0x446628		488d0475ffffffff	LEAQ 0xffffffff(SI*2), AX	

  0x446630		498901			MOVQ AX, 0(R9)		

  0x446633		c3			RET			

  0x446634		4831c0			XORQ AX, AX		

  0x446637		4831c9			XORQ CX, CX		

  0x44663a		4839d3			CMPQ DX, BX		

  0x44663d		0f9fc0			SETG AL			

  0x446640		0f94c1			SETE CL			

  0x446643		488d4441ff		LEAQ -0x1(CX)(AX*2), AX	

  0x446648		498901			MOVQ AX, 0(R9)		

  0x44664b		c3			RET			

  0x44664c		f30f6f06		MOVDQU 0(SI), X0	

  0x446650		f30f6f0f		MOVDQU 0(DI), X1	

  0x446654		660f74c8		PCMPEQB X0, X1		

  0x446658		660fd7c1		PMOVMSKB X1, AX		

  0x44665c		4835ffff0000		XORQ $0xffff, AX	

  0x446662		0f8515ffffff		JNE 0x44657d		

  0x446668		f30f6f4610		MOVDQU 0x10(SI), X0	

  0x44666d		f30f6f4f10		MOVDQU 0x10(DI), X1	

  0x446672		660f74c8		PCMPEQB X0, X1		

  0x446676		660fd7c1		PMOVMSKB X1, AX		

  0x44667a		4835ffff0000		XORQ $0xffff, AX	

  0x446680		0f85effeffff		JNE 0x446575		

  0x446686		f30f6f4620		MOVDQU 0x20(SI), X0	

  0x44668b		f30f6f4f20		MOVDQU 0x20(DI), X1	

  0x446690		660f74c8		PCMPEQB X0, X1		

  0x446694		660fd7c1		PMOVMSKB X1, AX		

  0x446698		4835ffff0000		XORQ $0xffff, AX	

  0x44669e		0f85c7feffff		JNE 0x44656b		

  0x4466a4		f30f6f4630		MOVDQU 0x30(SI), X0	

  0x4466a9		f30f6f4f30		MOVDQU 0x30(DI), X1	

  0x4466ae		660f74c8		PCMPEQB X0, X1		

  0x4466b2		660fd7c1		PMOVMSKB X1, AX		

  0x4466b6		4835ffff0000		XORQ $0xffff, AX	

  0x4466bc		0f859ffeffff		JNE 0x446561		

  0x4466c2		4883c640		ADDQ $0x40, SI		

  0x4466c6		4883c740		ADDQ $0x40, DI		

  0x4466ca		4983e840		SUBQ $0x40, R8		

  0x4466ce		4983f840		CMPQ $0x40, R8		

  0x4466d2		0f865dfeffff		JBE 0x446535		

  0x4466d8		e96fffffff		JMP 0x44664c		

  0x4466dd		c5fe6f16		VMOVDQU 0(SI), X2	

  0x4466e1		c5fe6f1f		VMOVDQU 0(DI), X3	

  0x4466e5		c5fe6f6620		VMOVDQU 0x20(SI), X4	

  0x4466ea		c5fe6f6f20		VMOVDQU 0x20(DI), X5	

  0x4466ef		c5e574c2		JE 0x4466b5		

  0x4466f3		c5fdd7			XLATB DS:0(BX)		
  0x4466f6		c0			?			

  0x4466f7		35ffffffff		XORL $-0x1, AX		

  0x4466fc		7523			JNE 0x446721		

  0x4466fe		c5d574f4		JE 0x4466f6		

  0x446702		c5fdd7			XLATB DS:0(BX)		
  0x446705		c6			?			

  0x446706		35ffffffff		XORL $-0x1, AX		

  0x44670b		751c			JNE 0x446729		

  0x44670d		4883c640		ADDQ $0x40, SI		

  0x446711		4883c740		ADDQ $0x40, DI		

  0x446715		4983e840		SUBQ $0x40, R8		

  0x446719		4983f840		CMPQ $0x40, R8		

  0x44671d		7212			JB 0x446731		

  0x44671f		ebbc			JMP 0x4466dd		

  0x446721		c5f877			VZEROUPPER		

  0x446724		e954feffff		JMP 0x44657d		

  0x446729		c5f877			VZEROUPPER		

  0x44672c		e93afeffff		JMP 0x44656b		

  0x446731		c5f877			VZEROUPPER		

  0x446734		e9fcfdffff		JMP 0x446535		

TEXT strings.IndexByte(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446740		488b742408		MOVQ 0x8(SP), SI	

  0x446745		488b5c2410		MOVQ 0x10(SP), BX	

  0x44674a		8a442418		MOVB 0x18(SP), AL	

  0x44674e		4c8d442420		LEAQ 0x20(SP), R8	

  0x446753		e908000000		JMP runtime.indexbytebody(SB)	

TEXT runtime.indexbytebody(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446760		66480f6ec0		MOVQ AX, X0		

  0x446765		660f60c0		PUNPCKLBW X0, X0	

  0x446769		660f60c0		PUNPCKLBW X0, X0	

  0x44676d		660f70c000		PSHUFD $0x0, X0, X0	

  0x446772		4883fb10		CMPQ $0x10, BX		

  0x446776		7c54			JL 0x4467cc		

  0x446778		4889f7			MOVQ SI, DI		

  0x44677b		4883fb20		CMPQ $0x20, BX		

  0x44677f		0f878d000000		JA 0x446812		

  0x446785		488d441ef0		LEAQ -0x10(SI)(BX*1), AX	

  0x44678a		eb15			JMP 0x4467a1		

  0x44678c		f30f6f0f		MOVDQU 0(DI), X1	

  0x446790		660f74c8		PCMPEQB X0, X1		

  0x446794		660fd7d1		PMOVMSKB X1, DX		

  0x446798		0fbcd2			BSFL DX, DX		

  0x44679b		7525			JNE 0x4467c2		

  0x44679d		4883c710		ADDQ $0x10, DI		

  0x4467a1		4839c7			CMPQ AX, DI		

  0x4467a4		72e6			JB 0x44678c		

  0x4467a6		4889c7			MOVQ AX, DI		

  0x4467a9		f30f6f08		MOVDQU 0(AX), X1	

  0x4467ad		660f74c8		PCMPEQB X0, X1		

  0x4467b1		660fd7d1		PMOVMSKB X1, DX		

  0x4467b5		0fbcd2			BSFL DX, DX		

  0x4467b8		7508			JNE 0x4467c2		

  0x4467ba		49c700ffffffff		MOVQ $-0x1, 0(R8)	

  0x4467c1		c3			RET			

  0x4467c2		4829f7			SUBQ SI, DI		

  0x4467c5		4801d7			ADDQ DX, DI		

  0x4467c8		498938			MOVQ DI, 0(R8)		

  0x4467cb		c3			RET			

  0x4467cc		4885db			TESTQ BX, BX		

  0x4467cf		74e9			JE 0x4467ba		

  0x4467d1		488d4610		LEAQ 0x10(SI), AX	

  0x4467d5		66a9f00f		TESTW $0xff0, AX	

  0x4467d9		7419			JE 0x4467f4		

  0x4467db		f30f6f0e		MOVDQU 0(SI), X1	

  0x4467df		660f74c8		PCMPEQB X0, X1		

  0x4467e3		660fd7d1		PMOVMSKB X1, DX		

  0x4467e7		0fbcd2			BSFL DX, DX		

  0x4467ea		74ce			JE 0x4467ba		

  0x4467ec		39da			CMPL BX, DX		

  0x4467ee		73ca			JAE 0x4467ba		

  0x4467f0		498910			MOVQ DX, 0(R8)		

  0x4467f3		c3			RET			

  0x4467f4		f30f6f4c1ef0		MOVDQU -0x10(SI)(BX*1), X1	

  0x4467fa		660f74c8		PCMPEQB X0, X1		

  0x4467fe		660fd7d1		PMOVMSKB X1, DX		

  0x446802		89d9			MOVL BX, CX		

  0x446804		d3e2			SHLL CL, DX		

  0x446806		c1ea10			SHRL $0x10, DX		

  0x446809		0fbcd2			BSFL DX, DX		

  0x44680c		74ac			JE 0x4467ba		

  0x44680e		498910			MOVQ DX, 0(R8)		

  0x446811		c3			RET			

  0x446812		803d9ad0070001		CMPB $0x1, runtime.support_avx2(SB)	

  0x446819		0f8566ffffff		JNE 0x446785		

  0x44681f		66480f6ec0		MOVQ AX, X0		

  0x446824		4c8d5c1ee0		LEAQ -0x20(SI)(BX*1), R11	

  0x446829		c4e27d78c8		JS 0x4467f6		

  0x44682e		c5fe6f17		VMOVDQU 0(DI), X2	

  0x446832		c5ed74d9		JE 0x44680f		

  0x446836		c4			?			
  0x446837		e27d			LOOP 0x4468b6		
  0x446839		17			?			
  0x44683a		db			?			

  0x44683b		7526			JNE 0x446863		

  0x44683d		4883c720		ADDQ $0x20, DI		

  0x446841		4c39df			CMPQ R11, DI		

  0x446844		7ce8			JL 0x44682e		

  0x446846		4c89df			MOVQ R11, DI		

  0x446849		c5fe6f17		VMOVDQU 0(DI), X2	

  0x44684d		c5ed74d9		JE 0x44682a		

  0x446851		c4			?			
  0x446852		e27d			LOOP 0x4468d1		
  0x446854		17			?			
  0x446855		db			?			

  0x446856		750b			JNE 0x446863		

  0x446858		c5f877			VZEROUPPER		

  0x44685b		49c700ffffffff		MOVQ $-0x1, 0(R8)	

  0x446862		c3			RET			

  0x446863		c5fdd7			XLATB DS:0(BX)		
  0x446866		d30f			RORL CL, 0(DI)		

  0x446868		bcd24829f7		MOVL $-0x8d6b72e, SP	

  0x44686d		4801fa			ADDQ DI, DX		

  0x446870		498910			MOVQ DX, 0(R8)		

  0x446873		c5f877			VZEROUPPER		

  0x446876		c3			RET			

TEXT runtime.return0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446880		b800000000		MOVL $0x0, AX		

  0x446885		c3			RET			

TEXT runtime.goexit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x446890		90			NOPL			

  0x446891		e82a29feff		CALL runtime.goexit1(SB)	

  0x446896		90			NOPL			

TEXT runtime.gcWriteBarrier(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/asm_amd64.s

  0x4468a0		4881ec80000000		SUBQ $0x80, SP		
  0x4468a7		48896c2478		MOVQ BP, 0x78(SP)	
  0x4468ac		488d6c2478		LEAQ 0x78(SP), BP	

  0x4468b1		4c89742468		MOVQ R14, 0x68(SP)	

  0x4468b6		4c896c2470		MOVQ R13, 0x70(SP)	

  0x4468bb		644c8b2c25f8ffffff	MOVQ FS:0xfffffff8, R13	

  0x4468c4		4d8b6d30		MOVQ 0x30(R13), R13	

  0x4468c8		4d8badd0000000		MOVQ 0xd0(R13), R13	

  0x4468cf		4d8bb590120000		MOVQ 0x1290(R13), R14	

  0x4468d6		4d8d7610		LEAQ 0x10(R14), R14	

  0x4468da		4d89b590120000		MOVQ R14, 0x1290(R13)	

  0x4468e1		4d3bb598120000		CMPQ 0x1298(R13), R14	

  0x4468e8		498946f0		MOVQ AX, -0x10(R14)	

  0x4468ec		4c8b2f			MOVQ 0(DI), R13		

  0x4468ef		4d896ef8		MOVQ R13, -0x8(R14)	

  0x4468f3		741a			JE 0x44690f		

  0x4468f5		4c8b742468		MOVQ 0x68(SP), R14	

  0x4468fa		4c8b6c2470		MOVQ 0x70(SP), R13	

  0x4468ff		488907			MOVQ AX, 0(DI)		

  0x446902		488b6c2478		MOVQ 0x78(SP), BP	
  0x446907		4881c480000000		ADDQ $0x80, SP		
  0x44690e		c3			RET			

  0x44690f		48893c24		MOVQ DI, 0(SP)		

  0x446913		4889442408		MOVQ AX, 0x8(SP)	

  0x446918		48895c2410		MOVQ BX, 0x10(SP)	

  0x44691d		48894c2418		MOVQ CX, 0x18(SP)	

  0x446922		4889542420		MOVQ DX, 0x20(SP)	

  0x446927		4889742428		MOVQ SI, 0x28(SP)	

  0x44692c		48896c2430		MOVQ BP, 0x30(SP)	

  0x446931		4c89442438		MOVQ R8, 0x38(SP)	

  0x446936		4c894c2440		MOVQ R9, 0x40(SP)	

  0x44693b		4c89542448		MOVQ R10, 0x48(SP)	

  0x446940		4c895c2450		MOVQ R11, 0x50(SP)	

  0x446945		4c89642458		MOVQ R12, 0x58(SP)	

  0x44694a		4c897c2460		MOVQ R15, 0x60(SP)	

  0x44694f		e89c7bfdff		CALL runtime.wbBufFlush(SB)	

  0x446954		488b3c24		MOVQ 0(SP), DI		

  0x446958		488b442408		MOVQ 0x8(SP), AX	

  0x44695d		488b5c2410		MOVQ 0x10(SP), BX	

  0x446962		488b4c2418		MOVQ 0x18(SP), CX	

  0x446967		488b542420		MOVQ 0x20(SP), DX	

  0x44696c		488b742428		MOVQ 0x28(SP), SI	

  0x446971		488b6c2430		MOVQ 0x30(SP), BP	

  0x446976		4c8b442438		MOVQ 0x38(SP), R8	

  0x44697b		4c8b4c2440		MOVQ 0x40(SP), R9	

  0x446980		4c8b542448		MOVQ 0x48(SP), R10	

  0x446985		4c8b5c2450		MOVQ 0x50(SP), R11	

  0x44698a		4c8b642458		MOVQ 0x58(SP), R12	

  0x44698f		4c8b7c2460		MOVQ 0x60(SP), R15	

  0x446994		e95cffffff		JMP 0x4468f5		

TEXT runtime.duffzero(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/duff_amd64.s

  0x4469a0		0f1107			MOVUPS X0, 0(DI)	

  0x4469a3		0f114710		MOVUPS X0, 0x10(DI)	

  0x4469a7		0f114720		MOVUPS X0, 0x20(DI)	

  0x4469ab		0f114730		MOVUPS X0, 0x30(DI)	

  0x4469af		488d7f40		LEAQ 0x40(DI), DI	

  0x4469b3		0f1107			MOVUPS X0, 0(DI)	

  0x4469b6		0f114710		MOVUPS X0, 0x10(DI)	

  0x4469ba		0f114720		MOVUPS X0, 0x20(DI)	

  0x4469be		0f114730		MOVUPS X0, 0x30(DI)	

  0x4469c2		488d7f40		LEAQ 0x40(DI), DI	

  0x4469c6		0f1107			MOVUPS X0, 0(DI)	

  0x4469c9		0f114710		MOVUPS X0, 0x10(DI)	

  0x4469cd		0f114720		MOVUPS X0, 0x20(DI)	

  0x4469d1		0f114730		MOVUPS X0, 0x30(DI)	

  0x4469d5		488d7f40		LEAQ 0x40(DI), DI	

  0x4469d9		0f1107			MOVUPS X0, 0(DI)	

  0x4469dc		0f114710		MOVUPS X0, 0x10(DI)	

  0x4469e0		0f114720		MOVUPS X0, 0x20(DI)	

  0x4469e4		0f114730		MOVUPS X0, 0x30(DI)	

  0x4469e8		488d7f40		LEAQ 0x40(DI), DI	

  0x4469ec		0f1107			MOVUPS X0, 0(DI)	

  0x4469ef		0f114710		MOVUPS X0, 0x10(DI)	

  0x4469f3		0f114720		MOVUPS X0, 0x20(DI)	

  0x4469f7		0f114730		MOVUPS X0, 0x30(DI)	

  0x4469fb		488d7f40		LEAQ 0x40(DI), DI	

  0x4469ff		0f1107			MOVUPS X0, 0(DI)	

  0x446a02		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a06		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a0a		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a0e		488d7f40		LEAQ 0x40(DI), DI	

  0x446a12		0f1107			MOVUPS X0, 0(DI)	

  0x446a15		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a19		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a1d		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a21		488d7f40		LEAQ 0x40(DI), DI	

  0x446a25		0f1107			MOVUPS X0, 0(DI)	

  0x446a28		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a2c		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a30		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a34		488d7f40		LEAQ 0x40(DI), DI	

  0x446a38		0f1107			MOVUPS X0, 0(DI)	

  0x446a3b		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a3f		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a43		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a47		488d7f40		LEAQ 0x40(DI), DI	

  0x446a4b		0f1107			MOVUPS X0, 0(DI)	

  0x446a4e		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a52		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a56		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a5a		488d7f40		LEAQ 0x40(DI), DI	

  0x446a5e		0f1107			MOVUPS X0, 0(DI)	

  0x446a61		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a65		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a69		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a6d		488d7f40		LEAQ 0x40(DI), DI	

  0x446a71		0f1107			MOVUPS X0, 0(DI)	

  0x446a74		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a78		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a7c		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a80		488d7f40		LEAQ 0x40(DI), DI	

  0x446a84		0f1107			MOVUPS X0, 0(DI)	

  0x446a87		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a8b		0f114720		MOVUPS X0, 0x20(DI)	

  0x446a8f		0f114730		MOVUPS X0, 0x30(DI)	

  0x446a93		488d7f40		LEAQ 0x40(DI), DI	

  0x446a97		0f1107			MOVUPS X0, 0(DI)	

  0x446a9a		0f114710		MOVUPS X0, 0x10(DI)	

  0x446a9e		0f114720		MOVUPS X0, 0x20(DI)	

  0x446aa2		0f114730		MOVUPS X0, 0x30(DI)	

  0x446aa6		488d7f40		LEAQ 0x40(DI), DI	

  0x446aaa		0f1107			MOVUPS X0, 0(DI)	

  0x446aad		0f114710		MOVUPS X0, 0x10(DI)	

  0x446ab1		0f114720		MOVUPS X0, 0x20(DI)	

  0x446ab5		0f114730		MOVUPS X0, 0x30(DI)	

  0x446ab9		488d7f40		LEAQ 0x40(DI), DI	

  0x446abd		0f1107			MOVUPS X0, 0(DI)	

  0x446ac0		0f114710		MOVUPS X0, 0x10(DI)	

  0x446ac4		0f114720		MOVUPS X0, 0x20(DI)	

  0x446ac8		0f114730		MOVUPS X0, 0x30(DI)	

  0x446acc		488d7f40		LEAQ 0x40(DI), DI	

  0x446ad0		c3			RET			

TEXT runtime.duffcopy(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/duff_amd64.s

  0x446ae0		0f1006			MOVUPS 0(SI), X0	

  0x446ae3		4883c610		ADDQ $0x10, SI		

  0x446ae7		0f1107			MOVUPS X0, 0(DI)	

  0x446aea		4883c710		ADDQ $0x10, DI		

  0x446aee		0f1006			MOVUPS 0(SI), X0	

  0x446af1		4883c610		ADDQ $0x10, SI		

  0x446af5		0f1107			MOVUPS X0, 0(DI)	

  0x446af8		4883c710		ADDQ $0x10, DI		

  0x446afc		0f1006			MOVUPS 0(SI), X0	

  0x446aff		4883c610		ADDQ $0x10, SI		

  0x446b03		0f1107			MOVUPS X0, 0(DI)	

  0x446b06		4883c710		ADDQ $0x10, DI		

  0x446b0a		0f1006			MOVUPS 0(SI), X0	

  0x446b0d		4883c610		ADDQ $0x10, SI		

  0x446b11		0f1107			MOVUPS X0, 0(DI)	

  0x446b14		4883c710		ADDQ $0x10, DI		

  0x446b18		0f1006			MOVUPS 0(SI), X0	

  0x446b1b		4883c610		ADDQ $0x10, SI		

  0x446b1f		0f1107			MOVUPS X0, 0(DI)	

  0x446b22		4883c710		ADDQ $0x10, DI		

  0x446b26		0f1006			MOVUPS 0(SI), X0	

  0x446b29		4883c610		ADDQ $0x10, SI		

  0x446b2d		0f1107			MOVUPS X0, 0(DI)	

  0x446b30		4883c710		ADDQ $0x10, DI		

  0x446b34		0f1006			MOVUPS 0(SI), X0	

  0x446b37		4883c610		ADDQ $0x10, SI		

  0x446b3b		0f1107			MOVUPS X0, 0(DI)	

  0x446b3e		4883c710		ADDQ $0x10, DI		

  0x446b42		0f1006			MOVUPS 0(SI), X0	

  0x446b45		4883c610		ADDQ $0x10, SI		

  0x446b49		0f1107			MOVUPS X0, 0(DI)	

  0x446b4c		4883c710		ADDQ $0x10, DI		

  0x446b50		0f1006			MOVUPS 0(SI), X0	

  0x446b53		4883c610		ADDQ $0x10, SI		

  0x446b57		0f1107			MOVUPS X0, 0(DI)	

  0x446b5a		4883c710		ADDQ $0x10, DI		

  0x446b5e		0f1006			MOVUPS 0(SI), X0	

  0x446b61		4883c610		ADDQ $0x10, SI		

  0x446b65		0f1107			MOVUPS X0, 0(DI)	

  0x446b68		4883c710		ADDQ $0x10, DI		

  0x446b6c		0f1006			MOVUPS 0(SI), X0	

  0x446b6f		4883c610		ADDQ $0x10, SI		

  0x446b73		0f1107			MOVUPS X0, 0(DI)	

  0x446b76		4883c710		ADDQ $0x10, DI		

  0x446b7a		0f1006			MOVUPS 0(SI), X0	

  0x446b7d		4883c610		ADDQ $0x10, SI		

  0x446b81		0f1107			MOVUPS X0, 0(DI)	

  0x446b84		4883c710		ADDQ $0x10, DI		

  0x446b88		0f1006			MOVUPS 0(SI), X0	

  0x446b8b		4883c610		ADDQ $0x10, SI		

  0x446b8f		0f1107			MOVUPS X0, 0(DI)	

  0x446b92		4883c710		ADDQ $0x10, DI		

  0x446b96		0f1006			MOVUPS 0(SI), X0	

  0x446b99		4883c610		ADDQ $0x10, SI		

  0x446b9d		0f1107			MOVUPS X0, 0(DI)	

  0x446ba0		4883c710		ADDQ $0x10, DI		

  0x446ba4		0f1006			MOVUPS 0(SI), X0	

  0x446ba7		4883c610		ADDQ $0x10, SI		

  0x446bab		0f1107			MOVUPS X0, 0(DI)	

  0x446bae		4883c710		ADDQ $0x10, DI		

  0x446bb2		0f1006			MOVUPS 0(SI), X0	

  0x446bb5		4883c610		ADDQ $0x10, SI		

  0x446bb9		0f1107			MOVUPS X0, 0(DI)	

  0x446bbc		4883c710		ADDQ $0x10, DI		

  0x446bc0		0f1006			MOVUPS 0(SI), X0	

  0x446bc3		4883c610		ADDQ $0x10, SI		

  0x446bc7		0f1107			MOVUPS X0, 0(DI)	

  0x446bca		4883c710		ADDQ $0x10, DI		

  0x446bce		0f1006			MOVUPS 0(SI), X0	

  0x446bd1		4883c610		ADDQ $0x10, SI		

  0x446bd5		0f1107			MOVUPS X0, 0(DI)	

  0x446bd8		4883c710		ADDQ $0x10, DI		

  0x446bdc		0f1006			MOVUPS 0(SI), X0	

  0x446bdf		4883c610		ADDQ $0x10, SI		

  0x446be3		0f1107			MOVUPS X0, 0(DI)	

  0x446be6		4883c710		ADDQ $0x10, DI		

  0x446bea		0f1006			MOVUPS 0(SI), X0	

  0x446bed		4883c610		ADDQ $0x10, SI		

  0x446bf1		0f1107			MOVUPS X0, 0(DI)	

  0x446bf4		4883c710		ADDQ $0x10, DI		

  0x446bf8		0f1006			MOVUPS 0(SI), X0	

  0x446bfb		4883c610		ADDQ $0x10, SI		

  0x446bff		0f1107			MOVUPS X0, 0(DI)	

  0x446c02		4883c710		ADDQ $0x10, DI		

  0x446c06		0f1006			MOVUPS 0(SI), X0	

  0x446c09		4883c610		ADDQ $0x10, SI		

  0x446c0d		0f1107			MOVUPS X0, 0(DI)	

  0x446c10		4883c710		ADDQ $0x10, DI		

  0x446c14		0f1006			MOVUPS 0(SI), X0	

  0x446c17		4883c610		ADDQ $0x10, SI		

  0x446c1b		0f1107			MOVUPS X0, 0(DI)	

  0x446c1e		4883c710		ADDQ $0x10, DI		

  0x446c22		0f1006			MOVUPS 0(SI), X0	

  0x446c25		4883c610		ADDQ $0x10, SI		

  0x446c29		0f1107			MOVUPS X0, 0(DI)	

  0x446c2c		4883c710		ADDQ $0x10, DI		

  0x446c30		0f1006			MOVUPS 0(SI), X0	

  0x446c33		4883c610		ADDQ $0x10, SI		

  0x446c37		0f1107			MOVUPS X0, 0(DI)	

  0x446c3a		4883c710		ADDQ $0x10, DI		

  0x446c3e		0f1006			MOVUPS 0(SI), X0	

  0x446c41		4883c610		ADDQ $0x10, SI		

  0x446c45		0f1107			MOVUPS X0, 0(DI)	

  0x446c48		4883c710		ADDQ $0x10, DI		

  0x446c4c		0f1006			MOVUPS 0(SI), X0	

  0x446c4f		4883c610		ADDQ $0x10, SI		

  0x446c53		0f1107			MOVUPS X0, 0(DI)	

  0x446c56		4883c710		ADDQ $0x10, DI		

  0x446c5a		0f1006			MOVUPS 0(SI), X0	

  0x446c5d		4883c610		ADDQ $0x10, SI		

  0x446c61		0f1107			MOVUPS X0, 0(DI)	

  0x446c64		4883c710		ADDQ $0x10, DI		

  0x446c68		0f1006			MOVUPS 0(SI), X0	

  0x446c6b		4883c610		ADDQ $0x10, SI		

  0x446c6f		0f1107			MOVUPS X0, 0(DI)	

  0x446c72		4883c710		ADDQ $0x10, DI		

  0x446c76		0f1006			MOVUPS 0(SI), X0	

  0x446c79		4883c610		ADDQ $0x10, SI		

  0x446c7d		0f1107			MOVUPS X0, 0(DI)	

  0x446c80		4883c710		ADDQ $0x10, DI		

  0x446c84		0f1006			MOVUPS 0(SI), X0	

  0x446c87		4883c610		ADDQ $0x10, SI		

  0x446c8b		0f1107			MOVUPS X0, 0(DI)	

  0x446c8e		4883c710		ADDQ $0x10, DI		

  0x446c92		0f1006			MOVUPS 0(SI), X0	

  0x446c95		4883c610		ADDQ $0x10, SI		

  0x446c99		0f1107			MOVUPS X0, 0(DI)	

  0x446c9c		4883c710		ADDQ $0x10, DI		

  0x446ca0		0f1006			MOVUPS 0(SI), X0	

  0x446ca3		4883c610		ADDQ $0x10, SI		

  0x446ca7		0f1107			MOVUPS X0, 0(DI)	

  0x446caa		4883c710		ADDQ $0x10, DI		

  0x446cae		0f1006			MOVUPS 0(SI), X0	

  0x446cb1		4883c610		ADDQ $0x10, SI		

  0x446cb5		0f1107			MOVUPS X0, 0(DI)	

  0x446cb8		4883c710		ADDQ $0x10, DI		

  0x446cbc		0f1006			MOVUPS 0(SI), X0	

  0x446cbf		4883c610		ADDQ $0x10, SI		

  0x446cc3		0f1107			MOVUPS X0, 0(DI)	

  0x446cc6		4883c710		ADDQ $0x10, DI		

  0x446cca		0f1006			MOVUPS 0(SI), X0	

  0x446ccd		4883c610		ADDQ $0x10, SI		

  0x446cd1		0f1107			MOVUPS X0, 0(DI)	

  0x446cd4		4883c710		ADDQ $0x10, DI		

  0x446cd8		0f1006			MOVUPS 0(SI), X0	

  0x446cdb		4883c610		ADDQ $0x10, SI		

  0x446cdf		0f1107			MOVUPS X0, 0(DI)	

  0x446ce2		4883c710		ADDQ $0x10, DI		

  0x446ce6		0f1006			MOVUPS 0(SI), X0	

  0x446ce9		4883c610		ADDQ $0x10, SI		

  0x446ced		0f1107			MOVUPS X0, 0(DI)	

  0x446cf0		4883c710		ADDQ $0x10, DI		

  0x446cf4		0f1006			MOVUPS 0(SI), X0	

  0x446cf7		4883c610		ADDQ $0x10, SI		

  0x446cfb		0f1107			MOVUPS X0, 0(DI)	

  0x446cfe		4883c710		ADDQ $0x10, DI		

  0x446d02		0f1006			MOVUPS 0(SI), X0	

  0x446d05		4883c610		ADDQ $0x10, SI		

  0x446d09		0f1107			MOVUPS X0, 0(DI)	

  0x446d0c		4883c710		ADDQ $0x10, DI		

  0x446d10		0f1006			MOVUPS 0(SI), X0	

  0x446d13		4883c610		ADDQ $0x10, SI		

  0x446d17		0f1107			MOVUPS X0, 0(DI)	

  0x446d1a		4883c710		ADDQ $0x10, DI		

  0x446d1e		0f1006			MOVUPS 0(SI), X0	

  0x446d21		4883c610		ADDQ $0x10, SI		

  0x446d25		0f1107			MOVUPS X0, 0(DI)	

  0x446d28		4883c710		ADDQ $0x10, DI		

  0x446d2c		0f1006			MOVUPS 0(SI), X0	

  0x446d2f		4883c610		ADDQ $0x10, SI		

  0x446d33		0f1107			MOVUPS X0, 0(DI)	

  0x446d36		4883c710		ADDQ $0x10, DI		

  0x446d3a		0f1006			MOVUPS 0(SI), X0	

  0x446d3d		4883c610		ADDQ $0x10, SI		

  0x446d41		0f1107			MOVUPS X0, 0(DI)	

  0x446d44		4883c710		ADDQ $0x10, DI		

  0x446d48		0f1006			MOVUPS 0(SI), X0	

  0x446d4b		4883c610		ADDQ $0x10, SI		

  0x446d4f		0f1107			MOVUPS X0, 0(DI)	

  0x446d52		4883c710		ADDQ $0x10, DI		

  0x446d56		0f1006			MOVUPS 0(SI), X0	

  0x446d59		4883c610		ADDQ $0x10, SI		

  0x446d5d		0f1107			MOVUPS X0, 0(DI)	

  0x446d60		4883c710		ADDQ $0x10, DI		

  0x446d64		0f1006			MOVUPS 0(SI), X0	

  0x446d67		4883c610		ADDQ $0x10, SI		

  0x446d6b		0f1107			MOVUPS X0, 0(DI)	

  0x446d6e		4883c710		ADDQ $0x10, DI		

  0x446d72		0f1006			MOVUPS 0(SI), X0	

  0x446d75		4883c610		ADDQ $0x10, SI		

  0x446d79		0f1107			MOVUPS X0, 0(DI)	

  0x446d7c		4883c710		ADDQ $0x10, DI		

  0x446d80		0f1006			MOVUPS 0(SI), X0	

  0x446d83		4883c610		ADDQ $0x10, SI		

  0x446d87		0f1107			MOVUPS X0, 0(DI)	

  0x446d8a		4883c710		ADDQ $0x10, DI		

  0x446d8e		0f1006			MOVUPS 0(SI), X0	

  0x446d91		4883c610		ADDQ $0x10, SI		

  0x446d95		0f1107			MOVUPS X0, 0(DI)	

  0x446d98		4883c710		ADDQ $0x10, DI		

  0x446d9c		0f1006			MOVUPS 0(SI), X0	

  0x446d9f		4883c610		ADDQ $0x10, SI		

  0x446da3		0f1107			MOVUPS X0, 0(DI)	

  0x446da6		4883c710		ADDQ $0x10, DI		

  0x446daa		0f1006			MOVUPS 0(SI), X0	

  0x446dad		4883c610		ADDQ $0x10, SI		

  0x446db1		0f1107			MOVUPS X0, 0(DI)	

  0x446db4		4883c710		ADDQ $0x10, DI		

  0x446db8		0f1006			MOVUPS 0(SI), X0	

  0x446dbb		4883c610		ADDQ $0x10, SI		

  0x446dbf		0f1107			MOVUPS X0, 0(DI)	

  0x446dc2		4883c710		ADDQ $0x10, DI		

  0x446dc6		0f1006			MOVUPS 0(SI), X0	

  0x446dc9		4883c610		ADDQ $0x10, SI		

  0x446dcd		0f1107			MOVUPS X0, 0(DI)	

  0x446dd0		4883c710		ADDQ $0x10, DI		

  0x446dd4		0f1006			MOVUPS 0(SI), X0	

  0x446dd7		4883c610		ADDQ $0x10, SI		

  0x446ddb		0f1107			MOVUPS X0, 0(DI)	

  0x446dde		4883c710		ADDQ $0x10, DI		

  0x446de2		0f1006			MOVUPS 0(SI), X0	

  0x446de5		4883c610		ADDQ $0x10, SI		

  0x446de9		0f1107			MOVUPS X0, 0(DI)	

  0x446dec		4883c710		ADDQ $0x10, DI		

  0x446df0		0f1006			MOVUPS 0(SI), X0	

  0x446df3		4883c610		ADDQ $0x10, SI		

  0x446df7		0f1107			MOVUPS X0, 0(DI)	

  0x446dfa		4883c710		ADDQ $0x10, DI		

  0x446dfe		0f1006			MOVUPS 0(SI), X0	

  0x446e01		4883c610		ADDQ $0x10, SI		

  0x446e05		0f1107			MOVUPS X0, 0(DI)	

  0x446e08		4883c710		ADDQ $0x10, DI		

  0x446e0c		0f1006			MOVUPS 0(SI), X0	

  0x446e0f		4883c610		ADDQ $0x10, SI		

  0x446e13		0f1107			MOVUPS X0, 0(DI)	

  0x446e16		4883c710		ADDQ $0x10, DI		

  0x446e1a		0f1006			MOVUPS 0(SI), X0	

  0x446e1d		4883c610		ADDQ $0x10, SI		

  0x446e21		0f1107			MOVUPS X0, 0(DI)	

  0x446e24		4883c710		ADDQ $0x10, DI		

  0x446e28		0f1006			MOVUPS 0(SI), X0	

  0x446e2b		4883c610		ADDQ $0x10, SI		

  0x446e2f		0f1107			MOVUPS X0, 0(DI)	

  0x446e32		4883c710		ADDQ $0x10, DI		

  0x446e36		0f1006			MOVUPS 0(SI), X0	

  0x446e39		4883c610		ADDQ $0x10, SI		

  0x446e3d		0f1107			MOVUPS X0, 0(DI)	

  0x446e40		4883c710		ADDQ $0x10, DI		

  0x446e44		0f1006			MOVUPS 0(SI), X0	

  0x446e47		4883c610		ADDQ $0x10, SI		

  0x446e4b		0f1107			MOVUPS X0, 0(DI)	

  0x446e4e		4883c710		ADDQ $0x10, DI		

  0x446e52		0f1006			MOVUPS 0(SI), X0	

  0x446e55		4883c610		ADDQ $0x10, SI		

  0x446e59		0f1107			MOVUPS X0, 0(DI)	

  0x446e5c		4883c710		ADDQ $0x10, DI		

  0x446e60		c3			RET			

TEXT runtime.memclrNoHeapPointers(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/memclr_amd64.s

  0x446e70		488b7c2408		MOVQ 0x8(SP), DI	

  0x446e75		488b5c2410		MOVQ 0x10(SP), BX	

  0x446e7a		4831c0			XORQ AX, AX		

  0x446e7d		4885db			TESTQ BX, BX		

  0x446e80		0f84a8010000		JE 0x44702e		

  0x446e86		4883fb02		CMPQ $0x2, BX		

  0x446e8a		0f8697010000		JBE 0x447027		

  0x446e90		4883fb04		CMPQ $0x4, BX		

  0x446e94		0f8695010000		JBE 0x44702f		

  0x446e9a		4883fb08		CMPQ $0x8, BX		

  0x446e9e		0f8294010000		JB 0x447038		

  0x446ea4		0f8495010000		JE 0x44703f		

  0x446eaa		4883fb10		CMPQ $0x10, BX		

  0x446eae		0f868f010000		JBE 0x447043		

  0x446eb4		660fefc0		PXOR X0, X0		

  0x446eb8		4883fb20		CMPQ $0x20, BX		

  0x446ebc		0f868a010000		JBE 0x44704c		

  0x446ec2		4883fb40		CMPQ $0x40, BX		

  0x446ec6		0f868b010000		JBE 0x447057		

  0x446ecc		4881fb80000000		CMPQ $0x80, BX		

  0x446ed3		0f8694010000		JBE 0x44706d		

  0x446ed9		4881fb00010000		CMPQ $0x100, BX		

  0x446ee0		0f86b3010000		JBE 0x447099		

  0x446ee6		803dc6c9070001		CMPB $0x1, runtime.support_avx2(SB)	

  0x446eed		0f8483000000		JE 0x446f76		

  0x446ef3		f30f7f07		MOVDQU X0, 0(DI)	

  0x446ef7		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x446efc		f30f7f4720		MOVDQU X0, 0x20(DI)	

  0x446f01		f30f7f4730		MOVDQU X0, 0x30(DI)	

  0x446f06		f30f7f4740		MOVDQU X0, 0x40(DI)	

  0x446f0b		f30f7f4750		MOVDQU X0, 0x50(DI)	

  0x446f10		f30f7f4760		MOVDQU X0, 0x60(DI)	

  0x446f15		f30f7f4770		MOVDQU X0, 0x70(DI)	

  0x446f1a		f30f7f8780000000	MOVDQU X0, 0x80(DI)	

  0x446f22		f30f7f8790000000	MOVDQU X0, 0x90(DI)	

  0x446f2a		f30f7f87a0000000	MOVDQU X0, 0xa0(DI)	

  0x446f32		f30f7f87b0000000	MOVDQU X0, 0xb0(DI)	

  0x446f3a		f30f7f87c0000000	MOVDQU X0, 0xc0(DI)	

  0x446f42		f30f7f87d0000000	MOVDQU X0, 0xd0(DI)	

  0x446f4a		f30f7f87e0000000	MOVDQU X0, 0xe0(DI)	

  0x446f52		f30f7f87f0000000	MOVDQU X0, 0xf0(DI)	

  0x446f5a		4881eb00010000		SUBQ $0x100, BX		

  0x446f61		4881c700010000		ADDQ $0x100, DI		

  0x446f68		4881fb00010000		CMPQ $0x100, BX		

  0x446f6f		7382			JAE 0x446ef3		

  0x446f71		e907ffffff		JMP 0x446e7d		

  0x446f76		c5fdef			OUTL AX, DX		
  0x446f79		c04881fb		RORB $0xfb, -0x7f(AX)	

  0x446f7d		0000			ADDB AL, 0(AX)		
  0x446f7f		0002			ADDB AL, 0(DX)		

  0x446f81		7346			JAE 0x446fc9		

  0x446f83		c5fe7f07		VMOVDQU X0, 0(DI)	

  0x446f87		c5fe7f4720		VMOVDQU X0, 0x20(DI)	

  0x446f8c		c5fe7f4740		VMOVDQU X0, 0x40(DI)	

  0x446f91		c5fe7f4760		VMOVDQU X0, 0x60(DI)	

  0x446f96		4881eb80000000		SUBQ $0x80, BX		

  0x446f9d		4881c780000000		ADDQ $0x80, DI		

  0x446fa4		4881fb80000000		CMPQ $0x80, BX		

  0x446fab		73d6			JAE 0x446f83		

  0x446fad		c5fe7f441fe0		VMOVDQU X0, -0x20(DI)(BX*1)	

  0x446fb3		c5fe7f441fc0		VMOVDQU X0, -0x40(DI)(BX*1)	

  0x446fb9		c5fe7f441fa0		VMOVDQU X0, -0x60(DI)(BX*1)	

  0x446fbf		c5fe7f441f80		VMOVDQU X0, -0x80(DI)(BX*1)	

  0x446fc5		c5f877			VZEROUPPER		

  0x446fc8		c3			RET			

  0x446fc9		c5fe7f07		VMOVDQU X0, 0(DI)	

  0x446fcd		4889fe			MOVQ DI, SI		

  0x446fd0		4883c720		ADDQ $0x20, DI		

  0x446fd4		4883e7e0		ANDQ $-0x20, DI		

  0x446fd8		4829fe			SUBQ DI, SI		

  0x446fdb		4801f3			ADDQ SI, BX		

  0x446fde		c5fde707		VMOVNTDQ X0, 0(DI)	

  0x446fe2		c5fde74720		VMOVNTDQ X0, 0x20(DI)	

  0x446fe7		c5fde74740		VMOVNTDQ X0, 0x40(DI)	

  0x446fec		c5fde74760		VMOVNTDQ X0, 0x60(DI)	

  0x446ff1		4881eb80000000		SUBQ $0x80, BX		

  0x446ff8		4881c780000000		ADDQ $0x80, DI		

  0x446fff		4881fb80000000		CMPQ $0x80, BX		

  0x447006		73d6			JAE 0x446fde		

  0x447008		0faef8			SFENCE			

  0x44700b		c5fe7f441fe0		VMOVDQU X0, -0x20(DI)(BX*1)	

  0x447011		c5fe7f441fc0		VMOVDQU X0, -0x40(DI)(BX*1)	

  0x447017		c5fe7f441fa0		VMOVDQU X0, -0x60(DI)(BX*1)	

  0x44701d		c5fe7f441f80		VMOVDQU X0, -0x80(DI)(BX*1)	

  0x447023		c5f877			VZEROUPPER		

  0x447026		c3			RET			

  0x447027		8807			MOVB AL, 0(DI)		

  0x447029		88441fff		MOVB AL, -0x1(DI)(BX*1)	

  0x44702d		c3			RET			

  0x44702e		c3			RET			

  0x44702f		668907			MOVW AX, 0(DI)		

  0x447032		6689441ffe		MOVW AX, -0x2(DI)(BX*1)	

  0x447037		c3			RET			

  0x447038		8907			MOVL AX, 0(DI)		

  0x44703a		89441ffc		MOVL AX, -0x4(DI)(BX*1)	

  0x44703e		c3			RET			

  0x44703f		488907			MOVQ AX, 0(DI)		

  0x447042		c3			RET			

  0x447043		488907			MOVQ AX, 0(DI)		

  0x447046		4889441ff8		MOVQ AX, -0x8(DI)(BX*1)	

  0x44704b		c3			RET			

  0x44704c		f30f7f07		MOVDQU X0, 0(DI)	

  0x447050		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x447056		c3			RET			

  0x447057		f30f7f07		MOVDQU X0, 0(DI)	

  0x44705b		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x447060		f30f7f441fe0		MOVDQU X0, -0x20(DI)(BX*1)	

  0x447066		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x44706c		c3			RET			

  0x44706d		f30f7f07		MOVDQU X0, 0(DI)	

  0x447071		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x447076		f30f7f4720		MOVDQU X0, 0x20(DI)	

  0x44707b		f30f7f4730		MOVDQU X0, 0x30(DI)	

  0x447080		f30f7f441fc0		MOVDQU X0, -0x40(DI)(BX*1)	

  0x447086		f30f7f441fd0		MOVDQU X0, -0x30(DI)(BX*1)	

  0x44708c		f30f7f441fe0		MOVDQU X0, -0x20(DI)(BX*1)	

  0x447092		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x447098		c3			RET			

  0x447099		f30f7f07		MOVDQU X0, 0(DI)	

  0x44709d		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x4470a2		f30f7f4720		MOVDQU X0, 0x20(DI)	

  0x4470a7		f30f7f4730		MOVDQU X0, 0x30(DI)	

  0x4470ac		f30f7f4740		MOVDQU X0, 0x40(DI)	

  0x4470b1		f30f7f4750		MOVDQU X0, 0x50(DI)	

  0x4470b6		f30f7f4760		MOVDQU X0, 0x60(DI)	

  0x4470bb		f30f7f4770		MOVDQU X0, 0x70(DI)	

  0x4470c0		f30f7f441f80		MOVDQU X0, -0x80(DI)(BX*1)	

  0x4470c6		f30f7f441f90		MOVDQU X0, -0x70(DI)(BX*1)	

  0x4470cc		f30f7f441fa0		MOVDQU X0, -0x60(DI)(BX*1)	

  0x4470d2		f30f7f441fb0		MOVDQU X0, -0x50(DI)(BX*1)	

  0x4470d8		f30f7f441fc0		MOVDQU X0, -0x40(DI)(BX*1)	

  0x4470de		f30f7f441fd0		MOVDQU X0, -0x30(DI)(BX*1)	

  0x4470e4		f30f7f441fe0		MOVDQU X0, -0x20(DI)(BX*1)	

  0x4470ea		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x4470f0		c3			RET			

TEXT runtime.memmove(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/memmove_amd64.s

  0x447100		488b7c2408		MOVQ 0x8(SP), DI	

  0x447105		488b742410		MOVQ 0x10(SP), SI	

  0x44710a		488b5c2418		MOVQ 0x18(SP), BX	

  0x44710f		4885db			TESTQ BX, BX		

  0x447112		0f84f1000000		JE 0x447209		

  0x447118		4883fb02		CMPQ $0x2, BX		

  0x44711c		0f86da000000		JBE 0x4471fc		

  0x447122		4883fb04		CMPQ $0x4, BX		

  0x447126		0f86de000000		JBE 0x44720a		

  0x44712c		4883fb08		CMPQ $0x8, BX		

  0x447130		0f82ec000000		JB 0x447222		

  0x447136		0f84f3000000		JE 0x44722f		

  0x44713c		4883fb10		CMPQ $0x10, BX		

  0x447140		0f86f0000000		JBE 0x447236		

  0x447146		4883fb20		CMPQ $0x20, BX		

  0x44714a		0f86f7000000		JBE 0x447247		

  0x447150		4883fb40		CMPQ $0x40, BX		

  0x447154		0f8602010000		JBE 0x44725c		

  0x44715a		4881fb80000000		CMPQ $0x80, BX		

  0x447161		0f8620010000		JBE 0x447287		

  0x447167		4881fb00010000		CMPQ $0x100, BX		

  0x44716e		0f866a010000		JBE 0x4472de		

  0x447174		f60542c7070001		TESTB $0x1, runtime.useAVXmemmove(SB)	

  0x44717b		0f8521030000		JNE 0x4474a2		

  0x447181		4839fe			CMPQ DI, SI		

  0x447184		763a			JBE 0x4471c0		

  0x447186		4881fb00080000		CMPQ $0x800, BX		

  0x44718d		0f860a020000		JBE 0x44739d		

  0x447193		803d1cc7070001		CMPB $0x1, runtime.support_erms(SB)	

  0x44719a		7511			JNE 0x4471ad		

  0x44719c		89f0			MOVL SI, AX		

  0x44719e		09f8			ORL DI, AX		

  0x4471a0		a907000000		TESTL $0x7, AX		

  0x4471a5		7406			JE 0x4471ad		

  0x4471a7		4889d9			MOVQ BX, CX		

  0x4471aa		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)	

  0x4471ac		c3			RET			

  0x4471ad		4889d9			MOVQ BX, CX		

  0x4471b0		48c1e903		SHRQ $0x3, CX		

  0x4471b4		4883e307		ANDQ $0x7, BX		

  0x4471b8		f348a5			REP; MOVSQ DS:0(SI), ES:0(DI)	

  0x4471bb		e94fffffff		JMP 0x44710f		

  0x4471c0		4889f1			MOVQ SI, CX		

  0x4471c3		4801d9			ADDQ BX, CX		

  0x4471c6		4839f9			CMPQ DI, CX		

  0x4471c9		76bb			JBE 0x447186		

  0x4471cb		4801df			ADDQ BX, DI		

  0x4471ce		4801de			ADDQ BX, SI		

  0x4471d1		fd			STD			

  0x4471d2		4889d9			MOVQ BX, CX		

  0x4471d5		48c1e903		SHRQ $0x3, CX		

  0x4471d9		4883e307		ANDQ $0x7, BX		

  0x4471dd		4883ef08		SUBQ $0x8, DI		

  0x4471e1		4883ee08		SUBQ $0x8, SI		

  0x4471e5		f348a5			REP; MOVSQ DS:0(SI), ES:0(DI)	

  0x4471e8		fc			CLD			

  0x4471e9		4883c708		ADDQ $0x8, DI		

  0x4471ed		4883c608		ADDQ $0x8, SI		

  0x4471f1		4829df			SUBQ BX, DI		

  0x4471f4		4829de			SUBQ BX, SI		

  0x4471f7		e913ffffff		JMP 0x44710f		

  0x4471fc		8a06			MOVB 0(SI), AL		

  0x4471fe		8a4c1eff		MOVB -0x1(SI)(BX*1), CL	

  0x447202		8807			MOVB AL, 0(DI)		

  0x447204		884c1fff		MOVB CL, -0x1(DI)(BX*1)	

  0x447208		c3			RET			

  0x447209		c3			RET			

  0x44720a		4883fb04		CMPQ $0x4, BX		

  0x44720e		7205			JB 0x447215		

  0x447210		8b06			MOVL 0(SI), AX		

  0x447212		8907			MOVL AX, 0(DI)		

  0x447214		c3			RET			

  0x447215		668b06			MOVW 0(SI), AX		

  0x447218		8a4e02			MOVB 0x2(SI), CL	

  0x44721b		668907			MOVW AX, 0(DI)		

  0x44721e		884f02			MOVB CL, 0x2(DI)	

  0x447221		c3			RET			

  0x447222		8b06			MOVL 0(SI), AX		

  0x447224		8b4c1efc		MOVL -0x4(SI)(BX*1), CX	

  0x447228		8907			MOVL AX, 0(DI)		

  0x44722a		894c1ffc		MOVL CX, -0x4(DI)(BX*1)	

  0x44722e		c3			RET			

  0x44722f		488b06			MOVQ 0(SI), AX		

  0x447232		488907			MOVQ AX, 0(DI)		

  0x447235		c3			RET			

  0x447236		488b06			MOVQ 0(SI), AX		

  0x447239		488b4c1ef8		MOVQ -0x8(SI)(BX*1), CX	

  0x44723e		488907			MOVQ AX, 0(DI)		

  0x447241		48894c1ff8		MOVQ CX, -0x8(DI)(BX*1)	

  0x447246		c3			RET			

  0x447247		f30f6f06		MOVDQU 0(SI), X0	

  0x44724b		f30f6f4c1ef0		MOVDQU -0x10(SI)(BX*1), X1	

  0x447251		f30f7f07		MOVDQU X0, 0(DI)	

  0x447255		f30f7f4c1ff0		MOVDQU X1, -0x10(DI)(BX*1)	

  0x44725b		c3			RET			

  0x44725c		f30f6f06		MOVDQU 0(SI), X0	

  0x447260		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x447265		f30f6f541ee0		MOVDQU -0x20(SI)(BX*1), X2	

  0x44726b		f30f6f5c1ef0		MOVDQU -0x10(SI)(BX*1), X3	

  0x447271		f30f7f07		MOVDQU X0, 0(DI)	

  0x447275		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x44727a		f30f7f541fe0		MOVDQU X2, -0x20(DI)(BX*1)	

  0x447280		f30f7f5c1ff0		MOVDQU X3, -0x10(DI)(BX*1)	

  0x447286		c3			RET			

  0x447287		f30f6f06		MOVDQU 0(SI), X0	

  0x44728b		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x447290		f30f6f5620		MOVDQU 0x20(SI), X2	

  0x447295		f30f6f5e30		MOVDQU 0x30(SI), X3	

  0x44729a		f30f6f641ec0		MOVDQU -0x40(SI)(BX*1), X4	

  0x4472a0		f30f6f6c1ed0		MOVDQU -0x30(SI)(BX*1), X5	

  0x4472a6		f30f6f741ee0		MOVDQU -0x20(SI)(BX*1), X6	

  0x4472ac		f30f6f7c1ef0		MOVDQU -0x10(SI)(BX*1), X7	

  0x4472b2		f30f7f07		MOVDQU X0, 0(DI)	

  0x4472b6		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x4472bb		f30f7f5720		MOVDQU X2, 0x20(DI)	

  0x4472c0		f30f7f5f30		MOVDQU X3, 0x30(DI)	

  0x4472c5		f30f7f641fc0		MOVDQU X4, -0x40(DI)(BX*1)	

  0x4472cb		f30f7f6c1fd0		MOVDQU X5, -0x30(DI)(BX*1)	

  0x4472d1		f30f7f741fe0		MOVDQU X6, -0x20(DI)(BX*1)	

  0x4472d7		f30f7f7c1ff0		MOVDQU X7, -0x10(DI)(BX*1)	

  0x4472dd		c3			RET			

  0x4472de		f30f6f06		MOVDQU 0(SI), X0	

  0x4472e2		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x4472e7		f30f6f5620		MOVDQU 0x20(SI), X2	

  0x4472ec		f30f6f5e30		MOVDQU 0x30(SI), X3	

  0x4472f1		f30f6f6640		MOVDQU 0x40(SI), X4	

  0x4472f6		f30f6f6e50		MOVDQU 0x50(SI), X5	

  0x4472fb		f30f6f7660		MOVDQU 0x60(SI), X6	

  0x447300		f30f6f7e70		MOVDQU 0x70(SI), X7	

  0x447305		f3440f6f441e80		MOVDQU -0x80(SI)(BX*1), X8	

  0x44730c		f3440f6f4c1e90		MOVDQU -0x70(SI)(BX*1), X9	

  0x447313		f3440f6f541ea0		MOVDQU -0x60(SI)(BX*1), X10	

  0x44731a		f3440f6f5c1eb0		MOVDQU -0x50(SI)(BX*1), X11	

  0x447321		f3440f6f641ec0		MOVDQU -0x40(SI)(BX*1), X12	

  0x447328		f3440f6f6c1ed0		MOVDQU -0x30(SI)(BX*1), X13	

  0x44732f		f3440f6f741ee0		MOVDQU -0x20(SI)(BX*1), X14	

  0x447336		f3440f6f7c1ef0		MOVDQU -0x10(SI)(BX*1), X15	

  0x44733d		f30f7f07		MOVDQU X0, 0(DI)	

  0x447341		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x447346		f30f7f5720		MOVDQU X2, 0x20(DI)	

  0x44734b		f30f7f5f30		MOVDQU X3, 0x30(DI)	

  0x447350		f30f7f6740		MOVDQU X4, 0x40(DI)	

  0x447355		f30f7f6f50		MOVDQU X5, 0x50(DI)	

  0x44735a		f30f7f7760		MOVDQU X6, 0x60(DI)	

  0x44735f		f30f7f7f70		MOVDQU X7, 0x70(DI)	

  0x447364		f3440f7f441f80		MOVDQU X8, -0x80(DI)(BX*1)	

  0x44736b		f3440f7f4c1f90		MOVDQU X9, -0x70(DI)(BX*1)	

  0x447372		f3440f7f541fa0		MOVDQU X10, -0x60(DI)(BX*1)	

  0x447379		f3440f7f5c1fb0		MOVDQU X11, -0x50(DI)(BX*1)	

  0x447380		f3440f7f641fc0		MOVDQU X12, -0x40(DI)(BX*1)	

  0x447387		f3440f7f6c1fd0		MOVDQU X13, -0x30(DI)(BX*1)	

  0x44738e		f3440f7f741fe0		MOVDQU X14, -0x20(DI)(BX*1)	

  0x447395		f3440f7f7c1ff0		MOVDQU X15, -0x10(DI)(BX*1)	

  0x44739c		c3			RET			

  0x44739d		4881eb00010000		SUBQ $0x100, BX		

  0x4473a4		f30f6f06		MOVDQU 0(SI), X0	

  0x4473a8		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x4473ad		f30f6f5620		MOVDQU 0x20(SI), X2	

  0x4473b2		f30f6f5e30		MOVDQU 0x30(SI), X3	

  0x4473b7		f30f6f6640		MOVDQU 0x40(SI), X4	

  0x4473bc		f30f6f6e50		MOVDQU 0x50(SI), X5	

  0x4473c1		f30f6f7660		MOVDQU 0x60(SI), X6	

  0x4473c6		f30f6f7e70		MOVDQU 0x70(SI), X7	

  0x4473cb		f3440f6f8680000000	MOVDQU 0x80(SI), X8	

  0x4473d4		f3440f6f8e90000000	MOVDQU 0x90(SI), X9	

  0x4473dd		f3440f6f96a0000000	MOVDQU 0xa0(SI), X10	

  0x4473e6		f3440f6f9eb0000000	MOVDQU 0xb0(SI), X11	

  0x4473ef		f3440f6fa6c0000000	MOVDQU 0xc0(SI), X12	

  0x4473f8		f3440f6faed0000000	MOVDQU 0xd0(SI), X13	

  0x447401		f3440f6fb6e0000000	MOVDQU 0xe0(SI), X14	

  0x44740a		f3440f6fbef0000000	MOVDQU 0xf0(SI), X15	

  0x447413		f30f7f07		MOVDQU X0, 0(DI)	

  0x447417		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x44741c		f30f7f5720		MOVDQU X2, 0x20(DI)	

  0x447421		f30f7f5f30		MOVDQU X3, 0x30(DI)	

  0x447426		f30f7f6740		MOVDQU X4, 0x40(DI)	

  0x44742b		f30f7f6f50		MOVDQU X5, 0x50(DI)	

  0x447430		f30f7f7760		MOVDQU X6, 0x60(DI)	

  0x447435		f30f7f7f70		MOVDQU X7, 0x70(DI)	

  0x44743a		f3440f7f8780000000	MOVDQU X8, 0x80(DI)	

  0x447443		f3440f7f8f90000000	MOVDQU X9, 0x90(DI)	

  0x44744c		f3440f7f97a0000000	MOVDQU X10, 0xa0(DI)	

  0x447455		f3440f7f9fb0000000	MOVDQU X11, 0xb0(DI)	

  0x44745e		f3440f7fa7c0000000	MOVDQU X12, 0xc0(DI)	

  0x447467		f3440f7fafd0000000	MOVDQU X13, 0xd0(DI)	

  0x447470		f3440f7fb7e0000000	MOVDQU X14, 0xe0(DI)	

  0x447479		f3440f7fbff0000000	MOVDQU X15, 0xf0(DI)	

  0x447482		4881fb00010000		CMPQ $0x100, BX		

  0x447489		488db600010000		LEAQ 0x100(SI), SI	

  0x447490		488dbf00010000		LEAQ 0x100(DI), DI	

  0x447497		0f8d00ffffff		JGE 0x44739d		

  0x44749d		e96dfcffff		JMP 0x44710f		

  0x4474a2		4889f9			MOVQ DI, CX		

  0x4474a5		4829f1			SUBQ SI, CX		

  0x4474a8		4839d9			CMPQ BX, CX		

  0x4474ab		0f82ac010000		JB 0x44765d		

  0x4474b1		4881fb00001000		CMPQ $0x100000, BX	

  0x4474b8		0f83c3000000		JAE 0x447581		

  0x4474be		488d0c1e		LEAQ 0(SI)(BX*1), CX	

  0x4474c2		4989fa			MOVQ DI, R10		

  0x4474c5		f30f6f6980		MOVDQU -0x80(CX), X5	

  0x4474ca		f30f6f7190		MOVDQU -0x70(CX), X6	

  0x4474cf		48c7c080000000		MOVQ $0x80, AX		

  0x4474d6		4883e7e0		ANDQ $-0x20, DI		

  0x4474da		4883c720		ADDQ $0x20, DI		

  0x4474de		f30f6f79a0		MOVDQU -0x60(CX), X7	

  0x4474e3		f3440f6f41b0		MOVDQU -0x50(CX), X8	

  0x4474e9		4989fb			MOVQ DI, R11		

  0x4474ec		4d29d3			SUBQ R10, R11		

  0x4474ef		f3440f6f49c0		MOVDQU -0x40(CX), X9	

  0x4474f5		f3440f6f51d0		MOVDQU -0x30(CX), X10	

  0x4474fb		4c29db			SUBQ R11, BX		

  0x4474fe		f3440f6f59e0		MOVDQU -0x20(CX), X11	

  0x447504		f3440f6f61f0		MOVDQU -0x10(CX), X12	

  0x44750a		c5fe6f26		VMOVDQU 0(SI), X4	

  0x44750e		4c01de			ADDQ R11, SI		

  0x447511		4829c3			SUBQ AX, BX		

  0x447514		c5fe6f06		VMOVDQU 0(SI), X0	

  0x447518		c5fe6f4e20		VMOVDQU 0x20(SI), X1	

  0x44751d		c5fe6f5640		VMOVDQU 0x40(SI), X2	

  0x447522		c5fe6f5e60		VMOVDQU 0x60(SI), X3	

  0x447527		4801c6			ADDQ AX, SI		

  0x44752a		c5fd7f07		VMOVDQA X0, 0(DI)	

  0x44752e		c5fd7f4f20		VMOVDQA X1, 0x20(DI)	

  0x447533		c5fd7f5740		VMOVDQA X2, 0x40(DI)	

  0x447538		c5fd7f5f60		VMOVDQA X3, 0x60(DI)	

  0x44753d		4801c7			ADDQ AX, DI		

  0x447540		4829c3			SUBQ AX, BX		

  0x447543		77cf			JA 0x447514		

  0x447545		4801c3			ADDQ AX, BX		

  0x447548		4801fb			ADDQ DI, BX		

  0x44754b		c4c17e7f22		VMOVDQU X4, 0(DX)	

  0x447550		c5f877			VZEROUPPER		

  0x447553		f30f7f6b80		MOVDQU X5, -0x80(BX)	

  0x447558		f30f7f7390		MOVDQU X6, -0x70(BX)	

  0x44755d		f30f7f7ba0		MOVDQU X7, -0x60(BX)	

  0x447562		f3440f7f43b0		MOVDQU X8, -0x50(BX)	

  0x447568		f3440f7f4bc0		MOVDQU X9, -0x40(BX)	

  0x44756e		f3440f7f53d0		MOVDQU X10, -0x30(BX)	

  0x447574		f3440f7f5be0		MOVDQU X11, -0x20(BX)	

  0x44757a		f3440f7f63f0		MOVDQU X12, -0x10(BX)	

  0x447580		c3			RET			

  0x447581		488d0c1e		LEAQ 0(SI)(BX*1), CX	

  0x447585		f30f6f6c1e80		MOVDQU -0x80(SI)(BX*1), X5	

  0x44758b		f30f6f7190		MOVDQU -0x70(CX), X6	

  0x447590		f30f6f79a0		MOVDQU -0x60(CX), X7	

  0x447595		f3440f6f41b0		MOVDQU -0x50(CX), X8	

  0x44759b		f3440f6f49c0		MOVDQU -0x40(CX), X9	

  0x4475a1		f3440f6f51d0		MOVDQU -0x30(CX), X10	

  0x4475a7		f3440f6f59e0		MOVDQU -0x20(CX), X11	

  0x4475ad		f3440f6f61f0		MOVDQU -0x10(CX), X12	

  0x4475b3		c5fe6f26		VMOVDQU 0(SI), X4	

  0x4475b7		4989f8			MOVQ DI, R8		

  0x4475ba		4883e7e0		ANDQ $-0x20, DI		

  0x4475be		4883c720		ADDQ $0x20, DI		

  0x4475c2		4989fa			MOVQ DI, R10		

  0x4475c5		4d29c2			SUBQ R8, R10		

  0x4475c8		4c29d3			SUBQ R10, BX		

  0x4475cb		4c01d6			ADDQ R10, SI		

  0x4475ce		488d0c1f		LEAQ 0(DI)(BX*1), CX	

  0x4475d2		4881eb80000000		SUBQ $0x80, BX		

  0x4475d9		0f1886c0010000		PREFETCHNTA 0x1c0(SI)	

  0x4475e0		0f188680020000		PREFETCHNTA 0x280(SI)	

  0x4475e7		c5fe6f06		VMOVDQU 0(SI), X0	

  0x4475eb		c5fe6f4e20		VMOVDQU 0x20(SI), X1	

  0x4475f0		c5fe6f5640		VMOVDQU 0x40(SI), X2	

  0x4475f5		c5fe6f5e60		VMOVDQU 0x60(SI), X3	

  0x4475fa		4881c680000000		ADDQ $0x80, SI		

  0x447601		c5fde707		VMOVNTDQ X0, 0(DI)	

  0x447605		c5fde74f20		VMOVNTDQ X1, 0x20(DI)	

  0x44760a		c5fde75740		VMOVNTDQ X2, 0x40(DI)	

  0x44760f		c5fde75f60		VMOVNTDQ X3, 0x60(DI)	

  0x447614		4881c780000000		ADDQ $0x80, DI		

  0x44761b		4881eb80000000		SUBQ $0x80, BX		

  0x447622		77b5			JA 0x4475d9		

  0x447624		0faef8			SFENCE			

  0x447627		c4c17e7f20		VMOVDQU X4, 0(AX)	

  0x44762c		c5f877			VZEROUPPER		

  0x44762f		f30f7f6980		MOVDQU X5, -0x80(CX)	

  0x447634		f30f7f7190		MOVDQU X6, -0x70(CX)	

  0x447639		f30f7f79a0		MOVDQU X7, -0x60(CX)	

  0x44763e		f3440f7f41b0		MOVDQU X8, -0x50(CX)	

  0x447644		f3440f7f49c0		MOVDQU X9, -0x40(CX)	

  0x44764a		f3440f7f51d0		MOVDQU X10, -0x30(CX)	

  0x447650		f3440f7f59e0		MOVDQU X11, -0x20(CX)	

  0x447656		f3440f7f61f0		MOVDQU X12, -0x10(CX)	

  0x44765c		c3			RET			

  0x44765d		4889f8			MOVQ DI, AX		

  0x447660		f30f6f2e		MOVDQU 0(SI), X5	

  0x447664		f30f6f7610		MOVDQU 0x10(SI), X6	

  0x447669		4801df			ADDQ BX, DI		

  0x44766c		f30f6f7e20		MOVDQU 0x20(SI), X7	

  0x447671		f3440f6f4630		MOVDQU 0x30(SI), X8	

  0x447677		4c8d57e0		LEAQ -0x20(DI), R10	

  0x44767b		4989fb			MOVQ DI, R11		

  0x44767e		f3440f6f4e40		MOVDQU 0x40(SI), X9	

  0x447684		f3440f6f5650		MOVDQU 0x50(SI), X10	

  0x44768a		4983e31f		ANDQ $0x1f, R11		

  0x44768e		f3440f6f5e60		MOVDQU 0x60(SI), X11	

  0x447694		f3440f6f6670		MOVDQU 0x70(SI), X12	

  0x44769a		4c31df			XORQ R11, DI		

  0x44769d		4801de			ADDQ BX, SI		

  0x4476a0		c5fe6f66e0		VMOVDQU -0x20(SI), X4	

  0x4476a5		4c29de			SUBQ R11, SI		

  0x4476a8		4c29db			SUBQ R11, BX		

  0x4476ab		4881fb00001000		CMPQ $0x100000, BX	

  0x4476b2		777b			JA 0x44772f		

  0x4476b4		4881eb80000000		SUBQ $0x80, BX		

  0x4476bb		c5fe6f46e0		VMOVDQU -0x20(SI), X0	

  0x4476c0		c5fe6f4ec0		VMOVDQU -0x40(SI), X1	

  0x4476c5		c5fe6f56a0		VMOVDQU -0x60(SI), X2	

  0x4476ca		c5fe6f5e80		VMOVDQU -0x80(SI), X3	

  0x4476cf		4881ee80000000		SUBQ $0x80, SI		

  0x4476d6		c5fd7f47e0		VMOVDQA X0, -0x20(DI)	

  0x4476db		c5fd7f4fc0		VMOVDQA X1, -0x40(DI)	

  0x4476e0		c5fd7f57a0		VMOVDQA X2, -0x60(DI)	

  0x4476e5		c5fd7f5f80		VMOVDQA X3, -0x80(DI)	

  0x4476ea		4881ef80000000		SUBQ $0x80, DI		

  0x4476f1		4881eb80000000		SUBQ $0x80, BX		

  0x4476f8		77c1			JA 0x4476bb		

  0x4476fa		c4c17e7f22		VMOVDQU X4, 0(DX)	

  0x4476ff		c5f877			VZEROUPPER		

  0x447702		f30f7f28		MOVDQU X5, 0(AX)	

  0x447706		f30f7f7010		MOVDQU X6, 0x10(AX)	

  0x44770b		f30f7f7820		MOVDQU X7, 0x20(AX)	

  0x447710		f3440f7f4030		MOVDQU X8, 0x30(AX)	

  0x447716		f3440f7f4840		MOVDQU X9, 0x40(AX)	

  0x44771c		f3440f7f5050		MOVDQU X10, 0x50(AX)	

  0x447722		f3440f7f5860		MOVDQU X11, 0x60(AX)	

  0x447728		f3440f7f6070		MOVDQU X12, 0x70(AX)	

  0x44772e		c3			RET			

  0x44772f		4881eb80000000		SUBQ $0x80, BX		

  0x447736		0f188640feffff		PREFETCHNTA 0xfffffe40(SI)	

  0x44773d		0f188680fdffff		PREFETCHNTA 0xfffffd80(SI)	

  0x447744		c5fe6f46e0		VMOVDQU -0x20(SI), X0	

  0x447749		c5fe6f4ec0		VMOVDQU -0x40(SI), X1	

  0x44774e		c5fe6f56a0		VMOVDQU -0x60(SI), X2	

  0x447753		c5fe6f5e80		VMOVDQU -0x80(SI), X3	

  0x447758		4881ee80000000		SUBQ $0x80, SI		

  0x44775f		c5fde747e0		VMOVNTDQ X0, -0x20(DI)	

  0x447764		c5fde74fc0		VMOVNTDQ X1, -0x40(DI)	

  0x447769		c5fde757a0		VMOVNTDQ X2, -0x60(DI)	

  0x44776e		c5fde75f80		VMOVNTDQ X3, -0x80(DI)	

  0x447773		4881ef80000000		SUBQ $0x80, DI		

  0x44777a		4881eb80000000		SUBQ $0x80, BX		

  0x447781		77b3			JA 0x447736		

  0x447783		0faef8			SFENCE			

  0x447786		c4c17e7f22		VMOVDQU X4, 0(DX)	

  0x44778b		c5f877			VZEROUPPER		

  0x44778e		f30f7f28		MOVDQU X5, 0(AX)	

  0x447792		f30f7f7010		MOVDQU X6, 0x10(AX)	

  0x447797		f30f7f7820		MOVDQU X7, 0x20(AX)	

  0x44779c		f3440f7f4030		MOVDQU X8, 0x30(AX)	

  0x4477a2		f3440f7f4840		MOVDQU X9, 0x40(AX)	

  0x4477a8		f3440f7f5050		MOVDQU X10, 0x50(AX)	

  0x4477ae		f3440f7f5860		MOVDQU X11, 0x60(AX)	

  0x4477b4		f3440f7f6070		MOVDQU X12, 0x70(AX)	

  0x4477ba		c3			RET			

TEXT _rt0_amd64_linux(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/rt0_linux_amd64.s

  0x4477c0		e93bc9ffff		JMP _rt0_amd64(SB)	

TEXT runtime.exit(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x4477d0		8b7c2408		MOVL 0x8(SP), DI	

  0x4477d4		b8e7000000		MOVL $0xe7, AX		

  0x4477d9		0f05			SYSCALL			

  0x4477db		c3			RET			

TEXT runtime.exitThread(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x4477e0		488b442408		MOVQ 0x8(SP), AX	

  0x4477e5		c70000000000		MOVL $0x0, 0(AX)	

  0x4477eb		bf00000000		MOVL $0x0, DI		

  0x4477f0		b83c000000		MOVL $0x3c, AX		

  0x4477f5		0f05			SYSCALL			

  0x4477f7		cd03			INT $0x3		

  0x4477f9		ebfe			JMP 0x4477f9		

TEXT runtime.open(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447800		bf9cffffff		MOVL $-0x64, DI		

  0x447805		488b742408		MOVQ 0x8(SP), SI	

  0x44780a		8b542410		MOVL 0x10(SP), DX	

  0x44780e		448b542414		MOVL 0x14(SP), R10	

  0x447813		b801010000		MOVL $0x101, AX		

  0x447818		0f05			SYSCALL			

  0x44781a		483d01f0ffff		CMPQ $-0xfff, AX	

  0x447820		7605			JBE 0x447827		

  0x447822		b8ffffffff		MOVL $-0x1, AX		

  0x447827		89442418		MOVL AX, 0x18(SP)	

  0x44782b		c3			RET			

TEXT runtime.closefd(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447830		8b7c2408		MOVL 0x8(SP), DI	

  0x447834		b803000000		MOVL $0x3, AX		

  0x447839		0f05			SYSCALL			

  0x44783b		483d01f0ffff		CMPQ $-0xfff, AX	

  0x447841		7605			JBE 0x447848		

  0x447843		b8ffffffff		MOVL $-0x1, AX		

  0x447848		89442410		MOVL AX, 0x10(SP)	

  0x44784c		c3			RET			

TEXT runtime.write(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447850		488b7c2408		MOVQ 0x8(SP), DI	

  0x447855		488b742410		MOVQ 0x10(SP), SI	

  0x44785a		8b542418		MOVL 0x18(SP), DX	

  0x44785e		b801000000		MOVL $0x1, AX		

  0x447863		0f05			SYSCALL			

  0x447865		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44786b		7605			JBE 0x447872		

  0x44786d		b8ffffffff		MOVL $-0x1, AX		

  0x447872		89442420		MOVL AX, 0x20(SP)	

  0x447876		c3			RET			

TEXT runtime.read(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447880		8b7c2408		MOVL 0x8(SP), DI	

  0x447884		488b742410		MOVQ 0x10(SP), SI	

  0x447889		8b542418		MOVL 0x18(SP), DX	

  0x44788d		b800000000		MOVL $0x0, AX		

  0x447892		0f05			SYSCALL			

  0x447894		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44789a		7605			JBE 0x4478a1		

  0x44789c		b8ffffffff		MOVL $-0x1, AX		

  0x4478a1		89442420		MOVL AX, 0x20(SP)	

  0x4478a5		c3			RET			

TEXT runtime.usleep(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x4478b0		4883ec18		SUBQ $0x18, SP		
  0x4478b4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4478b9		488d6c2410		LEAQ 0x10(SP), BP	

  0x4478be		ba00000000		MOVL $0x0, DX		

  0x4478c3		8b442420		MOVL 0x20(SP), AX	

  0x4478c7		b940420f00		MOVL $0xf4240, CX	

  0x4478cc		f7f1			DIVL CX			

  0x4478ce		48890424		MOVQ AX, 0(SP)		

  0x4478d2		b8e8030000		MOVL $0x3e8, AX		

  0x4478d7		f7e2			MULL DX			

  0x4478d9		4889442408		MOVQ AX, 0x8(SP)	

  0x4478de		bf00000000		MOVL $0x0, DI		

  0x4478e3		be00000000		MOVL $0x0, SI		

  0x4478e8		ba00000000		MOVL $0x0, DX		

  0x4478ed		41ba00000000		MOVL $0x0, R10		

  0x4478f3		4989e0			MOVQ SP, R8		

  0x4478f6		41b900000000		MOVL $0x0, R9		

  0x4478fc		b80e010000		MOVL $0x10e, AX		

  0x447901		0f05			SYSCALL			

  0x447903		488b6c2410		MOVQ 0x10(SP), BP	
  0x447908		4883c418		ADDQ $0x18, SP		
  0x44790c		c3			RET			

TEXT runtime.gettid(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447910		b8ba000000		MOVL $0xba, AX		

  0x447915		0f05			SYSCALL			

  0x447917		89442408		MOVL AX, 0x8(SP)	

  0x44791b		c3			RET			

TEXT runtime.raise(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447920		b8ba000000		MOVL $0xba, AX		

  0x447925		0f05			SYSCALL			

  0x447927		89c7			MOVL AX, DI		

  0x447929		8b742408		MOVL 0x8(SP), SI	

  0x44792d		b8c8000000		MOVL $0xc8, AX		

  0x447932		0f05			SYSCALL			

  0x447934		c3			RET			

TEXT runtime.raiseproc(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447940		b827000000		MOVL $0x27, AX		

  0x447945		0f05			SYSCALL			

  0x447947		89c7			MOVL AX, DI		

  0x447949		8b742408		MOVL 0x8(SP), SI	

  0x44794d		b83e000000		MOVL $0x3e, AX		

  0x447952		0f05			SYSCALL			

  0x447954		c3			RET			

TEXT runtime.setitimer(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447960		8b7c2408		MOVL 0x8(SP), DI	

  0x447964		488b742410		MOVQ 0x10(SP), SI	

  0x447969		488b542418		MOVQ 0x18(SP), DX	

  0x44796e		b826000000		MOVL $0x26, AX		

  0x447973		0f05			SYSCALL			

  0x447975		c3			RET			

TEXT runtime.mincore(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447980		488b7c2408		MOVQ 0x8(SP), DI	

  0x447985		488b742410		MOVQ 0x10(SP), SI	

  0x44798a		488b542418		MOVQ 0x18(SP), DX	

  0x44798f		b81b000000		MOVL $0x1b, AX		

  0x447994		0f05			SYSCALL			

  0x447996		89442420		MOVL AX, 0x20(SP)	

  0x44799a		c3			RET			

TEXT runtime.walltime(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x4479a0		4889e5			MOVQ SP, BP		

  0x4479a3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x4479ac		488b4830		MOVQ 0x30(AX), CX	

  0x4479b0		488b91c0000000		MOVQ 0xc0(CX), DX	

  0x4479b7		4839d0			CMPQ DX, AX		

  0x4479ba		7507			JNE 0x4479c3		

  0x4479bc		488b11			MOVQ 0(CX), DX		

  0x4479bf		488b6238		MOVQ 0x38(DX), SP	

  0x4479c3		4883ec10		SUBQ $0x10, SP		

  0x4479c7		4883e4f0		ANDQ $-0x10, SP		

  0x4479cb		488b0536bf0700		MOVQ runtime.__vdso_clock_gettime_sym(SB), AX	

  0x4479d2		4883f800		CMPQ $0x0, AX		

  0x4479d6		7421			JE 0x4479f9		

  0x4479d8		bf00000000		MOVL $0x0, DI		

  0x4479dd		488d3424		LEAQ 0(SP), SI		

  0x4479e1		ffd0			CALL AX			

  0x4479e3		488b0424		MOVQ 0(SP), AX		

  0x4479e7		488b542408		MOVQ 0x8(SP), DX	

  0x4479ec		4889ec			MOVQ BP, SP		

  0x4479ef		4889442408		MOVQ AX, 0x8(SP)	

  0x4479f4		89542410		MOVL DX, 0x10(SP)	

  0x4479f8		c3			RET			

  0x4479f9		488d3c24		LEAQ 0(SP), DI		

  0x4479fd		48c7c600000000		MOVQ $0x0, SI		

  0x447a04		488b0515d60500		MOVQ runtime.__vdso_gettimeofday_sym(SB), AX	

  0x447a0b		ffd0			CALL AX			

  0x447a0d		488b0424		MOVQ 0(SP), AX		

  0x447a11		8b542408		MOVL 0x8(SP), DX	

  0x447a15		4869d2e8030000		IMULQ $0x3e8, DX, DX	

  0x447a1c		4889ec			MOVQ BP, SP		

  0x447a1f		4889442408		MOVQ AX, 0x8(SP)	

  0x447a24		89542410		MOVL DX, 0x10(SP)	

  0x447a28		c3			RET			

TEXT runtime.nanotime(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447a30		4889e5			MOVQ SP, BP		

  0x447a33		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x447a3c		488b4830		MOVQ 0x30(AX), CX	

  0x447a40		488b91c0000000		MOVQ 0xc0(CX), DX	

  0x447a47		4839d0			CMPQ DX, AX		

  0x447a4a		7507			JNE 0x447a53		

  0x447a4c		488b11			MOVQ 0(CX), DX		

  0x447a4f		488b6238		MOVQ 0x38(DX), SP	

  0x447a53		4883ec10		SUBQ $0x10, SP		

  0x447a57		4883e4f0		ANDQ $-0x10, SP		

  0x447a5b		488b05a6be0700		MOVQ runtime.__vdso_clock_gettime_sym(SB), AX	

  0x447a62		4883f800		CMPQ $0x0, AX		

  0x447a66		7427			JE 0x447a8f		

  0x447a68		bf01000000		MOVL $0x1, DI		

  0x447a6d		488d3424		LEAQ 0(SP), SI		

  0x447a71		ffd0			CALL AX			

  0x447a73		488b0424		MOVQ 0(SP), AX		

  0x447a77		488b542408		MOVQ 0x8(SP), DX	

  0x447a7c		4889ec			MOVQ BP, SP		

  0x447a7f		4869c000ca9a3b		IMULQ $0x3b9aca00, AX, AX	

  0x447a86		4801d0			ADDQ DX, AX		

  0x447a89		4889442408		MOVQ AX, 0x8(SP)	

  0x447a8e		c3			RET			

  0x447a8f		488d3c24		LEAQ 0(SP), DI		

  0x447a93		48c7c600000000		MOVQ $0x0, SI		

  0x447a9a		488b057fd50500		MOVQ runtime.__vdso_gettimeofday_sym(SB), AX	

  0x447aa1		ffd0			CALL AX			

  0x447aa3		488b0424		MOVQ 0(SP), AX		

  0x447aa7		8b542408		MOVL 0x8(SP), DX	

  0x447aab		4889ec			MOVQ BP, SP		

  0x447aae		4869d2e8030000		IMULQ $0x3e8, DX, DX	

  0x447ab5		4869c000ca9a3b		IMULQ $0x3b9aca00, AX, AX	

  0x447abc		4801d0			ADDQ DX, AX		

  0x447abf		4889442408		MOVQ AX, 0x8(SP)	

  0x447ac4		c3			RET			

TEXT runtime.rtsigprocmask(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447ad0		8b7c2408		MOVL 0x8(SP), DI	

  0x447ad4		488b742410		MOVQ 0x10(SP), SI	

  0x447ad9		488b542418		MOVQ 0x18(SP), DX	

  0x447ade		448b542420		MOVL 0x20(SP), R10	

  0x447ae3		b80e000000		MOVL $0xe, AX		

  0x447ae8		0f05			SYSCALL			

  0x447aea		483d01f0ffff		CMPQ $-0xfff, AX	

  0x447af0		760b			JBE 0x447afd		

  0x447af2		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x447afd		c3			RET			

TEXT runtime.sysSigaction(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447b00		488b7c2408		MOVQ 0x8(SP), DI	

  0x447b05		488b742410		MOVQ 0x10(SP), SI	

  0x447b0a		488b542418		MOVQ 0x18(SP), DX	

  0x447b0f		4c8b542420		MOVQ 0x20(SP), R10	

  0x447b14		b80d000000		MOVL $0xd, AX		

  0x447b19		0f05			SYSCALL			

  0x447b1b		89442428		MOVL AX, 0x28(SP)	

  0x447b1f		c3			RET			

TEXT runtime.callCgoSigaction(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447b20		4883ec18		SUBQ $0x18, SP		
  0x447b24		48896c2410		MOVQ BP, 0x10(SP)	
  0x447b29		488d6c2410		LEAQ 0x10(SP), BP	

  0x447b2e		488b7c2420		MOVQ 0x20(SP), DI	

  0x447b33		488b742428		MOVQ 0x28(SP), SI	

  0x447b38		488b542430		MOVQ 0x30(SP), DX	

  0x447b3d		488b05a4fa0500		MOVQ _cgo_sigaction(SB), AX	

  0x447b44		4889e3			MOVQ SP, BX		

  0x447b47		4883e4f0		ANDQ $-0x10, SP		

  0x447b4b		ffd0			CALL AX			

  0x447b4d		4889dc			MOVQ BX, SP		

  0x447b50		89442438		MOVL AX, 0x38(SP)	

  0x447b54		488b6c2410		MOVQ 0x10(SP), BP	
  0x447b59		4883c418		ADDQ $0x18, SP		
  0x447b5d		c3			RET			

TEXT runtime.sigfwd(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447b60		488b442408		MOVQ 0x8(SP), AX	

  0x447b65		8b7c2410		MOVL 0x10(SP), DI	

  0x447b69		488b742418		MOVQ 0x18(SP), SI	

  0x447b6e		488b542420		MOVQ 0x20(SP), DX	

  0x447b73		55			PUSHL BP		

  0x447b74		4889e5			MOVQ SP, BP		

  0x447b77		4883e4f0		ANDQ $-0x10, SP		

  0x447b7b		ffd0			CALL AX			

  0x447b7d		4889ec			MOVQ BP, SP		

  0x447b80		5d			POPL BP			

  0x447b81		c3			RET			

TEXT runtime.sigtramp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447b90		4883ec50		SUBQ $0x50, SP		
  0x447b94		48896c2448		MOVQ BP, 0x48(SP)	
  0x447b99		488d6c2448		LEAQ 0x48(SP), BP	

  0x447b9e		48895c2440		MOVQ BX, 0x40(SP)	

  0x447ba3		48896c2438		MOVQ BP, 0x38(SP)	

  0x447ba8		4c89642430		MOVQ R12, 0x30(SP)	

  0x447bad		4c896c2428		MOVQ R13, 0x28(SP)	

  0x447bb2		4c89742420		MOVQ R14, 0x20(SP)	

  0x447bb7		4c897c2418		MOVQ R15, 0x18(SP)	

  0x447bbc		4889542410		MOVQ DX, 0x10(SP)	

  0x447bc1		4889742408		MOVQ SI, 0x8(SP)	

  0x447bc6		48893c24		MOVQ DI, 0(SP)		

  0x447bca		488d058fa7feff		LEAQ 0xfffea78f(IP), AX	

  0x447bd1		ffd0			CALL AX			

  0x447bd3		4c8b7c2418		MOVQ 0x18(SP), R15	

  0x447bd8		4c8b742420		MOVQ 0x20(SP), R14	

  0x447bdd		4c8b6c2428		MOVQ 0x28(SP), R13	

  0x447be2		4c8b642430		MOVQ 0x30(SP), R12	

  0x447be7		488b6c2438		MOVQ 0x38(SP), BP	

  0x447bec		488b5c2440		MOVQ 0x40(SP), BX	

  0x447bf1		488b6c2448		MOVQ 0x48(SP), BP	
  0x447bf6		4883c450		ADDQ $0x50, SP		
  0x447bfa		c3			RET			

TEXT runtime.cgoSigtramp(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447c00		488b0539fa0500		MOVQ runtime.cgoTraceback(SB), AX	

  0x447c07		4885c0			TESTQ AX, AX		

  0x447c0a		746f			JE 0x447c7b		

  0x447c0c		488b05adf90500		MOVQ _cgo_callers(SB), AX	

  0x447c13		4885c0			TESTQ AX, AX		

  0x447c16		7463			JE 0x447c7b		

  0x447c18		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x447c21		4885c0			TESTQ AX, AX		

  0x447c24		745a			JE 0x447c80		

  0x447c26		488b4030		MOVQ 0x30(AX), AX	

  0x447c2a		4885c0			TESTQ AX, AX		

  0x447c2d		744c			JE 0x447c7b		

  0x447c2f		8b8838010000		MOVL 0x138(AX), CX	

  0x447c35		85c9			TESTL CX, CX		

  0x447c37		7442			JE 0x447c7b		

  0x447c39		488b88c0000000		MOVQ 0xc0(AX), CX	

  0x447c40		4885c9			TESTQ CX, CX		

  0x447c43		7436			JE 0x447c7b		

  0x447c45		488b4970		MOVQ 0x70(CX), CX	

  0x447c49		4885c9			TESTQ CX, CX		

  0x447c4c		742d			JE 0x447c7b		

  0x447c4e		4c8b8040010000		MOVQ 0x140(AX), R8	

  0x447c55		4d85c0			TESTQ R8, R8		

  0x447c58		7421			JE 0x447c7b		

  0x447c5a		8b883c010000		MOVL 0x13c(AX), CX	

  0x447c60		85c9			TESTL CX, CX		

  0x447c62		7517			JNE 0x447c7b		

  0x447c64		488b0dd5f90500		MOVQ runtime.cgoTraceback(SB), CX	

  0x447c6b		4c8d0d1effffff		LEAQ 0xffffff1e(IP), R9	

  0x447c72		488b0547f90500		MOVQ _cgo_callers(SB), AX	

  0x447c79		ffe0			JMP AX			

  0x447c7b		e910ffffff		JMP runtime.sigtramp(SB)	

  0x447c80		83ff1b			CMPL $0x1b, DI		

  0x447c83		75f6			JNE 0x447c7b		

  0x447c85		b800000000		MOVL $0x0, AX		

  0x447c8a		b901000000		MOVL $0x1, CX		

  0x447c8f		4c8d1d6abc0700		LEAQ runtime.sigprofCallersUse(SB), R11	

  0x447c96		f0410fb10b		LOCK CMPXCHGL CX, 0(R11)	

  0x447c9b		75de			JNE 0x447c7b		

  0x447c9d		488b0d9cf90500		MOVQ runtime.cgoTraceback(SB), CX	

  0x447ca4		4c8d0515c00700		LEAQ runtime.sigprofCallers(SB), R8	

  0x447cab		4c8d0d1e37feff		LEAQ 0xfffe371e(IP), R9	

  0x447cb2		488b0507f90500		MOVQ _cgo_callers(SB), AX	

  0x447cb9		ffe0			JMP AX			

TEXT runtime.sigreturn(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447cc0		48c7c00f000000		MOVQ $0xf, AX		

  0x447cc7		0f05			SYSCALL			

  0x447cc9		cd03			INT $0x3		

TEXT runtime.sysMmap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447cd0		488b7c2408		MOVQ 0x8(SP), DI	

  0x447cd5		488b742410		MOVQ 0x10(SP), SI	

  0x447cda		8b542418		MOVL 0x18(SP), DX	

  0x447cde		448b54241c		MOVL 0x1c(SP), R10	

  0x447ce3		448b442420		MOVL 0x20(SP), R8	

  0x447ce8		448b4c2424		MOVL 0x24(SP), R9	

  0x447ced		b809000000		MOVL $0x9, AX		

  0x447cf2		0f05			SYSCALL			

  0x447cf4		483d01f0ffff		CMPQ $-0xfff, AX	

  0x447cfa		7615			JBE 0x447d11		

  0x447cfc		48f7d0			NOTQ AX			

  0x447cff		48ffc0			INCQ AX			

  0x447d02		48c744242800000000	MOVQ $0x0, 0x28(SP)	

  0x447d0b		4889442430		MOVQ AX, 0x30(SP)	

  0x447d10		c3			RET			

  0x447d11		4889442428		MOVQ AX, 0x28(SP)	

  0x447d16		48c744243000000000	MOVQ $0x0, 0x30(SP)	

  0x447d1f		c3			RET			

TEXT runtime.callCgoMmap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447d20		4883ec18		SUBQ $0x18, SP		
  0x447d24		48896c2410		MOVQ BP, 0x10(SP)	
  0x447d29		488d6c2410		LEAQ 0x10(SP), BP	

  0x447d2e		488b7c2420		MOVQ 0x20(SP), DI	

  0x447d33		488b742428		MOVQ 0x28(SP), SI	

  0x447d38		8b542430		MOVL 0x30(SP), DX	

  0x447d3c		8b4c2434		MOVL 0x34(SP), CX	

  0x447d40		448b442438		MOVL 0x38(SP), R8	

  0x447d45		448b4c243c		MOVL 0x3c(SP), R9	

  0x447d4a		488b057ff80500		MOVQ _cgo_mmap(SB), AX	

  0x447d51		4889e3			MOVQ SP, BX		

  0x447d54		4883e4f0		ANDQ $-0x10, SP		

  0x447d58		48891c24		MOVQ BX, 0(SP)		

  0x447d5c		ffd0			CALL AX			

  0x447d5e		488b2424		MOVQ 0(SP), SP		

  0x447d62		4889442440		MOVQ AX, 0x40(SP)	

  0x447d67		488b6c2410		MOVQ 0x10(SP), BP	
  0x447d6c		4883c418		ADDQ $0x18, SP		
  0x447d70		c3			RET			

TEXT runtime.sysMunmap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447d80		488b7c2408		MOVQ 0x8(SP), DI	

  0x447d85		488b742410		MOVQ 0x10(SP), SI	

  0x447d8a		48c7c00b000000		MOVQ $0xb, AX		

  0x447d91		0f05			SYSCALL			

  0x447d93		483d01f0ffff		CMPQ $-0xfff, AX	

  0x447d99		760b			JBE 0x447da6		

  0x447d9b		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x447da6		c3			RET			

TEXT runtime.callCgoMunmap(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447db0		4883ec18		SUBQ $0x18, SP		
  0x447db4		48896c2410		MOVQ BP, 0x10(SP)	
  0x447db9		488d6c2410		LEAQ 0x10(SP), BP	

  0x447dbe		488b7c2420		MOVQ 0x20(SP), DI	

  0x447dc3		488b742428		MOVQ 0x28(SP), SI	

  0x447dc8		488b0509f80500		MOVQ _cgo_munmap(SB), AX	

  0x447dcf		4889e3			MOVQ SP, BX		

  0x447dd2		4883e4f0		ANDQ $-0x10, SP		

  0x447dd6		48891c24		MOVQ BX, 0(SP)		

  0x447dda		ffd0			CALL AX			

  0x447ddc		488b2424		MOVQ 0(SP), SP		

  0x447de0		488b6c2410		MOVQ 0x10(SP), BP	
  0x447de5		4883c418		ADDQ $0x18, SP		
  0x447de9		c3			RET			

TEXT runtime.madvise(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447df0		488b7c2408		MOVQ 0x8(SP), DI	

  0x447df5		488b742410		MOVQ 0x10(SP), SI	

  0x447dfa		8b542418		MOVL 0x18(SP), DX	

  0x447dfe		48c7c01c000000		MOVQ $0x1c, AX		

  0x447e05		0f05			SYSCALL			

  0x447e07		c3			RET			

TEXT runtime.futex(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447e10		488b7c2408		MOVQ 0x8(SP), DI	

  0x447e15		8b742410		MOVL 0x10(SP), SI	

  0x447e19		8b542414		MOVL 0x14(SP), DX	

  0x447e1d		4c8b542418		MOVQ 0x18(SP), R10	

  0x447e22		4c8b442420		MOVQ 0x20(SP), R8	

  0x447e27		448b4c2428		MOVL 0x28(SP), R9	

  0x447e2c		b8ca000000		MOVL $0xca, AX		

  0x447e31		0f05			SYSCALL			

  0x447e33		89442430		MOVL AX, 0x30(SP)	

  0x447e37		c3			RET			

TEXT runtime.clone(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447e40		8b7c2408		MOVL 0x8(SP), DI	

  0x447e44		488b742410		MOVQ 0x10(SP), SI	

  0x447e49		48c7c200000000		MOVQ $0x0, DX		

  0x447e50		49c7c200000000		MOVQ $0x0, R10		

  0x447e57		4c8b442418		MOVQ 0x18(SP), R8	

  0x447e5c		4c8b4c2420		MOVQ 0x20(SP), R9	

  0x447e61		4c8b642428		MOVQ 0x28(SP), R12	

  0x447e66		b838000000		MOVL $0x38, AX		

  0x447e6b		0f05			SYSCALL			

  0x447e6d		4883f800		CMPQ $0x0, AX		

  0x447e71		7405			JE 0x447e78		

  0x447e73		89442430		MOVL AX, 0x30(SP)	

  0x447e77		c3			RET			

  0x447e78		4889f4			MOVQ SI, SP		

  0x447e7b		4983f800		CMPQ $0x0, R8		

  0x447e7f		742f			JE 0x447eb0		

  0x447e81		4983f900		CMPQ $0x0, R9		

  0x447e85		7429			JE 0x447eb0		

  0x447e87		b8ba000000		MOVL $0xba, AX		

  0x447e8c		0f05			SYSCALL			

  0x447e8e		49894048		MOVQ AX, 0x48(R8)	

  0x447e92		498db888000000		LEAQ 0x88(R8), DI	

  0x447e99		e862000000		CALL runtime.settls(SB)	

  0x447e9e		4d894130		MOVQ R8, 0x30(R9)	

  0x447ea2		644c890c25f8ffffff	MOVQ R9, FS:0xfffffff8	

  0x447eab		e820deffff		CALL runtime.stackcheck(SB)	

  0x447eb0		41ffd4			CALL R12		

  0x447eb3		bf6f000000		MOVL $0x6f, DI		

  0x447eb8		b83c000000		MOVL $0x3c, AX		

  0x447ebd		0f05			SYSCALL			

  0x447ebf		ebf2			JMP 0x447eb3		

TEXT runtime.sigaltstack(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447ed0		488b7c2408		MOVQ 0x8(SP), DI	

  0x447ed5		488b742410		MOVQ 0x10(SP), SI	

  0x447eda		48c7c083000000		MOVQ $0x83, AX		

  0x447ee1		0f05			SYSCALL			

  0x447ee3		483d01f0ffff		CMPQ $-0xfff, AX	

  0x447ee9		760b			JBE 0x447ef6		

  0x447eeb		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x447ef6		c3			RET			

TEXT runtime.settls(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447f00		4883ec28		SUBQ $0x28, SP		
  0x447f04		48896c2420		MOVQ BP, 0x20(SP)	
  0x447f09		488d6c2420		LEAQ 0x20(SP), BP	

  0x447f0e		4883c708		ADDQ $0x8, DI		

  0x447f12		4889fe			MOVQ DI, SI		

  0x447f15		48c7c702100000		MOVQ $0x1002, DI	

  0x447f1c		48c7c09e000000		MOVQ $0x9e, AX		

  0x447f23		0f05			SYSCALL			

  0x447f25		483d01f0ffff		CMPQ $-0xfff, AX	

  0x447f2b		760b			JBE 0x447f38		

  0x447f2d		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x447f38		488b6c2420		MOVQ 0x20(SP), BP	
  0x447f3d		4883c428		ADDQ $0x28, SP		
  0x447f41		c3			RET			

TEXT runtime.osyield(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447f50		b818000000		MOVL $0x18, AX		

  0x447f55		0f05			SYSCALL			

  0x447f57		c3			RET			

TEXT runtime.sched_getaffinity(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447f60		488b7c2408		MOVQ 0x8(SP), DI	

  0x447f65		488b742410		MOVQ 0x10(SP), SI	

  0x447f6a		488b542418		MOVQ 0x18(SP), DX	

  0x447f6f		b8cc000000		MOVL $0xcc, AX		

  0x447f74		0f05			SYSCALL			

  0x447f76		89442420		MOVL AX, 0x20(SP)	

  0x447f7a		c3			RET			

TEXT runtime.epollwait(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447f80		8b7c2408		MOVL 0x8(SP), DI	

  0x447f84		488b742410		MOVQ 0x10(SP), SI	

  0x447f89		8b542418		MOVL 0x18(SP), DX	

  0x447f8d		448b54241c		MOVL 0x1c(SP), R10	

  0x447f92		49c7c000000000		MOVQ $0x0, R8		

  0x447f99		b819010000		MOVL $0x119, AX		

  0x447f9e		0f05			SYSCALL			

  0x447fa0		89442420		MOVL AX, 0x20(SP)	

  0x447fa4		c3			RET			

TEXT runtime.sbrk0(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/sys_linux_amd64.s

  0x447fb0		48c7c700000000		MOVQ $0x0, DI		

  0x447fb7		b80c000000		MOVL $0xc, AX		

  0x447fbc		0f05			SYSCALL			

  0x447fbe		4889442408		MOVQ AX, 0x8(SP)	

  0x447fc3		c3			RET			

TEXT runtime.(*itabTableType).(runtime.add)-fm(SB) /Users/lijiao/Work-Finup/Bin/go1.10.3/go/src/runtime/iface.go
		iterate_itabs(t2.add)
  0x447fd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX					
  0x447fd9		483b6110		CMPQ 0x10(CX), SP					
  0x447fdd		762f			JBE 0x44800e						
  0x447fdf		4883ec18		SUBQ $0x18, SP						
  0x447fe3		48896c2410		MOVQ BP, 0x10(SP)					
  0x447fe8		488d6c2410		LEAQ 0x10(SP), BP					
  0x447fed		488b4208		MOVQ 0x8(DX), AX					
  0x447ff1		48890424		MOVQ AX, 0(SP)						
  0x447ff5		488b442420		MOVQ 0x20(SP), AX					
  0x447ffa		4889442408		MOVQ AX, 0x8(SP)					
  0x447fff		e80c0afcff		CALL runtime.(*itabTableType).add(SB)			
  0x448004		488b6c2410		MOVQ 0x10(SP), BP					
  0x448009		4883c418		ADDQ $0x18, SP						
  0x44800d		c3			RET							
  0x44800e		e8bdc4ffff		CALL runtime.morestack(SB)				
  0x448013		ebbb			JMP runtime.(*itabTableType).(runtime.add)-fm(SB)	

TEXT type..hash.runtime.uncommontype(SB) <autogenerated>

  0x448020		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448029		483b6110		CMPQ 0x10(CX), SP			
  0x44802d		7668			JBE 0x448097				
  0x44802f		4883ec28		SUBQ $0x28, SP				
  0x448033		48896c2420		MOVQ BP, 0x20(SP)			
  0x448038		488d6c2420		LEAQ 0x20(SP), BP			
  0x44803d		488b442430		MOVQ 0x30(SP), AX			
  0x448042		48890424		MOVQ AX, 0(SP)				
  0x448046		488b4c2438		MOVQ 0x38(SP), CX			
  0x44804b		48894c2408		MOVQ CX, 0x8(SP)			
  0x448050		48c744241006000000	MOVQ $0x6, 0x10(SP)			
  0x448059		e8b2dafbff		CALL runtime.memhash(SB)		
  0x44805e		488b442418		MOVQ 0x18(SP), AX			
  0x448063		488b4c2430		MOVQ 0x30(SP), CX			
  0x448068		4883c108		ADDQ $0x8, CX				
  0x44806c		48890c24		MOVQ CX, 0(SP)				
  0x448070		4889442408		MOVQ AX, 0x8(SP)			
  0x448075		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x44807e		e88ddafbff		CALL runtime.memhash(SB)		
  0x448083		488b442418		MOVQ 0x18(SP), AX			
  0x448088		4889442440		MOVQ AX, 0x40(SP)			
  0x44808d		488b6c2420		MOVQ 0x20(SP), BP			
  0x448092		4883c428		ADDQ $0x28, SP				
  0x448096		c3			RET					
  0x448097		e8d4c4ffff		CALL runtime.morestack_noctxt(SB)	
  0x44809c		eb82			JMP type..hash.runtime.uncommontype(SB)	

TEXT type..eq.runtime.uncommontype(SB) <autogenerated>

  0x4480a0		488b442408		MOVQ 0x8(SP), AX	
  0x4480a5		8b08			MOVL 0(AX), CX		
  0x4480a7		488b542410		MOVQ 0x10(SP), DX	
  0x4480ac		8b1a			MOVL 0(DX), BX		
  0x4480ae		39d9			CMPL BX, CX		
  0x4480b0		7521			JNE 0x4480d3		
  0x4480b2		0fb74804		MOVZX 0x4(AX), CX	
  0x4480b6		0fb75a04		MOVZX 0x4(DX), BX	
  0x4480ba		6639d9			CMPW BX, CX		
  0x4480bd		7510			JNE 0x4480cf		
  0x4480bf		8b4008			MOVL 0x8(AX), AX	
  0x4480c2		8b4a08			MOVL 0x8(DX), CX	
  0x4480c5		39c8			CMPL CX, AX		
  0x4480c7		0f94c0			SETE AL			
  0x4480ca		88442418		MOVB AL, 0x18(SP)	
  0x4480ce		c3			RET			
  0x4480cf		31c0			XORL AX, AX		
  0x4480d1		ebf7			JMP 0x4480ca		
  0x4480d3		31c0			XORL AX, AX		
  0x4480d5		ebf3			JMP 0x4480ca		

TEXT type..hash.runtime.itab(SB) <autogenerated>

  0x4480e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4480e9		483b6110		CMPQ 0x10(CX), SP			
  0x4480ed		7668			JBE 0x448157				
  0x4480ef		4883ec28		SUBQ $0x28, SP				
  0x4480f3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4480f8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4480fd		488b442430		MOVQ 0x30(SP), AX			
  0x448102		48890424		MOVQ AX, 0(SP)				
  0x448106		488b4c2438		MOVQ 0x38(SP), CX			
  0x44810b		48894c2408		MOVQ CX, 0x8(SP)			
  0x448110		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x448119		e8f2d9fbff		CALL runtime.memhash(SB)		
  0x44811e		488b442418		MOVQ 0x18(SP), AX			
  0x448123		488b4c2430		MOVQ 0x30(SP), CX			
  0x448128		4883c118		ADDQ $0x18, CX				
  0x44812c		48890c24		MOVQ CX, 0(SP)				
  0x448130		4889442408		MOVQ AX, 0x8(SP)			
  0x448135		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44813e		e8cdd9fbff		CALL runtime.memhash(SB)		
  0x448143		488b442418		MOVQ 0x18(SP), AX			
  0x448148		4889442440		MOVQ AX, 0x40(SP)			
  0x44814d		488b6c2420		MOVQ 0x20(SP), BP			
  0x448152		4883c428		ADDQ $0x28, SP				
  0x448156		c3			RET					
  0x448157		e814c4ffff		CALL runtime.morestack_noctxt(SB)	
  0x44815c		eb82			JMP type..hash.runtime.itab(SB)		

TEXT type..eq.runtime.itab(SB) <autogenerated>

  0x448160		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448169		483b6110		CMPQ 0x10(CX), SP			
  0x44816d		7662			JBE 0x4481d1				
  0x44816f		4883ec28		SUBQ $0x28, SP				
  0x448173		48896c2420		MOVQ BP, 0x20(SP)			
  0x448178		488d6c2420		LEAQ 0x20(SP), BP			
  0x44817d		488b442438		MOVQ 0x38(SP), AX			
  0x448182		4889442408		MOVQ AX, 0x8(SP)			
  0x448187		488b4c2430		MOVQ 0x30(SP), CX			
  0x44818c		48890c24		MOVQ CX, 0(SP)				
  0x448190		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x448199		e8a2e1ffff		CALL runtime.memequal(SB)		
  0x44819e		0fb6442418		MOVZX 0x18(SP), AX			
  0x4481a3		84c0			TESTL AL, AL				
  0x4481a5		7426			JE 0x4481cd				
  0x4481a7		488b442438		MOVQ 0x38(SP), AX			
  0x4481ac		488b4018		MOVQ 0x18(AX), AX			
  0x4481b0		488b4c2430		MOVQ 0x30(SP), CX			
  0x4481b5		488b4918		MOVQ 0x18(CX), CX			
  0x4481b9		4839c1			CMPQ AX, CX				
  0x4481bc		0f94c0			SETE AL					
  0x4481bf		88442440		MOVB AL, 0x40(SP)			
  0x4481c3		488b6c2420		MOVQ 0x20(SP), BP			
  0x4481c8		4883c428		ADDQ $0x28, SP				
  0x4481cc		c3			RET					
  0x4481cd		31c0			XORL AX, AX				
  0x4481cf		ebee			JMP 0x4481bf				
  0x4481d1		e89ac3ffff		CALL runtime.morestack_noctxt(SB)	
  0x4481d6		eb88			JMP type..eq.runtime.itab(SB)		

TEXT type..hash.runtime.modulehash(SB) <autogenerated>

  0x4481e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4481e9		483b6110		CMPQ 0x10(CX), SP			
  0x4481ed		767b			JBE 0x44826a				
  0x4481ef		4883ec28		SUBQ $0x28, SP				
  0x4481f3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4481f8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4481fd		488b442430		MOVQ 0x30(SP), AX			
  0x448202		48890424		MOVQ AX, 0(SP)				
  0x448206		488b4c2438		MOVQ 0x38(SP), CX			
  0x44820b		48894c2408		MOVQ CX, 0x8(SP)			
  0x448210		e86b8ffbff		CALL runtime.strhash(SB)		
  0x448215		488b442410		MOVQ 0x10(SP), AX			
  0x44821a		488b4c2430		MOVQ 0x30(SP), CX			
  0x44821f		488d5110		LEAQ 0x10(CX), DX			
  0x448223		48891424		MOVQ DX, 0(SP)				
  0x448227		4889442408		MOVQ AX, 0x8(SP)			
  0x44822c		e84f8ffbff		CALL runtime.strhash(SB)		
  0x448231		488b442410		MOVQ 0x10(SP), AX			
  0x448236		488b4c2430		MOVQ 0x30(SP), CX			
  0x44823b		4883c120		ADDQ $0x20, CX				
  0x44823f		48890c24		MOVQ CX, 0(SP)				
  0x448243		4889442408		MOVQ AX, 0x8(SP)			
  0x448248		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x448251		e8bad8fbff		CALL runtime.memhash(SB)		
  0x448256		488b442418		MOVQ 0x18(SP), AX			
  0x44825b		4889442440		MOVQ AX, 0x40(SP)			
  0x448260		488b6c2420		MOVQ 0x20(SP), BP			
  0x448265		4883c428		ADDQ $0x28, SP				
  0x448269		c3			RET					
  0x44826a		e801c3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44826f		e96cffffff		JMP type..hash.runtime.modulehash(SB)	

TEXT type..eq.runtime.modulehash(SB) <autogenerated>

  0x448280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448289		483b6110		CMPQ 0x10(CX), SP			
  0x44828d		0f86bb000000		JBE 0x44834e				
  0x448293		4883ec28		SUBQ $0x28, SP				
  0x448297		48896c2420		MOVQ BP, 0x20(SP)			
  0x44829c		488d6c2420		LEAQ 0x20(SP), BP			
  0x4482a1		488b442430		MOVQ 0x30(SP), AX			
  0x4482a6		488b4808		MOVQ 0x8(AX), CX			
  0x4482aa		488b10			MOVQ 0(AX), DX				
  0x4482ad		488b5c2438		MOVQ 0x38(SP), BX			
  0x4482b2		488b7308		MOVQ 0x8(BX), SI			
  0x4482b6		488b3b			MOVQ 0(BX), DI				
  0x4482b9		4839ce			CMPQ CX, SI				
  0x4482bc		7469			JE 0x448327				
  0x4482be		31c9			XORL CX, CX				
  0x4482c0		84c9			TESTL CL, CL				
  0x4482c2		745f			JE 0x448323				
  0x4482c4		488b4818		MOVQ 0x18(AX), CX			
  0x4482c8		488b5010		MOVQ 0x10(AX), DX			
  0x4482cc		488b7318		MOVQ 0x18(BX), SI			
  0x4482d0		488b7b10		MOVQ 0x10(BX), DI			
  0x4482d4		4839f1			CMPQ SI, CX				
  0x4482d7		7426			JE 0x4482ff				
  0x4482d9		31c9			XORL CX, CX				
  0x4482db		84c9			TESTL CL, CL				
  0x4482dd		741c			JE 0x4482fb				
  0x4482df		488b4020		MOVQ 0x20(AX), AX			
  0x4482e3		488b4b20		MOVQ 0x20(BX), CX			
  0x4482e7		4839c8			CMPQ CX, AX				
  0x4482ea		0f94c0			SETE AL					
  0x4482ed		88442440		MOVB AL, 0x40(SP)			
  0x4482f1		488b6c2420		MOVQ 0x20(SP), BP			
  0x4482f6		4883c428		ADDQ $0x28, SP				
  0x4482fa		c3			RET					
  0x4482fb		31c0			XORL AX, AX				
  0x4482fd		ebee			JMP 0x4482ed				
  0x4482ff		48891424		MOVQ DX, 0(SP)				
  0x448303		48897c2408		MOVQ DI, 0x8(SP)			
  0x448308		48894c2410		MOVQ CX, 0x10(SP)			
  0x44830d		e82ee0ffff		CALL runtime.memequal(SB)		
  0x448312		0fb64c2418		MOVZX 0x18(SP), CX			
  0x448317		488b442430		MOVQ 0x30(SP), AX			
  0x44831c		488b5c2438		MOVQ 0x38(SP), BX			
  0x448321		ebb8			JMP 0x4482db				
  0x448323		31c9			XORL CX, CX				
  0x448325		ebb4			JMP 0x4482db				
  0x448327		48891424		MOVQ DX, 0(SP)				
  0x44832b		48897c2408		MOVQ DI, 0x8(SP)			
  0x448330		48894c2410		MOVQ CX, 0x10(SP)			
  0x448335		e806e0ffff		CALL runtime.memequal(SB)		
  0x44833a		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44833f		488b442430		MOVQ 0x30(SP), AX			
  0x448344		488b5c2438		MOVQ 0x38(SP), BX			
  0x448349		e972ffffff		JMP 0x4482c0				
  0x44834e		e81dc2ffff		CALL runtime.morestack_noctxt(SB)	
  0x448353		e928ffffff		JMP type..eq.runtime.modulehash(SB)	

TEXT type..hash.runtime.bitvector(SB) <autogenerated>

  0x448360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448369		483b6110		CMPQ 0x10(CX), SP			
  0x44836d		7668			JBE 0x4483d7				
  0x44836f		4883ec28		SUBQ $0x28, SP				
  0x448373		48896c2420		MOVQ BP, 0x20(SP)			
  0x448378		488d6c2420		LEAQ 0x20(SP), BP			
  0x44837d		488b442430		MOVQ 0x30(SP), AX			
  0x448382		48890424		MOVQ AX, 0(SP)				
  0x448386		488b4c2438		MOVQ 0x38(SP), CX			
  0x44838b		48894c2408		MOVQ CX, 0x8(SP)			
  0x448390		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x448399		e872d7fbff		CALL runtime.memhash(SB)		
  0x44839e		488b442418		MOVQ 0x18(SP), AX			
  0x4483a3		488b4c2430		MOVQ 0x30(SP), CX			
  0x4483a8		4883c108		ADDQ $0x8, CX				
  0x4483ac		48890c24		MOVQ CX, 0(SP)				
  0x4483b0		4889442408		MOVQ AX, 0x8(SP)			
  0x4483b5		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x4483be		e84dd7fbff		CALL runtime.memhash(SB)		
  0x4483c3		488b442418		MOVQ 0x18(SP), AX			
  0x4483c8		4889442440		MOVQ AX, 0x40(SP)			
  0x4483cd		488b6c2420		MOVQ 0x20(SP), BP			
  0x4483d2		4883c428		ADDQ $0x28, SP				
  0x4483d6		c3			RET					
  0x4483d7		e894c1ffff		CALL runtime.morestack_noctxt(SB)	
  0x4483dc		eb82			JMP type..hash.runtime.bitvector(SB)	

TEXT type..eq.runtime.bitvector(SB) <autogenerated>

  0x4483e0		488b442408		MOVQ 0x8(SP), AX	
  0x4483e5		8b08			MOVL 0(AX), CX		
  0x4483e7		488b542410		MOVQ 0x10(SP), DX	
  0x4483ec		8b1a			MOVL 0(DX), BX		
  0x4483ee		39d9			CMPL BX, CX		
  0x4483f0		7513			JNE 0x448405		
  0x4483f2		488b4008		MOVQ 0x8(AX), AX	
  0x4483f6		488b4a08		MOVQ 0x8(DX), CX	
  0x4483fa		4839c8			CMPQ CX, AX		
  0x4483fd		0f94c0			SETE AL			
  0x448400		88442418		MOVB AL, 0x18(SP)	
  0x448404		c3			RET			
  0x448405		31c0			XORL AX, AX		
  0x448407		ebf7			JMP 0x448400		

TEXT type..hash.struct { Size uint32; Mallocs uint64; Frees uint64 }(SB) <autogenerated>

  0x448410		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX							
  0x448419		483b6110		CMPQ 0x10(CX), SP							
  0x44841d		7668			JBE 0x448487								
  0x44841f		4883ec28		SUBQ $0x28, SP								
  0x448423		48896c2420		MOVQ BP, 0x20(SP)							
  0x448428		488d6c2420		LEAQ 0x20(SP), BP							
  0x44842d		488b442430		MOVQ 0x30(SP), AX							
  0x448432		48890424		MOVQ AX, 0(SP)								
  0x448436		488b4c2438		MOVQ 0x38(SP), CX							
  0x44843b		48894c2408		MOVQ CX, 0x8(SP)							
  0x448440		48c744241004000000	MOVQ $0x4, 0x10(SP)							
  0x448449		e8c2d6fbff		CALL runtime.memhash(SB)						
  0x44844e		488b442418		MOVQ 0x18(SP), AX							
  0x448453		488b4c2430		MOVQ 0x30(SP), CX							
  0x448458		4883c108		ADDQ $0x8, CX								
  0x44845c		48890c24		MOVQ CX, 0(SP)								
  0x448460		4889442408		MOVQ AX, 0x8(SP)							
  0x448465		48c744241010000000	MOVQ $0x10, 0x10(SP)							
  0x44846e		e89dd6fbff		CALL runtime.memhash(SB)						
  0x448473		488b442418		MOVQ 0x18(SP), AX							
  0x448478		4889442440		MOVQ AX, 0x40(SP)							
  0x44847d		488b6c2420		MOVQ 0x20(SP), BP							
  0x448482		4883c428		ADDQ $0x28, SP								
  0x448486		c3			RET									
  0x448487		e8e4c0ffff		CALL runtime.morestack_noctxt(SB)					
  0x44848c		eb82			JMP type..hash.struct { Size uint32; Mallocs uint64; Frees uint64 }(SB)	

TEXT type..eq.struct { Size uint32; Mallocs uint64; Frees uint64 }(SB) <autogenerated>

  0x448490		488b442408		MOVQ 0x8(SP), AX	
  0x448495		8b08			MOVL 0(AX), CX		
  0x448497		488b542410		MOVQ 0x10(SP), DX	
  0x44849c		8b1a			MOVL 0(DX), BX		
  0x44849e		39d9			CMPL BX, CX		
  0x4484a0		7524			JNE 0x4484c6		
  0x4484a2		488b4808		MOVQ 0x8(AX), CX	
  0x4484a6		488b5a08		MOVQ 0x8(DX), BX	
  0x4484aa		4839d9			CMPQ BX, CX		
  0x4484ad		7513			JNE 0x4484c2		
  0x4484af		488b4010		MOVQ 0x10(AX), AX	
  0x4484b3		488b4a10		MOVQ 0x10(DX), CX	
  0x4484b7		4839c1			CMPQ AX, CX		
  0x4484ba		0f94c0			SETE AL			
  0x4484bd		88442418		MOVB AL, 0x18(SP)	
  0x4484c1		c3			RET			
  0x4484c2		31c0			XORL AX, AX		
  0x4484c4		ebf7			JMP 0x4484bd		
  0x4484c6		31c0			XORL AX, AX		
  0x4484c8		ebf3			JMP 0x4484bd		

TEXT type..hash.[61]struct { Size uint32; Mallocs uint64; Frees uint64 }(SB) <autogenerated>

  0x4484d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX								
  0x4484d9		483b6110		CMPQ 0x10(CX), SP								
  0x4484dd		7659			JBE 0x448538									
  0x4484df		4883ec28		SUBQ $0x28, SP									
  0x4484e3		48896c2420		MOVQ BP, 0x20(SP)								
  0x4484e8		488d6c2420		LEAQ 0x20(SP), BP								
  0x4484ed		31c0			XORL AX, AX									
  0x4484ef		488b4c2438		MOVQ 0x38(SP), CX								
  0x4484f4		eb2d			JMP 0x448523									
  0x4484f6		4889442418		MOVQ AX, 0x18(SP)								
  0x4484fb		488d1440		LEAQ 0(AX)(AX*2), DX								
  0x4484ff		488b5c2430		MOVQ 0x30(SP), BX								
  0x448504		488d14d3		LEAQ 0(BX)(DX*8), DX								
  0x448508		48891424		MOVQ DX, 0(SP)									
  0x44850c		48894c2408		MOVQ CX, 0x8(SP)								
  0x448511		e8fafeffff		CALL type..hash.struct { Size uint32; Mallocs uint64; Frees uint64 }(SB)	
  0x448516		488b4c2410		MOVQ 0x10(SP), CX								
  0x44851b		488b442418		MOVQ 0x18(SP), AX								
  0x448520		48ffc0			INCQ AX										
  0x448523		4883f83d		CMPQ $0x3d, AX									
  0x448527		7ccd			JL 0x4484f6									
  0x448529		48894c2440		MOVQ CX, 0x40(SP)								
  0x44852e		488b6c2420		MOVQ 0x20(SP), BP								
  0x448533		4883c428		ADDQ $0x28, SP									
  0x448537		c3			RET										
  0x448538		e833c0ffff		CALL runtime.morestack_noctxt(SB)						
  0x44853d		eb91			JMP type..hash.[61]struct { Size uint32; Mallocs uint64; Frees uint64 }(SB)	

TEXT type..eq.[61]struct { Size uint32; Mallocs uint64; Frees uint64 }(SB) <autogenerated>

  0x448540		488b442410		MOVQ 0x10(SP), AX	
  0x448545		488b4c2408		MOVQ 0x8(SP), CX	
  0x44854a		31d2			XORL DX, DX		
  0x44854c		eb03			JMP 0x448551		
  0x44854e		48ffc2			INCQ DX			
  0x448551		4883fa3d		CMPQ $0x3d, DX		
  0x448555		7d32			JGE 0x448589		
  0x448557		488d1c52		LEAQ 0(DX)(DX*2), BX	
  0x44855b		8b34d9			MOVL 0(CX)(BX*8), SI	
  0x44855e		8b3cd8			MOVL 0(AX)(BX*8), DI	
  0x448561		39fe			CMPL DI, SI		
  0x448563		751e			JNE 0x448583		
  0x448565		488b74d908		MOVQ 0x8(CX)(BX*8), SI	
  0x44856a		488b7cd808		MOVQ 0x8(AX)(BX*8), DI	
  0x44856f		4839fe			CMPQ DI, SI		
  0x448572		750f			JNE 0x448583		
  0x448574		488b74d910		MOVQ 0x10(CX)(BX*8), SI	
  0x448579		488b5cd810		MOVQ 0x10(AX)(BX*8), BX	
  0x44857e		4839f3			CMPQ SI, BX		
  0x448581		74cb			JE 0x44854e		
  0x448583		c644241800		MOVB $0x0, 0x18(SP)	
  0x448588		c3			RET			
  0x448589		c644241801		MOVB $0x1, 0x18(SP)	
  0x44858e		c3			RET			

TEXT type..hash.runtime.MemStats(SB) <autogenerated>

  0x448590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX								
  0x448599		483b6110		CMPQ 0x10(CX), SP								
  0x44859d		0f86a9000000		JBE 0x44864c									
  0x4485a3		4883ec28		SUBQ $0x28, SP									
  0x4485a7		48896c2420		MOVQ BP, 0x20(SP)								
  0x4485ac		488d6c2420		LEAQ 0x20(SP), BP								
  0x4485b1		488b442430		MOVQ 0x30(SP), AX								
  0x4485b6		48890424		MOVQ AX, 0(SP)									
  0x4485ba		488b4c2438		MOVQ 0x38(SP), CX								
  0x4485bf		48894c2408		MOVQ CX, 0x8(SP)								
  0x4485c4		48c7442410c8100000	MOVQ $0x10c8, 0x10(SP)								
  0x4485cd		e83ed5fbff		CALL runtime.memhash(SB)							
  0x4485d2		488b442418		MOVQ 0x18(SP), AX								
  0x4485d7		488b4c2430		MOVQ 0x30(SP), CX								
  0x4485dc		488d91c8100000		LEAQ 0x10c8(CX), DX								
  0x4485e3		48891424		MOVQ DX, 0(SP)									
  0x4485e7		4889442408		MOVQ AX, 0x8(SP)								
  0x4485ec		e80f8dfbff		CALL runtime.f64hash(SB)							
  0x4485f1		488b442410		MOVQ 0x10(SP), AX								
  0x4485f6		488b4c2430		MOVQ 0x30(SP), CX								
  0x4485fb		488d91d0100000		LEAQ 0x10d0(CX), DX								
  0x448602		48891424		MOVQ DX, 0(SP)									
  0x448606		4889442408		MOVQ AX, 0x8(SP)								
  0x44860b		48c744241002000000	MOVQ $0x2, 0x10(SP)								
  0x448614		e8f7d4fbff		CALL runtime.memhash(SB)							
  0x448619		488b442418		MOVQ 0x18(SP), AX								
  0x44861e		488b4c2430		MOVQ 0x30(SP), CX								
  0x448623		4881c1d8100000		ADDQ $0x10d8, CX								
  0x44862a		48890c24		MOVQ CX, 0(SP)									
  0x44862e		4889442408		MOVQ AX, 0x8(SP)								
  0x448633		e898feffff		CALL type..hash.[61]struct { Size uint32; Mallocs uint64; Frees uint64 }(SB)	
  0x448638		488b442410		MOVQ 0x10(SP), AX								
  0x44863d		4889442440		MOVQ AX, 0x40(SP)								
  0x448642		488b6c2420		MOVQ 0x20(SP), BP								
  0x448647		4883c428		ADDQ $0x28, SP									
  0x44864b		c3			RET										
  0x44864c		e81fbfffff		CALL runtime.morestack_noctxt(SB)						
  0x448651		e93affffff		JMP type..hash.runtime.MemStats(SB)						

TEXT type..eq.runtime.MemStats(SB) <autogenerated>

  0x448660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX								
  0x448669		483b6110		CMPQ 0x10(CX), SP								
  0x44866d		0f86c0000000		JBE 0x448733									
  0x448673		4883ec28		SUBQ $0x28, SP									
  0x448677		48896c2420		MOVQ BP, 0x20(SP)								
  0x44867c		488d6c2420		LEAQ 0x20(SP), BP								
  0x448681		488b442438		MOVQ 0x38(SP), AX								
  0x448686		4889442408		MOVQ AX, 0x8(SP)								
  0x44868b		488b4c2430		MOVQ 0x30(SP), CX								
  0x448690		48890c24		MOVQ CX, 0(SP)									
  0x448694		48c7442410c8100000	MOVQ $0x10c8, 0x10(SP)								
  0x44869d		e89edcffff		CALL runtime.memequal(SB)							
  0x4486a2		0fb6442418		MOVZX 0x18(SP), AX								
  0x4486a7		84c0			TESTL AL, AL									
  0x4486a9		0f8480000000		JE 0x44872f									
  0x4486af		488b442430		MOVQ 0x30(SP), AX								
  0x4486b4		f20f1080c8100000	MOVSD_XMM 0x10c8(AX), X0							
  0x4486bc		488b4c2438		MOVQ 0x38(SP), CX								
  0x4486c1		f20f1089c8100000	MOVSD_XMM 0x10c8(CX), X1							
  0x4486c9		660f2ec1		UCOMISD X1, X0									
  0x4486cd		755c			JNE 0x44872b									
  0x4486cf		7a5a			JP 0x44872b									
  0x4486d1		0fb690d0100000		MOVZX 0x10d0(AX), DX								
  0x4486d8		0fb699d0100000		MOVZX 0x10d0(CX), BX								
  0x4486df		38da			CMPL BL, DL									
  0x4486e1		7544			JNE 0x448727									
  0x4486e3		0fb690d1100000		MOVZX 0x10d1(AX), DX								
  0x4486ea		0fb699d1100000		MOVZX 0x10d1(CX), BX								
  0x4486f1		38da			CMPL BL, DL									
  0x4486f3		7410			JE 0x448705									
  0x4486f5		31c0			XORL AX, AX									
  0x4486f7		88442440		MOVB AL, 0x40(SP)								
  0x4486fb		488b6c2420		MOVQ 0x20(SP), BP								
  0x448700		4883c428		ADDQ $0x28, SP									
  0x448704		c3			RET										
  0x448705		4805d8100000		ADDQ $0x10d8, AX								
  0x44870b		48890424		MOVQ AX, 0(SP)									
  0x44870f		488d81d8100000		LEAQ 0x10d8(CX), AX								
  0x448716		4889442408		MOVQ AX, 0x8(SP)								
  0x44871b		e820feffff		CALL type..eq.[61]struct { Size uint32; Mallocs uint64; Frees uint64 }(SB)	
  0x448720		0fb6442410		MOVZX 0x10(SP), AX								
  0x448725		ebd0			JMP 0x4486f7									
  0x448727		31c0			XORL AX, AX									
  0x448729		ebcc			JMP 0x4486f7									
  0x44872b		31c0			XORL AX, AX									
  0x44872d		ebc8			JMP 0x4486f7									
  0x44872f		31c0			XORL AX, AX									
  0x448731		ebc4			JMP 0x4486f7									
  0x448733		e838beffff		CALL runtime.morestack_noctxt(SB)						
  0x448738		e923ffffff		JMP type..eq.runtime.MemStats(SB)						

TEXT type..hash.runtime.TypeAssertionError(SB) <autogenerated>

  0x448740		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x448749		483b6110		CMPQ 0x10(CX), SP				
  0x44874d		0f868e000000		JBE 0x4487e1					
  0x448753		4883ec20		SUBQ $0x20, SP					
  0x448757		48896c2418		MOVQ BP, 0x18(SP)				
  0x44875c		488d6c2418		LEAQ 0x18(SP), BP				
  0x448761		488b442428		MOVQ 0x28(SP), AX				
  0x448766		48890424		MOVQ AX, 0(SP)					
  0x44876a		488b4c2430		MOVQ 0x30(SP), CX				
  0x44876f		48894c2408		MOVQ CX, 0x8(SP)				
  0x448774		e8078afbff		CALL runtime.strhash(SB)			
  0x448779		488b442410		MOVQ 0x10(SP), AX				
  0x44877e		488b4c2428		MOVQ 0x28(SP), CX				
  0x448783		488d5110		LEAQ 0x10(CX), DX				
  0x448787		48891424		MOVQ DX, 0(SP)					
  0x44878b		4889442408		MOVQ AX, 0x8(SP)				
  0x448790		e8eb89fbff		CALL runtime.strhash(SB)			
  0x448795		488b442410		MOVQ 0x10(SP), AX				
  0x44879a		488b4c2428		MOVQ 0x28(SP), CX				
  0x44879f		488d5120		LEAQ 0x20(CX), DX				
  0x4487a3		48891424		MOVQ DX, 0(SP)					
  0x4487a7		4889442408		MOVQ AX, 0x8(SP)				
  0x4487ac		e8cf89fbff		CALL runtime.strhash(SB)			
  0x4487b1		488b442410		MOVQ 0x10(SP), AX				
  0x4487b6		488b4c2428		MOVQ 0x28(SP), CX				
  0x4487bb		4883c130		ADDQ $0x30, CX					
  0x4487bf		48890c24		MOVQ CX, 0(SP)					
  0x4487c3		4889442408		MOVQ AX, 0x8(SP)				
  0x4487c8		e8b389fbff		CALL runtime.strhash(SB)			
  0x4487cd		488b442410		MOVQ 0x10(SP), AX				
  0x4487d2		4889442438		MOVQ AX, 0x38(SP)				
  0x4487d7		488b6c2418		MOVQ 0x18(SP), BP				
  0x4487dc		4883c420		ADDQ $0x20, SP					
  0x4487e0		c3			RET						
  0x4487e1		e88abdffff		CALL runtime.morestack_noctxt(SB)		
  0x4487e6		e955ffffff		JMP type..hash.runtime.TypeAssertionError(SB)	

TEXT type..eq.runtime.TypeAssertionError(SB) <autogenerated>

  0x4487f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x4487f9		483b6110		CMPQ 0x10(CX), SP				
  0x4487fd		0f8637010000		JBE 0x44893a					
  0x448803		4883ec28		SUBQ $0x28, SP					
  0x448807		48896c2420		MOVQ BP, 0x20(SP)				
  0x44880c		488d6c2420		LEAQ 0x20(SP), BP				
  0x448811		488b442438		MOVQ 0x38(SP), AX				
  0x448816		488b4808		MOVQ 0x8(AX), CX				
  0x44881a		488b10			MOVQ 0(AX), DX					
  0x44881d		488b5c2430		MOVQ 0x30(SP), BX				
  0x448822		488b7308		MOVQ 0x8(BX), SI				
  0x448826		488b3b			MOVQ 0(BX), DI					
  0x448829		4839f1			CMPQ SI, CX					
  0x44882c		0f84e1000000		JE 0x448913					
  0x448832		31c9			XORL CX, CX					
  0x448834		84c9			TESTL CL, CL					
  0x448836		0f84d0000000		JE 0x44890c					
  0x44883c		488b4818		MOVQ 0x18(AX), CX				
  0x448840		488b5318		MOVQ 0x18(BX), DX				
  0x448844		488b7310		MOVQ 0x10(BX), SI				
  0x448848		488b7810		MOVQ 0x10(AX), DI				
  0x44884c		4839d1			CMPQ DX, CX					
  0x44884f		0f8490000000		JE 0x4488e5					
  0x448855		31c9			XORL CX, CX					
  0x448857		84c9			TESTL CL, CL					
  0x448859		0f8482000000		JE 0x4488e1					
  0x44885f		488b4828		MOVQ 0x28(AX), CX				
  0x448863		488b5328		MOVQ 0x28(BX), DX				
  0x448867		488b7320		MOVQ 0x20(BX), SI				
  0x44886b		488b7820		MOVQ 0x20(AX), DI				
  0x44886f		4839d1			CMPQ DX, CX					
  0x448872		7449			JE 0x4488bd					
  0x448874		31c9			XORL CX, CX					
  0x448876		84c9			TESTL CL, CL					
  0x448878		743f			JE 0x4488b9					
  0x44887a		488b4b38		MOVQ 0x38(BX), CX				
  0x44887e		488b5330		MOVQ 0x30(BX), DX				
  0x448882		488b5838		MOVQ 0x38(AX), BX				
  0x448886		488b4030		MOVQ 0x30(AX), AX				
  0x44888a		4839d9			CMPQ BX, CX					
  0x44888d		7410			JE 0x44889f					
  0x44888f		31c0			XORL AX, AX					
  0x448891		88442440		MOVB AL, 0x40(SP)				
  0x448895		488b6c2420		MOVQ 0x20(SP), BP				
  0x44889a		4883c428		ADDQ $0x28, SP					
  0x44889e		c3			RET						
  0x44889f		48891424		MOVQ DX, 0(SP)					
  0x4488a3		4889442408		MOVQ AX, 0x8(SP)				
  0x4488a8		48894c2410		MOVQ CX, 0x10(SP)				
  0x4488ad		e88edaffff		CALL runtime.memequal(SB)			
  0x4488b2		0fb6442418		MOVZX 0x18(SP), AX				
  0x4488b7		ebd8			JMP 0x448891					
  0x4488b9		31c0			XORL AX, AX					
  0x4488bb		ebd4			JMP 0x448891					
  0x4488bd		48893424		MOVQ SI, 0(SP)					
  0x4488c1		48897c2408		MOVQ DI, 0x8(SP)				
  0x4488c6		4889542410		MOVQ DX, 0x10(SP)				
  0x4488cb		e870daffff		CALL runtime.memequal(SB)			
  0x4488d0		0fb64c2418		MOVZX 0x18(SP), CX				
  0x4488d5		488b442438		MOVQ 0x38(SP), AX				
  0x4488da		488b5c2430		MOVQ 0x30(SP), BX				
  0x4488df		eb95			JMP 0x448876					
  0x4488e1		31c9			XORL CX, CX					
  0x4488e3		eb91			JMP 0x448876					
  0x4488e5		48893424		MOVQ SI, 0(SP)					
  0x4488e9		48897c2408		MOVQ DI, 0x8(SP)				
  0x4488ee		4889542410		MOVQ DX, 0x10(SP)				
  0x4488f3		e848daffff		CALL runtime.memequal(SB)			
  0x4488f8		0fb64c2418		MOVZX 0x18(SP), CX				
  0x4488fd		488b442438		MOVQ 0x38(SP), AX				
  0x448902		488b5c2430		MOVQ 0x30(SP), BX				
  0x448907		e94bffffff		JMP 0x448857					
  0x44890c		31c9			XORL CX, CX					
  0x44890e		e944ffffff		JMP 0x448857					
  0x448913		48893c24		MOVQ DI, 0(SP)					
  0x448917		4889542408		MOVQ DX, 0x8(SP)				
  0x44891c		4889742410		MOVQ SI, 0x10(SP)				
  0x448921		e81adaffff		CALL runtime.memequal(SB)			
  0x448926		0fb64c2418		MOVZX 0x18(SP), CX				
  0x44892b		488b442438		MOVQ 0x38(SP), AX				
  0x448930		488b5c2430		MOVQ 0x30(SP), BX				
  0x448935		e9fafeffff		JMP 0x448834					
  0x44893a		e831bcffff		CALL runtime.morestack_noctxt(SB)		
  0x44893f		e9acfeffff		JMP type..eq.runtime.TypeAssertionError(SB)	

TEXT type..hash.runtime._panic(SB) <autogenerated>

  0x448950		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448959		483b6110		CMPQ 0x10(CX), SP			
  0x44895d		0f8684000000		JBE 0x4489e7				
  0x448963		4883ec28		SUBQ $0x28, SP				
  0x448967		48896c2420		MOVQ BP, 0x20(SP)			
  0x44896c		488d6c2420		LEAQ 0x20(SP), BP			
  0x448971		488b442430		MOVQ 0x30(SP), AX			
  0x448976		48890424		MOVQ AX, 0(SP)				
  0x44897a		488b4c2438		MOVQ 0x38(SP), CX			
  0x44897f		48894c2408		MOVQ CX, 0x8(SP)			
  0x448984		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44898d		e87ed1fbff		CALL runtime.memhash(SB)		
  0x448992		488b442418		MOVQ 0x18(SP), AX			
  0x448997		488b4c2430		MOVQ 0x30(SP), CX			
  0x44899c		488d5108		LEAQ 0x8(CX), DX			
  0x4489a0		48891424		MOVQ DX, 0(SP)				
  0x4489a4		4889442408		MOVQ AX, 0x8(SP)			
  0x4489a9		e8d28cfbff		CALL runtime.nilinterhash(SB)		
  0x4489ae		488b442410		MOVQ 0x10(SP), AX			
  0x4489b3		488b4c2430		MOVQ 0x30(SP), CX			
  0x4489b8		4883c118		ADDQ $0x18, CX				
  0x4489bc		48890c24		MOVQ CX, 0(SP)				
  0x4489c0		4889442408		MOVQ AX, 0x8(SP)			
  0x4489c5		48c74424100a000000	MOVQ $0xa, 0x10(SP)			
  0x4489ce		e83dd1fbff		CALL runtime.memhash(SB)		
  0x4489d3		488b442418		MOVQ 0x18(SP), AX			
  0x4489d8		4889442440		MOVQ AX, 0x40(SP)			
  0x4489dd		488b6c2420		MOVQ 0x20(SP), BP			
  0x4489e2		4883c428		ADDQ $0x28, SP				
  0x4489e6		c3			RET					
  0x4489e7		e884bbffff		CALL runtime.morestack_noctxt(SB)	
  0x4489ec		e95fffffff		JMP type..hash.runtime._panic(SB)	

TEXT type..eq.runtime._panic(SB) <autogenerated>

  0x448a00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448a09		483b6110		CMPQ 0x10(CX), SP			
  0x448a0d		0f869c000000		JBE 0x448aaf				
  0x448a13		4883ec28		SUBQ $0x28, SP				
  0x448a17		48896c2420		MOVQ BP, 0x20(SP)			
  0x448a1c		488d6c2420		LEAQ 0x20(SP), BP			
  0x448a21		488b442430		MOVQ 0x30(SP), AX			
  0x448a26		488b08			MOVQ 0(AX), CX				
  0x448a29		488b542438		MOVQ 0x38(SP), DX			
  0x448a2e		488b1a			MOVQ 0(DX), BX				
  0x448a31		4839d9			CMPQ BX, CX				
  0x448a34		7575			JNE 0x448aab				
  0x448a36		488b4a10		MOVQ 0x10(DX), CX			
  0x448a3a		488b5a08		MOVQ 0x8(DX), BX			
  0x448a3e		488b7010		MOVQ 0x10(AX), SI			
  0x448a42		488b7808		MOVQ 0x8(AX), DI			
  0x448a46		4839df			CMPQ BX, DI				
  0x448a49		743c			JE 0x448a87				
  0x448a4b		31c9			XORL CX, CX				
  0x448a4d		84c9			TESTL CL, CL				
  0x448a4f		7510			JNE 0x448a61				
  0x448a51		31c0			XORL AX, AX				
  0x448a53		88442440		MOVB AL, 0x40(SP)			
  0x448a57		488b6c2420		MOVQ 0x20(SP), BP			
  0x448a5c		4883c428		ADDQ $0x28, SP				
  0x448a60		c3			RET					
  0x448a61		488d4a18		LEAQ 0x18(DX), CX			
  0x448a65		48894c2408		MOVQ CX, 0x8(SP)			
  0x448a6a		4883c018		ADDQ $0x18, AX				
  0x448a6e		48890424		MOVQ AX, 0(SP)				
  0x448a72		48c74424100a000000	MOVQ $0xa, 0x10(SP)			
  0x448a7b		e8c0d8ffff		CALL runtime.memequal(SB)		
  0x448a80		0fb6442418		MOVZX 0x18(SP), AX			
  0x448a85		ebcc			JMP 0x448a53				
  0x448a87		48893c24		MOVQ DI, 0(SP)				
  0x448a8b		4889742408		MOVQ SI, 0x8(SP)			
  0x448a90		48894c2410		MOVQ CX, 0x10(SP)			
  0x448a95		e85690fbff		CALL runtime.efaceeq(SB)		
  0x448a9a		0fb64c2418		MOVZX 0x18(SP), CX			
  0x448a9f		488b442430		MOVQ 0x30(SP), AX			
  0x448aa4		488b542438		MOVQ 0x38(SP), DX			
  0x448aa9		eba2			JMP 0x448a4d				
  0x448aab		31c9			XORL CX, CX				
  0x448aad		eb9e			JMP 0x448a4d				
  0x448aaf		e8bcbaffff		CALL runtime.morestack_noctxt(SB)	
  0x448ab4		e947ffffff		JMP type..eq.runtime._panic(SB)		

TEXT type..hash.runtime._defer(SB) <autogenerated>

  0x448ac0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448ac9		483b6110		CMPQ 0x10(CX), SP			
  0x448acd		7668			JBE 0x448b37				
  0x448acf		4883ec28		SUBQ $0x28, SP				
  0x448ad3		48896c2420		MOVQ BP, 0x20(SP)			
  0x448ad8		488d6c2420		LEAQ 0x20(SP), BP			
  0x448add		488b442430		MOVQ 0x30(SP), AX			
  0x448ae2		48890424		MOVQ AX, 0(SP)				
  0x448ae6		488b4c2438		MOVQ 0x38(SP), CX			
  0x448aeb		48894c2408		MOVQ CX, 0x8(SP)			
  0x448af0		48c744241005000000	MOVQ $0x5, 0x10(SP)			
  0x448af9		e812d0fbff		CALL runtime.memhash(SB)		
  0x448afe		488b442418		MOVQ 0x18(SP), AX			
  0x448b03		488b4c2430		MOVQ 0x30(SP), CX			
  0x448b08		4883c108		ADDQ $0x8, CX				
  0x448b0c		48890c24		MOVQ CX, 0(SP)				
  0x448b10		4889442408		MOVQ AX, 0x8(SP)			
  0x448b15		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x448b1e		e8edcffbff		CALL runtime.memhash(SB)		
  0x448b23		488b442418		MOVQ 0x18(SP), AX			
  0x448b28		4889442440		MOVQ AX, 0x40(SP)			
  0x448b2d		488b6c2420		MOVQ 0x20(SP), BP			
  0x448b32		4883c428		ADDQ $0x28, SP				
  0x448b36		c3			RET					
  0x448b37		e834baffff		CALL runtime.morestack_noctxt(SB)	
  0x448b3c		eb82			JMP type..hash.runtime._defer(SB)	

TEXT type..eq.runtime._defer(SB) <autogenerated>

  0x448b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448b49		483b6110		CMPQ 0x10(CX), SP			
  0x448b4d		7666			JBE 0x448bb5				
  0x448b4f		4883ec28		SUBQ $0x28, SP				
  0x448b53		48896c2420		MOVQ BP, 0x20(SP)			
  0x448b58		488d6c2420		LEAQ 0x20(SP), BP			
  0x448b5d		488b442430		MOVQ 0x30(SP), AX			
  0x448b62		8b08			MOVL 0(AX), CX				
  0x448b64		488b542438		MOVQ 0x38(SP), DX			
  0x448b69		8b1a			MOVL 0(DX), BX				
  0x448b6b		39d9			CMPL BX, CX				
  0x448b6d		7542			JNE 0x448bb1				
  0x448b6f		0fb64804		MOVZX 0x4(AX), CX			
  0x448b73		0fb65a04		MOVZX 0x4(DX), BX			
  0x448b77		38d9			CMPL BL, CL				
  0x448b79		7410			JE 0x448b8b				
  0x448b7b		31c0			XORL AX, AX				
  0x448b7d		88442440		MOVB AL, 0x40(SP)			
  0x448b81		488b6c2420		MOVQ 0x20(SP), BP			
  0x448b86		4883c428		ADDQ $0x28, SP				
  0x448b8a		c3			RET					
  0x448b8b		488d4a08		LEAQ 0x8(DX), CX			
  0x448b8f		48894c2408		MOVQ CX, 0x8(SP)			
  0x448b94		4883c008		ADDQ $0x8, AX				
  0x448b98		48890424		MOVQ AX, 0(SP)				
  0x448b9c		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x448ba5		e896d7ffff		CALL runtime.memequal(SB)		
  0x448baa		0fb6442418		MOVZX 0x18(SP), AX			
  0x448baf		ebcc			JMP 0x448b7d				
  0x448bb1		31c0			XORL AX, AX				
  0x448bb3		ebc8			JMP 0x448b7d				
  0x448bb5		e8b6b9ffff		CALL runtime.morestack_noctxt(SB)	
  0x448bba		eb84			JMP type..eq.runtime._defer(SB)		

TEXT type..hash.runtime.sysmontick(SB) <autogenerated>

  0x448bc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448bc9		483b6110		CMPQ 0x10(CX), SP			
  0x448bcd		0f868d000000		JBE 0x448c60				
  0x448bd3		4883ec28		SUBQ $0x28, SP				
  0x448bd7		48896c2420		MOVQ BP, 0x20(SP)			
  0x448bdc		488d6c2420		LEAQ 0x20(SP), BP			
  0x448be1		488b442430		MOVQ 0x30(SP), AX			
  0x448be6		48890424		MOVQ AX, 0(SP)				
  0x448bea		488b4c2438		MOVQ 0x38(SP), CX			
  0x448bef		48894c2408		MOVQ CX, 0x8(SP)			
  0x448bf4		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x448bfd		e80ecffbff		CALL runtime.memhash(SB)		
  0x448c02		488b442418		MOVQ 0x18(SP), AX			
  0x448c07		488b4c2430		MOVQ 0x30(SP), CX			
  0x448c0c		488d5108		LEAQ 0x8(CX), DX			
  0x448c10		48891424		MOVQ DX, 0(SP)				
  0x448c14		4889442408		MOVQ AX, 0x8(SP)			
  0x448c19		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x448c22		e8e9cefbff		CALL runtime.memhash(SB)		
  0x448c27		488b442418		MOVQ 0x18(SP), AX			
  0x448c2c		488b4c2430		MOVQ 0x30(SP), CX			
  0x448c31		4883c118		ADDQ $0x18, CX				
  0x448c35		48890c24		MOVQ CX, 0(SP)				
  0x448c39		4889442408		MOVQ AX, 0x8(SP)			
  0x448c3e		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x448c47		e8c4cefbff		CALL runtime.memhash(SB)		
  0x448c4c		488b442418		MOVQ 0x18(SP), AX			
  0x448c51		4889442440		MOVQ AX, 0x40(SP)			
  0x448c56		488b6c2420		MOVQ 0x20(SP), BP			
  0x448c5b		4883c428		ADDQ $0x28, SP				
  0x448c5f		c3			RET					
  0x448c60		e80bb9ffff		CALL runtime.morestack_noctxt(SB)	
  0x448c65		e956ffffff		JMP type..hash.runtime.sysmontick(SB)	

TEXT type..eq.runtime.sysmontick(SB) <autogenerated>

  0x448c70		488b442408		MOVQ 0x8(SP), AX	
  0x448c75		8b08			MOVL 0(AX), CX		
  0x448c77		488b542410		MOVQ 0x10(SP), DX	
  0x448c7c		8b1a			MOVL 0(DX), BX		
  0x448c7e		39d9			CMPL BX, CX		
  0x448c80		7532			JNE 0x448cb4		
  0x448c82		488b4808		MOVQ 0x8(AX), CX	
  0x448c86		488b5a08		MOVQ 0x8(DX), BX	
  0x448c8a		4839cb			CMPQ CX, BX		
  0x448c8d		7521			JNE 0x448cb0		
  0x448c8f		8b4810			MOVL 0x10(AX), CX	
  0x448c92		8b5a10			MOVL 0x10(DX), BX	
  0x448c95		39d9			CMPL BX, CX		
  0x448c97		7513			JNE 0x448cac		
  0x448c99		488b4018		MOVQ 0x18(AX), AX	
  0x448c9d		488b4a18		MOVQ 0x18(DX), CX	
  0x448ca1		4839c1			CMPQ AX, CX		
  0x448ca4		0f94c0			SETE AL			
  0x448ca7		88442418		MOVB AL, 0x18(SP)	
  0x448cab		c3			RET			
  0x448cac		31c0			XORL AX, AX		
  0x448cae		ebf7			JMP 0x448ca7		
  0x448cb0		31c0			XORL AX, AX		
  0x448cb2		ebf3			JMP 0x448ca7		
  0x448cb4		31c0			XORL AX, AX		
  0x448cb6		ebef			JMP 0x448ca7		

TEXT type..hash.runtime.special(SB) <autogenerated>

  0x448cc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448cc9		483b6110		CMPQ 0x10(CX), SP			
  0x448ccd		7643			JBE 0x448d12				
  0x448ccf		4883ec28		SUBQ $0x28, SP				
  0x448cd3		48896c2420		MOVQ BP, 0x20(SP)			
  0x448cd8		488d6c2420		LEAQ 0x20(SP), BP			
  0x448cdd		488b442430		MOVQ 0x30(SP), AX			
  0x448ce2		48890424		MOVQ AX, 0(SP)				
  0x448ce6		488b442438		MOVQ 0x38(SP), AX			
  0x448ceb		4889442408		MOVQ AX, 0x8(SP)			
  0x448cf0		48c74424100b000000	MOVQ $0xb, 0x10(SP)			
  0x448cf9		e812cefbff		CALL runtime.memhash(SB)		
  0x448cfe		488b442418		MOVQ 0x18(SP), AX			
  0x448d03		4889442440		MOVQ AX, 0x40(SP)			
  0x448d08		488b6c2420		MOVQ 0x20(SP), BP			
  0x448d0d		4883c428		ADDQ $0x28, SP				
  0x448d11		c3			RET					
  0x448d12		e859b8ffff		CALL runtime.morestack_noctxt(SB)	
  0x448d17		eba7			JMP type..hash.runtime.special(SB)	

TEXT type..eq.runtime.special(SB) <autogenerated>

  0x448d20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448d29		483b6110		CMPQ 0x10(CX), SP			
  0x448d2d		7642			JBE 0x448d71				
  0x448d2f		4883ec28		SUBQ $0x28, SP				
  0x448d33		48896c2420		MOVQ BP, 0x20(SP)			
  0x448d38		488d6c2420		LEAQ 0x20(SP), BP			
  0x448d3d		488b442438		MOVQ 0x38(SP), AX			
  0x448d42		4889442408		MOVQ AX, 0x8(SP)			
  0x448d47		488b442430		MOVQ 0x30(SP), AX			
  0x448d4c		48890424		MOVQ AX, 0(SP)				
  0x448d50		48c74424100b000000	MOVQ $0xb, 0x10(SP)			
  0x448d59		e8e2d5ffff		CALL runtime.memequal(SB)		
  0x448d5e		0fb6442418		MOVZX 0x18(SP), AX			
  0x448d63		88442440		MOVB AL, 0x40(SP)			
  0x448d67		488b6c2420		MOVQ 0x20(SP), BP			
  0x448d6c		4883c428		ADDQ $0x28, SP				
  0x448d70		c3			RET					
  0x448d71		e8fab7ffff		CALL runtime.morestack_noctxt(SB)	
  0x448d76		eba8			JMP type..eq.runtime.special(SB)	

TEXT type..hash.runtime.markBits(SB) <autogenerated>

  0x448d80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448d89		483b6110		CMPQ 0x10(CX), SP			
  0x448d8d		7668			JBE 0x448df7				
  0x448d8f		4883ec28		SUBQ $0x28, SP				
  0x448d93		48896c2420		MOVQ BP, 0x20(SP)			
  0x448d98		488d6c2420		LEAQ 0x20(SP), BP			
  0x448d9d		488b442430		MOVQ 0x30(SP), AX			
  0x448da2		48890424		MOVQ AX, 0(SP)				
  0x448da6		488b4c2438		MOVQ 0x38(SP), CX			
  0x448dab		48894c2408		MOVQ CX, 0x8(SP)			
  0x448db0		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x448db9		e852cdfbff		CALL runtime.memhash(SB)		
  0x448dbe		488b442418		MOVQ 0x18(SP), AX			
  0x448dc3		488b4c2430		MOVQ 0x30(SP), CX			
  0x448dc8		4883c110		ADDQ $0x10, CX				
  0x448dcc		48890c24		MOVQ CX, 0(SP)				
  0x448dd0		4889442408		MOVQ AX, 0x8(SP)			
  0x448dd5		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x448dde		e82dcdfbff		CALL runtime.memhash(SB)		
  0x448de3		488b442418		MOVQ 0x18(SP), AX			
  0x448de8		4889442440		MOVQ AX, 0x40(SP)			
  0x448ded		488b6c2420		MOVQ 0x20(SP), BP			
  0x448df2		4883c428		ADDQ $0x28, SP				
  0x448df6		c3			RET					
  0x448df7		e874b7ffff		CALL runtime.morestack_noctxt(SB)	
  0x448dfc		eb82			JMP type..hash.runtime.markBits(SB)	

TEXT type..eq.runtime.markBits(SB) <autogenerated>

  0x448e00		488b442408		MOVQ 0x8(SP), AX	
  0x448e05		488b08			MOVQ 0(AX), CX		
  0x448e08		488b542410		MOVQ 0x10(SP), DX	
  0x448e0d		488b1a			MOVQ 0(DX), BX		
  0x448e10		4839d9			CMPQ BX, CX		
  0x448e13		7523			JNE 0x448e38		
  0x448e15		0fb64808		MOVZX 0x8(AX), CX	
  0x448e19		0fb65a08		MOVZX 0x8(DX), BX	
  0x448e1d		38d9			CMPL BL, CL		
  0x448e1f		7513			JNE 0x448e34		
  0x448e21		488b4010		MOVQ 0x10(AX), AX	
  0x448e25		488b4a10		MOVQ 0x10(DX), CX	
  0x448e29		4839c8			CMPQ CX, AX		
  0x448e2c		0f94c0			SETE AL			
  0x448e2f		88442418		MOVB AL, 0x18(SP)	
  0x448e33		c3			RET			
  0x448e34		31c0			XORL AX, AX		
  0x448e36		ebf7			JMP 0x448e2f		
  0x448e38		31c0			XORL AX, AX		
  0x448e3a		ebf3			JMP 0x448e2f		

TEXT type..hash.runtime.mcache(SB) <autogenerated>

  0x448e40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448e49		483b6110		CMPQ 0x10(CX), SP			
  0x448e4d		7668			JBE 0x448eb7				
  0x448e4f		4883ec28		SUBQ $0x28, SP				
  0x448e53		48896c2420		MOVQ BP, 0x20(SP)			
  0x448e58		488d6c2420		LEAQ 0x20(SP), BP			
  0x448e5d		488b442430		MOVQ 0x30(SP), AX			
  0x448e62		48890424		MOVQ AX, 0(SP)				
  0x448e66		488b4c2438		MOVQ 0x38(SP), CX			
  0x448e6b		48894c2408		MOVQ CX, 0x8(SP)			
  0x448e70		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x448e79		e892ccfbff		CALL runtime.memhash(SB)		
  0x448e7e		488b442418		MOVQ 0x18(SP), AX			
  0x448e83		488b4c2430		MOVQ 0x30(SP), CX			
  0x448e88		4883c108		ADDQ $0x8, CX				
  0x448e8c		48890c24		MOVQ CX, 0(SP)				
  0x448e90		4889442408		MOVQ AX, 0x8(SP)			
  0x448e95		48c7442410c0060000	MOVQ $0x6c0, 0x10(SP)			
  0x448e9e		e86dccfbff		CALL runtime.memhash(SB)		
  0x448ea3		488b442418		MOVQ 0x18(SP), AX			
  0x448ea8		4889442440		MOVQ AX, 0x40(SP)			
  0x448ead		488b6c2420		MOVQ 0x20(SP), BP			
  0x448eb2		4883c428		ADDQ $0x28, SP				
  0x448eb6		c3			RET					
  0x448eb7		e8b4b6ffff		CALL runtime.morestack_noctxt(SB)	
  0x448ebc		eb82			JMP type..hash.runtime.mcache(SB)	

TEXT type..eq.runtime.mcache(SB) <autogenerated>

  0x448ec0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448ec9		483b6110		CMPQ 0x10(CX), SP			
  0x448ecd		7656			JBE 0x448f25				
  0x448ecf		4883ec28		SUBQ $0x28, SP				
  0x448ed3		48896c2420		MOVQ BP, 0x20(SP)			
  0x448ed8		488d6c2420		LEAQ 0x20(SP), BP			
  0x448edd		488b442430		MOVQ 0x30(SP), AX			
  0x448ee2		8b08			MOVL 0(AX), CX				
  0x448ee4		488b542438		MOVQ 0x38(SP), DX			
  0x448ee9		8b1a			MOVL 0(DX), BX				
  0x448eeb		39d9			CMPL BX, CX				
  0x448eed		7410			JE 0x448eff				
  0x448eef		31c0			XORL AX, AX				
  0x448ef1		88442440		MOVB AL, 0x40(SP)			
  0x448ef5		488b6c2420		MOVQ 0x20(SP), BP			
  0x448efa		4883c428		ADDQ $0x28, SP				
  0x448efe		c3			RET					
  0x448eff		488d4a08		LEAQ 0x8(DX), CX			
  0x448f03		48894c2408		MOVQ CX, 0x8(SP)			
  0x448f08		4883c008		ADDQ $0x8, AX				
  0x448f0c		48890424		MOVQ AX, 0(SP)				
  0x448f10		48c7442410c0060000	MOVQ $0x6c0, 0x10(SP)			
  0x448f19		e822d4ffff		CALL runtime.memequal(SB)		
  0x448f1e		0fb6442418		MOVZX 0x18(SP), AX			
  0x448f23		ebcc			JMP 0x448ef1				
  0x448f25		e846b6ffff		CALL runtime.morestack_noctxt(SB)	
  0x448f2a		eb94			JMP type..eq.runtime.mcache(SB)		

TEXT type..hash.runtime.hchan(SB) <autogenerated>

  0x448f30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448f39		483b6110		CMPQ 0x10(CX), SP			
  0x448f3d		7668			JBE 0x448fa7				
  0x448f3f		4883ec28		SUBQ $0x28, SP				
  0x448f43		48896c2420		MOVQ BP, 0x20(SP)			
  0x448f48		488d6c2420		LEAQ 0x20(SP), BP			
  0x448f4d		488b442430		MOVQ 0x30(SP), AX			
  0x448f52		48890424		MOVQ AX, 0(SP)				
  0x448f56		488b4c2438		MOVQ 0x38(SP), CX			
  0x448f5b		48894c2408		MOVQ CX, 0x8(SP)			
  0x448f60		48c74424101a000000	MOVQ $0x1a, 0x10(SP)			
  0x448f69		e8a2cbfbff		CALL runtime.memhash(SB)		
  0x448f6e		488b442418		MOVQ 0x18(SP), AX			
  0x448f73		488b4c2430		MOVQ 0x30(SP), CX			
  0x448f78		4883c11c		ADDQ $0x1c, CX				
  0x448f7c		48890c24		MOVQ CX, 0(SP)				
  0x448f80		4889442408		MOVQ AX, 0x8(SP)			
  0x448f85		48c744241044000000	MOVQ $0x44, 0x10(SP)			
  0x448f8e		e87dcbfbff		CALL runtime.memhash(SB)		
  0x448f93		488b442418		MOVQ 0x18(SP), AX			
  0x448f98		4889442440		MOVQ AX, 0x40(SP)			
  0x448f9d		488b6c2420		MOVQ 0x20(SP), BP			
  0x448fa2		4883c428		ADDQ $0x28, SP				
  0x448fa6		c3			RET					
  0x448fa7		e8c4b5ffff		CALL runtime.morestack_noctxt(SB)	
  0x448fac		eb82			JMP type..hash.runtime.hchan(SB)	

TEXT type..eq.runtime.hchan(SB) <autogenerated>

  0x448fb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448fb9		483b6110		CMPQ 0x10(CX), SP			
  0x448fbd		7678			JBE 0x449037				
  0x448fbf		4883ec28		SUBQ $0x28, SP				
  0x448fc3		48896c2420		MOVQ BP, 0x20(SP)			
  0x448fc8		488d6c2420		LEAQ 0x20(SP), BP			
  0x448fcd		488b442438		MOVQ 0x38(SP), AX			
  0x448fd2		4889442408		MOVQ AX, 0x8(SP)			
  0x448fd7		488b4c2430		MOVQ 0x30(SP), CX			
  0x448fdc		48890c24		MOVQ CX, 0(SP)				
  0x448fe0		48c74424101a000000	MOVQ $0x1a, 0x10(SP)			
  0x448fe9		e852d3ffff		CALL runtime.memequal(SB)		
  0x448fee		0fb6442418		MOVZX 0x18(SP), AX			
  0x448ff3		84c0			TESTL AL, AL				
  0x448ff5		7510			JNE 0x449007				
  0x448ff7		31c0			XORL AX, AX				
  0x448ff9		88442440		MOVB AL, 0x40(SP)			
  0x448ffd		488b6c2420		MOVQ 0x20(SP), BP			
  0x449002		4883c428		ADDQ $0x28, SP				
  0x449006		c3			RET					
  0x449007		488b442438		MOVQ 0x38(SP), AX			
  0x44900c		4883c01c		ADDQ $0x1c, AX				
  0x449010		4889442408		MOVQ AX, 0x8(SP)			
  0x449015		488b442430		MOVQ 0x30(SP), AX			
  0x44901a		4883c01c		ADDQ $0x1c, AX				
  0x44901e		48890424		MOVQ AX, 0(SP)				
  0x449022		48c744241044000000	MOVQ $0x44, 0x10(SP)			
  0x44902b		e810d3ffff		CALL runtime.memequal(SB)		
  0x449030		0fb6442418		MOVZX 0x18(SP), AX			
  0x449035		ebc2			JMP 0x448ff9				
  0x449037		e834b5ffff		CALL runtime.morestack_noctxt(SB)	
  0x44903c		e96fffffff		JMP type..eq.runtime.hchan(SB)		

TEXT type..hash.runtime.sudog(SB) <autogenerated>

  0x449050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449059		483b6110		CMPQ 0x10(CX), SP			
  0x44905d		0f868d000000		JBE 0x4490f0				
  0x449063		4883ec28		SUBQ $0x28, SP				
  0x449067		48896c2420		MOVQ BP, 0x20(SP)			
  0x44906c		488d6c2420		LEAQ 0x20(SP), BP			
  0x449071		488b442430		MOVQ 0x30(SP), AX			
  0x449076		48890424		MOVQ AX, 0(SP)				
  0x44907a		488b4c2438		MOVQ 0x38(SP), CX			
  0x44907f		48894c2408		MOVQ CX, 0x8(SP)			
  0x449084		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44908d		e87ecafbff		CALL runtime.memhash(SB)		
  0x449092		488b442418		MOVQ 0x18(SP), AX			
  0x449097		488b4c2430		MOVQ 0x30(SP), CX			
  0x44909c		488d5110		LEAQ 0x10(CX), DX			
  0x4490a0		48891424		MOVQ DX, 0(SP)				
  0x4490a4		4889442408		MOVQ AX, 0x8(SP)			
  0x4490a9		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x4490b2		e859cafbff		CALL runtime.memhash(SB)		
  0x4490b7		488b442418		MOVQ 0x18(SP), AX			
  0x4490bc		488b4c2430		MOVQ 0x30(SP), CX			
  0x4490c1		4883c140		ADDQ $0x40, CX				
  0x4490c5		48890c24		MOVQ CX, 0(SP)				
  0x4490c9		4889442408		MOVQ AX, 0x8(SP)			
  0x4490ce		48c744241020000000	MOVQ $0x20, 0x10(SP)			
  0x4490d7		e834cafbff		CALL runtime.memhash(SB)		
  0x4490dc		488b442418		MOVQ 0x18(SP), AX			
  0x4490e1		4889442440		MOVQ AX, 0x40(SP)			
  0x4490e6		488b6c2420		MOVQ 0x20(SP), BP			
  0x4490eb		4883c428		ADDQ $0x28, SP				
  0x4490ef		c3			RET					
  0x4490f0		e87bb4ffff		CALL runtime.morestack_noctxt(SB)	
  0x4490f5		e956ffffff		JMP type..hash.runtime.sudog(SB)	

TEXT type..eq.runtime.sudog(SB) <autogenerated>

  0x449100		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449109		483b6110		CMPQ 0x10(CX), SP			
  0x44910d		0f869f000000		JBE 0x4491b2				
  0x449113		4883ec28		SUBQ $0x28, SP				
  0x449117		48896c2420		MOVQ BP, 0x20(SP)			
  0x44911c		488d6c2420		LEAQ 0x20(SP), BP			
  0x449121		488b442430		MOVQ 0x30(SP), AX			
  0x449126		488b08			MOVQ 0(AX), CX				
  0x449129		488b542438		MOVQ 0x38(SP), DX			
  0x44912e		488b1a			MOVQ 0(DX), BX				
  0x449131		4839d9			CMPQ BX, CX				
  0x449134		7578			JNE 0x4491ae				
  0x449136		0fb64808		MOVZX 0x8(AX), CX			
  0x44913a		0fb65a08		MOVZX 0x8(DX), BX			
  0x44913e		38d9			CMPL BL, CL				
  0x449140		743c			JE 0x44917e				
  0x449142		31c9			XORL CX, CX				
  0x449144		84c9			TESTL CL, CL				
  0x449146		7510			JNE 0x449158				
  0x449148		31c0			XORL AX, AX				
  0x44914a		88442440		MOVB AL, 0x40(SP)			
  0x44914e		488b6c2420		MOVQ 0x20(SP), BP			
  0x449153		4883c428		ADDQ $0x28, SP				
  0x449157		c3			RET					
  0x449158		488d4a40		LEAQ 0x40(DX), CX			
  0x44915c		48894c2408		MOVQ CX, 0x8(SP)			
  0x449161		4883c040		ADDQ $0x40, AX				
  0x449165		48890424		MOVQ AX, 0(SP)				
  0x449169		48c744241020000000	MOVQ $0x20, 0x10(SP)			
  0x449172		e8c9d1ffff		CALL runtime.memequal(SB)		
  0x449177		0fb6442418		MOVZX 0x18(SP), AX			
  0x44917c		ebcc			JMP 0x44914a				
  0x44917e		488d4a10		LEAQ 0x10(DX), CX			
  0x449182		48894c2408		MOVQ CX, 0x8(SP)			
  0x449187		488d4810		LEAQ 0x10(AX), CX			
  0x44918b		48890c24		MOVQ CX, 0(SP)				
  0x44918f		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x449198		e8a3d1ffff		CALL runtime.memequal(SB)		
  0x44919d		0fb64c2418		MOVZX 0x18(SP), CX			
  0x4491a2		488b442430		MOVQ 0x30(SP), AX			
  0x4491a7		488b542438		MOVQ 0x38(SP), DX			
  0x4491ac		eb96			JMP 0x449144				
  0x4491ae		31c9			XORL CX, CX				
  0x4491b0		eb92			JMP 0x449144				
  0x4491b2		e8b9b3ffff		CALL runtime.morestack_noctxt(SB)	
  0x4491b7		e944ffffff		JMP type..eq.runtime.sudog(SB)		

TEXT type..hash.runtime.cpuProfile(SB) <autogenerated>

  0x4491c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4491c9		483b6110		CMPQ 0x10(CX), SP			
  0x4491cd		7668			JBE 0x449237				
  0x4491cf		4883ec28		SUBQ $0x28, SP				
  0x4491d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4491d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4491dd		488b442430		MOVQ 0x30(SP), AX			
  0x4491e2		48890424		MOVQ AX, 0(SP)				
  0x4491e6		488b4c2438		MOVQ 0x38(SP), CX			
  0x4491eb		48894c2408		MOVQ CX, 0x8(SP)			
  0x4491f0		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x4491f9		e812c9fbff		CALL runtime.memhash(SB)		
  0x4491fe		488b442418		MOVQ 0x18(SP), AX			
  0x449203		488b4c2430		MOVQ 0x30(SP), CX			
  0x449208		4883c110		ADDQ $0x10, CX				
  0x44920c		48890c24		MOVQ CX, 0(SP)				
  0x449210		4889442408		MOVQ AX, 0x8(SP)			
  0x449215		48c7442410581f0000	MOVQ $0x1f58, 0x10(SP)			
  0x44921e		e8edc8fbff		CALL runtime.memhash(SB)		
  0x449223		488b442418		MOVQ 0x18(SP), AX			
  0x449228		4889442440		MOVQ AX, 0x40(SP)			
  0x44922d		488b6c2420		MOVQ 0x20(SP), BP			
  0x449232		4883c428		ADDQ $0x28, SP				
  0x449236		c3			RET					
  0x449237		e834b3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44923c		eb82			JMP type..hash.runtime.cpuProfile(SB)	

TEXT type..eq.runtime.cpuProfile(SB) <autogenerated>

  0x449240		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449249		483b6110		CMPQ 0x10(CX), SP			
  0x44924d		7669			JBE 0x4492b8				
  0x44924f		4883ec28		SUBQ $0x28, SP				
  0x449253		48896c2420		MOVQ BP, 0x20(SP)			
  0x449258		488d6c2420		LEAQ 0x20(SP), BP			
  0x44925d		488b442438		MOVQ 0x38(SP), AX			
  0x449262		488b08			MOVQ 0(AX), CX				
  0x449265		488b542430		MOVQ 0x30(SP), DX			
  0x44926a		488b1a			MOVQ 0(DX), BX				
  0x44926d		4839cb			CMPQ CX, BX				
  0x449270		7542			JNE 0x4492b4				
  0x449272		0fb64a08		MOVZX 0x8(DX), CX			
  0x449276		0fb65808		MOVZX 0x8(AX), BX			
  0x44927a		38d9			CMPL BL, CL				
  0x44927c		7410			JE 0x44928e				
  0x44927e		31c0			XORL AX, AX				
  0x449280		88442440		MOVB AL, 0x40(SP)			
  0x449284		488b6c2420		MOVQ 0x20(SP), BP			
  0x449289		4883c428		ADDQ $0x28, SP				
  0x44928d		c3			RET					
  0x44928e		4883c010		ADDQ $0x10, AX				
  0x449292		4889442408		MOVQ AX, 0x8(SP)			
  0x449297		488d4210		LEAQ 0x10(DX), AX			
  0x44929b		48890424		MOVQ AX, 0(SP)				
  0x44929f		48c7442410581f0000	MOVQ $0x1f58, 0x10(SP)			
  0x4492a8		e893d0ffff		CALL runtime.memequal(SB)		
  0x4492ad		0fb6442418		MOVZX 0x18(SP), AX			
  0x4492b2		ebcc			JMP 0x449280				
  0x4492b4		31c0			XORL AX, AX				
  0x4492b6		ebc8			JMP 0x449280				
  0x4492b8		e8b3b2ffff		CALL runtime.morestack_noctxt(SB)	
  0x4492bd		eb81			JMP type..eq.runtime.cpuProfile(SB)	

TEXT type..hash.runtime.dbgVar(SB) <autogenerated>

  0x4492c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4492c9		483b6110		CMPQ 0x10(CX), SP			
  0x4492cd		765f			JBE 0x44932e				
  0x4492cf		4883ec28		SUBQ $0x28, SP				
  0x4492d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4492d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4492dd		488b442430		MOVQ 0x30(SP), AX			
  0x4492e2		48890424		MOVQ AX, 0(SP)				
  0x4492e6		488b4c2438		MOVQ 0x38(SP), CX			
  0x4492eb		48894c2408		MOVQ CX, 0x8(SP)			
  0x4492f0		e88b7efbff		CALL runtime.strhash(SB)		
  0x4492f5		488b442410		MOVQ 0x10(SP), AX			
  0x4492fa		488b4c2430		MOVQ 0x30(SP), CX			
  0x4492ff		4883c110		ADDQ $0x10, CX				
  0x449303		48890c24		MOVQ CX, 0(SP)				
  0x449307		4889442408		MOVQ AX, 0x8(SP)			
  0x44930c		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x449315		e8f6c7fbff		CALL runtime.memhash(SB)		
  0x44931a		488b442418		MOVQ 0x18(SP), AX			
  0x44931f		4889442440		MOVQ AX, 0x40(SP)			
  0x449324		488b6c2420		MOVQ 0x20(SP), BP			
  0x449329		4883c428		ADDQ $0x28, SP				
  0x44932d		c3			RET					
  0x44932e		e83db2ffff		CALL runtime.morestack_noctxt(SB)	
  0x449333		eb8b			JMP type..hash.runtime.dbgVar(SB)	

TEXT type..eq.runtime.dbgVar(SB) <autogenerated>

  0x449340		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449349		483b6110		CMPQ 0x10(CX), SP			
  0x44934d		7675			JBE 0x4493c4				
  0x44934f		4883ec28		SUBQ $0x28, SP				
  0x449353		48896c2420		MOVQ BP, 0x20(SP)			
  0x449358		488d6c2420		LEAQ 0x20(SP), BP			
  0x44935d		488b442430		MOVQ 0x30(SP), AX			
  0x449362		488b4808		MOVQ 0x8(AX), CX			
  0x449366		488b10			MOVQ 0(AX), DX				
  0x449369		488b5c2438		MOVQ 0x38(SP), BX			
  0x44936e		488b7308		MOVQ 0x8(BX), SI			
  0x449372		488b3b			MOVQ 0(BX), DI				
  0x449375		4839f1			CMPQ SI, CX				
  0x449378		7426			JE 0x4493a0				
  0x44937a		31c9			XORL CX, CX				
  0x44937c		84c9			TESTL CL, CL				
  0x44937e		741c			JE 0x44939c				
  0x449380		488b4010		MOVQ 0x10(AX), AX			
  0x449384		488b4b10		MOVQ 0x10(BX), CX			
  0x449388		4839c8			CMPQ CX, AX				
  0x44938b		0f94c0			SETE AL					
  0x44938e		88442440		MOVB AL, 0x40(SP)			
  0x449392		488b6c2420		MOVQ 0x20(SP), BP			
  0x449397		4883c428		ADDQ $0x28, SP				
  0x44939b		c3			RET					
  0x44939c		31c0			XORL AX, AX				
  0x44939e		ebee			JMP 0x44938e				
  0x4493a0		48891424		MOVQ DX, 0(SP)				
  0x4493a4		48897c2408		MOVQ DI, 0x8(SP)			
  0x4493a9		48894c2410		MOVQ CX, 0x10(SP)			
  0x4493ae		e88dcfffff		CALL runtime.memequal(SB)		
  0x4493b3		0fb64c2418		MOVZX 0x18(SP), CX			
  0x4493b8		488b442430		MOVQ 0x30(SP), AX			
  0x4493bd		488b5c2438		MOVQ 0x38(SP), BX			
  0x4493c2		ebb8			JMP 0x44937c				
  0x4493c4		e8a7b1ffff		CALL runtime.morestack_noctxt(SB)	
  0x4493c9		e972ffffff		JMP type..eq.runtime.dbgVar(SB)		

TEXT runtime.(*errorString).Error(SB) <autogenerated>

  0x4493d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4493d9		483b6110		CMPQ 0x10(CX), SP	
  0x4493dd		7679			JBE 0x449458		
  0x4493df		4883ec40		SUBQ $0x40, SP		
  0x4493e3		48896c2438		MOVQ BP, 0x38(SP)	
  0x4493e8		488d6c2438		LEAQ 0x38(SP), BP	
  0x4493ed		488b5920		MOVQ 0x20(CX), BX	
  0x4493f1		4885db			TESTQ BX, BX		
  0x4493f4		756c			JNE 0x449462		
  0x4493f6		488b442448		MOVQ 0x48(SP), AX	
  0x4493fb		4885c0			TESTQ AX, AX		
  0x4493fe		7451			JE 0x449451		
  0x449400		488b4808		MOVQ 0x8(AX), CX	
  0x449404		488b00			MOVQ 0(AX), AX		
	return "runtime error: " + string(e)
  0x449407		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x44940f		488d1591150200		LEAQ 0x21591(IP), DX		
  0x449416		4889542408		MOVQ DX, 0x8(SP)		
  0x44941b		48c74424100f000000	MOVQ $0xf, 0x10(SP)		
  0x449424		4889442418		MOVQ AX, 0x18(SP)		
  0x449429		48894c2420		MOVQ CX, 0x20(SP)		
  0x44942e		e8addbfeff		CALL runtime.concatstring2(SB)	
  0x449433		488b442428		MOVQ 0x28(SP), AX		
  0x449438		488b4c2430		MOVQ 0x30(SP), CX		

  0x44943d		4889442450		MOVQ AX, 0x50(SP)			
  0x449442		48894c2458		MOVQ CX, 0x58(SP)			
  0x449447		488b6c2438		MOVQ 0x38(SP), BP			
  0x44944c		4883c440		ADDQ $0x40, SP				
  0x449450		c3			RET					
  0x449451		e89ac2fbff		CALL runtime.panicwrap(SB)		
  0x449456		0f0b			UD2					
  0x449458		e813b1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44945d		e96effffff		JMP runtime.(*errorString).Error(SB)	
  0x449462		488d7c2448		LEAQ 0x48(SP), DI			
  0x449467		48393b			CMPQ DI, 0(BX)				
  0x44946a		758a			JNE 0x4493f6				
  0x44946c		488923			MOVQ SP, 0(BX)				
  0x44946f		eb85			JMP 0x4493f6				

TEXT type..hash.runtime.finblock(SB) <autogenerated>

  0x449480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449489		483b6110		CMPQ 0x10(CX), SP			
  0x44948d		7668			JBE 0x4494f7				
  0x44948f		4883ec28		SUBQ $0x28, SP				
  0x449493		48896c2420		MOVQ BP, 0x20(SP)			
  0x449498		488d6c2420		LEAQ 0x20(SP), BP			
  0x44949d		488b442430		MOVQ 0x30(SP), AX			
  0x4494a2		48890424		MOVQ AX, 0(SP)				
  0x4494a6		488b4c2438		MOVQ 0x38(SP), CX			
  0x4494ab		48894c2408		MOVQ CX, 0x8(SP)			
  0x4494b0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x4494b9		e852c6fbff		CALL runtime.memhash(SB)		
  0x4494be		488b442418		MOVQ 0x18(SP), AX			
  0x4494c3		488b4c2430		MOVQ 0x30(SP), CX			
  0x4494c8		4883c118		ADDQ $0x18, CX				
  0x4494cc		48890c24		MOVQ CX, 0(SP)				
  0x4494d0		4889442408		MOVQ AX, 0x8(SP)			
  0x4494d5		48c7442410c80f0000	MOVQ $0xfc8, 0x10(SP)			
  0x4494de		e82dc6fbff		CALL runtime.memhash(SB)		
  0x4494e3		488b442418		MOVQ 0x18(SP), AX			
  0x4494e8		4889442440		MOVQ AX, 0x40(SP)			
  0x4494ed		488b6c2420		MOVQ 0x20(SP), BP			
  0x4494f2		4883c428		ADDQ $0x28, SP				
  0x4494f6		c3			RET					
  0x4494f7		e874b0ffff		CALL runtime.morestack_noctxt(SB)	
  0x4494fc		eb82			JMP type..hash.runtime.finblock(SB)	

TEXT type..eq.runtime.finblock(SB) <autogenerated>

  0x449500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449509		483b6110		CMPQ 0x10(CX), SP			
  0x44950d		7678			JBE 0x449587				
  0x44950f		4883ec28		SUBQ $0x28, SP				
  0x449513		48896c2420		MOVQ BP, 0x20(SP)			
  0x449518		488d6c2420		LEAQ 0x20(SP), BP			
  0x44951d		488b442438		MOVQ 0x38(SP), AX			
  0x449522		4889442408		MOVQ AX, 0x8(SP)			
  0x449527		488b4c2430		MOVQ 0x30(SP), CX			
  0x44952c		48890c24		MOVQ CX, 0(SP)				
  0x449530		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x449539		e802ceffff		CALL runtime.memequal(SB)		
  0x44953e		0fb6442418		MOVZX 0x18(SP), AX			
  0x449543		84c0			TESTL AL, AL				
  0x449545		7510			JNE 0x449557				
  0x449547		31c0			XORL AX, AX				
  0x449549		88442440		MOVB AL, 0x40(SP)			
  0x44954d		488b6c2420		MOVQ 0x20(SP), BP			
  0x449552		4883c428		ADDQ $0x28, SP				
  0x449556		c3			RET					
  0x449557		488b442430		MOVQ 0x30(SP), AX			
  0x44955c		4883c018		ADDQ $0x18, AX				
  0x449560		48890424		MOVQ AX, 0(SP)				
  0x449564		488b442438		MOVQ 0x38(SP), AX			
  0x449569		4883c018		ADDQ $0x18, AX				
  0x44956d		4889442408		MOVQ AX, 0x8(SP)			
  0x449572		48c7442410c80f0000	MOVQ $0xfc8, 0x10(SP)			
  0x44957b		e8c0cdffff		CALL runtime.memequal(SB)		
  0x449580		0fb6442418		MOVZX 0x18(SP), AX			
  0x449585		ebc2			JMP 0x449549				
  0x449587		e8e4afffff		CALL runtime.morestack_noctxt(SB)	
  0x44958c		e96fffffff		JMP type..eq.runtime.finblock(SB)	

TEXT type..hash.runtime.forcegcstate(SB) <autogenerated>

  0x4495a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4495a9		483b6110		CMPQ 0x10(CX), SP			
  0x4495ad		7643			JBE 0x4495f2				
  0x4495af		4883ec28		SUBQ $0x28, SP				
  0x4495b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4495b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4495bd		488b442430		MOVQ 0x30(SP), AX			
  0x4495c2		48890424		MOVQ AX, 0(SP)				
  0x4495c6		488b442438		MOVQ 0x38(SP), AX			
  0x4495cb		4889442408		MOVQ AX, 0x8(SP)			
  0x4495d0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x4495d9		e832c5fbff		CALL runtime.memhash(SB)		
  0x4495de		488b442418		MOVQ 0x18(SP), AX			
  0x4495e3		4889442440		MOVQ AX, 0x40(SP)			
  0x4495e8		488b6c2420		MOVQ 0x20(SP), BP			
  0x4495ed		4883c428		ADDQ $0x28, SP				
  0x4495f1		c3			RET					
  0x4495f2		e879afffff		CALL runtime.morestack_noctxt(SB)	
  0x4495f7		eba7			JMP type..hash.runtime.forcegcstate(SB)	

TEXT type..eq.runtime.forcegcstate(SB) <autogenerated>

  0x449600		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449609		483b6110		CMPQ 0x10(CX), SP			
  0x44960d		7642			JBE 0x449651				
  0x44960f		4883ec28		SUBQ $0x28, SP				
  0x449613		48896c2420		MOVQ BP, 0x20(SP)			
  0x449618		488d6c2420		LEAQ 0x20(SP), BP			
  0x44961d		488b442438		MOVQ 0x38(SP), AX			
  0x449622		4889442408		MOVQ AX, 0x8(SP)			
  0x449627		488b442430		MOVQ 0x30(SP), AX			
  0x44962c		48890424		MOVQ AX, 0(SP)				
  0x449630		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x449639		e802cdffff		CALL runtime.memequal(SB)		
  0x44963e		0fb6442418		MOVZX 0x18(SP), AX			
  0x449643		88442440		MOVB AL, 0x40(SP)			
  0x449647		488b6c2420		MOVQ 0x20(SP), BP			
  0x44964c		4883c428		ADDQ $0x28, SP				
  0x449650		c3			RET					
  0x449651		e81aafffff		CALL runtime.morestack_noctxt(SB)	
  0x449656		eba8			JMP type..eq.runtime.forcegcstate(SB)	

TEXT type..hash.runtime.gcControllerState(SB) <autogenerated>

  0x449660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x449669		483b6110		CMPQ 0x10(CX), SP				
  0x44966d		0f8697000000		JBE 0x44970a					
  0x449673		4883ec28		SUBQ $0x28, SP					
  0x449677		48896c2420		MOVQ BP, 0x20(SP)				
  0x44967c		488d6c2420		LEAQ 0x20(SP), BP				
  0x449681		488b442430		MOVQ 0x30(SP), AX				
  0x449686		48890424		MOVQ AX, 0(SP)					
  0x44968a		488b4c2438		MOVQ 0x38(SP), CX				
  0x44968f		48894c2408		MOVQ CX, 0x8(SP)				
  0x449694		48c744241040000000	MOVQ $0x40, 0x10(SP)				
  0x44969d		e86ec4fbff		CALL runtime.memhash(SB)			
  0x4496a2		488b442418		MOVQ 0x18(SP), AX				
  0x4496a7		488b4c2430		MOVQ 0x30(SP), CX				
  0x4496ac		488d5140		LEAQ 0x40(CX), DX				
  0x4496b0		48891424		MOVQ DX, 0(SP)					
  0x4496b4		4889442408		MOVQ AX, 0x8(SP)				
  0x4496b9		e8427cfbff		CALL runtime.f64hash(SB)			
  0x4496be		488b442410		MOVQ 0x10(SP), AX				
  0x4496c3		488b4c2430		MOVQ 0x30(SP), CX				
  0x4496c8		488d5148		LEAQ 0x48(CX), DX				
  0x4496cc		48891424		MOVQ DX, 0(SP)					
  0x4496d0		4889442408		MOVQ AX, 0x8(SP)				
  0x4496d5		e8267cfbff		CALL runtime.f64hash(SB)			
  0x4496da		488b442410		MOVQ 0x10(SP), AX				
  0x4496df		488b4c2430		MOVQ 0x30(SP), CX				
  0x4496e4		4883c150		ADDQ $0x50, CX					
  0x4496e8		48890c24		MOVQ CX, 0(SP)					
  0x4496ec		4889442408		MOVQ AX, 0x8(SP)				
  0x4496f1		e80a7cfbff		CALL runtime.f64hash(SB)			
  0x4496f6		488b442410		MOVQ 0x10(SP), AX				
  0x4496fb		4889442440		MOVQ AX, 0x40(SP)				
  0x449700		488b6c2420		MOVQ 0x20(SP), BP				
  0x449705		4883c428		ADDQ $0x28, SP					
  0x449709		c3			RET						
  0x44970a		e861aeffff		CALL runtime.morestack_noctxt(SB)		
  0x44970f		e94cffffff		JMP type..hash.runtime.gcControllerState(SB)	

TEXT type..eq.runtime.gcControllerState(SB) <autogenerated>

  0x449720		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x449729		483b6110		CMPQ 0x10(CX), SP				
  0x44972d		0f8696000000		JBE 0x4497c9					
  0x449733		4883ec28		SUBQ $0x28, SP					
  0x449737		48896c2420		MOVQ BP, 0x20(SP)				
  0x44973c		488d6c2420		LEAQ 0x20(SP), BP				
  0x449741		488b442438		MOVQ 0x38(SP), AX				
  0x449746		4889442408		MOVQ AX, 0x8(SP)				
  0x44974b		488b4c2430		MOVQ 0x30(SP), CX				
  0x449750		48890c24		MOVQ CX, 0(SP)					
  0x449754		48c744241040000000	MOVQ $0x40, 0x10(SP)				
  0x44975d		e8decbffff		CALL runtime.memequal(SB)			
  0x449762		0fb6442418		MOVZX 0x18(SP), AX				
  0x449767		84c0			TESTL AL, AL					
  0x449769		745a			JE 0x4497c5					
  0x44976b		488b442430		MOVQ 0x30(SP), AX				
  0x449770		f20f104040		MOVSD_XMM 0x40(AX), X0				
  0x449775		488b4c2438		MOVQ 0x38(SP), CX				
  0x44977a		f20f104940		MOVSD_XMM 0x40(CX), X1				
  0x44977f		660f2ec1		UCOMISD X1, X0					
  0x449783		753c			JNE 0x4497c1					
  0x449785		7a3a			JP 0x4497c1					
  0x449787		f20f104048		MOVSD_XMM 0x48(AX), X0				
  0x44978c		f20f104948		MOVSD_XMM 0x48(CX), X1				
  0x449791		660f2ec1		UCOMISD X1, X0					
  0x449795		7526			JNE 0x4497bd					
  0x449797		7a24			JP 0x4497bd					
  0x449799		f20f104050		MOVSD_XMM 0x50(AX), X0				
  0x44979e		f20f104950		MOVSD_XMM 0x50(CX), X1				
  0x4497a3		660f2ec8		UCOMISD X0, X1					
  0x4497a7		0f94c1			SETE CL						
  0x4497aa		0f9bc0			SETNP AL					
  0x4497ad		21c1			ANDL AX, CX					
  0x4497af		884c2440		MOVB CL, 0x40(SP)				
  0x4497b3		488b6c2420		MOVQ 0x20(SP), BP				
  0x4497b8		4883c428		ADDQ $0x28, SP					
  0x4497bc		c3			RET						
  0x4497bd		31c9			XORL CX, CX					
  0x4497bf		ebee			JMP 0x4497af					
  0x4497c1		31c9			XORL CX, CX					
  0x4497c3		ebea			JMP 0x4497af					
  0x4497c5		31c9			XORL CX, CX					
  0x4497c7		ebe6			JMP 0x4497af					
  0x4497c9		e8a2adffff		CALL runtime.morestack_noctxt(SB)		
  0x4497ce		e94dffffff		JMP type..eq.runtime.gcControllerState(SB)	

TEXT type..hash.runtime.gcSweepBuf(SB) <autogenerated>

  0x4497e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4497e9		483b6110		CMPQ 0x10(CX), SP			
  0x4497ed		7643			JBE 0x449832				
  0x4497ef		4883ec28		SUBQ $0x28, SP				
  0x4497f3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4497f8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4497fd		488b442430		MOVQ 0x30(SP), AX			
  0x449802		48890424		MOVQ AX, 0(SP)				
  0x449806		488b442438		MOVQ 0x38(SP), AX			
  0x44980b		4889442408		MOVQ AX, 0x8(SP)			
  0x449810		48c744241024000000	MOVQ $0x24, 0x10(SP)			
  0x449819		e8f2c2fbff		CALL runtime.memhash(SB)		
  0x44981e		488b442418		MOVQ 0x18(SP), AX			
  0x449823		4889442440		MOVQ AX, 0x40(SP)			
  0x449828		488b6c2420		MOVQ 0x20(SP), BP			
  0x44982d		4883c428		ADDQ $0x28, SP				
  0x449831		c3			RET					
  0x449832		e839adffff		CALL runtime.morestack_noctxt(SB)	
  0x449837		eba7			JMP type..hash.runtime.gcSweepBuf(SB)	

TEXT type..eq.runtime.gcSweepBuf(SB) <autogenerated>

  0x449840		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449849		483b6110		CMPQ 0x10(CX), SP			
  0x44984d		7642			JBE 0x449891				
  0x44984f		4883ec28		SUBQ $0x28, SP				
  0x449853		48896c2420		MOVQ BP, 0x20(SP)			
  0x449858		488d6c2420		LEAQ 0x20(SP), BP			
  0x44985d		488b442438		MOVQ 0x38(SP), AX			
  0x449862		4889442408		MOVQ AX, 0x8(SP)			
  0x449867		488b442430		MOVQ 0x30(SP), AX			
  0x44986c		48890424		MOVQ AX, 0(SP)				
  0x449870		48c744241024000000	MOVQ $0x24, 0x10(SP)			
  0x449879		e8c2caffff		CALL runtime.memequal(SB)		
  0x44987e		0fb6442418		MOVZX 0x18(SP), AX			
  0x449883		88442440		MOVB AL, 0x40(SP)			
  0x449887		488b6c2420		MOVQ 0x20(SP), BP			
  0x44988c		4883c428		ADDQ $0x28, SP				
  0x449890		c3			RET					
  0x449891		e8daacffff		CALL runtime.morestack_noctxt(SB)	
  0x449896		eba8			JMP type..eq.runtime.gcSweepBuf(SB)	

TEXT type..hash.runtime.gcTrigger(SB) <autogenerated>

  0x4498a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4498a9		483b6110		CMPQ 0x10(CX), SP			
  0x4498ad		7643			JBE 0x4498f2				
  0x4498af		4883ec28		SUBQ $0x28, SP				
  0x4498b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x4498b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x4498bd		488b442430		MOVQ 0x30(SP), AX			
  0x4498c2		48890424		MOVQ AX, 0(SP)				
  0x4498c6		488b442438		MOVQ 0x38(SP), AX			
  0x4498cb		4889442408		MOVQ AX, 0x8(SP)			
  0x4498d0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x4498d9		e832c2fbff		CALL runtime.memhash(SB)		
  0x4498de		488b442418		MOVQ 0x18(SP), AX			
  0x4498e3		4889442440		MOVQ AX, 0x40(SP)			
  0x4498e8		488b6c2420		MOVQ 0x20(SP), BP			
  0x4498ed		4883c428		ADDQ $0x28, SP				
  0x4498f1		c3			RET					
  0x4498f2		e879acffff		CALL runtime.morestack_noctxt(SB)	
  0x4498f7		eba7			JMP type..hash.runtime.gcTrigger(SB)	

TEXT type..eq.runtime.gcTrigger(SB) <autogenerated>

  0x449900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449909		483b6110		CMPQ 0x10(CX), SP			
  0x44990d		7642			JBE 0x449951				
  0x44990f		4883ec28		SUBQ $0x28, SP				
  0x449913		48896c2420		MOVQ BP, 0x20(SP)			
  0x449918		488d6c2420		LEAQ 0x20(SP), BP			
  0x44991d		488b442438		MOVQ 0x38(SP), AX			
  0x449922		4889442408		MOVQ AX, 0x8(SP)			
  0x449927		488b442430		MOVQ 0x30(SP), AX			
  0x44992c		48890424		MOVQ AX, 0(SP)				
  0x449930		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x449939		e802caffff		CALL runtime.memequal(SB)		
  0x44993e		0fb6442418		MOVZX 0x18(SP), AX			
  0x449943		88442440		MOVB AL, 0x40(SP)			
  0x449947		488b6c2420		MOVQ 0x20(SP), BP			
  0x44994c		4883c428		ADDQ $0x28, SP				
  0x449950		c3			RET					
  0x449951		e81aacffff		CALL runtime.morestack_noctxt(SB)	
  0x449956		eba8			JMP type..eq.runtime.gcTrigger(SB)	

TEXT type..hash.runtime.heapBits(SB) <autogenerated>

  0x449960		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449969		483b6110		CMPQ 0x10(CX), SP			
  0x44996d		7643			JBE 0x4499b2				
  0x44996f		4883ec28		SUBQ $0x28, SP				
  0x449973		48896c2420		MOVQ BP, 0x20(SP)			
  0x449978		488d6c2420		LEAQ 0x20(SP), BP			
  0x44997d		488b442430		MOVQ 0x30(SP), AX			
  0x449982		48890424		MOVQ AX, 0(SP)				
  0x449986		488b442438		MOVQ 0x38(SP), AX			
  0x44998b		4889442408		MOVQ AX, 0x8(SP)			
  0x449990		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x449999		e872c1fbff		CALL runtime.memhash(SB)		
  0x44999e		488b442418		MOVQ 0x18(SP), AX			
  0x4499a3		4889442440		MOVQ AX, 0x40(SP)			
  0x4499a8		488b6c2420		MOVQ 0x20(SP), BP			
  0x4499ad		4883c428		ADDQ $0x28, SP				
  0x4499b1		c3			RET					
  0x4499b2		e8b9abffff		CALL runtime.morestack_noctxt(SB)	
  0x4499b7		eba7			JMP type..hash.runtime.heapBits(SB)	

TEXT type..eq.runtime.heapBits(SB) <autogenerated>

  0x4499c0		488b442408		MOVQ 0x8(SP), AX	
  0x4499c5		488b08			MOVQ 0(AX), CX		
  0x4499c8		488b542410		MOVQ 0x10(SP), DX	
  0x4499cd		488b1a			MOVQ 0(DX), BX		
  0x4499d0		4839d9			CMPQ BX, CX		
  0x4499d3		7510			JNE 0x4499e5		
  0x4499d5		8b4008			MOVL 0x8(AX), AX	
  0x4499d8		8b4a08			MOVL 0x8(DX), CX	
  0x4499db		39c8			CMPL CX, AX		
  0x4499dd		0f94c0			SETE AL			
  0x4499e0		88442418		MOVB AL, 0x18(SP)	
  0x4499e4		c3			RET			
  0x4499e5		31c0			XORL AX, AX		
  0x4499e7		ebf7			JMP 0x4499e0		

TEXT type..hash.runtime.treapNode(SB) <autogenerated>

  0x4499f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4499f9		483b6110		CMPQ 0x10(CX), SP			
  0x4499fd		7643			JBE 0x449a42				
  0x4499ff		4883ec28		SUBQ $0x28, SP				
  0x449a03		48896c2420		MOVQ BP, 0x20(SP)			
  0x449a08		488d6c2420		LEAQ 0x20(SP), BP			
  0x449a0d		488b442430		MOVQ 0x30(SP), AX			
  0x449a12		48890424		MOVQ AX, 0(SP)				
  0x449a16		488b442438		MOVQ 0x38(SP), AX			
  0x449a1b		4889442408		MOVQ AX, 0x8(SP)			
  0x449a20		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x449a29		e8e2c0fbff		CALL runtime.memhash(SB)		
  0x449a2e		488b442418		MOVQ 0x18(SP), AX			
  0x449a33		4889442440		MOVQ AX, 0x40(SP)			
  0x449a38		488b6c2420		MOVQ 0x20(SP), BP			
  0x449a3d		4883c428		ADDQ $0x28, SP				
  0x449a41		c3			RET					
  0x449a42		e829abffff		CALL runtime.morestack_noctxt(SB)	
  0x449a47		eba7			JMP type..hash.runtime.treapNode(SB)	

TEXT type..eq.runtime.treapNode(SB) <autogenerated>

  0x449a50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449a59		483b6110		CMPQ 0x10(CX), SP			
  0x449a5d		7642			JBE 0x449aa1				
  0x449a5f		4883ec28		SUBQ $0x28, SP				
  0x449a63		48896c2420		MOVQ BP, 0x20(SP)			
  0x449a68		488d6c2420		LEAQ 0x20(SP), BP			
  0x449a6d		488b442438		MOVQ 0x38(SP), AX			
  0x449a72		4889442408		MOVQ AX, 0x8(SP)			
  0x449a77		488b442430		MOVQ 0x30(SP), AX			
  0x449a7c		48890424		MOVQ AX, 0(SP)				
  0x449a80		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x449a89		e8b2c8ffff		CALL runtime.memequal(SB)		
  0x449a8e		0fb6442418		MOVZX 0x18(SP), AX			
  0x449a93		88442440		MOVB AL, 0x40(SP)			
  0x449a97		488b6c2420		MOVQ 0x20(SP), BP			
  0x449a9c		4883c428		ADDQ $0x28, SP				
  0x449aa0		c3			RET					
  0x449aa1		e8caaaffff		CALL runtime.morestack_noctxt(SB)	
  0x449aa6		eba8			JMP type..eq.runtime.treapNode(SB)	

TEXT type..hash.runtime.mcentral(SB) <autogenerated>

  0x449ab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449ab9		483b6110		CMPQ 0x10(CX), SP			
  0x449abd		7668			JBE 0x449b27				
  0x449abf		4883ec28		SUBQ $0x28, SP				
  0x449ac3		48896c2420		MOVQ BP, 0x20(SP)			
  0x449ac8		488d6c2420		LEAQ 0x20(SP), BP			
  0x449acd		488b442430		MOVQ 0x30(SP), AX			
  0x449ad2		48890424		MOVQ AX, 0(SP)				
  0x449ad6		488b4c2438		MOVQ 0x38(SP), CX			
  0x449adb		48894c2408		MOVQ CX, 0x8(SP)			
  0x449ae0		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x449ae9		e822c0fbff		CALL runtime.memhash(SB)		
  0x449aee		488b442418		MOVQ 0x18(SP), AX			
  0x449af3		488b4c2430		MOVQ 0x30(SP), CX			
  0x449af8		4883c110		ADDQ $0x10, CX				
  0x449afc		48890c24		MOVQ CX, 0(SP)				
  0x449b00		4889442408		MOVQ AX, 0x8(SP)			
  0x449b05		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x449b0e		e8fdbffbff		CALL runtime.memhash(SB)		
  0x449b13		488b442418		MOVQ 0x18(SP), AX			
  0x449b18		4889442440		MOVQ AX, 0x40(SP)			
  0x449b1d		488b6c2420		MOVQ 0x20(SP), BP			
  0x449b22		4883c428		ADDQ $0x28, SP				
  0x449b26		c3			RET					
  0x449b27		e844aaffff		CALL runtime.morestack_noctxt(SB)	
  0x449b2c		eb82			JMP type..hash.runtime.mcentral(SB)	

TEXT type..eq.runtime.mcentral(SB) <autogenerated>

  0x449b30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449b39		483b6110		CMPQ 0x10(CX), SP			
  0x449b3d		7669			JBE 0x449ba8				
  0x449b3f		4883ec28		SUBQ $0x28, SP				
  0x449b43		48896c2420		MOVQ BP, 0x20(SP)			
  0x449b48		488d6c2420		LEAQ 0x20(SP), BP			
  0x449b4d		488b442438		MOVQ 0x38(SP), AX			
  0x449b52		488b08			MOVQ 0(AX), CX				
  0x449b55		488b542430		MOVQ 0x30(SP), DX			
  0x449b5a		488b1a			MOVQ 0(DX), BX				
  0x449b5d		4839cb			CMPQ CX, BX				
  0x449b60		7542			JNE 0x449ba4				
  0x449b62		0fb64a08		MOVZX 0x8(DX), CX			
  0x449b66		0fb65808		MOVZX 0x8(AX), BX			
  0x449b6a		38d9			CMPL BL, CL				
  0x449b6c		7410			JE 0x449b7e				
  0x449b6e		31c0			XORL AX, AX				
  0x449b70		88442440		MOVB AL, 0x40(SP)			
  0x449b74		488b6c2420		MOVQ 0x20(SP), BP			
  0x449b79		4883c428		ADDQ $0x28, SP				
  0x449b7d		c3			RET					
  0x449b7e		4883c010		ADDQ $0x10, AX				
  0x449b82		4889442408		MOVQ AX, 0x8(SP)			
  0x449b87		488d4210		LEAQ 0x10(DX), AX			
  0x449b8b		48890424		MOVQ AX, 0(SP)				
  0x449b8f		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x449b98		e8a3c7ffff		CALL runtime.memequal(SB)		
  0x449b9d		0fb6442418		MOVZX 0x18(SP), AX			
  0x449ba2		ebcc			JMP 0x449b70				
  0x449ba4		31c0			XORL AX, AX				
  0x449ba6		ebc8			JMP 0x449b70				
  0x449ba8		e8c3a9ffff		CALL runtime.morestack_noctxt(SB)	
  0x449bad		eb81			JMP type..eq.runtime.mcentral(SB)	

TEXT type..hash.[2]runtime.gcSweepBuf(SB) <autogenerated>

  0x449bb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x449bb9		483b6110		CMPQ 0x10(CX), SP				
  0x449bbd		7659			JBE 0x449c18					
  0x449bbf		4883ec28		SUBQ $0x28, SP					
  0x449bc3		48896c2420		MOVQ BP, 0x20(SP)				
  0x449bc8		488d6c2420		LEAQ 0x20(SP), BP				
  0x449bcd		31c0			XORL AX, AX					
  0x449bcf		488b4c2438		MOVQ 0x38(SP), CX				
  0x449bd4		eb2d			JMP 0x449c03					
  0x449bd6		4889442418		MOVQ AX, 0x18(SP)				
  0x449bdb		488d1480		LEAQ 0(AX)(AX*4), DX				
  0x449bdf		488b5c2430		MOVQ 0x30(SP), BX				
  0x449be4		488d14d3		LEAQ 0(BX)(DX*8), DX				
  0x449be8		48891424		MOVQ DX, 0(SP)					
  0x449bec		48894c2408		MOVQ CX, 0x8(SP)				
  0x449bf1		e8eafbffff		CALL type..hash.runtime.gcSweepBuf(SB)		
  0x449bf6		488b4c2410		MOVQ 0x10(SP), CX				
  0x449bfb		488b442418		MOVQ 0x18(SP), AX				
  0x449c00		48ffc0			INCQ AX						
  0x449c03		4883f802		CMPQ $0x2, AX					
  0x449c07		7ccd			JL 0x449bd6					
  0x449c09		48894c2440		MOVQ CX, 0x40(SP)				
  0x449c0e		488b6c2420		MOVQ 0x20(SP), BP				
  0x449c13		4883c428		ADDQ $0x28, SP					
  0x449c17		c3			RET						
  0x449c18		e853a9ffff		CALL runtime.morestack_noctxt(SB)		
  0x449c1d		eb91			JMP type..hash.[2]runtime.gcSweepBuf(SB)	

TEXT type..eq.[2]runtime.gcSweepBuf(SB) <autogenerated>

  0x449c20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449c29		483b6110		CMPQ 0x10(CX), SP			
  0x449c2d		7671			JBE 0x449ca0				
  0x449c2f		4883ec28		SUBQ $0x28, SP				
  0x449c33		48896c2420		MOVQ BP, 0x20(SP)			
  0x449c38		488d6c2420		LEAQ 0x20(SP), BP			
  0x449c3d		31c0			XORL AX, AX				
  0x449c3f		eb09			JMP 0x449c4a				
  0x449c41		488b4c2418		MOVQ 0x18(SP), CX			
  0x449c46		488d4101		LEAQ 0x1(CX), AX			
  0x449c4a		4883f802		CMPQ $0x2, AX				
  0x449c4e		7d41			JGE 0x449c91				
  0x449c50		4889442418		MOVQ AX, 0x18(SP)			
  0x449c55		488d0c80		LEAQ 0(AX)(AX*4), CX			
  0x449c59		488b542430		MOVQ 0x30(SP), DX			
  0x449c5e		488d1cca		LEAQ 0(DX)(CX*8), BX			
  0x449c62		48891c24		MOVQ BX, 0(SP)				
  0x449c66		488b5c2438		MOVQ 0x38(SP), BX			
  0x449c6b		488d0ccb		LEAQ 0(BX)(CX*8), CX			
  0x449c6f		48894c2408		MOVQ CX, 0x8(SP)			
  0x449c74		e8c7fbffff		CALL type..eq.runtime.gcSweepBuf(SB)	
  0x449c79		0fb6442410		MOVZX 0x10(SP), AX			
  0x449c7e		84c0			TESTL AL, AL				
  0x449c80		75bf			JNE 0x449c41				
  0x449c82		c644244000		MOVB $0x0, 0x40(SP)			
  0x449c87		488b6c2420		MOVQ 0x20(SP), BP			
  0x449c8c		4883c428		ADDQ $0x28, SP				
  0x449c90		c3			RET					
  0x449c91		c644244001		MOVB $0x1, 0x40(SP)			
  0x449c96		488b6c2420		MOVQ 0x20(SP), BP			
  0x449c9b		4883c428		ADDQ $0x28, SP				
  0x449c9f		c3			RET					
  0x449ca0		e8cba8ffff		CALL runtime.morestack_noctxt(SB)	
  0x449ca5		e976ffffff		JMP type..eq.[2]runtime.gcSweepBuf(SB)	

TEXT type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x449cb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x449cb9		483b6110		CMPQ 0x10(CX), SP									
  0x449cbd		765f			JBE 0x449d1e										
  0x449cbf		4883ec28		SUBQ $0x28, SP										
  0x449cc3		48896c2420		MOVQ BP, 0x20(SP)									
  0x449cc8		488d6c2420		LEAQ 0x20(SP), BP									
  0x449ccd		488b442430		MOVQ 0x30(SP), AX									
  0x449cd2		48890424		MOVQ AX, 0(SP)										
  0x449cd6		488b4c2438		MOVQ 0x38(SP), CX									
  0x449cdb		48894c2408		MOVQ CX, 0x8(SP)									
  0x449ce0		e8cbfdffff		CALL type..hash.runtime.mcentral(SB)							
  0x449ce5		488b442410		MOVQ 0x10(SP), AX									
  0x449cea		488b4c2430		MOVQ 0x30(SP), CX									
  0x449cef		4883c138		ADDQ $0x38, CX										
  0x449cf3		48890c24		MOVQ CX, 0(SP)										
  0x449cf7		4889442408		MOVQ AX, 0x8(SP)									
  0x449cfc		48c744241008000000	MOVQ $0x8, 0x10(SP)									
  0x449d05		e806befbff		CALL runtime.memhash(SB)								
  0x449d0a		488b442418		MOVQ 0x18(SP), AX									
  0x449d0f		4889442440		MOVQ AX, 0x40(SP)									
  0x449d14		488b6c2420		MOVQ 0x20(SP), BP									
  0x449d19		4883c428		ADDQ $0x28, SP										
  0x449d1d		c3			RET											
  0x449d1e		e84da8ffff		CALL runtime.morestack_noctxt(SB)							
  0x449d23		eb8b			JMP type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x449d30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x449d39		483b6110		CMPQ 0x10(CX), SP									
  0x449d3d		7659			JBE 0x449d98										
  0x449d3f		4883ec20		SUBQ $0x20, SP										
  0x449d43		48896c2418		MOVQ BP, 0x18(SP)									
  0x449d48		488d6c2418		LEAQ 0x18(SP), BP									
  0x449d4d		488b442428		MOVQ 0x28(SP), AX									
  0x449d52		48890424		MOVQ AX, 0(SP)										
  0x449d56		488b4c2430		MOVQ 0x30(SP), CX									
  0x449d5b		48894c2408		MOVQ CX, 0x8(SP)									
  0x449d60		e8cbfdffff		CALL type..eq.runtime.mcentral(SB)							
  0x449d65		0fb6442410		MOVZX 0x10(SP), AX									
  0x449d6a		84c0			TESTL AL, AL										
  0x449d6c		7426			JE 0x449d94										
  0x449d6e		488b442428		MOVQ 0x28(SP), AX									
  0x449d73		488b4038		MOVQ 0x38(AX), AX									
  0x449d77		488b4c2430		MOVQ 0x30(SP), CX									
  0x449d7c		488b4938		MOVQ 0x38(CX), CX									
  0x449d80		4839c8			CMPQ CX, AX										
  0x449d83		0f94c0			SETE AL											
  0x449d86		88442438		MOVB AL, 0x38(SP)									
  0x449d8a		488b6c2418		MOVQ 0x18(SP), BP									
  0x449d8f		4883c420		ADDQ $0x20, SP										
  0x449d93		c3			RET											
  0x449d94		31c0			XORL AX, AX										
  0x449d96		ebee			JMP 0x449d86										
  0x449d98		e8d3a7ffff		CALL runtime.morestack_noctxt(SB)							
  0x449d9d		eb91			JMP type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x449da0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX										
  0x449da9		483b6110		CMPQ 0x10(CX), SP										
  0x449dad		765a			JBE 0x449e09											
  0x449daf		4883ec28		SUBQ $0x28, SP											
  0x449db3		48896c2420		MOVQ BP, 0x20(SP)										
  0x449db8		488d6c2420		LEAQ 0x20(SP), BP										
  0x449dbd		31c0			XORL AX, AX											
  0x449dbf		488b4c2438		MOVQ 0x38(SP), CX										
  0x449dc4		eb2c			JMP 0x449df2											
  0x449dc6		4889442418		MOVQ AX, 0x18(SP)										
  0x449dcb		48c1e006		SHLQ $0x6, AX											
  0x449dcf		488b5c2430		MOVQ 0x30(SP), BX										
  0x449dd4		4801d8			ADDQ BX, AX											
  0x449dd7		48890424		MOVQ AX, 0(SP)											
  0x449ddb		48894c2408		MOVQ CX, 0x8(SP)										
  0x449de0		e8cbfeffff		CALL type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)		
  0x449de5		488b4c2410		MOVQ 0x10(SP), CX										
  0x449dea		488b442418		MOVQ 0x18(SP), AX										
  0x449def		48ffc0			INCQ AX												
  0x449df2		483d86000000		CMPQ $0x86, AX											
  0x449df8		7ccc			JL 0x449dc6											
  0x449dfa		48894c2440		MOVQ CX, 0x40(SP)										
  0x449dff		488b6c2420		MOVQ 0x20(SP), BP										
  0x449e04		4883c428		ADDQ $0x28, SP											
  0x449e08		c3			RET												
  0x449e09		e862a7ffff		CALL runtime.morestack_noctxt(SB)								
  0x449e0e		eb90			JMP type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x449e10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX										
  0x449e19		483b6110		CMPQ 0x10(CX), SP										
  0x449e1d		0f8698000000		JBE 0x449ebb											
  0x449e23		4883ec30		SUBQ $0x30, SP											
  0x449e27		48896c2428		MOVQ BP, 0x28(SP)										
  0x449e2c		488d6c2428		LEAQ 0x28(SP), BP										
  0x449e31		31c0			XORL AX, AX											
  0x449e33		eb0b			JMP 0x449e40											
  0x449e35		488b4c2418		MOVQ 0x18(SP), CX										
  0x449e3a		48ffc1			INCQ CX												
  0x449e3d		4889c8			MOVQ CX, AX											
  0x449e40		483d86000000		CMPQ $0x86, AX											
  0x449e46		7d64			JGE 0x449eac											
  0x449e48		4889442418		MOVQ AX, 0x18(SP)										
  0x449e4d		48c1e006		SHLQ $0x6, AX											
  0x449e51		4889442420		MOVQ AX, 0x20(SP)										
  0x449e56		488b542438		MOVQ 0x38(SP), DX										
  0x449e5b		488d1c10		LEAQ 0(AX)(DX*1), BX										
  0x449e5f		48891c24		MOVQ BX, 0(SP)											
  0x449e63		488b5c2440		MOVQ 0x40(SP), BX										
  0x449e68		488d3418		LEAQ 0(AX)(BX*1), SI										
  0x449e6c		4889742408		MOVQ SI, 0x8(SP)										
  0x449e71		e8bafcffff		CALL type..eq.runtime.mcentral(SB)								
  0x449e76		0fb6442410		MOVZX 0x10(SP), AX										
  0x449e7b		84c0			TESTL AL, AL											
  0x449e7d		741e			JE 0x449e9d											
  0x449e7f		488b442438		MOVQ 0x38(SP), AX										
  0x449e84		488b4c2420		MOVQ 0x20(SP), CX										
  0x449e89		488b540138		MOVQ 0x38(CX)(AX*1), DX										
  0x449e8e		488b5c2440		MOVQ 0x40(SP), BX										
  0x449e93		488b4c1938		MOVQ 0x38(CX)(BX*1), CX										
  0x449e98		4839ca			CMPQ CX, DX											
  0x449e9b		7498			JE 0x449e35											
  0x449e9d		c644244800		MOVB $0x0, 0x48(SP)										
  0x449ea2		488b6c2428		MOVQ 0x28(SP), BP										
  0x449ea7		4883c430		ADDQ $0x30, SP											
  0x449eab		c3			RET												
  0x449eac		c644244801		MOVB $0x1, 0x48(SP)										
  0x449eb1		488b6c2428		MOVQ 0x28(SP), BP										
  0x449eb6		4883c430		ADDQ $0x30, SP											
  0x449eba		c3			RET												
  0x449ebb		e8b0a6ffff		CALL runtime.morestack_noctxt(SB)								
  0x449ec0		e94bffffff		JMP type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..hash.runtime.specialfinalizer(SB) <autogenerated>

  0x449ed0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x449ed9		483b6110		CMPQ 0x10(CX), SP				
  0x449edd		765f			JBE 0x449f3e					
  0x449edf		4883ec28		SUBQ $0x28, SP					
  0x449ee3		48896c2420		MOVQ BP, 0x20(SP)				
  0x449ee8		488d6c2420		LEAQ 0x20(SP), BP				
  0x449eed		488b442430		MOVQ 0x30(SP), AX				
  0x449ef2		48890424		MOVQ AX, 0(SP)					
  0x449ef6		488b4c2438		MOVQ 0x38(SP), CX				
  0x449efb		48894c2408		MOVQ CX, 0x8(SP)				
  0x449f00		e8bbedffff		CALL type..hash.runtime.special(SB)		
  0x449f05		488b442410		MOVQ 0x10(SP), AX				
  0x449f0a		488b4c2430		MOVQ 0x30(SP), CX				
  0x449f0f		4883c110		ADDQ $0x10, CX					
  0x449f13		48890c24		MOVQ CX, 0(SP)					
  0x449f17		4889442408		MOVQ AX, 0x8(SP)				
  0x449f1c		48c744241020000000	MOVQ $0x20, 0x10(SP)				
  0x449f25		e8e6bbfbff		CALL runtime.memhash(SB)			
  0x449f2a		488b442418		MOVQ 0x18(SP), AX				
  0x449f2f		4889442440		MOVQ AX, 0x40(SP)				
  0x449f34		488b6c2420		MOVQ 0x20(SP), BP				
  0x449f39		4883c428		ADDQ $0x28, SP					
  0x449f3d		c3			RET						
  0x449f3e		e82da6ffff		CALL runtime.morestack_noctxt(SB)		
  0x449f43		eb8b			JMP type..hash.runtime.specialfinalizer(SB)	

TEXT type..eq.runtime.specialfinalizer(SB) <autogenerated>

  0x449f50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x449f59		483b6110		CMPQ 0x10(CX), SP				
  0x449f5d		767a			JBE 0x449fd9					
  0x449f5f		4883ec28		SUBQ $0x28, SP					
  0x449f63		48896c2420		MOVQ BP, 0x20(SP)				
  0x449f68		488d6c2420		LEAQ 0x20(SP), BP				
  0x449f6d		488b442438		MOVQ 0x38(SP), AX				
  0x449f72		488b08			MOVQ 0(AX), CX					
  0x449f75		488b542430		MOVQ 0x30(SP), DX				
  0x449f7a		488b1a			MOVQ 0(DX), BX					
  0x449f7d		4839cb			CMPQ CX, BX					
  0x449f80		7553			JNE 0x449fd5					
  0x449f82		0fb74a08		MOVZX 0x8(DX), CX				
  0x449f86		0fb75808		MOVZX 0x8(AX), BX				
  0x449f8a		6639d9			CMPW BX, CX					
  0x449f8d		7542			JNE 0x449fd1					
  0x449f8f		0fb64a0a		MOVZX 0xa(DX), CX				
  0x449f93		0fb6580a		MOVZX 0xa(AX), BX				
  0x449f97		38d9			CMPL BL, CL					
  0x449f99		7410			JE 0x449fab					
  0x449f9b		31c0			XORL AX, AX					
  0x449f9d		88442440		MOVB AL, 0x40(SP)				
  0x449fa1		488b6c2420		MOVQ 0x20(SP), BP				
  0x449fa6		4883c428		ADDQ $0x28, SP					
  0x449faa		c3			RET						
  0x449fab		4883c010		ADDQ $0x10, AX					
  0x449faf		4889442408		MOVQ AX, 0x8(SP)				
  0x449fb4		488d4210		LEAQ 0x10(DX), AX				
  0x449fb8		48890424		MOVQ AX, 0(SP)					
  0x449fbc		48c744241020000000	MOVQ $0x20, 0x10(SP)				
  0x449fc5		e876c3ffff		CALL runtime.memequal(SB)			
  0x449fca		0fb6442418		MOVZX 0x18(SP), AX				
  0x449fcf		ebcc			JMP 0x449f9d					
  0x449fd1		31c0			XORL AX, AX					
  0x449fd3		ebc8			JMP 0x449f9d					
  0x449fd5		31c0			XORL AX, AX					
  0x449fd7		ebc4			JMP 0x449f9d					
  0x449fd9		e892a5ffff		CALL runtime.morestack_noctxt(SB)		
  0x449fde		e96dffffff		JMP type..eq.runtime.specialfinalizer(SB)	

TEXT type..hash.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x449ff0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX										
  0x449ff9		483b6110		CMPQ 0x10(CX), SP										
  0x449ffd		7668			JBE 0x44a067											
  0x449fff		4883ec28		SUBQ $0x28, SP											
  0x44a003		48896c2420		MOVQ BP, 0x20(SP)										
  0x44a008		488d6c2420		LEAQ 0x20(SP), BP										
  0x44a00d		488b442430		MOVQ 0x30(SP), AX										
  0x44a012		48890424		MOVQ AX, 0(SP)											
  0x44a016		488b4c2438		MOVQ 0x38(SP), CX										
  0x44a01b		48894c2408		MOVQ CX, 0x8(SP)										
  0x44a020		48c744241004000000	MOVQ $0x4, 0x10(SP)										
  0x44a029		e8e2bafbff		CALL runtime.memhash(SB)									
  0x44a02e		488b442418		MOVQ 0x18(SP), AX										
  0x44a033		488b4c2430		MOVQ 0x30(SP), CX										
  0x44a038		4883c108		ADDQ $0x8, CX											
  0x44a03c		48890c24		MOVQ CX, 0(SP)											
  0x44a040		4889442408		MOVQ AX, 0x8(SP)										
  0x44a045		48c744241010000000	MOVQ $0x10, 0x10(SP)										
  0x44a04e		e8bdbafbff		CALL runtime.memhash(SB)									
  0x44a053		488b442418		MOVQ 0x18(SP), AX										
  0x44a058		4889442440		MOVQ AX, 0x40(SP)										
  0x44a05d		488b6c2420		MOVQ 0x20(SP), BP										
  0x44a062		4883c428		ADDQ $0x28, SP											
  0x44a066		c3			RET												
  0x44a067		e804a5ffff		CALL runtime.morestack_noctxt(SB)								
  0x44a06c		eb82			JMP type..hash.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	

TEXT type..eq.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x44a070		488b442408		MOVQ 0x8(SP), AX	
  0x44a075		8b08			MOVL 0(AX), CX		
  0x44a077		488b542410		MOVQ 0x10(SP), DX	
  0x44a07c		8b1a			MOVL 0(DX), BX		
  0x44a07e		39d9			CMPL BX, CX		
  0x44a080		7524			JNE 0x44a0a6		
  0x44a082		488b4808		MOVQ 0x8(AX), CX	
  0x44a086		488b5a08		MOVQ 0x8(DX), BX	
  0x44a08a		4839d9			CMPQ BX, CX		
  0x44a08d		7513			JNE 0x44a0a2		
  0x44a08f		488b4010		MOVQ 0x10(AX), AX	
  0x44a093		488b4a10		MOVQ 0x10(DX), CX	
  0x44a097		4839c1			CMPQ AX, CX		
  0x44a09a		0f94c0			SETE AL			
  0x44a09d		88442418		MOVB AL, 0x18(SP)	
  0x44a0a1		c3			RET			
  0x44a0a2		31c0			XORL AX, AX		
  0x44a0a4		ebf7			JMP 0x44a09d		
  0x44a0a6		31c0			XORL AX, AX		
  0x44a0a8		ebf3			JMP 0x44a09d		

TEXT type..hash.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x44a0b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX											
  0x44a0b9		483b6110		CMPQ 0x10(CX), SP											
  0x44a0bd		7659			JBE 0x44a118												
  0x44a0bf		4883ec28		SUBQ $0x28, SP												
  0x44a0c3		48896c2420		MOVQ BP, 0x20(SP)											
  0x44a0c8		488d6c2420		LEAQ 0x20(SP), BP											
  0x44a0cd		31c0			XORL AX, AX												
  0x44a0cf		488b4c2438		MOVQ 0x38(SP), CX											
  0x44a0d4		eb2d			JMP 0x44a103												
  0x44a0d6		4889442418		MOVQ AX, 0x18(SP)											
  0x44a0db		488d1440		LEAQ 0(AX)(AX*2), DX											
  0x44a0df		488b5c2430		MOVQ 0x30(SP), BX											
  0x44a0e4		488d14d3		LEAQ 0(BX)(DX*8), DX											
  0x44a0e8		48891424		MOVQ DX, 0(SP)												
  0x44a0ec		48894c2408		MOVQ CX, 0x8(SP)											
  0x44a0f1		e8fafeffff		CALL type..hash.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	
  0x44a0f6		488b4c2410		MOVQ 0x10(SP), CX											
  0x44a0fb		488b442418		MOVQ 0x18(SP), AX											
  0x44a100		48ffc0			INCQ AX													
  0x44a103		4883f843		CMPQ $0x43, AX												
  0x44a107		7ccd			JL 0x44a0d6												
  0x44a109		48894c2440		MOVQ CX, 0x40(SP)											
  0x44a10e		488b6c2420		MOVQ 0x20(SP), BP											
  0x44a113		4883c428		ADDQ $0x28, SP												
  0x44a117		c3			RET													
  0x44a118		e853a4ffff		CALL runtime.morestack_noctxt(SB)									
  0x44a11d		eb91			JMP type..hash.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	

TEXT type..eq.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x44a120		488b442410		MOVQ 0x10(SP), AX	
  0x44a125		488b4c2408		MOVQ 0x8(SP), CX	
  0x44a12a		31d2			XORL DX, DX		
  0x44a12c		eb03			JMP 0x44a131		
  0x44a12e		48ffc2			INCQ DX			
  0x44a131		4883fa43		CMPQ $0x43, DX		
  0x44a135		7d32			JGE 0x44a169		
  0x44a137		488d1c52		LEAQ 0(DX)(DX*2), BX	
  0x44a13b		8b34d9			MOVL 0(CX)(BX*8), SI	
  0x44a13e		8b3cd8			MOVL 0(AX)(BX*8), DI	
  0x44a141		39fe			CMPL DI, SI		
  0x44a143		751e			JNE 0x44a163		
  0x44a145		488b74d908		MOVQ 0x8(CX)(BX*8), SI	
  0x44a14a		488b7cd808		MOVQ 0x8(AX)(BX*8), DI	
  0x44a14f		4839fe			CMPQ DI, SI		
  0x44a152		750f			JNE 0x44a163		
  0x44a154		488b74d910		MOVQ 0x10(CX)(BX*8), SI	
  0x44a159		488b5cd810		MOVQ 0x10(AX)(BX*8), BX	
  0x44a15e		4839f3			CMPQ SI, BX		
  0x44a161		74cb			JE 0x44a12e		
  0x44a163		c644241800		MOVB $0x0, 0x18(SP)	
  0x44a168		c3			RET			
  0x44a169		c644241801		MOVB $0x1, 0x18(SP)	
  0x44a16e		c3			RET			

TEXT type..hash.runtime.mstats(SB) <autogenerated>

  0x44a170		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX											
  0x44a179		483b6110		CMPQ 0x10(CX), SP											
  0x44a17d		0f8618010000		JBE 0x44a29b												
  0x44a183		4883ec28		SUBQ $0x28, SP												
  0x44a187		48896c2420		MOVQ BP, 0x20(SP)											
  0x44a18c		488d6c2420		LEAQ 0x20(SP), BP											
  0x44a191		488b442430		MOVQ 0x30(SP), AX											
  0x44a196		48890424		MOVQ AX, 0(SP)												
  0x44a19a		488b4c2438		MOVQ 0x38(SP), CX											
  0x44a19f		48894c2408		MOVQ CX, 0x8(SP)											
  0x44a1a4		48c7442410c8100000	MOVQ $0x10c8, 0x10(SP)											
  0x44a1ad		e85eb9fbff		CALL runtime.memhash(SB)										
  0x44a1b2		488b442418		MOVQ 0x18(SP), AX											
  0x44a1b7		488b4c2430		MOVQ 0x30(SP), CX											
  0x44a1bc		488d91c8100000		LEAQ 0x10c8(CX), DX											
  0x44a1c3		48891424		MOVQ DX, 0(SP)												
  0x44a1c7		4889442408		MOVQ AX, 0x8(SP)											
  0x44a1cc		e82f71fbff		CALL runtime.f64hash(SB)										
  0x44a1d1		488b442410		MOVQ 0x10(SP), AX											
  0x44a1d6		488b4c2430		MOVQ 0x30(SP), CX											
  0x44a1db		488d91d0100000		LEAQ 0x10d0(CX), DX											
  0x44a1e2		48891424		MOVQ DX, 0(SP)												
  0x44a1e6		4889442408		MOVQ AX, 0x8(SP)											
  0x44a1eb		48c744241002000000	MOVQ $0x2, 0x10(SP)											
  0x44a1f4		e817b9fbff		CALL runtime.memhash(SB)										
  0x44a1f9		488b442418		MOVQ 0x18(SP), AX											
  0x44a1fe		488b4c2430		MOVQ 0x30(SP), CX											
  0x44a203		488d91d8100000		LEAQ 0x10d8(CX), DX											
  0x44a20a		48891424		MOVQ DX, 0(SP)												
  0x44a20e		4889442408		MOVQ AX, 0x8(SP)											
  0x44a213		e898feffff		CALL type..hash.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	
  0x44a218		488b442410		MOVQ 0x10(SP), AX											
  0x44a21d		488b4c2430		MOVQ 0x30(SP), CX											
  0x44a222		488d9120170000		LEAQ 0x1720(CX), DX											
  0x44a229		48891424		MOVQ DX, 0(SP)												
  0x44a22d		4889442408		MOVQ AX, 0x8(SP)											
  0x44a232		48c744241010000000	MOVQ $0x10, 0x10(SP)											
  0x44a23b		e8d0b8fbff		CALL runtime.memhash(SB)										
  0x44a240		488b442418		MOVQ 0x18(SP), AX											
  0x44a245		488b4c2430		MOVQ 0x30(SP), CX											
  0x44a24a		488d9130170000		LEAQ 0x1730(CX), DX											
  0x44a251		48891424		MOVQ DX, 0(SP)												
  0x44a255		4889442408		MOVQ AX, 0x8(SP)											
  0x44a25a		e8a170fbff		CALL runtime.f64hash(SB)										
  0x44a25f		488b442410		MOVQ 0x10(SP), AX											
  0x44a264		488b4c2430		MOVQ 0x30(SP), CX											
  0x44a269		4881c138170000		ADDQ $0x1738, CX											
  0x44a270		48890c24		MOVQ CX, 0(SP)												
  0x44a274		4889442408		MOVQ AX, 0x8(SP)											
  0x44a279		48c744241020000000	MOVQ $0x20, 0x10(SP)											
  0x44a282		e889b8fbff		CALL runtime.memhash(SB)										
  0x44a287		488b442418		MOVQ 0x18(SP), AX											
  0x44a28c		4889442440		MOVQ AX, 0x40(SP)											
  0x44a291		488b6c2420		MOVQ 0x20(SP), BP											
  0x44a296		4883c428		ADDQ $0x28, SP												
  0x44a29a		c3			RET													
  0x44a29b		e8d0a2ffff		CALL runtime.morestack_noctxt(SB)									
  0x44a2a0		e9cbfeffff		JMP type..hash.runtime.mstats(SB)									

TEXT type..eq.runtime.mstats(SB) <autogenerated>

  0x44a2b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX											
  0x44a2b9		483b6110		CMPQ 0x10(CX), SP											
  0x44a2bd		0f8670010000		JBE 0x44a433												
  0x44a2c3		4883ec28		SUBQ $0x28, SP												
  0x44a2c7		48896c2420		MOVQ BP, 0x20(SP)											
  0x44a2cc		488d6c2420		LEAQ 0x20(SP), BP											
  0x44a2d1		488b442438		MOVQ 0x38(SP), AX											
  0x44a2d6		4889442408		MOVQ AX, 0x8(SP)											
  0x44a2db		488b4c2430		MOVQ 0x30(SP), CX											
  0x44a2e0		48890c24		MOVQ CX, 0(SP)												
  0x44a2e4		48c7442410c8100000	MOVQ $0x10c8, 0x10(SP)											
  0x44a2ed		e84ec0ffff		CALL runtime.memequal(SB)										
  0x44a2f2		0fb6442418		MOVZX 0x18(SP), AX											
  0x44a2f7		84c0			TESTL AL, AL												
  0x44a2f9		0f8423010000		JE 0x44a422												
  0x44a2ff		488b442430		MOVQ 0x30(SP), AX											
  0x44a304		f20f1080c8100000	MOVSD_XMM 0x10c8(AX), X0										
  0x44a30c		488b4c2438		MOVQ 0x38(SP), CX											
  0x44a311		f20f1089c8100000	MOVSD_XMM 0x10c8(CX), X1										
  0x44a319		660f2ec8		UCOMISD X0, X1												
  0x44a31d		0f85f8000000		JNE 0x44a41b												
  0x44a323		0f8af2000000		JP 0x44a41b												
  0x44a329		0fb690d0100000		MOVZX 0x10d0(AX), DX											
  0x44a330		0fb699d0100000		MOVZX 0x10d0(CX), BX											
  0x44a337		38d3			CMPL DL, BL												
  0x44a339		0f85d5000000		JNE 0x44a414												
  0x44a33f		0fb690d1100000		MOVZX 0x10d1(AX), DX											
  0x44a346		0fb699d1100000		MOVZX 0x10d1(CX), BX											
  0x44a34d		38d3			CMPL DL, BL												
  0x44a34f		0f848f000000		JE 0x44a3e4												
  0x44a355		31d2			XORL DX, DX												
  0x44a357		84d2			TESTL DL, DL												
  0x44a359		0f8481000000		JE 0x44a3e0												
  0x44a35f		488b9020170000		MOVQ 0x1720(AX), DX											
  0x44a366		488b9920170000		MOVQ 0x1720(CX), BX											
  0x44a36d		4839da			CMPQ BX, DX												
  0x44a370		756a			JNE 0x44a3dc												
  0x44a372		488b9028170000		MOVQ 0x1728(AX), DX											
  0x44a379		488b9928170000		MOVQ 0x1728(CX), BX											
  0x44a380		4839da			CMPQ BX, DX												
  0x44a383		7553			JNE 0x44a3d8												
  0x44a385		f20f108030170000	MOVSD_XMM 0x1730(AX), X0										
  0x44a38d		f20f108930170000	MOVSD_XMM 0x1730(CX), X1										
  0x44a395		660f2ec8		UCOMISD X0, X1												
  0x44a399		7502			JNE 0x44a39d												
  0x44a39b		7b10			JNP 0x44a3ad												
  0x44a39d		31c0			XORL AX, AX												
  0x44a39f		88442440		MOVB AL, 0x40(SP)											
  0x44a3a3		488b6c2420		MOVQ 0x20(SP), BP											
  0x44a3a8		4883c428		ADDQ $0x28, SP												
  0x44a3ac		c3			RET													
  0x44a3ad		4881c138170000		ADDQ $0x1738, CX											
  0x44a3b4		48894c2408		MOVQ CX, 0x8(SP)											
  0x44a3b9		480538170000		ADDQ $0x1738, AX											
  0x44a3bf		48890424		MOVQ AX, 0(SP)												
  0x44a3c3		48c744241020000000	MOVQ $0x20, 0x10(SP)											
  0x44a3cc		e86fbfffff		CALL runtime.memequal(SB)										
  0x44a3d1		0fb6442418		MOVZX 0x18(SP), AX											
  0x44a3d6		ebc7			JMP 0x44a39f												
  0x44a3d8		31c0			XORL AX, AX												
  0x44a3da		ebc3			JMP 0x44a39f												
  0x44a3dc		31c0			XORL AX, AX												
  0x44a3de		ebbf			JMP 0x44a39f												
  0x44a3e0		31c0			XORL AX, AX												
  0x44a3e2		ebbb			JMP 0x44a39f												
  0x44a3e4		488d90d8100000		LEAQ 0x10d8(AX), DX											
  0x44a3eb		48891424		MOVQ DX, 0(SP)												
  0x44a3ef		488d91d8100000		LEAQ 0x10d8(CX), DX											
  0x44a3f6		4889542408		MOVQ DX, 0x8(SP)											
  0x44a3fb		e820fdffff		CALL type..eq.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	
  0x44a400		0fb6542410		MOVZX 0x10(SP), DX											
  0x44a405		488b442430		MOVQ 0x30(SP), AX											
  0x44a40a		488b4c2438		MOVQ 0x38(SP), CX											
  0x44a40f		e943ffffff		JMP 0x44a357												
  0x44a414		31d2			XORL DX, DX												
  0x44a416		e93cffffff		JMP 0x44a357												
  0x44a41b		31d2			XORL DX, DX												
  0x44a41d		e935ffffff		JMP 0x44a357												
  0x44a422		488b442430		MOVQ 0x30(SP), AX											
  0x44a427		488b4c2438		MOVQ 0x38(SP), CX											
  0x44a42c		31d2			XORL DX, DX												
  0x44a42e		e924ffffff		JMP 0x44a357												
  0x44a433		e838a1ffff		CALL runtime.morestack_noctxt(SB)									
  0x44a438		e973feffff		JMP type..eq.runtime.mstats(SB)										

TEXT runtime.(*plainError).Error(SB) <autogenerated>

  0x44a440		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x44a449		4883ec08		SUBQ $0x8, SP			
  0x44a44d		48892c24		MOVQ BP, 0(SP)			
  0x44a451		488d2c24		LEAQ 0(SP), BP			
  0x44a455		488b5920		MOVQ 0x20(CX), BX		
  0x44a459		4885db			TESTQ BX, BX			
  0x44a45c		752b			JNE 0x44a489			
  0x44a45e		488b442410		MOVQ 0x10(SP), AX		
  0x44a463		4885c0			TESTQ AX, AX			
  0x44a466		741a			JE 0x44a482			
  0x44a468		488b4808		MOVQ 0x8(AX), CX		
  0x44a46c		488b00			MOVQ 0(AX), AX			
  0x44a46f		4889442418		MOVQ AX, 0x18(SP)		
  0x44a474		48894c2420		MOVQ CX, 0x20(SP)		
  0x44a479		488b2c24		MOVQ 0(SP), BP			
  0x44a47d		4883c408		ADDQ $0x8, SP			
  0x44a481		c3			RET				
  0x44a482		e869b2fbff		CALL runtime.panicwrap(SB)	
  0x44a487		0f0b			UD2				
  0x44a489		488d7c2410		LEAQ 0x10(SP), DI		
  0x44a48e		48393b			CMPQ DI, 0(BX)			
  0x44a491		75cb			JNE 0x44a45e			
  0x44a493		488923			MOVQ SP, 0(BX)			
  0x44a496		ebc6			JMP 0x44a45e			

TEXT type..hash.runtime.rwmutex(SB) <autogenerated>

  0x44a4a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a4a9		483b6110		CMPQ 0x10(CX), SP			
  0x44a4ad		7668			JBE 0x44a517				
  0x44a4af		4883ec28		SUBQ $0x28, SP				
  0x44a4b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a4b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a4bd		488b442430		MOVQ 0x30(SP), AX			
  0x44a4c2		48890424		MOVQ AX, 0(SP)				
  0x44a4c6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44a4cb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44a4d0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44a4d9		e832b6fbff		CALL runtime.memhash(SB)		
  0x44a4de		488b442418		MOVQ 0x18(SP), AX			
  0x44a4e3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44a4e8		4883c118		ADDQ $0x18, CX				
  0x44a4ec		48890c24		MOVQ CX, 0(SP)				
  0x44a4f0		4889442408		MOVQ AX, 0x8(SP)			
  0x44a4f5		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x44a4fe		e80db6fbff		CALL runtime.memhash(SB)		
  0x44a503		488b442418		MOVQ 0x18(SP), AX			
  0x44a508		4889442440		MOVQ AX, 0x40(SP)			
  0x44a50d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a512		4883c428		ADDQ $0x28, SP				
  0x44a516		c3			RET					
  0x44a517		e854a0ffff		CALL runtime.morestack_noctxt(SB)	
  0x44a51c		eb82			JMP type..hash.runtime.rwmutex(SB)	

TEXT type..eq.runtime.rwmutex(SB) <autogenerated>

  0x44a520		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a529		483b6110		CMPQ 0x10(CX), SP			
  0x44a52d		7678			JBE 0x44a5a7				
  0x44a52f		4883ec28		SUBQ $0x28, SP				
  0x44a533		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a538		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a53d		488b442438		MOVQ 0x38(SP), AX			
  0x44a542		4889442408		MOVQ AX, 0x8(SP)			
  0x44a547		488b4c2430		MOVQ 0x30(SP), CX			
  0x44a54c		48890c24		MOVQ CX, 0(SP)				
  0x44a550		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44a559		e8e2bdffff		CALL runtime.memequal(SB)		
  0x44a55e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44a563		84c0			TESTL AL, AL				
  0x44a565		7510			JNE 0x44a577				
  0x44a567		31c0			XORL AX, AX				
  0x44a569		88442440		MOVB AL, 0x40(SP)			
  0x44a56d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a572		4883c428		ADDQ $0x28, SP				
  0x44a576		c3			RET					
  0x44a577		488b442438		MOVQ 0x38(SP), AX			
  0x44a57c		4883c018		ADDQ $0x18, AX				
  0x44a580		4889442408		MOVQ AX, 0x8(SP)			
  0x44a585		488b442430		MOVQ 0x30(SP), AX			
  0x44a58a		4883c018		ADDQ $0x18, AX				
  0x44a58e		48890424		MOVQ AX, 0(SP)				
  0x44a592		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x44a59b		e8a0bdffff		CALL runtime.memequal(SB)		
  0x44a5a0		0fb6442418		MOVZX 0x18(SP), AX			
  0x44a5a5		ebc2			JMP 0x44a569				
  0x44a5a7		e8c49fffff		CALL runtime.morestack_noctxt(SB)	
  0x44a5ac		e96fffffff		JMP type..eq.runtime.rwmutex(SB)	

TEXT type..hash.runtime.semaRoot(SB) <autogenerated>

  0x44a5c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a5c9		483b6110		CMPQ 0x10(CX), SP			
  0x44a5cd		7643			JBE 0x44a612				
  0x44a5cf		4883ec28		SUBQ $0x28, SP				
  0x44a5d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a5d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a5dd		488b442430		MOVQ 0x30(SP), AX			
  0x44a5e2		48890424		MOVQ AX, 0(SP)				
  0x44a5e6		488b442438		MOVQ 0x38(SP), AX			
  0x44a5eb		4889442408		MOVQ AX, 0x8(SP)			
  0x44a5f0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44a5f9		e812b5fbff		CALL runtime.memhash(SB)		
  0x44a5fe		488b442418		MOVQ 0x18(SP), AX			
  0x44a603		4889442440		MOVQ AX, 0x40(SP)			
  0x44a608		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a60d		4883c428		ADDQ $0x28, SP				
  0x44a611		c3			RET					
  0x44a612		e8599fffff		CALL runtime.morestack_noctxt(SB)	
  0x44a617		eba7			JMP type..hash.runtime.semaRoot(SB)	

TEXT type..eq.runtime.semaRoot(SB) <autogenerated>

  0x44a620		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a629		483b6110		CMPQ 0x10(CX), SP			
  0x44a62d		7642			JBE 0x44a671				
  0x44a62f		4883ec28		SUBQ $0x28, SP				
  0x44a633		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a638		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a63d		488b442438		MOVQ 0x38(SP), AX			
  0x44a642		4889442408		MOVQ AX, 0x8(SP)			
  0x44a647		488b442430		MOVQ 0x30(SP), AX			
  0x44a64c		48890424		MOVQ AX, 0(SP)				
  0x44a650		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44a659		e8e2bcffff		CALL runtime.memequal(SB)		
  0x44a65e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44a663		88442440		MOVB AL, 0x40(SP)			
  0x44a667		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a66c		4883c428		ADDQ $0x28, SP				
  0x44a670		c3			RET					
  0x44a671		e8fa9effff		CALL runtime.morestack_noctxt(SB)	
  0x44a676		eba8			JMP type..eq.runtime.semaRoot(SB)	

TEXT type..hash.runtime.sigTabT(SB) <autogenerated>

  0x44a680		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a689		483b6110		CMPQ 0x10(CX), SP			
  0x44a68d		765f			JBE 0x44a6ee				
  0x44a68f		4883ec28		SUBQ $0x28, SP				
  0x44a693		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a698		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a69d		488b442430		MOVQ 0x30(SP), AX			
  0x44a6a2		48890424		MOVQ AX, 0(SP)				
  0x44a6a6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44a6ab		48894c2408		MOVQ CX, 0x8(SP)			
  0x44a6b0		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x44a6b9		e852b4fbff		CALL runtime.memhash(SB)		
  0x44a6be		488b442418		MOVQ 0x18(SP), AX			
  0x44a6c3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44a6c8		4883c108		ADDQ $0x8, CX				
  0x44a6cc		48890c24		MOVQ CX, 0(SP)				
  0x44a6d0		4889442408		MOVQ AX, 0x8(SP)			
  0x44a6d5		e8a66afbff		CALL runtime.strhash(SB)		
  0x44a6da		488b442410		MOVQ 0x10(SP), AX			
  0x44a6df		4889442440		MOVQ AX, 0x40(SP)			
  0x44a6e4		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a6e9		4883c428		ADDQ $0x28, SP				
  0x44a6ed		c3			RET					
  0x44a6ee		e87d9effff		CALL runtime.morestack_noctxt(SB)	
  0x44a6f3		eb8b			JMP type..hash.runtime.sigTabT(SB)	

TEXT type..eq.runtime.sigTabT(SB) <autogenerated>

  0x44a700		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a709		483b6110		CMPQ 0x10(CX), SP			
  0x44a70d		7663			JBE 0x44a772				
  0x44a70f		4883ec28		SUBQ $0x28, SP				
  0x44a713		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a718		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a71d		488b442430		MOVQ 0x30(SP), AX			
  0x44a722		8b08			MOVL 0(AX), CX				
  0x44a724		488b542438		MOVQ 0x38(SP), DX			
  0x44a729		8b1a			MOVL 0(DX), BX				
  0x44a72b		39d9			CMPL BX, CX				
  0x44a72d		753f			JNE 0x44a76e				
  0x44a72f		488b4a10		MOVQ 0x10(DX), CX			
  0x44a733		488b5208		MOVQ 0x8(DX), DX			
  0x44a737		488b5810		MOVQ 0x10(AX), BX			
  0x44a73b		488b4008		MOVQ 0x8(AX), AX			
  0x44a73f		4839cb			CMPQ CX, BX				
  0x44a742		7410			JE 0x44a754				
  0x44a744		31c0			XORL AX, AX				
  0x44a746		88442440		MOVB AL, 0x40(SP)			
  0x44a74a		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a74f		4883c428		ADDQ $0x28, SP				
  0x44a753		c3			RET					
  0x44a754		48890424		MOVQ AX, 0(SP)				
  0x44a758		4889542408		MOVQ DX, 0x8(SP)			
  0x44a75d		48895c2410		MOVQ BX, 0x10(SP)			
  0x44a762		e8d9bbffff		CALL runtime.memequal(SB)		
  0x44a767		0fb6442418		MOVZX 0x18(SP), AX			
  0x44a76c		ebd8			JMP 0x44a746				
  0x44a76e		31c0			XORL AX, AX				
  0x44a770		ebd4			JMP 0x44a746				
  0x44a772		e8f99dffff		CALL runtime.morestack_noctxt(SB)	
  0x44a777		eb87			JMP type..eq.runtime.sigTabT(SB)	

TEXT type..hash.runtime.siginfo(SB) <autogenerated>

  0x44a780		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a789		483b6110		CMPQ 0x10(CX), SP			
  0x44a78d		7668			JBE 0x44a7f7				
  0x44a78f		4883ec28		SUBQ $0x28, SP				
  0x44a793		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a798		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a79d		488b442430		MOVQ 0x30(SP), AX			
  0x44a7a2		48890424		MOVQ AX, 0(SP)				
  0x44a7a6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44a7ab		48894c2408		MOVQ CX, 0x8(SP)			
  0x44a7b0		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x44a7b9		e852b3fbff		CALL runtime.memhash(SB)		
  0x44a7be		488b442418		MOVQ 0x18(SP), AX			
  0x44a7c3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44a7c8		4883c110		ADDQ $0x10, CX				
  0x44a7cc		48890c24		MOVQ CX, 0(SP)				
  0x44a7d0		4889442408		MOVQ AX, 0x8(SP)			
  0x44a7d5		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44a7de		e82db3fbff		CALL runtime.memhash(SB)		
  0x44a7e3		488b442418		MOVQ 0x18(SP), AX			
  0x44a7e8		4889442440		MOVQ AX, 0x40(SP)			
  0x44a7ed		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a7f2		4883c428		ADDQ $0x28, SP				
  0x44a7f6		c3			RET					
  0x44a7f7		e8749dffff		CALL runtime.morestack_noctxt(SB)	
  0x44a7fc		eb82			JMP type..hash.runtime.siginfo(SB)	

TEXT type..eq.runtime.siginfo(SB) <autogenerated>

  0x44a800		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a809		483b6110		CMPQ 0x10(CX), SP			
  0x44a80d		7662			JBE 0x44a871				
  0x44a80f		4883ec28		SUBQ $0x28, SP				
  0x44a813		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a818		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a81d		488b442438		MOVQ 0x38(SP), AX			
  0x44a822		4889442408		MOVQ AX, 0x8(SP)			
  0x44a827		488b4c2430		MOVQ 0x30(SP), CX			
  0x44a82c		48890c24		MOVQ CX, 0(SP)				
  0x44a830		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x44a839		e802bbffff		CALL runtime.memequal(SB)		
  0x44a83e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44a843		84c0			TESTL AL, AL				
  0x44a845		7426			JE 0x44a86d				
  0x44a847		488b442430		MOVQ 0x30(SP), AX			
  0x44a84c		488b4010		MOVQ 0x10(AX), AX			
  0x44a850		488b4c2438		MOVQ 0x38(SP), CX			
  0x44a855		488b4910		MOVQ 0x10(CX), CX			
  0x44a859		4839c8			CMPQ CX, AX				
  0x44a85c		0f94c0			SETE AL					
  0x44a85f		88442440		MOVB AL, 0x40(SP)			
  0x44a863		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a868		4883c428		ADDQ $0x28, SP				
  0x44a86c		c3			RET					
  0x44a86d		31c0			XORL AX, AX				
  0x44a86f		ebee			JMP 0x44a85f				
  0x44a871		e8fa9cffff		CALL runtime.morestack_noctxt(SB)	
  0x44a876		eb88			JMP type..eq.runtime.siginfo(SB)	

TEXT type..hash.runtime.stackmap(SB) <autogenerated>

  0x44a880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a889		483b6110		CMPQ 0x10(CX), SP			
  0x44a88d		7643			JBE 0x44a8d2				
  0x44a88f		4883ec28		SUBQ $0x28, SP				
  0x44a893		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a898		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a89d		488b442430		MOVQ 0x30(SP), AX			
  0x44a8a2		48890424		MOVQ AX, 0(SP)				
  0x44a8a6		488b442438		MOVQ 0x38(SP), AX			
  0x44a8ab		4889442408		MOVQ AX, 0x8(SP)			
  0x44a8b0		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44a8b9		e852b2fbff		CALL runtime.memhash(SB)		
  0x44a8be		488b442418		MOVQ 0x18(SP), AX			
  0x44a8c3		4889442440		MOVQ AX, 0x40(SP)			
  0x44a8c8		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a8cd		4883c428		ADDQ $0x28, SP				
  0x44a8d1		c3			RET					
  0x44a8d2		e8999cffff		CALL runtime.morestack_noctxt(SB)	
  0x44a8d7		eba7			JMP type..hash.runtime.stackmap(SB)	

TEXT type..eq.runtime.stackmap(SB) <autogenerated>

  0x44a8e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a8e9		483b6110		CMPQ 0x10(CX), SP			
  0x44a8ed		7642			JBE 0x44a931				
  0x44a8ef		4883ec28		SUBQ $0x28, SP				
  0x44a8f3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a8f8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a8fd		488b442438		MOVQ 0x38(SP), AX			
  0x44a902		4889442408		MOVQ AX, 0x8(SP)			
  0x44a907		488b442430		MOVQ 0x30(SP), AX			
  0x44a90c		48890424		MOVQ AX, 0(SP)				
  0x44a910		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44a919		e822baffff		CALL runtime.memequal(SB)		
  0x44a91e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44a923		88442440		MOVB AL, 0x40(SP)			
  0x44a927		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a92c		4883c428		ADDQ $0x28, SP				
  0x44a930		c3			RET					
  0x44a931		e83a9cffff		CALL runtime.morestack_noctxt(SB)	
  0x44a936		eba8			JMP type..eq.runtime.stackmap(SB)	

TEXT type..hash.runtime.sweepdata(SB) <autogenerated>

  0x44a940		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a949		483b6110		CMPQ 0x10(CX), SP			
  0x44a94d		7668			JBE 0x44a9b7				
  0x44a94f		4883ec28		SUBQ $0x28, SP				
  0x44a953		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a958		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a95d		488b442430		MOVQ 0x30(SP), AX			
  0x44a962		48890424		MOVQ AX, 0(SP)				
  0x44a966		488b4c2438		MOVQ 0x38(SP), CX			
  0x44a96b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44a970		48c744241012000000	MOVQ $0x12, 0x10(SP)			
  0x44a979		e892b1fbff		CALL runtime.memhash(SB)		
  0x44a97e		488b442418		MOVQ 0x18(SP), AX			
  0x44a983		488b4c2430		MOVQ 0x30(SP), CX			
  0x44a988		4883c114		ADDQ $0x14, CX				
  0x44a98c		48890c24		MOVQ CX, 0(SP)				
  0x44a990		4889442408		MOVQ AX, 0x8(SP)			
  0x44a995		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44a99e		e86db1fbff		CALL runtime.memhash(SB)		
  0x44a9a3		488b442418		MOVQ 0x18(SP), AX			
  0x44a9a8		4889442440		MOVQ AX, 0x40(SP)			
  0x44a9ad		488b6c2420		MOVQ 0x20(SP), BP			
  0x44a9b2		4883c428		ADDQ $0x28, SP				
  0x44a9b6		c3			RET					
  0x44a9b7		e8b49bffff		CALL runtime.morestack_noctxt(SB)	
  0x44a9bc		eb82			JMP type..hash.runtime.sweepdata(SB)	

TEXT type..eq.runtime.sweepdata(SB) <autogenerated>

  0x44a9c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44a9c9		483b6110		CMPQ 0x10(CX), SP			
  0x44a9cd		766d			JBE 0x44aa3c				
  0x44a9cf		4883ec28		SUBQ $0x28, SP				
  0x44a9d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44a9d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44a9dd		488b442438		MOVQ 0x38(SP), AX			
  0x44a9e2		4889442408		MOVQ AX, 0x8(SP)			
  0x44a9e7		488b4c2430		MOVQ 0x30(SP), CX			
  0x44a9ec		48890c24		MOVQ CX, 0(SP)				
  0x44a9f0		48c744241012000000	MOVQ $0x12, 0x10(SP)			
  0x44a9f9		e842b9ffff		CALL runtime.memequal(SB)		
  0x44a9fe		0fb6442418		MOVZX 0x18(SP), AX			
  0x44aa03		84c0			TESTL AL, AL				
  0x44aa05		7431			JE 0x44aa38				
  0x44aa07		488b442430		MOVQ 0x30(SP), AX			
  0x44aa0c		8b4814			MOVL 0x14(AX), CX			
  0x44aa0f		488b542438		MOVQ 0x38(SP), DX			
  0x44aa14		8b5a14			MOVL 0x14(DX), BX			
  0x44aa17		39d9			CMPL BX, CX				
  0x44aa19		7519			JNE 0x44aa34				
  0x44aa1b		8b4018			MOVL 0x18(AX), AX			
  0x44aa1e		8b4a18			MOVL 0x18(DX), CX			
  0x44aa21		39c1			CMPL AX, CX				
  0x44aa23		0f94c0			SETE AL					
  0x44aa26		88442440		MOVB AL, 0x40(SP)			
  0x44aa2a		488b6c2420		MOVQ 0x20(SP), BP			
  0x44aa2f		4883c428		ADDQ $0x28, SP				
  0x44aa33		c3			RET					
  0x44aa34		31c0			XORL AX, AX				
  0x44aa36		ebee			JMP 0x44aa26				
  0x44aa38		31c0			XORL AX, AX				
  0x44aa3a		ebea			JMP 0x44aa26				
  0x44aa3c		e82f9bffff		CALL runtime.morestack_noctxt(SB)	
  0x44aa41		e97affffff		JMP type..eq.runtime.sweepdata(SB)	

TEXT type..hash.runtime.symbol_key(SB) <autogenerated>

  0x44aa50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44aa59		483b6110		CMPQ 0x10(CX), SP			
  0x44aa5d		765f			JBE 0x44aabe				
  0x44aa5f		4883ec28		SUBQ $0x28, SP				
  0x44aa63		48896c2420		MOVQ BP, 0x20(SP)			
  0x44aa68		488d6c2420		LEAQ 0x20(SP), BP			
  0x44aa6d		488b442430		MOVQ 0x30(SP), AX			
  0x44aa72		48890424		MOVQ AX, 0(SP)				
  0x44aa76		488b4c2438		MOVQ 0x38(SP), CX			
  0x44aa7b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44aa80		e8fb66fbff		CALL runtime.strhash(SB)		
  0x44aa85		488b442410		MOVQ 0x10(SP), AX			
  0x44aa8a		488b4c2430		MOVQ 0x30(SP), CX			
  0x44aa8f		4883c110		ADDQ $0x10, CX				
  0x44aa93		48890c24		MOVQ CX, 0(SP)				
  0x44aa97		4889442408		MOVQ AX, 0x8(SP)			
  0x44aa9c		48c744241010000000	MOVQ $0x10, 0x10(SP)			
  0x44aaa5		e866b0fbff		CALL runtime.memhash(SB)		
  0x44aaaa		488b442418		MOVQ 0x18(SP), AX			
  0x44aaaf		4889442440		MOVQ AX, 0x40(SP)			
  0x44aab4		488b6c2420		MOVQ 0x20(SP), BP			
  0x44aab9		4883c428		ADDQ $0x28, SP				
  0x44aabd		c3			RET					
  0x44aabe		e8ad9affff		CALL runtime.morestack_noctxt(SB)	
  0x44aac3		eb8b			JMP type..hash.runtime.symbol_key(SB)	

TEXT type..eq.runtime.symbol_key(SB) <autogenerated>

  0x44aad0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44aad9		483b6110		CMPQ 0x10(CX), SP			
  0x44aadd		0f8682000000		JBE 0x44ab65				
  0x44aae3		4883ec28		SUBQ $0x28, SP				
  0x44aae7		48896c2420		MOVQ BP, 0x20(SP)			
  0x44aaec		488d6c2420		LEAQ 0x20(SP), BP			
  0x44aaf1		488b442430		MOVQ 0x30(SP), AX			
  0x44aaf6		488b4808		MOVQ 0x8(AX), CX			
  0x44aafa		488b10			MOVQ 0(AX), DX				
  0x44aafd		488b5c2438		MOVQ 0x38(SP), BX			
  0x44ab02		488b7308		MOVQ 0x8(BX), SI			
  0x44ab06		488b3b			MOVQ 0(BX), DI				
  0x44ab09		4839f1			CMPQ SI, CX				
  0x44ab0c		7433			JE 0x44ab41				
  0x44ab0e		31c9			XORL CX, CX				
  0x44ab10		84c9			TESTL CL, CL				
  0x44ab12		7510			JNE 0x44ab24				
  0x44ab14		31c0			XORL AX, AX				
  0x44ab16		88442440		MOVB AL, 0x40(SP)			
  0x44ab1a		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ab1f		4883c428		ADDQ $0x28, SP				
  0x44ab23		c3			RET					
  0x44ab24		488d4b10		LEAQ 0x10(BX), CX			
  0x44ab28		48894c2408		MOVQ CX, 0x8(SP)			
  0x44ab2d		4883c010		ADDQ $0x10, AX				
  0x44ab31		48890424		MOVQ AX, 0(SP)				
  0x44ab35		e8566dfbff		CALL runtime.memequal128(SB)		
  0x44ab3a		0fb6442410		MOVZX 0x10(SP), AX			
  0x44ab3f		ebd5			JMP 0x44ab16				
  0x44ab41		48891424		MOVQ DX, 0(SP)				
  0x44ab45		48897c2408		MOVQ DI, 0x8(SP)			
  0x44ab4a		48894c2410		MOVQ CX, 0x10(SP)			
  0x44ab4f		e8ecb7ffff		CALL runtime.memequal(SB)		
  0x44ab54		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44ab59		488b442430		MOVQ 0x30(SP), AX			
  0x44ab5e		488b5c2438		MOVQ 0x38(SP), BX			
  0x44ab63		ebab			JMP 0x44ab10				
  0x44ab65		e8069affff		CALL runtime.morestack_noctxt(SB)	
  0x44ab6a		e961ffffff		JMP type..eq.runtime.symbol_key(SB)	

TEXT type..hash.runtime.traceStack(SB) <autogenerated>

  0x44ab70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ab79		483b6110		CMPQ 0x10(CX), SP			
  0x44ab7d		7668			JBE 0x44abe7				
  0x44ab7f		4883ec28		SUBQ $0x28, SP				
  0x44ab83		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ab88		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ab8d		488b442430		MOVQ 0x30(SP), AX			
  0x44ab92		48890424		MOVQ AX, 0(SP)				
  0x44ab96		488b4c2438		MOVQ 0x38(SP), CX			
  0x44ab9b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44aba0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44aba9		e862affbff		CALL runtime.memhash(SB)		
  0x44abae		488b442418		MOVQ 0x18(SP), AX			
  0x44abb3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44abb8		4883c118		ADDQ $0x18, CX				
  0x44abbc		48890c24		MOVQ CX, 0(SP)				
  0x44abc0		4889442408		MOVQ AX, 0x8(SP)			
  0x44abc5		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44abce		e83daffbff		CALL runtime.memhash(SB)		
  0x44abd3		488b442418		MOVQ 0x18(SP), AX			
  0x44abd8		4889442440		MOVQ AX, 0x40(SP)			
  0x44abdd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44abe2		4883c428		ADDQ $0x28, SP				
  0x44abe6		c3			RET					
  0x44abe7		e88499ffff		CALL runtime.morestack_noctxt(SB)	
  0x44abec		eb82			JMP type..hash.runtime.traceStack(SB)	

TEXT type..eq.runtime.traceStack(SB) <autogenerated>

  0x44abf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44abf9		483b6110		CMPQ 0x10(CX), SP			
  0x44abfd		766a			JBE 0x44ac69				
  0x44abff		4883ec28		SUBQ $0x28, SP				
  0x44ac03		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ac08		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ac0d		488b442438		MOVQ 0x38(SP), AX			
  0x44ac12		4889442408		MOVQ AX, 0x8(SP)			
  0x44ac17		488b4c2430		MOVQ 0x30(SP), CX			
  0x44ac1c		48890c24		MOVQ CX, 0(SP)				
  0x44ac20		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44ac29		e812b7ffff		CALL runtime.memequal(SB)		
  0x44ac2e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44ac33		84c0			TESTL AL, AL				
  0x44ac35		742e			JE 0x44ac65				
  0x44ac37		488b442430		MOVQ 0x30(SP), AX			
  0x44ac3c		488b4018		MOVQ 0x18(AX), AX			
  0x44ac40		488b4c2438		MOVQ 0x38(SP), CX			
  0x44ac45		488b4918		MOVQ 0x18(CX), CX			
  0x44ac49		4839c8			CMPQ CX, AX				
  0x44ac4c		7513			JNE 0x44ac61				
  0x44ac4e		b801000000		MOVL $0x1, AX				
  0x44ac53		88442440		MOVB AL, 0x40(SP)			
  0x44ac57		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ac5c		4883c428		ADDQ $0x28, SP				
  0x44ac60		c3			RET					
  0x44ac61		31c0			XORL AX, AX				
  0x44ac63		ebee			JMP 0x44ac53				
  0x44ac65		31c0			XORL AX, AX				
  0x44ac67		ebea			JMP 0x44ac53				
  0x44ac69		e80299ffff		CALL runtime.morestack_noctxt(SB)	
  0x44ac6e		eb80			JMP type..eq.runtime.traceStack(SB)	

TEXT type..hash.runtime.traceStackTable(SB) <autogenerated>

  0x44ac70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44ac79		483b6110		CMPQ 0x10(CX), SP				
  0x44ac7d		7668			JBE 0x44ace7					
  0x44ac7f		4883ec28		SUBQ $0x28, SP					
  0x44ac83		48896c2420		MOVQ BP, 0x20(SP)				
  0x44ac88		488d6c2420		LEAQ 0x20(SP), BP				
  0x44ac8d		488b442430		MOVQ 0x30(SP), AX				
  0x44ac92		48890424		MOVQ AX, 0(SP)					
  0x44ac96		488b4c2438		MOVQ 0x38(SP), CX				
  0x44ac9b		48894c2408		MOVQ CX, 0x8(SP)				
  0x44aca0		48c74424100c000000	MOVQ $0xc, 0x10(SP)				
  0x44aca9		e862aefbff		CALL runtime.memhash(SB)			
  0x44acae		488b442418		MOVQ 0x18(SP), AX				
  0x44acb3		488b4c2430		MOVQ 0x30(SP), CX				
  0x44acb8		4883c110		ADDQ $0x10, CX					
  0x44acbc		48890c24		MOVQ CX, 0(SP)					
  0x44acc0		4889442408		MOVQ AX, 0x8(SP)				
  0x44acc5		48c744241010000100	MOVQ $0x10010, 0x10(SP)				
  0x44acce		e83daefbff		CALL runtime.memhash(SB)			
  0x44acd3		488b442418		MOVQ 0x18(SP), AX				
  0x44acd8		4889442440		MOVQ AX, 0x40(SP)				
  0x44acdd		488b6c2420		MOVQ 0x20(SP), BP				
  0x44ace2		4883c428		ADDQ $0x28, SP					
  0x44ace6		c3			RET						
  0x44ace7		e88498ffff		CALL runtime.morestack_noctxt(SB)		
  0x44acec		eb82			JMP type..hash.runtime.traceStackTable(SB)	

TEXT type..eq.runtime.traceStackTable(SB) <autogenerated>

  0x44acf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44acf9		483b6110		CMPQ 0x10(CX), SP				
  0x44acfd		0f868e000000		JBE 0x44ad91					
  0x44ad03		4883ec28		SUBQ $0x28, SP					
  0x44ad07		48896c2420		MOVQ BP, 0x20(SP)				
  0x44ad0c		488d6c2420		LEAQ 0x20(SP), BP				
  0x44ad11		488b442438		MOVQ 0x38(SP), AX				
  0x44ad16		488b08			MOVQ 0(AX), CX					
  0x44ad19		488b542430		MOVQ 0x30(SP), DX				
  0x44ad1e		488b1a			MOVQ 0(DX), BX					
  0x44ad21		4839cb			CMPQ CX, BX					
  0x44ad24		7567			JNE 0x44ad8d					
  0x44ad26		8b4a08			MOVL 0x8(DX), CX				
  0x44ad29		8b5808			MOVL 0x8(AX), BX				
  0x44ad2c		39d9			CMPL BX, CX					
  0x44ad2e		7559			JNE 0x44ad89					
  0x44ad30		488b4810		MOVQ 0x10(AX), CX				
  0x44ad34		488b5a10		MOVQ 0x10(DX), BX				
  0x44ad38		4839cb			CMPQ CX, BX					
  0x44ad3b		7548			JNE 0x44ad85					
  0x44ad3d		488b4818		MOVQ 0x18(AX), CX				
  0x44ad41		488b5a18		MOVQ 0x18(DX), BX				
  0x44ad45		4839cb			CMPQ CX, BX					
  0x44ad48		0f94c1			SETE CL						
  0x44ad4b		84c9			TESTL CL, CL					
  0x44ad4d		7510			JNE 0x44ad5f					
  0x44ad4f		31c0			XORL AX, AX					
  0x44ad51		88442440		MOVB AL, 0x40(SP)				
  0x44ad55		488b6c2420		MOVQ 0x20(SP), BP				
  0x44ad5a		4883c428		ADDQ $0x28, SP					
  0x44ad5e		c3			RET						
  0x44ad5f		488d4a20		LEAQ 0x20(DX), CX				
  0x44ad63		48890c24		MOVQ CX, 0(SP)					
  0x44ad67		4883c020		ADDQ $0x20, AX					
  0x44ad6b		4889442408		MOVQ AX, 0x8(SP)				
  0x44ad70		48c744241000000100	MOVQ $0x10000, 0x10(SP)				
  0x44ad79		e8c2b5ffff		CALL runtime.memequal(SB)			
  0x44ad7e		0fb6442418		MOVZX 0x18(SP), AX				
  0x44ad83		ebcc			JMP 0x44ad51					
  0x44ad85		31c9			XORL CX, CX					
  0x44ad87		ebc2			JMP 0x44ad4b					
  0x44ad89		31c0			XORL AX, AX					
  0x44ad8b		ebc4			JMP 0x44ad51					
  0x44ad8d		31c0			XORL AX, AX					
  0x44ad8f		ebc0			JMP 0x44ad51					
  0x44ad91		e8da97ffff		CALL runtime.morestack_noctxt(SB)		
  0x44ad96		e955ffffff		JMP type..eq.runtime.traceStackTable(SB)	

TEXT type..hash.runtime.version_key(SB) <autogenerated>

  0x44ada0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ada9		483b6110		CMPQ 0x10(CX), SP			
  0x44adad		765f			JBE 0x44ae0e				
  0x44adaf		4883ec28		SUBQ $0x28, SP				
  0x44adb3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44adb8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44adbd		488b442430		MOVQ 0x30(SP), AX			
  0x44adc2		48890424		MOVQ AX, 0(SP)				
  0x44adc6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44adcb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44add0		e8ab63fbff		CALL runtime.strhash(SB)		
  0x44add5		488b442410		MOVQ 0x10(SP), AX			
  0x44adda		488b4c2430		MOVQ 0x30(SP), CX			
  0x44addf		4883c110		ADDQ $0x10, CX				
  0x44ade3		48890c24		MOVQ CX, 0(SP)				
  0x44ade7		4889442408		MOVQ AX, 0x8(SP)			
  0x44adec		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x44adf5		e816adfbff		CALL runtime.memhash(SB)		
  0x44adfa		488b442418		MOVQ 0x18(SP), AX			
  0x44adff		4889442440		MOVQ AX, 0x40(SP)			
  0x44ae04		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ae09		4883c428		ADDQ $0x28, SP				
  0x44ae0d		c3			RET					
  0x44ae0e		e85d97ffff		CALL runtime.morestack_noctxt(SB)	
  0x44ae13		eb8b			JMP type..hash.runtime.version_key(SB)	

TEXT type..eq.runtime.version_key(SB) <autogenerated>

  0x44ae20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ae29		483b6110		CMPQ 0x10(CX), SP			
  0x44ae2d		7672			JBE 0x44aea1				
  0x44ae2f		4883ec28		SUBQ $0x28, SP				
  0x44ae33		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ae38		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ae3d		488b442430		MOVQ 0x30(SP), AX			
  0x44ae42		488b4808		MOVQ 0x8(AX), CX			
  0x44ae46		488b10			MOVQ 0(AX), DX				
  0x44ae49		488b5c2438		MOVQ 0x38(SP), BX			
  0x44ae4e		488b7308		MOVQ 0x8(BX), SI			
  0x44ae52		488b3b			MOVQ 0(BX), DI				
  0x44ae55		4839f1			CMPQ SI, CX				
  0x44ae58		7423			JE 0x44ae7d				
  0x44ae5a		31c9			XORL CX, CX				
  0x44ae5c		84c9			TESTL CL, CL				
  0x44ae5e		7419			JE 0x44ae79				
  0x44ae60		8b4010			MOVL 0x10(AX), AX			
  0x44ae63		8b4b10			MOVL 0x10(BX), CX			
  0x44ae66		39c8			CMPL CX, AX				
  0x44ae68		0f94c0			SETE AL					
  0x44ae6b		88442440		MOVB AL, 0x40(SP)			
  0x44ae6f		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ae74		4883c428		ADDQ $0x28, SP				
  0x44ae78		c3			RET					
  0x44ae79		31c0			XORL AX, AX				
  0x44ae7b		ebee			JMP 0x44ae6b				
  0x44ae7d		48891424		MOVQ DX, 0(SP)				
  0x44ae81		48897c2408		MOVQ DI, 0x8(SP)			
  0x44ae86		48894c2410		MOVQ CX, 0x10(SP)			
  0x44ae8b		e8b0b4ffff		CALL runtime.memequal(SB)		
  0x44ae90		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44ae95		488b442430		MOVQ 0x30(SP), AX			
  0x44ae9a		488b5c2438		MOVQ 0x38(SP), BX			
  0x44ae9f		ebbb			JMP 0x44ae5c				
  0x44aea1		e8ca96ffff		CALL runtime.morestack_noctxt(SB)	
  0x44aea6		e975ffffff		JMP type..eq.runtime.version_key(SB)	

TEXT type..hash.[14]runtime.dbgVar(SB) <autogenerated>

  0x44aeb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44aeb9		483b6110		CMPQ 0x10(CX), SP			
  0x44aebd		7659			JBE 0x44af18				
  0x44aebf		4883ec28		SUBQ $0x28, SP				
  0x44aec3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44aec8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44aecd		31c0			XORL AX, AX				
  0x44aecf		488b4c2438		MOVQ 0x38(SP), CX			
  0x44aed4		eb2d			JMP 0x44af03				
  0x44aed6		4889442418		MOVQ AX, 0x18(SP)			
  0x44aedb		488d1440		LEAQ 0(AX)(AX*2), DX			
  0x44aedf		488b5c2430		MOVQ 0x30(SP), BX			
  0x44aee4		488d14d3		LEAQ 0(BX)(DX*8), DX			
  0x44aee8		48891424		MOVQ DX, 0(SP)				
  0x44aeec		48894c2408		MOVQ CX, 0x8(SP)			
  0x44aef1		e8cae3ffff		CALL type..hash.runtime.dbgVar(SB)	
  0x44aef6		488b4c2410		MOVQ 0x10(SP), CX			
  0x44aefb		488b442418		MOVQ 0x18(SP), AX			
  0x44af00		48ffc0			INCQ AX					
  0x44af03		4883f80e		CMPQ $0xe, AX				
  0x44af07		7ccd			JL 0x44aed6				
  0x44af09		48894c2440		MOVQ CX, 0x40(SP)			
  0x44af0e		488b6c2420		MOVQ 0x20(SP), BP			
  0x44af13		4883c428		ADDQ $0x28, SP				
  0x44af17		c3			RET					
  0x44af18		e85396ffff		CALL runtime.morestack_noctxt(SB)	
  0x44af1d		eb91			JMP type..hash.[14]runtime.dbgVar(SB)	

TEXT type..eq.[14]runtime.dbgVar(SB) <autogenerated>

  0x44af20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44af29		483b6110		CMPQ 0x10(CX), SP			
  0x44af2d		0f86a8000000		JBE 0x44afdb				
  0x44af33		4883ec38		SUBQ $0x38, SP				
  0x44af37		48896c2430		MOVQ BP, 0x30(SP)			
  0x44af3c		488d6c2430		LEAQ 0x30(SP), BP			
  0x44af41		31c0			XORL AX, AX				
  0x44af43		eb09			JMP 0x44af4e				
  0x44af45		488b542420		MOVQ 0x20(SP), DX			
  0x44af4a		488d4201		LEAQ 0x1(DX), AX			
  0x44af4e		4883f80e		CMPQ $0xe, AX				
  0x44af52		7d78			JGE 0x44afcc				
  0x44af54		488d0c40		LEAQ 0(AX)(AX*2), CX			
  0x44af58		488b542440		MOVQ 0x40(SP), DX			
  0x44af5d		488b1cca		MOVQ 0(DX)(CX*8), BX			
  0x44af61		488b74ca08		MOVQ 0x8(DX)(CX*8), SI			
  0x44af66		488b7c2448		MOVQ 0x48(SP), DI			
  0x44af6b		4c8b04cf		MOVQ 0(DI)(CX*8), R8			
  0x44af6f		4c8b4ccf08		MOVQ 0x8(DI)(CX*8), R9			
  0x44af74		4c39ce			CMPQ R9, SI				
  0x44af77		7544			JNE 0x44afbd				
  0x44af79		4889442420		MOVQ AX, 0x20(SP)			
  0x44af7e		48894c2428		MOVQ CX, 0x28(SP)			
  0x44af83		48891c24		MOVQ BX, 0(SP)				
  0x44af87		4c89442408		MOVQ R8, 0x8(SP)			
  0x44af8c		4889742410		MOVQ SI, 0x10(SP)			
  0x44af91		e8aab3ffff		CALL runtime.memequal(SB)		
  0x44af96		0fb6442418		MOVZX 0x18(SP), AX			
  0x44af9b		84c0			TESTL AL, AL				
  0x44af9d		741e			JE 0x44afbd				
  0x44af9f		488b442428		MOVQ 0x28(SP), AX			
  0x44afa4		488b4c2440		MOVQ 0x40(SP), CX			
  0x44afa9		488b54c110		MOVQ 0x10(CX)(AX*8), DX			
  0x44afae		488b5c2448		MOVQ 0x48(SP), BX			
  0x44afb3		488b44c310		MOVQ 0x10(BX)(AX*8), AX			
  0x44afb8		4839c2			CMPQ AX, DX				
  0x44afbb		7488			JE 0x44af45				
  0x44afbd		c644245000		MOVB $0x0, 0x50(SP)			
  0x44afc2		488b6c2430		MOVQ 0x30(SP), BP			
  0x44afc7		4883c438		ADDQ $0x38, SP				
  0x44afcb		c3			RET					
  0x44afcc		c644245001		MOVB $0x1, 0x50(SP)			
  0x44afd1		488b6c2430		MOVQ 0x30(SP), BP			
  0x44afd6		4883c438		ADDQ $0x38, SP				
  0x44afda		c3			RET					
  0x44afdb		e89095ffff		CALL runtime.morestack_noctxt(SB)	
  0x44afe0		e93bffffff		JMP type..eq.[14]runtime.dbgVar(SB)	

TEXT type..hash.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44aff0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44aff9		483b6110		CMPQ 0x10(CX), SP									
  0x44affd		765f			JBE 0x44b05e										
  0x44afff		4883ec28		SUBQ $0x28, SP										
  0x44b003		48896c2420		MOVQ BP, 0x20(SP)									
  0x44b008		488d6c2420		LEAQ 0x20(SP), BP									
  0x44b00d		488b442430		MOVQ 0x30(SP), AX									
  0x44b012		48890424		MOVQ AX, 0(SP)										
  0x44b016		488b4c2438		MOVQ 0x38(SP), CX									
  0x44b01b		48894c2408		MOVQ CX, 0x8(SP)									
  0x44b020		e89bf5ffff		CALL type..hash.runtime.semaRoot(SB)							
  0x44b025		488b442410		MOVQ 0x10(SP), AX									
  0x44b02a		488b4c2430		MOVQ 0x30(SP), CX									
  0x44b02f		4883c118		ADDQ $0x18, CX										
  0x44b033		48890c24		MOVQ CX, 0(SP)										
  0x44b037		4889442408		MOVQ AX, 0x8(SP)									
  0x44b03c		48c744241028000000	MOVQ $0x28, 0x10(SP)									
  0x44b045		e8c6aafbff		CALL runtime.memhash(SB)								
  0x44b04a		488b442418		MOVQ 0x18(SP), AX									
  0x44b04f		4889442440		MOVQ AX, 0x40(SP)									
  0x44b054		488b6c2420		MOVQ 0x20(SP), BP									
  0x44b059		4883c428		ADDQ $0x28, SP										
  0x44b05d		c3			RET											
  0x44b05e		e80d95ffff		CALL runtime.morestack_noctxt(SB)							
  0x44b063		eb8b			JMP type..hash.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..eq.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44b070		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44b079		483b6110		CMPQ 0x10(CX), SP									
  0x44b07d		7678			JBE 0x44b0f7										
  0x44b07f		4883ec28		SUBQ $0x28, SP										
  0x44b083		48896c2420		MOVQ BP, 0x20(SP)									
  0x44b088		488d6c2420		LEAQ 0x20(SP), BP									
  0x44b08d		488b442430		MOVQ 0x30(SP), AX									
  0x44b092		488b08			MOVQ 0(AX), CX										
  0x44b095		488b542438		MOVQ 0x38(SP), DX									
  0x44b09a		488b1a			MOVQ 0(DX), BX										
  0x44b09d		4839d9			CMPQ BX, CX										
  0x44b0a0		7551			JNE 0x44b0f3										
  0x44b0a2		488b4808		MOVQ 0x8(AX), CX									
  0x44b0a6		488b5a08		MOVQ 0x8(DX), BX									
  0x44b0aa		4839d9			CMPQ BX, CX										
  0x44b0ad		7540			JNE 0x44b0ef										
  0x44b0af		8b4810			MOVL 0x10(AX), CX									
  0x44b0b2		8b5a10			MOVL 0x10(DX), BX									
  0x44b0b5		39d9			CMPL BX, CX										
  0x44b0b7		7410			JE 0x44b0c9										
  0x44b0b9		31c0			XORL AX, AX										
  0x44b0bb		88442440		MOVB AL, 0x40(SP)									
  0x44b0bf		488b6c2420		MOVQ 0x20(SP), BP									
  0x44b0c4		4883c428		ADDQ $0x28, SP										
  0x44b0c8		c3			RET											
  0x44b0c9		4883c018		ADDQ $0x18, AX										
  0x44b0cd		48890424		MOVQ AX, 0(SP)										
  0x44b0d1		488d4218		LEAQ 0x18(DX), AX									
  0x44b0d5		4889442408		MOVQ AX, 0x8(SP)									
  0x44b0da		48c744241028000000	MOVQ $0x28, 0x10(SP)									
  0x44b0e3		e858b2ffff		CALL runtime.memequal(SB)								
  0x44b0e8		0fb6442418		MOVZX 0x18(SP), AX									
  0x44b0ed		ebcc			JMP 0x44b0bb										
  0x44b0ef		31c0			XORL AX, AX										
  0x44b0f1		ebc8			JMP 0x44b0bb										
  0x44b0f3		31c0			XORL AX, AX										
  0x44b0f5		ebc4			JMP 0x44b0bb										
  0x44b0f7		e87494ffff		CALL runtime.morestack_noctxt(SB)							
  0x44b0fc		e96fffffff		JMP type..eq.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..hash.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44b110		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44b119		483b6110		CMPQ 0x10(CX), SP									
  0x44b11d		765a			JBE 0x44b179										
  0x44b11f		4883ec28		SUBQ $0x28, SP										
  0x44b123		48896c2420		MOVQ BP, 0x20(SP)									
  0x44b128		488d6c2420		LEAQ 0x20(SP), BP									
  0x44b12d		31c0			XORL AX, AX										
  0x44b12f		488b4c2438		MOVQ 0x38(SP), CX									
  0x44b134		eb2c			JMP 0x44b162										
  0x44b136		4889442418		MOVQ AX, 0x18(SP)									
  0x44b13b		48c1e006		SHLQ $0x6, AX										
  0x44b13f		488b5c2430		MOVQ 0x30(SP), BX									
  0x44b144		4801d8			ADDQ BX, AX										
  0x44b147		48890424		MOVQ AX, 0(SP)										
  0x44b14b		48894c2408		MOVQ CX, 0x8(SP)									
  0x44b150		e89bfeffff		CALL type..hash.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	
  0x44b155		488b4c2410		MOVQ 0x10(SP), CX									
  0x44b15a		488b442418		MOVQ 0x18(SP), AX									
  0x44b15f		48ffc0			INCQ AX											
  0x44b162		483dfb000000		CMPQ $0xfb, AX										
  0x44b168		7ccc			JL 0x44b136										
  0x44b16a		48894c2440		MOVQ CX, 0x40(SP)									
  0x44b16f		488b6c2420		MOVQ 0x20(SP), BP									
  0x44b174		4883c428		ADDQ $0x28, SP										
  0x44b178		c3			RET											
  0x44b179		e8f293ffff		CALL runtime.morestack_noctxt(SB)							
  0x44b17e		eb90			JMP type..hash.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..eq.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44b180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44b189		483b6110		CMPQ 0x10(CX), SP									
  0x44b18d		0f86a9000000		JBE 0x44b23c										
  0x44b193		4883ec30		SUBQ $0x30, SP										
  0x44b197		48896c2428		MOVQ BP, 0x28(SP)									
  0x44b19c		488d6c2428		LEAQ 0x28(SP), BP									
  0x44b1a1		31c0			XORL AX, AX										
  0x44b1a3		eb09			JMP 0x44b1ae										
  0x44b1a5		488b4c2420		MOVQ 0x20(SP), CX									
  0x44b1aa		488d4101		LEAQ 0x1(CX), AX									
  0x44b1ae		483dfb000000		CMPQ $0xfb, AX										
  0x44b1b4		7d77			JGE 0x44b22d										
  0x44b1b6		4889c1			MOVQ AX, CX										
  0x44b1b9		48c1e006		SHLQ $0x6, AX										
  0x44b1bd		488b542438		MOVQ 0x38(SP), DX									
  0x44b1c2		488b1c10		MOVQ 0(AX)(DX*1), BX									
  0x44b1c6		488b742440		MOVQ 0x40(SP), SI									
  0x44b1cb		488b3c30		MOVQ 0(AX)(SI*1), DI									
  0x44b1cf		4839fb			CMPQ DI, BX										
  0x44b1d2		754a			JNE 0x44b21e										
  0x44b1d4		488b5c1008		MOVQ 0x8(AX)(DX*1), BX									
  0x44b1d9		488b7c3008		MOVQ 0x8(AX)(SI*1), DI									
  0x44b1de		4839fb			CMPQ DI, BX										
  0x44b1e1		753b			JNE 0x44b21e										
  0x44b1e3		8b5c1010		MOVL 0x10(AX)(DX*1), BX									
  0x44b1e7		8b7c3010		MOVL 0x10(AX)(SI*1), DI									
  0x44b1eb		39fb			CMPL DI, BX										
  0x44b1ed		752f			JNE 0x44b21e										
  0x44b1ef		48894c2420		MOVQ CX, 0x20(SP)									
  0x44b1f4		488d4c1018		LEAQ 0x18(AX)(DX*1), CX									
  0x44b1f9		48890c24		MOVQ CX, 0(SP)										
  0x44b1fd		488d443018		LEAQ 0x18(AX)(SI*1), AX									
  0x44b202		4889442408		MOVQ AX, 0x8(SP)									
  0x44b207		48c744241028000000	MOVQ $0x28, 0x10(SP)									
  0x44b210		e82bb1ffff		CALL runtime.memequal(SB)								
  0x44b215		0fb6442418		MOVZX 0x18(SP), AX									
  0x44b21a		84c0			TESTL AL, AL										
  0x44b21c		7587			JNE 0x44b1a5										
  0x44b21e		c644244800		MOVB $0x0, 0x48(SP)									
  0x44b223		488b6c2428		MOVQ 0x28(SP), BP									
  0x44b228		4883c430		ADDQ $0x30, SP										
  0x44b22c		c3			RET											
  0x44b22d		c644244801		MOVB $0x1, 0x48(SP)									
  0x44b232		488b6c2428		MOVQ 0x28(SP), BP									
  0x44b237		4883c430		ADDQ $0x30, SP										
  0x44b23b		c3			RET											
  0x44b23c		e82f93ffff		CALL runtime.morestack_noctxt(SB)							
  0x44b241		e93affffff		JMP type..eq.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..hash.[2]string(SB) <autogenerated>

  0x44b250		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b259		483b6110		CMPQ 0x10(CX), SP			
  0x44b25d		7658			JBE 0x44b2b7				
  0x44b25f		4883ec28		SUBQ $0x28, SP				
  0x44b263		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b268		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b26d		31c0			XORL AX, AX				
  0x44b26f		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b274		eb2c			JMP 0x44b2a2				
  0x44b276		4889442418		MOVQ AX, 0x18(SP)			
  0x44b27b		48c1e004		SHLQ $0x4, AX				
  0x44b27f		488b5c2430		MOVQ 0x30(SP), BX			
  0x44b284		4801d8			ADDQ BX, AX				
  0x44b287		48890424		MOVQ AX, 0(SP)				
  0x44b28b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b290		e8eb5efbff		CALL runtime.strhash(SB)		
  0x44b295		488b4c2410		MOVQ 0x10(SP), CX			
  0x44b29a		488b442418		MOVQ 0x18(SP), AX			
  0x44b29f		48ffc0			INCQ AX					
  0x44b2a2		4883f802		CMPQ $0x2, AX				
  0x44b2a6		7cce			JL 0x44b276				
  0x44b2a8		48894c2440		MOVQ CX, 0x40(SP)			
  0x44b2ad		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b2b2		4883c428		ADDQ $0x28, SP				
  0x44b2b6		c3			RET					
  0x44b2b7		e8b492ffff		CALL runtime.morestack_noctxt(SB)	
  0x44b2bc		eb92			JMP type..hash.[2]string(SB)		

TEXT type..eq.[2]string(SB) <autogenerated>

  0x44b2c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b2c9		483b6110		CMPQ 0x10(CX), SP			
  0x44b2cd		0f8688000000		JBE 0x44b35b				
  0x44b2d3		4883ec30		SUBQ $0x30, SP				
  0x44b2d7		48896c2428		MOVQ BP, 0x28(SP)			
  0x44b2dc		488d6c2428		LEAQ 0x28(SP), BP			
  0x44b2e1		31c0			XORL AX, AX				
  0x44b2e3		eb09			JMP 0x44b2ee				
  0x44b2e5		488b4c2420		MOVQ 0x20(SP), CX			
  0x44b2ea		488d4101		LEAQ 0x1(CX), AX			
  0x44b2ee		4883f802		CMPQ $0x2, AX				
  0x44b2f2		7d58			JGE 0x44b34c				
  0x44b2f4		4889c1			MOVQ AX, CX				
  0x44b2f7		48c1e004		SHLQ $0x4, AX				
  0x44b2fb		488b542440		MOVQ 0x40(SP), DX			
  0x44b300		488b5c1008		MOVQ 0x8(AX)(DX*1), BX			
  0x44b305		488b3410		MOVQ 0(AX)(DX*1), SI			
  0x44b309		488b7c2438		MOVQ 0x38(SP), DI			
  0x44b30e		4c8b0438		MOVQ 0(AX)(DI*1), R8			
  0x44b312		488b443808		MOVQ 0x8(AX)(DI*1), AX			
  0x44b317		4839d8			CMPQ BX, AX				
  0x44b31a		7521			JNE 0x44b33d				
  0x44b31c		48894c2420		MOVQ CX, 0x20(SP)			
  0x44b321		4c890424		MOVQ R8, 0(SP)				
  0x44b325		4889742408		MOVQ SI, 0x8(SP)			
  0x44b32a		4889442410		MOVQ AX, 0x10(SP)			
  0x44b32f		e80cb0ffff		CALL runtime.memequal(SB)		
  0x44b334		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b339		84c0			TESTL AL, AL				
  0x44b33b		75a8			JNE 0x44b2e5				
  0x44b33d		c644244800		MOVB $0x0, 0x48(SP)			
  0x44b342		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b347		4883c430		ADDQ $0x30, SP				
  0x44b34b		c3			RET					
  0x44b34c		c644244801		MOVB $0x1, 0x48(SP)			
  0x44b351		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b356		4883c430		ADDQ $0x30, SP				
  0x44b35a		c3			RET					
  0x44b35b		e81092ffff		CALL runtime.morestack_noctxt(SB)	
  0x44b360		e95bffffff		JMP type..eq.[2]string(SB)		

TEXT type..hash.[33]float64(SB) <autogenerated>

  0x44b370		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b379		483b6110		CMPQ 0x10(CX), SP			
  0x44b37d		7655			JBE 0x44b3d4				
  0x44b37f		4883ec28		SUBQ $0x28, SP				
  0x44b383		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b388		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b38d		31c0			XORL AX, AX				
  0x44b38f		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b394		eb29			JMP 0x44b3bf				
  0x44b396		4889442418		MOVQ AX, 0x18(SP)			
  0x44b39b		488b542430		MOVQ 0x30(SP), DX			
  0x44b3a0		488d1cc2		LEAQ 0(DX)(AX*8), BX			
  0x44b3a4		48891c24		MOVQ BX, 0(SP)				
  0x44b3a8		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b3ad		e84e5ffbff		CALL runtime.f64hash(SB)		
  0x44b3b2		488b4c2410		MOVQ 0x10(SP), CX			
  0x44b3b7		488b442418		MOVQ 0x18(SP), AX			
  0x44b3bc		48ffc0			INCQ AX					
  0x44b3bf		4883f821		CMPQ $0x21, AX				
  0x44b3c3		7cd1			JL 0x44b396				
  0x44b3c5		48894c2440		MOVQ CX, 0x40(SP)			
  0x44b3ca		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b3cf		4883c428		ADDQ $0x28, SP				
  0x44b3d3		c3			RET					
  0x44b3d4		e89791ffff		CALL runtime.morestack_noctxt(SB)	
  0x44b3d9		eb95			JMP type..hash.[33]float64(SB)		

TEXT type..eq.[33]float64(SB) <autogenerated>

  0x44b3e0		488b442408		MOVQ 0x8(SP), AX		
  0x44b3e5		488b4c2410		MOVQ 0x10(SP), CX		
  0x44b3ea		31d2			XORL DX, DX			
  0x44b3ec		eb03			JMP 0x44b3f1			
  0x44b3ee		48ffc2			INCQ DX				
  0x44b3f1		4883fa21		CMPQ $0x21, DX			
  0x44b3f5		7d18			JGE 0x44b40f			
  0x44b3f7		f20f1004d0		MOVSD_XMM 0(AX)(DX*8), X0	
  0x44b3fc		f20f100cd1		MOVSD_XMM 0(CX)(DX*8), X1	
  0x44b401		660f2ec1		UCOMISD X1, X0			
  0x44b405		7502			JNE 0x44b409			
  0x44b407		7be5			JNP 0x44b3ee			
  0x44b409		c644241800		MOVB $0x0, 0x18(SP)		
  0x44b40e		c3			RET				
  0x44b40f		c644241801		MOVB $0x1, 0x18(SP)		
  0x44b414		c3			RET				

TEXT type..hash.[3]runtime.symbol_key(SB) <autogenerated>

  0x44b420		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44b429		483b6110		CMPQ 0x10(CX), SP				
  0x44b42d		7658			JBE 0x44b487					
  0x44b42f		4883ec28		SUBQ $0x28, SP					
  0x44b433		48896c2420		MOVQ BP, 0x20(SP)				
  0x44b438		488d6c2420		LEAQ 0x20(SP), BP				
  0x44b43d		31c0			XORL AX, AX					
  0x44b43f		488b4c2438		MOVQ 0x38(SP), CX				
  0x44b444		eb2c			JMP 0x44b472					
  0x44b446		4889442418		MOVQ AX, 0x18(SP)				
  0x44b44b		48c1e005		SHLQ $0x5, AX					
  0x44b44f		488b5c2430		MOVQ 0x30(SP), BX				
  0x44b454		4801d8			ADDQ BX, AX					
  0x44b457		48890424		MOVQ AX, 0(SP)					
  0x44b45b		48894c2408		MOVQ CX, 0x8(SP)				
  0x44b460		e8ebf5ffff		CALL type..hash.runtime.symbol_key(SB)		
  0x44b465		488b4c2410		MOVQ 0x10(SP), CX				
  0x44b46a		488b442418		MOVQ 0x18(SP), AX				
  0x44b46f		48ffc0			INCQ AX						
  0x44b472		4883f803		CMPQ $0x3, AX					
  0x44b476		7cce			JL 0x44b446					
  0x44b478		48894c2440		MOVQ CX, 0x40(SP)				
  0x44b47d		488b6c2420		MOVQ 0x20(SP), BP				
  0x44b482		4883c428		ADDQ $0x28, SP					
  0x44b486		c3			RET						
  0x44b487		e8e490ffff		CALL runtime.morestack_noctxt(SB)		
  0x44b48c		eb92			JMP type..hash.[3]runtime.symbol_key(SB)	

TEXT type..eq.[3]runtime.symbol_key(SB) <autogenerated>

  0x44b490		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b499		483b6110		CMPQ 0x10(CX), SP			
  0x44b49d		0f86cd000000		JBE 0x44b570				
  0x44b4a3		4883ec38		SUBQ $0x38, SP				
  0x44b4a7		48896c2430		MOVQ BP, 0x30(SP)			
  0x44b4ac		488d6c2430		LEAQ 0x30(SP), BP			
  0x44b4b1		31c0			XORL AX, AX				
  0x44b4b3		eb0b			JMP 0x44b4c0				
  0x44b4b5		488b4c2428		MOVQ 0x28(SP), CX			
  0x44b4ba		48ffc1			INCQ CX					
  0x44b4bd		4889c8			MOVQ CX, AX				
  0x44b4c0		4883f803		CMPQ $0x3, AX				
  0x44b4c4		0f8d97000000		JGE 0x44b561				
  0x44b4ca		4889c1			MOVQ AX, CX				
  0x44b4cd		48c1e005		SHLQ $0x5, AX				
  0x44b4d1		488b542448		MOVQ 0x48(SP), DX			
  0x44b4d6		488b5c1008		MOVQ 0x8(AX)(DX*1), BX			
  0x44b4db		488b3410		MOVQ 0(AX)(DX*1), SI			
  0x44b4df		488b7c2440		MOVQ 0x40(SP), DI			
  0x44b4e4		4c8b443808		MOVQ 0x8(AX)(DI*1), R8			
  0x44b4e9		4c8b0c38		MOVQ 0(AX)(DI*1), R9			
  0x44b4ed		4939d8			CMPQ BX, R8				
  0x44b4f0		7560			JNE 0x44b552				
  0x44b4f2		48894c2428		MOVQ CX, 0x28(SP)			
  0x44b4f7		4889442420		MOVQ AX, 0x20(SP)			
  0x44b4fc		4c890c24		MOVQ R9, 0(SP)				
  0x44b500		4889742408		MOVQ SI, 0x8(SP)			
  0x44b505		4c89442410		MOVQ R8, 0x10(SP)			
  0x44b50a		e831aeffff		CALL runtime.memequal(SB)		
  0x44b50f		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b514		84c0			TESTL AL, AL				
  0x44b516		743a			JE 0x44b552				
  0x44b518		488b442440		MOVQ 0x40(SP), AX			
  0x44b51d		488b4c2420		MOVQ 0x20(SP), CX			
  0x44b522		8b540110		MOVL 0x10(CX)(AX*1), DX			
  0x44b526		488b5c2448		MOVQ 0x48(SP), BX			
  0x44b52b		8b741910		MOVL 0x10(CX)(BX*1), SI			
  0x44b52f		39d6			CMPL DX, SI				
  0x44b531		751f			JNE 0x44b552				
  0x44b533		8b540114		MOVL 0x14(CX)(AX*1), DX			
  0x44b537		8b741914		MOVL 0x14(CX)(BX*1), SI			
  0x44b53b		39f2			CMPL SI, DX				
  0x44b53d		7513			JNE 0x44b552				
  0x44b53f		488b540118		MOVQ 0x18(CX)(AX*1), DX			
  0x44b544		488b4c1918		MOVQ 0x18(CX)(BX*1), CX			
  0x44b549		4839ca			CMPQ CX, DX				
  0x44b54c		0f8463ffffff		JE 0x44b4b5				
  0x44b552		c644245000		MOVB $0x0, 0x50(SP)			
  0x44b557		488b6c2430		MOVQ 0x30(SP), BP			
  0x44b55c		4883c438		ADDQ $0x38, SP				
  0x44b560		c3			RET					
  0x44b561		c644245001		MOVB $0x1, 0x50(SP)			
  0x44b566		488b6c2430		MOVQ 0x30(SP), BP			
  0x44b56b		4883c438		ADDQ $0x38, SP				
  0x44b56f		c3			RET					
  0x44b570		e8fb8fffff		CALL runtime.morestack_noctxt(SB)	
  0x44b575		e916ffffff		JMP type..eq.[3]runtime.symbol_key(SB)	

TEXT type..hash.[4]string(SB) <autogenerated>

  0x44b580		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b589		483b6110		CMPQ 0x10(CX), SP			
  0x44b58d		7658			JBE 0x44b5e7				
  0x44b58f		4883ec28		SUBQ $0x28, SP				
  0x44b593		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b598		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b59d		31c0			XORL AX, AX				
  0x44b59f		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b5a4		eb2c			JMP 0x44b5d2				
  0x44b5a6		4889442418		MOVQ AX, 0x18(SP)			
  0x44b5ab		48c1e004		SHLQ $0x4, AX				
  0x44b5af		488b5c2430		MOVQ 0x30(SP), BX			
  0x44b5b4		4801d8			ADDQ BX, AX				
  0x44b5b7		48890424		MOVQ AX, 0(SP)				
  0x44b5bb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b5c0		e8bb5bfbff		CALL runtime.strhash(SB)		
  0x44b5c5		488b4c2410		MOVQ 0x10(SP), CX			
  0x44b5ca		488b442418		MOVQ 0x18(SP), AX			
  0x44b5cf		48ffc0			INCQ AX					
  0x44b5d2		4883f804		CMPQ $0x4, AX				
  0x44b5d6		7cce			JL 0x44b5a6				
  0x44b5d8		48894c2440		MOVQ CX, 0x40(SP)			
  0x44b5dd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b5e2		4883c428		ADDQ $0x28, SP				
  0x44b5e6		c3			RET					
  0x44b5e7		e8848fffff		CALL runtime.morestack_noctxt(SB)	
  0x44b5ec		eb92			JMP type..hash.[4]string(SB)		

TEXT type..eq.[4]string(SB) <autogenerated>

  0x44b5f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b5f9		483b6110		CMPQ 0x10(CX), SP			
  0x44b5fd		0f8688000000		JBE 0x44b68b				
  0x44b603		4883ec30		SUBQ $0x30, SP				
  0x44b607		48896c2428		MOVQ BP, 0x28(SP)			
  0x44b60c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44b611		31c0			XORL AX, AX				
  0x44b613		eb09			JMP 0x44b61e				
  0x44b615		488b4c2420		MOVQ 0x20(SP), CX			
  0x44b61a		488d4101		LEAQ 0x1(CX), AX			
  0x44b61e		4883f804		CMPQ $0x4, AX				
  0x44b622		7d58			JGE 0x44b67c				
  0x44b624		4889c1			MOVQ AX, CX				
  0x44b627		48c1e004		SHLQ $0x4, AX				
  0x44b62b		488b542440		MOVQ 0x40(SP), DX			
  0x44b630		488b5c1008		MOVQ 0x8(AX)(DX*1), BX			
  0x44b635		488b3410		MOVQ 0(AX)(DX*1), SI			
  0x44b639		488b7c2438		MOVQ 0x38(SP), DI			
  0x44b63e		4c8b0438		MOVQ 0(AX)(DI*1), R8			
  0x44b642		488b443808		MOVQ 0x8(AX)(DI*1), AX			
  0x44b647		4839d8			CMPQ BX, AX				
  0x44b64a		7521			JNE 0x44b66d				
  0x44b64c		48894c2420		MOVQ CX, 0x20(SP)			
  0x44b651		4c890424		MOVQ R8, 0(SP)				
  0x44b655		4889742408		MOVQ SI, 0x8(SP)			
  0x44b65a		4889442410		MOVQ AX, 0x10(SP)			
  0x44b65f		e8dcacffff		CALL runtime.memequal(SB)		
  0x44b664		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b669		84c0			TESTL AL, AL				
  0x44b66b		75a8			JNE 0x44b615				
  0x44b66d		c644244800		MOVB $0x0, 0x48(SP)			
  0x44b672		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b677		4883c430		ADDQ $0x30, SP				
  0x44b67b		c3			RET					
  0x44b67c		c644244801		MOVB $0x1, 0x48(SP)			
  0x44b681		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b686		4883c430		ADDQ $0x30, SP				
  0x44b68a		c3			RET					
  0x44b68b		e8e08effff		CALL runtime.morestack_noctxt(SB)	
  0x44b690		e95bffffff		JMP type..eq.[4]string(SB)		

TEXT type..hash.[65]runtime.sigTabT(SB) <autogenerated>

  0x44b6a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b6a9		483b6110		CMPQ 0x10(CX), SP			
  0x44b6ad		7659			JBE 0x44b708				
  0x44b6af		4883ec28		SUBQ $0x28, SP				
  0x44b6b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b6b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b6bd		31c0			XORL AX, AX				
  0x44b6bf		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b6c4		eb2d			JMP 0x44b6f3				
  0x44b6c6		4889442418		MOVQ AX, 0x18(SP)			
  0x44b6cb		488d1440		LEAQ 0(AX)(AX*2), DX			
  0x44b6cf		488b5c2430		MOVQ 0x30(SP), BX			
  0x44b6d4		488d14d3		LEAQ 0(BX)(DX*8), DX			
  0x44b6d8		48891424		MOVQ DX, 0(SP)				
  0x44b6dc		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b6e1		e89aefffff		CALL type..hash.runtime.sigTabT(SB)	
  0x44b6e6		488b4c2410		MOVQ 0x10(SP), CX			
  0x44b6eb		488b442418		MOVQ 0x18(SP), AX			
  0x44b6f0		48ffc0			INCQ AX					
  0x44b6f3		4883f841		CMPQ $0x41, AX				
  0x44b6f7		7ccd			JL 0x44b6c6				
  0x44b6f9		48894c2440		MOVQ CX, 0x40(SP)			
  0x44b6fe		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b703		4883c428		ADDQ $0x28, SP				
  0x44b707		c3			RET					
  0x44b708		e8638effff		CALL runtime.morestack_noctxt(SB)	
  0x44b70d		eb91			JMP type..hash.[65]runtime.sigTabT(SB)	

TEXT type..eq.[65]runtime.sigTabT(SB) <autogenerated>

  0x44b710		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b719		483b6110		CMPQ 0x10(CX), SP			
  0x44b71d		0f8691000000		JBE 0x44b7b4				
  0x44b723		4883ec30		SUBQ $0x30, SP				
  0x44b727		48896c2428		MOVQ BP, 0x28(SP)			
  0x44b72c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44b731		31c0			XORL AX, AX				
  0x44b733		eb09			JMP 0x44b73e				
  0x44b735		488b4c2420		MOVQ 0x20(SP), CX			
  0x44b73a		488d4101		LEAQ 0x1(CX), AX			
  0x44b73e		4883f841		CMPQ $0x41, AX				
  0x44b742		7d61			JGE 0x44b7a5				
  0x44b744		488d0c40		LEAQ 0(AX)(AX*2), CX			
  0x44b748		488b542440		MOVQ 0x40(SP), DX			
  0x44b74d		8b1cca			MOVL 0(DX)(CX*8), BX			
  0x44b750		488b742438		MOVQ 0x38(SP), SI			
  0x44b755		8b3cce			MOVL 0(SI)(CX*8), DI			
  0x44b758		39df			CMPL BX, DI				
  0x44b75a		753a			JNE 0x44b796				
  0x44b75c		488b5cce08		MOVQ 0x8(SI)(CX*8), BX			
  0x44b761		488b7cce10		MOVQ 0x10(SI)(CX*8), DI			
  0x44b766		4c8b44ca08		MOVQ 0x8(DX)(CX*8), R8			
  0x44b76b		488b4cca10		MOVQ 0x10(DX)(CX*8), CX			
  0x44b770		4839cf			CMPQ CX, DI				
  0x44b773		7521			JNE 0x44b796				
  0x44b775		4889442420		MOVQ AX, 0x20(SP)			
  0x44b77a		48891c24		MOVQ BX, 0(SP)				
  0x44b77e		4c89442408		MOVQ R8, 0x8(SP)			
  0x44b783		48897c2410		MOVQ DI, 0x10(SP)			
  0x44b788		e8b3abffff		CALL runtime.memequal(SB)		
  0x44b78d		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b792		84c0			TESTL AL, AL				
  0x44b794		759f			JNE 0x44b735				
  0x44b796		c644244800		MOVB $0x0, 0x48(SP)			
  0x44b79b		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b7a0		4883c430		ADDQ $0x30, SP				
  0x44b7a4		c3			RET					
  0x44b7a5		c644244801		MOVB $0x1, 0x48(SP)			
  0x44b7aa		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b7af		4883c430		ADDQ $0x30, SP				
  0x44b7b3		c3			RET					
  0x44b7b4		e8b78dffff		CALL runtime.morestack_noctxt(SB)	
  0x44b7b9		e952ffffff		JMP type..eq.[65]runtime.sigTabT(SB)	

TEXT type..hash.[6]string(SB) <autogenerated>

  0x44b7c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b7c9		483b6110		CMPQ 0x10(CX), SP			
  0x44b7cd		7658			JBE 0x44b827				
  0x44b7cf		4883ec28		SUBQ $0x28, SP				
  0x44b7d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b7d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b7dd		31c0			XORL AX, AX				
  0x44b7df		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b7e4		eb2c			JMP 0x44b812				
  0x44b7e6		4889442418		MOVQ AX, 0x18(SP)			
  0x44b7eb		48c1e004		SHLQ $0x4, AX				
  0x44b7ef		488b5c2430		MOVQ 0x30(SP), BX			
  0x44b7f4		4801d8			ADDQ BX, AX				
  0x44b7f7		48890424		MOVQ AX, 0(SP)				
  0x44b7fb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b800		e87b59fbff		CALL runtime.strhash(SB)		
  0x44b805		488b4c2410		MOVQ 0x10(SP), CX			
  0x44b80a		488b442418		MOVQ 0x18(SP), AX			
  0x44b80f		48ffc0			INCQ AX					
  0x44b812		4883f806		CMPQ $0x6, AX				
  0x44b816		7cce			JL 0x44b7e6				
  0x44b818		48894c2440		MOVQ CX, 0x40(SP)			
  0x44b81d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b822		4883c428		ADDQ $0x28, SP				
  0x44b826		c3			RET					
  0x44b827		e8448dffff		CALL runtime.morestack_noctxt(SB)	
  0x44b82c		eb92			JMP type..hash.[6]string(SB)		

TEXT type..eq.[6]string(SB) <autogenerated>

  0x44b830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b839		483b6110		CMPQ 0x10(CX), SP			
  0x44b83d		0f8688000000		JBE 0x44b8cb				
  0x44b843		4883ec30		SUBQ $0x30, SP				
  0x44b847		48896c2428		MOVQ BP, 0x28(SP)			
  0x44b84c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44b851		31c0			XORL AX, AX				
  0x44b853		eb09			JMP 0x44b85e				
  0x44b855		488b4c2420		MOVQ 0x20(SP), CX			
  0x44b85a		488d4101		LEAQ 0x1(CX), AX			
  0x44b85e		4883f806		CMPQ $0x6, AX				
  0x44b862		7d58			JGE 0x44b8bc				
  0x44b864		4889c1			MOVQ AX, CX				
  0x44b867		48c1e004		SHLQ $0x4, AX				
  0x44b86b		488b542440		MOVQ 0x40(SP), DX			
  0x44b870		488b5c1008		MOVQ 0x8(AX)(DX*1), BX			
  0x44b875		488b3410		MOVQ 0(AX)(DX*1), SI			
  0x44b879		488b7c2438		MOVQ 0x38(SP), DI			
  0x44b87e		4c8b0438		MOVQ 0(AX)(DI*1), R8			
  0x44b882		488b443808		MOVQ 0x8(AX)(DI*1), AX			
  0x44b887		4839d8			CMPQ BX, AX				
  0x44b88a		7521			JNE 0x44b8ad				
  0x44b88c		48894c2420		MOVQ CX, 0x20(SP)			
  0x44b891		4c890424		MOVQ R8, 0(SP)				
  0x44b895		4889742408		MOVQ SI, 0x8(SP)			
  0x44b89a		4889442410		MOVQ AX, 0x10(SP)			
  0x44b89f		e89caaffff		CALL runtime.memequal(SB)		
  0x44b8a4		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b8a9		84c0			TESTL AL, AL				
  0x44b8ab		75a8			JNE 0x44b855				
  0x44b8ad		c644244800		MOVB $0x0, 0x48(SP)			
  0x44b8b2		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b8b7		4883c430		ADDQ $0x30, SP				
  0x44b8bb		c3			RET					
  0x44b8bc		c644244801		MOVB $0x1, 0x48(SP)			
  0x44b8c1		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b8c6		4883c430		ADDQ $0x30, SP				
  0x44b8ca		c3			RET					
  0x44b8cb		e8a08cffff		CALL runtime.morestack_noctxt(SB)	
  0x44b8d0		e95bffffff		JMP type..eq.[6]string(SB)		

TEXT type..hash.[9]string(SB) <autogenerated>

  0x44b8e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b8e9		483b6110		CMPQ 0x10(CX), SP			
  0x44b8ed		7658			JBE 0x44b947				
  0x44b8ef		4883ec28		SUBQ $0x28, SP				
  0x44b8f3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b8f8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b8fd		31c0			XORL AX, AX				
  0x44b8ff		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b904		eb2c			JMP 0x44b932				
  0x44b906		4889442418		MOVQ AX, 0x18(SP)			
  0x44b90b		48c1e004		SHLQ $0x4, AX				
  0x44b90f		488b5c2430		MOVQ 0x30(SP), BX			
  0x44b914		4801d8			ADDQ BX, AX				
  0x44b917		48890424		MOVQ AX, 0(SP)				
  0x44b91b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b920		e85b58fbff		CALL runtime.strhash(SB)		
  0x44b925		488b4c2410		MOVQ 0x10(SP), CX			
  0x44b92a		488b442418		MOVQ 0x18(SP), AX			
  0x44b92f		48ffc0			INCQ AX					
  0x44b932		4883f809		CMPQ $0x9, AX				
  0x44b936		7cce			JL 0x44b906				
  0x44b938		48894c2440		MOVQ CX, 0x40(SP)			
  0x44b93d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b942		4883c428		ADDQ $0x28, SP				
  0x44b946		c3			RET					
  0x44b947		e8248cffff		CALL runtime.morestack_noctxt(SB)	
  0x44b94c		eb92			JMP type..hash.[9]string(SB)		

TEXT type..eq.[9]string(SB) <autogenerated>

  0x44b950		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b959		483b6110		CMPQ 0x10(CX), SP			
  0x44b95d		0f8688000000		JBE 0x44b9eb				
  0x44b963		4883ec30		SUBQ $0x30, SP				
  0x44b967		48896c2428		MOVQ BP, 0x28(SP)			
  0x44b96c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44b971		31c0			XORL AX, AX				
  0x44b973		eb09			JMP 0x44b97e				
  0x44b975		488b4c2420		MOVQ 0x20(SP), CX			
  0x44b97a		488d4101		LEAQ 0x1(CX), AX			
  0x44b97e		4883f809		CMPQ $0x9, AX				
  0x44b982		7d58			JGE 0x44b9dc				
  0x44b984		4889c1			MOVQ AX, CX				
  0x44b987		48c1e004		SHLQ $0x4, AX				
  0x44b98b		488b542440		MOVQ 0x40(SP), DX			
  0x44b990		488b5c1008		MOVQ 0x8(AX)(DX*1), BX			
  0x44b995		488b3410		MOVQ 0(AX)(DX*1), SI			
  0x44b999		488b7c2438		MOVQ 0x38(SP), DI			
  0x44b99e		4c8b0438		MOVQ 0(AX)(DI*1), R8			
  0x44b9a2		488b443808		MOVQ 0x8(AX)(DI*1), AX			
  0x44b9a7		4839d8			CMPQ BX, AX				
  0x44b9aa		7521			JNE 0x44b9cd				
  0x44b9ac		48894c2420		MOVQ CX, 0x20(SP)			
  0x44b9b1		4c890424		MOVQ R8, 0(SP)				
  0x44b9b5		4889742408		MOVQ SI, 0x8(SP)			
  0x44b9ba		4889442410		MOVQ AX, 0x10(SP)			
  0x44b9bf		e87ca9ffff		CALL runtime.memequal(SB)		
  0x44b9c4		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b9c9		84c0			TESTL AL, AL				
  0x44b9cb		75a8			JNE 0x44b975				
  0x44b9cd		c644244800		MOVB $0x0, 0x48(SP)			
  0x44b9d2		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b9d7		4883c430		ADDQ $0x30, SP				
  0x44b9db		c3			RET					
  0x44b9dc		c644244801		MOVB $0x1, 0x48(SP)			
  0x44b9e1		488b6c2428		MOVQ 0x28(SP), BP			
  0x44b9e6		4883c430		ADDQ $0x30, SP				
  0x44b9ea		c3			RET					
  0x44b9eb		e8808bffff		CALL runtime.morestack_noctxt(SB)	
  0x44b9f0		e95bffffff		JMP type..eq.[9]string(SB)		

TEXT type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(SB) <autogenerated>

  0x44ba00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX								
  0x44ba09		483b6110		CMPQ 0x10(CX), SP								
  0x44ba0d		7643			JBE 0x44ba52									
  0x44ba0f		4883ec28		SUBQ $0x28, SP									
  0x44ba13		48896c2420		MOVQ BP, 0x20(SP)								
  0x44ba18		488d6c2420		LEAQ 0x20(SP), BP								
  0x44ba1d		488b442430		MOVQ 0x30(SP), AX								
  0x44ba22		48890424		MOVQ AX, 0(SP)									
  0x44ba26		488b442438		MOVQ 0x38(SP), AX								
  0x44ba2b		4889442408		MOVQ AX, 0x8(SP)								
  0x44ba30		48c744241005000000	MOVQ $0x5, 0x10(SP)								
  0x44ba39		e8d2a0fbff		CALL runtime.memhash(SB)							
  0x44ba3e		488b442418		MOVQ 0x18(SP), AX								
  0x44ba43		4889442440		MOVQ AX, 0x40(SP)								
  0x44ba48		488b6c2420		MOVQ 0x20(SP), BP								
  0x44ba4d		4883c428		ADDQ $0x28, SP									
  0x44ba51		c3			RET										
  0x44ba52		e8198bffff		CALL runtime.morestack_noctxt(SB)						
  0x44ba57		eba7			JMP type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(SB)	

TEXT type..eq.struct { runtime.cycle uint32; runtime.flushed bool }(SB) <autogenerated>

  0x44ba60		488b442408		MOVQ 0x8(SP), AX	
  0x44ba65		8b08			MOVL 0(AX), CX		
  0x44ba67		488b542410		MOVQ 0x10(SP), DX	
  0x44ba6c		8b1a			MOVL 0(DX), BX		
  0x44ba6e		39d9			CMPL BX, CX		
  0x44ba70		7512			JNE 0x44ba84		
  0x44ba72		0fb64004		MOVZX 0x4(AX), AX	
  0x44ba76		0fb64a04		MOVZX 0x4(DX), CX	
  0x44ba7a		38c8			CMPL CL, AL		
  0x44ba7c		0f94c0			SETE AL			
  0x44ba7f		88442418		MOVB AL, 0x18(SP)	
  0x44ba83		c3			RET			
  0x44ba84		31c0			XORL AX, AX		
  0x44ba86		ebf7			JMP 0x44ba7f		

TEXT type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB) <autogenerated>

  0x44ba90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX															
  0x44ba99		483b6110		CMPQ 0x10(CX), SP															
  0x44ba9d		7668			JBE 0x44bb07																
  0x44ba9f		4883ec28		SUBQ $0x28, SP																
  0x44baa3		48896c2420		MOVQ BP, 0x20(SP)															
  0x44baa8		488d6c2420		LEAQ 0x20(SP), BP															
  0x44baad		488b442430		MOVQ 0x30(SP), AX															
  0x44bab2		48890424		MOVQ AX, 0(SP)																
  0x44bab6		488b4c2438		MOVQ 0x38(SP), CX															
  0x44babb		48894c2408		MOVQ CX, 0x8(SP)															
  0x44bac0		48c744241006000000	MOVQ $0x6, 0x10(SP)															
  0x44bac9		e842a0fbff		CALL runtime.memhash(SB)														
  0x44bace		488b442418		MOVQ 0x18(SP), AX															
  0x44bad3		488b4c2430		MOVQ 0x30(SP), CX															
  0x44bad8		4883c108		ADDQ $0x8, CX																
  0x44badc		48890c24		MOVQ CX, 0(SP)																
  0x44bae0		4889442408		MOVQ AX, 0x8(SP)															
  0x44bae5		48c744241008000000	MOVQ $0x8, 0x10(SP)															
  0x44baee		e81da0fbff		CALL runtime.memhash(SB)														
  0x44baf3		488b442418		MOVQ 0x18(SP), AX															
  0x44baf8		4889442440		MOVQ AX, 0x40(SP)															
  0x44bafd		488b6c2420		MOVQ 0x20(SP), BP															
  0x44bb02		4883c428		ADDQ $0x28, SP																
  0x44bb06		c3			RET																	
  0x44bb07		e8648affff		CALL runtime.morestack_noctxt(SB)													
  0x44bb0c		eb82			JMP type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB)	

TEXT type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB) <autogenerated>

  0x44bb10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX															
  0x44bb19		483b6110		CMPQ 0x10(CX), SP															
  0x44bb1d		7662			JBE 0x44bb81																
  0x44bb1f		4883ec28		SUBQ $0x28, SP																
  0x44bb23		48896c2420		MOVQ BP, 0x20(SP)															
  0x44bb28		488d6c2420		LEAQ 0x20(SP), BP															
  0x44bb2d		488b442438		MOVQ 0x38(SP), AX															
  0x44bb32		4889442408		MOVQ AX, 0x8(SP)															
  0x44bb37		488b4c2430		MOVQ 0x30(SP), CX															
  0x44bb3c		48890c24		MOVQ CX, 0(SP)																
  0x44bb40		48c744241006000000	MOVQ $0x6, 0x10(SP)															
  0x44bb49		e8f2a7ffff		CALL runtime.memequal(SB)														
  0x44bb4e		0fb6442418		MOVZX 0x18(SP), AX															
  0x44bb53		84c0			TESTL AL, AL																
  0x44bb55		7426			JE 0x44bb7d																
  0x44bb57		488b442430		MOVQ 0x30(SP), AX															
  0x44bb5c		488b4008		MOVQ 0x8(AX), AX															
  0x44bb60		488b4c2438		MOVQ 0x38(SP), CX															
  0x44bb65		488b4908		MOVQ 0x8(CX), CX															
  0x44bb69		4839c8			CMPQ CX, AX																
  0x44bb6c		0f94c0			SETE AL																	
  0x44bb6f		88442440		MOVB AL, 0x40(SP)															
  0x44bb73		488b6c2420		MOVQ 0x20(SP), BP															
  0x44bb78		4883c428		ADDQ $0x28, SP																
  0x44bb7c		c3			RET																	
  0x44bb7d		31c0			XORL AX, AX																
  0x44bb7f		ebee			JMP 0x44bb6f																
  0x44bb81		e8ea89ffff		CALL runtime.morestack_noctxt(SB)													
  0x44bb86		eb88			JMP type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB)	

TEXT type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB) <autogenerated>

  0x44bb90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																																																																																																																																																																										
  0x44bb99		483b6110		CMPQ 0x10(CX), SP																																																																																																																																																																										
  0x44bb9d		0f8683010000		JBE 0x44bd26																																																																																																																																																																											
  0x44bba3		4883ec28		SUBQ $0x28, SP																																																																																																																																																																											
  0x44bba7		48896c2420		MOVQ BP, 0x20(SP)																																																																																																																																																																										
  0x44bbac		488d6c2420		LEAQ 0x20(SP), BP																																																																																																																																																																										
  0x44bbb1		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																																										
  0x44bbb6		48890424		MOVQ AX, 0(SP)																																																																																																																																																																											
  0x44bbba		488b4c2438		MOVQ 0x38(SP), CX																																																																																																																																																																										
  0x44bbbf		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																																										
  0x44bbc4		48c744241078000000	MOVQ $0x78, 0x10(SP)																																																																																																																																																																										
  0x44bbcd		e83e9ffbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bbd2		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bbd7		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bbdc		488d9180000000		LEAQ 0x80(CX), DX																																																																																																																																																																										
  0x44bbe3		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bbe7		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bbec		48c744241014000000	MOVQ $0x14, 0x10(SP)																																																																																																																																																																										
  0x44bbf5		e8169ffbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bbfa		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bbff		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bc04		488d9198000000		LEAQ 0x98(CX), DX																																																																																																																																																																										
  0x44bc0b		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bc0f		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bc14		48c744241019000000	MOVQ $0x19, 0x10(SP)																																																																																																																																																																										
  0x44bc1d		e8ee9efbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bc22		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bc27		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bc2c		488d91b8000000		LEAQ 0xb8(CX), DX																																																																																																																																																																										
  0x44bc33		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bc37		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bc3c		48c744241029000000	MOVQ $0x29, 0x10(SP)																																																																																																																																																																										
  0x44bc45		e8c69efbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bc4a		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bc4f		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bc54		488d91e4000000		LEAQ 0xe4(CX), DX																																																																																																																																																																										
  0x44bc5b		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bc5f		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bc64		48c744241008000000	MOVQ $0x8, 0x10(SP)																																																																																																																																																																										
  0x44bc6d		e89e9efbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bc72		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bc77		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bc7c		488d91f0000000		LEAQ 0xf0(CX), DX																																																																																																																																																																										
  0x44bc83		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bc87		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bc8c		48c74424100c000000	MOVQ $0xc, 0x10(SP)																																																																																																																																																																										
  0x44bc95		e8769efbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bc9a		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bc9f		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bca4		488d9100010000		LEAQ 0x100(CX), DX																																																																																																																																																																										
  0x44bcab		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bcaf		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bcb4		48c744241009000000	MOVQ $0x9, 0x10(SP)																																																																																																																																																																										
  0x44bcbd		e84e9efbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bcc2		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bcc7		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bccc		488d9110010000		LEAQ 0x110(CX), DX																																																																																																																																																																										
  0x44bcd3		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bcd7		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bcdc		48c744241044000000	MOVQ $0x44, 0x10(SP)																																																																																																																																																																										
  0x44bce5		e8269efbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bcea		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bcef		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bcf4		4881c158010000		ADDQ $0x158, CX																																																																																																																																																																											
  0x44bcfb		48890c24		MOVQ CX, 0(SP)																																																																																																																																																																											
  0x44bcff		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bd04		48c744241050000000	MOVQ $0x50, 0x10(SP)																																																																																																																																																																										
  0x44bd0d		e8fe9dfbff		CALL runtime.memhash(SB)																																																																																																																																																																									
  0x44bd12		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																																										
  0x44bd17		4889442440		MOVQ AX, 0x40(SP)																																																																																																																																																																										
  0x44bd1c		488b6c2420		MOVQ 0x20(SP), BP																																																																																																																																																																										
  0x44bd21		4883c428		ADDQ $0x28, SP																																																																																																																																																																											
  0x44bd25		c3			RET																																																																																																																																																																												
  0x44bd26		e84588ffff		CALL runtime.morestack_noctxt(SB)																																																																																																																																																																								
  0x44bd2b		e960feffff		JMP type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB)	

TEXT type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB) <autogenerated>

  0x44bd30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																																																																																																																																																																										
  0x44bd39		483b6110		CMPQ 0x10(CX), SP																																																																																																																																																																										
  0x44bd3d		0f8630020000		JBE 0x44bf73																																																																																																																																																																											
  0x44bd43		4883ec28		SUBQ $0x28, SP																																																																																																																																																																											
  0x44bd47		48896c2420		MOVQ BP, 0x20(SP)																																																																																																																																																																										
  0x44bd4c		488d6c2420		LEAQ 0x20(SP), BP																																																																																																																																																																										
  0x44bd51		488b442438		MOVQ 0x38(SP), AX																																																																																																																																																																										
  0x44bd56		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																																										
  0x44bd5b		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bd60		48890c24		MOVQ CX, 0(SP)																																																																																																																																																																											
  0x44bd64		48c744241078000000	MOVQ $0x78, 0x10(SP)																																																																																																																																																																										
  0x44bd6d		e8cea5ffff		CALL runtime.memequal(SB)																																																																																																																																																																									
  0x44bd72		0fb6442418		MOVZX 0x18(SP), AX																																																																																																																																																																										
  0x44bd77		84c0			TESTL AL, AL																																																																																																																																																																											
  0x44bd79		0f85bb010000		JNE 0x44bf3a																																																																																																																																																																											
  0x44bd7f		31c0			XORL AX, AX																																																																																																																																																																											
  0x44bd81		84c0			TESTL AL, AL																																																																																																																																																																											
  0x44bd83		0f8578010000		JNE 0x44bf01																																																																																																																																																																											
  0x44bd89		31c0			XORL AX, AX																																																																																																																																																																											
  0x44bd8b		84c0			TESTL AL, AL																																																																																																																																																																											
  0x44bd8d		0f8535010000		JNE 0x44bec8																																																																																																																																																																											
  0x44bd93		31c0			XORL AX, AX																																																																																																																																																																											
  0x44bd95		84c0			TESTL AL, AL																																																																																																																																																																											
  0x44bd97		0f841a010000		JE 0x44beb7																																																																																																																																																																											
  0x44bd9d		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																																										
  0x44bda2		8b88e4000000		MOVL 0xe4(AX), CX																																																																																																																																																																										
  0x44bda8		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																																										
  0x44bdad		8b9ae4000000		MOVL 0xe4(DX), BX																																																																																																																																																																										
  0x44bdb3		39cb			CMPL CX, BX																																																																																																																																																																											
  0x44bdb5		0f85f5000000		JNE 0x44beb0																																																																																																																																																																											
  0x44bdbb		8b88e8000000		MOVL 0xe8(AX), CX																																																																																																																																																																										
  0x44bdc1		8b9ae8000000		MOVL 0xe8(DX), BX																																																																																																																																																																										
  0x44bdc7		39cb			CMPL CX, BX																																																																																																																																																																											
  0x44bdc9		0f85da000000		JNE 0x44bea9																																																																																																																																																																											
  0x44bdcf		488b8af0000000		MOVQ 0xf0(DX), CX																																																																																																																																																																										
  0x44bdd6		488b98f0000000		MOVQ 0xf0(AX), BX																																																																																																																																																																										
  0x44bddd		4839cb			CMPQ CX, BX																																																																																																																																																																											
  0x44bde0		0f85bc000000		JNE 0x44bea2																																																																																																																																																																											
  0x44bde6		8b88f8000000		MOVL 0xf8(AX), CX																																																																																																																																																																										
  0x44bdec		8b9af8000000		MOVL 0xf8(DX), BX																																																																																																																																																																										
  0x44bdf2		39cb			CMPL CX, BX																																																																																																																																																																											
  0x44bdf4		0f85a4000000		JNE 0x44be9e																																																																																																																																																																											
  0x44bdfa		488b8800010000		MOVQ 0x100(AX), CX																																																																																																																																																																										
  0x44be01		488b9a00010000		MOVQ 0x100(DX), BX																																																																																																																																																																										
  0x44be08		4839d9			CMPQ BX, CX																																																																																																																																																																											
  0x44be0b		0f8589000000		JNE 0x44be9a																																																																																																																																																																											
  0x44be11		0fb68808010000		MOVZX 0x108(AX), CX																																																																																																																																																																										
  0x44be18		0fb69a08010000		MOVZX 0x108(DX), BX																																																																																																																																																																										
  0x44be1f		38d9			CMPL BL, CL																																																																																																																																																																											
  0x44be21		7441			JE 0x44be64																																																																																																																																																																											
  0x44be23		31c9			XORL CX, CX																																																																																																																																																																											
  0x44be25		84c9			TESTL CL, CL																																																																																																																																																																											
  0x44be27		7510			JNE 0x44be39																																																																																																																																																																											
  0x44be29		31c0			XORL AX, AX																																																																																																																																																																											
  0x44be2b		88442440		MOVB AL, 0x40(SP)																																																																																																																																																																										
  0x44be2f		488b6c2420		MOVQ 0x20(SP), BP																																																																																																																																																																										
  0x44be34		4883c428		ADDQ $0x28, SP																																																																																																																																																																											
  0x44be38		c3			RET																																																																																																																																																																												
  0x44be39		488d8a58010000		LEAQ 0x158(DX), CX																																																																																																																																																																										
  0x44be40		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																																										
  0x44be45		480558010000		ADDQ $0x158, AX																																																																																																																																																																											
  0x44be4b		48890424		MOVQ AX, 0(SP)																																																																																																																																																																											
  0x44be4f		48c744241050000000	MOVQ $0x50, 0x10(SP)																																																																																																																																																																										
  0x44be58		e8e3a4ffff		CALL runtime.memequal(SB)																																																																																																																																																																									
  0x44be5d		0fb6442418		MOVZX 0x18(SP), AX																																																																																																																																																																										
  0x44be62		ebc7			JMP 0x44be2b																																																																																																																																																																											
  0x44be64		488d8a10010000		LEAQ 0x110(DX), CX																																																																																																																																																																										
  0x44be6b		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																																										
  0x44be70		488d8810010000		LEAQ 0x110(AX), CX																																																																																																																																																																										
  0x44be77		48890c24		MOVQ CX, 0(SP)																																																																																																																																																																											
  0x44be7b		48c744241044000000	MOVQ $0x44, 0x10(SP)																																																																																																																																																																										
  0x44be84		e8b7a4ffff		CALL runtime.memequal(SB)																																																																																																																																																																									
  0x44be89		0fb64c2418		MOVZX 0x18(SP), CX																																																																																																																																																																										
  0x44be8e		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																																										
  0x44be93		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																																										
  0x44be98		eb8b			JMP 0x44be25																																																																																																																																																																											
  0x44be9a		31c9			XORL CX, CX																																																																																																																																																																											
  0x44be9c		eb87			JMP 0x44be25																																																																																																																																																																											
  0x44be9e		31c9			XORL CX, CX																																																																																																																																																																											
  0x44bea0		eb83			JMP 0x44be25																																																																																																																																																																											
  0x44bea2		31c9			XORL CX, CX																																																																																																																																																																											
  0x44bea4		e97cffffff		JMP 0x44be25																																																																																																																																																																											
  0x44bea9		31c9			XORL CX, CX																																																																																																																																																																											
  0x44beab		e975ffffff		JMP 0x44be25																																																																																																																																																																											
  0x44beb0		31c9			XORL CX, CX																																																																																																																																																																											
  0x44beb2		e96effffff		JMP 0x44be25																																																																																																																																																																											
  0x44beb7		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																																										
  0x44bebc		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																																										
  0x44bec1		31c9			XORL CX, CX																																																																																																																																																																											
  0x44bec3		e95dffffff		JMP 0x44be25																																																																																																																																																																											
  0x44bec8		488b442438		MOVQ 0x38(SP), AX																																																																																																																																																																										
  0x44becd		488d88b8000000		LEAQ 0xb8(AX), CX																																																																																																																																																																										
  0x44bed4		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																																										
  0x44bed9		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bede		488d91b8000000		LEAQ 0xb8(CX), DX																																																																																																																																																																										
  0x44bee5		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bee9		48c744241029000000	MOVQ $0x29, 0x10(SP)																																																																																																																																																																										
  0x44bef2		e849a4ffff		CALL runtime.memequal(SB)																																																																																																																																																																									
  0x44bef7		0fb6442418		MOVZX 0x18(SP), AX																																																																																																																																																																										
  0x44befc		e994feffff		JMP 0x44bd95																																																																																																																																																																											
  0x44bf01		488b442438		MOVQ 0x38(SP), AX																																																																																																																																																																										
  0x44bf06		488d8898000000		LEAQ 0x98(AX), CX																																																																																																																																																																										
  0x44bf0d		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																																										
  0x44bf12		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bf17		488d9198000000		LEAQ 0x98(CX), DX																																																																																																																																																																										
  0x44bf1e		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bf22		48c744241019000000	MOVQ $0x19, 0x10(SP)																																																																																																																																																																										
  0x44bf2b		e810a4ffff		CALL runtime.memequal(SB)																																																																																																																																																																									
  0x44bf30		0fb6442418		MOVZX 0x18(SP), AX																																																																																																																																																																										
  0x44bf35		e951feffff		JMP 0x44bd8b																																																																																																																																																																											
  0x44bf3a		488b442438		MOVQ 0x38(SP), AX																																																																																																																																																																										
  0x44bf3f		488d8880000000		LEAQ 0x80(AX), CX																																																																																																																																																																										
  0x44bf46		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																																										
  0x44bf4b		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																																										
  0x44bf50		488d9180000000		LEAQ 0x80(CX), DX																																																																																																																																																																										
  0x44bf57		48891424		MOVQ DX, 0(SP)																																																																																																																																																																											
  0x44bf5b		48c744241014000000	MOVQ $0x14, 0x10(SP)																																																																																																																																																																										
  0x44bf64		e8d7a3ffff		CALL runtime.memequal(SB)																																																																																																																																																																									
  0x44bf69		0fb6442418		MOVZX 0x18(SP), AX																																																																																																																																																																										
  0x44bf6e		e90efeffff		JMP 0x44bd81																																																																																																																																																																											
  0x44bf73		e8f885ffff		CALL runtime.morestack_noctxt(SB)																																																																																																																																																																								
  0x44bf78		e9b3fdffff		JMP type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB)	

TEXT type..hash.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB) <autogenerated>

  0x44bf80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																				
  0x44bf89		483b6110		CMPQ 0x10(CX), SP																				
  0x44bf8d		7668			JBE 0x44bff7																					
  0x44bf8f		4883ec28		SUBQ $0x28, SP																					
  0x44bf93		48896c2420		MOVQ BP, 0x20(SP)																				
  0x44bf98		488d6c2420		LEAQ 0x20(SP), BP																				
  0x44bf9d		488b442430		MOVQ 0x30(SP), AX																				
  0x44bfa2		48890424		MOVQ AX, 0(SP)																					
  0x44bfa6		488b4c2438		MOVQ 0x38(SP), CX																				
  0x44bfab		48894c2408		MOVQ CX, 0x8(SP)																				
  0x44bfb0		48c744241011000000	MOVQ $0x11, 0x10(SP)																				
  0x44bfb9		e8529bfbff		CALL runtime.memhash(SB)																			
  0x44bfbe		488b442418		MOVQ 0x18(SP), AX																				
  0x44bfc3		488b4c2430		MOVQ 0x30(SP), CX																				
  0x44bfc8		4883c118		ADDQ $0x18, CX																					
  0x44bfcc		48890c24		MOVQ CX, 0(SP)																					
  0x44bfd0		4889442408		MOVQ AX, 0x8(SP)																				
  0x44bfd5		48c74424100c000000	MOVQ $0xc, 0x10(SP)																				
  0x44bfde		e82d9bfbff		CALL runtime.memhash(SB)																			
  0x44bfe3		488b442418		MOVQ 0x18(SP), AX																				
  0x44bfe8		4889442440		MOVQ AX, 0x40(SP)																				
  0x44bfed		488b6c2420		MOVQ 0x20(SP), BP																				
  0x44bff2		4883c428		ADDQ $0x28, SP																					
  0x44bff6		c3			RET																						
  0x44bff7		e87485ffff		CALL runtime.morestack_noctxt(SB)																		
  0x44bffc		eb82			JMP type..hash.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB)	

TEXT type..eq.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB) <autogenerated>

  0x44c000		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																				
  0x44c009		483b6110		CMPQ 0x10(CX), SP																				
  0x44c00d		7670			JBE 0x44c07f																					
  0x44c00f		4883ec28		SUBQ $0x28, SP																					
  0x44c013		48896c2420		MOVQ BP, 0x20(SP)																				
  0x44c018		488d6c2420		LEAQ 0x20(SP), BP																				
  0x44c01d		488b442438		MOVQ 0x38(SP), AX																				
  0x44c022		4889442408		MOVQ AX, 0x8(SP)																				
  0x44c027		488b4c2430		MOVQ 0x30(SP), CX																				
  0x44c02c		48890c24		MOVQ CX, 0(SP)																					
  0x44c030		48c744241011000000	MOVQ $0x11, 0x10(SP)																				
  0x44c039		e802a3ffff		CALL runtime.memequal(SB)																			
  0x44c03e		0fb6442418		MOVZX 0x18(SP), AX																				
  0x44c043		84c0			TESTL AL, AL																					
  0x44c045		7434			JE 0x44c07b																					
  0x44c047		488b442438		MOVQ 0x38(SP), AX																				
  0x44c04c		488b4818		MOVQ 0x18(AX), CX																				
  0x44c050		488b542430		MOVQ 0x30(SP), DX																				
  0x44c055		488b5a18		MOVQ 0x18(DX), BX																				
  0x44c059		4839cb			CMPQ CX, BX																					
  0x44c05c		7519			JNE 0x44c077																					
  0x44c05e		8b4a20			MOVL 0x20(DX), CX																				
  0x44c061		8b4020			MOVL 0x20(AX), AX																				
  0x44c064		39c1			CMPL AX, CX																					
  0x44c066		0f94c0			SETE AL																						
  0x44c069		88442440		MOVB AL, 0x40(SP)																				
  0x44c06d		488b6c2420		MOVQ 0x20(SP), BP																				
  0x44c072		4883c428		ADDQ $0x28, SP																					
  0x44c076		c3			RET																						
  0x44c077		31c0			XORL AX, AX																					
  0x44c079		ebee			JMP 0x44c069																					
  0x44c07b		31c0			XORL AX, AX																					
  0x44c07d		ebea			JMP 0x44c069																					
  0x44c07f		e8ec84ffff		CALL runtime.morestack_noctxt(SB)																		
  0x44c084		e977ffffff		JMP type..eq.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB)	

TEXT type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB) <autogenerated>

  0x44c090		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																											
  0x44c099		483b6110		CMPQ 0x10(CX), SP																											
  0x44c09d		7643			JBE 0x44c0e2																												
  0x44c09f		4883ec28		SUBQ $0x28, SP																												
  0x44c0a3		48896c2420		MOVQ BP, 0x20(SP)																											
  0x44c0a8		488d6c2420		LEAQ 0x20(SP), BP																											
  0x44c0ad		488b442430		MOVQ 0x30(SP), AX																											
  0x44c0b2		48890424		MOVQ AX, 0(SP)																												
  0x44c0b6		488b442438		MOVQ 0x38(SP), AX																											
  0x44c0bb		4889442408		MOVQ AX, 0x8(SP)																											
  0x44c0c0		48c744241041000000	MOVQ $0x41, 0x10(SP)																											
  0x44c0c9		e8429afbff		CALL runtime.memhash(SB)																										
  0x44c0ce		488b442418		MOVQ 0x18(SP), AX																											
  0x44c0d3		4889442440		MOVQ AX, 0x40(SP)																											
  0x44c0d8		488b6c2420		MOVQ 0x20(SP), BP																											
  0x44c0dd		4883c428		ADDQ $0x28, SP																												
  0x44c0e1		c3			RET																													
  0x44c0e2		e88984ffff		CALL runtime.morestack_noctxt(SB)																									
  0x44c0e7		eba7			JMP type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB)	

TEXT type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB) <autogenerated>

  0x44c0f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																										
  0x44c0f9		483b6110		CMPQ 0x10(CX), SP																										
  0x44c0fd		7642			JBE 0x44c141																											
  0x44c0ff		4883ec28		SUBQ $0x28, SP																											
  0x44c103		48896c2420		MOVQ BP, 0x20(SP)																										
  0x44c108		488d6c2420		LEAQ 0x20(SP), BP																										
  0x44c10d		488b442438		MOVQ 0x38(SP), AX																										
  0x44c112		4889442408		MOVQ AX, 0x8(SP)																										
  0x44c117		488b442430		MOVQ 0x30(SP), AX																										
  0x44c11c		48890424		MOVQ AX, 0(SP)																											
  0x44c120		48c744241041000000	MOVQ $0x41, 0x10(SP)																										
  0x44c129		e812a2ffff		CALL runtime.memequal(SB)																									
  0x44c12e		0fb6442418		MOVZX 0x18(SP), AX																										
  0x44c133		88442440		MOVB AL, 0x40(SP)																										
  0x44c137		488b6c2420		MOVQ 0x20(SP), BP																										
  0x44c13c		4883c428		ADDQ $0x28, SP																											
  0x44c140		c3			RET																												
  0x44c141		e82a84ffff		CALL runtime.morestack_noctxt(SB)																								
  0x44c146		eba8			JMP type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB)	

TEXT main.det1(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
func det1() int {
  0x44c150		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c159		483b6110		CMPQ 0x10(CX), SP	
  0x44c15d		7670			JBE 0x44c1cf		
  0x44c15f		4883ec28		SUBQ $0x28, SP		
  0x44c163		48896c2420		MOVQ BP, 0x20(SP)	
  0x44c168		488d6c2420		LEAQ 0x20(SP), BP	
  0x44c16d		48c744243000000000	MOVQ $0x0, 0x30(SP)	
	result := 2
  0x44c176		48c744241802000000	MOVQ $0x2, 0x18(SP)	
	}()
  0x44c17f		488d442418		LEAQ 0x18(SP), AX	
  0x44c184		4889442410		MOVQ AX, 0x10(SP)	
	defer func() {
  0x44c189		c7042408000000		MOVL $0x8, 0(SP)		
  0x44c190		488d05a91d0200		LEAQ 0x21da9(IP), AX		
  0x44c197		4889442408		MOVQ AX, 0x8(SP)		
  0x44c19c		e87f3bfdff		CALL runtime.deferproc(SB)	
  0x44c1a1		85c0			TESTL AX, AX			
  0x44c1a3		751a			JNE 0x44c1bf			
	return result
  0x44c1a5		488b442418		MOVQ 0x18(SP), AX		
  0x44c1aa		4889442430		MOVQ AX, 0x30(SP)		
  0x44c1af		90			NOPL				
  0x44c1b0		e84b44fdff		CALL runtime.deferreturn(SB)	
  0x44c1b5		488b6c2420		MOVQ 0x20(SP), BP		
  0x44c1ba		4883c428		ADDQ $0x28, SP			
  0x44c1be		c3			RET				
	defer func() {
  0x44c1bf		90			NOPL				
  0x44c1c0		e83b44fdff		CALL runtime.deferreturn(SB)	
  0x44c1c5		488b6c2420		MOVQ 0x20(SP), BP		
  0x44c1ca		4883c428		ADDQ $0x28, SP			
  0x44c1ce		c3			RET				
func det1() int {
  0x44c1cf		e89c83ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c1d4		e977ffffff		JMP main.det1(SB)			

TEXT main.det2(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
func det2() int {
  0x44c1e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c1e9		483b6110		CMPQ 0x10(CX), SP	
  0x44c1ed		0f8686000000		JBE 0x44c279		
  0x44c1f3		4883ec28		SUBQ $0x28, SP		
  0x44c1f7		48896c2420		MOVQ BP, 0x20(SP)	
  0x44c1fc		488d6c2420		LEAQ 0x20(SP), BP	
  0x44c201		48c744243000000000	MOVQ $0x0, 0x30(SP)	
	result := 2
  0x44c20a		488d050fac0000		LEAQ 0xac0f(IP), AX		
  0x44c211		48890424		MOVQ AX, 0(SP)			
  0x44c215		e806effbff		CALL runtime.newobject(SB)	
  0x44c21a		488b442408		MOVQ 0x8(SP), AX		
  0x44c21f		4889442418		MOVQ AX, 0x18(SP)		
  0x44c224		48c70002000000		MOVQ $0x2, 0(AX)		
	}(&result)
  0x44c22b		4889442410		MOVQ AX, 0x10(SP)	
	defer func(result *int) {
  0x44c230		c7042408000000		MOVL $0x8, 0(SP)		
  0x44c237		488d0d0a1d0200		LEAQ 0x21d0a(IP), CX		
  0x44c23e		48894c2408		MOVQ CX, 0x8(SP)		
  0x44c243		e8d83afdff		CALL runtime.deferproc(SB)	
	}(&result)
  0x44c248		85c0			TESTL AX, AX		
  0x44c24a		751d			JNE 0x44c269		
  0x44c24c		488b442418		MOVQ 0x18(SP), AX	
	return result
  0x44c251		488b00			MOVQ 0(AX), AX			
  0x44c254		4889442430		MOVQ AX, 0x30(SP)		
  0x44c259		90			NOPL				
  0x44c25a		e8a143fdff		CALL runtime.deferreturn(SB)	
  0x44c25f		488b6c2420		MOVQ 0x20(SP), BP		
  0x44c264		4883c428		ADDQ $0x28, SP			
  0x44c268		c3			RET				
	defer func(result *int) {
  0x44c269		90			NOPL				
  0x44c26a		e89143fdff		CALL runtime.deferreturn(SB)	
	}(&result)
  0x44c26f		488b6c2420		MOVQ 0x20(SP), BP	
  0x44c274		4883c428		ADDQ $0x28, SP		
  0x44c278		c3			RET			
func det2() int {
  0x44c279		e8f282ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c27e		e95dffffff		JMP main.det2(SB)			

TEXT main.det3(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
func det3() (result int) {
  0x44c290		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c299		483b6110		CMPQ 0x10(CX), SP	
  0x44c29d		765d			JBE 0x44c2fc		
  0x44c29f		4883ec20		SUBQ $0x20, SP		
  0x44c2a3		48896c2418		MOVQ BP, 0x18(SP)	
  0x44c2a8		488d6c2418		LEAQ 0x18(SP), BP	
	result = 2
  0x44c2ad		48c744242802000000	MOVQ $0x2, 0x28(SP)	
	}()
  0x44c2b6		488d442428		LEAQ 0x28(SP), AX	
  0x44c2bb		4889442410		MOVQ AX, 0x10(SP)	
	defer func() {
  0x44c2c0		c7042408000000		MOVL $0x8, 0(SP)		
  0x44c2c7		488d05821c0200		LEAQ 0x21c82(IP), AX		
  0x44c2ce		4889442408		MOVQ AX, 0x8(SP)		
  0x44c2d3		e8483afdff		CALL runtime.deferproc(SB)	
  0x44c2d8		85c0			TESTL AX, AX			
  0x44c2da		7510			JNE 0x44c2ec			
	return result
  0x44c2dc		90			NOPL				
  0x44c2dd		e81e43fdff		CALL runtime.deferreturn(SB)	
  0x44c2e2		488b6c2418		MOVQ 0x18(SP), BP		
  0x44c2e7		4883c420		ADDQ $0x20, SP			
  0x44c2eb		c3			RET				
	defer func() {
  0x44c2ec		90			NOPL				
  0x44c2ed		e80e43fdff		CALL runtime.deferreturn(SB)	
  0x44c2f2		488b6c2418		MOVQ 0x18(SP), BP		
  0x44c2f7		4883c420		ADDQ $0x20, SP			
  0x44c2fb		c3			RET				
func det3() (result int) {
  0x44c2fc		e86f82ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c301		eb8d			JMP main.det3(SB)			

TEXT main.det4(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
func det4() *int {
  0x44c310		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c319		483b6110		CMPQ 0x10(CX), SP	
  0x44c31d		0f8683000000		JBE 0x44c3a6		
  0x44c323		4883ec28		SUBQ $0x28, SP		
  0x44c327		48896c2420		MOVQ BP, 0x20(SP)	
  0x44c32c		488d6c2420		LEAQ 0x20(SP), BP	
  0x44c331		48c744243000000000	MOVQ $0x0, 0x30(SP)	
	result := 2
  0x44c33a		488d05dfaa0000		LEAQ 0xaadf(IP), AX		
  0x44c341		48890424		MOVQ AX, 0(SP)			
  0x44c345		e8d6edfbff		CALL runtime.newobject(SB)	
  0x44c34a		488b442408		MOVQ 0x8(SP), AX		
  0x44c34f		4889442418		MOVQ AX, 0x18(SP)		
  0x44c354		48c70002000000		MOVQ $0x2, 0(AX)		
	}()
  0x44c35b		4889442410		MOVQ AX, 0x10(SP)	
	defer func() {
  0x44c360		c7042408000000		MOVL $0x8, 0(SP)		
  0x44c367		488d0dea1b0200		LEAQ 0x21bea(IP), CX		
  0x44c36e		48894c2408		MOVQ CX, 0x8(SP)		
  0x44c373		e8a839fdff		CALL runtime.deferproc(SB)	
  0x44c378		85c0			TESTL AX, AX			
  0x44c37a		751a			JNE 0x44c396			
	return &result
  0x44c37c		488b442418		MOVQ 0x18(SP), AX		
  0x44c381		4889442430		MOVQ AX, 0x30(SP)		
  0x44c386		90			NOPL				
  0x44c387		e87442fdff		CALL runtime.deferreturn(SB)	
  0x44c38c		488b6c2420		MOVQ 0x20(SP), BP		
  0x44c391		4883c428		ADDQ $0x28, SP			
  0x44c395		c3			RET				
	defer func() {
  0x44c396		90			NOPL				
  0x44c397		e86442fdff		CALL runtime.deferreturn(SB)	
  0x44c39c		488b6c2420		MOVQ 0x20(SP), BP		
  0x44c3a1		4883c428		ADDQ $0x28, SP			
  0x44c3a5		c3			RET				
func det4() *int {
  0x44c3a6		e8c581ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c3ab		e960ffffff		JMP main.det4(SB)			

TEXT main.main(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
func main() {
  0x44c3b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c3b9		483b6110		CMPQ 0x10(CX), SP	
  0x44c3bd		0f86d1000000		JBE 0x44c494		
  0x44c3c3		4883ec38		SUBQ $0x38, SP		
  0x44c3c7		48896c2430		MOVQ BP, 0x30(SP)	
  0x44c3cc		488d6c2430		LEAQ 0x30(SP), BP	
	a := det1()
  0x44c3d1		e87afdffff		CALL main.det1(SB)	
  0x44c3d6		488b0424		MOVQ 0(SP), AX		
  0x44c3da		4889442418		MOVQ AX, 0x18(SP)	
	b := det2()
  0x44c3df		e8fcfdffff		CALL main.det2(SB)	
  0x44c3e4		488b0424		MOVQ 0(SP), AX		
  0x44c3e8		4889442410		MOVQ AX, 0x10(SP)	
	c := det3()
  0x44c3ed		e89efeffff		CALL main.det3(SB)	
  0x44c3f2		488b0424		MOVQ 0(SP), AX		
  0x44c3f6		4889442408		MOVQ AX, 0x8(SP)	
	d := det4()
  0x44c3fb		e810ffffff		CALL main.det4(SB)	
  0x44c400		488b0424		MOVQ 0(SP), AX		
  0x44c404		4889442428		MOVQ AX, 0x28(SP)	
	println(a)
  0x44c409		e8f256fdff		CALL runtime.printlock(SB)	
  0x44c40e		488b442418		MOVQ 0x18(SP), AX		
  0x44c413		48890424		MOVQ AX, 0(SP)			
  0x44c417		e8645efdff		CALL runtime.printint(SB)	
  0x44c41c		e86f59fdff		CALL runtime.printnl(SB)	
  0x44c421		e85a57fdff		CALL runtime.printunlock(SB)	
	println(b)
  0x44c426		e8d556fdff		CALL runtime.printlock(SB)	
  0x44c42b		488b442410		MOVQ 0x10(SP), AX		
  0x44c430		48890424		MOVQ AX, 0(SP)			
  0x44c434		e8475efdff		CALL runtime.printint(SB)	
  0x44c439		e85259fdff		CALL runtime.printnl(SB)	
  0x44c43e		e83d57fdff		CALL runtime.printunlock(SB)	
	println(c)
  0x44c443		e8b856fdff		CALL runtime.printlock(SB)	
  0x44c448		488b442408		MOVQ 0x8(SP), AX		
  0x44c44d		48890424		MOVQ AX, 0(SP)			
  0x44c451		e82a5efdff		CALL runtime.printint(SB)	
  0x44c456		e83559fdff		CALL runtime.printnl(SB)	
  0x44c45b		e82057fdff		CALL runtime.printunlock(SB)	
  0x44c460		488b442428		MOVQ 0x28(SP), AX		
	println(*d)
  0x44c465		488b00			MOVQ 0(AX), AX			
  0x44c468		4889442420		MOVQ AX, 0x20(SP)		
  0x44c46d		e88e56fdff		CALL runtime.printlock(SB)	
  0x44c472		488b442420		MOVQ 0x20(SP), AX		
  0x44c477		48890424		MOVQ AX, 0(SP)			
  0x44c47b		e8005efdff		CALL runtime.printint(SB)	
  0x44c480		e80b59fdff		CALL runtime.printnl(SB)	
  0x44c485		e8f656fdff		CALL runtime.printunlock(SB)	
}
  0x44c48a		488b6c2430		MOVQ 0x30(SP), BP	
  0x44c48f		4883c438		ADDQ $0x38, SP		
  0x44c493		c3			RET			
func main() {
  0x44c494		e8d780ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c499		e912ffffff		JMP main.main(SB)			

TEXT main.det1.func1(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
	defer func() {
  0x44c4a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c4a9		483b6110		CMPQ 0x10(CX), SP	
  0x44c4ad		7647			JBE 0x44c4f6		
  0x44c4af		4883ec18		SUBQ $0x18, SP		
  0x44c4b3		48896c2410		MOVQ BP, 0x10(SP)	
  0x44c4b8		488d6c2410		LEAQ 0x10(SP), BP	
		println("det1")
  0x44c4bd		e83e56fdff		CALL runtime.printlock(SB)	
  0x44c4c2		488d05ead80100		LEAQ 0x1d8ea(IP), AX		
  0x44c4c9		48890424		MOVQ AX, 0(SP)			
  0x44c4cd		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x44c4d6		e8655ffdff		CALL runtime.printstring(SB)	
  0x44c4db		e8a056fdff		CALL runtime.printunlock(SB)	
	defer func() {
  0x44c4e0		488b442420		MOVQ 0x20(SP), AX	
		result = 1
  0x44c4e5		48c70001000000		MOVQ $0x1, 0(AX)	
	}()
  0x44c4ec		488b6c2410		MOVQ 0x10(SP), BP	
  0x44c4f1		4883c418		ADDQ $0x18, SP		
  0x44c4f5		c3			RET			
	defer func() {
  0x44c4f6		e87580ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c4fb		eba3			JMP main.det1.func1(SB)			

TEXT main.det2.func1(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
	defer func(result *int) {
  0x44c500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c509		483b6110		CMPQ 0x10(CX), SP	
  0x44c50d		7647			JBE 0x44c556		
  0x44c50f		4883ec18		SUBQ $0x18, SP		
  0x44c513		48896c2410		MOVQ BP, 0x10(SP)	
  0x44c518		488d6c2410		LEAQ 0x10(SP), BP	
		println("det2")
  0x44c51d		e8de55fdff		CALL runtime.printlock(SB)	
  0x44c522		488d058fd80100		LEAQ 0x1d88f(IP), AX		
  0x44c529		48890424		MOVQ AX, 0(SP)			
  0x44c52d		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x44c536		e8055ffdff		CALL runtime.printstring(SB)	
  0x44c53b		e84056fdff		CALL runtime.printunlock(SB)	
	defer func(result *int) {
  0x44c540		488b442420		MOVQ 0x20(SP), AX	
		*result = 1
  0x44c545		48c70001000000		MOVQ $0x1, 0(AX)	
	}(&result)
  0x44c54c		488b6c2410		MOVQ 0x10(SP), BP	
  0x44c551		4883c418		ADDQ $0x18, SP		
  0x44c555		c3			RET			
	defer func(result *int) {
  0x44c556		e81580ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c55b		eba3			JMP main.det2.func1(SB)			

TEXT main.det3.func1(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
	defer func() {
  0x44c560		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c569		483b6110		CMPQ 0x10(CX), SP	
  0x44c56d		7647			JBE 0x44c5b6		
  0x44c56f		4883ec18		SUBQ $0x18, SP		
  0x44c573		48896c2410		MOVQ BP, 0x10(SP)	
  0x44c578		488d6c2410		LEAQ 0x10(SP), BP	
		println("det3")
  0x44c57d		e87e55fdff		CALL runtime.printlock(SB)	
  0x44c582		488d0534d80100		LEAQ 0x1d834(IP), AX		
  0x44c589		48890424		MOVQ AX, 0(SP)			
  0x44c58d		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x44c596		e8a55efdff		CALL runtime.printstring(SB)	
  0x44c59b		e8e055fdff		CALL runtime.printunlock(SB)	
	defer func() {
  0x44c5a0		488b442420		MOVQ 0x20(SP), AX	
		result = 1
  0x44c5a5		48c70001000000		MOVQ $0x1, 0(AX)	
	}()
  0x44c5ac		488b6c2410		MOVQ 0x10(SP), BP	
  0x44c5b1		4883c418		ADDQ $0x18, SP		
  0x44c5b5		c3			RET			
	defer func() {
  0x44c5b6		e8b57fffff		CALL runtime.morestack_noctxt(SB)	
  0x44c5bb		eba3			JMP main.det3.func1(SB)			

TEXT main.det4.func1(SB) /Users/lijiao/Work-Finup/workspace/studys/study-golang/defer/main.go
	defer func() {
  0x44c5c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44c5c9		483b6110		CMPQ 0x10(CX), SP	
  0x44c5cd		7647			JBE 0x44c616		
  0x44c5cf		4883ec18		SUBQ $0x18, SP		
  0x44c5d3		48896c2410		MOVQ BP, 0x10(SP)	
  0x44c5d8		488d6c2410		LEAQ 0x10(SP), BP	
		println("det4")
  0x44c5dd		e81e55fdff		CALL runtime.printlock(SB)	
  0x44c5e2		488d05d9d70100		LEAQ 0x1d7d9(IP), AX		
  0x44c5e9		48890424		MOVQ AX, 0(SP)			
  0x44c5ed		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x44c5f6		e8455efdff		CALL runtime.printstring(SB)	
  0x44c5fb		e88055fdff		CALL runtime.printunlock(SB)	
	defer func() {
  0x44c600		488b442420		MOVQ 0x20(SP), AX	
		result = 1
  0x44c605		48c70001000000		MOVQ $0x1, 0(AX)	
	}()
  0x44c60c		488b6c2410		MOVQ 0x10(SP), BP	
  0x44c611		4883c418		ADDQ $0x18, SP		
  0x44c615		c3			RET			
	defer func() {
  0x44c616		e8557fffff		CALL runtime.morestack_noctxt(SB)	
  0x44c61b		eba3			JMP main.det4.func1(SB)			

TEXT main.init(SB) <autogenerated>

  0x44c620		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c629		483b6110		CMPQ 0x10(CX), SP			
  0x44c62d		7639			JBE 0x44c668				
  0x44c62f		4883ec08		SUBQ $0x8, SP				
  0x44c633		48892c24		MOVQ BP, 0(SP)				
  0x44c637		488d2c24		LEAQ 0(SP), BP				
  0x44c63b		0fb6055e720700		MOVZX main.initdone.(SB), AX		
  0x44c642		3c01			CMPL $0x1, AL				
  0x44c644		7609			JBE 0x44c64f				
  0x44c646		488b2c24		MOVQ 0(SP), BP				
  0x44c64a		4883c408		ADDQ $0x8, SP				
  0x44c64e		c3			RET					
  0x44c64f		7507			JNE 0x44c658				
  0x44c651		e88a36fdff		CALL runtime.throwinit(SB)		
  0x44c656		0f0b			UD2					
  0x44c658		c6054172070002		MOVB $0x2, main.initdone.(SB)		
  0x44c65f		488b2c24		MOVQ 0(SP), BP				
  0x44c663		4883c408		ADDQ $0x8, SP				
  0x44c667		c3			RET					
  0x44c668		e8037fffff		CALL runtime.morestack_noctxt(SB)	
  0x44c66d		ebb1			JMP main.init(SB)			
